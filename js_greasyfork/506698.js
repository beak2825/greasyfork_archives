// ==UserScript==
// @name         WaniKani Stats
// @namespace    http://tampermonkey.net/
// @version      0.18
// @description  Add stats info to WaniKani
// @author       Jigen
// @match        https://www.wanikani.com/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// @downloadURL https://update.greasyfork.org/scripts/506698/WaniKani%20Stats.user.js
// @updateURL https://update.greasyfork.org/scripts/506698/WaniKani%20Stats.meta.js
// ==/UserScript==

(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$2 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  });
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c2) => c2.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s2 = str ? `on${capitalize(str)}` : ``;
    return s2;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber$1 = (val) => {
  const n2 = isString$1(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item2 = value[i2];
      const normalized = isString$1(item2) ? parseStringStyle(item2) : normalizeStyle(item2);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item2) => {
    if (item2) {
      const tmp = item2.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style: style2 } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style2) {
    props.style = normalizeStyle(style2);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2
  );
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i2, l2;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].pause();
        }
      }
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].resume();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      this.effects.length = 0;
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed2 = false) {
  sub.flags |= 8;
  if (isComputed2) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e2 = batchedComputed;
    batchedComputed = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= -9;
      e2 = next;
    }
  }
  let error;
  while (batchedSub) {
    let e2 = batchedSub;
    batchedSub = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= -9;
      if (e2.flags & 1) {
        try {
          ;
          e2.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e2 = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
        removeSub(l2, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e2) {
  const { cleanup } = e2;
  e2.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
        addSub(l2);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
const ARRAY_ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$2(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = /* @__PURE__ */ toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return /* @__PURE__ */ isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = /* @__PURE__ */ toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item2) {
  if (/* @__PURE__ */ isReadonly(target)) {
    return /* @__PURE__ */ isReactive(target) ? toReadonly(toReactive(item2)) : toReadonly(item2);
  }
  return toReactive(item2);
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator$1(this, Symbol.iterator, (item2) => toWrapped(this, item2));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x2) => isArray$2(x2) ? reactiveReadArray(x2) : x2)
    );
  },
  entries() {
    return iterator$1(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(
      this,
      "filter",
      fn,
      thisArg,
      (v2) => v2.map((item2) => toWrapped(this, item2)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply(
      this,
      "find",
      fn,
      thisArg,
      (item2) => toWrapped(this, item2),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(
      this,
      "findLast",
      fn,
      thisArg,
      (item2) => toWrapped(this, item2),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce$1(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce$1(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator$1(this, "values", (item2) => toWrapped(this, item2));
  }
};
function iterator$1(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !/* @__PURE__ */ isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !/* @__PURE__ */ isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item2, index2) {
        return fn.call(this, toWrapped(self2, item2), index2, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item2, index2) {
        return fn.call(this, item2, index2, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce$1(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!/* @__PURE__ */ isShallow(self2)) {
      wrappedFn = function(acc, item2, index2) {
        return fn.call(this, acc, toWrapped(self2, item2), index2, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item2, index2) {
        return fn.call(this, acc, item2, index2, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = /* @__PURE__ */ toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && /* @__PURE__ */ isProxy(args[0])) {
    args[0] = /* @__PURE__ */ toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = (/* @__PURE__ */ toRaw(self2))[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
function hasOwnProperty$1(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = /* @__PURE__ */ toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ isRef(target) ? target : receiver
    );
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (/* @__PURE__ */ isRef(res)) {
      const value = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject$1(value) ? /* @__PURE__ */ readonly(value) : value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? /* @__PURE__ */ readonly(res) : /* @__PURE__ */ reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = isArray$2(target) && isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = /* @__PURE__ */ isReadonly(oldValue);
      if (!/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) {
        oldValue = /* @__PURE__ */ toRaw(oldValue);
        value = /* @__PURE__ */ toRaw(value);
      }
      if (!isArrayWithIntegerKey && /* @__PURE__ */ isRef(oldValue) && !/* @__PURE__ */ isRef(value)) {
        if (isOldValueReadonly) {
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      /* @__PURE__ */ isRef(target) ? target : receiver
    );
    if (target === /* @__PURE__ */ toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$2(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = /* @__PURE__ */ toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return extend$1(
      // inheriting all iterator properties
      Object.create(innerIterator),
      {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        }
      }
    );
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = /* @__PURE__ */ toRaw(target);
      const rawKey = /* @__PURE__ */ toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(/* @__PURE__ */ toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = /* @__PURE__ */ toRaw(target);
      const rawKey = /* @__PURE__ */ toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = /* @__PURE__ */ toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend$1(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) {
          value = /* @__PURE__ */ toRaw(value);
        }
        const target = /* @__PURE__ */ toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) {
          value = /* @__PURE__ */ toRaw(value);
        }
        const target = /* @__PURE__ */ toRaw(this);
        const { has, get: get3 } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = /* @__PURE__ */ toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get3.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = /* @__PURE__ */ toRaw(this);
        const { has, get: get3 } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = /* @__PURE__ */ toRaw(key);
          hadKey = has.call(target, key);
        }
        get3 ? get3.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = /* @__PURE__ */ toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
// @__NO_SIDE_EFFECTS__
function reactive(target) {
  if (/* @__PURE__ */ isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
// @__NO_SIDE_EFFECTS__
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
// @__NO_SIDE_EFFECTS__
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
// @__NO_SIDE_EFFECTS__
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
// @__NO_SIDE_EFFECTS__
function isReactive(value) {
  if (/* @__PURE__ */ isReadonly(value)) {
    return /* @__PURE__ */ isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
// @__NO_SIDE_EFFECTS__
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
// @__NO_SIDE_EFFECTS__
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
// @__NO_SIDE_EFFECTS__
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
// @__NO_SIDE_EFFECTS__
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$1(value) ? /* @__PURE__ */ reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? /* @__PURE__ */ readonly(value) : value;
// @__NO_SIDE_EFFECTS__
function isRef(r2) {
  return r2 ? r2["__v_isRef"] === true : false;
}
// @__NO_SIDE_EFFECTS__
function ref(value) {
  return createRef(value, false);
}
// @__NO_SIDE_EFFECTS__
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (/* @__PURE__ */ isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : /* @__PURE__ */ toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || /* @__PURE__ */ isShallow(newValue) || /* @__PURE__ */ isReadonly(newValue);
    newValue = useDirectValue ? newValue : /* @__PURE__ */ toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return /* @__PURE__ */ isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (/* @__PURE__ */ isRef(oldValue) && !/* @__PURE__ */ isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return /* @__PURE__ */ isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
// @__NO_SIDE_EFFECTS__
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
    this._raw = /* @__PURE__ */ toRaw(_object);
    let shallow = true;
    let obj = _object;
    if (!isArray$2(_object) || !isIntegerKey(String(_key))) {
      do {
        shallow = !/* @__PURE__ */ isProxy(obj) || /* @__PURE__ */ isShallow(obj);
      } while (shallow && (obj = obj["__v_raw"]));
    }
    this._shallow = shallow;
  }
  get value() {
    let val = this._object[this._key];
    if (this._shallow) {
      val = unref(val);
    }
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    if (this._shallow && /* @__PURE__ */ isRef(this._raw[this._key])) {
      const nestedRef = this._object[this._key];
      if (/* @__PURE__ */ isRef(nestedRef)) {
        nestedRef.value = newVal;
        return;
      }
    }
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(this._raw, this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  return new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
// @__NO_SIDE_EFFECTS__
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$2(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (/* @__PURE__ */ isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (/* @__PURE__ */ isRef(source)) {
    getter = () => source.value;
    forceTrigger = /* @__PURE__ */ isShallow(source);
  } else if (/* @__PURE__ */ isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => /* @__PURE__ */ isReactive(s2) || /* @__PURE__ */ isShallow(s2));
    getter = () => source.map((s2) => {
      if (/* @__PURE__ */ isRef(s2)) {
        return s2.value;
      } else if (/* @__PURE__ */ isReactive(s2)) {
        return reactiveGetter(s2);
      } else if (isFunction$2(s2)) {
        return call ? call(s2, 2) : s2();
      } else ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (/* @__PURE__ */ isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$2(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance2 = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance2 && instance2.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance2,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a2, _b;
          return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance2 && instance2.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance2, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close2 = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (/* @__PURE__ */ isRef(value)) {
    value = formatProp(key, /* @__PURE__ */ toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$2(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = /* @__PURE__ */ toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance2, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance2, type);
  }
}
function callWithAsyncErrorHandling(fn, instance2, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance2, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance2, type);
      });
    }
    return res;
  }
  if (isArray$2(fn)) {
    const values = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values.push(callWithAsyncErrorHandling(fn[i2], instance2, type, args));
    }
    return values;
  }
}
function handleError(err, instance2, type, throwInDev = true) {
  const contextVNode = instance2 ? instance2.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance2 && instance2.appContext.config || EMPTY_OBJ;
  if (instance2) {
    let cur = instance2.parent;
    const exposedInstance = instance2.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex$1(id) {
  let start = flushIndex + 1;
  let end3 = queue.length;
  while (start < end3) {
    const middle = start + end3 >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end3 = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex$1(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance2, seen, i2 = flushIndex + 1) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.flags & 2) {
      if (instance2 && cb.id !== instance2.uid) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b2) => getId(a2) - getId(b2)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance2) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance2;
  currentScopeId = instance2 && instance2.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance2 = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance: instance2,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance2, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance2, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function provide(key, value) {
  if (currentInstance) {
    let provides7 = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides7) {
      provides7 = currentInstance.provides = Object.create(parentProvides);
    }
    provides7[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance2 = getCurrentInstance();
  if (instance2 || currentApp) {
    let provides7 = currentApp ? currentApp._context.provides : instance2 ? instance2.parent == null || instance2.ce ? instance2.vnode.appContext && instance2.vnode.appContext.provides : instance2.parent.provides : void 0;
    if (provides7 && key in provides7) {
      return provides7[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance2 && instance2.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}
const ssrContextKey = /* @__PURE__ */ Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance2 = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance2, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance2 && instance2.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance2) {
        job.id = instance2.uid;
        job.i = instance2;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
const TeleportEndKey = /* @__PURE__ */ Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled3 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace2 !== "svg" && isTargetSVG(target)) {
            namespace2 = "svg";
          } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
            namespace2 = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled3) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled3) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace2 === "svg" || isTargetSVG(target)) {
        namespace2 = "svg";
      } else if (namespace2 === "mathml" || isTargetMathML(target)) {
        namespace2 = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          false
        );
      }
      if (disabled3) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled3);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled3 = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled3) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled3);
  } else if (disabled3) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = /* @__PURE__ */ Symbol("_leaveCb");
const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance2) => {
  const subTree = instance2.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = /* @__PURE__ */ toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance2,
        // #11061, ensure enterHooks is fresh after clone
        (hooks8) => enterHooks = hooks8
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance2.subTree && getInnerChild$1(instance2.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance2).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance2
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance2.job.flags & 8)) {
              instance2.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c2 of children) {
      if (c2.type !== Comment) {
        child = c2;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance2, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter: onBeforeEnter2,
    onEnter: onEnter3,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave: onBeforeLeave2,
    onLeave: onLeave3,
    onAfterLeave: onAfterLeave3,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance2,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks8 = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter2;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter2;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter3;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter3;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks8.delayedLeave) {
          hooks8.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove22) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove22();
      }
      callHook2(onBeforeLeave2, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove22();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave3, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave3) {
        callAsyncHook(onLeave3, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks22 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance2,
        postClone
      );
      if (postClone) postClone(hooks22);
      return hooks22;
    }
  };
  return hooks8;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$2(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks8) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks8;
    setTransitionHooks(vnode.component.subTree, hooks8);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks8.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks8.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks8;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function useId() {
  const i2 = getCurrentInstance();
  if (i2) {
    return (i2.appContext.config.idPrefix || "v") + "-" + i2.ids[0] + i2.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance2) {
  instance2.ids = [instance2.ids[0] + instance2.ids[2]++ + "-", 0, 0];
}
function useTemplateRef(key) {
  const i2 = getCurrentInstance();
  const r2 = /* @__PURE__ */ shallowRef(null);
  if (i2) {
    const refs = i2.refs === EMPTY_OBJ ? i2.refs = {} : i2.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r2.value,
        set: (val) => r2.value = val
      });
    }
  }
  const ret = r2;
  return ret;
}
const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r2, i2) => setRef(
        r2,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = /* @__PURE__ */ toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    invalidatePendingSetRef(oldRawRef);
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (/* @__PURE__ */ isRef(oldRef)) {
      {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
    }
  }
  if (isFunction$2(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = /* @__PURE__ */ isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                const newVal = [refValue];
                {
                  ref3.value = newVal;
                }
                if (rawRef.k) refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          {
            ref3.value = value;
          }
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks8 = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks8.unshift(wrappedHook);
    } else {
      hooks8.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance2 = currentRenderingInstance || currentInstance;
  if (instance2) {
    const Component = instance2.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance2[type] || Component[type], name) || // global registration
      resolve(instance2.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray$2(source);
  if (sourceIsArray || isString$1(source)) {
    const sourceIsReactiveArray = sourceIsArray && /* @__PURE__ */ isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !/* @__PURE__ */ isShallow(source);
      isReadonlySource = /* @__PURE__ */ isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i2])) : toReactive(source[i2]) : source[i2],
        i2,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item2, i2) => renderItem(item2, i2, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $host: (i2) => i2.ce,
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance2 }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data6, props, accessCache, type, appContext } = instance2;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data6[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data6 !== EMPTY_OBJ && hasOwn(data6, key)) {
        accessCache[key] = 2;
        return data6[key];
      } else if (hasOwn(props, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance2.attrs, "get", "");
      }
      return publicGetter(instance2);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance2 }, key, value) {
    const { data: data6, setupState, ctx } = instance2;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data6 !== EMPTY_OBJ && hasOwn(data6, key)) {
      data6[key] = value;
      return true;
    } else if (hasOwn(instance2.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance2) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data: data6, setupState, accessCache, ctx, appContext, props, type }
  }, key) {
    let cssModules;
    return !!(accessCache[key] || data6 !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data6, key) || hasSetupBinding(setupState, key) || hasOwn(props, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance2) {
  const options = resolveMergedOptions(instance2);
  const publicThis = instance2.proxy;
  const ctx = instance2.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance2, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created: created2,
    beforeMount: beforeMount3,
    mounted: mounted7,
    beforeUpdate: beforeUpdate2,
    updated: updated4,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount5,
    destroyed,
    unmounted: unmounted5,
    render: render3,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data6 = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data6)) ;
    else {
      instance2.data = /* @__PURE__ */ reactive(data6);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set3 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get3,
        set: set3
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides7 = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides7).forEach((key) => {
      provide(key, provides7[key]);
    });
  }
  if (created2) {
    callHook$1(created2, instance2, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook3) => register(_hook3.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount3);
  registerLifecycleHook(onMounted, mounted7);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated4);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount5);
  registerLifecycleHook(onUnmounted, unmounted5);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance2.exposed || (instance2.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance2.exposed) {
      instance2.exposed = {};
    }
  }
  if (render3 && instance2.render === NOOP) {
    instance2.render = render3;
  }
  if (inheritAttrs != null) {
    instance2.inheritAttrs = inheritAttrs;
  }
  if (components) instance2.components = components;
  if (directives) instance2.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance2);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (/* @__PURE__ */ isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance2, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance2.proxy)) : hook.bind(instance2.proxy),
    instance2,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler4 = ctx[raw];
    if (isFunction$2(handler4)) {
      {
        watch(getter, handler4);
      }
    }
  } else if (isFunction$2(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$1(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler4 = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler4)) {
        watch(getter, handler4, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance2) {
  const base = instance2.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance2.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions$1(to2, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$2(to2) ? to2.call(this, this) : to2,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend$1(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
  if (to2) {
    if (isArray$2(to2) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to2, from) {
  if (!to2) return from;
  if (!from) return to2;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray(to2[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render3, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace2) {
        if (!isMounted) {
          const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace2 === true) {
            namespace2 = "svg";
          } else if (namespace2 === false) {
            namespace2 = void 0;
          }
          {
            render3(vnode, rootContainer, namespace2);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app2._instance,
            16
          );
          render3(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance2, event, ...rawArgs) {
  if (instance2.isUnmounted) return;
  const props = instance2.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler4 = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler4 && isModelListener2) {
    handler4 = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler4) {
    callWithAsyncErrorHandling(
      handler4,
      instance2,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance2.emitted) {
      instance2.emitted = {};
    } else if (instance2.emitted[handlerName]) {
      return;
    }
    instance2.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance2,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance2) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs: attrs2,
    emit: emit2,
    render: render3,
    renderCache,
    props,
    data: data6,
    setupState,
    ctx,
    inheritAttrs
  } = instance2;
  const prev = setCurrentRenderingInstance(instance2);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render3.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? /* @__PURE__ */ shallowReadonly(props) : props,
          setupState,
          data6,
          ctx
        )
      );
      fallthroughAttrs = attrs2;
    } else {
      const render22 = Component;
      if (false) ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? /* @__PURE__ */ shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return /* @__PURE__ */ shallowReadonly(attrs2);
            },
            slots,
            emit: emit2
          } : { attrs: attrs2, slots, emit: emit2 }
        ) : render22(
          false ? /* @__PURE__ */ shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs2 : getFunctionalFallthrough(attrs2);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance2, 1);
    result = createVNode(Comment);
  }
  let root6 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root6;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root6 = cloneVNode(root6, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root6 = cloneVNode(root6, null, false, true);
    root6.dirs = root6.dirs ? root6.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root6, vnode.transition);
  }
  {
    result = root6;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs2) => {
  let res;
  for (const key in attrs2) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs2[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs2, props) => {
  const res = {};
  for (const key in attrs2) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs2[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root6 = parent.subTree;
    if (root6.suspense && root6.suspense.activeBranch === vnode) {
      root6.el = vnode.el;
    }
    if (root6 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance2, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs2 = createInternalObject();
  instance2.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance2, rawProps, props, attrs2);
  for (const key in instance2.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance2.props = isSSR ? props : /* @__PURE__ */ shallowReactive(props);
  } else {
    if (!instance2.type.props) {
      instance2.props = attrs2;
    } else {
      instance2.props = props;
    }
  }
  instance2.attrs = attrs2;
}
function updateProps(instance2, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs: attrs2,
    vnode: { patchFlag }
  } = instance2;
  const rawCurrentProps = /* @__PURE__ */ toRaw(props);
  const [options] = instance2.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance2.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance2.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs2, key)) {
            if (value !== attrs2[key]) {
              attrs2[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance2,
              false
            );
          }
        } else {
          if (value !== attrs2[key]) {
            attrs2[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance2, rawProps, props, attrs2)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance2,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs2 !== rawCurrentProps) {
      for (const key in attrs2) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs2[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance2.attrs, "set", "");
  }
}
function setFullProps(instance2, rawProps, props, attrs2) {
  const [options, needCastKeys] = instance2.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance2.emitsOptions, key)) {
        if (!(key in attrs2) || value !== attrs2[key]) {
          attrs2[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = /* @__PURE__ */ toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance2,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance2, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance2;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance2);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance2.ce) {
        instance2.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$2(propType)) {
          for (let index2 = 0; index2 < propType.length; ++index2) {
            const type = propType[index2];
            const typeName = isFunction$2(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$2(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance2) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance2, children) => {
  const normalized = normalizeSlotValue(children);
  instance2.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance2, children, optimized) => {
  const slots = instance2.slots = createInternalObject();
  if (instance2.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
  }
};
const updateSlots = (instance2, children, optimized) => {
  const { vnode, slots } = instance2;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace2);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        {
          hostSetText(el, n2.children);
        }
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace2) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace2,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace2 = "svg";
    } else if (n2.type === "math") {
      namespace2 = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
      try {
        if (customElement) {
          customElement._beginPatch();
        }
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } finally {
        if (customElement) {
          customElement._endPatch();
        }
      }
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace2,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace2),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace2, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace2);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace2);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace2);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace2, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace2);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace2) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace2,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace2, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren && n1.dynamicChildren.length === dynamicChildren.length) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace2,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
    const instance2 = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance2.ctx.renderer = internals;
    }
    {
      setupComponent(instance2, false, optimized);
    }
    if (instance2.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance2, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance2.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance2,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace2,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance2 = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance2.asyncDep && !instance2.asyncResolved) {
        updateComponentPreRender(instance2, n2, optimized);
        return;
      } else {
        instance2.next = n2;
        instance2.update();
      }
    } else {
      n2.el = n1.el;
      instance2.vnode = n2;
    }
  };
  const setupRenderEffect = (instance2, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
    const componentUpdateFn = () => {
      if (!instance2.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent, root: root6, type } = instance2;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance2, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance2, true);
        {
          if (root6.ce && // @ts-expect-error _def is private
          root6.ce._def.shadowRoot !== false) {
            root6.ce._injectChildStyle(type);
          }
          const subTree = instance2.subTree = renderComponentRoot(instance2);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance2,
            parentSuspense,
            namespace2
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance2.a && queuePostRenderEffect(instance2.a, parentSuspense);
        }
        instance2.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance2;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance2);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance2, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance2.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance2, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance2, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance2, true);
        const nextTree = renderComponentRoot(instance2);
        const prevTree = instance2.subTree;
        instance2.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance2,
          parentSuspense,
          namespace2
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance2, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance2.scope.on();
    const effect2 = instance2.effect = new ReactiveEffect(componentUpdateFn);
    instance2.scope.off();
    const update = instance2.update = effect2.run.bind(effect2);
    const job = instance2.job = effect2.runIfDirty.bind(effect2);
    job.i = instance2;
    job.id = instance2.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance2, true);
    update();
  };
  const updateComponentPreRender = (instance2, nextVNode, optimized) => {
    nextVNode.component = instance2;
    const prevProps = instance2.vnode.props;
    instance2.vnode = nextVNode;
    instance2.next = null;
    updateProps(instance2, nextVNode.props, prevProps, optimized);
    updateSlots(instance2, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance2);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          anchorVNode.el || resolveAsyncComponentPlaceholder(anchorVNode)
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove222 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove222();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove222, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove22(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove22 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end3) => {
    let next;
    while (cur !== end3) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end3);
  };
  const unmountComponent = (instance2, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance2;
    invalidateMount(m2);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance2, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance2.isUnmounted = true;
    }, parentSuspense);
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render3 = (vnode, container, namespace2) => {
    let instance2;
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
        instance2 = container._vnode.component;
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace2
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs(instance2);
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove22,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render: render3,
    hydrate,
    createApp: createAppAPI(render3)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        if (c2.patchFlag !== -1) {
          c2.el = c1.el;
        } else {
          c2.__elIndex = i2 + // take fragment start anchor into account
          (n1.type === Fragment ? 1 : 0);
        }
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance2) {
  const subComponent = instance2.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks8) {
  if (hooks8) {
    for (let i2 = 0; i2 < hooks8.length; i2++)
      hooks8[i2].flags |= 8;
  }
}
function resolveAsyncComponentPlaceholder(anchorVnode) {
  if (anchorVnode.placeholder) {
    return anchorVnode.placeholder;
  }
  const instance2 = anchorVnode.component;
  if (instance2) {
    return resolveAsyncComponentPlaceholder(instance2.subTree);
  }
  return null;
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = /* @__PURE__ */ Symbol.for("v-fgt");
const Text = /* @__PURE__ */ Symbol.for("v-txt");
const Comment = /* @__PURE__ */ Symbol.for("v-cmt");
const Static = /* @__PURE__ */ Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || /* @__PURE__ */ isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style2)) {
      if (/* @__PURE__ */ isProxy(style2) && !isArray$2(style2)) {
        style2 = extend$1({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return /* @__PURE__ */ isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance2, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance2, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance2 = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance2.ctx = { _: instance2 };
  }
  instance2.root = parent ? parent.root : instance2;
  instance2.emit = emit.bind(null, instance2);
  if (vnode.ce) {
    vnode.ce(instance2);
  }
  return instance2;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key])) setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set3) => set3(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance2) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance2);
  instance2.scope.on();
  return () => {
    instance2.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance2) {
  return instance2.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance2, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance2.vnode;
  const isStateful = isStatefulComponent(instance2);
  initProps(instance2, props, isStateful, isSSR);
  initSlots(instance2, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance2, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance2, isSSR) {
  const Component = instance2.type;
  instance2.accessCache = /* @__PURE__ */ Object.create(null);
  instance2.proxy = new Proxy(instance2.ctx, PublicInstanceProxyHandlers);
  const { setup: setup3 } = Component;
  if (setup3) {
    pauseTracking();
    const setupContext = instance2.setupContext = setup3.length > 1 ? createSetupContext(instance2) : null;
    const reset = setCurrentInstance(instance2);
    const setupResult = callWithErrorHandling(
      setup3,
      instance2,
      0,
      [
        instance2.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance2.sp) && !isAsyncWrapper(instance2)) {
      markAsyncBoundary(instance2);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance2, resolvedResult);
        }).catch((e2) => {
          handleError(e2, instance2, 0);
        });
      } else {
        instance2.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance2, setupResult);
    }
  } else {
    finishComponentSetup(instance2);
  }
}
function handleSetupResult(instance2, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance2.type.__ssrInlineRender) {
      instance2.ssrRender = setupResult;
    } else {
      instance2.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance2.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance2);
}
function finishComponentSetup(instance2, isSSR, skipOptions) {
  const Component = instance2.type;
  if (!instance2.render) {
    instance2.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance2);
    pauseTracking();
    try {
      applyOptions(instance2);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance2) {
  const expose = (exposed) => {
    instance2.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance2.attrs, attrsProxyHandlers),
      slots: instance2.slots,
      emit: instance2.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance2) {
  if (instance2.exposed) {
    return instance2.exposeProxy || (instance2.exposeProxy = new Proxy(proxyRefs(markRaw(instance2.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance2);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance2.proxy;
  }
}
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance2, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance2) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance2.components) || instance2.parent && inferFromRegistry(
      instance2.parent.type.components
    ) || inferFromRegistry(instance2.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = /* @__PURE__ */ computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h$8(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}
const version = "3.5.27";
let policy = void 0;
const tt$2 = typeof window !== "undefined" && window.trustedTypes;
if (tt$2) {
  try {
    policy = /* @__PURE__ */ tt$2.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e2) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace2, is2, props) => {
    const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace2, start, end3) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end3 || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end3 || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace2 === "svg" || namespace2 === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = /* @__PURE__ */ Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t2) => {
  t2.displayName = "Transition";
  t2.props = TransitionPropsValidators;
  return t2;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h$8(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter: onBeforeEnter2,
    onEnter: onEnter3,
    onEnterCancelled,
    onLeave: onLeave3,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter2,
    onAppear = onEnter3,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter3;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter2, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow(el);
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow(el);
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave3)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave3, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end3 = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end3();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end3();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles2 = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles2[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  if (s2 === "auto") return 0;
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(el) {
  const targetDocument = el ? el.ownerDocument : document;
  return targetDocument.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = /* @__PURE__ */ Symbol("_vod");
const vShowHidden = /* @__PURE__ */ Symbol("_vsh");
const CSS_VAR_TEXT = /* @__PURE__ */ Symbol("");
const displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style2, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style2[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style2.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
    if (el[vShowHidden]) {
      style2.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$2(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance2, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler4, options) {
  el.addEventListener(event, handler4, options);
}
function removeEventListener(el, event, handler4, options) {
  el.removeEventListener(event, handler4, options);
}
const veiKey = /* @__PURE__ */ Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance2 = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance2
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$6 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$6.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance2) {
  const invoker = (e2) => {
    if (!e2._vts) {
      e2._vts = Date.now();
    } else if (e2._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e2, invoker.value),
      instance2,
      5,
      [e2]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$2(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map(
      (fn) => (e22) => !e22._stopped && fn && fn(e22)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace2, parentComponent) => {
  const isSVG = namespace2 === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "sandbox" && el.tagName === "IFRAME") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = ((...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
});
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var ie$2 = Object.defineProperty;
var K$3 = Object.getOwnPropertySymbols;
var se$1 = Object.prototype.hasOwnProperty, ae$2 = Object.prototype.propertyIsEnumerable;
var N$3 = (e2, t2, n2) => t2 in e2 ? ie$2(e2, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t2] = n2, d$E = (e2, t2) => {
  for (var n2 in t2 || (t2 = {})) se$1.call(t2, n2) && N$3(e2, n2, t2[n2]);
  if (K$3) for (var n2 of K$3(t2)) ae$2.call(t2, n2) && N$3(e2, n2, t2[n2]);
  return e2;
};
function l$j(e2) {
  return e2 == null || e2 === "" || Array.isArray(e2) && e2.length === 0 || !(e2 instanceof Date) && typeof e2 == "object" && Object.keys(e2).length === 0;
}
function c$A(e2) {
  return typeof e2 == "function" && "call" in e2 && "apply" in e2;
}
function s$e(e2) {
  return !l$j(e2);
}
function i$v(e2, t2 = true) {
  return e2 instanceof Object && e2.constructor === Object && (t2 || Object.keys(e2).length !== 0);
}
function $$4(e2 = {}, t2 = {}) {
  let n2 = d$E({}, e2);
  return Object.keys(t2).forEach((o2) => {
    let r2 = o2;
    i$v(t2[r2]) && r2 in e2 && i$v(e2[r2]) ? n2[r2] = $$4(e2[r2], t2[r2]) : n2[r2] = t2[r2];
  }), n2;
}
function w$4(...e2) {
  return e2.reduce((t2, n2, o2) => o2 === 0 ? n2 : $$4(t2, n2), {});
}
function M$3(e2, t2) {
  let n2 = -1;
  if (s$e(e2)) try {
    n2 = e2.findLastIndex(t2);
  } catch (o2) {
    n2 = e2.lastIndexOf([...e2].reverse().find(t2));
  }
  return n2;
}
function m$6(e2, ...t2) {
  return c$A(e2) ? e2(...t2) : e2;
}
function a$J(e2, t2 = true) {
  return typeof e2 == "string" && (t2 || e2 !== "");
}
function g$8(e2) {
  return a$J(e2) ? e2.replace(/(-|_)/g, "").toLowerCase() : e2;
}
function F$4(e2, t2 = "", n2 = {}) {
  let o2 = g$8(t2).split("."), r2 = o2.shift();
  if (r2) {
    if (i$v(e2)) {
      let u2 = Object.keys(e2).find((f2) => g$8(f2) === r2) || "";
      return F$4(m$6(e2[u2], n2), o2.join("."), n2);
    }
    return;
  }
  return m$6(e2, n2);
}
function C$5(e2, t2 = true) {
  return Array.isArray(e2) && (t2 || e2.length !== 0);
}
function z$3(e2) {
  return s$e(e2) && !isNaN(e2);
}
function J$3(e2 = "") {
  return s$e(e2) && e2.length === 1 && !!e2.match(/\S| /);
}
function G$2(e2, t2) {
  if (t2) {
    let n2 = t2.test(e2);
    return t2.lastIndex = 0, n2;
  }
  return false;
}
function H$2(...e2) {
  return w$4(...e2);
}
function Y$4(e2) {
  return e2 && e2.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":").trim();
}
function ne$2(e2) {
  return a$J(e2, false) ? e2[0].toUpperCase() + e2.slice(1) : e2;
}
function re$1(e2) {
  return a$J(e2) ? e2.replace(/(_)/g, "-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : e2;
}
function s$d() {
  let r2 = /* @__PURE__ */ new Map();
  return { on(e2, t2) {
    let n2 = r2.get(e2);
    return n2 ? n2.push(t2) : n2 = [t2], r2.set(e2, n2), this;
  }, off(e2, t2) {
    let n2 = r2.get(e2);
    return n2 && n2.splice(n2.indexOf(t2) >>> 0, 1), this;
  }, emit(e2, t2) {
    let n2 = r2.get(e2);
    n2 && n2.forEach((i2) => {
      i2(t2);
    });
  }, clear() {
    r2.clear();
  } };
}
function f$c(...e2) {
  if (e2) {
    let t2 = [];
    for (let i2 = 0; i2 < e2.length; i2++) {
      let n2 = e2[i2];
      if (!n2) continue;
      let s2 = typeof n2;
      if (s2 === "string" || s2 === "number") t2.push(n2);
      else if (s2 === "object") {
        let c2 = Array.isArray(n2) ? [f$c(...n2)] : Object.entries(n2).map(([r2, o2]) => o2 ? r2 : void 0);
        t2 = c2.length ? t2.concat(c2.filter((r2) => !!r2)) : t2;
      }
    }
    return t2.join(" ").trim();
  }
}
function R$2(t2, e2) {
  return t2 ? t2.classList ? t2.classList.contains(e2) : new RegExp("(^| )" + e2 + "( |$)", "gi").test(t2.className) : false;
}
function W$2(t2, e2) {
  if (t2 && e2) {
    let o2 = (n2) => {
      R$2(t2, n2) || (t2.classList ? t2.classList.add(n2) : t2.className += " " + n2);
    };
    [e2].flat().filter(Boolean).forEach((n2) => n2.split(" ").forEach(o2));
  }
}
function F$3() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
function st$2(t2) {
  typeof t2 == "string" ? W$2(document.body, t2 || "p-overflow-hidden") : (t2 != null && t2.variableName && document.body.style.setProperty(t2.variableName, F$3() + "px"), W$2(document.body, (t2 == null ? void 0 : t2.className) || "p-overflow-hidden"));
}
function P$2(t2, e2) {
  if (t2 && e2) {
    let o2 = (n2) => {
      t2.classList ? t2.classList.remove(n2) : t2.className = t2.className.replace(new RegExp("(^|\\b)" + n2.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    };
    [e2].flat().filter(Boolean).forEach((n2) => n2.split(" ").forEach(o2));
  }
}
function dt$2(t2) {
  typeof t2 == "string" ? P$2(document.body, t2 || "p-overflow-hidden") : (t2 != null && t2.variableName && document.body.style.removeProperty(t2.variableName), P$2(document.body, (t2 == null ? void 0 : t2.className) || "p-overflow-hidden"));
}
function x$3(t2) {
  for (let e2 of document == null ? void 0 : document.styleSheets) try {
    for (let o2 of e2 == null ? void 0 : e2.cssRules) for (let n2 of o2 == null ? void 0 : o2.style) if (t2.test(n2)) return { name: n2, value: o2.style.getPropertyValue(n2).trim() };
  } catch (o2) {
  }
  return null;
}
function w$3(t2) {
  let e2 = { width: 0, height: 0 };
  if (t2) {
    let [o2, n2] = [t2.style.visibility, t2.style.display], r2 = t2.getBoundingClientRect();
    t2.style.visibility = "hidden", t2.style.display = "block", e2.width = r2.width || t2.offsetWidth, e2.height = r2.height || t2.offsetHeight, t2.style.display = n2, t2.style.visibility = o2;
  }
  return e2;
}
function h$7() {
  let t2 = window, e2 = document, o2 = e2.documentElement, n2 = e2.getElementsByTagName("body")[0], r2 = t2.innerWidth || o2.clientWidth || n2.clientWidth, i2 = t2.innerHeight || o2.clientHeight || n2.clientHeight;
  return { width: r2, height: i2 };
}
function E$3(t2) {
  return t2 ? Math.abs(t2.scrollLeft) : 0;
}
function k$5() {
  let t2 = document.documentElement;
  return (window.pageXOffset || E$3(t2)) - (t2.clientLeft || 0);
}
function $$3() {
  let t2 = document.documentElement;
  return (window.pageYOffset || t2.scrollTop) - (t2.clientTop || 0);
}
function V$2(t2) {
  return t2 ? getComputedStyle(t2).direction === "rtl" : false;
}
function D$2(t2, e2, o2 = true) {
  var n2, r2, i2, l2;
  if (t2) {
    let d2 = t2.offsetParent ? { width: t2.offsetWidth, height: t2.offsetHeight } : w$3(t2), s2 = d2.height, a2 = d2.width, u2 = e2.offsetHeight, p2 = e2.offsetWidth, f2 = e2.getBoundingClientRect(), g2 = $$3(), it2 = k$5(), lt2 = h$7(), L2, N2, ot2 = "top";
    f2.top + u2 + s2 > lt2.height ? (L2 = f2.top + g2 - s2, ot2 = "bottom", L2 < 0 && (L2 = g2)) : L2 = u2 + f2.top + g2, f2.left + a2 > lt2.width ? N2 = Math.max(0, f2.left + it2 + p2 - a2) : N2 = f2.left + it2, V$2(t2) ? t2.style.insetInlineEnd = N2 + "px" : t2.style.insetInlineStart = N2 + "px", t2.style.top = L2 + "px", t2.style.transformOrigin = ot2, o2 && (t2.style.marginTop = ot2 === "bottom" ? `calc(${(r2 = (n2 = x$3(/-anchor-gutter$/)) == null ? void 0 : n2.value) != null ? r2 : "2px"} * -1)` : (l2 = (i2 = x$3(/-anchor-gutter$/)) == null ? void 0 : i2.value) != null ? l2 : "");
  }
}
function S$3(t2, e2) {
  t2 && (typeof e2 == "string" ? t2.style.cssText = e2 : Object.entries(e2 || {}).forEach(([o2, n2]) => t2.style[o2] = n2));
}
function v$5(t2, e2) {
  if (t2 instanceof HTMLElement) {
    let o2 = t2.offsetWidth;
    return o2;
  }
  return 0;
}
function y$2(t2) {
  if (t2) {
    let e2 = t2.parentNode;
    return e2 && e2 instanceof ShadowRoot && e2.host && (e2 = e2.host), e2;
  }
  return null;
}
function T$2(t2) {
  return !!(t2 !== null && typeof t2 != "undefined" && t2.nodeName && y$2(t2));
}
function c$z(t2) {
  return typeof Element != "undefined" ? t2 instanceof Element : t2 !== null && typeof t2 == "object" && t2.nodeType === 1 && typeof t2.nodeName == "string";
}
function A$3(t2, e2 = {}) {
  if (c$z(t2)) {
    let o2 = (n2, r2) => {
      var l2, d2;
      let i2 = (l2 = t2 == null ? void 0 : t2.$attrs) != null && l2[n2] ? [(d2 = t2 == null ? void 0 : t2.$attrs) == null ? void 0 : d2[n2]] : [];
      return [r2].flat().reduce((s2, a2) => {
        if (a2 != null) {
          let u2 = typeof a2;
          if (u2 === "string" || u2 === "number") s2.push(a2);
          else if (u2 === "object") {
            let p2 = Array.isArray(a2) ? o2(n2, a2) : Object.entries(a2).map(([f2, g2]) => n2 === "style" && (g2 || g2 === 0) ? `${f2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${g2}` : g2 ? f2 : void 0);
            s2 = p2.length ? s2.concat(p2.filter((f2) => !!f2)) : s2;
          }
        }
        return s2;
      }, i2);
    };
    Object.entries(e2).forEach(([n2, r2]) => {
      if (r2 != null) {
        let i2 = n2.match(/^on(.+)/);
        i2 ? t2.addEventListener(i2[1].toLowerCase(), r2) : n2 === "p-bind" || n2 === "pBind" ? A$3(t2, r2) : (r2 = n2 === "class" ? [...new Set(o2("class", r2))].join(" ").trim() : n2 === "style" ? o2("style", r2).join(";").trim() : r2, (t2.$attrs = t2.$attrs || {}) && (t2.$attrs[n2] = r2), t2.setAttribute(n2, r2));
      }
    });
  }
}
function U$2(t2, e2 = {}, ...o2) {
  if (t2) {
    let n2 = document.createElement(t2);
    return A$3(n2, e2), n2.append(...o2), n2;
  }
}
function ht$2(t2, e2) {
  if (t2) {
    t2.style.opacity = "0";
    let o2 = +/* @__PURE__ */ new Date(), n2 = "0", r2 = function() {
      n2 = `${+t2.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - o2) / e2}`, t2.style.opacity = n2, o2 = +/* @__PURE__ */ new Date(), +n2 < 1 && ("requestAnimationFrame" in window ? requestAnimationFrame(r2) : setTimeout(r2, 16));
    };
    r2();
  }
}
function Y$3(t2, e2) {
  return c$z(t2) ? Array.from(t2.querySelectorAll(e2)) : [];
}
function z$2(t2, e2) {
  return c$z(t2) ? t2.matches(e2) ? t2 : t2.querySelector(e2) : null;
}
function bt$1(t2, e2) {
  t2 && document.activeElement !== t2 && t2.focus(e2);
}
function Q$3(t2, e2) {
  if (c$z(t2)) {
    let o2 = t2.getAttribute(e2);
    return isNaN(o2) ? o2 === "true" || o2 === "false" ? o2 === "true" : o2 : +o2;
  }
}
function b$7(t2, e2 = "") {
  let o2 = Y$3(t2, `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [href]:not([tabindex = "-1"]):not([style*="display:none"]):not([hidden])${e2},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2}`), n2 = [];
  for (let r2 of o2) getComputedStyle(r2).display != "none" && getComputedStyle(r2).visibility != "hidden" && n2.push(r2);
  return n2;
}
function vt$1(t2, e2) {
  let o2 = b$7(t2, e2);
  return o2.length > 0 ? o2[0] : null;
}
function Tt$1(t2) {
  if (t2) {
    let e2 = t2.offsetHeight, o2 = getComputedStyle(t2);
    return e2 -= parseFloat(o2.paddingTop) + parseFloat(o2.paddingBottom) + parseFloat(o2.borderTopWidth) + parseFloat(o2.borderBottomWidth), e2;
  }
  return 0;
}
function Lt$1(t2, e2) {
  let o2 = b$7(t2, e2);
  return o2.length > 0 ? o2[o2.length - 1] : null;
}
function K$2(t2) {
  if (t2) {
    let e2 = t2.getBoundingClientRect();
    return { top: e2.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0), left: e2.left + (window.pageXOffset || E$3(document.documentElement) || E$3(document.body) || 0) };
  }
  return { top: "auto", left: "auto" };
}
function C$4(t2, e2) {
  if (t2) {
    let o2 = t2.offsetHeight;
    return o2;
  }
  return 0;
}
function M$2(t2, e2 = []) {
  let o2 = y$2(t2);
  return o2 === null ? e2 : M$2(o2, e2.concat([o2]));
}
function At$1(t2) {
  let e2 = [];
  if (t2) {
    let o2 = M$2(t2), n2 = /(auto|scroll)/, r2 = (i2) => {
      try {
        let l2 = window.getComputedStyle(i2, null);
        return n2.test(l2.getPropertyValue("overflow")) || n2.test(l2.getPropertyValue("overflowX")) || n2.test(l2.getPropertyValue("overflowY"));
      } catch (l2) {
        return false;
      }
    };
    for (let i2 of o2) {
      let l2 = i2.nodeType === 1 && i2.dataset.scrollselectors;
      if (l2) {
        let d2 = l2.split(",");
        for (let s2 of d2) {
          let a2 = z$2(i2, s2);
          a2 && r2(a2) && e2.push(a2);
        }
      }
      i2.nodeType !== 9 && r2(i2) && e2.push(i2);
    }
  }
  return e2;
}
function Rt$1(t2) {
  if (t2) {
    let e2 = t2.offsetWidth, o2 = getComputedStyle(t2);
    return e2 -= parseFloat(o2.paddingLeft) + parseFloat(o2.paddingRight) + parseFloat(o2.borderLeftWidth) + parseFloat(o2.borderRightWidth), e2;
  }
  return 0;
}
function _$2(t2, e2, o2) {
  return c$z(t2) ? Q$3(t2, e2) === o2 : false;
}
function tt$1() {
  return !!(typeof window != "undefined" && window.document && window.document.createElement);
}
function It$1(t2, e2 = "") {
  return c$z(t2) ? t2.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e2}`) : false;
}
function Yt$2() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
function _t$2(t2, e2 = "", o2) {
  c$z(t2) && o2 !== null && o2 !== void 0 && t2.setAttribute(e2, o2);
}
var t$F = {};
function s$c(n2 = "pui_id_") {
  return Object.hasOwn(t$F, n2) || (t$F[n2] = 0), t$F[n2]++, `${n2}${t$F[n2]}`;
}
function g$7() {
  let r2 = [], i2 = (e2, n2, t2 = 999) => {
    let s2 = u2(e2, n2, t2), o2 = s2.value + (s2.key === e2 ? 0 : t2) + 1;
    return r2.push({ key: e2, value: o2 }), o2;
  }, d2 = (e2) => {
    r2 = r2.filter((n2) => n2.value !== e2);
  }, a2 = (e2, n2) => u2(e2).value, u2 = (e2, n2, t2 = 0) => [...r2].reverse().find((s2) => true) || { key: e2, value: t2 }, l2 = (e2) => e2 && parseInt(e2.style.zIndex, 10) || 0;
  return { get: l2, set: (e2, n2, t2) => {
    n2 && (n2.style.zIndex = String(i2(e2, true, t2)));
  }, clear: (e2) => {
    e2 && (d2(l2(e2)), e2.style.zIndex = "");
  }, getCurrent: (e2) => a2(e2) };
}
var x$2 = g$7();
var rt$2 = Object.defineProperty, st$1 = Object.defineProperties;
var nt$1 = Object.getOwnPropertyDescriptors;
var F$2 = Object.getOwnPropertySymbols;
var xe$1 = Object.prototype.hasOwnProperty, be$1 = Object.prototype.propertyIsEnumerable;
var _e$1 = (e2, t2, r2) => t2 in e2 ? rt$2(e2, t2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e2[t2] = r2, h$6 = (e2, t2) => {
  for (var r2 in t2 || (t2 = {})) xe$1.call(t2, r2) && _e$1(e2, r2, t2[r2]);
  if (F$2) for (var r2 of F$2(t2)) be$1.call(t2, r2) && _e$1(e2, r2, t2[r2]);
  return e2;
}, $$2 = (e2, t2) => st$1(e2, nt$1(t2));
var v$4 = (e2, t2) => {
  var r2 = {};
  for (var s2 in e2) xe$1.call(e2, s2) && t2.indexOf(s2) < 0 && (r2[s2] = e2[s2]);
  if (e2 != null && F$2) for (var s2 of F$2(e2)) t2.indexOf(s2) < 0 && be$1.call(e2, s2) && (r2[s2] = e2[s2]);
  return r2;
};
function ke$1(...e2) {
  return w$4(...e2);
}
var at$2 = s$d(), N$2 = at$2;
var k$4 = /{([^}]*)}/g, ne$1 = /(\d+\s+[\+\-\*\/]\s+\d+)/g, ie$1 = /var\([^)]+\)/g;
function oe$1(e2) {
  return a$J(e2) ? e2.replace(/[A-Z]/g, (t2, r2) => r2 === 0 ? t2 : "." + t2.toLowerCase()).toLowerCase() : e2;
}
function ve$1(e2) {
  return i$v(e2) && e2.hasOwnProperty("$value") && e2.hasOwnProperty("$type") ? e2.$value : e2;
}
function dt$1(e2) {
  return e2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
function Q$2(e2 = "", t2 = "") {
  return dt$1(`${a$J(e2, false) && a$J(t2, false) ? `${e2}-` : e2}${t2}`);
}
function ae$1(e2 = "", t2 = "") {
  return `--${Q$2(e2, t2)}`;
}
function ht$1(e2 = "") {
  let t2 = (e2.match(/{/g) || []).length, r2 = (e2.match(/}/g) || []).length;
  return (t2 + r2) % 2 !== 0;
}
function Y$2(e2, t2 = "", r2 = "", s2 = [], i2) {
  if (a$J(e2)) {
    let a2 = e2.trim();
    if (ht$1(a2)) return;
    if (G$2(a2, k$4)) {
      let n2 = a2.replaceAll(k$4, (l2) => {
        let c2 = l2.replace(/{|}/g, "").split(".").filter((m2) => !s2.some((d2) => G$2(m2, d2)));
        return `var(${ae$1(r2, re$1(c2.join("-")))}${s$e(i2) ? `, ${i2}` : ""})`;
      });
      return G$2(n2.replace(ie$1, "0"), ne$1) ? `calc(${n2})` : n2;
    }
    return a2;
  } else if (z$3(e2)) return e2;
}
function Re$1(e2, t2, r2) {
  a$J(t2, false) && e2.push(`${t2}:${r2};`);
}
function C$3(e2, t2) {
  return e2 ? `${e2}{${t2}}` : "";
}
function le$1(e2, t2) {
  if (e2.indexOf("dt(") === -1) return e2;
  function r2(n2, l2) {
    let o2 = [], c2 = 0, m2 = "", d2 = null, u2 = 0;
    for (; c2 <= n2.length; ) {
      let g2 = n2[c2];
      if ((g2 === '"' || g2 === "'" || g2 === "`") && n2[c2 - 1] !== "\\" && (d2 = d2 === g2 ? null : g2), !d2 && (g2 === "(" && u2++, g2 === ")" && u2--, (g2 === "," || c2 === n2.length) && u2 === 0)) {
        let f2 = m2.trim();
        f2.startsWith("dt(") ? o2.push(le$1(f2, l2)) : o2.push(s2(f2)), m2 = "", c2++;
        continue;
      }
      g2 !== void 0 && (m2 += g2), c2++;
    }
    return o2;
  }
  function s2(n2) {
    let l2 = n2[0];
    if ((l2 === '"' || l2 === "'" || l2 === "`") && n2[n2.length - 1] === l2) return n2.slice(1, -1);
    let o2 = Number(n2);
    return isNaN(o2) ? n2 : o2;
  }
  let i2 = [], a2 = [];
  for (let n2 = 0; n2 < e2.length; n2++) if (e2[n2] === "d" && e2.slice(n2, n2 + 3) === "dt(") a2.push(n2), n2 += 2;
  else if (e2[n2] === ")" && a2.length > 0) {
    let l2 = a2.pop();
    a2.length === 0 && i2.push([l2, n2]);
  }
  if (!i2.length) return e2;
  for (let n2 = i2.length - 1; n2 >= 0; n2--) {
    let [l2, o2] = i2[n2], c2 = e2.slice(l2 + 3, o2), m2 = r2(c2, t2), d2 = t2(...m2);
    e2 = e2.slice(0, l2) + d2 + e2.slice(o2 + 1);
  }
  return e2;
}
var rr = (e2) => {
  var a2;
  let t2 = S$2.getTheme(), r2 = ue$1(t2, e2, void 0, "variable"), s2 = (a2 = r2 == null ? void 0 : r2.match(/--[\w-]+/g)) == null ? void 0 : a2[0], i2 = ue$1(t2, e2, void 0, "value");
  return { name: s2, variable: r2, value: i2 };
}, E$2 = (...e2) => ue$1(S$2.getTheme(), ...e2), ue$1 = (e2 = {}, t2, r2, s2) => {
  if (t2) {
    let { variable: i2, options: a2 } = S$2.defaults || {}, { prefix: n2, transform: l2 } = (e2 == null ? void 0 : e2.options) || a2 || {}, o2 = G$2(t2, k$4) ? t2 : `{${t2}}`;
    return s2 === "value" || l$j(s2) && l2 === "strict" ? S$2.getTokenValue(t2) : Y$2(o2, void 0, n2, [i2.excludedKeyRegex], r2);
  }
  return "";
};
function ar(e2, ...t2) {
  if (e2 instanceof Array) {
    let r2 = e2.reduce((s2, i2, a2) => {
      var n2;
      return s2 + i2 + ((n2 = m$6(t2[a2], { dt: E$2 })) != null ? n2 : "");
    }, "");
    return le$1(r2, E$2);
  }
  return m$6(e2, { dt: E$2 });
}
function de$1(e2, t2 = {}) {
  let r2 = S$2.defaults.variable, { prefix: s2 = r2.prefix, selector: i2 = r2.selector, excludedKeyRegex: a2 = r2.excludedKeyRegex } = t2, n2 = [], l2 = [], o2 = [{ node: e2, path: s2 }];
  for (; o2.length; ) {
    let { node: m2, path: d2 } = o2.pop();
    for (let u2 in m2) {
      let g2 = m2[u2], f2 = ve$1(g2), p2 = G$2(u2, a2) ? Q$2(d2) : Q$2(d2, re$1(u2));
      if (i$v(f2)) o2.push({ node: f2, path: p2 });
      else {
        let y2 = ae$1(p2), R2 = Y$2(f2, p2, s2, [a2]);
        Re$1(l2, y2, R2);
        let T2 = p2;
        s2 && T2.startsWith(s2 + "-") && (T2 = T2.slice(s2.length + 1)), n2.push(T2.replace(/-/g, "."));
      }
    }
  }
  let c2 = l2.join("");
  return { value: l2, tokens: n2, declarations: c2, css: C$3(i2, c2) };
}
var b$6 = { regex: { rules: { class: { pattern: /^\.([a-zA-Z][\w-]*)$/, resolve(e2) {
  return { type: "class", selector: e2, matched: this.pattern.test(e2.trim()) };
} }, attr: { pattern: /^\[(.*)\]$/, resolve(e2) {
  return { type: "attr", selector: `:root${e2},:host${e2}`, matched: this.pattern.test(e2.trim()) };
} }, media: { pattern: /^@media (.*)$/, resolve(e2) {
  return { type: "media", selector: e2, matched: this.pattern.test(e2.trim()) };
} }, system: { pattern: /^system$/, resolve(e2) {
  return { type: "system", selector: "@media (prefers-color-scheme: dark)", matched: this.pattern.test(e2.trim()) };
} }, custom: { resolve(e2) {
  return { type: "custom", selector: e2, matched: true };
} } }, resolve(e2) {
  let t2 = Object.keys(this.rules).filter((r2) => r2 !== "custom").map((r2) => this.rules[r2]);
  return [e2].flat().map((r2) => {
    var s2;
    return (s2 = t2.map((i2) => i2.resolve(r2)).find((i2) => i2.matched)) != null ? s2 : this.rules.custom.resolve(r2);
  });
} }, _toVariables(e2, t2) {
  return de$1(e2, { prefix: t2 == null ? void 0 : t2.prefix });
}, getCommon({ name: e2 = "", theme: t2 = {}, params: r2, set: s2, defaults: i2 }) {
  var R2, T2, j2, O2, M2, z2, V2;
  let { preset: a2, options: n2 } = t2, l2, o2, c2, m2, d2, u2, g2;
  if (s$e(a2) && n2.transform !== "strict") {
    let { primitive: L2, semantic: te2, extend: re2 } = a2, f2 = te2 || {}, { colorScheme: K2 } = f2, A2 = v$4(f2, ["colorScheme"]), x2 = re2 || {}, { colorScheme: X2 } = x2, G2 = v$4(x2, ["colorScheme"]), p2 = K2 || {}, { dark: U2 } = p2, B2 = v$4(p2, ["dark"]), y2 = X2 || {}, { dark: I2 } = y2, H2 = v$4(y2, ["dark"]), W2 = s$e(L2) ? this._toVariables({ primitive: L2 }, n2) : {}, q2 = s$e(A2) ? this._toVariables({ semantic: A2 }, n2) : {}, Z2 = s$e(B2) ? this._toVariables({ light: B2 }, n2) : {}, pe2 = s$e(U2) ? this._toVariables({ dark: U2 }, n2) : {}, fe2 = s$e(G2) ? this._toVariables({ semantic: G2 }, n2) : {}, ye2 = s$e(H2) ? this._toVariables({ light: H2 }, n2) : {}, Se2 = s$e(I2) ? this._toVariables({ dark: I2 }, n2) : {}, [Me2, ze2] = [(R2 = W2.declarations) != null ? R2 : "", W2.tokens], [Ke2, Xe2] = [(T2 = q2.declarations) != null ? T2 : "", q2.tokens || []], [Ge2, Ue2] = [(j2 = Z2.declarations) != null ? j2 : "", Z2.tokens || []], [Be2, Ie2] = [(O2 = pe2.declarations) != null ? O2 : "", pe2.tokens || []], [He2, We2] = [(M2 = fe2.declarations) != null ? M2 : "", fe2.tokens || []], [qe2, Ze2] = [(z2 = ye2.declarations) != null ? z2 : "", ye2.tokens || []], [Fe2, Je2] = [(V2 = Se2.declarations) != null ? V2 : "", Se2.tokens || []];
    l2 = this.transformCSS(e2, Me2, "light", "variable", n2, s2, i2), o2 = ze2;
    let Qe2 = this.transformCSS(e2, `${Ke2}${Ge2}`, "light", "variable", n2, s2, i2), Ye2 = this.transformCSS(e2, `${Be2}`, "dark", "variable", n2, s2, i2);
    c2 = `${Qe2}${Ye2}`, m2 = [.../* @__PURE__ */ new Set([...Xe2, ...Ue2, ...Ie2])];
    let et2 = this.transformCSS(e2, `${He2}${qe2}color-scheme:light`, "light", "variable", n2, s2, i2), tt2 = this.transformCSS(e2, `${Fe2}color-scheme:dark`, "dark", "variable", n2, s2, i2);
    d2 = `${et2}${tt2}`, u2 = [.../* @__PURE__ */ new Set([...We2, ...Ze2, ...Je2])], g2 = m$6(a2.css, { dt: E$2 });
  }
  return { primitive: { css: l2, tokens: o2 }, semantic: { css: c2, tokens: m2 }, global: { css: d2, tokens: u2 }, style: g2 };
}, getPreset({ name: e2 = "", preset: t2 = {}, options: r2, params: s2, set: i2, defaults: a2, selector: n2 }) {
  var f2, x2, p2;
  let l2, o2, c2;
  if (s$e(t2) && r2.transform !== "strict") {
    let y2 = e2.replace("-directive", ""), m2 = t2, { colorScheme: R2, extend: T2, css: j2 } = m2, O2 = v$4(m2, ["colorScheme", "extend", "css"]), d2 = T2 || {}, { colorScheme: M2 } = d2, z2 = v$4(d2, ["colorScheme"]), u2 = R2 || {}, { dark: V2 } = u2, L2 = v$4(u2, ["dark"]), g2 = M2 || {}, { dark: te2 } = g2, re2 = v$4(g2, ["dark"]), K2 = s$e(O2) ? this._toVariables({ [y2]: h$6(h$6({}, O2), z2) }, r2) : {}, A2 = s$e(L2) ? this._toVariables({ [y2]: h$6(h$6({}, L2), re2) }, r2) : {}, X2 = s$e(V2) ? this._toVariables({ [y2]: h$6(h$6({}, V2), te2) }, r2) : {}, [G2, U2] = [(f2 = K2.declarations) != null ? f2 : "", K2.tokens || []], [B2, I2] = [(x2 = A2.declarations) != null ? x2 : "", A2.tokens || []], [H2, W2] = [(p2 = X2.declarations) != null ? p2 : "", X2.tokens || []], q2 = this.transformCSS(y2, `${G2}${B2}`, "light", "variable", r2, i2, a2, n2), Z2 = this.transformCSS(y2, H2, "dark", "variable", r2, i2, a2, n2);
    l2 = `${q2}${Z2}`, o2 = [.../* @__PURE__ */ new Set([...U2, ...I2, ...W2])], c2 = m$6(j2, { dt: E$2 });
  }
  return { css: l2, tokens: o2, style: c2 };
}, getPresetC({ name: e2 = "", theme: t2 = {}, params: r2, set: s2, defaults: i2 }) {
  var o2;
  let { preset: a2, options: n2 } = t2, l2 = (o2 = a2 == null ? void 0 : a2.components) == null ? void 0 : o2[e2];
  return this.getPreset({ name: e2, preset: l2, options: n2, params: r2, set: s2, defaults: i2 });
}, getPresetD({ name: e2 = "", theme: t2 = {}, params: r2, set: s2, defaults: i2 }) {
  var c2, m2;
  let a2 = e2.replace("-directive", ""), { preset: n2, options: l2 } = t2, o2 = ((c2 = n2 == null ? void 0 : n2.components) == null ? void 0 : c2[a2]) || ((m2 = n2 == null ? void 0 : n2.directives) == null ? void 0 : m2[a2]);
  return this.getPreset({ name: a2, preset: o2, options: l2, params: r2, set: s2, defaults: i2 });
}, applyDarkColorScheme(e2) {
  return !(e2.darkModeSelector === "none" || e2.darkModeSelector === false);
}, getColorSchemeOption(e2, t2) {
  var r2;
  return this.applyDarkColorScheme(e2) ? this.regex.resolve(e2.darkModeSelector === true ? t2.options.darkModeSelector : (r2 = e2.darkModeSelector) != null ? r2 : t2.options.darkModeSelector) : [];
}, getLayerOrder(e2, t2 = {}, r2, s2) {
  let { cssLayer: i2 } = t2;
  return i2 ? `@layer ${m$6(i2.order || i2.name || "primeui", r2)}` : "";
}, getCommonStyleSheet({ name: e2 = "", theme: t2 = {}, params: r2, props: s2 = {}, set: i2, defaults: a2 }) {
  let n2 = this.getCommon({ name: e2, theme: t2, params: r2, set: i2, defaults: a2 }), l2 = Object.entries(s2).reduce((o2, [c2, m2]) => o2.push(`${c2}="${m2}"`) && o2, []).join(" ");
  return Object.entries(n2 || {}).reduce((o2, [c2, m2]) => {
    if (i$v(m2) && Object.hasOwn(m2, "css")) {
      let d2 = Y$4(m2.css), u2 = `${c2}-variables`;
      o2.push(`<style type="text/css" data-primevue-style-id="${u2}" ${l2}>${d2}</style>`);
    }
    return o2;
  }, []).join("");
}, getStyleSheet({ name: e2 = "", theme: t2 = {}, params: r2, props: s2 = {}, set: i2, defaults: a2 }) {
  var c2;
  let n2 = { name: e2, theme: t2, params: r2, set: i2, defaults: a2 }, l2 = (c2 = e2.includes("-directive") ? this.getPresetD(n2) : this.getPresetC(n2)) == null ? void 0 : c2.css, o2 = Object.entries(s2).reduce((m2, [d2, u2]) => m2.push(`${d2}="${u2}"`) && m2, []).join(" ");
  return l2 ? `<style type="text/css" data-primevue-style-id="${e2}-variables" ${o2}>${Y$4(l2)}</style>` : "";
}, createTokens(e2 = {}, t2, r2 = "", s2 = "", i2 = {}) {
  let a2 = function(l2, o2 = {}, c2 = []) {
    if (c2.includes(this.path)) return console.warn(`Circular reference detected at ${this.path}`), { colorScheme: l2, path: this.path, paths: o2, value: void 0 };
    c2.push(this.path), o2.name = this.path, o2.binding || (o2.binding = {});
    let m2 = this.value;
    if (typeof this.value == "string" && k$4.test(this.value)) {
      let u2 = this.value.trim().replace(k$4, (g2) => {
        var y2;
        let f2 = g2.slice(1, -1), x2 = this.tokens[f2];
        if (!x2) return console.warn(`Token not found for path: ${f2}`), "__UNRESOLVED__";
        let p2 = x2.computed(l2, o2, c2);
        return Array.isArray(p2) && p2.length === 2 ? `light-dark(${p2[0].value},${p2[1].value})` : (y2 = p2 == null ? void 0 : p2.value) != null ? y2 : "__UNRESOLVED__";
      });
      m2 = ne$1.test(u2.replace(ie$1, "0")) ? `calc(${u2})` : u2;
    }
    return l$j(o2.binding) && delete o2.binding, c2.pop(), { colorScheme: l2, path: this.path, paths: o2, value: m2.includes("__UNRESOLVED__") ? void 0 : m2 };
  }, n2 = (l2, o2, c2) => {
    Object.entries(l2).forEach(([m2, d2]) => {
      let u2 = G$2(m2, t2.variable.excludedKeyRegex) ? o2 : o2 ? `${o2}.${oe$1(m2)}` : oe$1(m2), g2 = c2 ? `${c2}.${m2}` : m2;
      i$v(d2) ? n2(d2, u2, g2) : (i2[u2] || (i2[u2] = { paths: [], computed: (f2, x2 = {}, p2 = []) => {
        if (i2[u2].paths.length === 1) return i2[u2].paths[0].computed(i2[u2].paths[0].scheme, x2.binding, p2);
        if (f2 && f2 !== "none") for (let y2 = 0; y2 < i2[u2].paths.length; y2++) {
          let R2 = i2[u2].paths[y2];
          if (R2.scheme === f2) return R2.computed(f2, x2.binding, p2);
        }
        return i2[u2].paths.map((y2) => y2.computed(y2.scheme, x2[y2.scheme], p2));
      } }), i2[u2].paths.push({ path: g2, value: d2, scheme: g2.includes("colorScheme.light") ? "light" : g2.includes("colorScheme.dark") ? "dark" : "none", computed: a2, tokens: i2 }));
    });
  };
  return n2(e2, r2, s2), i2;
}, getTokenValue(e2, t2, r2) {
  var l2;
  let i2 = ((o2) => o2.split(".").filter((m2) => !G$2(m2.toLowerCase(), r2.variable.excludedKeyRegex)).join("."))(t2), a2 = t2.includes("colorScheme.light") ? "light" : t2.includes("colorScheme.dark") ? "dark" : void 0, n2 = [(l2 = e2[i2]) == null ? void 0 : l2.computed(a2)].flat().filter((o2) => o2);
  return n2.length === 1 ? n2[0].value : n2.reduce((o2 = {}, c2) => {
    let u2 = c2, { colorScheme: m2 } = u2, d2 = v$4(u2, ["colorScheme"]);
    return o2[m2] = d2, o2;
  }, void 0);
}, getSelectorRule(e2, t2, r2, s2) {
  return r2 === "class" || r2 === "attr" ? C$3(s$e(t2) ? `${e2}${t2},${e2} ${t2}` : e2, s2) : C$3(e2, C$3(t2 != null ? t2 : ":root,:host", s2));
}, transformCSS(e2, t2, r2, s2, i2 = {}, a2, n2, l2) {
  if (s$e(t2)) {
    let { cssLayer: o2 } = i2;
    if (s2 !== "style") {
      let c2 = this.getColorSchemeOption(i2, n2);
      t2 = r2 === "dark" ? c2.reduce((m2, { type: d2, selector: u2 }) => (s$e(u2) && (m2 += u2.includes("[CSS]") ? u2.replace("[CSS]", t2) : this.getSelectorRule(u2, l2, d2, t2)), m2), "") : C$3(l2 != null ? l2 : ":root,:host", t2);
    }
    if (o2) {
      let c2 = { name: "primeui" };
      i$v(o2) && (c2.name = m$6(o2.name, { name: e2, type: s2 })), s$e(c2.name) && (t2 = C$3(`@layer ${c2.name}`, t2), a2 == null || a2.layerNames(c2.name));
    }
    return t2;
  }
  return "";
} };
var S$2 = { defaults: { variable: { prefix: "p", selector: ":root,:host", excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi }, options: { prefix: "p", darkModeSelector: "system", cssLayer: false } }, _theme: void 0, _layerNames: /* @__PURE__ */ new Set(), _loadedStyleNames: /* @__PURE__ */ new Set(), _loadingStyles: /* @__PURE__ */ new Set(), _tokens: {}, update(e2 = {}) {
  let { theme: t2 } = e2;
  t2 && (this._theme = $$2(h$6({}, t2), { options: h$6(h$6({}, this.defaults.options), t2.options) }), this._tokens = b$6.createTokens(this.preset, this.defaults), this.clearLoadedStyleNames());
}, get theme() {
  return this._theme;
}, get preset() {
  var e2;
  return ((e2 = this.theme) == null ? void 0 : e2.preset) || {};
}, get options() {
  var e2;
  return ((e2 = this.theme) == null ? void 0 : e2.options) || {};
}, get tokens() {
  return this._tokens;
}, getTheme() {
  return this.theme;
}, setTheme(e2) {
  this.update({ theme: e2 }), N$2.emit("theme:change", e2);
}, getPreset() {
  return this.preset;
}, setPreset(e2) {
  this._theme = $$2(h$6({}, this.theme), { preset: e2 }), this._tokens = b$6.createTokens(e2, this.defaults), this.clearLoadedStyleNames(), N$2.emit("preset:change", e2), N$2.emit("theme:change", this.theme);
}, getOptions() {
  return this.options;
}, setOptions(e2) {
  this._theme = $$2(h$6({}, this.theme), { options: e2 }), this.clearLoadedStyleNames(), N$2.emit("options:change", e2), N$2.emit("theme:change", this.theme);
}, getLayerNames() {
  return [...this._layerNames];
}, setLayerNames(e2) {
  this._layerNames.add(e2);
}, getLoadedStyleNames() {
  return this._loadedStyleNames;
}, isStyleNameLoaded(e2) {
  return this._loadedStyleNames.has(e2);
}, setLoadedStyleName(e2) {
  this._loadedStyleNames.add(e2);
}, deleteLoadedStyleName(e2) {
  this._loadedStyleNames.delete(e2);
}, clearLoadedStyleNames() {
  this._loadedStyleNames.clear();
}, getTokenValue(e2) {
  return b$6.getTokenValue(this.tokens, e2, this.defaults);
}, getCommon(e2 = "", t2) {
  return b$6.getCommon({ name: e2, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getComponent(e2 = "", t2) {
  let r2 = { name: e2, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b$6.getPresetC(r2);
}, getDirective(e2 = "", t2) {
  let r2 = { name: e2, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b$6.getPresetD(r2);
}, getCustomPreset(e2 = "", t2, r2, s2) {
  let i2 = { name: e2, preset: t2, options: this.options, selector: r2, params: s2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b$6.getPreset(i2);
}, getLayerOrderCSS(e2 = "") {
  return b$6.getLayerOrder(e2, this.options, { names: this.getLayerNames() }, this.defaults);
}, transformCSS(e2 = "", t2, r2 = "style", s2) {
  return b$6.transformCSS(e2, t2, s2, r2, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
}, getCommonStyleSheet(e2 = "", t2, r2 = {}) {
  return b$6.getCommonStyleSheet({ name: e2, theme: this.theme, params: t2, props: r2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getStyleSheet(e2, t2, r2 = {}) {
  return b$6.getStyleSheet({ name: e2, theme: this.theme, params: t2, props: r2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, onStyleMounted(e2) {
  this._loadingStyles.add(e2);
}, onStyleUpdated(e2) {
  this._loadingStyles.add(e2);
}, onStyleLoaded(e2, { name: t2 }) {
  this._loadingStyles.size && (this._loadingStyles.delete(t2), N$2.emit(`theme:${t2}:load`, e2), !this._loadingStyles.size && N$2.emit("theme:load"));
} };
var o$1n = { transitionDuration: "{transition.duration}" }, r$1k = { borderWidth: "0", borderColor: "{content.border.color}" }, e$W = { color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{text.color}", activeHoverColor: "{text.color}", padding: "1.125rem", fontWeight: "700", borderRadius: "0", borderWidth: "0 1px 1px 1px", borderColor: "{content.border.color}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" }, toggleIcon: { color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{text.color}", activeHoverColor: "{text.color}" }, first: { topBorderRadius: "{content.border.radius}", borderWidth: "1px" }, last: { bottomBorderRadius: "{content.border.radius}", activeBottomBorderRadius: "0" } }, t$E = { borderWidth: "0 1px 1px 1px", borderColor: "{content.border.color}", background: "{content.background}", color: "{text.color}", padding: "1.125rem" }, c$y = { light: { header: { background: "{surface.50}", hoverBackground: "{surface.100}", activeBackground: "{surface.50}", activeHoverBackground: "{surface.100}" } }, dark: { header: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.800}", activeHoverBackground: "{surface.700}" } } }, d$D = { root: o$1n, panel: r$1k, header: e$W, content: t$E, colorScheme: c$y };
var o$1m = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}" }, r$1j = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, d$C = { padding: "{list.padding}", gap: "{list.gap}" }, e$V = { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}" }, l$i = { background: "{list.option.group.background}", color: "{list.option.group.color}", fontWeight: "{list.option.group.font.weight}", padding: "{list.option.group.padding}" }, i$u = { width: "2.5rem", sm: { width: "2rem" }, lg: { width: "3rem" }, borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.border.color}", activeBorderColor: "{form.field.border.color}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" } }, c$x = { borderRadius: "{border.radius.sm}" }, f$b = { padding: "{list.option.padding}" }, s$b = { light: { chip: { focusBackground: "{surface.200}", focusColor: "{surface.800}" }, dropdown: { background: "{surface.50}", hoverBackground: "{surface.100}", activeBackground: "{surface.200}", color: "{surface.600}", hoverColor: "{surface.700}", activeColor: "{surface.800}" } }, dark: { chip: { focusBackground: "{surface.700}", focusColor: "{surface.0}" }, dropdown: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.600}", color: "{surface.300}", hoverColor: "{surface.200}", activeColor: "{surface.100}" } } }, a$I = { root: o$1m, overlay: r$1j, list: d$C, option: e$V, optionGroup: l$i, dropdown: i$u, chip: c$x, emptyMessage: f$b, colorScheme: s$b };
var e$U = { width: "2rem", height: "2rem", fontSize: "1rem", background: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}" }, r$1i = { size: "1rem" }, o$1l = { borderColor: "{content.background}", offset: "-0.75rem" }, t$D = { width: "3rem", height: "3rem", fontSize: "1.5rem", icon: { size: "1.5rem" }, group: { offset: "-1rem" } }, i$t = { width: "4rem", height: "4rem", fontSize: "2rem", icon: { size: "2rem" }, group: { offset: "-1.5rem" } }, n$A = { root: e$U, icon: r$1i, group: o$1l, lg: t$D, xl: i$t };
var r$1h = { borderRadius: "{border.radius.md}", padding: "0 0.5rem", fontSize: "0.75rem", fontWeight: "700", minWidth: "1.5rem", height: "1.5rem" }, o$1k = { size: "0.5rem" }, e$T = { fontSize: "0.625rem", minWidth: "1.25rem", height: "1.25rem" }, c$w = { fontSize: "0.875rem", minWidth: "1.75rem", height: "1.75rem" }, a$H = { fontSize: "1rem", minWidth: "2rem", height: "2rem" }, n$z = { light: { primary: { background: "{primary.color}", color: "{primary.contrast.color}" }, secondary: { background: "{surface.100}", color: "{surface.600}" }, success: { background: "{green.500}", color: "{surface.0}" }, info: { background: "{sky.500}", color: "{surface.0}" }, warn: { background: "{orange.500}", color: "{surface.0}" }, danger: { background: "{red.500}", color: "{surface.0}" }, contrast: { background: "{surface.950}", color: "{surface.0}" } }, dark: { primary: { background: "{primary.color}", color: "{primary.contrast.color}" }, secondary: { background: "{surface.800}", color: "{surface.300}" }, success: { background: "{green.400}", color: "{green.950}" }, info: { background: "{sky.400}", color: "{sky.950}" }, warn: { background: "{orange.400}", color: "{orange.950}" }, danger: { background: "{red.400}", color: "{red.950}" }, contrast: { background: "{surface.0}", color: "{surface.950}" } } }, d$B = { root: r$1h, dot: o$1k, sm: e$T, lg: c$w, xl: a$H, colorScheme: n$z };
var o$1j = { borderRadius: { none: "0", xs: "2px", sm: "4px", md: "6px", lg: "8px", xl: "12px" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" } }, r$1g = { transitionDuration: "0.2s", focusRing: { width: "0", style: "none", color: "transparent", offset: "0" }, disabledOpacity: "0.6", iconSize: "1rem", anchorGutter: "2px", primary: { 50: "{emerald.50}", 100: "{emerald.100}", 200: "{emerald.200}", 300: "{emerald.300}", 400: "{emerald.400}", 500: "{emerald.500}", 600: "{emerald.600}", 700: "{emerald.700}", 800: "{emerald.800}", 900: "{emerald.900}", 950: "{emerald.950}" }, formField: { paddingX: "0.75rem", paddingY: "0.625rem", sm: { fontSize: "0.875rem", paddingX: "0.625rem", paddingY: "0.5rem" }, lg: { fontSize: "1.125rem", paddingX: "0.875rem", paddingY: "0.75rem" }, borderRadius: "{border.radius.md}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" }, transitionDuration: "{transition.duration}" }, list: { padding: "0.5rem 0", gap: "0", header: { padding: "0.625rem 1rem 0 1rem" }, option: { padding: "0.625rem 1rem", borderRadius: "0" }, optionGroup: { padding: "0.625rem 1rem", fontWeight: "600" } }, content: { borderRadius: "{border.radius.md}" }, mask: { transitionDuration: "0.3s" }, navigation: { list: { padding: "0.5rem 0", gap: "0" }, item: { padding: "0.625rem 1rem", borderRadius: "0", gap: "0.5rem" }, submenuLabel: { padding: "0.625rem 1rem", fontWeight: "600" }, submenuIcon: { size: "0.875rem" } }, overlay: { select: { borderRadius: "{border.radius.md}", shadow: "0 2px 12px 0 rgba(0, 0, 0, 0.1)" }, popover: { borderRadius: "{border.radius.md}", padding: "1rem", shadow: "0 1px 3px rgba(0, 0, 0, 0.1)" }, modal: { borderRadius: "{border.radius.xl}", padding: "1.5rem", shadow: "0 1px 3px rgba(0, 0, 0, 0.3)" }, navigation: { shadow: "0 2px 12px 0 rgba(0, 0, 0, 0.1)" } }, colorScheme: { light: { surface: { 0: "#ffffff", 50: "{slate.50}", 100: "{slate.100}", 200: "{slate.200}", 300: "{slate.300}", 400: "{slate.400}", 500: "{slate.500}", 600: "{slate.600}", 700: "{slate.700}", 800: "{slate.800}", 900: "{slate.900}", 950: "{slate.950}" }, primary: { color: "{primary.500}", contrastColor: "#ffffff", hoverColor: "{primary.600}", activeColor: "{primary.700}" }, highlight: { background: "{primary.50}", focusBackground: "{primary.100}", color: "{primary.700}", focusColor: "{primary.800}" }, focusRing: { shadow: "0 0 0 0.2rem {primary.200}" }, mask: { background: "rgba(0,0,0,0.4)", color: "{surface.200}" }, formField: { background: "{surface.0}", disabledBackground: "{surface.200}", filledBackground: "{surface.50}", filledHoverBackground: "{surface.50}", filledFocusBackground: "{surface.0}", borderColor: "{surface.300}", hoverBorderColor: "{primary.color}", focusBorderColor: "{primary.color}", invalidBorderColor: "{red.400}", color: "{surface.700}", disabledColor: "{surface.500}", placeholderColor: "{surface.500}", invalidPlaceholderColor: "{red.600}", floatLabelColor: "{surface.500}", floatLabelFocusColor: "{primary.600}", floatLabelActiveColor: "{surface.500}", floatLabelInvalidColor: "{form.field.invalid.placeholder.color}", iconColor: "{surface.500}", shadow: "none" }, text: { color: "{surface.700}", hoverColor: "{surface.800}", mutedColor: "{surface.500}", hoverMutedColor: "{surface.600}" }, content: { background: "{surface.0}", hoverBackground: "{surface.100}", borderColor: "{surface.200}", color: "{text.color}", hoverColor: "{text.hover.color}" }, overlay: { select: { background: "{surface.0}", borderColor: "{surface.200}", color: "{text.color}" }, popover: { background: "{surface.0}", borderColor: "{surface.200}", color: "{text.color}" }, modal: { background: "{surface.0}", borderColor: "{surface.200}", color: "{text.color}" } }, list: { option: { focusBackground: "{surface.100}", selectedBackground: "{highlight.background}", selectedFocusBackground: "{highlight.focus.background}", color: "{text.color}", focusColor: "{text.hover.color}", selectedColor: "{highlight.color}", selectedFocusColor: "{highlight.focus.color}", icon: { color: "{surface.400}", focusColor: "{surface.500}" } }, optionGroup: { background: "transparent", color: "{text.color}" } }, navigation: { item: { focusBackground: "{surface.100}", activeBackground: "{surface.100}", color: "{text.color}", focusColor: "{text.hover.color}", activeColor: "{text.hover.color}", icon: { color: "{surface.400}", focusColor: "{surface.500}", activeColor: "{surface.500}" } }, submenuLabel: { background: "transparent", color: "{text.color}" }, submenuIcon: { color: "{surface.400}", focusColor: "{surface.500}", activeColor: "{surface.500}" } } }, dark: { surface: { 0: "#ffffff", 50: "{zinc.50}", 100: "{zinc.100}", 200: "{zinc.200}", 300: "{zinc.300}", 400: "{zinc.400}", 500: "{zinc.500}", 600: "{zinc.600}", 700: "{zinc.700}", 800: "{zinc.800}", 900: "{zinc.900}", 950: "{zinc.950}" }, primary: { color: "{primary.400}", contrastColor: "{surface.900}", hoverColor: "{primary.300}", activeColor: "{primary.200}" }, highlight: { background: "color-mix(in srgb, {primary.400}, transparent 84%)", focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)", color: "rgba(255,255,255,.87)", focusColor: "rgba(255,255,255,.87)" }, focusRing: { shadow: "0 0 0 0.2rem color-mix(in srgb, {primary.color}, transparent 80%)" }, mask: { background: "rgba(0,0,0,0.6)", color: "{surface.200}" }, formField: { background: "{surface.950}", disabledBackground: "{surface.700}", filledBackground: "{surface.800}", filledHoverBackground: "{surface.800}", filledFocusBackground: "{surface.950}", borderColor: "{surface.600}", hoverBorderColor: "{primary.color}", focusBorderColor: "{primary.color}", invalidBorderColor: "{red.300}", color: "{surface.0}", disabledColor: "{surface.400}", placeholderColor: "{surface.400}", invalidPlaceholderColor: "{red.400}", floatLabelColor: "{surface.400}", floatLabelFocusColor: "{primary.color}", floatLabelActiveColor: "{surface.400}", floatLabelInvalidColor: "{form.field.invalid.placeholder.color}", iconColor: "{surface.400}", shadow: "none" }, text: { color: "{surface.0}", hoverColor: "{surface.0}", mutedColor: "{surface.400}", hoverMutedColor: "{surface.300}" }, content: { background: "{surface.900}", hoverBackground: "{surface.800}", borderColor: "{surface.700}", color: "{text.color}", hoverColor: "{text.hover.color}" }, overlay: { select: { background: "{surface.900}", borderColor: "{surface.700}", color: "{text.color}" }, popover: { background: "{surface.900}", borderColor: "{surface.700}", color: "{text.color}" }, modal: { background: "{surface.900}", borderColor: "{surface.700}", color: "{text.color}" } }, list: { option: { focusBackground: "{surface.800}", selectedBackground: "{highlight.background}", selectedFocusBackground: "{highlight.focus.background}", color: "{text.color}", focusColor: "{text.hover.color}", selectedColor: "{highlight.color}", selectedFocusColor: "{highlight.focus.color}", icon: { color: "{surface.500}", focusColor: "{surface.400}" } }, optionGroup: { background: "transparent", color: "{text.color}" } }, navigation: { item: { focusBackground: "{surface.800}", activeBackground: "{surface.800}", color: "{text.color}", focusColor: "{text.hover.color}", activeColor: "{text.hover.color}", icon: { color: "{surface.500}", focusColor: "{surface.400}", activeColor: "{surface.400}" } }, submenuLabel: { background: "transparent", color: "{text.color}" }, submenuIcon: { color: "{surface.500}", focusColor: "{surface.400}", activeColor: "{surface.400}" } } } } }, e$S = { primitive: o$1j, semantic: r$1g };
var r$1f = { borderRadius: "{content.border.radius}" }, o$1i = { root: r$1f };
var o$1h = { padding: "1.25rem", background: "{content.background}", gap: "0.5rem", transitionDuration: "{transition.duration}" }, r$1e = { color: "{text.muted.color}", hoverColor: "{text.color}", borderRadius: "{content.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", hoverColor: "{navigation.item.icon.focus.color}" }, focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, i$s = { color: "{navigation.item.icon.color}" }, t$C = { root: o$1h, item: r$1e, separator: i$s };
var r$1d = { borderRadius: "{form.field.border.radius}", roundedBorderRadius: "2rem", gap: "0.5rem", paddingX: "1rem", paddingY: "{form.field.padding.y}", iconOnlyWidth: "2.75rem", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}", iconOnlyWidth: "2.25rem" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}", iconOnlyWidth: "3.25rem" }, label: { fontWeight: "600" }, raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", offset: "{form.field.focus.ring.offset}" }, badgeSize: "1rem", transitionDuration: "{form.field.transition.duration}" }, o$1g = { light: { root: { primary: { background: "{primary.color}", hoverBackground: "{primary.hover.color}", activeBackground: "{primary.active.color}", borderColor: "{primary.color}", hoverBorderColor: "{primary.hover.color}", activeBorderColor: "{primary.active.color}", color: "{primary.contrast.color}", hoverColor: "{primary.contrast.color}", activeColor: "{primary.contrast.color}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {primary.200}" } }, secondary: { background: "{surface.100}", hoverBackground: "{surface.200}", activeBackground: "{surface.300}", borderColor: "{surface.100}", hoverBorderColor: "{surface.200}", activeBorderColor: "{surface.300}", color: "{surface.600}", hoverColor: "{surface.700}", activeColor: "{surface.800}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {surface.200}" } }, info: { background: "{sky.500}", hoverBackground: "{sky.600}", activeBackground: "{sky.700}", borderColor: "{sky.500}", hoverBorderColor: "{sky.600}", activeBorderColor: "{sky.700}", color: "#ffffff", hoverColor: "#ffffff", activeColor: "#ffffff", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {sky.200}" } }, success: { background: "{green.500}", hoverBackground: "{green.600}", activeBackground: "{green.700}", borderColor: "{green.500}", hoverBorderColor: "{green.600}", activeBorderColor: "{green.700}", color: "#ffffff", hoverColor: "#ffffff", activeColor: "#ffffff", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {green.200}" } }, warn: { background: "{orange.500}", hoverBackground: "{orange.600}", activeBackground: "{orange.700}", borderColor: "{orange.500}", hoverBorderColor: "{orange.600}", activeBorderColor: "{orange.700}", color: "#ffffff", hoverColor: "#ffffff", activeColor: "#ffffff", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {orange.200}" } }, help: { background: "{purple.500}", hoverBackground: "{purple.600}", activeBackground: "{purple.700}", borderColor: "{purple.500}", hoverBorderColor: "{purple.600}", activeBorderColor: "{purple.700}", color: "#ffffff", hoverColor: "#ffffff", activeColor: "#ffffff", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {purple.200}" } }, danger: { background: "{red.500}", hoverBackground: "{red.600}", activeBackground: "{red.700}", borderColor: "{red.500}", hoverBorderColor: "{red.600}", activeBorderColor: "{red.700}", color: "#ffffff", hoverColor: "#ffffff", activeColor: "#ffffff", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {red.200}" } }, contrast: { background: "{surface.950}", hoverBackground: "{surface.900}", activeBackground: "{surface.800}", borderColor: "{surface.950}", hoverBorderColor: "{surface.900}", activeBorderColor: "{surface.800}", color: "{surface.0}", hoverColor: "{surface.0}", activeColor: "{surface.0}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem {surface.400}" } } }, outlined: { primary: { hoverBackground: "{primary.50}", activeBackground: "{primary.100}", borderColor: "{primary.200}", color: "{primary.color}" }, secondary: { hoverBackground: "{surface.50}", activeBackground: "{surface.100}", borderColor: "{surface.200}", color: "{surface.500}" }, success: { hoverBackground: "{green.50}", activeBackground: "{green.100}", borderColor: "{green.200}", color: "{green.500}" }, info: { hoverBackground: "{sky.50}", activeBackground: "{sky.100}", borderColor: "{sky.200}", color: "{sky.500}" }, warn: { hoverBackground: "{orange.50}", activeBackground: "{orange.100}", borderColor: "{orange.200}", color: "{orange.500}" }, help: { hoverBackground: "{purple.50}", activeBackground: "{purple.100}", borderColor: "{purple.200}", color: "{purple.500}" }, danger: { hoverBackground: "{red.50}", activeBackground: "{red.100}", borderColor: "{red.200}", color: "{red.500}" }, contrast: { hoverBackground: "{surface.50}", activeBackground: "{surface.100}", borderColor: "{surface.700}", color: "{surface.950}" }, plain: { hoverBackground: "{surface.50}", activeBackground: "{surface.100}", borderColor: "{surface.200}", color: "{surface.700}" } }, text: { primary: { hoverBackground: "{primary.50}", activeBackground: "{primary.100}", color: "{primary.color}" }, secondary: { hoverBackground: "{surface.100}", activeBackground: "{surface.200}", color: "{surface.600}" }, success: { hoverBackground: "{green.50}", activeBackground: "{green.100}", color: "{green.500}" }, info: { hoverBackground: "{sky.50}", activeBackground: "{sky.100}", color: "{sky.500}" }, warn: { hoverBackground: "{orange.50}", activeBackground: "{orange.100}", color: "{orange.500}" }, help: { hoverBackground: "{purple.50}", activeBackground: "{purple.100}", color: "{purple.500}" }, danger: { hoverBackground: "{red.50}", activeBackground: "{red.100}", color: "{red.500}" }, contrast: { hoverBackground: "{surface.50}", activeBackground: "{surface.100}", color: "{surface.950}" }, plain: { hoverBackground: "{surface.50}", activeBackground: "{surface.100}", color: "{surface.700}" } }, link: { color: "{primary.color}", hoverColor: "{primary.color}", activeColor: "{primary.color}" } }, dark: { root: { primary: { background: "{primary.color}", hoverBackground: "{primary.hover.color}", activeBackground: "{primary.active.color}", borderColor: "{primary.color}", hoverBorderColor: "{primary.hover.color}", activeBorderColor: "{primary.active.color}", color: "{primary.contrast.color}", hoverColor: "{primary.contrast.color}", activeColor: "{primary.contrast.color}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {primary.color}, transparent 80%)" } }, secondary: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.600}", borderColor: "{surface.800}", hoverBorderColor: "{surface.700}", activeBorderColor: "{surface.600}", color: "{surface.300}", hoverColor: "{surface.200}", activeColor: "{surface.100}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.300}, transparent 80%)" } }, info: { background: "{sky.400}", hoverBackground: "{sky.300}", activeBackground: "{sky.200}", borderColor: "{sky.400}", hoverBorderColor: "{sky.300}", activeBorderColor: "{sky.200}", color: "{sky.950}", hoverColor: "{sky.950}", activeColor: "{sky.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {sky.400}, transparent 80%)" } }, success: { background: "{green.400}", hoverBackground: "{green.300}", activeBackground: "{green.200}", borderColor: "{green.400}", hoverBorderColor: "{green.300}", activeBorderColor: "{green.200}", color: "{green.950}", hoverColor: "{green.950}", activeColor: "{green.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {green.400}, transparent 80%)" } }, warn: { background: "{orange.400}", hoverBackground: "{orange.300}", activeBackground: "{orange.200}", borderColor: "{orange.400}", hoverBorderColor: "{orange.300}", activeBorderColor: "{orange.200}", color: "{orange.950}", hoverColor: "{orange.950}", activeColor: "{orange.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {orange.400}, transparent 80%)" } }, help: { background: "{purple.400}", hoverBackground: "{purple.300}", activeBackground: "{purple.200}", borderColor: "{purple.400}", hoverBorderColor: "{purple.300}", activeBorderColor: "{purple.200}", color: "{purple.950}", hoverColor: "{purple.950}", activeColor: "{purple.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {purple.400}, transparent 80%)" } }, danger: { background: "{red.400}", hoverBackground: "{red.300}", activeBackground: "{red.200}", borderColor: "{red.400}", hoverBorderColor: "{red.300}", activeBorderColor: "{red.200}", color: "{red.950}", hoverColor: "{red.950}", activeColor: "{red.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {red.400}, transparent 80%)" } }, contrast: { background: "{surface.0}", hoverBackground: "{surface.100}", activeBackground: "{surface.200}", borderColor: "{surface.0}", hoverBorderColor: "{surface.100}", activeBorderColor: "{surface.200}", color: "{surface.950}", hoverColor: "{surface.950}", activeColor: "{surface.950}", focusRing: { color: "transparent", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.0}, transparent 80%)" } } }, outlined: { primary: { hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)", activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)", borderColor: "{primary.700}", color: "{primary.color}" }, secondary: { hoverBackground: "rgba(255,255,255,0.04)", activeBackground: "rgba(255,255,255,0.16)", borderColor: "{surface.700}", color: "{surface.400}" }, success: { hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)", borderColor: "{green.700}", color: "{green.400}" }, info: { hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)", borderColor: "{sky.700}", color: "{sky.400}" }, warn: { hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)", borderColor: "{orange.700}", color: "{orange.400}" }, help: { hoverBackground: "color-mix(in srgb, {help.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {help.400}, transparent 84%)", borderColor: "{purple.700}", color: "{purple.400}" }, danger: { hoverBackground: "color-mix(in srgb, {danger.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {danger.400}, transparent 84%)", borderColor: "{red.700}", color: "{red.400}" }, contrast: { hoverBackground: "{surface.800}", activeBackground: "{surface.700}", borderColor: "{surface.500}", color: "{surface.0}" }, plain: { hoverBackground: "{surface.800}", activeBackground: "{surface.700}", borderColor: "{surface.600}", color: "{surface.0}" } }, text: { primary: { hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)", activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)", color: "{primary.color}" }, secondary: { hoverBackground: "{surface.700}", activeBackground: "{surface.600}", color: "{surface.300}" }, success: { hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)", color: "{green.400}" }, info: { hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)", color: "{sky.400}" }, warn: { hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)", color: "{orange.400}" }, help: { hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)", color: "{purple.400}" }, danger: { hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)", activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)", color: "{red.400}" }, contrast: { hoverBackground: "{surface.800}", activeBackground: "{surface.700}", color: "{surface.0}" }, plain: { hoverBackground: "{surface.800}", activeBackground: "{surface.700}", color: "{surface.0}" } }, link: { color: "{primary.color}", hoverColor: "{primary.color}", activeColor: "{primary.color}" } } }, e$R = { root: r$1d, colorScheme: o$1g };
var o$1f = { background: "{content.background}", borderRadius: "{border.radius.lg}", color: "{content.color}", shadow: "0 .125rem .25rem rgba(0,0,0,.075)" }, r$1c = { padding: "1.5rem", gap: "0.75rem" }, e$Q = { gap: "0.5rem" }, t$B = { fontSize: "1.25rem", fontWeight: "700" }, a$G = { color: "{text.muted.color}" }, d$A = { root: o$1f, body: r$1c, caption: e$Q, title: t$B, subtitle: a$G };
var r$1b = { transitionDuration: "{transition.duration}" }, o$1e = { gap: "0.25rem" }, a$F = { padding: "1rem", gap: "0.5rem" }, i$r = { width: "1rem", height: "1rem", borderRadius: "50", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, c$v = { light: { indicator: { background: "{surface.200}", hoverBackground: "{surface.300}", activeBackground: "{primary.color}" } }, dark: { indicator: { background: "{surface.700}", hoverBackground: "{surface.600}", activeBackground: "{primary.color}" } } }, t$A = { root: r$1b, content: o$1e, indicatorList: a$F, indicator: i$r, colorScheme: c$v };
var o$1d = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, r$1a = { width: "2.5rem", color: "{form.field.icon.color}" }, d$z = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, l$h = { padding: "{list.padding}", gap: "{list.gap}", mobileIndent: "1.25rem" }, e$P = { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}", icon: { color: "{list.option.icon.color}", focusColor: "{list.option.icon.focus.color}", size: "0.875rem" } }, i$q = { color: "{form.field.icon.color}" }, f$a = { root: o$1d, dropdown: r$1a, overlay: d$z, list: l$h, option: e$P, clearIcon: i$q };
var o$1c = { borderRadius: "{border.radius.sm}", width: "1.5rem", height: "1.5rem", background: "{form.field.background}", checkedBackground: "{primary.color}", checkedHoverBackground: "{primary.hover.color}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", checkedBorderColor: "{primary.color}", checkedHoverBorderColor: "{primary.hover.color}", checkedFocusBorderColor: "{primary.color}", checkedDisabledBorderColor: "{form.field.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", shadow: "{form.field.shadow}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { width: "1.25rem", height: "1.25rem" }, lg: { width: "1.75rem", height: "1.75rem" } }, r$19 = { size: "1rem", color: "{form.field.color}", checkedColor: "{primary.contrast.color}", checkedHoverColor: "{primary.contrast.color}", disabledColor: "{form.field.disabled.color}", sm: { size: "0.75rem" }, lg: { size: "1.25rem" } }, e$O = { root: o$1c, icon: r$19 };
var o$1b = { borderRadius: "16px", paddingX: "0.875rem", paddingY: "0.625rem", gap: "0.5rem", transitionDuration: "{transition.duration}" }, r$18 = { width: "2rem", height: "2rem" }, e$N = { size: "1rem" }, c$u = { size: "1rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, i$p = { light: { root: { background: "{surface.100}", color: "{surface.800}" }, icon: { color: "{surface.800}" }, removeIcon: { color: "{surface.800}" } }, dark: { root: { background: "{surface.800}", color: "{surface.0}" }, icon: { color: "{surface.0}" }, removeIcon: { color: "{surface.0}" } } }, s$a = { root: o$1b, image: r$18, icon: e$N, removeIcon: c$u, colorScheme: i$p };
var r$17 = { transitionDuration: "{transition.duration}" }, o$1a = { width: "1.75rem", height: "1.75rem", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" } }, e$M = { shadow: "{overlay.popover.shadow}", borderRadius: "{overlay.popover.borderRadius}" }, a$E = { light: { panel: { background: "{surface.800}", borderColor: "{surface.900}" }, handle: { color: "{surface.0}" } }, dark: { panel: { background: "{surface.900}", borderColor: "{surface.700}" }, handle: { color: "{surface.0}" } } }, d$y = { root: r$17, preview: o$1a, panel: e$M, colorScheme: a$E };
var o$19 = { size: "2rem", color: "{overlay.modal.color}" }, e$L = { gap: "1rem" }, r$16 = { icon: o$19, content: e$L };
var o$18 = { background: "{overlay.popover.background}", borderColor: "{overlay.popover.border.color}", color: "{overlay.popover.color}", borderRadius: "{overlay.popover.border.radius}", shadow: "{overlay.popover.shadow}", gutter: "10px", arrowOffset: "1.25rem" }, r$15 = { padding: "{overlay.popover.padding}", gap: "1rem" }, e$K = { size: "1.5rem", color: "{overlay.popover.color}" }, p$5 = { gap: "0.5rem", padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}" }, a$D = { root: o$18, content: r$15, icon: e$K, footer: p$5 };
var o$17 = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}", shadow: "{overlay.navigation.shadow}", transitionDuration: "{transition.duration}" }, i$o = { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}" }, n$y = { focusBackground: "{navigation.item.focus.background}", activeBackground: "{navigation.item.active.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", activeColor: "{navigation.item.active.color}", padding: "{navigation.item.padding}", borderRadius: "{navigation.item.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}", activeColor: "{navigation.item.icon.active.color}" } }, a$C = { mobileIndent: "1.25rem" }, t$z = { size: "{navigation.submenu.icon.size}", color: "{navigation.submenu.icon.color}", focusColor: "{navigation.submenu.icon.focus.color}", activeColor: "{navigation.submenu.icon.active.color}" }, r$14 = { borderColor: "{content.border.color}" }, c$t = { root: o$17, list: i$o, item: n$y, submenu: a$C, submenuIcon: t$z, separator: r$14 };
var o$16 = { transitionDuration: "{transition.duration}" }, r$13 = { borderColor: "{datatable.border.color}", borderWidth: "1px 0 1px 0", padding: "0.75rem 1rem", sm: { padding: "0.375rem 0.5rem" }, lg: { padding: "1rem 1.25rem" } }, e$J = { selectedBackground: "{highlight.background}", borderColor: "{datatable.border.color}", hoverColor: "{content.hover.color}", selectedColor: "{highlight.color}", gap: "0.5rem", padding: "0.75rem 1rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" }, sm: { padding: "0.375rem 0.5rem" }, lg: { padding: "1rem 1.25rem" } }, d$x = { fontWeight: "700" }, l$g = { background: "{content.background}", hoverBackground: "{content.hover.background}", selectedBackground: "{highlight.background}", color: "{content.color}", hoverColor: "{content.hover.color}", selectedColor: "{highlight.color}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, c$s = { borderColor: "{datatable.border.color}", padding: "0.75rem 1rem", sm: { padding: "0.375rem 0.5rem" }, lg: { padding: "1rem 1.25rem" } }, t$y = { borderColor: "{datatable.border.color}", padding: "0.75rem 1rem", sm: { padding: "0.375rem 0.5rem" }, lg: { padding: "1rem 1.25rem" } }, a$B = { fontWeight: "700" }, n$x = { borderColor: "{datatable.border.color}", borderWidth: "0 0 1px 0", padding: "0.75rem 1rem", sm: { padding: "0.375rem 0.5rem" }, lg: { padding: "1rem 1.25rem" } }, s$9 = { color: "{primary.color}" }, i$n = { width: "0.5rem" }, g$6 = { width: "1px", color: "{primary.color}" }, u$8 = { color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", size: "0.875rem" }, b$5 = { size: "2rem" }, p$4 = { hoverBackground: "{content.hover.background}", selectedHoverBackground: "{content.background}", color: "{text.muted.color}", hoverColor: "{text.color}", selectedHoverColor: "{primary.color}", size: "1.75rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, f$9 = { inlineGap: "0.5rem", overlaySelect: { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, overlayPopover: { background: "{overlay.popover.background}", borderColor: "{overlay.popover.border.color}", borderRadius: "{overlay.popover.border.radius}", color: "{overlay.popover.color}", shadow: "{overlay.popover.shadow}", padding: "{overlay.popover.padding}", gap: "0.5rem" }, rule: { borderColor: "{content.border.color}" }, constraintList: { padding: "{list.padding}", gap: "{list.gap}" }, constraint: { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", separator: { borderColor: "{content.border.color}" }, padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}" } }, h$5 = { borderColor: "{datatable.border.color}", borderWidth: "0 0 1px 0" }, m$5 = { borderColor: "{datatable.border.color}", borderWidth: "0 0 1px 0" }, v$3 = { light: { root: { borderColor: "{content.border.color}" }, header: { background: "{surface.50}", color: "{text.color}" }, headerCell: { background: "{surface.50}", hoverBackground: "{surface.100}", color: "{text.color}" }, footer: { background: "{surface.50}", color: "{text.color}" }, footerCell: { background: "{surface.50}", color: "{text.color}" }, row: { stripedBackground: "{surface.50}" }, bodyCell: { selectedBorderColor: "{primary.100}" } }, dark: { root: { borderColor: "{surface.800}" }, header: { background: "{surface.800}", color: "{text.color}" }, headerCell: { background: "{surface.800}", hoverBackground: "{surface.700}", color: "{text.color}" }, footer: { background: "{surface.800}", color: "{text.color}" }, footerCell: { background: "{surface.800}", color: "{text.color}" }, row: { stripedBackground: "{surface.950}" }, bodyCell: { selectedBorderColor: "{primary.900}" } } }, k$3 = { root: o$16, header: r$13, headerCell: e$J, columnTitle: d$x, row: l$g, bodyCell: c$s, footerCell: t$y, columnFooter: a$B, footer: n$x, dropPoint: s$9, columnResizer: i$n, resizeIndicator: g$6, sortIcon: u$8, loadingIcon: b$5, rowToggleButton: p$4, filter: f$9, paginatorTop: h$5, paginatorBottom: m$5, colorScheme: v$3 };
var o$15 = { borderColor: "{content.border.color}", borderWidth: "1px", borderRadius: "4px", padding: "0" }, r$12 = { borderColor: "{content.border.color}", borderWidth: "0 0 1px 0", padding: "0.875rem 1.125rem", borderRadius: "5px 5px 0 0" }, e$I = { background: "{content.background}", color: "{content.color}", borderColor: "transparent", borderWidth: "0", padding: "0", borderRadius: "5px" }, d$w = { background: "{content.background}", color: "{content.color}", borderColor: "{content.border.color}", borderWidth: "1px 0 0 0", padding: "0.875rem 1.125rem", borderRadius: "0 0 5px 5px" }, t$x = { borderColor: "{content.border.color}", borderWidth: "0 0 1px 0" }, n$w = { borderColor: "{content.border.color}", borderWidth: "1px 0 0 0" }, c$r = { light: { header: { background: "{surface.50}", color: "{text.color}" } }, dark: { header: { background: "{surface.800}", color: "{text.color}" } } }, a$A = { root: o$15, header: r$12, content: e$I, footer: d$w, paginatorTop: t$x, paginatorBottom: n$w, colorScheme: c$r };
var o$14 = { transitionDuration: "{transition.duration}" }, r$11 = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}", shadow: "{overlay.popover.shadow}", padding: "{overlay.popover.padding}" }, e$H = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", padding: "0 0 0.75rem 0" }, d$v = { gap: "0.5rem", fontWeight: "700" }, c$q = { width: "2.5rem", sm: { width: "2rem" }, lg: { width: "3rem" }, borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.border.color}", activeBorderColor: "{form.field.border.color}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" } }, n$v = { color: "{form.field.icon.color}" }, t$w = { hoverBackground: "{content.hover.background}", color: "{content.color}", hoverColor: "{content.hover.color}", padding: "0.375rem 0.625rem", borderRadius: "{content.border.radius}" }, a$z = { hoverBackground: "{content.hover.background}", color: "{content.color}", hoverColor: "{content.hover.color}", padding: "0.375rem 0.625rem", borderRadius: "{content.border.radius}" }, i$m = { borderColor: "{content.border.color}", gap: "{overlay.popover.padding}" }, l$f = { margin: "0.75rem 0 0 0" }, f$8 = { padding: "0.375rem", fontWeight: "700", color: "{content.color}" }, u$7 = { hoverBackground: "{content.hover.background}", selectedBackground: "{primary.color}", rangeSelectedBackground: "{highlight.background}", color: "{content.color}", hoverColor: "{content.hover.color}", selectedColor: "{primary.contrast.color}", rangeSelectedColor: "{highlight.color}", width: "2.5rem", height: "2.5rem", borderRadius: "50%", padding: "0.375rem", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" } }, s$8 = { margin: "0.75rem 0 0 0" }, g$5 = { padding: "0.5rem", borderRadius: "{content.border.radius}" }, h$4 = { margin: "0.75rem 0 0 0" }, m$4 = { padding: "0.5rem", borderRadius: "{content.border.radius}" }, b$4 = { padding: "0.75rem 0 0 0", borderColor: "{content.border.color}" }, p$3 = { padding: "0.75rem 0 0 0", borderColor: "{content.border.color}", gap: "0.5rem", buttonGap: "0.25rem" }, v$2 = { light: { dropdown: { background: "{surface.50}", hoverBackground: "{surface.100}", activeBackground: "{surface.200}", color: "{surface.600}", hoverColor: "{surface.700}", activeColor: "{surface.800}" }, today: { background: "{surface.200}", color: "{surface.900}" } }, dark: { dropdown: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.600}", color: "{surface.300}", hoverColor: "{surface.200}", activeColor: "{surface.100}" }, today: { background: "{surface.700}", color: "{surface.0}" } } }, k$2 = { root: o$14, panel: r$11, header: e$H, title: d$v, dropdown: c$q, inputIcon: n$v, selectMonth: t$w, selectYear: a$z, group: i$m, dayView: l$f, weekDay: f$8, date: u$7, monthView: s$8, month: g$5, yearView: h$4, year: m$4, buttonbar: b$4, timePicker: p$3, colorScheme: v$2 };
var o$13 = { background: "{overlay.modal.background}", borderColor: "{overlay.modal.border.color}", color: "{overlay.modal.color}", borderRadius: "{overlay.modal.border.radius}", shadow: "{overlay.modal.shadow}" }, a$y = { padding: "{overlay.modal.padding}", gap: "0.5rem" }, d$u = { fontSize: "1.25rem", fontWeight: "600" }, r$10 = { padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}" }, l$e = { padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}", gap: "0.5rem" }, e$G = { root: o$13, header: a$y, title: d$u, content: r$10, footer: l$e };
var r$$ = { borderColor: "{content.border.color}" }, o$12 = { background: "{content.background}", color: "{text.color}" }, n$u = { margin: "1.125rem 0", padding: "0 1.125rem", content: { padding: "0 0.625rem" } }, e$F = { margin: "0 1.125rem", padding: "1.125rem 0", content: { padding: "0.625rem 0" } }, t$v = { root: r$$, content: o$12, horizontal: n$u, vertical: e$F };
var r$_ = { background: "rgba(255, 255, 255, 0.1)", borderColor: "rgba(255, 255, 255, 0.2)", padding: "0.5rem", borderRadius: "{border.radius.lg}" }, o$11 = { borderRadius: "{content.border.radius}", padding: "0.5rem", size: "3rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, d$t = { root: r$_, item: o$11 };
var o$10 = { background: "{overlay.modal.background}", borderColor: "{overlay.modal.border.color}", color: "{overlay.modal.color}", shadow: "{overlay.modal.shadow}" }, a$x = { padding: "{overlay.modal.padding}" }, d$s = { fontSize: "1.5rem", fontWeight: "600" }, r$Z = { padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}" }, l$d = { padding: "{overlay.modal.padding}" }, e$E = { root: o$10, header: a$x, title: d$s, content: r$Z, footer: l$d };
var o$$ = { borderColor: "{content.border.color}", borderRadius: "{content.border.radius}" }, r$Y = { color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{primary.color}" }, e$D = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}", padding: "{list.padding}" }, l$c = { focusBackground: "{list.option.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}" }, t$u = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}" }, c$p = { light: { toolbar: { background: "{surface.50}" } }, dark: { toolbar: { background: "{surface.800}" } } }, d$r = { toolbar: o$$, toolbarItem: r$Y, overlay: e$D, overlayOption: l$c, content: t$u, colorScheme: c$p };
var o$_ = { background: "{content.background}", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", color: "{content.color}", padding: "0.75rem 1.125rem 1.125rem 1.125rem", transitionDuration: "{transition.duration}" }, r$X = { borderRadius: "{content.border.radius}", borderWidth: "1px", borderColor: "{content.border.color}", padding: "0.625rem 0.875rem", gap: "0.5rem", fontWeight: "700", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, e$C = { color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}" }, t$t = { padding: "0" }, c$o = { light: { legend: { background: "{surface.50}", hoverBackground: "{surface.100}", color: "{text.color}", hoverColor: "{text.hover.color}" } }, dark: { legend: { background: "{surface.800}", hoverBackground: "{surface.700}", color: "{text.color}", hoverColor: "{text.hover.color}" } } }, n$t = { root: o$_, legend: r$X, toggleIcon: e$C, content: t$t, colorScheme: c$o };
var r$W = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}", transitionDuration: "{transition.duration}" }, o$Z = { borderWidth: "0 0 1px 0", borderColor: "{content.border.color}", padding: "1.125rem", borderRadius: "5px 5px 0 0", gap: "0.5rem" }, e$B = { highlightBorderColor: "{primary.color}", padding: "1.125rem", gap: "1rem" }, a$w = { padding: "1rem", gap: "1rem", borderColor: "{content.border.color}", info: { gap: "0.5rem" } }, t$s = { gap: "0.5rem" }, d$q = { height: "0.25rem" }, n$s = { gap: "0.5rem" }, c$n = { light: { header: { background: "{surface.50}", color: "{text.color}" } }, dark: { header: { background: "{surface.800}", color: "{text.color}" } } }, i$l = { root: r$W, header: o$Z, content: e$B, file: a$w, fileList: t$s, progressbar: d$q, basic: n$s, colorScheme: c$n };
var o$Y = { color: "{form.field.float.label.color}", focusColor: "{form.field.float.label.focus.color}", activeColor: "{form.field.float.label.active.color}", invalidColor: "{form.field.float.label.invalid.color}", transitionDuration: "0.2s", positionX: "{form.field.padding.x}", positionY: "{form.field.padding.y}", fontWeight: "500", active: { fontSize: "0.75rem", fontWeight: "400" } }, i$k = { active: { top: "-1.375rem" } }, r$V = { input: { paddingTop: "1.875rem", paddingBottom: "{form.field.padding.y}" }, active: { top: "{form.field.padding.y}" } }, a$v = { borderRadius: "{border.radius.xs}", active: { background: "{form.field.background}", padding: "0 0.125rem" } }, d$p = { root: o$Y, over: i$k, in: r$V, on: a$v };
var o$X = { borderWidth: "1px", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", transitionDuration: "{transition.duration}" }, r$U = { background: "rgba(255, 255, 255, 0.1)", hoverBackground: "rgba(255, 255, 255, 0.2)", color: "{surface.100}", hoverColor: "{surface.0}", size: "3rem", gutter: "0", prev: { borderRadius: "0 12px 12px 0" }, next: { borderRadius: "12px 0 0 12px" }, focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, e$A = { size: "1.5rem" }, t$r = { padding: "1rem 0.25rem" }, n$r = { size: "2rem", borderRadius: "{content.border.radius}", gutter: "0.5rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, a$u = { size: "1rem" }, c$m = { background: "rgba(0, 0, 0, 0.5)", color: "{surface.100}", padding: "1rem" }, s$7 = { gap: "0.5rem", padding: "1rem" }, u$6 = { width: "1rem", height: "1rem", activeBackground: "{primary.color}", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, i$j = { background: "rgba(0, 0, 0, 0.5)" }, d$o = { background: "rgba(255, 255, 255, 0.4)", hoverBackground: "rgba(255, 255, 255, 0.6)", activeBackground: "rgba(255, 255, 255, 0.9)" }, g$4 = { size: "3rem", gutter: "0.5rem", background: "rgba(255, 255, 255, 0.1)", hoverBackground: "rgba(255, 255, 255, 0.2)", color: "{surface.50}", hoverColor: "{surface.0}", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, f$7 = { size: "1.5rem" }, h$3 = { light: { thumbnailsContent: { background: "{surface.50}" }, thumbnailNavButton: { hoverBackground: "{surface.100}", color: "{surface.600}", hoverColor: "{surface.700}" }, indicatorButton: { background: "{surface.200}", hoverBackground: "{surface.300}" } }, dark: { thumbnailsContent: { background: "{surface.800}" }, thumbnailNavButton: { hoverBackground: "{surface.700}", color: "{surface.400}", hoverColor: "{surface.0}" }, indicatorButton: { background: "{surface.700}", hoverBackground: "{surface.600}" } } }, l$b = { root: o$X, navButton: r$U, navIcon: e$A, thumbnailsContent: t$r, thumbnailNavButton: n$r, thumbnailNavButtonIcon: a$u, caption: c$m, indicatorList: s$7, indicatorButton: u$6, insetIndicatorList: i$j, insetIndicatorButton: d$o, closeButton: g$4, closeButtonIcon: f$7, colorScheme: h$3 };
var o$W = { color: "{form.field.icon.color}" }, r$T = { icon: o$W };
var o$V = { color: "{form.field.float.label.color}", focusColor: "{form.field.float.label.focus.color}", invalidColor: "{form.field.float.label.invalid.color}", transitionDuration: "0.2s", positionX: "{form.field.padding.x}", top: "{form.field.padding.y}", fontSize: "0.75rem", fontWeight: "400" }, l$a = { paddingTop: "1.875rem", paddingBottom: "{form.field.padding.y}" }, i$i = { root: o$V, input: l$a };
var o$U = { transitionDuration: "{transition.duration}" }, r$S = { icon: { size: "1.5rem" }, mask: { background: "{mask.background}", color: "{mask.color}" } }, a$t = { position: { left: "auto", right: "1rem", top: "1rem", bottom: "auto" }, blur: "8px", background: "rgba(255,255,255,0.1)", borderColor: "rgba(255,255,255,0.2)", borderWidth: "1px", borderRadius: "{content.border.radius}", padding: ".5rem", gap: "0.5rem" }, e$z = { hoverBackground: "rgba(255,255,255,0.1)", color: "{surface.50}", hoverColor: "{surface.0}", size: "3rem", iconSize: "1.5rem", borderRadius: "{content.border.radius}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, i$h = { root: o$U, preview: r$S, toolbar: a$t, action: e$z };
var r$R = { size: "15px", hoverSize: "30px", background: "rgba(255,255,255,0.3)", hoverBackground: "rgba(255,255,255,0.3)", borderColor: "rgba(255,255,255,0.3)", hoverBorderColor: "rgba(255,255,255,0.3)", borderWidth: "3px", borderRadius: "50%", transitionDuration: "{transition.duration}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "rgba(255,255,255,0.3)", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, o$T = { handle: r$R };
var r$Q = { padding: "{form.field.padding.y} {form.field.padding.x}", borderRadius: "{content.border.radius}", gap: "0.5rem" }, o$S = { fontWeight: "500" }, n$q = { size: "1.125rem" }, e$y = { light: { info: { background: "color-mix(in srgb, {blue.50}, transparent 5%)", borderColor: "color-mix(in srgb, {blue.50}, transparent 5%)", color: "{blue.600}", shadow: "none" }, success: { background: "color-mix(in srgb, {green.50}, transparent 5%)", borderColor: "color-mix(in srgb, {green.50}, transparent 5%)", color: "{green.600}", shadow: "none" }, warn: { background: "color-mix(in srgb,{yellow.50}, transparent 5%)", borderColor: "color-mix(in srgb,{yellow.50}, transparent 5%)", color: "{yellow.600}", shadow: "none" }, error: { background: "color-mix(in srgb, {red.50}, transparent 5%)", borderColor: "color-mix(in srgb, {red.50}, transparent 5%)", color: "{red.600}", shadow: "none" }, secondary: { background: "{surface.100}", borderColor: "{surface.100}", color: "{surface.600}", shadow: "none" }, contrast: { background: "{surface.900}", borderColor: "{surface.900}", color: "{surface.50}", shadow: "none" } }, dark: { info: { background: "color-mix(in srgb, {blue.500}, transparent 84%)", borderColor: "color-mix(in srgb, {blue.500}, transparent 84%)", color: "{blue.500}", shadow: "none" }, success: { background: "color-mix(in srgb, {green.500}, transparent 84%)", borderColor: "color-mix(in srgb, {green.500}, transparent 84%)", color: "{green.500}", shadow: "none" }, warn: { background: "color-mix(in srgb, {yellow.500}, transparent 84%)", borderColor: "color-mix(in srgb, {yellow.500}, transparent 84%)", color: "{yellow.500}", shadow: "none" }, error: { background: "color-mix(in srgb, {red.500}, transparent 84%)", borderColor: "color-mix(in srgb, {red.500}, transparent 84%)", color: "{red.500}", shadow: "none" }, secondary: { background: "{surface.800}", borderColor: "{surface.800}", color: "{surface.300}", shadow: "none" }, contrast: { background: "{surface.0}", borderColor: "{surface.0}", color: "{surface.950}", shadow: "none" } } }, a$s = { root: r$Q, text: o$S, icon: n$q, colorScheme: e$y };
var o$R = { padding: "{form.field.padding.y} {form.field.padding.x}", borderRadius: "{content.border.radius}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" }, transitionDuration: "{transition.duration}" }, r$P = { hoverBackground: "{content.hover.background}", hoverColor: "{content.hover.color}" }, n$p = { root: o$R, display: r$P };
var o$Q = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}" }, r$O = { borderRadius: "{border.radius.sm}" }, d$n = { light: { chip: { focusBackground: "{surface.200}", color: "{surface.800}" } }, dark: { chip: { focusBackground: "{surface.700}", color: "{surface.0}" } } }, f$6 = { root: o$Q, chip: r$O, colorScheme: d$n };
var r$N = { borderRadius: "{form.field.border.radius}", padding: "0.625rem 0.5rem", minWidth: "2.75rem" }, o$P = { light: { addon: { background: "{surface.50}", borderColor: "{form.field.border.color}", color: "{text.muted.color}" } }, dark: { addon: { background: "{surface.800}", borderColor: "{form.field.border.color}", color: "{text.muted.color}" } } }, d$m = { addon: r$N, colorScheme: o$P };
var r$M = { transitionDuration: "{transition.duration}" }, o$O = { width: "2.5rem", borderRadius: "{form.field.border.radius}", verticalPadding: "{form.field.padding.y}" }, e$x = { light: { button: { background: "{surface.100}", hoverBackground: "{surface.200}", activeBackground: "{surface.300}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.border.color}", activeBorderColor: "{form.field.border.color}", color: "{surface.600}", hoverColor: "{surface.700}", activeColor: "{surface.800}" } }, dark: { button: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.500}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.border.color}", activeBorderColor: "{form.field.border.color}", color: "{surface.300}", hoverColor: "{surface.200}", activeColor: "{surface.100}" } } }, d$l = { root: r$M, button: o$O, colorScheme: e$x };
var r$L = { gap: "0.5rem" }, t$q = { width: "2.5rem", sm: { width: "2rem" }, lg: { width: "3rem" } }, e$w = { root: r$L, input: t$q };
var o$N = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, d$k = { root: o$N };
var o$M = { transitionDuration: "{transition.duration}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, r$K = { background: "{primary.color}" }, t$p = { background: "{content.border.color}" }, n$o = { color: "{text.muted.color}" }, c$l = { root: o$M, value: r$K, range: t$p, text: n$o };
var o$L = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", borderColor: "{form.field.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", shadow: "{form.field.shadow}", borderRadius: "{form.field.border.radius}", transitionDuration: "{form.field.transition.duration}" }, r$J = { padding: "{list.padding}", gap: "{list.gap}", header: { padding: "{list.header.padding}" } }, d$j = { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}" }, i$g = { background: "{list.option.group.background}", color: "{list.option.group.color}", fontWeight: "{list.option.group.font.weight}", padding: "{list.option.group.padding}" }, t$o = { color: "{list.option.color}", gutterStart: "-0.5rem", gutterEnd: "0.5rem" }, e$v = { padding: "{list.option.padding}" }, l$9 = { light: { option: { stripedBackground: "{surface.50}" } }, dark: { option: { stripedBackground: "{surface.900}" } } }, n$n = { root: o$L, list: r$J, option: d$j, optionGroup: i$g, checkmark: t$o, emptyMessage: e$v, colorScheme: l$9 };
var o$K = { borderColor: "transparent", borderRadius: "{content.border.radius}", color: "{content.color}", gap: "0.5rem", verticalOrientation: { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}" }, horizontalOrientation: { padding: "0.75rem 1rem", gap: "0.5rem" }, transitionDuration: "{transition.duration}" }, n$m = { borderRadius: "{content.border.radius}", padding: "0.75rem 1rem" }, a$r = { focusBackground: "{navigation.item.focus.background}", activeBackground: "{navigation.item.active.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", activeColor: "{navigation.item.active.color}", padding: "{navigation.item.padding}", borderRadius: "{navigation.item.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}", activeColor: "{navigation.item.icon.active.color}" } }, i$f = { padding: "0", background: "{content.background}", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", color: "{content.color}", shadow: "{overlay.navigation.shadow}", gap: "0.5rem" }, r$I = { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}" }, t$n = { padding: "{navigation.submenu.label.padding}", fontWeight: "{navigation.submenu.label.font.weight}", background: "{navigation.submenu.label.background}", color: "{navigation.submenu.label.color}" }, e$u = { size: "{navigation.submenu.icon.size}", color: "{navigation.submenu.icon.color}", focusColor: "{navigation.submenu.icon.focus.color}", activeColor: "{navigation.submenu.icon.active.color}" }, c$k = { borderColor: "{content.border.color}" }, d$i = { borderRadius: "50%", size: "2rem", color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", hoverBackground: "{content.hover.background}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, g$3 = { light: { root: { background: "{surface.50}" } }, dark: { root: { background: "{surface.800}" } } }, u$5 = { root: o$K, baseItem: n$m, item: a$r, overlay: i$f, submenu: r$I, submenuLabel: t$n, submenuIcon: e$u, separator: c$k, mobileButton: d$i, colorScheme: g$3 };
var o$J = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}", shadow: "{overlay.navigation.shadow}", transitionDuration: "{transition.duration}" }, n$l = { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}" }, a$q = { focusBackground: "{navigation.item.focus.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", padding: "{navigation.item.padding}", borderRadius: "{navigation.item.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}" } }, i$e = { padding: "{navigation.submenu.label.padding}", fontWeight: "{navigation.submenu.label.font.weight}", background: "{navigation.submenu.label.background}", color: "{navigation.submenu.label.color}" }, t$m = { borderColor: "{content.border.color}" }, r$H = { root: o$J, list: n$l, item: a$q, submenuLabel: i$e, separator: t$m };
var o$I = { borderColor: "transparent", borderRadius: "{content.border.radius}", color: "{content.color}", gap: "0.5rem", padding: "0.75rem 1rem", transitionDuration: "{transition.duration}" }, r$G = { borderRadius: "{content.border.radius}", padding: "0.75rem 1rem" }, i$d = { focusBackground: "{navigation.item.focus.background}", activeBackground: "{navigation.item.active.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", activeColor: "{navigation.item.active.color}", padding: "{navigation.item.padding}", borderRadius: "{navigation.item.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}", activeColor: "{navigation.item.icon.active.color}" } }, n$k = { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}", background: "{content.background}", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", shadow: "{overlay.navigation.shadow}", mobileIndent: "1.25rem", icon: { size: "{navigation.submenu.icon.size}", color: "{navigation.submenu.icon.color}", focusColor: "{navigation.submenu.icon.focus.color}", activeColor: "{navigation.submenu.icon.active.color}" } }, a$p = { borderColor: "{content.border.color}" }, t$l = { borderRadius: "50%", size: "2rem", color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", hoverBackground: "{content.hover.background}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, e$t = { light: { root: { background: "{surface.50}" } }, dark: { root: { background: "{surface.800}" } } }, c$j = { root: o$I, baseItem: r$G, item: i$d, submenu: n$k, separator: a$p, mobileButton: t$l, colorScheme: e$t };
var o$H = { borderRadius: "{content.border.radius}", borderWidth: "1px", transitionDuration: "{transition.duration}" }, r$F = { padding: "0.75rem 1rem", gap: "0.5rem", sm: { padding: "0.5rem 0.625rem" }, lg: { padding: "0.75rem 0.875rem" } }, e$s = { fontSize: "1rem", fontWeight: "500", sm: { fontSize: "0.875rem" }, lg: { fontSize: "1.125rem" } }, n$j = { size: "1.25rem", sm: { size: "1rem" }, lg: { size: "1.5rem" } }, l$8 = { width: "2rem", height: "2rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", offset: "{focus.ring.offset}" } }, c$i = { size: "1rem", sm: { size: "0.875rem" }, lg: { size: "1.125rem" } }, s$6 = { root: { borderWidth: "1px" } }, a$o = { content: { padding: "0" } }, t$k = { light: { info: { background: "color-mix(in srgb, {blue.50}, transparent 5%)", borderColor: "transparent", color: "{blue.600}", shadow: "none", closeButton: { hoverBackground: "{blue.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {blue.200}" } }, outlined: { color: "{blue.600}", borderColor: "{blue.600}" }, simple: { color: "{blue.600}" } }, success: { background: "color-mix(in srgb, {green.50}, transparent 5%)", borderColor: "transparent", color: "{green.600}", shadow: "none", closeButton: { hoverBackground: "{green.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {green.200}" } }, outlined: { color: "{green.600}", borderColor: "{green.600}" }, simple: { color: "{green.600}" } }, warn: { background: "color-mix(in srgb,{yellow.50}, transparent 5%)", borderColor: "transparent", color: "{yellow.600}", shadow: "none", closeButton: { hoverBackground: "{yellow.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {yellow.200}" } }, outlined: { color: "{yellow.600}", borderColor: "{yellow.600}" }, simple: { color: "{yellow.600}" } }, error: { background: "color-mix(in srgb, {red.50}, transparent 5%)", borderColor: "transparent", color: "{red.600}", shadow: "none", closeButton: { hoverBackground: "{red.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {red.200}" } }, outlined: { color: "{red.600}", borderColor: "{red.600}" }, simple: { color: "{red.600}" } }, secondary: { background: "{surface.100}", borderColor: "transparent", color: "{surface.600}", shadow: "none", closeButton: { hoverBackground: "{surface.200}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {surface.200}" } }, outlined: { color: "{surface.500}", borderColor: "{surface.500}" }, simple: { color: "{surface.500}" } }, contrast: { background: "{surface.900}", borderColor: "transparent", color: "{surface.50}", shadow: "none", closeButton: { hoverBackground: "{surface.800}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {surface.400}" } }, outlined: { color: "{surface.900}", borderColor: "{surface.900}" }, simple: { color: "{surface.900}" } } }, dark: { info: { background: "color-mix(in srgb, {blue.500}, transparent 84%)", borderColor: "transparent", color: "{blue.500}", shadow: "none", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {blue.500}, transparent 80%)" } }, outlined: { color: "{blue.500}", borderColor: "{blue.500}" }, simple: { color: "{blue.500}" } }, success: { background: "color-mix(in srgb, {green.500}, transparent 84%)", borderColor: "transparent", color: "{green.500}", shadow: "none", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {green.500}, transparent 80%)" } }, outlined: { color: "{green.500}", borderColor: "{green.500}" }, simple: { color: "{green.500}" } }, warn: { background: "color-mix(in srgb, {yellow.500}, transparent 84%)", borderColor: "transparent", color: "{yellow.500}", shadow: "none", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {yellow.500}, transparent 80%)" } }, outlined: { color: "{yellow.500}", borderColor: "{yellow.500}" }, simple: { color: "{yellow.500}" } }, error: { background: "color-mix(in srgb, {red.500}, transparent 84%)", borderColor: "transparent", color: "{red.500}", shadow: "none", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {red.500}, transparent 80%)" } }, outlined: { color: "{red.500}", borderColor: "{red.500}" }, simple: { color: "{red.500}" } }, secondary: { background: "{surface.800}", borderColor: "transparent", color: "{surface.300}", shadow: "none", closeButton: { hoverBackground: "{surface.700}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.300}, transparent 80%)" } }, outlined: { color: "{surface.400}", borderColor: "{surface.400}" }, simple: { color: "{surface.400}" } }, contrast: { background: "{surface.0}", borderColor: "transparent", color: "{surface.950}", shadow: "none", closeButton: { hoverBackground: "{surface.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.950}, transparent 80%)" } }, outlined: { color: "{surface.0}", borderColor: "{surface.0}" }, simple: { color: "{surface.0}" } } } }, u$4 = { root: o$H, content: r$F, text: e$s, icon: n$j, closeButton: l$8, closeIcon: c$i, outlined: s$6, simple: a$o, colorScheme: t$k };
var e$r = { borderRadius: "{content.border.radius}", gap: "1rem" }, r$E = { background: "{content.border.color}", size: "0.625rem" }, a$n = { gap: "0.5rem" }, o$G = { size: "0.5rem" }, l$7 = { size: "1rem" }, t$j = { verticalGap: "0.5rem", horizontalGap: "1rem" }, b$3 = { root: e$r, meters: r$E, label: a$n, labelMarker: o$G, labelIcon: l$7, labelList: t$j };
var o$F = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, d$h = { width: "2.5rem", color: "{form.field.icon.color}" }, r$D = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, l$6 = { padding: "{list.padding}", gap: "{list.gap}", header: { padding: "{list.header.padding}" } }, i$c = { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}", gap: "0.5rem" }, e$q = { background: "{list.option.group.background}", color: "{list.option.group.color}", fontWeight: "{list.option.group.font.weight}", padding: "{list.option.group.padding}" }, f$5 = { color: "{form.field.icon.color}" }, a$m = { borderRadius: "{border.radius.sm}" }, c$h = { padding: "{list.option.padding}" }, n$i = { root: o$F, dropdown: d$h, overlay: r$D, list: l$6, option: i$c, optionGroup: e$q, chip: a$m, clearIcon: f$5, emptyMessage: c$h };
var r$C = { gap: "1.125rem" }, a$l = { gap: "0.5rem" }, o$E = { root: r$C, controls: a$l };
var o$D = { gutter: "0.75rem", transitionDuration: "{transition.duration}" }, r$B = { background: "{content.background}", hoverBackground: "{content.hover.background}", selectedBackground: "{highlight.background}", borderColor: "{content.border.color}", color: "{content.color}", selectedColor: "{highlight.color}", hoverColor: "{content.hover.color}", padding: "1rem 1.25rem", toggleablePadding: "1rem 1.25rem 1.5rem 1.25rem", borderRadius: "{content.border.radius}" }, e$p = { background: "{content.background}", hoverBackground: "{content.hover.background}", borderColor: "{content.border.color}", color: "{text.muted.color}", hoverColor: "{text.color}", size: "1.75rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, t$i = { color: "{content.border.color}", borderRadius: "{content.border.radius}", height: "24px" }, n$h = { root: o$D, node: r$B, nodeToggleButton: e$p, connector: t$i };
var o$C = { outline: { width: "2px", color: "{content.background}" } }, t$h = { root: o$C };
var o$B = { padding: "0.5rem 1rem", gap: "0.25rem", borderRadius: "{content.border.radius}", background: "{content.background}", color: "{content.color}", transitionDuration: "{transition.duration}" }, r$A = { background: "transparent", hoverBackground: "{content.hover.background}", selectedBackground: "{highlight.background}", color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", selectedColor: "{highlight.color}", width: "2.5rem", height: "2.5rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, t$g = { color: "{text.muted.color}" }, e$o = { maxWidth: "2.5rem" }, n$g = { root: o$B, navButton: r$A, currentPageReport: t$g, jumpToPageInput: e$o };
var r$z = { background: "{content.background}", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", color: "{content.color}" }, o$A = { borderWidth: "0 0 1px 0", borderColor: "{content.border.color}", padding: "1.125rem", borderRadius: "5px 5px 0 0" }, e$n = { padding: "0.25rem 1.125rem" }, d$g = { fontWeight: "700" }, t$f = { padding: "1.125rem" }, a$k = { padding: "1.125rem" }, c$g = { light: { header: { background: "{surface.50}", color: "{text.color}" } }, dark: { header: { background: "{surface.800}", color: "{text.color}" } } }, n$f = { root: r$z, header: o$A, toggleableHeader: e$n, title: d$g, content: t$f, footer: a$k, colorScheme: c$g };
var o$z = { gap: "0", transitionDuration: "{transition.duration}" }, r$y = { background: "{content.background}", borderColor: "{content.border.color}", borderWidth: "1px", color: "{content.color}", padding: "0.25rem 0.25rem", borderRadius: "0", first: { borderWidth: "1px 1px 0 1px", topBorderRadius: "{content.border.radius}" }, last: { borderWidth: "0 1px 1px 1px", bottomBorderRadius: "{content.border.radius}" } }, n$e = { focusBackground: "{navigation.item.focus.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", gap: "0.5rem", padding: "{navigation.item.padding}", borderRadius: "{content.border.radius}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}" } }, i$b = { indent: "1rem" }, t$e = { color: "{navigation.submenu.icon.color}", focusColor: "{navigation.submenu.icon.focus.color}" }, a$j = { root: o$z, panel: r$y, item: n$e, submenu: i$b, submenuIcon: t$e };
var r$x = { background: "{content.border.color}", borderRadius: "{content.border.radius}", height: ".75rem" }, o$y = { color: "{form.field.icon.color}" }, e$m = { background: "{overlay.popover.background}", borderColor: "{overlay.popover.border.color}", borderRadius: "{overlay.popover.border.radius}", color: "{overlay.popover.color}", padding: "{overlay.popover.padding}", shadow: "{overlay.popover.shadow}" }, a$i = { gap: "0.75rem" }, d$f = { light: { strength: { weakBackground: "{red.500}", mediumBackground: "{amber.500}", strongBackground: "{green.500}" } }, dark: { strength: { weakBackground: "{red.400}", mediumBackground: "{amber.400}", strongBackground: "{green.400}" } } }, n$d = { meter: r$x, icon: o$y, overlay: e$m, content: a$i, colorScheme: d$f };
var r$w = { gap: "1.125rem" }, a$h = { gap: "0.5rem" }, o$x = { root: r$w, controls: a$h };
var o$w = { background: "{overlay.popover.background}", borderColor: "{overlay.popover.border.color}", color: "{overlay.popover.color}", borderRadius: "{overlay.popover.border.radius}", shadow: "{overlay.popover.shadow}", gutter: "10px", arrowOffset: "1.25rem" }, r$v = { padding: "{overlay.popover.padding}" }, e$l = { root: o$w, content: r$v };
var r$u = { background: "{content.border.color}", borderRadius: "{content.border.radius}", height: "1.5rem" }, o$v = { background: "{primary.color}" }, e$k = { color: "{primary.contrast.color}", fontSize: "0.875rem", fontWeight: "600" }, t$d = { root: r$u, value: o$v, label: e$k };
var o$u = { light: { root: { colorOne: "{pink.500}", colorTwo: "{sky.500}", colorThree: "{emerald.500}", colorFour: "{amber.500}" } }, dark: { root: { colorOne: "{pink.400}", colorTwo: "{sky.400}", colorThree: "{emerald.400}", colorFour: "{amber.400}" } } }, r$t = { colorScheme: o$u };
var o$t = { width: "1.5rem", height: "1.5rem", background: "{form.field.background}", checkedBackground: "{primary.color}", checkedHoverBackground: "{primary.hover.color}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", checkedBorderColor: "{primary.color}", checkedHoverBorderColor: "{primary.hover.color}", checkedFocusBorderColor: "{primary.color}", checkedDisabledBorderColor: "{form.field.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", shadow: "{form.field.shadow}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { width: "1.25rem", height: "1.25rem" }, lg: { width: "1.75rem", height: "1.75rem" } }, r$s = { size: "1rem", checkedColor: "{primary.contrast.color}", checkedHoverColor: "{primary.contrast.color}", disabledColor: "{form.field.disabled.color}", sm: { size: "0.75rem" }, lg: { size: "1.25rem" } }, e$j = { root: o$t, icon: r$s };
var o$s = { gap: "0.25rem", transitionDuration: "{transition.duration}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, r$r = { size: "1.25rem", color: "{text.muted.color}", hoverColor: "{primary.color}", activeColor: "{primary.color}" }, i$a = { root: o$s, icon: r$r };
var r$q = { light: { root: { background: "rgba(0,0,0,0.1)" } }, dark: { root: { background: "rgba(255,255,255,0.3)" } } }, o$r = { colorScheme: r$q };
var r$p = { transitionDuration: "{transition.duration}" }, o$q = { size: "9px", borderRadius: "{border.radius.sm}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, s$5 = { light: { bar: { background: "{surface.200}" } }, dark: { bar: { background: "{surface.700}" } } }, a$g = { root: r$p, bar: o$q, colorScheme: s$5 };
var o$p = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, r$o = { width: "2.5rem", color: "{form.field.icon.color}" }, d$e = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, l$5 = { padding: "{list.padding}", gap: "{list.gap}", header: { padding: "{list.header.padding}" } }, i$9 = { focusBackground: "{list.option.focus.background}", selectedBackground: "{list.option.selected.background}", selectedFocusBackground: "{list.option.selected.focus.background}", color: "{list.option.color}", focusColor: "{list.option.focus.color}", selectedColor: "{list.option.selected.color}", selectedFocusColor: "{list.option.selected.focus.color}", padding: "{list.option.padding}", borderRadius: "{list.option.border.radius}" }, e$i = { background: "{list.option.group.background}", color: "{list.option.group.color}", fontWeight: "{list.option.group.font.weight}", padding: "{list.option.group.padding}" }, f$4 = { color: "{form.field.icon.color}" }, c$f = { color: "{list.option.color}", gutterStart: "-0.5rem", gutterEnd: "0.5rem" }, a$f = { padding: "{list.option.padding}" }, n$c = { root: o$p, dropdown: r$o, overlay: d$e, list: l$5, option: i$9, optionGroup: e$i, clearIcon: f$4, checkmark: c$f, emptyMessage: a$f };
var r$n = { borderRadius: "{form.field.border.radius}" }, o$o = { light: { root: { invalidBorderColor: "{form.field.invalid.border.color}" } }, dark: { root: { invalidBorderColor: "{form.field.invalid.border.color}" } } }, d$d = { root: r$n, colorScheme: o$o };
var r$m = { borderRadius: "{content.border.radius}" }, a$e = { light: { root: { background: "{surface.200}", animationBackground: "rgba(255,255,255,0.4)" } }, dark: { root: { background: "rgba(255, 255, 255, 0.06)", animationBackground: "rgba(255, 255, 255, 0.04)" } } }, o$n = { root: r$m, colorScheme: a$e };
var o$m = { transitionDuration: "{transition.duration}" }, r$l = { background: "{content.border.color}", borderRadius: "{content.border.radius}", size: "3px" }, e$h = { background: "{primary.color}" }, n$b = { width: "16px", height: "16px", borderRadius: "50%", background: "{primary.color}", hoverBackground: "{primary.color}", content: { borderRadius: "50%", hoverBackground: "{primary.color}", width: "12px", height: "12px", shadow: "none" }, focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" } }, d$c = { light: { handle: { content: { background: "{surface.0}" } } }, dark: { handle: { content: { background: "{surface.950}" } } } }, a$d = { root: o$m, track: r$l, range: e$h, handle: n$b, colorScheme: d$c };
var t$c = { gap: "0.5rem", transitionDuration: "{transition.duration}" }, a$c = { root: t$c };
var r$k = { borderRadius: "{form.field.border.radius}", roundedBorderRadius: "2rem", raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)" }, d$b = { root: r$k };
var o$l = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", transitionDuration: "{transition.duration}" }, r$j = { background: "{content.border.color}" }, n$a = { size: "24px", borderRadius: "{content.border.radius}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, t$b = { light: { handle: { background: "{surface.400}" } }, dark: { handle: { background: "{surface.600}" } } }, c$e = { root: o$l, gutter: r$j, handle: n$a, colorScheme: t$b };
var o$k = { transitionDuration: "{transition.duration}" }, r$i = { background: "{content.border.color}", activeBackground: "{primary.color}", margin: "0 0 0 1.625rem", size: "2px" }, e$g = { padding: "0.5rem", gap: "1rem" }, t$a = { padding: "0", borderRadius: "{content.border.radius}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" }, gap: "0.5rem" }, n$9 = { color: "{text.muted.color}", activeColor: "{primary.color}", fontWeight: "500" }, a$b = { background: "{content.background}", activeBackground: "{primary.color}", borderColor: "{content.border.color}", activeBorderColor: "{primary.color}", color: "{text.muted.color}", activeColor: "{primary.contrast.color}", size: "2.25rem", fontSize: "1.125rem", fontWeight: "500", borderRadius: "50%", shadow: "none" }, c$d = { padding: "0.875rem 0.5rem 1.125rem 0.5rem" }, i$8 = { background: "{content.background}", color: "{content.color}", padding: "0", indent: "1rem" }, d$a = { root: o$k, separator: r$i, step: e$g, stepHeader: t$a, stepTitle: n$9, stepNumber: a$b, steppanels: c$d, steppanel: i$8 };
var o$j = { transitionDuration: "{transition.duration}" }, r$h = { background: "{content.border.color}" }, t$9 = { borderRadius: "{content.border.radius}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" }, gap: "0.5rem" }, e$f = { color: "{text.muted.color}", activeColor: "{primary.color}", fontWeight: "500" }, i$7 = { background: "{content.background}", activeBackground: "{primary.color}", borderColor: "{content.border.color}", activeBorderColor: "{primary.color}", color: "{text.muted.color}", activeColor: "{primary.contrast.color}", size: "2.25rem", fontSize: "1.125rem", fontWeight: "500", borderRadius: "50%", shadow: "none" }, c$c = { root: o$j, separator: r$h, itemLink: t$9, itemLabel: e$f, itemNumber: i$7 };
var o$i = { transitionDuration: "{transition.duration}" }, r$g = { borderWidth: "0", background: "{content.background}", borderColor: "{content.border.color}" }, t$8 = { borderWidth: "2px 0 0 0", borderColor: "transparent", hoverBorderColor: "transparent", activeBorderColor: "{primary.color}", color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{primary.color}", padding: "1rem 1.25rem", fontWeight: "600", margin: "0", gap: "0.5rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, e$e = { color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{primary.color}" }, a$a = { height: "0", bottom: "0", background: "transparent" }, c$b = { light: { item: { background: "{surface.50}", hoverBackground: "{surface.100}", activeBackground: "{surface.0}" } }, dark: { item: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.900}" } } }, i$6 = { root: o$i, tablist: r$g, item: t$8, itemIcon: e$e, activeBar: a$a, colorScheme: c$b };
var o$h = { transitionDuration: "{transition.duration}" }, r$f = { borderWidth: "0", background: "{content.background}", borderColor: "{content.border.color}" }, t$7 = { borderWidth: "2px 0 0 0", borderColor: "transparent", hoverBorderColor: "transparent", activeBorderColor: "{primary.color}", color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{primary.color}", padding: "1rem 1.25rem", fontWeight: "700", margin: "0", gap: "0.5rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, n$8 = { background: "{content.background}", color: "{content.color}", padding: "0.875rem 1.125rem 1.125rem 1.125rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, c$a = { background: "{content.background}", color: "{text.muted.color}", hoverColor: "{text.color}", width: "2.5rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, e$d = { height: "0", bottom: "0", background: "transparent" }, a$9 = { light: { navButton: { shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)" }, tab: { background: "{surface.50}", hoverBackground: "{surface.100}", activeBackground: "{surface.0}" } }, dark: { navButton: { shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)" }, tab: { background: "{surface.800}", hoverBackground: "{surface.700}", activeBackground: "{surface.900}" } } }, s$4 = { root: o$h, tablist: r$f, tab: t$7, tabpanel: n$8, navButton: c$a, activeBar: e$d, colorScheme: a$9 };
var o$g = { transitionDuration: "{transition.duration}" }, r$e = { background: "{content.background}", borderColor: "{content.border.color}" }, t$6 = { borderColor: "{content.border.color}", activeBorderColor: "{primary.color}", color: "{text.muted.color}", hoverColor: "{text.color}", activeColor: "{primary.color}" }, n$7 = { background: "{content.background}", color: "{content.color}" }, a$8 = { background: "{content.background}", color: "{text.muted.color}", hoverColor: "{text.color}" }, c$9 = { light: { navButton: { shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)" } }, dark: { navButton: { shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)" } } }, e$c = { root: o$g, tabList: r$e, tab: t$6, tabPanel: n$7, navButton: a$8, colorScheme: c$9 };
var r$d = { fontSize: "0.875rem", fontWeight: "700", padding: "0.25rem 0.5rem", gap: "0.25rem", borderRadius: "{content.border.radius}", roundedBorderRadius: "{border.radius.xl}" }, o$f = { size: "0.75rem" }, c$8 = { light: { primary: { background: "{primary.color}", color: "{primary.contrast.color}" }, secondary: { background: "{surface.100}", color: "{surface.600}" }, success: { background: "{green.500}", color: "{surface.0}" }, info: { background: "{sky.500}", color: "{surface.0}" }, warn: { background: "{orange.500}", color: "{surface.0}" }, danger: { background: "{red.500}", color: "{surface.0}" }, contrast: { background: "{surface.950}", color: "{surface.0}" } }, dark: { primary: { background: "{primary.color}", color: "{primary.contrast.color}" }, secondary: { background: "{surface.800}", color: "{surface.300}" }, success: { background: "{green.400}", color: "{green.950}" }, info: { background: "{sky.400}", color: "{sky.950}" }, warn: { background: "{orange.400}", color: "{orange.950}" }, danger: { background: "{red.400}", color: "{red.950}" }, contrast: { background: "{surface.0}", color: "{surface.950}" } } }, a$7 = { root: r$d, icon: o$f, colorScheme: c$8 };
var r$c = { background: "{form.field.background}", borderColor: "{form.field.border.color}", color: "{form.field.color}", height: "18rem", padding: "{form.field.padding.y} {form.field.padding.x}", borderRadius: "{form.field.border.radius}" }, o$e = { gap: "0.25rem" }, d$9 = { margin: "2px 0" }, e$b = { root: r$c, prompt: o$e, commandResponse: d$9 };
var o$d = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, d$8 = { root: o$d };
var o$c = { background: "{content.background}", borderColor: "{content.border.color}", color: "{content.color}", borderRadius: "{content.border.radius}", shadow: "{overlay.navigation.shadow}", transitionDuration: "{transition.duration}" }, i$5 = { padding: "{navigation.list.padding}", gap: "{navigation.list.gap}" }, n$6 = { focusBackground: "{navigation.item.focus.background}", activeBackground: "{navigation.item.active.background}", color: "{navigation.item.color}", focusColor: "{navigation.item.focus.color}", activeColor: "{navigation.item.active.color}", padding: "{navigation.item.padding}", borderRadius: "{navigation.item.border.radius}", gap: "{navigation.item.gap}", icon: { color: "{navigation.item.icon.color}", focusColor: "{navigation.item.icon.focus.color}", activeColor: "{navigation.item.icon.active.color}" } }, a$6 = { mobileIndent: "1.25rem" }, t$5 = { size: "{navigation.submenu.icon.size}", color: "{navigation.submenu.icon.color}", focusColor: "{navigation.submenu.icon.focus.color}", activeColor: "{navigation.submenu.icon.active.color}" }, r$b = { borderColor: "{content.border.color}" }, c$7 = { root: o$c, list: i$5, item: n$6, submenu: a$6, submenuIcon: t$5, separator: r$b };
var e$a = { minHeight: "5rem" }, r$a = { eventContent: { padding: "1rem 0" } }, n$5 = { eventContent: { padding: "0 1rem" } }, o$b = { size: "1.125rem", borderRadius: "50%", borderWidth: "2px", background: "{content.background}", borderColor: "{primary.color}", content: { borderRadius: "50%", size: "0.375rem", background: "transparent", insetShadow: "none" } }, t$4 = { color: "{content.border.color}", size: "2px" }, a$5 = { event: e$a, horizontal: r$a, vertical: n$5, eventMarker: o$b, eventConnector: t$4 };
var o$a = { width: "25rem", borderRadius: "{content.border.radius}", borderWidth: "0 0 0 6px", transitionDuration: "{transition.duration}" }, r$9 = { size: "1.25rem" }, e$9 = { padding: "{overlay.popover.padding}", gap: "0.5rem" }, a$4 = { gap: "0.5rem" }, s$3 = { fontWeight: "500", fontSize: "1rem" }, c$6 = { fontWeight: "500", fontSize: "0.875rem" }, n$4 = { width: "2rem", height: "2rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", offset: "{focus.ring.offset}" } }, l$4 = { size: "1rem" }, u$3 = { light: { root: { blur: "1.5px" }, info: { background: "color-mix(in srgb, {blue.50}, transparent 5%)", borderColor: "{blue.500}", color: "{blue.600}", detailColor: "{surface.700}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{blue.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {blue.200}" } } }, success: { background: "color-mix(in srgb, {green.50}, transparent 5%)", borderColor: "{green.500}", color: "{green.600}", detailColor: "{surface.700}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{green.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {green.200}" } } }, warn: { background: "color-mix(in srgb,{yellow.50}, transparent 5%)", borderColor: "{yellow.500}", color: "{yellow.600}", detailColor: "{surface.700}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{yellow.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {yellow.200}" } } }, error: { background: "color-mix(in srgb, {red.50}, transparent 5%)", borderColor: "{red.500}", color: "{red.600}", detailColor: "{surface.700}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{red.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {red.200}" } } }, secondary: { background: "{surface.100}", borderColor: "{surface.500}", color: "{surface.600}", detailColor: "{surface.700}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{surface.200}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {surface.200}" } } }, contrast: { background: "{surface.900}", borderColor: "{primary.color}", color: "{surface.50}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{surface.800}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem {surface.400}" } } } }, dark: { root: { blur: "10px" }, info: { background: "color-mix(in srgb, {blue.500}, transparent 84%)", borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)", color: "{blue.500}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {blue.500}, transparent 80%)" } } }, success: { background: "color-mix(in srgb, {green.500}, transparent 84%)", borderColor: "color-mix(in srgb, {green.700}, transparent 64%)", color: "{green.500}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {green.500}, transparent 80%)" } } }, warn: { background: "color-mix(in srgb, {yellow.500}, transparent 84%)", borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)", color: "{yellow.500}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {yellow.500}, transparent 80%)" } } }, error: { background: "color-mix(in srgb, {red.500}, transparent 84%)", borderColor: "color-mix(in srgb, {red.700}, transparent 64%)", color: "{red.500}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "rgba(255, 255, 255, 0.05)", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {red.500}, transparent 80%)" } } }, secondary: { background: "{surface.800}", borderColor: "{surface.700}", color: "{surface.300}", detailColor: "{surface.0}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{surface.700}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.300}, transparent 80%)" } } }, contrast: { background: "{surface.0}", borderColor: "{surface.100}", color: "{surface.950}", detailColor: "{surface.950}", shadow: "{overlay.popover.shadow}", closeButton: { hoverBackground: "{surface.100}", focusRing: { color: "{focus.ring.color}", shadow: "0 0 0 0.2rem color-mix(in srgb, {surface.950}, transparent 80%)" } } } } }, d$7 = { root: o$a, icon: r$9, content: e$9, text: a$4, summary: s$3, detail: c$6, closeButton: n$4, closeIcon: l$4, colorScheme: u$3 };
var o$9 = { padding: "0.625rem 1rem", borderRadius: "{content.border.radius}", gap: "0.5rem", fontWeight: "500", background: "{form.field.background}", borderColor: "{form.field.border.color}", color: "{form.field.color}", hoverColor: "{form.field.color}", checkedBackground: "{highlight.background}", checkedColor: "{highlight.color}", checkedBorderColor: "{form.field.border.color}", disabledBackground: "{form.field.disabled.background}", disabledBorderColor: "{form.field.disabled.background}", disabledColor: "{form.field.disabled.color}", invalidBorderColor: "{form.field.invalid.border.color}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", padding: "0.5rem 0.75rem" }, lg: { fontSize: "{form.field.lg.font.size}", padding: "0.75rem 1.25rem" } }, r$8 = { color: "{text.muted.color}", hoverColor: "{text.muted.color}", checkedColor: "{highlight.color}", disabledColor: "{form.field.disabled.color}" }, d$6 = { checkedBackground: "transparent", checkedShadow: "none", padding: "0", borderRadius: "0", sm: { padding: "0" }, lg: { padding: "0" } }, e$8 = { light: { root: { hoverBackground: "{surface.100}" } }, dark: { root: { hoverBackground: "{surface.800}" } } }, i$4 = { root: o$9, icon: r$8, content: d$6, colorScheme: e$8 };
var r$7 = { width: "3rem", height: "1.75rem", borderRadius: "30px", gap: "0.25rem", shadow: "{form.field.shadow}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, borderWidth: "1px", borderColor: "transparent", hoverBorderColor: "transparent", checkedBorderColor: "transparent", checkedHoverBorderColor: "transparent", invalidBorderColor: "{form.field.invalid.border.color}", transitionDuration: "{form.field.transition.duration}", slideDuration: "0.2s" }, o$8 = { borderRadius: "50%", size: "1.25rem" }, e$7 = { light: { root: { background: "{surface.300}", disabledBackground: "{form.field.disabled.background}", hoverBackground: "{surface.400}", checkedBackground: "{primary.color}", checkedHoverBackground: "{primary.hover.color}" }, handle: { background: "{surface.0}", disabledBackground: "{form.field.disabled.color}", hoverBackground: "{surface.0}", checkedBackground: "{surface.0}", checkedHoverBackground: "{surface.0}", color: "{text.muted.color}", hoverColor: "{text.color}", checkedColor: "{primary.color}", checkedHoverColor: "{primary.hover.color}" } }, dark: { root: { background: "{surface.700}", disabledBackground: "{surface.600}", hoverBackground: "{surface.600}", checkedBackground: "{primary.color}", checkedHoverBackground: "{primary.hover.color}" }, handle: { background: "{surface.400}", disabledBackground: "{surface.900}", hoverBackground: "{surface.300}", checkedBackground: "{surface.900}", checkedHoverBackground: "{surface.900}", color: "{surface.900}", hoverColor: "{surface.800}", checkedColor: "{primary.color}", checkedHoverColor: "{primary.hover.color}" } } }, c$5 = { root: r$7, handle: o$8, colorScheme: e$7 };
var o$7 = { background: "{content.background}", borderColor: "{content.border.color}", borderRadius: "{content.border.radius}", color: "{content.color}", gap: "0.5rem", padding: "0.75rem" }, r$6 = { light: { root: { background: "{surface.50}", color: "{content.color}" } }, dark: { root: { background: "{surface.800}", color: "{content.color}" } } }, c$4 = { root: o$7, colorScheme: r$6 };
var r$5 = { maxWidth: "12.5rem", gutter: "0.25rem", shadow: "{overlay.popover.shadow}", padding: "0.625rem 0.75rem", borderRadius: "{overlay.popover.border.radius}" }, o$6 = { light: { root: { background: "{surface.700}", color: "{surface.0}" } }, dark: { root: { background: "{surface.700}", color: "{surface.0}" } } }, e$6 = { root: r$5, colorScheme: o$6 };
var o$5 = { background: "{content.background}", color: "{content.color}", padding: "1rem", gap: "2px", indent: "1rem", transitionDuration: "{transition.duration}" }, r$4 = { padding: "0.375rem 0.625rem", borderRadius: "{content.border.radius}", hoverBackground: "{content.hover.background}", selectedBackground: "{highlight.background}", color: "{text.color}", hoverColor: "{text.hover.color}", selectedColor: "{highlight.color}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" }, gap: "0.25rem" }, e$5 = { color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", selectedColor: "{highlight.color}" }, t$3 = { borderRadius: "50%", size: "1.75rem", hoverBackground: "{content.hover.background}", selectedHoverBackground: "{content.background}", color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", selectedHoverColor: "{primary.color}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, c$3 = { size: "2rem" }, n$3 = { margin: "0 0 0.5rem 0" }, d$5 = { root: o$5, node: r$4, nodeIcon: e$5, nodeToggleButton: t$3, loadingIcon: c$3, filter: n$3 };
var o$4 = { background: "{form.field.background}", disabledBackground: "{form.field.disabled.background}", filledBackground: "{form.field.filled.background}", filledHoverBackground: "{form.field.filled.hover.background}", filledFocusBackground: "{form.field.filled.focus.background}", borderColor: "{form.field.border.color}", hoverBorderColor: "{form.field.hover.border.color}", focusBorderColor: "{form.field.focus.border.color}", invalidBorderColor: "{form.field.invalid.border.color}", color: "{form.field.color}", disabledColor: "{form.field.disabled.color}", placeholderColor: "{form.field.placeholder.color}", invalidPlaceholderColor: "{form.field.invalid.placeholder.color}", shadow: "{form.field.shadow}", paddingX: "{form.field.padding.x}", paddingY: "{form.field.padding.y}", borderRadius: "{form.field.border.radius}", focusRing: { width: "{form.field.focus.ring.width}", style: "{form.field.focus.ring.style}", color: "{form.field.focus.ring.color}", offset: "{form.field.focus.ring.offset}", shadow: "{form.field.focus.ring.shadow}" }, transitionDuration: "{form.field.transition.duration}", sm: { fontSize: "{form.field.sm.font.size}", paddingX: "{form.field.sm.padding.x}", paddingY: "{form.field.sm.padding.y}" }, lg: { fontSize: "{form.field.lg.font.size}", paddingX: "{form.field.lg.padding.x}", paddingY: "{form.field.lg.padding.y}" } }, r$3 = { width: "2.5rem", color: "{form.field.icon.color}" }, d$4 = { background: "{overlay.select.background}", borderColor: "{overlay.select.border.color}", borderRadius: "{overlay.select.border.radius}", color: "{overlay.select.color}", shadow: "{overlay.select.shadow}" }, l$3 = { padding: "{list.padding}" }, e$4 = { padding: "{list.option.padding}" }, i$3 = { borderRadius: "{border.radius.sm}" }, f$3 = { color: "{form.field.icon.color}" }, a$3 = { root: o$4, dropdown: r$3, overlay: d$4, tree: l$3, emptyMessage: e$4, chip: i$3, clearIcon: f$3 };
var o$3 = { transitionDuration: "{transition.duration}" }, r$2 = { borderColor: "{treetable.border.color}", borderWidth: "1px 0 1px 0", padding: "0.75rem 1rem" }, e$3 = { selectedBackground: "{highlight.background}", borderColor: "{treetable.border.color}", hoverColor: "{content.hover.color}", selectedColor: "{highlight.color}", gap: "0.5rem", padding: "0.75rem 1rem", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, t$2 = { fontWeight: "700" }, c$2 = { background: "{content.background}", hoverBackground: "{content.hover.background}", selectedBackground: "{highlight.background}", color: "{content.color}", hoverColor: "{sr.hover.color}", selectedColor: "{highlight.color}", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "inset {focus.ring.shadow}" } }, l$2 = { borderColor: "{treetable.border.color}", padding: "0.75rem 1rem", gap: "0.5rem" }, d$3 = { borderColor: "{treetable.border.color}", padding: "0.75rem 1rem" }, n$2 = { fontWeight: "700" }, a$2 = { borderColor: "{treetable.border.color}", borderWidth: "0 0 1px 0", padding: "0.75rem 1rem" }, i$2 = { width: "0.5rem" }, s$2 = { width: "1px", color: "{primary.color}" }, g$2 = { color: "{text.muted.color}", hoverColor: "{text.hover.muted.color}", size: "0.875rem" }, u$2 = { size: "2rem" }, h$2 = { hoverBackground: "{content.hover.background}", selectedHoverBackground: "{content.background}", color: "{text.muted.color}", hoverColor: "{text.color}", selectedHoverColor: "{primary.color}", size: "1.75rem", borderRadius: "50%", focusRing: { width: "{focus.ring.width}", style: "{focus.ring.style}", color: "{focus.ring.color}", offset: "{focus.ring.offset}", shadow: "{focus.ring.shadow}" } }, f$2 = { borderColor: "{content.border.color}", borderWidth: "0 0 1px 0" }, b$2 = { borderColor: "{content.border.color}", borderWidth: "0 0 1px 0" }, m$3 = { light: { root: { borderColor: "{content.border.color}" }, header: { background: "{surface.50}", color: "{text.color}" }, headerCell: { background: "{surface.50}", hoverBackground: "{surface.100}", color: "{text.color}" }, footer: { background: "{surface.50}", color: "{text.color}" }, footerCell: { background: "{surface.50}", color: "{text.color}" }, bodyCell: { selectedBorderColor: "{primary.100}" } }, dark: { root: { borderColor: "{surface.800}" }, header: { background: "{surface.800}", color: "{text.color}" }, headerCell: { background: "{surface.800}", hoverBackground: "{surface.700}", color: "{text.color}" }, footer: { background: "{surface.800}", color: "{text.color}" }, footerCell: { background: "{surface.800}", color: "{text.color}" }, bodyCell: { selectedBorderColor: "{primary.900}" } } }, C$2 = { root: o$3, header: r$2, headerCell: e$3, columnTitle: t$2, row: c$2, bodyCell: l$2, footerCell: d$3, columnFooter: n$2, footer: a$2, columnResizer: i$2, resizeIndicator: s$2, sortIcon: g$2, loadingIcon: u$2, nodeToggleButton: h$2, paginatorTop: f$2, paginatorBottom: b$2, colorScheme: m$3 };
var o$2 = { mask: { background: "{content.background}", color: "{text.muted.color}" }, icon: { size: "2rem" } }, e$2 = { loader: o$2 };
function _typeof$i(o2) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$i(o2);
}
function ownKeys$c(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$a(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$c(Object(t2), true).forEach(function(r3) {
      _defineProperty$i(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$c(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$i(e2, r2, t2) {
  return (r2 = _toPropertyKey$i(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$i(t2) {
  var i2 = _toPrimitive$i(t2, "string");
  return "symbol" == _typeof$i(i2) ? i2 : i2 + "";
}
function _toPrimitive$i(t2, r2) {
  if ("object" != _typeof$i(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$i(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var index = _objectSpread$a(_objectSpread$a({}, e$S), {}, {
  components: {
    accordion: d$D,
    autocomplete: a$I,
    avatar: n$A,
    badge: d$B,
    blockui: o$1i,
    breadcrumb: t$C,
    button: e$R,
    datepicker: k$2,
    card: d$A,
    carousel: t$A,
    cascadeselect: f$a,
    checkbox: e$O,
    chip: s$a,
    colorpicker: d$y,
    confirmdialog: r$16,
    confirmpopup: a$D,
    contextmenu: c$t,
    dataview: a$A,
    datatable: k$3,
    dialog: e$G,
    divider: t$v,
    dock: d$t,
    drawer: e$E,
    editor: d$r,
    fieldset: n$t,
    fileupload: i$l,
    iftalabel: i$i,
    floatlabel: d$p,
    galleria: l$b,
    iconfield: r$T,
    image: i$h,
    imagecompare: o$T,
    inlinemessage: a$s,
    inplace: n$p,
    inputchips: f$6,
    inputgroup: d$m,
    inputnumber: d$l,
    inputotp: e$w,
    inputtext: d$k,
    knob: c$l,
    listbox: n$n,
    megamenu: u$5,
    menu: r$H,
    menubar: c$j,
    message: u$4,
    metergroup: b$3,
    multiselect: n$i,
    orderlist: o$E,
    organizationchart: n$h,
    overlaybadge: t$h,
    popover: e$l,
    paginator: n$g,
    password: n$d,
    panel: n$f,
    panelmenu: a$j,
    picklist: o$x,
    progressbar: t$d,
    progressspinner: r$t,
    radiobutton: e$j,
    rating: i$a,
    ripple: o$r,
    scrollpanel: a$g,
    select: n$c,
    selectbutton: d$d,
    skeleton: o$n,
    slider: a$d,
    speeddial: a$c,
    splitter: c$e,
    splitbutton: d$b,
    stepper: d$a,
    steps: c$c,
    tabmenu: i$6,
    tabs: s$4,
    tabview: e$c,
    textarea: d$8,
    tieredmenu: c$7,
    tag: a$7,
    terminal: e$b,
    timeline: a$5,
    togglebutton: i$4,
    toggleswitch: c$5,
    tree: d$5,
    treeselect: a$3,
    treetable: C$2,
    toast: d$7,
    toolbar: c$4,
    tooltip: e$6,
    virtualscroller: e$2
  }
});
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = (
  /* istanbul ignore next */
  /* @__PURE__ */ Symbol()
);
function isPlainObject$1(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => /* @__PURE__ */ ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      pinia2._a = app2;
      app2.provide(piniaSymbol, pinia2);
      app2.config.globalProperties.$pinia = pinia2;
      toBeInstalled.forEach((plugin) => _p.push(plugin));
      toBeInstalled = [];
    },
    use(plugin) {
      if (!this._a) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop$4 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$4) {
  subscriptions.add(callback);
  const removeSubscription = () => {
    const isDel = subscriptions.delete(callback);
    isDel && onCleanup();
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = /* @__PURE__ */ Symbol();
const ACTION_NAME = /* @__PURE__ */ Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !/* @__PURE__ */ isRef(subPatch) && !/* @__PURE__ */ isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  /* @__PURE__ */ Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
}
const { assign: assign$1 } = Object;
function isComputed(o2) {
  return !!(/* @__PURE__ */ isRef(o2) && o2.effect);
}
function createOptionsStore(id, options, pinia2, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia2.state.value[id];
  let store;
  function setup3() {
    if (!initialState && true) {
      pinia2.state.value[id] = state ? state() : {};
    }
    const localState = /* @__PURE__ */ toRefs(pinia2.state.value[id]);
    return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup3, options, pinia2, hot, true);
  return store;
}
function createSetupStore($id2, setup3, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$1({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = /* @__PURE__ */ new Set();
  let actionSubscriptions = /* @__PURE__ */ new Set();
  let debuggerEvents;
  const initialState = pinia2.state.value[$id2];
  if (!isOptionsStore && !initialState && true) {
    pinia2.state.value[$id2] = {};
  }
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id2]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id2,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id2], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id2,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = /* @__PURE__ */ Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id2]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$1($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$4
  );
  function $dispose() {
    scope.stop();
    subscriptions.clear();
    actionSubscriptions.clear();
    pinia2._s.delete($id2);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackSet = /* @__PURE__ */ new Set();
      const onErrorCallbackSet = /* @__PURE__ */ new Set();
      function after(callback) {
        afterCallbackSet.add(callback);
      }
      function onError2(callback) {
        onErrorCallbackSet.add(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError: onError2
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id2 ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackSet, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackSet, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackSet, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackSet, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id: $id2,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id2], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id2,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$1({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = /* @__PURE__ */ reactive(partialStore);
  pinia2._s.set($id2, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(() => setup3({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (/* @__PURE__ */ isRef(prop) && !isComputed(prop) || /* @__PURE__ */ isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (/* @__PURE__ */ isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        pinia2.state.value[$id2][key] = prop;
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      setupStore[key] = actionValue;
      optionsForPlugin.actions[key] = prop;
    } else ;
  }
  assign$1(store, setupStore);
  assign$1(/* @__PURE__ */ toRaw(store), setupStore);
  Object.defineProperty(store, "$state", {
    get: () => pinia2.state.value[$id2],
    set: (state) => {
      $patch(($state) => {
        assign$1($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign$1(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
// @__NO_SIDE_EFFECTS__
function defineStore(id, setup3, setupOptions) {
  let options;
  const isSetupStore = typeof setup3 === "function";
  options = isSetupStore ? setupOptions : setup3;
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup3, options, pinia2);
      } else {
        createOptionsStore(id, options, pinia2);
      }
    }
    const store = pinia2._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
function get(obj, path) {
  if (obj == null) return void 0;
  let value = obj;
  for (let i2 = 0; i2 < path.length; i2++) {
    if (value === void 0 || value[path[i2]] === void 0) return void 0;
    if (value === null || value[path[i2]] === null) return null;
    value = value[path[i2]];
  }
  return value;
}
function set(obj, value, path) {
  if (path.length === 0) return value;
  const idx = path[0];
  if (path.length > 1) value = set(typeof obj !== "object" || obj === null || !Object.prototype.hasOwnProperty.call(obj, idx) ? Number.isInteger(Number(path[1])) ? [] : {} : obj[idx], value, Array.prototype.slice.call(path, 1));
  if (Number.isInteger(Number(idx)) && Array.isArray(obj)) return obj.slice()[idx];
  return Object.assign({}, obj, { [idx]: value });
}
function unset(obj, path) {
  if (obj == null || path.length === 0) return obj;
  if (path.length === 1) {
    if (obj == null) return obj;
    if (Number.isInteger(path[0]) && Array.isArray(obj)) return Array.prototype.slice.call(obj, 0).splice(path[0], 1);
    const result = {};
    for (const p2 in obj) result[p2] = obj[p2];
    delete result[path[0]];
    return result;
  }
  if (obj[path[0]] == null) {
    if (Number.isInteger(path[0]) && Array.isArray(obj)) return Array.prototype.concat.call([], obj);
    const result = {};
    for (const p2 in obj) result[p2] = obj[p2];
    return result;
  }
  return set(obj, unset(obj[path[0]], Array.prototype.slice.call(path, 1)), [path[0]]);
}
function deepPick(obj, paths) {
  return paths.map((p2) => p2.split(".")).map((p2) => [p2, get(obj, p2)]).filter((t2) => t2[1] !== void 0).reduce((acc, cur) => set(acc, cur[1], cur[0]), {});
}
function deepOmit(obj, paths) {
  return paths.map((p2) => p2.split(".")).reduce((acc, cur) => unset(acc, cur), obj);
}
function hydrateStore(store, { storage, serializer, key, debug, pick, omit, beforeHydrate, afterHydrate }, context, runHooks = true) {
  try {
    if (runHooks) beforeHydrate?.(context);
    const fromStorage = storage.getItem(key);
    if (fromStorage) {
      const deserialized = serializer.deserialize(fromStorage);
      const picked = pick ? deepPick(deserialized, pick) : deserialized;
      const omitted = omit ? deepOmit(picked, omit) : picked;
      store.$patch(omitted);
    }
    if (runHooks) afterHydrate?.(context);
  } catch (error) {
    if (debug) console.error("[pinia-plugin-persistedstate]", error);
  }
}
function persistState(state, { storage, serializer, key, debug, pick, omit }) {
  try {
    const picked = pick ? deepPick(state, pick) : state;
    const omitted = omit ? deepOmit(picked, omit) : picked;
    const toStorage = serializer.serialize(omitted);
    storage.setItem(key, toStorage);
  } catch (error) {
    if (debug) console.error("[pinia-plugin-persistedstate]", error);
  }
}
function parsePersistKey(key, storeId) {
  return typeof key === "function" ? key(storeId) : typeof key === "string" ? key : storeId;
}
function createPersistence(context, optionsParser, auto) {
  const { pinia: pinia2, store, options: { persist = auto } } = context;
  if (!persist) return;
  if (!(store.$id in pinia2.state.value)) {
    const originalStore = pinia2._s.get(store.$id.replace("__hot:", ""));
    if (originalStore) Promise.resolve().then(() => originalStore.$persist());
    return;
  }
  const persistences = (Array.isArray(persist) ? persist : persist === true ? [{}] : [persist]).map(optionsParser);
  store.$hydrate = ({ runHooks = true } = {}) => {
    persistences.forEach((p2) => {
      hydrateStore(store, p2, context, runHooks);
    });
  };
  store.$persist = () => {
    persistences.forEach((p2) => {
      persistState(store.$state, p2);
    });
  };
  persistences.forEach((p2) => {
    hydrateStore(store, p2, context);
    store.$subscribe((_mutation, state) => persistState(state, p2), { detached: true });
  });
}
function createPersistedState(options = {}) {
  return function(context) {
    createPersistence(context, (p2) => {
      const persistKey = parsePersistKey(p2.key, context.store.$id);
      return {
        key: (options.key ? options.key : (x2) => x2)(persistKey),
        debug: p2.debug ?? options.debug ?? false,
        serializer: p2.serializer ?? options.serializer ?? {
          serialize: (data6) => JSON.stringify(data6),
          deserialize: (data6) => JSON.parse(data6)
        },
        storage: p2.storage ?? options.storage ?? window.localStorage,
        beforeHydrate: p2.beforeHydrate ?? options.beforeHydrate,
        afterHydrate: p2.afterHydrate ?? options.afterHydrate,
        pick: p2.pick,
        omit: p2.omit
      };
    }, options.auto ?? false);
  };
}
var src_default = createPersistedState();
var FilterMatchMode = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
var style$8 = "\n    *,\n    ::before,\n    ::after {\n        box-sizing: border-box;\n    }\n\n    .p-collapsible-enter-active {\n        animation: p-animate-collapsible-expand 0.2s ease-out;\n        overflow: hidden;\n    }\n\n    .p-collapsible-leave-active {\n        animation: p-animate-collapsible-collapse 0.2s ease-out;\n        overflow: hidden;\n    }\n\n    @keyframes p-animate-collapsible-expand {\n        from {\n            grid-template-rows: 0fr;\n        }\n        to {\n            grid-template-rows: 1fr;\n        }\n    }\n\n    @keyframes p-animate-collapsible-collapse {\n        from {\n            grid-template-rows: 1fr;\n        }\n        to {\n            grid-template-rows: 0fr;\n        }\n    }\n\n    .p-disabled,\n    .p-disabled * {\n        cursor: default;\n        pointer-events: none;\n        user-select: none;\n    }\n\n    .p-disabled,\n    .p-component:disabled {\n        opacity: dt('disabled.opacity');\n    }\n\n    .pi {\n        font-size: dt('icon.size');\n    }\n\n    .p-icon {\n        width: dt('icon.size');\n        height: dt('icon.size');\n    }\n\n    .p-overlay-mask {\n        background: var(--px-mask-background, dt('mask.background'));\n        color: dt('mask.color');\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    .p-overlay-mask-enter-active {\n        animation: p-animate-overlay-mask-enter dt('mask.transition.duration') forwards;\n    }\n\n    .p-overlay-mask-leave-active {\n        animation: p-animate-overlay-mask-leave dt('mask.transition.duration') forwards;\n    }\n\n    @keyframes p-animate-overlay-mask-enter {\n        from {\n            background: transparent;\n        }\n        to {\n            background: var(--px-mask-background, dt('mask.background'));\n        }\n    }\n    @keyframes p-animate-overlay-mask-leave {\n        from {\n            background: var(--px-mask-background, dt('mask.background'));\n        }\n        to {\n            background: transparent;\n        }\n    }\n\n    .p-anchored-overlay-enter-active {\n        animation: p-animate-anchored-overlay-enter 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    .p-anchored-overlay-leave-active {\n        animation: p-animate-anchored-overlay-leave 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    @keyframes p-animate-anchored-overlay-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n\n    @keyframes p-animate-anchored-overlay-leave {\n        to {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n";
function _typeof$h(o2) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$h(o2);
}
function ownKeys$b(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$9(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$b(Object(t2), true).forEach(function(r3) {
      _defineProperty$h(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$b(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$h(e2, r2, t2) {
  return (r2 = _toPropertyKey$h(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$h(t2) {
  var i2 = _toPrimitive$h(t2, "string");
  return "symbol" == _typeof$h(i2) ? i2 : i2 + "";
}
function _toPrimitive$h(t2, r2) {
  if ("object" != _typeof$h(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$h(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function tryOnMounted(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance() && getCurrentInstance().components) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
var _id = 0;
function useStyle(css3) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var isLoaded = /* @__PURE__ */ ref(false);
  var cssRef = /* @__PURE__ */ ref(css3);
  var styleRef = /* @__PURE__ */ ref(null);
  var defaultDocument = tt$1() ? window.document : void 0;
  var _options$document = options.document, document2 = _options$document === void 0 ? defaultDocument : _options$document, _options$immediate = options.immediate, immediate = _options$immediate === void 0 ? true : _options$immediate, _options$manual = options.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options.name, name = _options$name === void 0 ? "style_".concat(++_id) : _options$name, _options$id = options.id, id = _options$id === void 0 ? void 0 : _options$id, _options$media = options.media, media = _options$media === void 0 ? void 0 : _options$media, _options$nonce = options.nonce, nonce = _options$nonce === void 0 ? void 0 : _options$nonce, _options$first = options.first, first = _options$first === void 0 ? false : _options$first, _options$onMounted = options.onMounted, onStyleMounted = _options$onMounted === void 0 ? void 0 : _options$onMounted, _options$onUpdated = options.onUpdated, onStyleUpdated = _options$onUpdated === void 0 ? void 0 : _options$onUpdated, _options$onLoad = options.onLoad, onStyleLoaded = _options$onLoad === void 0 ? void 0 : _options$onLoad, _options$props = options.props, props = _options$props === void 0 ? {} : _options$props;
  var stop = function stop2() {
  };
  var load2 = function load3(_css) {
    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!document2) return;
    var _styleProps = _objectSpread$9(_objectSpread$9({}, props), _props);
    var _name = _styleProps.name || name, _id2 = _styleProps.id || id, _nonce = _styleProps.nonce || nonce;
    styleRef.value = document2.querySelector('style[data-primevue-style-id="'.concat(_name, '"]')) || document2.getElementById(_id2) || document2.createElement("style");
    if (!styleRef.value.isConnected) {
      cssRef.value = _css || css3;
      A$3(styleRef.value, {
        type: "text/css",
        id: _id2,
        media,
        nonce: _nonce
      });
      first ? document2.head.prepend(styleRef.value) : document2.head.appendChild(styleRef.value);
      _t$2(styleRef.value, "data-primevue-style-id", _name);
      A$3(styleRef.value, _styleProps);
      styleRef.value.onload = function(event) {
        return onStyleLoaded === null || onStyleLoaded === void 0 ? void 0 : onStyleLoaded(event, {
          name: _name
        });
      };
      onStyleMounted === null || onStyleMounted === void 0 || onStyleMounted(_name);
    }
    if (isLoaded.value) return;
    stop = watch(cssRef, function(value) {
      styleRef.value.textContent = value;
      onStyleUpdated === null || onStyleUpdated === void 0 || onStyleUpdated(_name);
    }, {
      immediate: true
    });
    isLoaded.value = true;
  };
  var unload = function unload2() {
    if (!document2 || !isLoaded.value) return;
    stop();
    T$2(styleRef.value) && document2.head.removeChild(styleRef.value);
    isLoaded.value = false;
    styleRef.value = null;
  };
  if (immediate && !manual) tryOnMounted(load2);
  return {
    id,
    name,
    el: styleRef,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: /* @__PURE__ */ readonly(isLoaded)
  };
}
function _typeof$g(o2) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$g(o2);
}
var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _slicedToArray$4(r2, e2) {
  return _arrayWithHoles$4(r2) || _iterableToArrayLimit$4(r2, e2) || _unsupportedIterableToArray$f(r2, e2) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$f(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$f(r2, a2) : void 0;
  }
}
function _arrayLikeToArray$f(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _iterableToArrayLimit$4(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$4(r2) {
  if (Array.isArray(r2)) return r2;
}
function ownKeys$a(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$8(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$a(Object(t2), true).forEach(function(r3) {
      _defineProperty$g(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$a(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$g(e2, r2, t2) {
  return (r2 = _toPropertyKey$g(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$g(t2) {
  var i2 = _toPrimitive$g(t2, "string");
  return "symbol" == _typeof$g(i2) ? i2 : i2 + "";
}
function _toPrimitive$g(t2, r2) {
  if ("object" != _typeof$g(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$g(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _taggedTemplateLiteral(e2, t2) {
  return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(t2) } }));
}
var css$2 = function css(_ref2) {
  var dt2 = _ref2.dt;
  return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    opacity: 0;\n    overflow: hidden;\n    padding: 0;\n    pointer-events: none;\n    position: absolute;\n    white-space: nowrap;\n    width: 1px;\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(dt2("scrollbar.width"), ";\n}\n");
};
var classes$8 = {};
var inlineStyles$1 = {};
var BaseStyle = {
  name: "base",
  css: css$2,
  style: style$8,
  classes: classes$8,
  inlineStyles: inlineStyles$1,
  load: function load(style2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var transform = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(cs2) {
      return cs2;
    };
    var computedStyle = transform(ar(_templateObject || (_templateObject = _taggedTemplateLiteral(["", ""])), style2));
    return s$e(computedStyle) ? useStyle(Y$4(computedStyle), _objectSpread$8({
      name: this.name
    }, options)) : {};
  },
  loadCSS: function loadCSS() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, options);
  },
  loadStyle: function loadStyle() {
    var _this = this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var style2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return this.load(this.style, options, function() {
      var computedStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return S$2.transformCSS(options.name || _this.name, "".concat(computedStyle).concat(ar(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["", ""])), style2)));
    });
  },
  getCommonTheme: function getCommonTheme(params) {
    return S$2.getCommon(this.name, params);
  },
  getComponentTheme: function getComponentTheme(params) {
    return S$2.getComponent(this.name, params);
  },
  getDirectiveTheme: function getDirectiveTheme(params) {
    return S$2.getDirective(this.name, params);
  },
  getPresetTheme: function getPresetTheme(preset, selector, params) {
    return S$2.getCustomPreset(this.name, preset, selector, params);
  },
  getLayerOrderThemeCSS: function getLayerOrderThemeCSS() {
    return S$2.getLayerOrderCSS(this.name);
  },
  getStyleSheet: function getStyleSheet() {
    var extendedCSS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var _css = m$6(this.css, {
        dt: E$2
      }) || "";
      var _style = Y$4(ar(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["", "", ""])), _css, extendedCSS));
      var _props = Object.entries(props).reduce(function(acc, _ref2) {
        var _ref3 = _slicedToArray$4(_ref2, 2), k2 = _ref3[0], v2 = _ref3[1];
        return acc.push("".concat(k2, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      return s$e(_style) ? '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(_props, ">").concat(_style, "</style>") : "";
    }
    return "";
  },
  getCommonThemeStyleSheet: function getCommonThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return S$2.getCommonStyleSheet(this.name, params, props);
  },
  getThemeStyleSheet: function getThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var css3 = [S$2.getStyleSheet(this.name, params, props)];
    if (this.style) {
      var name = this.name === "base" ? "global-style" : "".concat(this.name, "-style");
      var _css = ar(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["", ""])), m$6(this.style, {
        dt: E$2
      }));
      var _style = Y$4(S$2.transformCSS(name, _css));
      var _props = Object.entries(props).reduce(function(acc, _ref4) {
        var _ref5 = _slicedToArray$4(_ref4, 2), k2 = _ref5[0], v2 = _ref5[1];
        return acc.push("".concat(k2, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      s$e(_style) && css3.push('<style type="text/css" data-primevue-style-id="'.concat(name, '" ').concat(_props, ">").concat(_style, "</style>"));
    }
    return css3.join("");
  },
  extend: function extend(inStyle) {
    return _objectSpread$8(_objectSpread$8({}, this), {}, {
      css: void 0,
      style: void 0
    }, inStyle);
  }
};
var PrimeVueService = s$d();
function _typeof$f(o2) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$f(o2);
}
function ownKeys$9(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$7(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$9(Object(t2), true).forEach(function(r3) {
      _defineProperty$f(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$9(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$f(e2, r2, t2) {
  return (r2 = _toPropertyKey$f(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$f(t2) {
  var i2 = _toPrimitive$f(t2, "string");
  return "symbol" == _typeof$f(i2) ? i2 : i2 + "";
}
function _toPrimitive$f(t2, r2) {
  if ("object" != _typeof$f(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$f(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var defaultOptions$1 = {
  ripple: false,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: false,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: false,
  pt: void 0,
  ptOptions: {
    mergeSections: true,
    mergeProps: false
  },
  csp: {
    nonce: void 0
  }
};
var PrimeVueSymbol = /* @__PURE__ */ Symbol();
function setup(app2, options) {
  var PrimeVue2 = {
    config: /* @__PURE__ */ reactive(options)
  };
  app2.config.globalProperties.$primevue = PrimeVue2;
  app2.provide(PrimeVueSymbol, PrimeVue2);
  clearConfig();
  setupConfig(app2, PrimeVue2);
  return PrimeVue2;
}
var stopWatchers = [];
function clearConfig() {
  N$2.clear();
  stopWatchers.forEach(function(fn) {
    return fn === null || fn === void 0 ? void 0 : fn();
  });
  stopWatchers = [];
}
function setupConfig(app2, PrimeVue2) {
  var isThemeChanged = /* @__PURE__ */ ref(false);
  var loadCommonTheme = function loadCommonTheme2() {
    var _PrimeVue$config;
    if (((_PrimeVue$config = PrimeVue2.config) === null || _PrimeVue$config === void 0 ? void 0 : _PrimeVue$config.theme) === "none") return;
    if (!S$2.isStyleNameLoaded("common")) {
      var _BaseStyle$getCommonT, _PrimeVue$config2;
      var _ref2 = ((_BaseStyle$getCommonT = BaseStyle.getCommonTheme) === null || _BaseStyle$getCommonT === void 0 ? void 0 : _BaseStyle$getCommonT.call(BaseStyle)) || {}, primitive = _ref2.primitive, semantic = _ref2.semantic, global2 = _ref2.global, style2 = _ref2.style;
      var styleOptions = {
        nonce: (_PrimeVue$config2 = PrimeVue2.config) === null || _PrimeVue$config2 === void 0 || (_PrimeVue$config2 = _PrimeVue$config2.csp) === null || _PrimeVue$config2 === void 0 ? void 0 : _PrimeVue$config2.nonce
      };
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$7({
        name: "primitive-variables"
      }, styleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$7({
        name: "semantic-variables"
      }, styleOptions));
      BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$7({
        name: "global-variables"
      }, styleOptions));
      BaseStyle.loadStyle(_objectSpread$7({
        name: "global-style"
      }, styleOptions), style2);
      S$2.setLoadedStyleName("common");
    }
  };
  N$2.on("theme:change", function(newTheme) {
    if (!isThemeChanged.value) {
      app2.config.globalProperties.$primevue.config.theme = newTheme;
      isThemeChanged.value = true;
    }
  });
  var stopConfigWatcher = watch(PrimeVue2.config, function(newValue, oldValue) {
    PrimeVueService.emit("config:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopRippleWatcher = watch(function() {
    return PrimeVue2.config.ripple;
  }, function(newValue, oldValue) {
    PrimeVueService.emit("config:ripple:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopThemeWatcher = watch(function() {
    return PrimeVue2.config.theme;
  }, function(newValue, oldValue) {
    if (!isThemeChanged.value) {
      S$2.setTheme(newValue);
    }
    if (!PrimeVue2.config.unstyled) {
      loadCommonTheme();
    }
    isThemeChanged.value = false;
    PrimeVueService.emit("config:theme:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: false
  });
  var stopUnstyledWatcher = watch(function() {
    return PrimeVue2.config.unstyled;
  }, function(newValue, oldValue) {
    if (!newValue && PrimeVue2.config.theme) {
      loadCommonTheme();
    }
    PrimeVueService.emit("config:unstyled:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  stopWatchers.push(stopConfigWatcher);
  stopWatchers.push(stopRippleWatcher);
  stopWatchers.push(stopThemeWatcher);
  stopWatchers.push(stopUnstyledWatcher);
}
var PrimeVue = {
  install: function install(app2, options) {
    var configOptions = H$2(defaultOptions$1, options);
    setup(app2, configOptions);
  }
};
function _typeof$1$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1$1(o2);
}
function _classCallCheck$1(a2, n2) {
  if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey$1$1(o2.key), o2);
  }
}
function _createClass$1(e2, r2, t2) {
  return r2 && _defineProperties$1(e2.prototype, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function _toPropertyKey$1$1(t2) {
  var i2 = _toPrimitive$1$1(t2, "string");
  return "symbol" == _typeof$1$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1$1(t2, r2) {
  if ("object" != _typeof$1$1(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$1$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
var ConnectedOverlayScrollHandler = /* @__PURE__ */ (function() {
  function ConnectedOverlayScrollHandler2(element) {
    var listener2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    _classCallCheck$1(this, ConnectedOverlayScrollHandler2);
    this.element = element;
    this.listener = listener2;
  }
  return _createClass$1(ConnectedOverlayScrollHandler2, [{
    key: "bindScrollListener",
    value: function bindScrollListener3() {
      this.scrollableParents = At$1(this.element);
      for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
        this.scrollableParents[i2].addEventListener("scroll", this.listener);
      }
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener3() {
      if (this.scrollableParents) {
        for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
          this.scrollableParents[i2].removeEventListener("scroll", this.listener);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }
  }]);
})();
var Base = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: function getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded: function isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName: function setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName: function deleteLoadedStyleName(name) {
    this._loadedStyleNames["delete"](name);
  },
  clearLoadedStyleNames: function clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  }
};
function _typeof$e(o2) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$e(o2);
}
function _slicedToArray$3(r2, e2) {
  return _arrayWithHoles$3(r2) || _iterableToArrayLimit$3(r2, e2) || _unsupportedIterableToArray$e(r2, e2) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$e(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$e(r2, a2) : void 0;
  }
}
function _arrayLikeToArray$e(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _iterableToArrayLimit$3(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$3(r2) {
  if (Array.isArray(r2)) return r2;
}
function ownKeys$8(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$6(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$8(Object(t2), true).forEach(function(r3) {
      _defineProperty$e(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$8(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$e(e2, r2, t2) {
  return (r2 = _toPropertyKey$e(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$e(t2) {
  var i2 = _toPrimitive$e(t2, "string");
  return "symbol" == _typeof$e(i2) ? i2 : i2 + "";
}
function _toPrimitive$e(t2, r2) {
  if ("object" != _typeof$e(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$e(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var BaseDirective = {
  _getMeta: function _getMeta() {
    return [i$v(arguments.length <= 0 ? void 0 : arguments[0]) ? void 0 : arguments.length <= 0 ? void 0 : arguments[0], m$6(i$v(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  },
  _getConfig: function _getConfig(binding, vnode) {
    var _ref2, _binding$instance, _vnode$ctx;
    return (_ref2 = (binding === null || binding === void 0 || (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$primevue) || (vnode === null || vnode === void 0 || (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.appContext) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.config) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.globalProperties) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.$primevue)) === null || _ref2 === void 0 ? void 0 : _ref2.config;
  },
  _getOptionValue: F$4,
  _getPTValue: function _getPTValue() {
    var _instance$binding, _instance$$primevueCo;
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var obj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var searchInDefaultPT = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var getValue = function getValue2() {
      var value = BaseDirective._getOptionValue.apply(BaseDirective, arguments);
      return a$J(value) || C$5(value) ? {
        "class": value
      } : value;
    };
    var _ref2 = ((_instance$binding = instance2.binding) === null || _instance$binding === void 0 || (_instance$binding = _instance$binding.value) === null || _instance$binding === void 0 ? void 0 : _instance$binding.ptOptions) || ((_instance$$primevueCo = instance2.$primevueConfig) === null || _instance$$primevueCo === void 0 ? void 0 : _instance$$primevueCo.ptOptions) || {}, _ref2$mergeSections = _ref2.mergeSections, mergeSections = _ref2$mergeSections === void 0 ? true : _ref2$mergeSections, _ref2$mergeProps = _ref2.mergeProps, useMergeProps = _ref2$mergeProps === void 0 ? false : _ref2$mergeProps;
    var global2 = searchInDefaultPT ? BaseDirective._useDefaultPT(instance2, instance2.defaultPT(), getValue, key, params) : void 0;
    var self2 = BaseDirective._usePT(instance2, BaseDirective._getPT(obj, instance2.$name), getValue, key, _objectSpread$6(_objectSpread$6({}, params), {}, {
      global: global2 || {}
    }));
    var datasets = BaseDirective._getPTDatasets(instance2, key);
    return mergeSections || !mergeSections && self2 ? useMergeProps ? BaseDirective._mergeProps(instance2, useMergeProps, global2, self2, datasets) : _objectSpread$6(_objectSpread$6(_objectSpread$6({}, global2), self2), datasets) : _objectSpread$6(_objectSpread$6({}, self2), datasets);
  },
  _getPTDatasets: function _getPTDatasets() {
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var datasetPrefix = "data-pc-";
    return _objectSpread$6(_objectSpread$6({}, key === "root" && _defineProperty$e({}, "".concat(datasetPrefix, "name"), g$8(instance2.$name))), {}, _defineProperty$e({}, "".concat(datasetPrefix, "section"), g$8(key)));
  },
  _getPT: function _getPT(pt2) {
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var getValue = function getValue2(value) {
      var _computedValue$_key;
      var computedValue = callback ? callback(value) : value;
      var _key = g$8(key);
      return (_computedValue$_key = computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _computedValue$_key !== void 0 ? _computedValue$_key : computedValue;
    };
    return pt2 && Object.hasOwn(pt2, "_usept") ? {
      _usept: pt2["_usept"],
      originalValue: getValue(pt2.originalValue),
      value: getValue(pt2.value)
    } : getValue(pt2);
  },
  _usePT: function _usePT() {
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var pt2 = arguments.length > 1 ? arguments[1] : void 0;
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    var fn = function fn2(value2) {
      return callback(value2, key, params);
    };
    if (pt2 && Object.hasOwn(pt2, "_usept")) {
      var _instance$$primevueCo2;
      var _ref4 = pt2["_usept"] || ((_instance$$primevueCo2 = instance2.$primevueConfig) === null || _instance$$primevueCo2 === void 0 ? void 0 : _instance$$primevueCo2.ptOptions) || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps;
      var originalValue = fn(pt2.originalValue);
      var value = fn(pt2.value);
      if (originalValue === void 0 && value === void 0) return void 0;
      else if (a$J(value)) return value;
      else if (a$J(originalValue)) return originalValue;
      return mergeSections || !mergeSections && value ? useMergeProps ? BaseDirective._mergeProps(instance2, useMergeProps, originalValue, value) : _objectSpread$6(_objectSpread$6({}, originalValue), value) : value;
    }
    return fn(pt2);
  },
  _useDefaultPT: function _useDefaultPT() {
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaultPT2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    return BaseDirective._usePT(instance2, defaultPT2, callback, key, params);
  },
  _loadStyles: function _loadStyles() {
    var _config$csp;
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var binding = arguments.length > 1 ? arguments[1] : void 0;
    var vnode = arguments.length > 2 ? arguments[2] : void 0;
    var config2 = BaseDirective._getConfig(binding, vnode);
    var useStyleOptions = {
      nonce: config2 === null || config2 === void 0 || (_config$csp = config2.csp) === null || _config$csp === void 0 ? void 0 : _config$csp.nonce
    };
    BaseDirective._loadCoreStyles(instance2, useStyleOptions);
    BaseDirective._loadThemeStyles(instance2, useStyleOptions);
    BaseDirective._loadScopedThemeStyles(instance2, useStyleOptions);
    BaseDirective._removeThemeListeners(instance2);
    instance2.$loadStyles = function() {
      return BaseDirective._loadThemeStyles(instance2, useStyleOptions);
    };
    BaseDirective._themeChangeListener(instance2.$loadStyles);
  },
  _loadCoreStyles: function _loadCoreStyles() {
    var _instance$$style, _instance$$style2;
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (!Base.isStyleNameLoaded((_instance$$style = instance2.$style) === null || _instance$$style === void 0 ? void 0 : _instance$$style.name) && (_instance$$style2 = instance2.$style) !== null && _instance$$style2 !== void 0 && _instance$$style2.name) {
      var _instance$$style3;
      BaseStyle.loadCSS(useStyleOptions);
      (_instance$$style3 = instance2.$style) === null || _instance$$style3 === void 0 || _instance$$style3.loadCSS(useStyleOptions);
      Base.setLoadedStyleName(instance2.$style.name);
    }
  },
  _loadThemeStyles: function _loadThemeStyles() {
    var _instance$theme, _instance$$style5, _instance$$style6;
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (instance2 !== null && instance2 !== void 0 && instance2.isUnstyled() || (instance2 === null || instance2 === void 0 || (_instance$theme = instance2.theme) === null || _instance$theme === void 0 ? void 0 : _instance$theme.call(instance2)) === "none") return;
    if (!S$2.isStyleNameLoaded("common")) {
      var _instance$$style4, _instance$$style4$get;
      var _ref5 = ((_instance$$style4 = instance2.$style) === null || _instance$$style4 === void 0 || (_instance$$style4$get = _instance$$style4.getCommonTheme) === null || _instance$$style4$get === void 0 ? void 0 : _instance$$style4$get.call(_instance$$style4)) || {}, primitive = _ref5.primitive, semantic = _ref5.semantic, global2 = _ref5.global, style2 = _ref5.style;
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$6({
        name: "primitive-variables"
      }, useStyleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$6({
        name: "semantic-variables"
      }, useStyleOptions));
      BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$6({
        name: "global-variables"
      }, useStyleOptions));
      BaseStyle.loadStyle(_objectSpread$6({
        name: "global-style"
      }, useStyleOptions), style2);
      S$2.setLoadedStyleName("common");
    }
    if (!S$2.isStyleNameLoaded((_instance$$style5 = instance2.$style) === null || _instance$$style5 === void 0 ? void 0 : _instance$$style5.name) && (_instance$$style6 = instance2.$style) !== null && _instance$$style6 !== void 0 && _instance$$style6.name) {
      var _instance$$style7, _instance$$style7$get, _instance$$style8, _instance$$style9;
      var _ref6 = ((_instance$$style7 = instance2.$style) === null || _instance$$style7 === void 0 || (_instance$$style7$get = _instance$$style7.getDirectiveTheme) === null || _instance$$style7$get === void 0 ? void 0 : _instance$$style7$get.call(_instance$$style7)) || {}, css3 = _ref6.css, _style = _ref6.style;
      (_instance$$style8 = instance2.$style) === null || _instance$$style8 === void 0 || _instance$$style8.load(css3, _objectSpread$6({
        name: "".concat(instance2.$style.name, "-variables")
      }, useStyleOptions));
      (_instance$$style9 = instance2.$style) === null || _instance$$style9 === void 0 || _instance$$style9.loadStyle(_objectSpread$6({
        name: "".concat(instance2.$style.name, "-style")
      }, useStyleOptions), _style);
      S$2.setLoadedStyleName(instance2.$style.name);
    }
    if (!S$2.isStyleNameLoaded("layer-order")) {
      var _instance$$style0, _instance$$style0$get;
      var layerOrder = (_instance$$style0 = instance2.$style) === null || _instance$$style0 === void 0 || (_instance$$style0$get = _instance$$style0.getLayerOrderThemeCSS) === null || _instance$$style0$get === void 0 ? void 0 : _instance$$style0$get.call(_instance$$style0);
      BaseStyle.load(layerOrder, _objectSpread$6({
        name: "layer-order",
        first: true
      }, useStyleOptions));
      S$2.setLoadedStyleName("layer-order");
    }
  },
  _loadScopedThemeStyles: function _loadScopedThemeStyles() {
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    var preset = instance2.preset();
    if (preset && instance2.$attrSelector) {
      var _instance$$style1, _instance$$style1$get, _instance$$style10;
      var _ref7 = ((_instance$$style1 = instance2.$style) === null || _instance$$style1 === void 0 || (_instance$$style1$get = _instance$$style1.getPresetTheme) === null || _instance$$style1$get === void 0 ? void 0 : _instance$$style1$get.call(_instance$$style1, preset, "[".concat(instance2.$attrSelector, "]"))) || {}, css3 = _ref7.css;
      var scopedStyle = (_instance$$style10 = instance2.$style) === null || _instance$$style10 === void 0 ? void 0 : _instance$$style10.load(css3, _objectSpread$6({
        name: "".concat(instance2.$attrSelector, "-").concat(instance2.$style.name)
      }, useStyleOptions));
      instance2.scopedStyleEl = scopedStyle.el;
    }
  },
  _themeChangeListener: function _themeChangeListener() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Base.clearLoadedStyleNames();
    N$2.on("theme:change", callback);
  },
  _removeThemeListeners: function _removeThemeListeners() {
    var instance2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    N$2.off("theme:change", instance2.$loadStyles);
    instance2.$loadStyles = void 0;
  },
  _hook: function _hook(directiveName, hookName, el, binding, vnode, prevVnode) {
    var _binding$value, _config$pt;
    var name = "on".concat(ne$2(hookName));
    var config2 = BaseDirective._getConfig(binding, vnode);
    var instance2 = el === null || el === void 0 ? void 0 : el.$instance;
    var selfHook = BaseDirective._usePT(instance2, BaseDirective._getPT(binding === null || binding === void 0 || (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.pt, directiveName), BaseDirective._getOptionValue, "hooks.".concat(name));
    var defaultHook = BaseDirective._useDefaultPT(instance2, config2 === null || config2 === void 0 || (_config$pt = config2.pt) === null || _config$pt === void 0 || (_config$pt = _config$pt.directives) === null || _config$pt === void 0 ? void 0 : _config$pt[directiveName], BaseDirective._getOptionValue, "hooks.".concat(name));
    var options = {
      el,
      binding,
      vnode,
      prevVnode
    };
    selfHook === null || selfHook === void 0 || selfHook(instance2, options);
    defaultHook === null || defaultHook === void 0 || defaultHook(instance2, options);
  },
  /* eslint-disable-next-line no-unused-vars */
  _mergeProps: function _mergeProps() {
    var fn = arguments.length > 1 ? arguments[1] : void 0;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    return c$A(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
  },
  _extend: function _extend(name) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var handleHook = function handleHook2(hook, el, binding, vnode, prevVnode) {
      var _el$$pd, _el$$instance$hook, _el$$instance, _el$$pd2;
      el._$instances = el._$instances || {};
      var config2 = BaseDirective._getConfig(binding, vnode);
      var $prevInstance = el._$instances[name] || {};
      var $options = l$j($prevInstance) ? _objectSpread$6(_objectSpread$6({}, options), options === null || options === void 0 ? void 0 : options.methods) : {};
      el._$instances[name] = _objectSpread$6(_objectSpread$6({}, $prevInstance), {}, {
        /* new instance variables to pass in directive methods */
        $name: name,
        $host: el,
        $binding: binding,
        $modifiers: binding === null || binding === void 0 ? void 0 : binding.modifiers,
        $value: binding === null || binding === void 0 ? void 0 : binding.value,
        $el: $prevInstance["$el"] || el || void 0,
        $style: _objectSpread$6({
          classes: void 0,
          inlineStyles: void 0,
          load: function load2() {
          },
          loadCSS: function loadCSS2() {
          },
          loadStyle: function loadStyle2() {
          }
        }, options === null || options === void 0 ? void 0 : options.style),
        $primevueConfig: config2,
        $attrSelector: (_el$$pd = el.$pd) === null || _el$$pd === void 0 || (_el$$pd = _el$$pd[name]) === null || _el$$pd === void 0 ? void 0 : _el$$pd.attrSelector,
        /* computed instance variables */
        defaultPT: function defaultPT2() {
          return BaseDirective._getPT(config2 === null || config2 === void 0 ? void 0 : config2.pt, void 0, function(value) {
            var _value$directives;
            return value === null || value === void 0 || (_value$directives = value.directives) === null || _value$directives === void 0 ? void 0 : _value$directives[name];
          });
        },
        isUnstyled: function isUnstyled2() {
          var _el$_$instances$name, _el$_$instances$name2;
          return ((_el$_$instances$name = el._$instances[name]) === null || _el$_$instances$name === void 0 || (_el$_$instances$name = _el$_$instances$name.$binding) === null || _el$_$instances$name === void 0 || (_el$_$instances$name = _el$_$instances$name.value) === null || _el$_$instances$name === void 0 ? void 0 : _el$_$instances$name.unstyled) !== void 0 ? (_el$_$instances$name2 = el._$instances[name]) === null || _el$_$instances$name2 === void 0 || (_el$_$instances$name2 = _el$_$instances$name2.$binding) === null || _el$_$instances$name2 === void 0 || (_el$_$instances$name2 = _el$_$instances$name2.value) === null || _el$_$instances$name2 === void 0 ? void 0 : _el$_$instances$name2.unstyled : config2 === null || config2 === void 0 ? void 0 : config2.unstyled;
        },
        theme: function theme() {
          var _el$_$instances$name3;
          return (_el$_$instances$name3 = el._$instances[name]) === null || _el$_$instances$name3 === void 0 || (_el$_$instances$name3 = _el$_$instances$name3.$primevueConfig) === null || _el$_$instances$name3 === void 0 ? void 0 : _el$_$instances$name3.theme;
        },
        preset: function preset() {
          var _el$_$instances$name4;
          return (_el$_$instances$name4 = el._$instances[name]) === null || _el$_$instances$name4 === void 0 || (_el$_$instances$name4 = _el$_$instances$name4.$binding) === null || _el$_$instances$name4 === void 0 || (_el$_$instances$name4 = _el$_$instances$name4.value) === null || _el$_$instances$name4 === void 0 ? void 0 : _el$_$instances$name4.dt;
        },
        /* instance's methods */
        ptm: function ptm2() {
          var _el$_$instances$name5;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return BaseDirective._getPTValue(el._$instances[name], (_el$_$instances$name5 = el._$instances[name]) === null || _el$_$instances$name5 === void 0 || (_el$_$instances$name5 = _el$_$instances$name5.$binding) === null || _el$_$instances$name5 === void 0 || (_el$_$instances$name5 = _el$_$instances$name5.value) === null || _el$_$instances$name5 === void 0 ? void 0 : _el$_$instances$name5.pt, key, _objectSpread$6({}, params));
        },
        ptmo: function ptmo2() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return BaseDirective._getPTValue(el._$instances[name], obj, key, params, false);
        },
        cx: function cx2() {
          var _el$_$instances$name6, _el$_$instances$name7;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return !((_el$_$instances$name6 = el._$instances[name]) !== null && _el$_$instances$name6 !== void 0 && _el$_$instances$name6.isUnstyled()) ? BaseDirective._getOptionValue((_el$_$instances$name7 = el._$instances[name]) === null || _el$_$instances$name7 === void 0 || (_el$_$instances$name7 = _el$_$instances$name7.$style) === null || _el$_$instances$name7 === void 0 ? void 0 : _el$_$instances$name7.classes, key, _objectSpread$6({}, params)) : void 0;
        },
        sx: function sx2() {
          var _el$_$instances$name8;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return when ? BaseDirective._getOptionValue((_el$_$instances$name8 = el._$instances[name]) === null || _el$_$instances$name8 === void 0 || (_el$_$instances$name8 = _el$_$instances$name8.$style) === null || _el$_$instances$name8 === void 0 ? void 0 : _el$_$instances$name8.inlineStyles, key, _objectSpread$6({}, params)) : void 0;
        }
      }, $options);
      el.$instance = el._$instances[name];
      (_el$$instance$hook = (_el$$instance = el.$instance)[hook]) === null || _el$$instance$hook === void 0 || _el$$instance$hook.call(_el$$instance, el, binding, vnode, prevVnode);
      el["$".concat(name)] = el.$instance;
      BaseDirective._hook(name, hook, el, binding, vnode, prevVnode);
      el.$pd || (el.$pd = {});
      el.$pd[name] = _objectSpread$6(_objectSpread$6({}, (_el$$pd2 = el.$pd) === null || _el$$pd2 === void 0 ? void 0 : _el$$pd2[name]), {}, {
        name,
        instance: el._$instances[name]
      });
    };
    var handleWatchers = function handleWatchers2(el) {
      var _watchers$config2, _watchers$configRipp2, _instance$$primevueCo3;
      var instance2 = el._$instances[name];
      var watchers = instance2 === null || instance2 === void 0 ? void 0 : instance2.watch;
      var handleWatchConfig = function handleWatchConfig2(_ref8) {
        var _watchers$config;
        var newValue = _ref8.newValue, oldValue = _ref8.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$config = watchers["config"]) === null || _watchers$config === void 0 ? void 0 : _watchers$config.call(instance2, newValue, oldValue);
      };
      var handleWatchConfigRipple = function handleWatchConfigRipple2(_ref9) {
        var _watchers$configRipp;
        var newValue = _ref9.newValue, oldValue = _ref9.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$configRipp = watchers["config.ripple"]) === null || _watchers$configRipp === void 0 ? void 0 : _watchers$configRipp.call(instance2, newValue, oldValue);
      };
      instance2.$watchersCallback = {
        config: handleWatchConfig,
        "config.ripple": handleWatchConfigRipple
      };
      watchers === null || watchers === void 0 || (_watchers$config2 = watchers["config"]) === null || _watchers$config2 === void 0 || _watchers$config2.call(instance2, instance2 === null || instance2 === void 0 ? void 0 : instance2.$primevueConfig);
      PrimeVueService.on("config:change", handleWatchConfig);
      watchers === null || watchers === void 0 || (_watchers$configRipp2 = watchers["config.ripple"]) === null || _watchers$configRipp2 === void 0 || _watchers$configRipp2.call(instance2, instance2 === null || instance2 === void 0 || (_instance$$primevueCo3 = instance2.$primevueConfig) === null || _instance$$primevueCo3 === void 0 ? void 0 : _instance$$primevueCo3.ripple);
      PrimeVueService.on("config:ripple:change", handleWatchConfigRipple);
    };
    var stopWatchers2 = function stopWatchers3(el) {
      var watchers = el._$instances[name].$watchersCallback;
      if (watchers) {
        PrimeVueService.off("config:change", watchers.config);
        PrimeVueService.off("config:ripple:change", watchers["config.ripple"]);
        el._$instances[name].$watchersCallback = void 0;
      }
    };
    return {
      created: function created2(el, binding, vnode, prevVnode) {
        el.$pd || (el.$pd = {});
        el.$pd[name] = {
          name,
          attrSelector: s$c("pd")
        };
        handleHook("created", el, binding, vnode, prevVnode);
      },
      beforeMount: function beforeMount3(el, binding, vnode, prevVnode) {
        var _el$$pd$name;
        BaseDirective._loadStyles((_el$$pd$name = el.$pd[name]) === null || _el$$pd$name === void 0 ? void 0 : _el$$pd$name.instance, binding, vnode);
        handleHook("beforeMount", el, binding, vnode, prevVnode);
        handleWatchers(el);
      },
      mounted: function mounted7(el, binding, vnode, prevVnode) {
        var _el$$pd$name2;
        BaseDirective._loadStyles((_el$$pd$name2 = el.$pd[name]) === null || _el$$pd$name2 === void 0 ? void 0 : _el$$pd$name2.instance, binding, vnode);
        handleHook("mounted", el, binding, vnode, prevVnode);
      },
      beforeUpdate: function beforeUpdate2(el, binding, vnode, prevVnode) {
        handleHook("beforeUpdate", el, binding, vnode, prevVnode);
      },
      updated: function updated4(el, binding, vnode, prevVnode) {
        var _el$$pd$name3;
        BaseDirective._loadStyles((_el$$pd$name3 = el.$pd[name]) === null || _el$$pd$name3 === void 0 ? void 0 : _el$$pd$name3.instance, binding, vnode);
        handleHook("updated", el, binding, vnode, prevVnode);
      },
      beforeUnmount: function beforeUnmount5(el, binding, vnode, prevVnode) {
        var _el$$pd$name4;
        stopWatchers2(el);
        BaseDirective._removeThemeListeners((_el$$pd$name4 = el.$pd[name]) === null || _el$$pd$name4 === void 0 ? void 0 : _el$$pd$name4.instance);
        handleHook("beforeUnmount", el, binding, vnode, prevVnode);
      },
      unmounted: function unmounted5(el, binding, vnode, prevVnode) {
        var _el$$pd$name5;
        (_el$$pd$name5 = el.$pd[name]) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.instance) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.scopedStyleEl) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.value) === null || _el$$pd$name5 === void 0 || _el$$pd$name5.remove();
        handleHook("unmounted", el, binding, vnode, prevVnode);
      }
    };
  },
  extend: function extend2() {
    var _BaseDirective$_getMe = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe2 = _slicedToArray$3(_BaseDirective$_getMe, 2), name = _BaseDirective$_getMe2[0], options = _BaseDirective$_getMe2[1];
    return _objectSpread$6({
      extend: function extend4() {
        var _BaseDirective$_getMe3 = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe4 = _slicedToArray$3(_BaseDirective$_getMe3, 2), _name = _BaseDirective$_getMe4[0], _options = _BaseDirective$_getMe4[1];
        return BaseDirective.extend(_name, _objectSpread$6(_objectSpread$6(_objectSpread$6({}, options), options === null || options === void 0 ? void 0 : options.methods), _options));
      }
    }, BaseDirective._extend(name, options));
  }
};
var style$7 = "\n    .p-tooltip {\n        position: absolute;\n        display: none;\n        max-width: dt('tooltip.max.width');\n    }\n\n    .p-tooltip-right,\n    .p-tooltip-left {\n        padding: 0 dt('tooltip.gutter');\n    }\n\n    .p-tooltip-top,\n    .p-tooltip-bottom {\n        padding: dt('tooltip.gutter') 0;\n    }\n\n    .p-tooltip-text {\n        white-space: pre-line;\n        word-break: break-word;\n        background: dt('tooltip.background');\n        color: dt('tooltip.color');\n        padding: dt('tooltip.padding');\n        box-shadow: dt('tooltip.shadow');\n        border-radius: dt('tooltip.border.radius');\n    }\n\n    .p-tooltip-arrow {\n        position: absolute;\n        width: 0;\n        height: 0;\n        border-color: transparent;\n        border-style: solid;\n    }\n\n    .p-tooltip-right .p-tooltip-arrow {\n        margin-top: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter') 0;\n        border-right-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-left .p-tooltip-arrow {\n        margin-top: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') 0 dt('tooltip.gutter') dt('tooltip.gutter');\n        border-left-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-top .p-tooltip-arrow {\n        margin-left: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') dt('tooltip.gutter') 0 dt('tooltip.gutter');\n        border-top-color: dt('tooltip.background');\n        border-bottom-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-bottom .p-tooltip-arrow {\n        margin-left: calc(-1 * dt('tooltip.gutter'));\n        border-width: 0 dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter');\n        border-top-color: dt('tooltip.background');\n        border-bottom-color: dt('tooltip.background');\n    }\n";
var classes$7 = {
  root: "p-tooltip p-component",
  arrow: "p-tooltip-arrow",
  text: "p-tooltip-text"
};
var TooltipStyle = BaseStyle.extend({
  name: "tooltip-directive",
  style: style$7,
  classes: classes$7
});
var BaseTooltip = BaseDirective.extend({
  style: TooltipStyle
});
function _slicedToArray$2(r2, e2) {
  return _arrayWithHoles$2(r2) || _iterableToArrayLimit$2(r2, e2) || _unsupportedIterableToArray$d(r2, e2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$d(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$d(r2, a2) : void 0;
  }
}
function _arrayLikeToArray$d(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _iterableToArrayLimit$2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$2(r2) {
  if (Array.isArray(r2)) return r2;
}
function _defineProperty$d(e2, r2, t2) {
  return (r2 = _toPropertyKey$d(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$d(t2) {
  var i2 = _toPrimitive$d(t2, "string");
  return "symbol" == _typeof$d(i2) ? i2 : i2 + "";
}
function _toPrimitive$d(t2, r2) {
  if ("object" != _typeof$d(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$d(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$d(o2) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$d(o2);
}
var Tooltip = BaseTooltip.extend("tooltip", {
  beforeMount: function beforeMount(el, options) {
    var _options$instance$$pr;
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options);
    if (!options.value) return;
    else if (typeof options.value === "string") {
      target.$_ptooltipValue = options.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipFitContent = true;
      target.$_ptooltipIdAttr = s$c("pv_id") + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
    } else if (_typeof$d(options.value) === "object" && options.value) {
      if (l$j(options.value.value) || options.value.value.trim() === "") return;
      else {
        target.$_ptooltipValue = options.value.value;
        target.$_ptooltipDisabled = !!options.value.disabled === options.value.disabled ? options.value.disabled : false;
        target.$_ptooltipEscape = !!options.value.escape === options.value.escape ? options.value.escape : true;
        target.$_ptooltipClass = options.value["class"] || "";
        target.$_ptooltipFitContent = !!options.value.fitContent === options.value.fitContent ? options.value.fitContent : true;
        target.$_ptooltipIdAttr = options.value.id || s$c("pv_id") + "_tooltip";
        target.$_ptooltipShowDelay = options.value.showDelay || 0;
        target.$_ptooltipHideDelay = options.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options.value.autoHide === options.value.autoHide ? options.value.autoHide : true;
      }
    }
    target.$_ptooltipZIndex = (_options$instance$$pr = options.instance.$primevue) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.config) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.zIndex) === null || _options$instance$$pr === void 0 ? void 0 : _options$instance$$pr.tooltip;
    this.bindEvents(target, options);
    el.setAttribute("data-pd-tooltip", true);
  },
  updated: function updated(el, options) {
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options);
    this.unbindEvents(target);
    if (!options.value) {
      return;
    }
    if (typeof options.value === "string") {
      target.$_ptooltipValue = options.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipIdAttr = target.$_ptooltipIdAttr || s$c("pv_id") + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
      this.bindEvents(target, options);
    } else if (_typeof$d(options.value) === "object" && options.value) {
      if (l$j(options.value.value) || options.value.value.trim() === "") {
        this.unbindEvents(target, options);
        return;
      } else {
        target.$_ptooltipValue = options.value.value;
        target.$_ptooltipDisabled = !!options.value.disabled === options.value.disabled ? options.value.disabled : false;
        target.$_ptooltipEscape = !!options.value.escape === options.value.escape ? options.value.escape : true;
        target.$_ptooltipClass = options.value["class"] || "";
        target.$_ptooltipFitContent = !!options.value.fitContent === options.value.fitContent ? options.value.fitContent : true;
        target.$_ptooltipIdAttr = options.value.id || target.$_ptooltipIdAttr || s$c("pv_id") + "_tooltip";
        target.$_ptooltipShowDelay = options.value.showDelay || 0;
        target.$_ptooltipHideDelay = options.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options.value.autoHide === options.value.autoHide ? options.value.autoHide : true;
        this.bindEvents(target, options);
      }
    }
  },
  unmounted: function unmounted(el, options) {
    var target = this.getTarget(el);
    this.hide(el, 0);
    this.remove(target);
    this.unbindEvents(target, options);
    if (target.$_ptooltipScrollHandler) {
      target.$_ptooltipScrollHandler.destroy();
      target.$_ptooltipScrollHandler = null;
    }
  },
  timer: void 0,
  methods: {
    bindEvents: function bindEvents(el, options) {
      var _this = this;
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.$_ptooltipFocusEvent = function(event) {
          return _this.onFocus(event, options);
        };
        el.$_ptooltipBlurEvent = this.onBlur.bind(this);
        el.addEventListener("focus", el.$_ptooltipFocusEvent);
        el.addEventListener("blur", el.$_ptooltipBlurEvent);
      } else {
        el.$_ptooltipMouseEnterEvent = function(event) {
          return _this.onMouseEnter(event, options);
        };
        el.$_ptooltipMouseLeaveEvent = this.onMouseLeave.bind(this);
        el.$_ptooltipClickEvent = this.onClick.bind(this);
        el.addEventListener("mouseenter", el.$_ptooltipMouseEnterEvent);
        el.addEventListener("mouseleave", el.$_ptooltipMouseLeaveEvent);
        el.addEventListener("click", el.$_ptooltipClickEvent);
      }
      el.$_ptooltipKeydownEvent = this.onKeydown.bind(this);
      el.addEventListener("keydown", el.$_ptooltipKeydownEvent);
      el.$_pWindowResizeEvent = this.onWindowResize.bind(this, el);
    },
    unbindEvents: function unbindEvents(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.removeEventListener("focus", el.$_ptooltipFocusEvent);
        el.$_ptooltipFocusEvent = null;
        el.removeEventListener("blur", el.$_ptooltipBlurEvent);
        el.$_ptooltipBlurEvent = null;
      } else {
        el.removeEventListener("mouseenter", el.$_ptooltipMouseEnterEvent);
        el.$_ptooltipMouseEnterEvent = null;
        el.removeEventListener("mouseleave", el.$_ptooltipMouseLeaveEvent);
        el.$_ptooltipMouseLeaveEvent = null;
        el.removeEventListener("click", el.$_ptooltipClickEvent);
        el.$_ptooltipClickEvent = null;
      }
      el.removeEventListener("keydown", el.$_ptooltipKeydownEvent);
      window.removeEventListener("resize", el.$_pWindowResizeEvent);
      if (el.$_ptooltipId) {
        this.remove(el);
      }
    },
    bindScrollListener: function bindScrollListener(el) {
      var _this2 = this;
      if (!el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler = new ConnectedOverlayScrollHandler(el, function() {
          _this2.hide(el);
        });
      }
      el.$_ptooltipScrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener(el) {
      if (el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler.unbindScrollListener();
      }
    },
    onMouseEnter: function onMouseEnter(event, options) {
      var el = event.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options, showDelay);
    },
    onMouseLeave: function onMouseLeave(event) {
      var el = event.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      var autoHide = el.$_ptooltipAutoHide;
      if (!autoHide) {
        var valid = Q$3(event.target, "data-pc-name") === "tooltip" || Q$3(event.target, "data-pc-section") === "arrow" || Q$3(event.target, "data-pc-section") === "text" || Q$3(event.relatedTarget, "data-pc-name") === "tooltip" || Q$3(event.relatedTarget, "data-pc-section") === "arrow" || Q$3(event.relatedTarget, "data-pc-section") === "text";
        !valid && this.hide(el, hideDelay);
      } else {
        this.hide(el, hideDelay);
      }
    },
    onFocus: function onFocus(event, options) {
      var el = event.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options, showDelay);
    },
    onBlur: function onBlur(event) {
      var el = event.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    },
    onClick: function onClick(event) {
      var el = event.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    },
    onKeydown: function onKeydown(event) {
      var el = event.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      event.code === "Escape" && this.hide(event.currentTarget, hideDelay);
    },
    onWindowResize: function onWindowResize(el) {
      if (!Yt$2()) {
        this.hide(el);
      }
      window.removeEventListener("resize", el.$_pWindowResizeEvent);
    },
    tooltipActions: function tooltipActions(el, options) {
      if (el.$_ptooltipDisabled || !T$2(el) || !el.$_ptooltipPendingShow) {
        return;
      }
      el.$_ptooltipPendingShow = false;
      var tooltipElement = this.create(el, options);
      this.align(el);
      !this.isUnstyled() && ht$2(tooltipElement, 250);
      var $this = this;
      window.addEventListener("resize", el.$_pWindowResizeEvent);
      tooltipElement.addEventListener("mouseleave", function onTooltipLeave() {
        $this.hide(el);
        tooltipElement.removeEventListener("mouseleave", onTooltipLeave);
        el.removeEventListener("mouseenter", el.$_ptooltipMouseEnterEvent);
        setTimeout(function() {
          return el.addEventListener("mouseenter", el.$_ptooltipMouseEnterEvent);
        }, 50);
      });
      this.bindScrollListener(el);
      x$2.set("tooltip", tooltipElement, el.$_ptooltipZIndex);
    },
    show: function show(el, options, showDelay) {
      var _this3 = this;
      if (showDelay !== void 0) {
        this.timer = setTimeout(function() {
          return _this3.tooltipActions(el, options);
        }, showDelay);
        el.$_ptooltipPendingShow = true;
      } else {
        this.tooltipActions(el, options);
        el.$_ptooltipPendingShow = false;
      }
    },
    tooltipRemoval: function tooltipRemoval(el) {
      this.remove(el);
      this.unbindScrollListener(el);
      window.removeEventListener("resize", el.$_pWindowResizeEvent);
    },
    hide: function hide(el, hideDelay) {
      var _this4 = this;
      clearTimeout(this.timer);
      el.$_ptooltipPendingShow = false;
      if (hideDelay !== void 0) {
        setTimeout(function() {
          return _this4.tooltipRemoval(el);
        }, hideDelay);
      } else {
        this.tooltipRemoval(el);
      }
    },
    getTooltipElement: function getTooltipElement(el) {
      return document.getElementById(el.$_ptooltipId);
    },
    getArrowElement: function getArrowElement(el) {
      var tooltipElement = this.getTooltipElement(el);
      return z$2(tooltipElement, '[data-pc-section="arrow"]');
    },
    create: function create(el) {
      var modifiers = el.$_ptooltipModifiers;
      var tooltipArrow = U$2("div", {
        "class": !this.isUnstyled() && this.cx("arrow"),
        "p-bind": this.ptm("arrow", {
          context: modifiers
        })
      });
      var tooltipText = U$2("div", {
        "class": !this.isUnstyled() && this.cx("text"),
        "p-bind": this.ptm("text", {
          context: modifiers
        })
      });
      if (!el.$_ptooltipEscape) {
        tooltipText.innerHTML = el.$_ptooltipValue;
      } else {
        tooltipText.innerHTML = "";
        tooltipText.appendChild(document.createTextNode(el.$_ptooltipValue));
      }
      var container = U$2("div", _defineProperty$d(_defineProperty$d({
        id: el.$_ptooltipIdAttr,
        role: "tooltip",
        style: {
          display: "inline-block",
          width: el.$_ptooltipFitContent ? "fit-content" : void 0,
          pointerEvents: !this.isUnstyled() && el.$_ptooltipAutoHide && "none"
        },
        "class": [!this.isUnstyled() && this.cx("root"), el.$_ptooltipClass]
      }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
        context: modifiers
      })), tooltipArrow, tooltipText);
      document.body.appendChild(container);
      el.$_ptooltipId = container.id;
      this.$el = container;
      return container;
    },
    remove: function remove2(el) {
      if (el) {
        var tooltipElement = this.getTooltipElement(el);
        if (tooltipElement && tooltipElement.parentElement) {
          x$2.clear(tooltipElement);
          document.body.removeChild(tooltipElement);
        }
        el.$_ptooltipId = null;
      }
    },
    align: function align(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.top) {
        this.alignTop(el);
        if (this.isOutOfBounds(el)) {
          this.alignBottom(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
          }
        }
      } else if (modifiers.left) {
        this.alignLeft(el);
        if (this.isOutOfBounds(el)) {
          this.alignRight(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignLeft(el);
              }
            }
          }
        }
      } else if (modifiers.bottom) {
        this.alignBottom(el);
        if (this.isOutOfBounds(el)) {
          this.alignTop(el);
          if (this.isOutOfBounds(el)) {
            this.alignBottom(el);
          }
        }
      } else {
        this.alignRight(el);
        if (this.isOutOfBounds(el)) {
          this.alignLeft(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignRight(el);
              }
            }
          }
        }
      }
    },
    getHostOffset: function getHostOffset(el) {
      var offset = el.getBoundingClientRect();
      var targetLeft = offset.left + k$5();
      var targetTop = offset.top + $$3();
      return {
        left: targetLeft,
        top: targetTop
      };
    },
    alignRight: function alignRight(el) {
      this.preAlign(el, "right");
      var tooltipElement = this.getTooltipElement(el);
      var arrowElement = this.getArrowElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + v$5(el);
      var top = hostOffset.top + (C$4(el) - C$4(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
      arrowElement.style.top = "50%";
      arrowElement.style.right = null;
      arrowElement.style.bottom = null;
      arrowElement.style.left = "0";
    },
    alignLeft: function alignLeft(el) {
      this.preAlign(el, "left");
      var tooltipElement = this.getTooltipElement(el);
      var arrowElement = this.getArrowElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left - v$5(tooltipElement);
      var top = hostOffset.top + (C$4(el) - C$4(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
      arrowElement.style.top = "50%";
      arrowElement.style.right = "0";
      arrowElement.style.bottom = null;
      arrowElement.style.left = null;
    },
    alignTop: function alignTop(el) {
      this.preAlign(el, "top");
      var tooltipElement = this.getTooltipElement(el);
      var arrowElement = this.getArrowElement(el);
      var tooltipWidth = v$5(tooltipElement);
      var elementWidth = v$5(el);
      var _getViewport = h$7(), viewportWidth = _getViewport.width;
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (elementWidth - tooltipWidth) / 2;
      var top = hostOffset.top - C$4(tooltipElement);
      if (left < 0) {
        left = 0;
      } else if (left + tooltipWidth > viewportWidth) {
        left = Math.floor(hostOffset.left + elementWidth - tooltipWidth);
      }
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
      var elementRelativeCenter = hostOffset.left - this.getHostOffset(tooltipElement).left + elementWidth / 2;
      arrowElement.style.top = null;
      arrowElement.style.right = null;
      arrowElement.style.bottom = "0";
      arrowElement.style.left = elementRelativeCenter + "px";
    },
    alignBottom: function alignBottom(el) {
      this.preAlign(el, "bottom");
      var tooltipElement = this.getTooltipElement(el);
      var arrowElement = this.getArrowElement(el);
      var tooltipWidth = v$5(tooltipElement);
      var elementWidth = v$5(el);
      var _getViewport2 = h$7(), viewportWidth = _getViewport2.width;
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (elementWidth - tooltipWidth) / 2;
      var top = hostOffset.top + C$4(el);
      if (left < 0) {
        left = 0;
      } else if (left + tooltipWidth > viewportWidth) {
        left = Math.floor(hostOffset.left + elementWidth - tooltipWidth);
      }
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
      var elementRelativeCenter = hostOffset.left - this.getHostOffset(tooltipElement).left + elementWidth / 2;
      arrowElement.style.top = "0";
      arrowElement.style.right = null;
      arrowElement.style.bottom = null;
      arrowElement.style.left = elementRelativeCenter + "px";
    },
    preAlign: function preAlign(el, position) {
      var tooltipElement = this.getTooltipElement(el);
      tooltipElement.style.left = "-999px";
      tooltipElement.style.top = "-999px";
      P$2(tooltipElement, "p-tooltip-".concat(tooltipElement.$_ptooltipPosition));
      !this.isUnstyled() && W$2(tooltipElement, "p-tooltip-".concat(position));
      tooltipElement.$_ptooltipPosition = position;
      tooltipElement.setAttribute("data-p-position", position);
    },
    isOutOfBounds: function isOutOfBounds(el) {
      var tooltipElement = this.getTooltipElement(el);
      var offset = tooltipElement.getBoundingClientRect();
      var targetTop = offset.top;
      var targetLeft = offset.left;
      var width = v$5(tooltipElement);
      var height = C$4(tooltipElement);
      var viewport = h$7();
      return targetLeft + width > viewport.width || targetLeft < 0 || targetTop < 0 || targetTop + height > viewport.height;
    },
    getTarget: function getTarget(el) {
      var _findSingle;
      return R$2(el, "p-inputwrapper") ? (_findSingle = z$2(el, "input")) !== null && _findSingle !== void 0 ? _findSingle : el : el;
    },
    getModifiers: function getModifiers(options) {
      if (options.modifiers && Object.keys(options.modifiers).length) {
        return options.modifiers;
      }
      if (options.arg && _typeof$d(options.arg) === "object") {
        return Object.entries(options.arg).reduce(function(acc, _ref2) {
          var _ref22 = _slicedToArray$2(_ref2, 2), key = _ref22[0], val = _ref22[1];
          if (key === "event" || key === "position") acc[val] = true;
          return acc;
        }, {});
      }
      return {};
    }
  }
});
const isBrowser = typeof document !== "undefined";
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module" || obj.default && isRouteComponent(obj.default);
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop$3 = () => {
};
const isArray$1 = Array.isArray;
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key in defaults2) options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  return options;
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return text == null ? "" : encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  if (text == null) return null;
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery$1, location, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location.indexOf("#");
  let searchPos = location.indexOf("?");
  searchPos = hashPos >= 0 && searchPos > hashPos ? -1 : searchPos;
  if (searchPos >= 0) {
    path = location.slice(0, searchPos);
    searchString = location.slice(searchPos, hashPos > 0 ? hashPos : location.length);
    query = parseQuery$1(searchString.slice(1));
  }
  if (hashPos >= 0) {
    path = path || location.slice(0, hashPos);
    hash = location.slice(hashPos, location.length);
  }
  path = resolveRelativePath(path != null ? path : location, currentLocation);
  return {
    fullPath: path + searchString + hash,
    path,
    query,
    hash: decode(hash)
  };
}
function stringifyURL(stringifyQuery$1, location) {
  const query = location.query ? stringifyQuery$1(location.query) : "";
  return location.path + (query && "?") + query + (location.hash || "");
}
function isSameRouteLocation(stringifyQuery$1, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery$1(a2.query) === stringifyQuery$1(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length) return false;
  for (var key in a2) if (!isSameRouteLocationParamsValue(a2[key], b2[key])) return false;
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return isArray$1(a2) ? isEquivalentArray(a2, b2) : isArray$1(b2) ? isEquivalentArray(b2, a2) : a2?.valueOf() === b2?.valueOf();
}
function isEquivalentArray(a2, b2) {
  return isArray$1(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to2, from) {
  if (to2.startsWith("/")) return to2;
  if (!to2) return from;
  const fromSegments = from.split("/");
  const toSegments = to2.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") toSegments.push("");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".") continue;
    if (segment === "..") {
      if (position > 1) position--;
    } else break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
let NavigationType = /* @__PURE__ */ (function(NavigationType$1) {
  NavigationType$1["pop"] = "pop";
  NavigationType$1["push"] = "push";
  return NavigationType$1;
})({});
let NavigationDirection = /* @__PURE__ */ (function(NavigationDirection$1) {
  NavigationDirection$1["back"] = "back";
  NavigationDirection$1["forward"] = "forward";
  NavigationDirection$1["unknown"] = "";
  return NavigationDirection$1;
})({});
const START = "";
function normalizeBase(base) {
  if (!base) if (isBrowser) {
    const baseEl = document.querySelector("base");
    base = baseEl && baseEl.getAttribute("href") || "/";
    base = base.replace(/^\w+:\/\/[^\/]+/, "");
  } else base = "/";
  if (base[0] !== "/" && base[0] !== "#") base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
  return base.replace(BEFORE_HASH_RE, "#") + location;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else scrollToOptions = position;
  if ("scrollBehavior" in document.documentElement.style) window.scrollTo(scrollToOptions);
  else window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
}
function getScrollKey(path, delta) {
  return (history.state ? history.state.position - delta : -1) + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
let ErrorTypes = /* @__PURE__ */ (function(ErrorTypes$1) {
  ErrorTypes$1[ErrorTypes$1["MATCHER_NOT_FOUND"] = 1] = "MATCHER_NOT_FOUND";
  ErrorTypes$1[ErrorTypes$1["NAVIGATION_GUARD_REDIRECT"] = 2] = "NAVIGATION_GUARD_REDIRECT";
  ErrorTypes$1[ErrorTypes$1["NAVIGATION_ABORTED"] = 4] = "NAVIGATION_ABORTED";
  ErrorTypes$1[ErrorTypes$1["NAVIGATION_CANCELLED"] = 8] = "NAVIGATION_CANCELLED";
  ErrorTypes$1[ErrorTypes$1["NAVIGATION_DUPLICATED"] = 16] = "NAVIGATION_DUPLICATED";
  return ErrorTypes$1;
})({});
const NavigationFailureSymbol = /* @__PURE__ */ Symbol("");
({
  [ErrorTypes.MATCHER_NOT_FOUND]({ location, currentLocation }) {
    return `No match for
 ${JSON.stringify(location)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
  },
  [ErrorTypes.NAVIGATION_GUARD_REDIRECT]({ from, to: to2 }) {
    return `Redirected from "${from.fullPath}" to "${stringifyRoute(to2)}" via a navigation guard.`;
  },
  [ErrorTypes.NAVIGATION_ABORTED]({ from, to: to2 }) {
    return `Navigation aborted from "${from.fullPath}" to "${to2.fullPath}" via a navigation guard.`;
  },
  [ErrorTypes.NAVIGATION_CANCELLED]({ from, to: to2 }) {
    return `Navigation cancelled from "${from.fullPath}" to "${to2.fullPath}" with a new navigation.`;
  },
  [ErrorTypes.NAVIGATION_DUPLICATED]({ from, to: to2 }) {
    return `Avoided redundant navigation to current location: "${from.fullPath}".`;
  }
});
function createRouterError(type, params) {
  return assign(/* @__PURE__ */ new Error(), {
    type,
    [NavigationFailureSymbol]: true
  }, params);
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const propertiesToLog = [
  "params",
  "query",
  "hash"
];
function stringifyRoute(to2) {
  if (typeof to2 === "string") return to2;
  if (to2.path != null) return to2.path;
  const location = {};
  for (const key of propertiesToLog) if (key in to2) location[key] = to2[key];
  return JSON.stringify(location, null, 2);
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?") return query;
  const searchParams = (search[0] === "?" ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$1(currentValue)) currentValue = query[key] = [currentValue];
      currentValue.push(value);
    } else query[key] = value;
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) search += (search.length ? "&" : "") + key;
      continue;
    }
    (isArray$1(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)]).forEach((value$1) => {
      if (value$1 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value$1 != null) search += "=" + value$1;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) normalizedQuery[key] = isArray$1(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
  }
  return normalizedQuery;
}
const matchedRouteKey = /* @__PURE__ */ Symbol("");
const viewDepthKey = /* @__PURE__ */ Symbol("");
const routerKey = /* @__PURE__ */ Symbol("");
const routeLocationKey = /* @__PURE__ */ Symbol("");
const routerViewLocationKey = /* @__PURE__ */ Symbol("");
function useCallbacks() {
  let handlers = [];
  function add(handler4) {
    handlers.push(handler4);
    return () => {
      const i2 = handlers.indexOf(handler4);
      if (i2 > -1) handlers.splice(i2, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to2, from, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) reject(createRouterError(ErrorTypes.NAVIGATION_ABORTED, {
        from,
        to: to2
      }));
      else if (valid instanceof Error) reject(valid);
      else if (isRouteLocation(valid)) reject(createRouterError(ErrorTypes.NAVIGATION_GUARD_REDIRECT, {
        from: to2,
        to: valid
      }));
      else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") enterCallbackArray.push(valid);
        resolve2();
      }
    };
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to2, from, next));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3) guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to2, from, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name]) continue;
      if (isRouteComponent(rawComponent)) {
        const guard = (rawComponent.__vccOpts || rawComponent)[guardType];
        guard && guards.push(guardToPromiseFn(guard, to2, from, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved) throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.mods[name] = resolved;
          record.components[name] = resolvedComponent;
          const guard = (resolvedComponent.__vccOpts || resolvedComponent)[guardType];
          return guard && guardToPromiseFn(guard, to2, from, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
function extractChangingRecords(to2, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to2.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from.matched[i2];
    if (recordFrom) if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);
    else leavingRecords.push(recordFrom);
    const recordTo = to2.matched[i2];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) enteringRecords.push(recordTo);
    }
  }
  return [
    leavingRecords,
    updatingRecords,
    enteringRecords
  ];
}
function createMemoryHistory(base = "") {
  let listeners = [];
  let queue2 = [[START, {}]];
  let position = 0;
  base = normalizeBase(base);
  function setLocation(location$1, state = {}) {
    position++;
    if (position !== queue2.length) queue2.splice(position);
    queue2.push([location$1, state]);
  }
  function triggerListeners(to2, from, { direction, delta }) {
    const info = {
      direction,
      delta,
      type: NavigationType.pop
    };
    for (const callback of listeners) callback(to2, from, info);
  }
  const routerHistory = {
    location: START,
    state: {},
    base,
    createHref: createHref.bind(null, base),
    replace(to2, state) {
      queue2.splice(position--, 1);
      setLocation(to2, state);
    },
    push(to2, state) {
      setLocation(to2, state);
    },
    listen(callback) {
      listeners.push(callback);
      return () => {
        const index2 = listeners.indexOf(callback);
        if (index2 > -1) listeners.splice(index2, 1);
      };
    },
    destroy() {
      listeners = [];
      queue2 = [[START, {}]];
      position = 0;
    },
    go(delta, shouldTrigger = true) {
      const from = this.location;
      const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
      position = Math.max(0, Math.min(position + delta, queue2.length - 1));
      if (shouldTrigger) triggerListeners(this.location, from, {
        direction,
        delta
      });
    }
  };
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => queue2[position][0]
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => queue2[position][1]
  });
  return routerHistory;
}
let TokenType = /* @__PURE__ */ (function(TokenType$1) {
  TokenType$1[TokenType$1["Static"] = 0] = "Static";
  TokenType$1[TokenType$1["Param"] = 1] = "Param";
  TokenType$1[TokenType$1["Group"] = 2] = "Group";
  return TokenType$1;
})({});
var TokenizerState = /* @__PURE__ */ (function(TokenizerState$1) {
  TokenizerState$1[TokenizerState$1["Static"] = 0] = "Static";
  TokenizerState$1[TokenizerState$1["Param"] = 1] = "Param";
  TokenizerState$1[TokenizerState$1["ParamRegExp"] = 2] = "ParamRegExp";
  TokenizerState$1[TokenizerState$1["ParamRegExpEnd"] = 3] = "ParamRegExpEnd";
  TokenizerState$1[TokenizerState$1["EscapeNext"] = 4] = "EscapeNext";
  return TokenizerState$1;
})(TokenizerState || {});
const ROOT_TOKEN = {
  type: TokenType.Static,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path) return [[]];
  if (path === "/") return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) throw new Error(`Invalid path "${path}"`);
  function crash(message2) {
    throw new Error(`ERR (${state})/"${buffer}": ${message2}`);
  }
  let state = TokenizerState.Static;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment) tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer) return;
    if (state === TokenizerState.Static) segment.push({
      type: TokenType.Static,
      value: buffer
    });
    else if (state === TokenizerState.Param || state === TokenizerState.ParamRegExp || state === TokenizerState.ParamRegExpEnd) {
      if (segment.length > 1 && (char === "*" || char === "+")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: TokenType.Param,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else crash("Invalid state to consume buffer");
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state !== TokenizerState.ParamRegExp) {
      previousState = state;
      state = TokenizerState.EscapeNext;
      continue;
    }
    switch (state) {
      case TokenizerState.Static:
        if (char === "/") {
          if (buffer) consumeBuffer();
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = TokenizerState.Param;
        } else addCharToBuffer();
        break;
      case TokenizerState.EscapeNext:
        addCharToBuffer();
        state = previousState;
        break;
      case TokenizerState.Param:
        if (char === "(") state = TokenizerState.ParamRegExp;
        else if (VALID_PARAM_RE.test(char)) addCharToBuffer();
        else {
          consumeBuffer();
          state = TokenizerState.Static;
          if (char !== "*" && char !== "?" && char !== "+") i2--;
        }
        break;
      case TokenizerState.ParamRegExp:
        if (char === ")") if (customRe[customRe.length - 1] == "\\") customRe = customRe.slice(0, -1) + char;
        else state = TokenizerState.ParamRegExpEnd;
        else customRe += char;
        break;
      case TokenizerState.ParamRegExpEnd:
        consumeBuffer();
        state = TokenizerState.Static;
        if (char !== "*" && char !== "?" && char !== "+") i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === TokenizerState.ParamRegExp) crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
var PathScore = /* @__PURE__ */ (function(PathScore$1) {
  PathScore$1[PathScore$1["_multiplier"] = 10] = "_multiplier";
  PathScore$1[PathScore$1["Root"] = 90] = "Root";
  PathScore$1[PathScore$1["Segment"] = 40] = "Segment";
  PathScore$1[PathScore$1["SubSegment"] = 30] = "SubSegment";
  PathScore$1[PathScore$1["Static"] = 40] = "Static";
  PathScore$1[PathScore$1["Dynamic"] = 20] = "Dynamic";
  PathScore$1[PathScore$1["BonusCustomRegExp"] = 10] = "BonusCustomRegExp";
  PathScore$1[PathScore$1["BonusWildcard"] = -50] = "BonusWildcard";
  PathScore$1[PathScore$1["BonusRepeatable"] = -20] = "BonusRepeatable";
  PathScore$1[PathScore$1["BonusOptional"] = -8] = "BonusOptional";
  PathScore$1[PathScore$1["BonusStrict"] = 0.7000000000000001] = "BonusStrict";
  PathScore$1[PathScore$1["BonusCaseSensitive"] = 0.25] = "BonusCaseSensitive";
  return PathScore$1;
})(PathScore || {});
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [PathScore.Root];
    if (options.strict && !segment.length) pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = PathScore.Segment + (options.sensitive ? PathScore.BonusCaseSensitive : 0);
      if (token.type === TokenType.Static) {
        if (!tokenIndex) pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += PathScore.Static;
      } else if (token.type === TokenType.Param) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re$12 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re$12 !== BASE_PARAM_PATTERN) {
          subSegmentScore += PathScore.BonusCustomRegExp;
          try {
            `${re$12}`;
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re$12}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re$12})(?:/(?:${re$12}))*)` : `(${re$12})`;
        if (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional) subPattern += "?";
        pattern += subPattern;
        subSegmentScore += PathScore.Dynamic;
        if (optional) subSegmentScore += PathScore.BonusOptional;
        if (repeatable) subSegmentScore += PathScore.BonusRepeatable;
        if (re$12 === ".*") subSegmentScore += PathScore.BonusWildcard;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += PathScore.BonusStrict;
  }
  if (!options.strict) pattern += "/?";
  if (options.end) pattern += "$";
  else if (options.strict && !pattern.endsWith("/")) pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match2 = path.match(re2);
    const params = {};
    if (!match2) return null;
    for (let i2 = 1; i2 < match2.length; i2++) {
      const value = match2[i2] || "";
      const key = keys[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) if (token.type === TokenType.Static) path += token.value;
      else if (token.type === TokenType.Param) {
        const { value, repeatable, optional } = token;
        const param = value in params ? params[value] : "";
        if (isArray$1(param) && !repeatable) throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
        const text = isArray$1(param) ? param.join("/") : param;
        if (!text) if (optional) {
          if (segment.length < 2) if (path.endsWith("/")) path = path.slice(0, -1);
          else avoidDuplicatedSlash = true;
        } else throw new Error(`Missing required param "${value}"`);
        path += text;
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a2, b2) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b2.length) {
    const diff = b2[i2] - a2[i2];
    if (diff) return diff;
    i2++;
  }
  if (a2.length < b2.length) return a2.length === 1 && a2[0] === PathScore.Static + PathScore.Segment ? -1 : 1;
  else if (a2.length > b2.length) return b2.length === 1 && b2[0] === PathScore.Static + PathScore.Segment ? 1 : -1;
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp) return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore)) return 1;
    if (isLastScoreNegative(bScore)) return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const PATH_PARSER_OPTIONS_DEFAULTS = {
  strict: false,
  end: true,
  sensitive: false
};
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions(PATH_PARSER_OPTIONS_DEFAULTS, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [mainNormalizedRecord];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {
        components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
        path: alias,
        aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
      })));
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher)) {
          removeRoute(record.name);
        }
      }
      if (isMatchable(matcher)) insertMatcher(matcher);
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
      }
      originalRecord = originalRecord || matcher;
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$3;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    const index2 = findInsertionIndex(matcher, matchers);
    matchers.splice(index2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location$1, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location$1 && location$1.name) {
      matcher = matcherMap.get(location$1.name);
      if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, { location: location$1 });
      name = matcher.record.name;
      params = assign(pickParams(currentLocation.params, matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)), location$1.params && pickParams(location$1.params, matcher.keys.map((k2) => k2.name)));
      path = matcher.stringify(params);
    } else if (location$1.path != null) {
      path = location$1.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {
        location: location$1,
        currentLocation
      });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location$1.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  function clearRoutes() {
    matchers.length = 0;
    matcherMap.clear();
  }
  return {
    addRoute,
    resolve: resolve2,
    removeRoute,
    clearRoutes,
    getRoutes,
    getRecordMatcher
  };
}
function pickParams(params, keys) {
  const newParams = {};
  for (const key of keys) if (key in params) newParams[key] = params[key];
  return newParams;
}
function normalizeRouteRecord(record) {
  const normalized = {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: record.aliasOf,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
  Object.defineProperty(normalized, "mods", { value: {} });
  return normalized;
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) propsObject.default = props;
  else for (const name in record.components) propsObject[name] = typeof props === "object" ? props[name] : props;
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf) return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function findInsertionIndex(matcher, matchers) {
  let lower = 0;
  let upper = matchers.length;
  while (lower !== upper) {
    const mid = lower + upper >> 1;
    if (comparePathParserScore(matcher, matchers[mid]) < 0) upper = mid;
    else lower = mid + 1;
  }
  const insertionAncestor = getInsertionAncestor(matcher);
  if (insertionAncestor) {
    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
  }
  return upper;
}
function getInsertionAncestor(matcher) {
  let ancestor = matcher;
  while (ancestor = ancestor.parent) if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) return ancestor;
}
function isMatchable({ record }) {
  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => {
    const to2 = unref(props.to);
    return router2.resolve(to2);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length) return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1) return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      const p2 = router2[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop$3);
      if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) document.startViewTransition(() => p2);
      return p2;
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
function preferSingleVNode(vnodes) {
  return vnodes.length === 1 ? vnodes[0] : vnodes;
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink,
  setup(props, { slots }) {
    const link = /* @__PURE__ */ reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && preferSingleVNode(slots.default(link));
      return props.custom ? children : h$8("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey) return;
  if (e2.defaultPrevented) return;
  if (e2.button !== void 0 && e2.button !== 0) return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target)) return;
  }
  if (e2.preventDefault) e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) return false;
    } else if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value.valueOf() !== outerValue[i2].valueOf())) return false;
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs: attrs2, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) initialDepth++;
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = /* @__PURE__ */ ref();
    watch(() => [
      viewRef.value,
      matchedRouteRef.value,
      props.name
    ], ([instance2, to2, name], [oldInstance, from, oldName]) => {
      if (to2) {
        to2.instances[name] = instance2;
        if (from && from !== to2 && instance2 && instance2 === oldInstance) {
          if (!to2.leaveGuards.size) to2.leaveGuards = from.leaveGuards;
          if (!to2.updateGuards.size) to2.updateGuards = from.updateGuards;
        }
      }
      if (instance2 && to2 && (!from || !isSameRouteRecord(to2, from) || !oldInstance)) (to2.enterCallbacks[name] || []).forEach((callback) => callback(instance2));
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) return normalizeSlot(slots.default, {
        Component: ViewComponent,
        route
      });
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) matchedRoute.instances[currentName] = null;
      };
      const component = h$8(ViewComponent, assign({}, routeProps, attrs2, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, {
        Component: component,
        route
      }) || component;
    };
  }
});
function normalizeSlot(slot, data6) {
  if (!slot) return null;
  const slotContent = slot(data6);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = /* @__PURE__ */ shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) history.scrollRestoration = "manual";
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else record = parentOrRoute;
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) matcher.removeRoute(recordMatcher);
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute$1 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href$1 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute$1, {
        params: decodeParams(matchedRoute$1.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href$1
      });
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      matcherLocation = assign({}, rawLocation, { path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) if (targetParams[key] == null) delete targetParams[key];
      matcherLocation = assign({}, rawLocation, { params: encodeParams(targetParams) });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to2) {
    return typeof to2 === "string" ? parseURL(parseQuery$1, to2, currentRoute.value.path) : assign({}, to2);
  }
  function checkCanceledNavigation(to2, from) {
    if (pendingLocation !== to2) return createRouterError(ErrorTypes.NAVIGATION_CANCELLED, {
      from,
      to: to2
    });
  }
  function push(to2) {
    return pushWithRedirect(to2);
  }
  function replace3(to2) {
    return push(assign(locationAsObject(to2), { replace: true }));
  }
  function handleRedirectRecord(to2, from) {
    const lastMatched = to2.matched[to2.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to2, from) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to2.query,
        hash: to2.hash,
        params: newTargetLocation.path != null ? {} : to2.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to2, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to2);
    const from = currentRoute.value;
    const data6 = to2.state;
    const force = to2.force;
    const replace$1 = to2.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation, from);
    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
      state: typeof shouldRedirect === "object" ? assign({}, data6, shouldRedirect.state) : data6,
      force,
      replace: replace$1
    }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(ErrorTypes.NAVIGATION_DUPLICATED, {
        to: toLocation,
        from
      });
      handleScroll(from, from, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure$1) => {
      if (failure$1) {
        if (isNavigationFailure(failure$1, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {
          return pushWithRedirect(assign({ replace: replace$1 }, locationAsObject(failure$1.to), {
            state: typeof failure$1.to === "object" ? assign({}, data6, failure$1.to.state) : data6,
            force
          }), redirectedFrom || toLocation);
        }
      } else failure$1 = finalizeNavigation(toLocation, from, true, replace$1, data6);
      triggerAfterEach(toLocation, from, failure$1);
      return failure$1;
    });
  }
  function checkCanceledNavigationAndReject(to2, from) {
    const error = checkCanceledNavigation(to2, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  function navigate(to2, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from);
    for (const record of leavingRecords) record.leaveGuards.forEach((guard) => {
      guards.push(guardToPromiseFn(guard, to2, from));
    });
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) guards.push(guardToPromiseFn(guard, to2, from));
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from);
      for (const record of updatingRecords) record.updateGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to2, from));
      });
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) if (record.beforeEnter) if (isArray$1(record.beforeEnter)) for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to2, from));
      else guards.push(guardToPromiseFn(record.beforeEnter, to2, from));
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to2.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) guards.push(guardToPromiseFn(guard, to2, from));
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to2, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to2, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace$1, data6) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error) return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) if (replace$1 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({ scroll: isFirstNavigation && state && state.scroll }, data6));
    else routerHistory.push(toLocation.fullPath, data6);
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener) return;
    removeHistoryListener = routerHistory.listen((to2, _from, info) => {
      if (!router2.listening) return;
      const toLocation = resolve2(to2);
      const shouldRedirect = handleRedirectRecord(toLocation, router2.currentRoute.value);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, {
          replace: true,
          force: true
        }), toLocation).catch(noop$3);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(error, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED)) return error;
        if (isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {
          pushWithRedirect(assign(locationAsObject(error.to), { force: true }), toLocation).then((failure) => {
            if (isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED) && !info.delta && info.type === NavigationType.pop) routerHistory.go(-1, false);
          }).catch(noop$3);
          return Promise.reject();
        }
        if (info.delta) routerHistory.go(-info.delta, false);
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from, false);
        if (failure) {
          if (info.delta && !isNavigationFailure(failure, ErrorTypes.NAVIGATION_CANCELLED)) routerHistory.go(-info.delta, false);
          else if (info.type === NavigationType.pop && isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED)) routerHistory.go(-1, false);
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop$3);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to2, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) list.forEach((handler4) => handler4(error, to2, from));
    else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
    return new Promise((resolve$1, reject) => {
      readyHandlers.add([resolve$1, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve$1, reject]) => err ? reject(err) : resolve$1());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to2, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior) return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to2, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to2, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    clearRoutes: matcher.clearRoutes,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace: replace3,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app2) {
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router2;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) Object.defineProperty(reactiveRoute, key, {
        get: () => currentRoute.value[key],
        enumerable: true
      });
      app2.provide(routerKey, router2);
      app2.provide(routeLocationKey, /* @__PURE__ */ shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function useRouter() {
  return inject(routerKey);
}
const useChangelogStore = /* @__PURE__ */ defineStore(
  "changelog",
  () => {
    const currentVersion = /* @__PURE__ */ ref(0.16), lastLoadedVersion = /* @__PURE__ */ ref(0), log2 = /* @__PURE__ */ ref([
      {
        changes: ["Fixed Levels Progression Tab"],
        version: 0.11
      },
      {
        changes: ["Fixed Item Details Tab Only Going To Level 8"],
        version: 0.13
      },
      {
        changes: [
          "Start of some rewriting",
          "Item Details links to WaniKani pages",
          "Level up calculations using unlocked_on instead of started_on",
          "Accuracy details"
        ],
        version: 0.15
      },
      {
        changes: ["Joyo and JLPT Item Details pages"],
        version: 0.16
      }
    ]), showLog = /* @__PURE__ */ ref(false), showSince = /* @__PURE__ */ ref(0);
    const checkLog = () => {
      showLog.value = currentVersion.value > lastLoadedVersion.value && lastLoadedVersion.value > 0;
      showSince.value = lastLoadedVersion.value;
      lastLoadedVersion.value = currentVersion.value;
      const div = document.getElementById("statsChangelog");
      if (showLog.value && logSinceLast.value.length > 0) {
        if (div?.classList.contains("hidden")) {
          div?.classList.remove("hidden");
        }
      }
    };
    const logSinceLast = computed(
      () => log2.value.filter((i2) => i2.version > showSince.value)
    );
    return { checkLog, lastLoadedVersion, log: log2, logSinceLast, showLog };
  },
  {
    persist: {
      key: "WaniKaniStats",
      pick: ["lastLoadedVersion"]
    }
  }
);
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}
function isTypedArray$1(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
const regexpTag = "[object RegExp]";
const stringTag = "[object String]";
const numberTag = "[object Number]";
const booleanTag = "[object Boolean]";
const argumentsTag = "[object Arguments]";
const symbolTag = "[object Symbol]";
const dateTag = "[object Date]";
const mapTag = "[object Map]";
const setTag = "[object Set]";
const arrayTag = "[object Array]";
const arrayBufferTag = "[object ArrayBuffer]";
const objectTag = "[object Object]";
const dataViewTag = "[object DataView]";
const uint8ArrayTag = "[object Uint8Array]";
const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
const uint16ArrayTag = "[object Uint16Array]";
const uint32ArrayTag = "[object Uint32Array]";
const int8ArrayTag = "[object Int8Array]";
const int16ArrayTag = "[object Int16Array]";
const int32ArrayTag = "[object Int32Array]";
const float32ArrayTag = "[object Float32Array]";
const float64ArrayTag = "[object Float64Array]";
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack2);
  if (cloned !== void 0) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack2.has(valueToClone)) {
    return stack2.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result = new Array(valueToClone.length);
    stack2.set(valueToClone, result);
    for (let i2 = 0; i2 < valueToClone.length; i2++) {
      result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack2, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result.input = valueToClone.input;
    }
    return result;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result = new RegExp(valueToClone.source, valueToClone.flags);
    result.lastIndex = valueToClone.lastIndex;
    return result;
  }
  if (valueToClone instanceof Map) {
    const result = /* @__PURE__ */ new Map();
    stack2.set(valueToClone, result);
    for (const [key, value] of valueToClone) {
      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
    }
    return result;
  }
  if (valueToClone instanceof Set) {
    const result = /* @__PURE__ */ new Set();
    stack2.set(valueToClone, result);
    for (const value of valueToClone) {
      result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
    }
    return result;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray$1(valueToClone)) {
    const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack2.set(valueToClone, result);
    for (let i2 = 0; i2 < valueToClone.length; i2++) {
      result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack2, cloneValue);
    }
    return result;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
    const result = new Blob([valueToClone], { type: valueToClone.type });
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (valueToClone instanceof Error) {
    const result = new valueToClone.constructor();
    stack2.set(valueToClone, result);
    result.message = valueToClone.message;
    result.name = valueToClone.name;
    result.stack = valueToClone.stack;
    result.cause = valueToClone.cause;
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (valueToClone instanceof Boolean) {
    const result = new Boolean(valueToClone.valueOf());
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (valueToClone instanceof Number) {
    const result = new Number(valueToClone.valueOf());
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (valueToClone instanceof String) {
    const result = new String(valueToClone.valueOf());
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result = Object.create(Object.getPrototypeOf(valueToClone));
    stack2.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
    return result;
  }
  return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
  const keys = [...Object.keys(source), ...getSymbols(source)];
  for (let i2 = 0; i2 < keys.length; i2++) {
    const key = keys[i2];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
    }
  }
}
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}
function findKey$2(obj, predicate) {
  const keys = Object.keys(obj);
  return keys.find((key) => predicate(obj[key], key, obj));
}
const useIndexStore = /* @__PURE__ */ defineStore("index", () => {
  const dashboardLoaded = /* @__PURE__ */ ref(false), debug = false, kofiImage = "data:image/webp;base64,UklGRhwIAABXRUJQVlA4TBAIAAAvoEAgEIfCoJEkRX0CbvwrOkfM8GABIRtJ6gHcOJy/3Qu8oraNpMx3j/KnuVkAJRCE6P9ZLKA2bQPGKWtyBzB/DwoG/tOgDwUG1d4oPROCJ9AElAFPqOBDTYg+1IRIE1CBUIEmBEIFCnRO3AF3iwoVdi8z47NVqFChQgWoa9vmtI0YhVWxpGA1cHB6b3aK61owkbCRRUDA+R+OynzvNzPs/o3oPwRJksI2u1Cg48BKGcMBRx7g6GPgz6bj8cgbDgaDbrfbdvcpOGy5+2x3txwMhp43nkxnvmMd/cloOOi6LWERW+3uwJtMAyswPe62hMVsH41mhiWDlmgA3cE4MITguCWaw6OJif7eFw2j+9TXrPFUNJEDnZnRrp3/sozfFc2lO9YzZOykTc5oEB4LHuu63BRFnmXrdMtknwuJMjnkQ7pllmVFUZZVzc6MuAA/LayKfJ0mMo4sYbxI0iwvQ7zJgIUBUlauF5GtjJO8RLV0xnIdR5Yzfii0hmM6l0SNYLyqtYVjINccJqWeMKP6/DpqFpNaQ/AJi7eWUeO4DqkQ0OgTanHUQMqK+lASY6FEETWUf3kzhYvFBmoR6xEfb7HS0QukXG6ZHvAxw/iYHnK5o9QzAT6om+gSdXS0Ju/TrNiUdS1Msq7KTZE93v9hfCwhQlNoRl0+bmphG6tNCqqu1KIAK88ASR4KW1kXf7iNeVArNZ0rhd2sUiCUUNJWYUX1d2XOXnU6I0MgmeHpohaNYCnJzwOSIZwuQ9EQhqSwohtx0VTaH/ERISHHYF/1HrnaPtyWNingVQKqtlQiF83iI1FMPfbAZykahlCqO01IPLrgcyGaxlKd5OrKgerllkpYXY6aESmqPHWmKijtnMTiPrSK91eRtGqNPo6cEWjf5Qy8/Prrdr7l5a/3pyROvvzYe6W7i7OXOFZKu5jiEqw8UE4PG/UIg+Lk69VcyR/qzOnZ3VzFm0+nYKr+/VPCEqzsOj1QE9a4mZM8OznE572cOvMeqxExQhircK96HaeLjYELEGdzhDen+1/pxRzhr1MuogR/lCr4TxR44GqeXM7neDi9gd+Ji6jEJwllRRWWKqQQthH/60+2EQ4AOEkBjq5jAQIrxXkhfs9xXp5AgIf5CvxKUQsgA/B+zuHlnMMzLgr1O4HwtGC/cxvjSybW8NBX6MfZ3BwuIMB9WC+g1GBiKZByk0kzcGEU/57wxLbg2dws37KQwyobNlIKbwzjjIVSw/g70jNBfDGMXyTwBU0JLnnHLS34bhg3arA0cyVC3TbAT6sA2HmYkRSr3mbWbGyEGhI0XgIQ9xTObUWuxZJvOSqkSjvULvE1YQ0ztuxW4Ffacbpa8MEwLoQAdrbjZQlYqKCmh0JSeGF8/KW6UFFsKmiZia/He9jOkbRsBtO0iwBbp4HTxxBbZQPMn+tBQtj3yhIlCvVy1ybFawP7fimxq+ahiyWbjIDPWlDhhoG/BToH04+WP9dxhGp3iH3Tiphb7DFTfmnJS3xvfLzFBPwBFySe3ZnDKw3YxLjh4gbU4YcSmbBG+UIgYPoUyJo8rPZhS5lObm0tLyWwQldr76g8v6R2rexo5IzO8T1GUuC0H7VSYgHwtxHc8tLqL3KiK0PkKL0NjtKhsEP0GujpxQHXD9jBuqyBQ1Z8CiuFFaJvyEjBdS5SR/fAj1Lr5vhn7fgNHRQxIzEtTZFT6hBZRpm16G9PtsB36NFS4BSdbop/wvXbfAusuCCi66jYAg9xQgzPrkzHkuULw/HJasNncGgw/IE5Q40cDAiP7iGomAo0/NY58GosiTOyn4xwd6yYnCLMNXaJxpCVQ1pQKbKPwUzYKz/VH0Q6e2HuNmAEFXPi14Lzza0x231J17/fOQOxI3mUrn5k8PkFr43XmlaMjznqRtWCvMyVW3+SfDSh9ftQjb/kRunOMK98FTLq3VlCVOuOtzSTOjwJOqj39hPGxod24cW+WadFG1XD/d894vejPurmCiGptjQFpQzX8insssN3Kfp+R7epLy2h3IHZxH4MYyphC3+yBw3YYVMiubHDo6dUphI+X1/s1/qOSmF3tALSYCKAp8GV0MHnrz++e65710xSEi9wNFB5/Sel+qg1lHDa1nZbbipsd73L8JR/xUuD++zaEmwiOB04SuhTDmP7RLXE9wRmOu/wtWB7O67tcKmDJ6+Oo5Mebo5J8yFcEPEvVW4oqSIq2BWl0FXONPZERgabYlwTqWa21Ta3PaGWnJNzT/89ZsZudRTnWsG7srOmbvtoZ5+1tF9pE2I3suDtzrGJy9YtSofSKizwbY9kjdTRXYW5AbYodbeZRLzo+o4RHlGGGc2k0KmxYu+aTUzdqHe5IZJrPR8X5onGXT0DDQIBaHpdhswulSdxxI9txxxHgHUGFj3kZRVC94vXDzFj15FSMsg+HrBvY5EoKGXE4irErsKZ0mlT53fGLm8y55ep6f8p4pJ3iSy5jUnODHYFURgX7rYdydZtCDYJl5UAooVB1EtzuVIIoNTOIMqlJbnWxLGFQRcZ+FMDOWzX0SJ60MxZcNQ13fRs+45VHLXAe6D30FiCbnkDGNr3T5Zc/Ebt4zLGdf+k+YG/FacNS7WQ+b4ssixVMcuKTcWyXo4CZ0cbhbbQnTjWcmxHpuUdSC0VDq35L0VWZ/qmc1OnAfRHrsF2fKcpnPSMoDMKnCbRH3d0S7b6zWMw6f+jq0f1x4f1G1nk9XiqT3rDse/8B3A2HXvDfkfJXr/vjSezwPn/pQM=", loadingCount = /* @__PURE__ */ ref(0), scriptName = "WaniKani Stats", stages = /* @__PURE__ */ ref({
    apprentice: [1, 2, 3, 4],
    burned: [9],
    enlightened: [8],
    guru: [5, 6],
    initiate: [0],
    locked: [-1],
    master: [7]
  }), types = /* @__PURE__ */ ref({
    kana_vocabulary: "Kana Vocab",
    kanji: "Kanji",
    radical: "Radicals",
    vocabulary: "Vocabulary"
  }), visible = /* @__PURE__ */ ref(false);
  const loading = computed(() => loadingCount.value > 0), stageNumberToName = (stage) => {
    return findKey$2(stages.value, (s2) => s2.includes(stage));
  };
  return {
    dashboardLoaded,
    debug,
    kofiImage,
    loading,
    scriptName,
    stageNumberToName,
    stages,
    types,
    visible
  };
});
var faXmark = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
};
var faTriangleExclamation = {
  prefix: "fas",
  iconName: "triangle-exclamation",
  icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 0c14.7 0 28.2 8.1 35.2 21l216 400c6.7 12.4 6.4 27.4-.8 39.5S486.1 480 472 480L40 480c-14.1 0-27.2-7.4-34.4-19.5s-7.5-27.1-.8-39.5l216-400c7-12.9 20.5-21 35.2-21zm0 352a32 32 0 1 0 0 64 32 32 0 1 0 0-64zm0-192c-18.2 0-32.7 15.5-31.4 33.7l7.4 104c.9 12.5 11.4 22.3 23.9 22.3 12.6 0 23-9.7 23.9-22.3l7.4-104c1.3-18.2-13.1-33.7-31.4-33.7z"]
};
function _arrayLikeToArray$c(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithHoles$1(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles$b(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$c(r2);
}
function _classCallCheck(a2, n2) {
  if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey$c(o2.key), o2);
  }
}
function _createClass(e2, r2, t2) {
  return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _createForOfIteratorHelper(r2, e2) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray$c(r2)) || e2) {
      t2 && (r2 = t2);
      var n2 = 0, F2 = function() {
      };
      return {
        s: F2,
        n: function() {
          return n2 >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n2++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, u2 = false;
  return {
    s: function() {
      t2 = t2.call(r2);
    },
    n: function() {
      var r3 = t2.next();
      return a2 = r3.done, r3;
    },
    e: function(r3) {
      u2 = true, o2 = r3;
    },
    f: function() {
      try {
        a2 || null == t2.return || t2.return();
      } finally {
        if (u2) throw o2;
      }
    }
  };
}
function _defineProperty$c(e2, r2, t2) {
  return (r2 = _toPropertyKey$c(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _iterableToArray$c(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit$1(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys$7(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$7(Object(t2), true).forEach(function(r3) {
      _defineProperty$c(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$7(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _slicedToArray$1(r2, e2) {
  return _arrayWithHoles$1(r2) || _iterableToArrayLimit$1(r2, e2) || _unsupportedIterableToArray$c(r2, e2) || _nonIterableRest$1();
}
function _toConsumableArray$b(r2) {
  return _arrayWithoutHoles$b(r2) || _iterableToArray$c(r2) || _unsupportedIterableToArray$c(r2) || _nonIterableSpread$b();
}
function _toPrimitive$c(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey$c(t2) {
  var i2 = _toPrimitive$c(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof$c(o2) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$c(o2);
}
function _unsupportedIterableToArray$c(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$c(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$c(r2, a2) : void 0;
  }
}
var noop$1 = function noop2() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop$1,
  measure: noop$1
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e2) {
}
var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var _dt;
var E$1 = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, _$1 = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i;
var q$1 = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  },
  utility: {
    "fa-semibold": "semibold",
    fausb: "semibold"
  },
  "utility-duo": {
    "fa-semibold": "semibold",
    faudsb: "semibold"
  },
  "utility-fill": {
    "fa-semibold": "semibold",
    faufsb: "semibold"
  }
}, H$1 = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, Q$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"];
var i$1 = "classic", t$1 = "duotone", d$1 = "sharp", l$1 = "sharp-duotone", f$1 = "chisel", n$1 = "etch", h$1 = "jelly", o$1 = "jelly-duo", u$1 = "jelly-fill", g$1 = "notdog", s$1 = "notdog-duo", y$1 = "slab", m$2 = "slab-press", e$1 = "thumbprint", p$1 = "utility", a$1 = "utility-duo", w$1 = "utility-fill", x$1 = "whiteboard", b$1 = "Classic", c$1 = "Duotone", I$1 = "Sharp", F$1 = "Sharp Duotone", v$1 = "Chisel", S$1 = "Etch", A$2 = "Jelly", P$1 = "Jelly Duo", j$1 = "Jelly Fill", B$1 = "Notdog", N$1 = "Notdog Duo", k$1 = "Slab", D$1 = "Slab Press", T$1 = "Thumbprint", C$1 = "Utility", W$1 = "Utility Duo", K$1 = "Utility Fill", R$1 = "Whiteboard", rt$1 = [i$1, t$1, d$1, l$1, f$1, n$1, h$1, o$1, u$1, g$1, s$1, y$1, m$2, e$1, p$1, a$1, w$1, x$1];
_dt = {}, _defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_dt, i$1, b$1), t$1, c$1), d$1, I$1), l$1, F$1), f$1, v$1), n$1, S$1), h$1, A$2), o$1, P$1), u$1, j$1), g$1, B$1), _defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_dt, s$1, N$1), y$1, k$1), m$2, D$1), e$1, T$1), p$1, C$1), a$1, W$1), w$1, K$1), x$1, R$1);
var gt$1 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  },
  utility: {
    600: "fausb"
  },
  "utility-duo": {
    600: "faudsb"
  },
  "utility-fill": {
    600: "faufsb"
  }
};
var Ct$1 = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  },
  "Font Awesome 7 Utility": {
    600: "fausb",
    normal: "fausb"
  },
  "Font Awesome 7 Utility Duo": {
    600: "faudsb",
    normal: "faudsb"
  },
  "Font Awesome 7 Utility Fill": {
    600: "faufsb",
    normal: "faufsb"
  }
};
var Ut$1 = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["utility", {
  defaultShortPrefixId: "fausb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-duo", {
  defaultShortPrefixId: "faudsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-fill", {
  defaultShortPrefixId: "faufsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), _t$1 = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  utility: {
    semibold: "fausb"
  },
  "utility-duo": {
    semibold: "faudsb"
  },
  "utility-fill": {
    semibold: "faufsb"
  },
  whiteboard: {
    semibold: "fawsb"
  }
};
var Yt$1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], qt$1 = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, Ht$1 = ["kit"];
var L$1 = "kit", r$1 = "kit-duotone", U$1 = "Kit", J$2 = "Kit Duotone";
_defineProperty$c(_defineProperty$c({}, L$1, U$1), r$1, J$2);
var ol = {
  kit: {
    "fa-kit": "fak"
  }
};
var dl = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, fl = {
  kit: {
    fak: "fa-kit"
  }
};
var ul = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
var _ml;
var l$1$1 = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, f$1$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"];
var n$1$1 = "classic", o$1$1 = "duotone", u$1$1 = "sharp", s$1$1 = "sharp-duotone", h$1$1 = "chisel", g$1$1 = "etch", y$1$1 = "jelly", e$1$1 = "jelly-duo", m$1$1 = "jelly-fill", p$1$1 = "notdog", a$1$1 = "notdog-duo", w$1$1 = "slab", b$1$1 = "slab-press", r$1$1 = "thumbprint", c$1$1 = "utility", i$1$1 = "utility-duo", x$1$1 = "utility-fill", I$1$1 = "whiteboard", F$1$1 = "Classic", v$1$1 = "Duotone", S$1$1 = "Sharp", A$1$1 = "Sharp Duotone", P$1$1 = "Chisel", j$1$1 = "Etch", B$1$1 = "Jelly", N$1$1 = "Jelly Duo", k$1$1 = "Jelly Fill", D$1$1 = "Notdog", C$1$1 = "Notdog Duo", T$1$1 = "Slab", L$1$1 = "Slab Press", W$1$1 = "Thumbprint", R$1$1 = "Utility", K$1$1 = "Utility Duo", U$1$1 = "Utility Fill", J$1$1 = "Whiteboard";
_ml = {}, _defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_ml, n$1$1, F$1$1), o$1$1, v$1$1), u$1$1, S$1$1), s$1$1, A$1$1), h$1$1, P$1$1), g$1$1, j$1$1), y$1$1, B$1$1), e$1$1, N$1$1), m$1$1, k$1$1), p$1$1, D$1$1), _defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_ml, a$1$1, C$1$1), w$1$1, T$1$1), b$1$1, L$1$1), r$1$1, W$1$1), c$1$1, R$1$1), i$1$1, K$1$1), x$1$1, U$1$1), I$1$1, J$1$1);
var E$1$1 = "kit", d$1$1 = "kit-duotone", _$1$1 = "Kit", M$1 = "Kit Duotone";
_defineProperty$c(_defineProperty$c({}, E$1$1, _$1$1), d$1$1, M$1);
var $t$1 = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  },
  utility: {
    "fa-semibold": "fausb"
  },
  "utility-duo": {
    "fa-semibold": "faudsb"
  },
  "utility-fill": {
    "fa-semibold": "faufsb"
  }
}, z$1 = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"],
  utility: ["fausb"],
  "utility-duo": ["faudsb"],
  "utility-fill": ["faufsb"]
}, Ht$1$1 = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  },
  utility: {
    fausb: "fa-semibold"
  },
  "utility-duo": {
    faudsb: "fa-semibold"
  },
  "utility-fill": {
    faufsb: "fa-semibold"
  }
}, Y$1 = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], Zt$1 = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(f$1$1, Y$1), G$1 = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], O$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], V$1 = O$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), $$1 = ["aw", "fw", "pull-left", "pull-right"], to = [].concat(_toConsumableArray$b(Object.keys(z$1)), G$1, $$1, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", l$1$1.GROUP, l$1$1.SWAP_OPACITY, l$1$1.PRIMARY, l$1$1.SECONDARY]).concat(O$1.map(function(t2) {
  return "".concat(t2, "x");
})).concat(V$1.map(function(t2) {
  return "w-".concat(t2);
}));
var ro = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PSEUDO_ELEMENTS = ["::before", "::after", ":before", ":after"];
var PRODUCTION$1 = (function() {
  try {
    return true;
  } catch (e$$1) {
    return false;
  }
})();
function familyProxy(obj) {
  return new Proxy(obj, {
    get: function get22(target, prop) {
      return prop in target ? target[prop] : target[i$1];
    }
  });
}
var _PREFIX_TO_STYLE = _objectSpread2$1({}, q$1);
_PREFIX_TO_STYLE[i$1] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  "fa-duotone": "duotone"
}), q$1[i$1]), qt$1["kit"]), qt$1["kit-duotone"]);
var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
var _STYLE_TO_PREFIX = _objectSpread2$1({}, _t$1);
_STYLE_TO_PREFIX[i$1] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  duotone: "fad"
}), _STYLE_TO_PREFIX[i$1]), ul["kit"]), ul["kit-duotone"]);
var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
var _PREFIX_TO_LONG_STYLE = _objectSpread2$1({}, Ht$1$1);
_PREFIX_TO_LONG_STYLE[i$1] = _objectSpread2$1(_objectSpread2$1({}, _PREFIX_TO_LONG_STYLE[i$1]), fl["kit"]);
var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
var _LONG_STYLE_TO_PREFIX = _objectSpread2$1({}, $t$1);
_LONG_STYLE_TO_PREFIX[i$1] = _objectSpread2$1(_objectSpread2$1({}, _LONG_STYLE_TO_PREFIX[i$1]), ol["kit"]);
familyProxy(_LONG_STYLE_TO_PREFIX);
var ICON_SELECTION_SYNTAX_PATTERN = E$1;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = _$1;
var _FONT_WEIGHT_TO_PREFIX = _objectSpread2$1({}, gt$1);
familyProxy(_FONT_WEIGHT_TO_PREFIX);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = H$1;
var RESERVED_CLASSES = [].concat(_toConsumableArray$b(Ht$1), _toConsumableArray$b(to));
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  var attrs2 = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs2.forEach(function(_ref2) {
    var _ref22 = _slicedToArray$1(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  styleDefault: "solid",
  familyDefault: i$1,
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  searchPseudoElements: false,
  searchPseudoElementsWarnings: true,
  searchPseudoElementsFullScan: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
var _config = _objectSpread2$1(_objectSpread2$1({}, _default), initial);
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = {};
Object.keys(_default).forEach(function(key) {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function set22(val) {
      _config[key] = val;
      _onChangeCb.forEach(function(cb) {
        return cb(config);
      });
    },
    get: function get22() {
      return _config[key];
    }
  });
});
Object.defineProperty(config, "familyPrefix", {
  enumerable: true,
  set: function set2(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach(function(cb) {
      return cb(config);
    });
  },
  get: function get2() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return function() {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d$2 = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css22) {
  if (!css22 || !IS_DOM) {
    return;
  }
  var style2 = DOCUMENT.createElement("style");
  style2.setAttribute("type", "text/css");
  style2.innerHTML = css22;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i2 = headChildren.length - 1; i2 > -1; i2--) {
    var child = headChildren[i2];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style2, beforeChild);
  return css22;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size = 12;
  var id = "";
  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray$1(obj) {
  var array = [];
  for (var i2 = (obj || []).length >>> 0; i2--; ) {
    array[i2] = obj[i2];
  }
  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray$1(node.classList);
  } else {
    return (node.getAttribute("class") || "").split(" ").filter(function(i2) {
      return i2;
    });
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref2) {
  var transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height;
  var val = "";
  if (IS_IE) {
    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
  } else {
    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
  }
  val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}
var baseStyles = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
function css$1() {
  var dcp = DEFAULT_CSS_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.cssPrefix;
  var rc = config.replacementClass;
  var s2 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s2;
}
var _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css$1());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout: function mixout() {
    return {
      dom: {
        css: css$1,
        insertCss: ensureCss
      }
    };
  },
  hooks: function hooks() {
    return {
      beforeDOMElementCreation: function beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg: function beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w$2 = WINDOW || {};
if (!w$2[NAMESPACE_IDENTIFIER]) w$2[NAMESPACE_IDENTIFIER] = {};
if (!w$2[NAMESPACE_IDENTIFIER].styles) w$2[NAMESPACE_IDENTIFIER].styles = {};
if (!w$2[NAMESPACE_IDENTIFIER].hooks) w$2[NAMESPACE_IDENTIFIER].hooks = {};
if (!w$2[NAMESPACE_IDENTIFIER].shims) w$2[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w$2[NAMESPACE_IDENTIFIER];
var functions = [];
var _listener = function listener() {
  DOCUMENT.removeEventListener("DOMContentLoaded", _listener);
  loaded = 1;
  functions.map(function(fn) {
    return fn();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", _listener);
}
function domready(fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length = keys.length, iterator2 = fn, i2, key, result;
  if (initialValue === void 0) {
    i2 = 1;
    result = subject[keys[0]];
  } else {
    i2 = 0;
    result = initialValue;
  }
  for (; i2 < length; i2++) {
    key = keys[i2];
    result = iterator2(result, subject[key], key, subject);
  }
  return result;
};
function toHex(unicode) {
  if (_toConsumableArray$b(unicode).length !== 1) return null;
  return unicode.codePointAt(0).toString(16);
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce(function(acc, iconName) {
    var icon32 = icons[iconName];
    var expanded = !!icon32.icon;
    if (expanded) {
      acc[icon32.iconName] = icon32.icon;
    } else {
      acc[iconName] = icon32;
    }
    return acc;
  }, {});
}
function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2$1(_objectSpread2$1({}, namespace.styles[prefix] || {}), normalized);
  }
  if (prefix === "fas") {
    defineIcons("fa", icons);
  }
}
var styles = namespace.styles, shims = namespace.shims;
var FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
var PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce(function(acc, familyId) {
  acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
  return acc;
}, {});
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  var parts = cls.split("-");
  var prefix = parts[0];
  var iconName = parts.slice(1).join("-");
  if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = function build2() {
  var lookup = function lookup2(reducer) {
    return reduce(styles, function(o$$1, style2, prefix) {
      o$$1[prefix] = reduce(style2, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup(function(acc, icon32, iconName) {
    if (icon32[3]) {
      acc[icon32[3]] = iconName;
    }
    if (icon32[2]) {
      var aliases = icon32[2].filter(function(a$$1) {
        return typeof a$$1 === "number";
      });
      aliases.forEach(function(alias) {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup(function(acc, icon32, iconName) {
    acc[iconName] = iconName;
    if (icon32[2]) {
      var aliases = icon32[2].filter(function(a$$1) {
        return typeof a$$1 === "string";
      });
      aliases.forEach(function(alias) {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup(function(acc, icon32, iconName) {
    var aliases = icon32[2];
    acc[iconName] = iconName;
    aliases.forEach(function(alias) {
      acc[alias] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles || config.autoFetchSvg;
  var shimLookups = reduce(shims, function(acc, shim) {
    var maybeNameMaybeUnicode = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];
    if (prefix === "far" && !hasRegular) {
      prefix = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange(function(c$$1) {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  var oldUnicode = _byOldUnicode[unicode];
  var newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = function emptyCanonicalIcon2() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getFamilyId(values) {
  var family = i$1;
  var famProps = FAMILY_NAMES.reduce(function(acc, familyId) {
    acc[familyId] = "".concat(config.cssPrefix, "-").concat(familyId);
    return acc;
  }, {});
  rt$1.forEach(function(familyId) {
    if (values.includes(famProps[familyId]) || values.some(function(v$$1) {
      return PREFIXES_FOR_FAMILY[familyId].includes(v$$1);
    })) {
      family = familyId;
    }
  });
  return family;
}
function getCanonicalPrefix(styleOrPrefix) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$family = params.family, family = _params$family === void 0 ? i$1 : _params$family;
  var style2 = PREFIX_TO_STYLE[family][styleOrPrefix];
  if (family === t$1 && !styleOrPrefix) {
    return "fad";
  }
  var prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style2];
  var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  var result = prefix || defined || null;
  return result;
}
function moveNonFaClassesToRest(classNames) {
  var rest = [];
  var iconName = null;
  classNames.forEach(function(cls) {
    var result = getIconName(config.cssPrefix, cls);
    if (result) {
      iconName = result;
    } else if (cls) {
      rest.push(cls);
    }
  });
  return {
    iconName,
    rest
  };
}
function sortedUniqueValues(arr) {
  return arr.sort().filter(function(value, index2, arr2) {
    return arr2.indexOf(value) === index2;
  });
}
var _faCombinedClasses = Zt$1.concat(Yt$1);
function getCanonicalIcon(values) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$skipLookups = params.skipLookups, skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
  var givenPrefix = null;
  var faStyleOrFamilyClasses = sortedUniqueValues(values.filter(function(cls) {
    return _faCombinedClasses.includes(cls);
  }));
  var nonStyleOrFamilyClasses = sortedUniqueValues(values.filter(function(cls) {
    return !_faCombinedClasses.includes(cls);
  }));
  var faStyles = faStyleOrFamilyClasses.filter(function(cls) {
    givenPrefix = cls;
    return !Q$1.includes(cls);
  });
  var _faStyles = _slicedToArray$1(faStyles, 1), _faStyles$ = _faStyles[0], styleFromValues = _faStyles$ === void 0 ? null : _faStyles$;
  var family = getFamilyId(faStyleOrFamilyClasses);
  var canonical = _objectSpread2$1(_objectSpread2$1({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
    prefix: getCanonicalPrefix(styleFromValues, {
      family
    })
  });
  return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, canonical), getDefaultCanonicalPrefix({
    values,
    family,
    styles,
    config,
    canonical,
    givenPrefix
  })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
}
function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
  var prefix = canonical.prefix, iconName = canonical.iconName;
  if (skipLookups || !prefix || !iconName) {
    return {
      prefix,
      iconName
    };
  }
  var shim = givenPrefix === "fa" ? byOldName(iconName) : {};
  var aliasIconName = byAlias(prefix, iconName);
  iconName = shim.iconName || aliasIconName || iconName;
  prefix = shim.prefix || prefix;
  if (prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
    prefix = "fas";
  }
  return {
    prefix,
    iconName
  };
}
var newCanonicalFamilies = rt$1.filter(function(familyId) {
  return familyId !== i$1 || familyId !== t$1;
});
var newCanonicalStyles = Object.keys(Ht$1$1).filter(function(key) {
  return key !== i$1;
}).map(function(key) {
  return Object.keys(Ht$1$1[key]);
}).flat();
function getDefaultCanonicalPrefix(prefixOptions) {
  var values = prefixOptions.values, family = prefixOptions.family, canonical = prefixOptions.canonical, _prefixOptions$givenP = prefixOptions.givenPrefix, givenPrefix = _prefixOptions$givenP === void 0 ? "" : _prefixOptions$givenP, _prefixOptions$styles = prefixOptions.styles, styles2 = _prefixOptions$styles === void 0 ? {} : _prefixOptions$styles, _prefixOptions$config = prefixOptions.config, config$$1 = _prefixOptions$config === void 0 ? {} : _prefixOptions$config;
  var isDuotoneFamily = family === t$1;
  var valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
  var defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
  var canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
  if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
    canonical.prefix = "fad";
  }
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
    var validPrefix = Object.keys(styles2).find(function(key) {
      return newCanonicalStyles.includes(key);
    });
    if (validPrefix || config$$1.autoFetchSvg) {
      var defaultPrefix = Ut$1.get(family).defaultShortPrefixId;
      canonical.prefix = defaultPrefix;
      canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
    }
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = /* @__PURE__ */ (function() {
  function Library2() {
    _classCallCheck(this, Library2);
    this.definitions = {};
  }
  return _createClass(Library2, [{
    key: "add",
    value: function add() {
      var _this = this;
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread2$1(_objectSpread2$1({}, _this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);
        var longPrefix = PREFIX_TO_LONG_STYLE[i$1][key];
        if (longPrefix) defineIcons(longPrefix, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix = _normalized$key.prefix, iconName = _normalized$key.iconName, icon32 = _normalized$key.icon;
        var aliases = icon32[2];
        if (!additions[prefix]) additions[prefix] = {};
        if (aliases.length > 0) {
          aliases.forEach(function(alias) {
            if (typeof alias === "string") {
              additions[prefix][alias] = icon32;
            }
          });
        }
        additions[prefix][iconName] = icon32;
      });
      return additions;
    }
  }]);
})();
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref2) {
  var obj = _ref2.mixoutsTo;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(function(k2) {
    if (defaultProviderKeys.indexOf(k2) === -1) {
      delete providers[k2];
    }
  });
  _plugins.forEach(function(plugin) {
    var mixout8 = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout8).forEach(function(tk) {
      if (typeof mixout8[tk] === "function") {
        obj[tk] = mixout8[tk];
      }
      if (_typeof$c(mixout8[tk]) === "object") {
        Object.keys(mixout8[tk]).forEach(function(sk) {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout8[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      var hooks8 = plugin.hooks();
      Object.keys(hooks8).forEach(function(hook) {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks8[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    accumulator = hookFn.apply(null, [accumulator].concat(args));
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  var hook = arguments[0];
  var args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  var iconName = iconLookup.iconName;
  var prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
var library = new Library();
var noAuto = function noAuto2() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject(new Error("Operation requires a DOM of some kind."));
    }
  },
  watch: function watch2() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(function() {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
var parse = {
  icon: function icon(_icon) {
    if (_icon === null) {
      return null;
    }
    if (_typeof$c(_icon) === "object" && _icon.prefix && _icon.iconName) {
      return {
        prefix: _icon.prefix,
        iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
      };
    }
    if (Array.isArray(_icon) && _icon.length === 2) {
      var iconName = _icon[1].indexOf("fa-") === 0 ? _icon[1].slice(3) : _icon[1];
      var prefix = getCanonicalPrefix(_icon[0]);
      return {
        prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }
    if (typeof _icon === "string" && (_icon.indexOf("".concat(config.cssPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      var canonicalIcon = getCanonicalIcon(_icon.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof _icon === "string") {
      var _prefix = getDefaultUsablePrefix();
      return {
        prefix: _prefix,
        iconName: byAlias(_prefix, _icon) || _icon
      };
    }
  }
};
var api = {
  noAuto,
  config,
  dom,
  parse,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function autoReplace2() {
  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot, autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get22() {
      return val.abstract.map(function(a2) {
        return toHtml(a2);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get22() {
      if (!IS_DOM) return void 0;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref2) {
  var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform = _ref2.transform;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width, height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread2$1(_objectSpread2$1({}, styles2), {}, {
      "transform-origin": "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread2$1(_objectSpread2$1({}, attributes), {}, {
        id
      }),
      children
    }]
  }];
}
function isLabeled(attributes) {
  var labels = ["aria-label", "aria-labelledby", "title", "role"];
  return labels.some(function(label) {
    return label in attributes;
  });
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix = params.prefix, iconName = params.iconName, transform = params.transform, symbol = params.symbol, maskId = params.maskId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
  var attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter(function(c2) {
    return extra.classes.indexOf(c2) === -1;
  }).filter(function(c2) {
    return c2 !== "" || !!c2;
  }).concat(extra.classes).join(" ");
  var content = {
    children: [],
    attributes: _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
      "data-prefix": prefix,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  if (!isLabeled(extra.attributes) && !extra.attributes["aria-hidden"]) {
    content.attributes["aria-hidden"] = "true";
  }
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  var args = _objectSpread2$1(_objectSpread2$1({}, content), {}, {
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol,
    styles: _objectSpread2$1({}, extra.styles)
  });
  var _ref22 = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  }, children = _ref22.children, attributes = _ref22.attributes;
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content, width = params.width, height = params.height, transform = params.transform, extra = params.extra, _params$watchable2 = params.watchable, watchable = _params$watchable2 === void 0 ? false : _params$watchable2;
  var attributes = _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
    class: extra.classes.join(" ")
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  var styles2 = _objectSpread2$1({}, extra.styles);
  if (transformIsMeaningful(transform)) {
    styles2["transform"] = transformForCss({
      transform,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content, extra = params.extra;
  var attributes = _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
    class: extra.classes.join(" ")
  });
  var styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  return val;
}
var styles$1 = namespace.styles;
function asFoundIcon(icon32) {
  var width = icon32[0];
  var height = icon32[1];
  var _icon$slice = icon32.slice(4), _icon$slice2 = _slicedToArray$1(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION$1 && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
  }
}
function findIcon(iconName, prefix) {
  var givenPrefix = prefix;
  if (prefix === "fa" && config.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }
  return new Promise(function(resolve2, reject) {
    if (givenPrefix === "fa") {
      var shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }
    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      var icon32 = styles$1[prefix][iconName];
      return resolve2(asFoundIcon(icon32));
    }
    maybeNotifyMissing(iconName, prefix);
    resolve2(_objectSpread2$1(_objectSpread2$1({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    }));
  });
}
var noop$1$1 = function noop3() {
};
var p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1$1,
  measure: noop$1$1
};
var preamble = 'FA "7.1.0"';
var begin = function begin2(name) {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return function() {
    return end(name);
  };
};
var end = function end2(name) {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = function noop4() {
};
function isWatched(node) {
  var i2svg2 = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg2 === "string";
}
function hasPrefixAndIcon(node) {
  var prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  var icon32 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon32;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$ceFn = params.ceFn, ceFn = _params$ceFn === void 0 ? abstractObj.tag === "svg" ? createElementNS : createElement : _params$ceFn;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  var tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  var children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  var comment = " ".concat(node.outerHTML, " ");
  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  return comment;
}
var mutators = {
  replace: function replace(mutation) {
    var node = mutation[0];
    if (node.parentNode) {
      mutation[1].forEach(function(abstract) {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });
      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        var comment = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1];
    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    var forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      var splitClasses = abstract[0].attributes.class.split(" ").reduce(function(acc, cls) {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node.removeAttribute("class");
      } else {
        node.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    var newInnerHTML = abstract.map(function(a2) {
      return toHtml(a2);
    }).join("\n");
    node.setAttribute(DATA_FA_I2SVG, "");
    node.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  var callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(function() {
      var mutator = getMutator();
      var mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  var _options$treeCallback = options.treeCallback, treeCallback = _options$treeCallback === void 0 ? noop$2 : _options$treeCallback, _options$nodeCallback = options.nodeCallback, nodeCallback = _options$nodeCallback === void 0 ? noop$2 : _options$nodeCallback, _options$pseudoElemen = options.pseudoElementsCallback, pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2 : _options$pseudoElemen, _options$observeMutat = options.observeMutationsRoot, observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function(objects) {
    if (disabled) return;
    var defaultPrefix = getDefaultUsablePrefix();
    toArray$1(objects).forEach(function(mutationRecord) {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback([mutationRecord.target], true);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)), prefix = _getCanonicalIcon.prefix, iconName = _getCanonicalIcon.iconName;
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}
function styleParser(node) {
  var style2 = node.getAttribute("style");
  var val = [];
  if (style2) {
    val = style2.split(";").reduce(function(acc, style22) {
      var styles2 = style22.split(":");
      var prop = styles2[0];
      var value = styles2.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node) {
  var existingPrefix = node.getAttribute("data-prefix");
  var existingIconName = node.getAttribute("data-icon");
  var innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
  var val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }
  return val;
}
function attributesParser(node) {
  var extraAttributes = toArray$1(node.attributes).reduce(function(acc, attr) {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  var _classParser = classParser(node), iconName = _classParser.iconName, prefix = _classParser.prefix, extraClasses = _classParser.rest;
  var extraAttributes = attributesParser(node);
  var pluginMeta = chainHooks("parseNodeAttributes", {}, node);
  var extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2$1({
    iconName,
    prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}
var styles$2 = namespace.styles;
function generateMutation(node) {
  var nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
  }
}
function getKnownPrefixes() {
  return [].concat(_toConsumableArray$b(Yt$1), _toConsumableArray$b(Zt$1));
}
function onTree(root6) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  var htmlClassList = DOCUMENT.documentElement.classList;
  var hclAdd = function hclAdd2(suffix) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };
  var hclRemove = function hclRemove2(suffix) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };
  var prefixes2 = config.autoFetchSvg ? getKnownPrefixes() : Q$1.concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map(function(p$$1) {
    return ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  var candidates = [];
  try {
    candidates = toArray$1(root6.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  var mark = perf.begin("onTree");
  var mutations = candidates.reduce(function(acc, node) {
    try {
      var mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION$1) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise(function(resolve2, reject) {
    Promise.all(mutations).then(function(resolvedMutations) {
      perform(resolvedMutations, function() {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function") callback();
        mark();
        resolve2();
      });
    }).catch(function(e$$1) {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node).then(function(mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2$1(_objectSpread2$1({}, params), {}, {
      mask
    }));
  };
}
var render$i = function render2(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$classes = params.classes, classes2 = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix = iconDefinition.prefix, iconName = iconDefinition.iconName, icon32 = iconDefinition.icon;
  return domVariants(_objectSpread2$1({
    type: "icon"
  }, iconDefinition), function() {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon32),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
      symbol,
      maskId,
      extra: {
        attributes,
        styles: styles2,
        classes: classes2
      }
    });
  });
};
var ReplaceElements = {
  mixout: function mixout2() {
    return {
      icon: resolveIcons(render$i)
    };
  },
  hooks: function hooks2() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node, _params$callback = params.callback, callback = _params$callback === void 0 ? function() {
      } : _params$callback;
      return onTree(node, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
      var iconName = nodeMeta.iconName, prefix = nodeMeta.prefix, transform = nodeMeta.transform, symbol = nodeMeta.symbol, mask = nodeMeta.mask, maskId = nodeMeta.maskId, extra = nodeMeta.extra;
      return new Promise(function(resolve2, reject) {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(_ref2) {
          var _ref22 = _slicedToArray$1(_ref2, 2), main = _ref22[0], mask2 = _ref22[1];
          resolve2([node, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix,
            iconName,
            transform,
            symbol,
            maskId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref3) {
      var children = _ref3.children, attributes = _ref3.attributes, main = _ref3.main, transform = _ref3.transform, styles2 = _ref3.styles;
      var styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      var nextChild;
      if (transformIsMeaningful(transform)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children.push(nextChild || main.icon);
      return {
        children,
        attributes
      };
    };
  }
};
var Layers = {
  mixout: function mixout3() {
    return {
      layer: function layer2(assembler) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$classes = params.classes, classes2 = _params$classes === void 0 ? [] : _params$classes;
        return domVariants({
          type: "layer"
        }, function() {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          var children = [];
          assembler(function(args) {
            Array.isArray(args) ? args.map(function(a2) {
              children = children.concat(a2.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers")].concat(_toConsumableArray$b(classes2)).join(" ")
            },
            children
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout: function mixout4() {
    return {
      counter: function counter2(content) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        params.title;
        var _params$classes = params.classes, classes2 = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "counter",
          content
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-counter")].concat(_toConsumableArray$b(classes2))
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout: function mixout5() {
    return {
      text: function text2(content) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$classes = params.classes, classes2 = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "text",
          content
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-text")].concat(_toConsumableArray$b(classes2))
            }
          });
        });
      }
    };
  },
  provides: function provides2(providers$$1) {
    providers$$1.generateLayersText = function(node, nodeMeta) {
      var transform = nodeMeta.transform, extra = nodeMeta.extra;
      var width = null;
      var height = null;
      if (IS_IE) {
        var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        var boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width,
        height,
        transform,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
var _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), Ct$1), ro), dl);
var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce(function(acc, key) {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce(function(acc, fontFamily) {
  var weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || _toConsumableArray$b(Object.entries(weights))[0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  var cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  return toHex(_toConsumableArray$b(cleaned)[0] || "");
}
function isSecondaryLayer(styles2) {
  var hasStylisticSet = styles2.getPropertyValue("font-feature-settings").includes("ss01");
  var content = styles2.getPropertyValue("content");
  var cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  var codePoint = cleaned.codePointAt(0);
  var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return isPrependTen || isDoubled || hasStylisticSet;
}
function getPrefix(fontFamily, fontWeight) {
  var fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  var fontWeightInteger = parseInt(fontWeight);
  var fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
  return new Promise(function(resolve2, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      return resolve2();
    }
    var children = toArray$1(node.children);
    var alreadyProcessedPseudoElement = children.filter(function(c$$1) {
      return c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles2 = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles2.getPropertyValue("font-family");
    var fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    var fontWeight = styles2.getPropertyValue("font-weight");
    var content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve2();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      var _content = styles2.getPropertyValue("content");
      var prefix = getPrefix(fontFamily, fontWeight);
      var hexValue = hexValueFromContent(_content);
      var isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      var isSecondary = isSecondaryLayer(styles2);
      var iconName = byUnicode(prefix, hexValue);
      var iconIdentifier = iconName;
      if (isV4) {
        var iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node.removeChild(alreadyProcessedPseudoElement);
        }
        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(function(main) {
          var abstract = makeInlineSvgAbstract(_objectSpread2$1(_objectSpread2$1({}, meta), {}, {
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          var element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position === "::before") {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map(function(a$$1) {
            return toHtml(a$$1);
          }).join("\n");
          node.removeAttribute(pendingAttribute);
          resolve2();
        }).catch(reject);
      } else {
        resolve2();
      }
    } else {
      resolve2();
    }
  });
}
function replace2(node) {
  return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
}
var hasPseudoElement = function hasPseudoElement2(selector) {
  return !!selector && PSEUDO_ELEMENTS.some(function(pseudoSelector) {
    return selector.includes(pseudoSelector);
  });
};
var parseCSSRuleForPseudos = function parseCSSRuleForPseudos2(selectorText) {
  if (!selectorText) return [];
  var selectorSet = /* @__PURE__ */ new Set();
  var selectors = selectorText.split(/,(?![^()]*\))/).map(function(s$$1) {
    return s$$1.trim();
  });
  selectors = selectors.flatMap(function(selector2) {
    return selector2.includes("(") ? selector2 : selector2.split(",").map(function(s$$1) {
      return s$$1.trim();
    });
  });
  var _iterator = _createForOfIteratorHelper(selectors), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var selector = _step.value;
      if (hasPseudoElement(selector)) {
        var selectorWithoutPseudo = PSEUDO_ELEMENTS.reduce(function(acc, pseudoSelector) {
          return acc.replace(pseudoSelector, "");
        }, selector);
        if (selectorWithoutPseudo !== "" && selectorWithoutPseudo !== "*") {
          selectorSet.add(selectorWithoutPseudo);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return selectorSet;
};
function searchPseudoElements(root6) {
  var useAsNodeList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!IS_DOM) return;
  var nodeList;
  if (useAsNodeList) {
    nodeList = root6;
  } else if (config.searchPseudoElementsFullScan) {
    nodeList = root6.querySelectorAll("*");
  } else {
    var selectorSet = /* @__PURE__ */ new Set();
    var _iterator2 = _createForOfIteratorHelper(document.styleSheets), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var stylesheet = _step2.value;
        try {
          var _iterator3 = _createForOfIteratorHelper(stylesheet.cssRules), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var rule = _step3.value;
              var parsedSelectors = parseCSSRuleForPseudos(rule.selectorText);
              var _iterator4 = _createForOfIteratorHelper(parsedSelectors), _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                  var selector = _step4.value;
                  selectorSet.add(selector);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        } catch (e$$1) {
          if (config.searchPseudoElementsWarnings) {
            console.warn("Font Awesome: cannot parse stylesheet: ".concat(stylesheet.href, " (").concat(e$$1.message, ')\nIf it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.'));
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (!selectorSet.size) return;
    var cleanSelectors = Array.from(selectorSet).join(", ");
    try {
      nodeList = root6.querySelectorAll(cleanSelectors);
    } catch (_unused) {
    }
  }
  return new Promise(function(resolve2, reject) {
    var operations = toArray$1(nodeList).filter(processable).map(replace2);
    var end3 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(function() {
      end3();
      enableObservation();
      resolve2();
    }).catch(function() {
      end3();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks: function hooks3() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides: function provides3(providers2) {
    providers2.pseudoElements2svg = function(params) {
      var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node;
      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout: function mixout6() {
    return {
      dom: {
        unwatch: function unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks: function hooks4() {
    return {
      bootstrap: function bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto: function noAuto3() {
        disconnect();
      },
      watch: function watch22(params) {
        var observeMutationsRoot = params.observeMutationsRoot;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = function parseTransformString2(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce(function(acc, n2) {
    var parts = n2.toLowerCase().split("-");
    var first = parts[0];
    var rest = parts.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout: function mixout7() {
    return {
      parse: {
        transform: function transform(transformString) {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks: function hooks5() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var transformString = node.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides: function provides4(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref2) {
      var main = _ref2.main, transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
      var outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      var inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      var path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      var operations = {
        outer,
        inner,
        path
      };
      return {
        tag: "g",
        attributes: _objectSpread2$1({}, operations.outer),
        children: [{
          tag: "g",
          attributes: _objectSpread2$1({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2$1(_objectSpread2$1({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks: function hooks6() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var maskData = node.getAttribute("data-fa-mask");
        var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map(function(i2) {
          return i2.trim();
        }));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides: function provides5(providers2) {
    providers2.generateAbstractMask = function(_ref2) {
      var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform = _ref2.transform;
      var mainWidth = main.width, mainPath = main.icon;
      var maskWidth = mask.width, maskPath = mask.icon;
      var trans = transformForSvg({
        transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      var maskRect = {
        tag: "rect",
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          fill: "white"
        })
      };
      var maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      var maskInnerGroup = {
        tag: "g",
        attributes: _objectSpread2$1({}, trans.inner),
        children: [fillBlack(_objectSpread2$1({
          tag: mainPath.tag,
          attributes: _objectSpread2$1(_objectSpread2$1({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      var maskOuterGroup = {
        tag: "g",
        attributes: _objectSpread2$1({}, trans.outer),
        children: [maskInnerGroup]
      };
      var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      var maskTag = {
        tag: "mask",
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [maskRect, maskOuterGroup]
      };
      var defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: "rect",
        attributes: _objectSpread2$1({
          "fill": "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          "mask": "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides: function provides6(providers2) {
    var reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      var gChildren = [];
      var FILL = {
        fill: "currentColor"
      };
      var ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var OPACITY_ANIMATE = _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
        attributeName: "opacity"
      });
      var dot = {
        tag: "circle",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      if (!reduceMotion) {
        dot.children.push({
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: "1;0;1;1;0;1;"
          })
        });
      }
      gChildren.push(dot);
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks: function hooks7() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var symbolData = node.getAttribute("data-fa-symbol");
        var symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
api.noAuto;
api.config;
api.library;
api.dom;
var parse$1 = api.parse;
api.findIconDefinition;
api.toHtml;
var icon2 = api.icon;
api.layer;
api.text;
api.counter;
function _defineProperty$b(e2, r2, t2) {
  return (r2 = _toPropertyKey$b(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function ownKeys$6(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$6(Object(t2), true).forEach(function(r22) {
      _defineProperty$b(e2, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$6(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e2;
}
function _objectWithoutProperties(e2, t2) {
  if (null == e2) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _toPrimitive$b(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey$b(t2) {
  var i2 = _toPrimitive$b(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _typeof$b(o2) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof$b(o2);
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty$b({}, key, value) : {};
}
function classList(props) {
  var _classes;
  var classes2 = (_classes = {
    "fa-spin": props.spin,
    "fa-pulse": props.pulse,
    // the fixedWidth property has been deprecated as of version 7.0.0
    "fa-fw": props.fixedWidth,
    "fa-border": props.border,
    "fa-li": props.listItem,
    "fa-inverse": props.inverse,
    "fa-flip": props.flip === true,
    "fa-flip-horizontal": props.flip === "horizontal" || props.flip === "both",
    "fa-flip-vertical": props.flip === "vertical" || props.flip === "both"
  }, _defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_classes, "fa-".concat(props.size), props.size !== null), "fa-rotate-".concat(props.rotation), props.rotation !== null), "fa-rotate-by", props.rotateBy), "fa-pull-".concat(props.pull), props.pull !== null), "fa-swap-opacity", props.swapOpacity), "fa-bounce", props.bounce), "fa-shake", props.shake), "fa-beat", props.beat), "fa-fade", props.fade), "fa-beat-fade", props.beatFade), _defineProperty$b(_defineProperty$b(_defineProperty$b(_defineProperty$b(_classes, "fa-flash", props.flash), "fa-spin-pulse", props.spinPulse), "fa-spin-reverse", props.spinReverse), "fa-width-auto", props.widthAuto));
  return Object.keys(classes2).map(function(key) {
    return classes2[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var humps$1 = { exports: {} };
(function(module) {
  (function(global2) {
    var _processKeys = function(convert2, obj, options) {
      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
        return obj;
      }
      var output, i2 = 0, l2 = 0;
      if (_isArray(obj)) {
        output = [];
        for (l2 = obj.length; i2 < l2; i2++) {
          output.push(_processKeys(convert2, obj[i2], options));
        }
      } else {
        output = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            output[convert2(key, options)] = _processKeys(convert2, obj[key], options);
          }
        }
      }
      return output;
    };
    var separateWords = function(string, options) {
      options = options || {};
      var separator = options.separator || "_";
      var split = options.split || /(?=[A-Z])/;
      return string.split(split).join(separator);
    };
    var camelize2 = function(string) {
      if (_isNumerical(string)) {
        return string;
      }
      string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
        return chr ? chr.toUpperCase() : "";
      });
      return string.substr(0, 1).toLowerCase() + string.substr(1);
    };
    var pascalize = function(string) {
      var camelized = camelize2(string);
      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
    };
    var decamelize = function(string, options) {
      return separateWords(string, options).toLowerCase();
    };
    var toString3 = Object.prototype.toString;
    var _isFunction = function(obj) {
      return typeof obj === "function";
    };
    var _isObject = function(obj) {
      return obj === Object(obj);
    };
    var _isArray = function(obj) {
      return toString3.call(obj) == "[object Array]";
    };
    var _isDate = function(obj) {
      return toString3.call(obj) == "[object Date]";
    };
    var _isRegExp = function(obj) {
      return toString3.call(obj) == "[object RegExp]";
    };
    var _isBoolean = function(obj) {
      return toString3.call(obj) == "[object Boolean]";
    };
    var _isNumerical = function(obj) {
      obj = obj - 0;
      return obj === obj;
    };
    var _processor = function(convert2, options) {
      var callback = options && "process" in options ? options.process : options;
      if (typeof callback !== "function") {
        return convert2;
      }
      return function(string, options2) {
        return callback(string, convert2, options2);
      };
    };
    var humps2 = {
      camelize: camelize2,
      decamelize,
      pascalize,
      depascalize: decamelize,
      camelizeKeys: function(object, options) {
        return _processKeys(_processor(camelize2, options), object);
      },
      decamelizeKeys: function(object, options) {
        return _processKeys(_processor(decamelize, options), object, options);
      },
      pascalizeKeys: function(object, options) {
        return _processKeys(_processor(pascalize, options), object);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    if (module.exports) {
      module.exports = humps2;
    } else {
      global2.humps = humps2;
    }
  })(commonjsGlobal);
})(humps$1);
var humps = humps$1.exports;
var _excluded = ["class", "style"];
function styleToObject(style2) {
  return style2.split(";").map(function(s2) {
    return s2.trim();
  }).filter(function(s2) {
    return s2;
  }).reduce(function(output, pair) {
    var idx = pair.indexOf(":");
    var prop = humps.camelize(pair.slice(0, idx));
    var value = pair.slice(idx + 1).trim();
    output[prop] = value;
    return output;
  }, {});
}
function classToObject(classes2) {
  return classes2.split(/\s+/).reduce(function(output, className) {
    output[className] = true;
    return output;
  }, {});
}
function convert(abstractElement) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var attrs2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof abstractElement === "string") {
    return abstractElement;
  }
  var children = (abstractElement.children || []).map(function(child) {
    return convert(child);
  });
  var mixins = Object.keys(abstractElement.attributes || {}).reduce(function(mixins2, key) {
    var value = abstractElement.attributes[key];
    switch (key) {
      case "class":
        mixins2.class = classToObject(value);
        break;
      case "style":
        mixins2.style = styleToObject(value);
        break;
      default:
        mixins2.attrs[key] = value;
    }
    return mixins2;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  attrs2.class;
  var _attrs$style = attrs2.style, aStyle = _attrs$style === void 0 ? {} : _attrs$style, otherAttrs = _objectWithoutProperties(attrs2, _excluded);
  return h$8(abstractElement.tag, _objectSpread2(_objectSpread2(_objectSpread2({}, props), {}, {
    class: mixins.class,
    style: _objectSpread2(_objectSpread2({}, mixins.style), aStyle)
  }, mixins.attrs), otherAttrs), children);
}
var PRODUCTION = false;
try {
  PRODUCTION = true;
} catch (e2) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon22) {
  if (icon22 && _typeof$b(icon22) === "object" && icon22.prefix && icon22.iconName && icon22.icon) {
    return icon22;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon22);
  }
  if (icon22 === null) {
    return null;
  }
  if (_typeof$b(icon22) === "object" && icon22.prefix && icon22.iconName) {
    return icon22;
  }
  if (Array.isArray(icon22) && icon22.length === 2) {
    return {
      prefix: icon22[0],
      iconName: icon22[1]
    };
  }
  if (typeof icon22 === "string") {
    return {
      prefix: "fas",
      iconName: icon22
    };
  }
}
var FontAwesomeIcon = /* @__PURE__ */ defineComponent({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: false
    },
    // the fixedWidth property has been deprecated as of version 7
    fixedWidth: {
      type: Boolean,
      default: false
    },
    flip: {
      type: [Boolean, String],
      default: false,
      validator: function validator(value) {
        return [true, false, "horizontal", "vertical", "both"].indexOf(value) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: true
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    maskId: {
      type: String,
      default: null
    },
    listItem: {
      type: Boolean,
      default: false
    },
    pull: {
      type: String,
      default: null,
      validator: function validator2(value) {
        return ["right", "left"].indexOf(value) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function validator3(value) {
        return [90, 180, 270].indexOf(Number.parseInt(value, 10)) > -1;
      }
    },
    // the rotateBy property is only supported in version 7.0.0 and later
    rotateBy: {
      type: Boolean,
      default: false
    },
    swapOpacity: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: null,
      validator: function validator4(value) {
        return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(value) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: false
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: false
    },
    title: {
      type: String,
      default: null
    },
    titleId: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: false
    },
    bounce: {
      type: Boolean,
      default: false
    },
    shake: {
      type: Boolean,
      default: false
    },
    beat: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    },
    beatFade: {
      type: Boolean,
      default: false
    },
    flash: {
      type: Boolean,
      default: false
    },
    spinPulse: {
      type: Boolean,
      default: false
    },
    spinReverse: {
      type: Boolean,
      default: false
    },
    // the widthAuto property is only supported in version 7.0.0 and later
    widthAuto: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup2(props, _ref2) {
    var attrs2 = _ref2.attrs;
    var icon$1 = computed(function() {
      return normalizeIconArgs(props.icon);
    });
    var classes2 = computed(function() {
      return objectWithKey("classes", classList(props));
    });
    var transform = computed(function() {
      return objectWithKey("transform", typeof props.transform === "string" ? parse$1.transform(props.transform) : props.transform);
    });
    var mask = computed(function() {
      return objectWithKey("mask", normalizeIconArgs(props.mask));
    });
    var renderedIcon = computed(function() {
      var iconProps = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes2.value), transform.value), mask.value), {}, {
        symbol: props.symbol,
        maskId: props.maskId
      });
      iconProps.title = props.title;
      iconProps.titleId = props.titleId;
      return icon2(icon$1.value, iconProps);
    });
    watch(renderedIcon, function(value) {
      if (!value) {
        return log("Could not find one or more icon(s)", icon$1.value, mask.value);
      }
    }, {
      immediate: true
    });
    var vnode = computed(function() {
      return renderedIcon.value ? convert(renderedIcon.value.abstract[0], {}, attrs2) : null;
    });
    return function() {
      return vnode.value;
    };
  }
});
function useAttrSelector() {
  var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pc";
  var idx = useId();
  return "".concat(prefix).concat(idx.replace("v-", "").replaceAll("-", "_"));
}
var BaseComponentStyle = BaseStyle.extend({
  name: "common"
});
function _typeof$a(o2) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$a(o2);
}
function _toArray(r2) {
  return _arrayWithHoles(r2) || _iterableToArray$b(r2) || _unsupportedIterableToArray$b(r2) || _nonIterableRest();
}
function _iterableToArray$b(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray$b(r2, e2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$b(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$b(r2, a2) : void 0;
  }
}
function _arrayLikeToArray$b(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function ownKeys$5(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$5(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$5(Object(t2), true).forEach(function(r3) {
      _defineProperty$a(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$5(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$a(e2, r2, t2) {
  return (r2 = _toPropertyKey$a(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$a(t2) {
  var i2 = _toPrimitive$a(t2, "string");
  return "symbol" == _typeof$a(i2) ? i2 : i2 + "";
}
function _toPrimitive$a(t2, r2) {
  if ("object" != _typeof$a(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var script$k = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      "default": void 0
    },
    ptOptions: {
      type: Object,
      "default": void 0
    },
    unstyled: {
      type: Boolean,
      "default": void 0
    },
    dt: {
      type: Object,
      "default": void 0
    }
  },
  inject: {
    $parentInstance: {
      "default": void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: true,
      handler: function handler(newValue) {
        N$2.off("theme:change", this._loadCoreStyles);
        if (!newValue) {
          this._loadCoreStyles();
          this._themeChangeListener(this._loadCoreStyles);
        }
      }
    },
    dt: {
      immediate: true,
      handler: function handler2(newValue, oldValue) {
        var _this = this;
        N$2.off("theme:change", this._themeScopedListener);
        if (newValue) {
          this._loadScopedThemeStyles(newValue);
          this._themeScopedListener = function() {
            return _this._loadScopedThemeStyles(newValue);
          };
          this._themeChangeListener(this._themeScopedListener);
        } else {
          this._unloadScopedThemeStyles();
        }
      }
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  uid: void 0,
  $attrSelector: void 0,
  beforeCreate: function beforeCreate() {
    var _this$pt, _this$pt2, _this$pt3, _ref2, _ref$onBeforeCreate, _this$$primevueConfig, _this$$primevue, _this$$primevue2, _this$$primevue3, _ref22, _ref2$onBeforeCreate;
    var _usept = (_this$pt = this.pt) === null || _this$pt === void 0 ? void 0 : _this$pt["_usept"];
    var originalValue = _usept ? (_this$pt2 = this.pt) === null || _this$pt2 === void 0 || (_this$pt2 = _this$pt2.originalValue) === null || _this$pt2 === void 0 ? void 0 : _this$pt2[this.$.type.name] : void 0;
    var value = _usept ? (_this$pt3 = this.pt) === null || _this$pt3 === void 0 || (_this$pt3 = _this$pt3.value) === null || _this$pt3 === void 0 ? void 0 : _this$pt3[this.$.type.name] : this.pt;
    (_ref2 = value || originalValue) === null || _ref2 === void 0 || (_ref2 = _ref2.hooks) === null || _ref2 === void 0 || (_ref$onBeforeCreate = _ref2["onBeforeCreate"]) === null || _ref$onBeforeCreate === void 0 || _ref$onBeforeCreate.call(_ref2);
    var _useptInConfig = (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.pt) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig["_usept"];
    var originalValueInConfig = _useptInConfig ? (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.pt) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.originalValue : void 0;
    var valueInConfig = _useptInConfig ? (_this$$primevue2 = this.$primevue) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.config) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.pt) === null || _this$$primevue2 === void 0 ? void 0 : _this$$primevue2.value : (_this$$primevue3 = this.$primevue) === null || _this$$primevue3 === void 0 || (_this$$primevue3 = _this$$primevue3.config) === null || _this$$primevue3 === void 0 ? void 0 : _this$$primevue3.pt;
    (_ref22 = valueInConfig || originalValueInConfig) === null || _ref22 === void 0 || (_ref22 = _ref22[this.$.type.name]) === null || _ref22 === void 0 || (_ref22 = _ref22.hooks) === null || _ref22 === void 0 || (_ref2$onBeforeCreate = _ref22["onBeforeCreate"]) === null || _ref2$onBeforeCreate === void 0 || _ref2$onBeforeCreate.call(_ref22);
    this.$attrSelector = useAttrSelector();
    this.uid = this.$attrs.id || this.$attrSelector.replace("pc", "pv_id_");
  },
  created: function created() {
    this._hook("onCreated");
  },
  beforeMount: function beforeMount2() {
    var _this$$el;
    this.rootEl = z$2(c$z(this.$el) ? this.$el : (_this$$el = this.$el) === null || _this$$el === void 0 ? void 0 : _this$$el.parentElement, "[".concat(this.$attrSelector, "]"));
    if (this.rootEl) {
      this.rootEl.$pc = _objectSpread$5({
        name: this.$.type.name,
        attrSelector: this.$attrSelector
      }, this.$params);
    }
    this._loadStyles();
    this._hook("onBeforeMount");
  },
  mounted: function mounted() {
    this._hook("onMounted");
  },
  beforeUpdate: function beforeUpdate() {
    this._hook("onBeforeUpdate");
  },
  updated: function updated2() {
    this._hook("onUpdated");
  },
  beforeUnmount: function beforeUnmount() {
    this._hook("onBeforeUnmount");
  },
  unmounted: function unmounted2() {
    this._removeThemeListeners();
    this._unloadScopedThemeStyles();
    this._hook("onUnmounted");
  },
  methods: {
    _hook: function _hook2(hookName) {
      if (!this.$options.hostName) {
        var selfHook = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(hookName));
        var defaultHook = this._useDefaultPT(this._getOptionValue, "hooks.".concat(hookName));
        selfHook === null || selfHook === void 0 || selfHook();
        defaultHook === null || defaultHook === void 0 || defaultHook();
      }
    },
    _mergeProps: function _mergeProps2(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return c$A(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
    },
    _load: function _load() {
      if (!Base.isStyleNameLoaded("base")) {
        BaseStyle.loadCSS(this.$styleOptions);
        this._loadGlobalStyles();
        Base.setLoadedStyleName("base");
      }
      this._loadThemeStyles();
    },
    _loadStyles: function _loadStyles2() {
      this._load();
      this._themeChangeListener(this._load);
    },
    _loadCoreStyles: function _loadCoreStyles2() {
      var _this$$style, _this$$style2;
      if (!Base.isStyleNameLoaded((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.name) && (_this$$style2 = this.$style) !== null && _this$$style2 !== void 0 && _this$$style2.name) {
        BaseComponentStyle.loadCSS(this.$styleOptions);
        this.$options.style && this.$style.loadCSS(this.$styleOptions);
        Base.setLoadedStyleName(this.$style.name);
      }
    },
    _loadGlobalStyles: function _loadGlobalStyles() {
      var globalCSS = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      s$e(globalCSS) && BaseStyle.load(globalCSS, _objectSpread$5({
        name: "global"
      }, this.$styleOptions));
    },
    _loadThemeStyles: function _loadThemeStyles2() {
      var _this$$style4, _this$$style5;
      if (this.isUnstyled || this.$theme === "none") return;
      if (!S$2.isStyleNameLoaded("common")) {
        var _this$$style3, _this$$style3$getComm;
        var _ref3 = ((_this$$style3 = this.$style) === null || _this$$style3 === void 0 || (_this$$style3$getComm = _this$$style3.getCommonTheme) === null || _this$$style3$getComm === void 0 ? void 0 : _this$$style3$getComm.call(_this$$style3)) || {}, primitive = _ref3.primitive, semantic = _ref3.semantic, global2 = _ref3.global, style2 = _ref3.style;
        BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$5({
          name: "primitive-variables"
        }, this.$styleOptions));
        BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$5({
          name: "semantic-variables"
        }, this.$styleOptions));
        BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$5({
          name: "global-variables"
        }, this.$styleOptions));
        BaseStyle.loadStyle(_objectSpread$5({
          name: "global-style"
        }, this.$styleOptions), style2);
        S$2.setLoadedStyleName("common");
      }
      if (!S$2.isStyleNameLoaded((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.name) && (_this$$style5 = this.$style) !== null && _this$$style5 !== void 0 && _this$$style5.name) {
        var _this$$style6, _this$$style6$getComp, _this$$style7, _this$$style8;
        var _ref4 = ((_this$$style6 = this.$style) === null || _this$$style6 === void 0 || (_this$$style6$getComp = _this$$style6.getComponentTheme) === null || _this$$style6$getComp === void 0 ? void 0 : _this$$style6$getComp.call(_this$$style6)) || {}, css3 = _ref4.css, _style = _ref4.style;
        (_this$$style7 = this.$style) === null || _this$$style7 === void 0 || _this$$style7.load(css3, _objectSpread$5({
          name: "".concat(this.$style.name, "-variables")
        }, this.$styleOptions));
        (_this$$style8 = this.$style) === null || _this$$style8 === void 0 || _this$$style8.loadStyle(_objectSpread$5({
          name: "".concat(this.$style.name, "-style")
        }, this.$styleOptions), _style);
        S$2.setLoadedStyleName(this.$style.name);
      }
      if (!S$2.isStyleNameLoaded("layer-order")) {
        var _this$$style9, _this$$style9$getLaye;
        var layerOrder = (_this$$style9 = this.$style) === null || _this$$style9 === void 0 || (_this$$style9$getLaye = _this$$style9.getLayerOrderThemeCSS) === null || _this$$style9$getLaye === void 0 ? void 0 : _this$$style9$getLaye.call(_this$$style9);
        BaseStyle.load(layerOrder, _objectSpread$5({
          name: "layer-order",
          first: true
        }, this.$styleOptions));
        S$2.setLoadedStyleName("layer-order");
      }
    },
    _loadScopedThemeStyles: function _loadScopedThemeStyles2(preset) {
      var _this$$style0, _this$$style0$getPres, _this$$style1;
      var _ref5 = ((_this$$style0 = this.$style) === null || _this$$style0 === void 0 || (_this$$style0$getPres = _this$$style0.getPresetTheme) === null || _this$$style0$getPres === void 0 ? void 0 : _this$$style0$getPres.call(_this$$style0, preset, "[".concat(this.$attrSelector, "]"))) || {}, css3 = _ref5.css;
      var scopedStyle = (_this$$style1 = this.$style) === null || _this$$style1 === void 0 ? void 0 : _this$$style1.load(css3, _objectSpread$5({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = scopedStyle.el;
    },
    _unloadScopedThemeStyles: function _unloadScopedThemeStyles() {
      var _this$scopedStyleEl;
      (_this$scopedStyleEl = this.scopedStyleEl) === null || _this$scopedStyleEl === void 0 || (_this$scopedStyleEl = _this$scopedStyleEl.value) === null || _this$scopedStyleEl === void 0 || _this$scopedStyleEl.remove();
    },
    _themeChangeListener: function _themeChangeListener2() {
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Base.clearLoadedStyleNames();
      N$2.on("theme:change", callback);
    },
    _removeThemeListeners: function _removeThemeListeners2() {
      N$2.off("theme:change", this._loadCoreStyles);
      N$2.off("theme:change", this._load);
      N$2.off("theme:change", this._themeScopedListener);
    },
    _getHostInstance: function _getHostInstance(instance2) {
      return instance2 ? this.$options.hostName ? instance2.$.type.name === this.$options.hostName ? instance2 : this._getHostInstance(instance2.$parentInstance) : instance2.$parentInstance : void 0;
    },
    _getPropValue: function _getPropValue(name) {
      var _this$_getHostInstanc;
      return this[name] || ((_this$_getHostInstanc = this._getHostInstance(this)) === null || _this$_getHostInstanc === void 0 ? void 0 : _this$_getHostInstanc[name]);
    },
    _getOptionValue: function _getOptionValue(options) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return F$4(options, key, params);
    },
    _getPTValue: function _getPTValue2() {
      var _this$$primevueConfig2;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var searchOut = /./g.test(key) && !!params[key.split(".")[0]];
      var _ref6 = this._getPropValue("ptOptions") || ((_this$$primevueConfig2 = this.$primevueConfig) === null || _this$$primevueConfig2 === void 0 ? void 0 : _this$$primevueConfig2.ptOptions) || {}, _ref6$mergeSections = _ref6.mergeSections, mergeSections = _ref6$mergeSections === void 0 ? true : _ref6$mergeSections, _ref6$mergeProps = _ref6.mergeProps, useMergeProps = _ref6$mergeProps === void 0 ? false : _ref6$mergeProps;
      var global2 = searchInDefaultPT ? searchOut ? this._useGlobalPT(this._getPTClassValue, key, params) : this._useDefaultPT(this._getPTClassValue, key, params) : void 0;
      var self2 = searchOut ? void 0 : this._getPTSelf(obj, this._getPTClassValue, key, _objectSpread$5(_objectSpread$5({}, params), {}, {
        global: global2 || {}
      }));
      var datasets = this._getPTDatasets(key);
      return mergeSections || !mergeSections && self2 ? useMergeProps ? this._mergeProps(useMergeProps, global2, self2, datasets) : _objectSpread$5(_objectSpread$5(_objectSpread$5({}, global2), self2), datasets) : _objectSpread$5(_objectSpread$5({}, self2), datasets);
    },
    _getPTSelf: function _getPTSelf() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return mergeProps(
        this._usePT.apply(this, [this._getPT(obj, this.$name)].concat(args)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(args))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    },
    _getPTDatasets: function _getPTDatasets2() {
      var _this$pt4, _this$pt5;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var datasetPrefix = "data-pc-";
      var isExtended = key === "root" && s$e((_this$pt4 = this.pt) === null || _this$pt4 === void 0 ? void 0 : _this$pt4["data-pc-section"]);
      return key !== "transition" && _objectSpread$5(_objectSpread$5({}, key === "root" && _objectSpread$5(_objectSpread$5(_defineProperty$a({}, "".concat(datasetPrefix, "name"), g$8(isExtended ? (_this$pt5 = this.pt) === null || _this$pt5 === void 0 ? void 0 : _this$pt5["data-pc-section"] : this.$.type.name)), isExtended && _defineProperty$a({}, "".concat(datasetPrefix, "extend"), g$8(this.$.type.name))), {}, _defineProperty$a({}, "".concat(this.$attrSelector), ""))), {}, _defineProperty$a({}, "".concat(datasetPrefix, "section"), g$8(key)));
    },
    _getPTClassValue: function _getPTClassValue() {
      var value = this._getOptionValue.apply(this, arguments);
      return a$J(value) || C$5(value) ? {
        "class": value
      } : value;
    },
    _getPT: function _getPT2(pt2) {
      var _this2 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var getValue = function getValue2(value) {
        var _ref8;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var computedValue = callback ? callback(value) : value;
        var _key = g$8(key);
        var _cKey = g$8(_this2.$name);
        return (_ref8 = checkSameKey ? _key !== _cKey ? computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key] : void 0 : computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _ref8 !== void 0 ? _ref8 : computedValue;
      };
      return pt2 !== null && pt2 !== void 0 && pt2.hasOwnProperty("_usept") ? {
        _usept: pt2["_usept"],
        originalValue: getValue(pt2.originalValue),
        value: getValue(pt2.value)
      } : getValue(pt2, true);
    },
    _usePT: function _usePT2(pt2, callback, key, params) {
      var fn = function fn2(value2) {
        return callback(value2, key, params);
      };
      if (pt2 !== null && pt2 !== void 0 && pt2.hasOwnProperty("_usept")) {
        var _this$$primevueConfig3;
        var _ref9 = pt2["_usept"] || ((_this$$primevueConfig3 = this.$primevueConfig) === null || _this$$primevueConfig3 === void 0 ? void 0 : _this$$primevueConfig3.ptOptions) || {}, _ref9$mergeSections = _ref9.mergeSections, mergeSections = _ref9$mergeSections === void 0 ? true : _ref9$mergeSections, _ref9$mergeProps = _ref9.mergeProps, useMergeProps = _ref9$mergeProps === void 0 ? false : _ref9$mergeProps;
        var originalValue = fn(pt2.originalValue);
        var value = fn(pt2.value);
        if (originalValue === void 0 && value === void 0) return void 0;
        else if (a$J(value)) return value;
        else if (a$J(originalValue)) return originalValue;
        return mergeSections || !mergeSections && value ? useMergeProps ? this._mergeProps(useMergeProps, originalValue, value) : _objectSpread$5(_objectSpread$5({}, originalValue), value) : value;
      }
      return fn(pt2);
    },
    _useGlobalPT: function _useGlobalPT(callback, key, params) {
      return this._usePT(this.globalPT, callback, key, params);
    },
    _useDefaultPT: function _useDefaultPT2(callback, key, params) {
      return this._usePT(this.defaultPT, callback, key, params);
    },
    ptm: function ptm() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, key, _objectSpread$5(_objectSpread$5({}, this.$params), params));
    },
    ptmi: function ptmi() {
      var _attrs$id;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var attrs2 = mergeProps(this.$_attrsWithoutPT, this.ptm(key, params));
      (attrs2 === null || attrs2 === void 0 ? void 0 : attrs2.hasOwnProperty("id")) && ((_attrs$id = attrs2.id) !== null && _attrs$id !== void 0 ? _attrs$id : attrs2.id = this.$id);
      return attrs2;
    },
    ptmo: function ptmo() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(obj, key, _objectSpread$5({
        instance: this
      }, params), false);
    },
    cx: function cx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !this.isUnstyled ? this._getOptionValue(this.$style.classes, key, _objectSpread$5(_objectSpread$5({}, this.$params), params)) : void 0;
    },
    sx: function sx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (when) {
        var self2 = this._getOptionValue(this.$style.inlineStyles, key, _objectSpread$5(_objectSpread$5({}, this.$params), params));
        var base = this._getOptionValue(BaseComponentStyle.inlineStyles, key, _objectSpread$5(_objectSpread$5({}, this.$params), params));
        return [base, self2];
      }
      return void 0;
    }
  },
  computed: {
    globalPT: function globalPT() {
      var _this$$primevueConfig4, _this3 = this;
      return this._getPT((_this$$primevueConfig4 = this.$primevueConfig) === null || _this$$primevueConfig4 === void 0 ? void 0 : _this$$primevueConfig4.pt, void 0, function(value) {
        return m$6(value, {
          instance: _this3
        });
      });
    },
    defaultPT: function defaultPT() {
      var _this$$primevueConfig5, _this4 = this;
      return this._getPT((_this$$primevueConfig5 = this.$primevueConfig) === null || _this$$primevueConfig5 === void 0 ? void 0 : _this$$primevueConfig5.pt, void 0, function(value) {
        return _this4._getOptionValue(value, _this4.$name, _objectSpread$5({}, _this4.$params)) || m$6(value, _objectSpread$5({}, _this4.$params));
      });
    },
    isUnstyled: function isUnstyled() {
      var _this$$primevueConfig6;
      return this.unstyled !== void 0 ? this.unstyled : (_this$$primevueConfig6 = this.$primevueConfig) === null || _this$$primevueConfig6 === void 0 ? void 0 : _this$$primevueConfig6.unstyled;
    },
    $id: function $id() {
      return this.$attrs.id || this.uid;
    },
    $inProps: function $inProps() {
      var _this$$$vnode;
      var nodePropKeys = Object.keys(((_this$$$vnode = this.$.vnode) === null || _this$$$vnode === void 0 ? void 0 : _this$$$vnode.props) || {});
      return Object.fromEntries(Object.entries(this.$props).filter(function(_ref0) {
        var _ref1 = _slicedToArray(_ref0, 1), k2 = _ref1[0];
        return nodePropKeys === null || nodePropKeys === void 0 ? void 0 : nodePropKeys.includes(k2);
      }));
    },
    $theme: function $theme() {
      var _this$$primevueConfig7;
      return (_this$$primevueConfig7 = this.$primevueConfig) === null || _this$$primevueConfig7 === void 0 ? void 0 : _this$$primevueConfig7.theme;
    },
    $style: function $style() {
      return _objectSpread$5(_objectSpread$5({
        classes: void 0,
        inlineStyles: void 0,
        load: function load2() {
        },
        loadCSS: function loadCSS2() {
        },
        loadStyle: function loadStyle2() {
        }
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    },
    $styleOptions: function $styleOptions() {
      var _this$$primevueConfig8;
      return {
        nonce: (_this$$primevueConfig8 = this.$primevueConfig) === null || _this$$primevueConfig8 === void 0 || (_this$$primevueConfig8 = _this$$primevueConfig8.csp) === null || _this$$primevueConfig8 === void 0 ? void 0 : _this$$primevueConfig8.nonce
      };
    },
    $primevueConfig: function $primevueConfig() {
      var _this$$primevue4;
      return (_this$$primevue4 = this.$primevue) === null || _this$$primevue4 === void 0 ? void 0 : _this$$primevue4.config;
    },
    $name: function $name() {
      return this.$options.hostName || this.$.type.name;
    },
    $params: function $params() {
      var parentInstance = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: parentInstance,
          props: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$props,
          state: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$data,
          attrs: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$attrs
        }
      };
    },
    $_attrsPT: function $_attrsPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref10) {
        var _ref11 = _slicedToArray(_ref10, 1), key = _ref11[0];
        return key === null || key === void 0 ? void 0 : key.startsWith("pt:");
      }).reduce(function(result, _ref12) {
        var _ref13 = _slicedToArray(_ref12, 2), key = _ref13[0], value = _ref13[1];
        var _key$split = key.split(":"), _key$split2 = _toArray(_key$split), rest = _arrayLikeToArray$b(_key$split2).slice(1);
        rest === null || rest === void 0 || rest.reduce(function(currentObj, nestedKey, index2, array) {
          !currentObj[nestedKey] && (currentObj[nestedKey] = index2 === array.length - 1 ? value : {});
          return currentObj[nestedKey];
        }, result);
        return result;
      }, {});
    },
    $_attrsWithoutPT: function $_attrsWithoutPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref14) {
        var _ref15 = _slicedToArray(_ref14, 1), key = _ref15[0];
        return !(key !== null && key !== void 0 && key.startsWith("pt:"));
      }).reduce(function(acc, _ref16) {
        var _ref17 = _slicedToArray(_ref16, 2), key = _ref17[0], value = _ref17[1];
        acc[key] = value;
        return acc;
      }, {});
    }
  }
};
var css2 = "\n.p-icon {\n    display: inline-block;\n    vertical-align: baseline;\n    flex-shrink: 0;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
var BaseIconStyle = BaseStyle.extend({
  name: "baseicon",
  css: css2
});
function _typeof$9(o2) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$9(o2);
}
function ownKeys$4(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$4(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$4(Object(t2), true).forEach(function(r3) {
      _defineProperty$9(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$9(e2, r2, t2) {
  return (r2 = _toPropertyKey$9(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$9(t2) {
  var i2 = _toPrimitive$9(t2, "string");
  return "symbol" == _typeof$9(i2) ? i2 : i2 + "";
}
function _toPrimitive$9(t2, r2) {
  if ("object" != _typeof$9(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var script$j = {
  name: "BaseIcon",
  "extends": script$k,
  props: {
    label: {
      type: String,
      "default": void 0
    },
    spin: {
      type: Boolean,
      "default": false
    }
  },
  style: BaseIconStyle,
  provide: function provide2() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  },
  methods: {
    pti: function pti() {
      var isLabelEmpty = l$j(this.label);
      return _objectSpread$4(_objectSpread$4({}, !this.isUnstyled && {
        "class": ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: !isLabelEmpty ? "img" : void 0,
        "aria-label": !isLabelEmpty ? this.label : void 0,
        "aria-hidden": isLabelEmpty
      });
    }
  }
};
var script$i = {
  name: "SpinnerIcon",
  "extends": script$j
};
function _toConsumableArray$a(r2) {
  return _arrayWithoutHoles$a(r2) || _iterableToArray$a(r2) || _unsupportedIterableToArray$a(r2) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$a(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$a(r2, a2) : void 0;
  }
}
function _iterableToArray$a(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$a(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$a(r2);
}
function _arrayLikeToArray$a(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$a(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$i.render = render$h;
var style$6 = "\n    .p-badge {\n        display: inline-flex;\n        border-radius: dt('badge.border.radius');\n        align-items: center;\n        justify-content: center;\n        padding: dt('badge.padding');\n        background: dt('badge.primary.background');\n        color: dt('badge.primary.color');\n        font-size: dt('badge.font.size');\n        font-weight: dt('badge.font.weight');\n        min-width: dt('badge.min.width');\n        height: dt('badge.height');\n    }\n\n    .p-badge-dot {\n        width: dt('badge.dot.size');\n        min-width: dt('badge.dot.size');\n        height: dt('badge.dot.size');\n        border-radius: 50%;\n        padding: 0;\n    }\n\n    .p-badge-circle {\n        padding: 0;\n        border-radius: 50%;\n    }\n\n    .p-badge-secondary {\n        background: dt('badge.secondary.background');\n        color: dt('badge.secondary.color');\n    }\n\n    .p-badge-success {\n        background: dt('badge.success.background');\n        color: dt('badge.success.color');\n    }\n\n    .p-badge-info {\n        background: dt('badge.info.background');\n        color: dt('badge.info.color');\n    }\n\n    .p-badge-warn {\n        background: dt('badge.warn.background');\n        color: dt('badge.warn.color');\n    }\n\n    .p-badge-danger {\n        background: dt('badge.danger.background');\n        color: dt('badge.danger.color');\n    }\n\n    .p-badge-contrast {\n        background: dt('badge.contrast.background');\n        color: dt('badge.contrast.color');\n    }\n\n    .p-badge-sm {\n        font-size: dt('badge.sm.font.size');\n        min-width: dt('badge.sm.min.width');\n        height: dt('badge.sm.height');\n    }\n\n    .p-badge-lg {\n        font-size: dt('badge.lg.font.size');\n        min-width: dt('badge.lg.min.width');\n        height: dt('badge.lg.height');\n    }\n\n    .p-badge-xl {\n        font-size: dt('badge.xl.font.size');\n        min-width: dt('badge.xl.min.width');\n        height: dt('badge.xl.height');\n    }\n";
var classes$6 = {
  root: function root(_ref2) {
    var props = _ref2.props, instance2 = _ref2.instance;
    return ["p-badge p-component", {
      "p-badge-circle": s$e(props.value) && String(props.value).length === 1,
      "p-badge-dot": l$j(props.value) && !instance2.$slots["default"],
      "p-badge-sm": props.size === "small",
      "p-badge-lg": props.size === "large",
      "p-badge-xl": props.size === "xlarge",
      "p-badge-info": props.severity === "info",
      "p-badge-success": props.severity === "success",
      "p-badge-warn": props.severity === "warn",
      "p-badge-danger": props.severity === "danger",
      "p-badge-secondary": props.severity === "secondary",
      "p-badge-contrast": props.severity === "contrast"
    }];
  }
};
var BadgeStyle = BaseStyle.extend({
  name: "badge",
  style: style$6,
  classes: classes$6
});
var script$1$5 = {
  name: "BaseBadge",
  "extends": script$k,
  props: {
    value: {
      type: [String, Number],
      "default": null
    },
    severity: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": null
    }
  },
  style: BadgeStyle,
  provide: function provide3() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }
};
function _typeof$8(o2) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$8(o2);
}
function _defineProperty$8(e2, r2, t2) {
  return (r2 = _toPropertyKey$8(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$8(t2) {
  var i2 = _toPrimitive$8(t2, "string");
  return "symbol" == _typeof$8(i2) ? i2 : i2 + "";
}
function _toPrimitive$8(t2, r2) {
  if ("object" != _typeof$8(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var script$h = {
  name: "Badge",
  "extends": script$1$5,
  inheritAttrs: false,
  computed: {
    dataP: function dataP() {
      return f$c(_defineProperty$8(_defineProperty$8({
        circle: this.value != null && String(this.value).length === 1,
        empty: this.value == null && !this.$slots["default"]
      }, this.severity, this.severity), this.size, this.size));
    }
  }
};
var _hoisted_1$m = ["data-p"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root"),
    "data-p": $options.dataP
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString(_ctx.value), 1)];
  })], 16, _hoisted_1$m);
}
script$h.render = render$g;
var style$5 = "\n    .p-ink {\n        display: block;\n        position: absolute;\n        background: dt('ripple.background');\n        border-radius: 100%;\n        transform: scale(0);\n        pointer-events: none;\n    }\n\n    .p-ink-active {\n        animation: ripple 0.4s linear;\n    }\n\n    @keyframes ripple {\n        100% {\n            opacity: 0;\n            transform: scale(2.5);\n        }\n    }\n";
var classes$5 = {
  root: "p-ink"
};
var RippleStyle = BaseStyle.extend({
  name: "ripple-directive",
  style: style$5,
  classes: classes$5
});
var BaseRipple = BaseDirective.extend({
  style: RippleStyle
});
function _typeof$7(o2) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$7(o2);
}
function _toConsumableArray$9(r2) {
  return _arrayWithoutHoles$9(r2) || _iterableToArray$9(r2) || _unsupportedIterableToArray$9(r2) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$9(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$9(r2, a2) : void 0;
  }
}
function _iterableToArray$9(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$9(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$9(r2);
}
function _arrayLikeToArray$9(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _defineProperty$7(e2, r2, t2) {
  return (r2 = _toPropertyKey$7(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$7(t2) {
  var i2 = _toPrimitive$7(t2, "string");
  return "symbol" == _typeof$7(i2) ? i2 : i2 + "";
}
function _toPrimitive$7(t2, r2) {
  if ("object" != _typeof$7(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var Ripple = BaseRipple.extend("ripple", {
  watch: {
    "config.ripple": function configRipple(newValue) {
      if (newValue) {
        this.createRipple(this.$host);
        this.bindEvents(this.$host);
        this.$host.setAttribute("data-pd-ripple", true);
        this.$host.style["overflow"] = "hidden";
        this.$host.style["position"] = "relative";
      } else {
        this.remove(this.$host);
        this.$host.removeAttribute("data-pd-ripple");
      }
    }
  },
  unmounted: function unmounted3(el) {
    this.remove(el);
  },
  timeout: void 0,
  methods: {
    bindEvents: function bindEvents2(el) {
      el.addEventListener("mousedown", this.onMouseDown.bind(this));
    },
    unbindEvents: function unbindEvents2(el) {
      el.removeEventListener("mousedown", this.onMouseDown.bind(this));
    },
    createRipple: function createRipple(el) {
      var ink = this.getInk(el);
      if (!ink) {
        ink = U$2("span", _defineProperty$7(_defineProperty$7({
          role: "presentation",
          "aria-hidden": true,
          "data-p-ink": true,
          "data-p-ink-active": false,
          "class": !this.isUnstyled() && this.cx("root"),
          onAnimationEnd: this.onAnimationEnd.bind(this)
        }, this.$attrSelector, ""), "p-bind", this.ptm("root")));
        el.appendChild(ink);
        this.$el = ink;
      }
    },
    remove: function remove3(el) {
      var ink = this.getInk(el);
      if (ink) {
        this.$host.style["overflow"] = "";
        this.$host.style["position"] = "";
        this.unbindEvents(el);
        ink.removeEventListener("animationend", this.onAnimationEnd);
        ink.remove();
      }
    },
    onMouseDown: function onMouseDown(event) {
      var _this = this;
      var target = event.currentTarget;
      var ink = this.getInk(target);
      if (!ink || getComputedStyle(ink, null).display === "none") {
        return;
      }
      !this.isUnstyled() && P$2(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "false");
      if (!Tt$1(ink) && !Rt$1(ink)) {
        var d2 = Math.max(v$5(target), C$4(target));
        ink.style.height = d2 + "px";
        ink.style.width = d2 + "px";
      }
      var offset = K$2(target);
      var x2 = event.pageX - offset.left + document.body.scrollTop - Rt$1(ink) / 2;
      var y2 = event.pageY - offset.top + document.body.scrollLeft - Tt$1(ink) / 2;
      ink.style.top = y2 + "px";
      ink.style.left = x2 + "px";
      !this.isUnstyled() && W$2(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "true");
      this.timeout = setTimeout(function() {
        if (ink) {
          !_this.isUnstyled() && P$2(ink, "p-ink-active");
          ink.setAttribute("data-p-ink-active", "false");
        }
      }, 401);
    },
    onAnimationEnd: function onAnimationEnd(event) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      !this.isUnstyled() && P$2(event.currentTarget, "p-ink-active");
      event.currentTarget.setAttribute("data-p-ink-active", "false");
    },
    getInk: function getInk(el) {
      return el && el.children ? _toConsumableArray$9(el.children).find(function(child) {
        return Q$3(child, "data-pc-name") === "ripple";
      }) : void 0;
    }
  }
});
var style$4 = `
    .p-button {
        display: inline-flex;
        cursor: pointer;
        user-select: none;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        color: dt('button.primary.color');
        background: dt('button.primary.background');
        border: 1px solid dt('button.primary.border.color');
        padding: dt('button.padding.y') dt('button.padding.x');
        font-size: 1rem;
        font-family: inherit;
        font-feature-settings: inherit;
        transition:
            background dt('button.transition.duration'),
            color dt('button.transition.duration'),
            border-color dt('button.transition.duration'),
            outline-color dt('button.transition.duration'),
            box-shadow dt('button.transition.duration');
        border-radius: dt('button.border.radius');
        outline-color: transparent;
        gap: dt('button.gap');
    }

    .p-button:disabled {
        cursor: default;
    }

    .p-button-icon-right {
        order: 1;
    }

    .p-button-icon-right:dir(rtl) {
        order: -1;
    }

    .p-button:not(.p-button-vertical) .p-button-icon:not(.p-button-icon-right):dir(rtl) {
        order: 1;
    }

    .p-button-icon-bottom {
        order: 2;
    }

    .p-button-icon-only {
        width: dt('button.icon.only.width');
        padding-inline-start: 0;
        padding-inline-end: 0;
        gap: 0;
    }

    .p-button-icon-only.p-button-rounded {
        border-radius: 50%;
        height: dt('button.icon.only.width');
    }

    .p-button-icon-only .p-button-label {
        visibility: hidden;
        width: 0;
    }

    .p-button-icon-only::after {
        content: "";
        visibility: hidden;
        width: 0;
    }

    .p-button-sm {
        font-size: dt('button.sm.font.size');
        padding: dt('button.sm.padding.y') dt('button.sm.padding.x');
    }

    .p-button-sm .p-button-icon {
        font-size: dt('button.sm.font.size');
    }

    .p-button-sm.p-button-icon-only {
        width: dt('button.sm.icon.only.width');
    }

    .p-button-sm.p-button-icon-only.p-button-rounded {
        height: dt('button.sm.icon.only.width');
    }

    .p-button-lg {
        font-size: dt('button.lg.font.size');
        padding: dt('button.lg.padding.y') dt('button.lg.padding.x');
    }

    .p-button-lg .p-button-icon {
        font-size: dt('button.lg.font.size');
    }

    .p-button-lg.p-button-icon-only {
        width: dt('button.lg.icon.only.width');
    }

    .p-button-lg.p-button-icon-only.p-button-rounded {
        height: dt('button.lg.icon.only.width');
    }

    .p-button-vertical {
        flex-direction: column;
    }

    .p-button-label {
        font-weight: dt('button.label.font.weight');
    }

    .p-button-fluid {
        width: 100%;
    }

    .p-button-fluid.p-button-icon-only {
        width: dt('button.icon.only.width');
    }

    .p-button:not(:disabled):hover {
        background: dt('button.primary.hover.background');
        border: 1px solid dt('button.primary.hover.border.color');
        color: dt('button.primary.hover.color');
    }

    .p-button:not(:disabled):active {
        background: dt('button.primary.active.background');
        border: 1px solid dt('button.primary.active.border.color');
        color: dt('button.primary.active.color');
    }

    .p-button:focus-visible {
        box-shadow: dt('button.primary.focus.ring.shadow');
        outline: dt('button.focus.ring.width') dt('button.focus.ring.style') dt('button.primary.focus.ring.color');
        outline-offset: dt('button.focus.ring.offset');
    }

    .p-button .p-badge {
        min-width: dt('button.badge.size');
        height: dt('button.badge.size');
        line-height: dt('button.badge.size');
    }

    .p-button-raised {
        box-shadow: dt('button.raised.shadow');
    }

    .p-button-rounded {
        border-radius: dt('button.rounded.border.radius');
    }

    .p-button-secondary {
        background: dt('button.secondary.background');
        border: 1px solid dt('button.secondary.border.color');
        color: dt('button.secondary.color');
    }

    .p-button-secondary:not(:disabled):hover {
        background: dt('button.secondary.hover.background');
        border: 1px solid dt('button.secondary.hover.border.color');
        color: dt('button.secondary.hover.color');
    }

    .p-button-secondary:not(:disabled):active {
        background: dt('button.secondary.active.background');
        border: 1px solid dt('button.secondary.active.border.color');
        color: dt('button.secondary.active.color');
    }

    .p-button-secondary:focus-visible {
        outline-color: dt('button.secondary.focus.ring.color');
        box-shadow: dt('button.secondary.focus.ring.shadow');
    }

    .p-button-success {
        background: dt('button.success.background');
        border: 1px solid dt('button.success.border.color');
        color: dt('button.success.color');
    }

    .p-button-success:not(:disabled):hover {
        background: dt('button.success.hover.background');
        border: 1px solid dt('button.success.hover.border.color');
        color: dt('button.success.hover.color');
    }

    .p-button-success:not(:disabled):active {
        background: dt('button.success.active.background');
        border: 1px solid dt('button.success.active.border.color');
        color: dt('button.success.active.color');
    }

    .p-button-success:focus-visible {
        outline-color: dt('button.success.focus.ring.color');
        box-shadow: dt('button.success.focus.ring.shadow');
    }

    .p-button-info {
        background: dt('button.info.background');
        border: 1px solid dt('button.info.border.color');
        color: dt('button.info.color');
    }

    .p-button-info:not(:disabled):hover {
        background: dt('button.info.hover.background');
        border: 1px solid dt('button.info.hover.border.color');
        color: dt('button.info.hover.color');
    }

    .p-button-info:not(:disabled):active {
        background: dt('button.info.active.background');
        border: 1px solid dt('button.info.active.border.color');
        color: dt('button.info.active.color');
    }

    .p-button-info:focus-visible {
        outline-color: dt('button.info.focus.ring.color');
        box-shadow: dt('button.info.focus.ring.shadow');
    }

    .p-button-warn {
        background: dt('button.warn.background');
        border: 1px solid dt('button.warn.border.color');
        color: dt('button.warn.color');
    }

    .p-button-warn:not(:disabled):hover {
        background: dt('button.warn.hover.background');
        border: 1px solid dt('button.warn.hover.border.color');
        color: dt('button.warn.hover.color');
    }

    .p-button-warn:not(:disabled):active {
        background: dt('button.warn.active.background');
        border: 1px solid dt('button.warn.active.border.color');
        color: dt('button.warn.active.color');
    }

    .p-button-warn:focus-visible {
        outline-color: dt('button.warn.focus.ring.color');
        box-shadow: dt('button.warn.focus.ring.shadow');
    }

    .p-button-help {
        background: dt('button.help.background');
        border: 1px solid dt('button.help.border.color');
        color: dt('button.help.color');
    }

    .p-button-help:not(:disabled):hover {
        background: dt('button.help.hover.background');
        border: 1px solid dt('button.help.hover.border.color');
        color: dt('button.help.hover.color');
    }

    .p-button-help:not(:disabled):active {
        background: dt('button.help.active.background');
        border: 1px solid dt('button.help.active.border.color');
        color: dt('button.help.active.color');
    }

    .p-button-help:focus-visible {
        outline-color: dt('button.help.focus.ring.color');
        box-shadow: dt('button.help.focus.ring.shadow');
    }

    .p-button-danger {
        background: dt('button.danger.background');
        border: 1px solid dt('button.danger.border.color');
        color: dt('button.danger.color');
    }

    .p-button-danger:not(:disabled):hover {
        background: dt('button.danger.hover.background');
        border: 1px solid dt('button.danger.hover.border.color');
        color: dt('button.danger.hover.color');
    }

    .p-button-danger:not(:disabled):active {
        background: dt('button.danger.active.background');
        border: 1px solid dt('button.danger.active.border.color');
        color: dt('button.danger.active.color');
    }

    .p-button-danger:focus-visible {
        outline-color: dt('button.danger.focus.ring.color');
        box-shadow: dt('button.danger.focus.ring.shadow');
    }

    .p-button-contrast {
        background: dt('button.contrast.background');
        border: 1px solid dt('button.contrast.border.color');
        color: dt('button.contrast.color');
    }

    .p-button-contrast:not(:disabled):hover {
        background: dt('button.contrast.hover.background');
        border: 1px solid dt('button.contrast.hover.border.color');
        color: dt('button.contrast.hover.color');
    }

    .p-button-contrast:not(:disabled):active {
        background: dt('button.contrast.active.background');
        border: 1px solid dt('button.contrast.active.border.color');
        color: dt('button.contrast.active.color');
    }

    .p-button-contrast:focus-visible {
        outline-color: dt('button.contrast.focus.ring.color');
        box-shadow: dt('button.contrast.focus.ring.shadow');
    }

    .p-button-outlined {
        background: transparent;
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):hover {
        background: dt('button.outlined.primary.hover.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):active {
        background: dt('button.outlined.primary.active.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined.p-button-secondary {
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):hover {
        background: dt('button.outlined.secondary.hover.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):active {
        background: dt('button.outlined.secondary.active.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-success {
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):hover {
        background: dt('button.outlined.success.hover.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):active {
        background: dt('button.outlined.success.active.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-info {
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):hover {
        background: dt('button.outlined.info.hover.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):active {
        background: dt('button.outlined.info.active.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-warn {
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):hover {
        background: dt('button.outlined.warn.hover.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):active {
        background: dt('button.outlined.warn.active.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-help {
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):hover {
        background: dt('button.outlined.help.hover.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):active {
        background: dt('button.outlined.help.active.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-danger {
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):hover {
        background: dt('button.outlined.danger.hover.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):active {
        background: dt('button.outlined.danger.active.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-contrast {
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):hover {
        background: dt('button.outlined.contrast.hover.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):active {
        background: dt('button.outlined.contrast.active.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-plain {
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):hover {
        background: dt('button.outlined.plain.hover.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):active {
        background: dt('button.outlined.plain.active.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-text {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):hover {
        background: dt('button.text.primary.hover.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):active {
        background: dt('button.text.primary.active.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text.p-button-secondary {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):hover {
        background: dt('button.text.secondary.hover.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):active {
        background: dt('button.text.secondary.active.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-success {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):hover {
        background: dt('button.text.success.hover.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):active {
        background: dt('button.text.success.active.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-info {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):hover {
        background: dt('button.text.info.hover.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):active {
        background: dt('button.text.info.active.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-warn {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):hover {
        background: dt('button.text.warn.hover.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):active {
        background: dt('button.text.warn.active.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-help {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):hover {
        background: dt('button.text.help.hover.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):active {
        background: dt('button.text.help.active.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-danger {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):hover {
        background: dt('button.text.danger.hover.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):active {
        background: dt('button.text.danger.active.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-contrast {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):hover {
        background: dt('button.text.contrast.hover.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):active {
        background: dt('button.text.contrast.active.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-plain {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):hover {
        background: dt('button.text.plain.hover.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):active {
        background: dt('button.text.plain.active.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-link {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.color');
    }

    .p-button-link:not(:disabled):hover {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.hover.color');
    }

    .p-button-link:not(:disabled):hover .p-button-label {
        text-decoration: underline;
    }

    .p-button-link:not(:disabled):active {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.active.color');
    }
`;
function _typeof$6(o2) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$6(o2);
}
function _defineProperty$6(e2, r2, t2) {
  return (r2 = _toPropertyKey$6(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$6(t2) {
  var i2 = _toPrimitive$6(t2, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
function _toPrimitive$6(t2, r2) {
  if ("object" != _typeof$6(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var classes$4 = {
  root: function root2(_ref2) {
    var instance2 = _ref2.instance, props = _ref2.props;
    return ["p-button p-component", _defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6(_defineProperty$6({
      "p-button-icon-only": instance2.hasIcon && !props.label && !props.badge,
      "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
      "p-button-loading": props.loading,
      "p-button-link": props.link || props.variant === "link"
    }, "p-button-".concat(props.severity), props.severity), "p-button-raised", props.raised), "p-button-rounded", props.rounded), "p-button-text", props.text || props.variant === "text"), "p-button-outlined", props.outlined || props.variant === "outlined"), "p-button-sm", props.size === "small"), "p-button-lg", props.size === "large"), "p-button-plain", props.plain), "p-button-fluid", instance2.hasFluid)];
  },
  loadingIcon: "p-button-loading-icon",
  icon: function icon3(_ref3) {
    var props = _ref3.props;
    return ["p-button-icon", _defineProperty$6({}, "p-button-icon-".concat(props.iconPos), props.label)];
  },
  label: "p-button-label"
};
var ButtonStyle = BaseStyle.extend({
  name: "button",
  style: style$4,
  classes: classes$4
});
var script$1$4 = {
  name: "BaseButton",
  "extends": script$k,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    iconClass: {
      type: [String, Object],
      "default": null
    },
    badge: {
      type: String,
      "default": null
    },
    badgeClass: {
      type: [String, Object],
      "default": null
    },
    badgeSeverity: {
      type: String,
      "default": "secondary"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    as: {
      type: [String, Object],
      "default": "BUTTON"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    link: {
      type: Boolean,
      "default": false
    },
    severity: {
      type: String,
      "default": null
    },
    raised: {
      type: Boolean,
      "default": false
    },
    rounded: {
      type: Boolean,
      "default": false
    },
    text: {
      type: Boolean,
      "default": false
    },
    outlined: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    plain: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": null
    }
  },
  style: ButtonStyle,
  provide: function provide4() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }
};
function _typeof$5(o2) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$5(o2);
}
function _defineProperty$5(e2, r2, t2) {
  return (r2 = _toPropertyKey$5(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$5(t2) {
  var i2 = _toPrimitive$5(t2, "string");
  return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
}
function _toPrimitive$5(t2, r2) {
  if ("object" != _typeof$5(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var script$g = {
  name: "Button",
  "extends": script$1$4,
  inheritAttrs: false,
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          disabled: this.disabled
        }
      });
    }
  },
  computed: {
    disabled: function disabled2() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    },
    defaultAriaLabel: function defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    },
    hasIcon: function hasIcon() {
      return this.icon || this.$slots.icon;
    },
    attrs: function attrs() {
      return mergeProps(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    },
    asAttrs: function asAttrs() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    },
    a11yAttrs: function a11yAttrs() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    },
    hasFluid: function hasFluid() {
      return l$j(this.fluid) ? !!this.$pcFluid : this.fluid;
    },
    dataP: function dataP2() {
      return f$c(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5(_defineProperty$5({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge), "loading", this.loading), "fluid", this.hasFluid), "rounded", this.rounded), "raised", this.raised), "outlined", this.outlined || this.variant === "outlined"), "text", this.text || this.variant === "text"), "link", this.link || this.variant === "link"), "vertical", (this.iconPos === "top" || this.iconPos === "bottom") && this.label));
    },
    dataIconP: function dataIconP() {
      return f$c(_defineProperty$5(_defineProperty$5({}, this.iconPos, this.iconPos), this.size, this.size));
    },
    dataLabelP: function dataLabelP() {
      return f$c(_defineProperty$5(_defineProperty$5({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge));
    }
  },
  components: {
    SpinnerIcon: script$i,
    Badge: script$h
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$l = ["data-p"];
var _hoisted_2$h = ["data-p"];
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Badge = resolveComponent("Badge");
  var _directive_ripple = resolveDirective("ripple");
  return !_ctx.asChild ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root"),
    "data-p": $options.dataP
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default", {}, function() {
        return [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", mergeProps({
          key: 0,
          "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")]
        }, _ctx.ptm("loadingIcon")), function() {
          return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon"), _ctx.loadingIcon]
          }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
            key: 1,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")],
            spin: ""
          }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : renderSlot(_ctx.$slots, "icon", mergeProps({
          key: 1,
          "class": [_ctx.cx("icon")]
        }, _ctx.ptm("icon")), function() {
          return [_ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("icon"), _ctx.icon, _ctx.iconClass],
            "data-p": $options.dataIconP
          }, _ctx.ptm("icon")), null, 16, _hoisted_1$l)) : createCommentVNode("", true)];
        }), _ctx.label ? (openBlock(), createElementBlock("span", mergeProps({
          key: 2,
          "class": _ctx.cx("label")
        }, _ctx.ptm("label"), {
          "data-p": $options.dataLabelP
        }), toDisplayString(_ctx.label), 17, _hoisted_2$h)) : createCommentVNode("", true), _ctx.badge ? (openBlock(), createBlock(_component_Badge, {
          key: 3,
          value: _ctx.badge,
          "class": normalizeClass(_ctx.badgeClass),
          severity: _ctx.badgeSeverity,
          unstyled: _ctx.unstyled,
          pt: _ctx.ptm("pcBadge")
        }, null, 8, ["value", "class", "severity", "unstyled", "pt"])) : createCommentVNode("", true)];
      })];
    }),
    _: 3
  }, 16, ["class", "data-p"])), [[_directive_ripple]]) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    a11yAttrs: $options.a11yAttrs
  });
}
script$g.render = render$f;
var script$f = {
  name: "EyeIcon",
  "extends": script$j
};
function _toConsumableArray$8(r2) {
  return _arrayWithoutHoles$8(r2) || _iterableToArray$8(r2) || _unsupportedIterableToArray$8(r2) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$8(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$8(r2, a2) : void 0;
  }
}
function _iterableToArray$8(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$8(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$8(r2);
}
function _arrayLikeToArray$8(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$8(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M0.0535499 7.25213C0.208567 7.59162 2.40413 12.4 7 12.4C11.5959 12.4 13.7914 7.59162 13.9465 7.25213C13.9487 7.2471 13.9506 7.24304 13.952 7.24001C13.9837 7.16396 14 7.08239 14 7.00001C14 6.91762 13.9837 6.83605 13.952 6.76001C13.9506 6.75697 13.9487 6.75292 13.9465 6.74788C13.7914 6.4084 11.5959 1.60001 7 1.60001C2.40413 1.60001 0.208567 6.40839 0.0535499 6.74788C0.0512519 6.75292 0.0494023 6.75697 0.048 6.76001C0.0163137 6.83605 0 6.91762 0 7.00001C0 7.08239 0.0163137 7.16396 0.048 7.24001C0.0494023 7.24304 0.0512519 7.2471 0.0535499 7.25213ZM7 11.2C3.664 11.2 1.736 7.92001 1.264 7.00001C1.736 6.08001 3.664 2.80001 7 2.80001C10.336 2.80001 12.264 6.08001 12.736 7.00001C12.264 7.92001 10.336 11.2 7 11.2ZM5.55551 9.16182C5.98308 9.44751 6.48576 9.6 7 9.6C7.68891 9.59789 8.349 9.32328 8.83614 8.83614C9.32328 8.349 9.59789 7.68891 9.59999 7C9.59999 6.48576 9.44751 5.98308 9.16182 5.55551C8.87612 5.12794 8.47006 4.7947 7.99497 4.59791C7.51988 4.40112 6.99711 4.34963 6.49276 4.44995C5.98841 4.55027 5.52513 4.7979 5.16152 5.16152C4.7979 5.52513 4.55027 5.98841 4.44995 6.49276C4.34963 6.99711 4.40112 7.51988 4.59791 7.99497C4.7947 8.47006 5.12794 8.87612 5.55551 9.16182ZM6.2222 5.83594C6.45243 5.6821 6.7231 5.6 7 5.6C7.37065 5.6021 7.72553 5.75027 7.98762 6.01237C8.24972 6.27446 8.39789 6.62934 8.4 7C8.4 7.27689 8.31789 7.54756 8.16405 7.77779C8.01022 8.00802 7.79157 8.18746 7.53575 8.29343C7.27994 8.39939 6.99844 8.42711 6.72687 8.37309C6.4553 8.31908 6.20584 8.18574 6.01005 7.98994C5.81425 7.79415 5.68091 7.54469 5.6269 7.27312C5.57288 7.00155 5.6006 6.72006 5.70656 6.46424C5.81253 6.20842 5.99197 5.98977 6.2222 5.83594Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$f.render = render$e;
var script$e = {
  name: "RefreshIcon",
  "extends": script$j
};
function _toConsumableArray$7(r2) {
  return _arrayWithoutHoles$7(r2) || _iterableToArray$7(r2) || _unsupportedIterableToArray$7(r2) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$7(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$7(r2, a2) : void 0;
  }
}
function _iterableToArray$7(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$7(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$7(r2);
}
function _arrayLikeToArray$7(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$7(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M6.77051 5.96336C6.84324 5.99355 6.92127 6.00891 7.00002 6.00854C7.07877 6.00891 7.1568 5.99355 7.22953 5.96336C7.30226 5.93317 7.36823 5.88876 7.42357 5.83273L9.82101 3.43529C9.93325 3.32291 9.99629 3.17058 9.99629 3.01175C9.99629 2.85292 9.93325 2.70058 9.82101 2.5882L7.42357 0.190763C7.3687 0.131876 7.30253 0.0846451 7.22901 0.0518865C7.15549 0.019128 7.07612 0.00151319 6.99564 9.32772e-05C6.91517 -0.00132663 6.83523 0.0134773 6.7606 0.0436218C6.68597 0.0737664 6.61817 0.118634 6.56126 0.175548C6.50435 0.232462 6.45948 0.300257 6.42933 0.374888C6.39919 0.449519 6.38439 0.529456 6.38581 0.609933C6.38722 0.690409 6.40484 0.769775 6.4376 0.843296C6.47036 0.916817 6.51759 0.982986 6.57647 1.03786L7.95103 2.41241H6.99998C5.46337 2.41241 3.98969 3.02283 2.90314 4.10938C1.81659 5.19593 1.20618 6.66961 1.20618 8.20622C1.20618 9.74283 1.81659 11.2165 2.90314 12.3031C3.98969 13.3896 5.46337 14 6.99998 14C8.53595 13.9979 10.0084 13.3868 11.0945 12.3007C12.1806 11.2146 12.7917 9.74218 12.7938 8.20622C12.7938 8.04726 12.7306 7.89481 12.6182 7.78241C12.5058 7.67001 12.3534 7.60686 12.1944 7.60686C12.0355 7.60686 11.883 7.67001 11.7706 7.78241C11.6582 7.89481 11.5951 8.04726 11.5951 8.20622C11.5951 9.11504 11.3256 10.0035 10.8207 10.7591C10.3157 11.5148 9.59809 12.1037 8.75845 12.4515C7.9188 12.7993 6.99489 12.8903 6.10353 12.713C5.21217 12.5357 4.3934 12.0981 3.75077 11.4554C3.10813 10.8128 2.67049 9.99404 2.49319 9.10268C2.31589 8.21132 2.40688 7.2874 2.75468 6.44776C3.10247 5.60811 3.69143 4.89046 4.44709 4.38554C5.20275 3.88063 6.09116 3.61113 6.99998 3.61113H7.95098L6.57647 4.98564C6.46423 5.09802 6.40119 5.25035 6.40119 5.40918C6.40119 5.56801 6.46423 5.72035 6.57647 5.83273C6.63181 5.88876 6.69778 5.93317 6.77051 5.96336Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$e.render = render$d;
var script$d = {
  name: "SearchMinusIcon",
  "extends": script$j
};
function _toConsumableArray$6(r2) {
  return _arrayWithoutHoles$6(r2) || _iterableToArray$6(r2) || _unsupportedIterableToArray$6(r2) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$6(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$6(r2, a2) : void 0;
  }
}
function _iterableToArray$6(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$6(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$6(r2);
}
function _arrayLikeToArray$6(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$6(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M6.0208 12.0411C4.83005 12.0411 3.66604 11.688 2.67596 11.0265C1.68589 10.3649 0.914216 9.42464 0.458534 8.32452C0.00285271 7.22441 -0.116374 6.01388 0.11593 4.84601C0.348235 3.67813 0.921637 2.60537 1.76363 1.76338C2.60562 0.921393 3.67838 0.34799 4.84625 0.115686C6.01412 -0.116618 7.22466 0.00260857 8.32477 0.45829C9.42488 0.913972 10.3652 1.68564 11.0267 2.67572C11.6883 3.66579 12.0414 4.8298 12.0414 6.02056C12.0395 7.41563 11.5542 8.76029 10.6783 9.8305L13.8244 12.9765C13.9367 13.089 13.9997 13.2414 13.9997 13.4003C13.9997 13.5592 13.9367 13.7116 13.8244 13.8241C13.769 13.8801 13.703 13.9245 13.6302 13.9548C13.5575 13.985 13.4794 14.0003 13.4006 14C13.3218 14.0003 13.2437 13.985 13.171 13.9548C13.0982 13.9245 13.0322 13.8801 12.9768 13.8241L9.83082 10.678C8.76059 11.5539 7.4159 12.0393 6.0208 12.0411ZM6.0208 1.20731C5.07199 1.20731 4.14449 1.48867 3.35559 2.0158C2.56669 2.54292 1.95181 3.29215 1.58872 4.16874C1.22562 5.04532 1.13062 6.00989 1.31572 6.94046C1.50083 7.87104 1.95772 8.72583 2.62863 9.39674C3.29954 10.0676 4.15433 10.5245 5.0849 10.7096C6.01548 10.8947 6.98005 10.7997 7.85663 10.4367C8.73322 10.0736 9.48244 9.45868 10.0096 8.66978C10.5367 7.88088 10.8181 6.95337 10.8181 6.00457C10.8181 4.73226 10.3126 3.51206 9.41297 2.6124C8.51331 1.71274 7.29311 1.20731 6.0208 1.20731ZM4.00591 6.60422H8.00362C8.16266 6.60422 8.31518 6.54104 8.42764 6.42859C8.5401 6.31613 8.60328 6.1636 8.60328 6.00456C8.60328 5.84553 8.5401 5.693 8.42764 5.58054C8.31518 5.46809 8.16266 5.40491 8.00362 5.40491H4.00591C3.84687 5.40491 3.69434 5.46809 3.58189 5.58054C3.46943 5.693 3.40625 5.84553 3.40625 6.00456C3.40625 6.1636 3.46943 6.31613 3.58189 6.42859C3.69434 6.54104 3.84687 6.60422 4.00591 6.60422Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$d.render = render$c;
var script$c = {
  name: "SearchPlusIcon",
  "extends": script$j
};
function _toConsumableArray$5(r2) {
  return _arrayWithoutHoles$5(r2) || _iterableToArray$5(r2) || _unsupportedIterableToArray$5(r2) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$5(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$5(r2, a2) : void 0;
  }
}
function _iterableToArray$5(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$5(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$5(r2);
}
function _arrayLikeToArray$5(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$5(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M2.67596 11.0265C3.66604 11.688 4.83005 12.0411 6.0208 12.0411C6.81143 12.0411 7.59432 11.8854 8.32477 11.5828C8.86999 11.357 9.37802 11.0526 9.83311 10.6803L12.9768 13.8241C13.0322 13.8801 13.0982 13.9245 13.171 13.9548C13.2437 13.985 13.3218 14.0003 13.4006 14C13.4794 14.0003 13.5575 13.985 13.6302 13.9548C13.703 13.9245 13.769 13.8801 13.8244 13.8241C13.9367 13.7116 13.9997 13.5592 13.9997 13.4003C13.9997 13.2414 13.9367 13.089 13.8244 12.9765L10.6806 9.8328C11.0529 9.37773 11.3572 8.86972 11.5831 8.32452C11.8856 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0267 2.67572C10.3652 1.68564 9.42488 0.913972 8.32477 0.45829C7.22466 0.00260857 6.01412 -0.116618 4.84625 0.115686C3.67838 0.34799 2.60562 0.921393 1.76363 1.76338C0.921637 2.60537 0.348235 3.67813 0.11593 4.84601C-0.116374 6.01388 0.00285271 7.22441 0.458534 8.32452C0.914216 9.42464 1.68589 10.3649 2.67596 11.0265ZM3.35559 2.0158C4.14449 1.48867 5.07199 1.20731 6.0208 1.20731C7.29311 1.20731 8.51331 1.71274 9.41297 2.6124C10.3126 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5367 7.88088 10.0096 8.66978C9.48244 9.45868 8.73322 10.0736 7.85663 10.4367C6.98005 10.7997 6.01548 10.8947 5.0849 10.7096C4.15433 10.5245 3.29954 10.0676 2.62863 9.39674C1.95772 8.72583 1.50083 7.87104 1.31572 6.94046C1.13062 6.00989 1.22562 5.04532 1.58872 4.16874C1.95181 3.29215 2.56669 2.54292 3.35559 2.0158ZM6.00481 8.60309C5.84641 8.60102 5.69509 8.53718 5.58308 8.42517C5.47107 8.31316 5.40722 8.16183 5.40515 8.00344V6.60422H4.00591C3.84687 6.60422 3.69434 6.54104 3.58189 6.42859C3.46943 6.31613 3.40625 6.1636 3.40625 6.00456C3.40625 5.84553 3.46943 5.693 3.58189 5.58054C3.69434 5.46809 3.84687 5.40491 4.00591 5.40491H5.40515V4.00572C5.40515 3.84668 5.46833 3.69416 5.58079 3.5817C5.69324 3.46924 5.84577 3.40607 6.00481 3.40607C6.16385 3.40607 6.31637 3.46924 6.42883 3.5817C6.54129 3.69416 6.60447 3.84668 6.60447 4.00572V5.40491H8.00362C8.16266 5.40491 8.31518 5.46809 8.42764 5.58054C8.5401 5.693 8.60328 5.84553 8.60328 6.00456C8.60328 6.1636 8.5401 6.31613 8.42764 6.42859C8.31518 6.54104 8.16266 6.60422 8.00362 6.60422H6.60447V8.00344C6.60239 8.16183 6.53855 8.31316 6.42654 8.42517C6.31453 8.53718 6.1632 8.60102 6.00481 8.60309Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$c.render = render$b;
var script$b = {
  name: "TimesIcon",
  "extends": script$j
};
function _toConsumableArray$4(r2) {
  return _arrayWithoutHoles$4(r2) || _iterableToArray$4(r2) || _unsupportedIterableToArray$4(r2) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$4(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$4(r2, a2) : void 0;
  }
}
function _iterableToArray$4(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$4(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$4(r2);
}
function _arrayLikeToArray$4(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$4(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$b.render = render$a;
var script$a = {
  name: "UndoIcon",
  "extends": script$j
};
function _toConsumableArray$3(r2) {
  return _arrayWithoutHoles$3(r2) || _iterableToArray$3(r2) || _unsupportedIterableToArray$3(r2) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$3(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$3(r2, a2) : void 0;
  }
}
function _iterableToArray$3(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$3(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$3(r2);
}
function _arrayLikeToArray$3(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$3(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M6.77042 5.96336C6.84315 5.99355 6.92118 6.00891 6.99993 6.00854C7.07868 6.00891 7.15671 5.99355 7.22944 5.96336C7.30217 5.93317 7.36814 5.88876 7.42348 5.83273C7.53572 5.72035 7.59876 5.56801 7.59876 5.40918C7.59876 5.25035 7.53572 5.09802 7.42348 4.98564L6.04897 3.61113H6.99998C7.9088 3.61113 8.79722 3.88063 9.55288 4.38554C10.3085 4.89046 10.8975 5.60811 11.2453 6.44776C11.5931 7.2874 11.6841 8.21132 11.5068 9.10268C11.3295 9.99404 10.8918 10.8128 10.2492 11.4554C9.60657 12.0981 8.7878 12.5357 7.89644 12.713C7.00508 12.8903 6.08116 12.7993 5.24152 12.4515C4.40188 12.1037 3.68422 11.5148 3.17931 10.7591C2.67439 10.0035 2.4049 9.11504 2.4049 8.20622C2.4049 8.04726 2.34175 7.89481 2.22935 7.78241C2.11695 7.67001 1.9645 7.60686 1.80554 7.60686C1.64658 7.60686 1.49413 7.67001 1.38172 7.78241C1.26932 7.89481 1.20618 8.04726 1.20618 8.20622C1.20829 9.74218 1.81939 11.2146 2.90548 12.3007C3.99157 13.3868 5.46402 13.9979 6.99998 14C8.5366 14 10.0103 13.3896 11.0968 12.3031C12.1834 11.2165 12.7938 9.74283 12.7938 8.20622C12.7938 6.66961 12.1834 5.19593 11.0968 4.10938C10.0103 3.02283 8.5366 2.41241 6.99998 2.41241H6.04892L7.42348 1.03786C7.48236 0.982986 7.5296 0.916817 7.56235 0.843296C7.59511 0.769775 7.61273 0.690409 7.61415 0.609933C7.61557 0.529456 7.60076 0.449519 7.57062 0.374888C7.54047 0.300257 7.49561 0.232462 7.43869 0.175548C7.38178 0.118634 7.31398 0.0737664 7.23935 0.0436218C7.16472 0.0134773 7.08478 -0.00132663 7.00431 9.32772e-05C6.92383 0.00151319 6.84447 0.019128 6.77095 0.0518865C6.69742 0.0846451 6.63126 0.131876 6.57638 0.190763L4.17895 2.5882C4.06671 2.70058 4.00366 2.85292 4.00366 3.01175C4.00366 3.17058 4.06671 3.32291 4.17895 3.43529L6.57638 5.83273C6.63172 5.88876 6.69769 5.93317 6.77042 5.96336Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$a.render = render$9;
var FocusTrapStyle = BaseStyle.extend({
  name: "focustrap-directive"
});
var BaseFocusTrap = BaseDirective.extend({
  style: FocusTrapStyle
});
function _typeof$4(o2) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$4(o2);
}
function ownKeys$3(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$3(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$4(e2, r2, t2) {
  return (r2 = _toPropertyKey$4(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$4(t2) {
  var i2 = _toPrimitive$4(t2, "string");
  return "symbol" == _typeof$4(i2) ? i2 : i2 + "";
}
function _toPrimitive$4(t2, r2) {
  if ("object" != _typeof$4(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var FocusTrap = BaseFocusTrap.extend("focustrap", {
  mounted: function mounted2(el, binding) {
    var _ref2 = binding.value || {}, disabled3 = _ref2.disabled;
    if (!disabled3) {
      this.createHiddenFocusableElements(el, binding);
      this.bind(el, binding);
      this.autoElementFocus(el, binding);
    }
    el.setAttribute("data-pd-focustrap", true);
    this.$el = el;
  },
  updated: function updated3(el, binding) {
    var _ref2 = binding.value || {}, disabled3 = _ref2.disabled;
    disabled3 && this.unbind(el);
  },
  unmounted: function unmounted4(el) {
    this.unbind(el);
  },
  methods: {
    getComputedSelector: function getComputedSelector(selector) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(selector !== null && selector !== void 0 ? selector : "");
    },
    bind: function bind(el, binding) {
      var _this = this;
      var _ref3 = binding.value || {}, onFocusIn = _ref3.onFocusIn, onFocusOut = _ref3.onFocusOut;
      el.$_pfocustrap_mutationobserver = new MutationObserver(function(mutationList) {
        mutationList.forEach(function(mutation) {
          if (mutation.type === "childList" && !el.contains(document.activeElement)) {
            var _findNextFocusableElement = function findNextFocusableElement(_el) {
              var focusableElement = It$1(_el) ? It$1(_el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) ? _el : vt$1(el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) : vt$1(_el);
              return s$e(focusableElement) ? focusableElement : _el.nextSibling && _findNextFocusableElement(_el.nextSibling);
            };
            bt$1(_findNextFocusableElement(mutation.nextSibling));
          }
        });
      });
      el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_mutationobserver.observe(el, {
        childList: true
      });
      el.$_pfocustrap_focusinlistener = function(event) {
        return onFocusIn && onFocusIn(event);
      };
      el.$_pfocustrap_focusoutlistener = function(event) {
        return onFocusOut && onFocusOut(event);
      };
      el.addEventListener("focusin", el.$_pfocustrap_focusinlistener);
      el.addEventListener("focusout", el.$_pfocustrap_focusoutlistener);
    },
    unbind: function unbind(el) {
      el.$_pfocustrap_mutationobserver && el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_focusinlistener && el.removeEventListener("focusin", el.$_pfocustrap_focusinlistener) && (el.$_pfocustrap_focusinlistener = null);
      el.$_pfocustrap_focusoutlistener && el.removeEventListener("focusout", el.$_pfocustrap_focusoutlistener) && (el.$_pfocustrap_focusoutlistener = null);
    },
    autoFocus: function autoFocus(options) {
      this.autoElementFocus(this.$el, {
        value: _objectSpread$3(_objectSpread$3({}, options), {}, {
          autoFocus: true
        })
      });
    },
    autoElementFocus: function autoElementFocus(el, binding) {
      var _ref4 = binding.value || {}, _ref4$autoFocusSelect = _ref4.autoFocusSelector, autoFocusSelector = _ref4$autoFocusSelect === void 0 ? "" : _ref4$autoFocusSelect, _ref4$firstFocusableS = _ref4.firstFocusableSelector, firstFocusableSelector = _ref4$firstFocusableS === void 0 ? "" : _ref4$firstFocusableS, _ref4$autoFocus = _ref4.autoFocus, autoFocus2 = _ref4$autoFocus === void 0 ? false : _ref4$autoFocus;
      var focusableElement = vt$1(el, "[autofocus]".concat(this.getComputedSelector(autoFocusSelector)));
      autoFocus2 && !focusableElement && (focusableElement = vt$1(el, this.getComputedSelector(firstFocusableSelector)));
      bt$1(focusableElement);
    },
    onFirstHiddenElementFocus: function onFirstHiddenElementFocus(event) {
      var _this$$el;
      var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_lasthiddenfocusableelement || !((_this$$el = this.$el) !== null && _this$$el !== void 0 && _this$$el.contains(relatedTarget)) ? vt$1(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_lasthiddenfocusableelement;
      bt$1(focusableElement);
    },
    onLastHiddenElementFocus: function onLastHiddenElementFocus(event) {
      var _this$$el2;
      var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_firsthiddenfocusableelement || !((_this$$el2 = this.$el) !== null && _this$$el2 !== void 0 && _this$$el2.contains(relatedTarget)) ? Lt$1(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_firsthiddenfocusableelement;
      bt$1(focusableElement);
    },
    createHiddenFocusableElements: function createHiddenFocusableElements(el, binding) {
      var _this2 = this;
      var _ref5 = binding.value || {}, _ref5$tabIndex = _ref5.tabIndex, tabIndex = _ref5$tabIndex === void 0 ? 0 : _ref5$tabIndex, _ref5$firstFocusableS = _ref5.firstFocusableSelector, firstFocusableSelector = _ref5$firstFocusableS === void 0 ? "" : _ref5$firstFocusableS, _ref5$lastFocusableSe = _ref5.lastFocusableSelector, lastFocusableSelector = _ref5$lastFocusableSe === void 0 ? "" : _ref5$lastFocusableSe;
      var createFocusableElement = function createFocusableElement2(onFocus3) {
        return U$2("span", {
          "class": "p-hidden-accessible p-hidden-focusable",
          tabIndex,
          role: "presentation",
          "aria-hidden": true,
          "data-p-hidden-accessible": true,
          "data-p-hidden-focusable": true,
          onFocus: onFocus3 === null || onFocus3 === void 0 ? void 0 : onFocus3.bind(_this2)
        });
      };
      var firstFocusableElement = createFocusableElement(this.onFirstHiddenElementFocus);
      var lastFocusableElement = createFocusableElement(this.onLastHiddenElementFocus);
      firstFocusableElement.$_pfocustrap_lasthiddenfocusableelement = lastFocusableElement;
      firstFocusableElement.$_pfocustrap_focusableselector = firstFocusableSelector;
      firstFocusableElement.setAttribute("data-pc-section", "firstfocusableelement");
      lastFocusableElement.$_pfocustrap_firsthiddenfocusableelement = firstFocusableElement;
      lastFocusableElement.$_pfocustrap_focusableselector = lastFocusableSelector;
      lastFocusableElement.setAttribute("data-pc-section", "lastfocusableelement");
      el.prepend(firstFocusableElement);
      el.append(lastFocusableElement);
    }
  }
});
var script$9 = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: function data() {
    return {
      mounted: false
    };
  },
  mounted: function mounted3() {
    this.mounted = tt$1();
  },
  computed: {
    inline: function inline() {
      return this.disabled || this.appendTo === "self";
    }
  }
};
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}
script$9.render = render$8;
function blockBodyScroll() {
  st$2({
    variableName: rr("scrollbar.width").name
  });
}
function unblockBodyScroll() {
  dt$2({
    variableName: rr("scrollbar.width").name
  });
}
var style$3 = "\n    .p-image-mask {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .p-image-preview {\n        position: relative;\n        display: inline-flex;\n        line-height: 0;\n    }\n\n    .p-image-preview-mask {\n        position: absolute;\n        inset-inline-start: 0;\n        inset-block-start: 0;\n        width: 100%;\n        height: 100%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        opacity: 0;\n        border: 0 none;\n        padding: 0;\n        cursor: pointer;\n        background: transparent;\n        color: dt('image.preview.mask.color');\n        transition: background dt('image.transition.duration');\n    }\n\n    .p-image-preview:hover > .p-image-preview-mask,\n    .p-image-preview-mask:focus-visible {\n        opacity: 1;\n        cursor: pointer;\n        background: dt('image.preview.mask.background');\n        outline: 0 none;\n    }\n\n    .p-image-preview-icon {\n        font-size: dt('image.preview.icon.size');\n        width: dt('image.preview.icon.size');\n        height: dt('image.preview.icon.size');\n    }\n\n    .p-image-toolbar {\n        position: absolute;\n        inset-block-start: dt('image.toolbar.position.top');\n        inset-inline-end: dt('image.toolbar.position.right');\n        inset-inline-start: dt('image.toolbar.position.left');\n        inset-block-end: dt('image.toolbar.position.bottom');\n        display: flex;\n        z-index: 1;\n        padding: dt('image.toolbar.padding');\n        background: dt('image.toolbar.background');\n        backdrop-filter: blur(dt('image.toolbar.blur'));\n        border-color: dt('image.toolbar.border.color');\n        border-style: solid;\n        border-width: dt('image.toolbar.border.width');\n        border-radius: dt('image.toolbar.border.radius');\n        gap: dt('image.toolbar.gap');\n    }\n\n    .p-image-action {\n        display: inline-flex;\n        justify-content: center;\n        align-items: center;\n        color: dt('image.action.color');\n        background: transparent;\n        width: dt('image.action.size');\n        height: dt('image.action.size');\n        margin: 0;\n        padding: 0;\n        border: 0 none;\n        cursor: pointer;\n        user-select: none;\n        border-radius: dt('image.action.border.radius');\n        outline-color: transparent;\n        transition:\n            background dt('image.transition.duration'),\n            color dt('image.transition.duration'),\n            outline-color dt('image.transition.duration'),\n            box-shadow dt('image.transition.duration');\n    }\n\n    .p-image-action:hover {\n        color: dt('image.action.hover.color');\n        background: dt('image.action.hover.background');\n    }\n\n    .p-image-action:focus-visible {\n        box-shadow: dt('image.action.focus.ring.shadow');\n        outline: dt('image.action.focus.ring.width') dt('image.action.focus.ring.style') dt('image.action.focus.ring.color');\n        outline-offset: dt('image.action.focus.ring.offset');\n    }\n\n    .p-image-action .p-icon {\n        font-size: dt('image.action.icon.size');\n        width: dt('image.action.icon.size');\n        height: dt('image.action.icon.size');\n    }\n\n    .p-image-action.p-disabled {\n        pointer-events: auto;\n    }\n\n    .p-image-original {\n        max-width: 100vw;\n        max-height: 100vh;\n        transition: transform 300ms;\n    }\n\n    .p-image-original-enter-active {\n        animation: p-animate-image-original-enter 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    .p-image-original-leave-active {\n        animation: p-animate-image-original-leave 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    @keyframes p-animate-image-original-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n\n    @keyframes p-animate-image-original-leave {\n        to {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n";
var classes$3 = {
  root: function root3(_ref2) {
    var props = _ref2.props;
    return ["p-image p-component", {
      "p-image-preview": props.preview
    }];
  },
  previewMask: "p-image-preview-mask",
  previewIcon: "p-image-preview-icon",
  mask: "p-image-mask p-overlay-mask p-overlay-mask-enter-active",
  toolbar: "p-image-toolbar",
  rotateRightButton: "p-image-action p-image-rotate-right-button",
  rotateLeftButton: "p-image-action p-image-rotate-left-button",
  zoomOutButton: function zoomOutButton(_ref2) {
    var instance2 = _ref2.instance;
    return ["p-image-action p-image-zoom-out-button", {
      "p-disabled": instance2.isZoomOutDisabled
    }];
  },
  zoomInButton: function zoomInButton(_ref3) {
    var instance2 = _ref3.instance;
    return ["p-image-action p-image-zoom-in-button", {
      "p-disabled": instance2.isZoomInDisabled
    }];
  },
  closeButton: "p-image-action p-image-close-button",
  original: "p-image-original"
};
var ImageStyle = BaseStyle.extend({
  name: "image",
  style: style$3,
  classes: classes$3
});
var script$1$3 = {
  name: "BaseImage",
  "extends": script$k,
  props: {
    preview: {
      type: Boolean,
      "default": false
    },
    "class": {
      type: null,
      "default": null
    },
    style: {
      type: null,
      "default": null
    },
    imageStyle: {
      type: null,
      "default": null
    },
    imageClass: {
      type: null,
      "default": null
    },
    previewButtonProps: {
      type: null,
      "default": null
    },
    indicatorIcon: {
      type: String,
      "default": void 0
    },
    previewIcon: {
      type: String,
      "default": void 0
    },
    zoomInDisabled: {
      type: Boolean,
      "default": false
    },
    zoomOutDisabled: {
      type: Boolean,
      "default": false
    }
  },
  style: ImageStyle,
  provide: function provide5() {
    return {
      $pcImage: this,
      $parentInstance: this
    };
  }
};
var script$8 = {
  name: "Image",
  "extends": script$1$3,
  inheritAttrs: false,
  emits: ["show", "hide", "error"],
  mask: null,
  data: function data2() {
    return {
      maskVisible: false,
      previewVisible: false,
      rotate: 0,
      scale: 1
    };
  },
  beforeUnmount: function beforeUnmount2() {
    if (this.mask) {
      x$2.clear(this.container);
    }
  },
  methods: {
    maskRef: function maskRef(el) {
      this.mask = el;
    },
    toolbarRef: function toolbarRef(el) {
      this.toolbarRef = el;
    },
    onImageClick: function onImageClick() {
      var _this = this;
      if (this.preview) {
        blockBodyScroll();
        this.maskVisible = true;
        setTimeout(function() {
          _this.previewVisible = true;
        }, 25);
      }
    },
    onPreviewImageClick: function onPreviewImageClick() {
      this.previewClick = true;
    },
    onMaskClick: function onMaskClick(event) {
      var isBarActionsClicked = _$2(event.target, "data-pc-section-group", "action") || event.target.closest('[data-pc-section-group="action"]');
      if (!this.previewClick && !isBarActionsClicked) {
        this.previewVisible = false;
        this.rotate = 0;
        this.scale = 1;
      }
      this.previewClick = false;
    },
    onMaskKeydown: function onMaskKeydown(event) {
      var _this2 = this;
      switch (event.code) {
        case "Escape":
          this.hidePreview();
          setTimeout(function() {
            bt$1(_this2.$refs.previewButton);
          }, 200);
          event.preventDefault();
          break;
      }
    },
    onError: function onError() {
      this.$emit("error");
    },
    rotateRight: function rotateRight() {
      this.rotate += 90;
      this.previewClick = true;
    },
    rotateLeft: function rotateLeft() {
      this.rotate -= 90;
      this.previewClick = true;
    },
    zoomIn: function zoomIn() {
      this.scale = this.scale + 0.1;
      this.previewClick = true;
    },
    zoomOut: function zoomOut() {
      this.scale = this.scale - 0.1;
      this.previewClick = true;
    },
    onBeforeEnter: function onBeforeEnter() {
      x$2.set("modal", this.mask, this.$primevue.config.zIndex.modal);
    },
    onEnter: function onEnter() {
      this.focus();
      this.$emit("show");
    },
    onBeforeLeave: function onBeforeLeave() {
      !this.isUnstyled && W$2(this.mask, "p-overlay-mask-leave-active");
    },
    onLeave: function onLeave() {
      unblockBodyScroll();
      this.$emit("hide");
    },
    onAfterLeave: function onAfterLeave(el) {
      x$2.clear(el);
      this.maskVisible = false;
    },
    focus: function focus() {
      var focusTarget = this.mask.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    },
    hidePreview: function hidePreview() {
      this.previewVisible = false;
      this.rotate = 0;
      this.scale = 1;
      unblockBodyScroll();
    }
  },
  computed: {
    containerClass: function containerClass() {
      return [this.cx("root"), this["class"]];
    },
    rotateClass: function rotateClass() {
      return "p-image-preview-rotate-" + this.rotate;
    },
    imagePreviewStyle: function imagePreviewStyle() {
      return {
        transform: "rotate(" + this.rotate + "deg) scale(" + this.scale + ")"
      };
    },
    isZoomInDisabled: function isZoomInDisabled() {
      return this.zoomInDisabled || this.scale >= 1.5;
    },
    isZoomOutDisabled: function isZoomOutDisabled() {
      return this.zoomOutDisabled || this.scale <= 0.5;
    },
    rightAriaLabel: function rightAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.rotateRight : void 0;
    },
    leftAriaLabel: function leftAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.rotateLeft : void 0;
    },
    zoomInAriaLabel: function zoomInAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.zoomIn : void 0;
    },
    zoomOutAriaLabel: function zoomOutAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.zoomOut : void 0;
    },
    zoomImageAriaLabel: function zoomImageAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.zoomImage : void 0;
    },
    closeAriaLabel: function closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }
  },
  components: {
    Portal: script$9,
    EyeIcon: script$f,
    RefreshIcon: script$e,
    UndoIcon: script$a,
    SearchMinusIcon: script$d,
    SearchPlusIcon: script$c,
    TimesIcon: script$b
  },
  directives: {
    focustrap: FocusTrap
  }
};
function _typeof$3(o2) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$3(o2);
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$3(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$3(e2, r2, t2) {
  return (r2 = _toPropertyKey$3(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$3(t2) {
  var i2 = _toPrimitive$3(t2, "string");
  return "symbol" == _typeof$3(i2) ? i2 : i2 + "";
}
function _toPrimitive$3(t2, r2) {
  if ("object" != _typeof$3(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var _hoisted_1$k = ["aria-label"];
var _hoisted_2$g = ["aria-modal"];
var _hoisted_3$f = ["aria-label"];
var _hoisted_4$8 = ["aria-label"];
var _hoisted_5$8 = ["disabled", "aria-label"];
var _hoisted_6$3 = ["disabled", "aria-label"];
var _hoisted_7$3 = ["aria-label"];
var _hoisted_8$3 = ["src"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_RefreshIcon = resolveComponent("RefreshIcon");
  var _component_UndoIcon = resolveComponent("UndoIcon");
  var _component_SearchMinusIcon = resolveComponent("SearchMinusIcon");
  var _component_SearchPlusIcon = resolveComponent("SearchPlusIcon");
  var _component_TimesIcon = resolveComponent("TimesIcon");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createElementBlock("span", mergeProps({
    "class": $options.containerClass,
    style: _ctx.style
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "image", {
    errorCallback: $options.onError
  }, function() {
    return [createBaseVNode("img", mergeProps({
      style: _ctx.imageStyle,
      "class": _ctx.imageClass,
      onError: _cache[0] || (_cache[0] = function() {
        return $options.onError && $options.onError.apply($options, arguments);
      })
    }, _objectSpread$2(_objectSpread$2({}, _ctx.$attrs), _ctx.ptm("image"))), null, 16)];
  }), _ctx.preview ? (openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    ref: "previewButton",
    "aria-label": $options.zoomImageAriaLabel,
    type: "button",
    "class": _ctx.cx("previewMask"),
    onClick: _cache[1] || (_cache[1] = function() {
      return $options.onImageClick && $options.onImageClick.apply($options, arguments);
    })
  }, _objectSpread$2(_objectSpread$2({}, _ctx.previewButtonProps), _ctx.ptm("previewMask"))), [renderSlot(_ctx.$slots, _ctx.$slots.previewicon ? "previewicon" : "indicatoricon", {}, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.previewIcon || _ctx.indicatorIcon ? "i" : "EyeIcon"), mergeProps({
      "class": [_ctx.cx("previewIcon"), _ctx.previewIcon]
    }, _ctx.ptm("previewIcon")), null, 16, ["class"]))];
  })], 16, _hoisted_1$k)) : createCommentVNode("", true), createVNode(_component_Portal, null, {
    "default": withCtx(function() {
      return [$data.maskVisible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        role: "dialog",
        "class": _ctx.cx("mask"),
        "aria-modal": $data.maskVisible,
        onClick: _cache[8] || (_cache[8] = function() {
          return $options.onMaskClick && $options.onMaskClick.apply($options, arguments);
        }),
        onKeydown: _cache[9] || (_cache[9] = function() {
          return $options.onMaskKeydown && $options.onMaskKeydown.apply($options, arguments);
        })
      }, _ctx.ptm("mask")), [createBaseVNode("div", mergeProps({
        "class": _ctx.cx("toolbar")
      }, _ctx.ptm("toolbar")), [createBaseVNode("button", mergeProps({
        "class": _ctx.cx("rotateRightButton"),
        onClick: _cache[2] || (_cache[2] = function() {
          return $options.rotateRight && $options.rotateRight.apply($options, arguments);
        }),
        type: "button",
        "aria-label": $options.rightAriaLabel
      }, _ctx.ptm("rotateRightButton"), {
        "data-pc-group-section": "action"
      }), [renderSlot(_ctx.$slots, "refresh", {}, function() {
        return [createVNode(_component_RefreshIcon, normalizeProps(guardReactiveProps(_ctx.ptm("rotateRightIcon"))), null, 16)];
      })], 16, _hoisted_3$f), createBaseVNode("button", mergeProps({
        "class": _ctx.cx("rotateLeftButton"),
        onClick: _cache[3] || (_cache[3] = function() {
          return $options.rotateLeft && $options.rotateLeft.apply($options, arguments);
        }),
        type: "button",
        "aria-label": $options.leftAriaLabel
      }, _ctx.ptm("rotateLeftButton"), {
        "data-pc-group-section": "action"
      }), [renderSlot(_ctx.$slots, "undo", {}, function() {
        return [createVNode(_component_UndoIcon, normalizeProps(guardReactiveProps(_ctx.ptm("rotateLeftIcon"))), null, 16)];
      })], 16, _hoisted_4$8), createBaseVNode("button", mergeProps({
        "class": _ctx.cx("zoomOutButton"),
        onClick: _cache[4] || (_cache[4] = function() {
          return $options.zoomOut && $options.zoomOut.apply($options, arguments);
        }),
        type: "button",
        disabled: $options.isZoomOutDisabled,
        "aria-label": $options.zoomOutAriaLabel
      }, _ctx.ptm("zoomOutButton"), {
        "data-pc-group-section": "action"
      }), [renderSlot(_ctx.$slots, "zoomout", {}, function() {
        return [createVNode(_component_SearchMinusIcon, normalizeProps(guardReactiveProps(_ctx.ptm("zoomOutIcon"))), null, 16)];
      })], 16, _hoisted_5$8), createBaseVNode("button", mergeProps({
        "class": _ctx.cx("zoomInButton"),
        onClick: _cache[5] || (_cache[5] = function() {
          return $options.zoomIn && $options.zoomIn.apply($options, arguments);
        }),
        type: "button",
        disabled: $options.isZoomInDisabled,
        "aria-label": $options.zoomInAriaLabel
      }, _ctx.ptm("zoomInButton"), {
        "data-pc-group-section": "action"
      }), [renderSlot(_ctx.$slots, "zoomin", {}, function() {
        return [createVNode(_component_SearchPlusIcon, normalizeProps(guardReactiveProps(_ctx.ptm("zoomInIcon"))), null, 16)];
      })], 16, _hoisted_6$3), createBaseVNode("button", mergeProps({
        "class": _ctx.cx("closeButton"),
        type: "button",
        onClick: _cache[6] || (_cache[6] = function() {
          return $options.hidePreview && $options.hidePreview.apply($options, arguments);
        }),
        "aria-label": $options.closeAriaLabel,
        autofocus: ""
      }, _ctx.ptm("closeButton"), {
        "data-pc-group-section": "action"
      }), [renderSlot(_ctx.$slots, "close", {}, function() {
        return [createVNode(_component_TimesIcon, normalizeProps(guardReactiveProps(_ctx.ptm("closeIcon"))), null, 16)];
      })], 16, _hoisted_7$3)], 16), createVNode(Transition, mergeProps({
        name: "p-image-original",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onLeave: $options.onLeave,
        onBeforeLeave: $options.onBeforeLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.previewVisible ? (openBlock(), createElementBlock("div", normalizeProps(mergeProps({
            key: 0
          }, _ctx.ptm("originalContainer"))), [renderSlot(_ctx.$slots, _ctx.$slots.original ? "original" : "preview", {
            "class": normalizeClass(_ctx.cx("original")),
            style: normalizeStyle($options.imagePreviewStyle),
            previewCallback: $options.onPreviewImageClick
          }, function() {
            return [createBaseVNode("img", mergeProps({
              src: _ctx.$attrs.src,
              "class": _ctx.cx("original"),
              style: $options.imagePreviewStyle,
              onClick: _cache[7] || (_cache[7] = function() {
                return $options.onPreviewImageClick && $options.onPreviewImageClick.apply($options, arguments);
              })
            }, _ctx.ptm("original")), null, 16, _hoisted_8$3)];
          })], 16)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onBeforeEnter", "onEnter", "onLeave", "onBeforeLeave", "onAfterLeave"])], 16, _hoisted_2$g)), [[_directive_focustrap]]) : createCommentVNode("", true)];
    }),
    _: 3
  })], 16);
}
script$8.render = render$7;
var style$2 = "\n    .p-message {\n        display: grid;\n        grid-template-rows: 1fr;\n        border-radius: dt('message.border.radius');\n        outline-width: dt('message.border.width');\n        outline-style: solid;\n    }\n\n    .p-message-content-wrapper {\n        min-height: 0;\n    }\n\n    .p-message-content {\n        display: flex;\n        align-items: center;\n        padding: dt('message.content.padding');\n        gap: dt('message.content.gap');\n    }\n\n    .p-message-icon {\n        flex-shrink: 0;\n    }\n\n    .p-message-close-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        margin-inline-start: auto;\n        overflow: hidden;\n        position: relative;\n        width: dt('message.close.button.width');\n        height: dt('message.close.button.height');\n        border-radius: dt('message.close.button.border.radius');\n        background: transparent;\n        transition:\n            background dt('message.transition.duration'),\n            color dt('message.transition.duration'),\n            outline-color dt('message.transition.duration'),\n            box-shadow dt('message.transition.duration'),\n            opacity 0.3s;\n        outline-color: transparent;\n        color: inherit;\n        padding: 0;\n        border: none;\n        cursor: pointer;\n        user-select: none;\n    }\n\n    .p-message-close-icon {\n        font-size: dt('message.close.icon.size');\n        width: dt('message.close.icon.size');\n        height: dt('message.close.icon.size');\n    }\n\n    .p-message-close-button:focus-visible {\n        outline-width: dt('message.close.button.focus.ring.width');\n        outline-style: dt('message.close.button.focus.ring.style');\n        outline-offset: dt('message.close.button.focus.ring.offset');\n    }\n\n    .p-message-info {\n        background: dt('message.info.background');\n        outline-color: dt('message.info.border.color');\n        color: dt('message.info.color');\n        box-shadow: dt('message.info.shadow');\n    }\n\n    .p-message-info .p-message-close-button:focus-visible {\n        outline-color: dt('message.info.close.button.focus.ring.color');\n        box-shadow: dt('message.info.close.button.focus.ring.shadow');\n    }\n\n    .p-message-info .p-message-close-button:hover {\n        background: dt('message.info.close.button.hover.background');\n    }\n\n    .p-message-info.p-message-outlined {\n        color: dt('message.info.outlined.color');\n        outline-color: dt('message.info.outlined.border.color');\n    }\n\n    .p-message-info.p-message-simple {\n        color: dt('message.info.simple.color');\n    }\n\n    .p-message-success {\n        background: dt('message.success.background');\n        outline-color: dt('message.success.border.color');\n        color: dt('message.success.color');\n        box-shadow: dt('message.success.shadow');\n    }\n\n    .p-message-success .p-message-close-button:focus-visible {\n        outline-color: dt('message.success.close.button.focus.ring.color');\n        box-shadow: dt('message.success.close.button.focus.ring.shadow');\n    }\n\n    .p-message-success .p-message-close-button:hover {\n        background: dt('message.success.close.button.hover.background');\n    }\n\n    .p-message-success.p-message-outlined {\n        color: dt('message.success.outlined.color');\n        outline-color: dt('message.success.outlined.border.color');\n    }\n\n    .p-message-success.p-message-simple {\n        color: dt('message.success.simple.color');\n    }\n\n    .p-message-warn {\n        background: dt('message.warn.background');\n        outline-color: dt('message.warn.border.color');\n        color: dt('message.warn.color');\n        box-shadow: dt('message.warn.shadow');\n    }\n\n    .p-message-warn .p-message-close-button:focus-visible {\n        outline-color: dt('message.warn.close.button.focus.ring.color');\n        box-shadow: dt('message.warn.close.button.focus.ring.shadow');\n    }\n\n    .p-message-warn .p-message-close-button:hover {\n        background: dt('message.warn.close.button.hover.background');\n    }\n\n    .p-message-warn.p-message-outlined {\n        color: dt('message.warn.outlined.color');\n        outline-color: dt('message.warn.outlined.border.color');\n    }\n\n    .p-message-warn.p-message-simple {\n        color: dt('message.warn.simple.color');\n    }\n\n    .p-message-error {\n        background: dt('message.error.background');\n        outline-color: dt('message.error.border.color');\n        color: dt('message.error.color');\n        box-shadow: dt('message.error.shadow');\n    }\n\n    .p-message-error .p-message-close-button:focus-visible {\n        outline-color: dt('message.error.close.button.focus.ring.color');\n        box-shadow: dt('message.error.close.button.focus.ring.shadow');\n    }\n\n    .p-message-error .p-message-close-button:hover {\n        background: dt('message.error.close.button.hover.background');\n    }\n\n    .p-message-error.p-message-outlined {\n        color: dt('message.error.outlined.color');\n        outline-color: dt('message.error.outlined.border.color');\n    }\n\n    .p-message-error.p-message-simple {\n        color: dt('message.error.simple.color');\n    }\n\n    .p-message-secondary {\n        background: dt('message.secondary.background');\n        outline-color: dt('message.secondary.border.color');\n        color: dt('message.secondary.color');\n        box-shadow: dt('message.secondary.shadow');\n    }\n\n    .p-message-secondary .p-message-close-button:focus-visible {\n        outline-color: dt('message.secondary.close.button.focus.ring.color');\n        box-shadow: dt('message.secondary.close.button.focus.ring.shadow');\n    }\n\n    .p-message-secondary .p-message-close-button:hover {\n        background: dt('message.secondary.close.button.hover.background');\n    }\n\n    .p-message-secondary.p-message-outlined {\n        color: dt('message.secondary.outlined.color');\n        outline-color: dt('message.secondary.outlined.border.color');\n    }\n\n    .p-message-secondary.p-message-simple {\n        color: dt('message.secondary.simple.color');\n    }\n\n    .p-message-contrast {\n        background: dt('message.contrast.background');\n        outline-color: dt('message.contrast.border.color');\n        color: dt('message.contrast.color');\n        box-shadow: dt('message.contrast.shadow');\n    }\n\n    .p-message-contrast .p-message-close-button:focus-visible {\n        outline-color: dt('message.contrast.close.button.focus.ring.color');\n        box-shadow: dt('message.contrast.close.button.focus.ring.shadow');\n    }\n\n    .p-message-contrast .p-message-close-button:hover {\n        background: dt('message.contrast.close.button.hover.background');\n    }\n\n    .p-message-contrast.p-message-outlined {\n        color: dt('message.contrast.outlined.color');\n        outline-color: dt('message.contrast.outlined.border.color');\n    }\n\n    .p-message-contrast.p-message-simple {\n        color: dt('message.contrast.simple.color');\n    }\n\n    .p-message-text {\n        font-size: dt('message.text.font.size');\n        font-weight: dt('message.text.font.weight');\n    }\n\n    .p-message-icon {\n        font-size: dt('message.icon.size');\n        width: dt('message.icon.size');\n        height: dt('message.icon.size');\n    }\n\n    .p-message-sm .p-message-content {\n        padding: dt('message.content.sm.padding');\n    }\n\n    .p-message-sm .p-message-text {\n        font-size: dt('message.text.sm.font.size');\n    }\n\n    .p-message-sm .p-message-icon {\n        font-size: dt('message.icon.sm.size');\n        width: dt('message.icon.sm.size');\n        height: dt('message.icon.sm.size');\n    }\n\n    .p-message-sm .p-message-close-icon {\n        font-size: dt('message.close.icon.sm.size');\n        width: dt('message.close.icon.sm.size');\n        height: dt('message.close.icon.sm.size');\n    }\n\n    .p-message-lg .p-message-content {\n        padding: dt('message.content.lg.padding');\n    }\n\n    .p-message-lg .p-message-text {\n        font-size: dt('message.text.lg.font.size');\n    }\n\n    .p-message-lg .p-message-icon {\n        font-size: dt('message.icon.lg.size');\n        width: dt('message.icon.lg.size');\n        height: dt('message.icon.lg.size');\n    }\n\n    .p-message-lg .p-message-close-icon {\n        font-size: dt('message.close.icon.lg.size');\n        width: dt('message.close.icon.lg.size');\n        height: dt('message.close.icon.lg.size');\n    }\n\n    .p-message-outlined {\n        background: transparent;\n        outline-width: dt('message.outlined.border.width');\n    }\n\n    .p-message-simple {\n        background: transparent;\n        outline-color: transparent;\n        box-shadow: none;\n    }\n\n    .p-message-simple .p-message-content {\n        padding: dt('message.simple.content.padding');\n    }\n\n    .p-message-outlined .p-message-close-button:hover,\n    .p-message-simple .p-message-close-button:hover {\n        background: transparent;\n    }\n\n    .p-message-enter-active {\n        animation: p-animate-message-enter 0.3s ease-out forwards;\n        overflow: hidden;\n    }\n\n    .p-message-leave-active {\n        animation: p-animate-message-leave 0.15s ease-in forwards;\n        overflow: hidden;\n    }\n\n    @keyframes p-animate-message-enter {\n        from {\n            opacity: 0;\n            grid-template-rows: 0fr;\n        }\n        to {\n            opacity: 1;\n            grid-template-rows: 1fr;\n        }\n    }\n\n    @keyframes p-animate-message-leave {\n        from {\n            opacity: 1;\n            grid-template-rows: 1fr;\n        }\n        to {\n            opacity: 0;\n            margin: 0;\n            grid-template-rows: 0fr;\n        }\n    }\n";
var classes$2 = {
  root: function root4(_ref2) {
    var props = _ref2.props;
    return ["p-message p-component p-message-" + props.severity, {
      "p-message-outlined": props.variant === "outlined",
      "p-message-simple": props.variant === "simple",
      "p-message-sm": props.size === "small",
      "p-message-lg": props.size === "large"
    }];
  },
  contentWrapper: "p-message-content-wrapper",
  content: "p-message-content",
  icon: "p-message-icon",
  text: "p-message-text",
  closeButton: "p-message-close-button",
  closeIcon: "p-message-close-icon"
};
var MessageStyle = BaseStyle.extend({
  name: "message",
  style: style$2,
  classes: classes$2
});
var script$1$2 = {
  name: "BaseMessage",
  "extends": script$k,
  props: {
    severity: {
      type: String,
      "default": "info"
    },
    closable: {
      type: Boolean,
      "default": false
    },
    life: {
      type: Number,
      "default": null
    },
    icon: {
      type: String,
      "default": void 0
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: null,
      "default": null
    },
    size: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    }
  },
  style: MessageStyle,
  provide: function provide6() {
    return {
      $pcMessage: this,
      $parentInstance: this
    };
  }
};
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
function _defineProperty$1(e2, r2, t2) {
  return (r2 = _toPropertyKey$1(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$1(t2) {
  var i2 = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var script$7 = {
  name: "Message",
  "extends": script$1$2,
  inheritAttrs: false,
  emits: ["close", "life-end"],
  timeout: null,
  data: function data3() {
    return {
      visible: true
    };
  },
  mounted: function mounted4() {
    var _this = this;
    if (this.life) {
      setTimeout(function() {
        _this.visible = false;
        _this.$emit("life-end");
      }, this.life);
    }
  },
  methods: {
    close: function close(event) {
      this.visible = false;
      this.$emit("close", event);
    }
  },
  computed: {
    closeAriaLabel: function closeAriaLabel2() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    },
    dataP: function dataP3() {
      return f$c(_defineProperty$1(_defineProperty$1({
        outlined: this.variant === "outlined",
        simple: this.variant === "simple"
      }, this.severity, this.severity), this.size, this.size));
    }
  },
  directives: {
    ripple: Ripple
  },
  components: {
    TimesIcon: script$b
  }
};
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$2(o2);
}
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$2(e2, r2, t2) {
  return (r2 = _toPropertyKey$2(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey$2(t2) {
  var i2 = _toPrimitive$2(t2, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$2(t2, r2) {
  if ("object" != _typeof$2(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var _hoisted_1$j = ["data-p"];
var _hoisted_2$f = ["data-p"];
var _hoisted_3$e = ["data-p"];
var _hoisted_4$7 = ["aria-label", "data-p"];
var _hoisted_5$7 = ["data-p"];
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_TimesIcon = resolveComponent("TimesIcon");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createBlock(Transition, mergeProps({
    name: "p-message",
    appear: ""
  }, _ctx.ptmi("transition")), {
    "default": withCtx(function() {
      return [$data.visible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        "class": _ctx.cx("root"),
        role: "alert",
        "aria-live": "assertive",
        "aria-atomic": "true",
        "data-p": $options.dataP
      }, _ctx.ptm("root")), [createBaseVNode("div", mergeProps({
        "class": _ctx.cx("contentWrapper")
      }, _ctx.ptm("contentWrapper")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
        key: 0,
        closeCallback: $options.close
      }) : (openBlock(), createElementBlock("div", mergeProps({
        key: 1,
        "class": _ctx.cx("content"),
        "data-p": $options.dataP
      }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "icon", {
        "class": normalizeClass(_ctx.cx("icon"))
      }, function() {
        return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.icon ? "span" : null), mergeProps({
          "class": [_ctx.cx("icon"), _ctx.icon],
          "data-p": $options.dataP
        }, _ctx.ptm("icon")), null, 16, ["class", "data-p"]))];
      }), _ctx.$slots["default"] ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        "class": _ctx.cx("text"),
        "data-p": $options.dataP
      }, _ctx.ptm("text")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_3$e)) : createCommentVNode("", true), _ctx.closable ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
        key: 1,
        "class": _ctx.cx("closeButton"),
        "aria-label": $options.closeAriaLabel,
        type: "button",
        onClick: _cache[0] || (_cache[0] = function($event) {
          return $options.close($event);
        }),
        "data-p": $options.dataP
      }, _objectSpread$1(_objectSpread$1({}, _ctx.closeButtonProps), _ctx.ptm("closeButton"))), [renderSlot(_ctx.$slots, "closeicon", {}, function() {
        return [_ctx.closeIcon ? (openBlock(), createElementBlock("i", mergeProps({
          key: 0,
          "class": [_ctx.cx("closeIcon"), _ctx.closeIcon],
          "data-p": $options.dataP
        }, _ctx.ptm("closeIcon")), null, 16, _hoisted_5$7)) : (openBlock(), createBlock(_component_TimesIcon, mergeProps({
          key: 1,
          "class": [_ctx.cx("closeIcon"), _ctx.closeIcon],
          "data-p": $options.dataP
        }, _ctx.ptm("closeIcon")), null, 16, ["class", "data-p"]))];
      })], 16, _hoisted_4$7)), [[_directive_ripple]]) : createCommentVNode("", true)], 16, _hoisted_2$f))], 16)], 16, _hoisted_1$j)) : createCommentVNode("", true)];
    }),
    _: 3
  }, 16);
}
script$7.render = render$6;
var OverlayEventBus = s$d();
var style$1 = "\n    .p-popover {\n        margin-block-start: dt('popover.gutter');\n        background: dt('popover.background');\n        color: dt('popover.color');\n        border: 1px solid dt('popover.border.color');\n        border-radius: dt('popover.border.radius');\n        box-shadow: dt('popover.shadow');\n        will-change: transform;\n    }\n\n    .p-popover-content {\n        padding: dt('popover.content.padding');\n    }\n\n    .p-popover-flipped {\n        margin-block-start: calc(dt('popover.gutter') * -1);\n        margin-block-end: dt('popover.gutter');\n    }\n\n    .p-popover:after,\n    .p-popover:before {\n        bottom: 100%;\n        left: calc(dt('popover.arrow.offset') + dt('popover.arrow.left'));\n        content: ' ';\n        height: 0;\n        width: 0;\n        position: absolute;\n        pointer-events: none;\n    }\n\n    .p-popover:after {\n        border-width: calc(dt('popover.gutter') - 2px);\n        margin-left: calc(-1 * (dt('popover.gutter') - 2px));\n        border-style: solid;\n        border-color: transparent;\n        border-bottom-color: dt('popover.background');\n    }\n\n    .p-popover:before {\n        border-width: dt('popover.gutter');\n        margin-left: calc(-1 * dt('popover.gutter'));\n        border-style: solid;\n        border-color: transparent;\n        border-bottom-color: dt('popover.border.color');\n    }\n\n    .p-popover-flipped:after,\n    .p-popover-flipped:before {\n        bottom: auto;\n        top: 100%;\n    }\n\n    .p-popover.p-popover-flipped:after {\n        border-bottom-color: transparent;\n        border-top-color: dt('popover.background');\n    }\n\n    .p-popover.p-popover-flipped:before {\n        border-bottom-color: transparent;\n        border-top-color: dt('popover.border.color');\n    }\n";
var classes$1 = {
  root: "p-popover p-component",
  content: "p-popover-content"
};
var PopoverStyle = BaseStyle.extend({
  name: "popover",
  style: style$1,
  classes: classes$1
});
var script$1$1 = {
  name: "BasePopover",
  "extends": script$k,
  props: {
    dismissable: {
      type: Boolean,
      "default": true
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    }
  },
  style: PopoverStyle,
  provide: function provide7() {
    return {
      $pcPopover: this,
      $parentInstance: this
    };
  }
};
var script$6 = {
  name: "Popover",
  "extends": script$1$1,
  inheritAttrs: false,
  emits: ["show", "hide"],
  data: function data4() {
    return {
      visible: false
    };
  },
  watch: {
    dismissable: {
      immediate: true,
      handler: function handler3(newValue) {
        if (newValue) {
          this.bindOutsideClickListener();
        } else {
          this.unbindOutsideClickListener();
        }
      }
    }
  },
  selfClick: false,
  target: null,
  eventTarget: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  styleElement: null,
  overlayEventListener: null,
  documentKeydownListener: null,
  beforeUnmount: function beforeUnmount3() {
    if (this.dismissable) {
      this.unbindOutsideClickListener();
    }
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.destroyStyle();
    this.unbindResizeListener();
    this.target = null;
    if (this.container && this.autoZIndex) {
      x$2.clear(this.container);
    }
    if (this.overlayEventListener) {
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    }
    this.container = null;
  },
  mounted: function mounted5() {
    if (this.breakpoints) {
      this.createStyle();
    }
  },
  methods: {
    toggle: function toggle(event, target) {
      if (this.visible) this.hide();
      else this.show(event, target);
    },
    show: function show2(event, target) {
      this.visible = true;
      this.eventTarget = event.currentTarget;
      this.target = target || event.currentTarget;
    },
    hide: function hide2() {
      this.visible = false;
    },
    onContentClick: function onContentClick() {
      this.selfClick = true;
    },
    onEnter: function onEnter2(el) {
      var _this = this;
      S$3(el, {
        position: "absolute",
        top: "0"
      });
      this.alignOverlay();
      if (this.dismissable) {
        this.bindOutsideClickListener();
      }
      this.bindScrollListener();
      this.bindResizeListener();
      if (this.autoZIndex) {
        x$2.set("overlay", el, this.baseZIndex + this.$primevue.config.zIndex.overlay);
      }
      this.overlayEventListener = function(e2) {
        if (_this.container.contains(e2.target)) {
          _this.selfClick = true;
        }
      };
      this.focus();
      OverlayEventBus.on("overlay-click", this.overlayEventListener);
      this.$emit("show");
      if (this.closeOnEscape) {
        this.bindDocumentKeyDownListener();
      }
    },
    onLeave: function onLeave2() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.unbindDocumentKeyDownListener();
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
      this.$emit("hide");
    },
    onAfterLeave: function onAfterLeave2(el) {
      if (this.autoZIndex) {
        x$2.clear(el);
      }
    },
    alignOverlay: function alignOverlay() {
      D$2(this.container, this.target, false);
      var containerOffset = K$2(this.container);
      var targetOffset = K$2(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty(rr("popover.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-popover-flipped", "true");
        !this.isUnstyled && W$2(this.container, "p-popover-flipped");
      }
    },
    onContentKeydown: function onContentKeydown(event) {
      if (event.code === "Escape" && this.closeOnEscape) {
        this.hide();
        bt$1(this.target);
      }
    },
    onButtonKeydown: function onButtonKeydown(event) {
      switch (event.code) {
        case "ArrowDown":
        case "ArrowUp":
        case "ArrowLeft":
        case "ArrowRight":
          event.preventDefault();
      }
    },
    focus: function focus2() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    },
    onKeyDown: function onKeyDown(event) {
      if (event.code === "Escape" && this.closeOnEscape) {
        this.visible = false;
      }
    },
    bindDocumentKeyDownListener: function bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    },
    unbindDocumentKeyDownListener: function unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    },
    bindOutsideClickListener: function bindOutsideClickListener() {
      var _this2 = this;
      if (!this.outsideClickListener && tt$1()) {
        this.outsideClickListener = function(event) {
          if (_this2.visible && !_this2.selfClick && !_this2.isTargetClicked(event)) {
            _this2.visible = false;
          }
          _this2.selfClick = false;
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    },
    bindScrollListener: function bindScrollListener2() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener2() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },
    bindResizeListener: function bindResizeListener() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !Yt$2()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    },
    isTargetClicked: function isTargetClicked(event) {
      return this.eventTarget && (this.eventTarget === event.target || this.eventTarget.contains(event.target));
    },
    containerRef: function containerRef(el) {
      this.container = el;
    },
    createStyle: function createStyle() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        _t$2(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-popover[").concat(this.$attrSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    },
    destroyStyle: function destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },
    onOverlayClick: function onOverlayClick(event) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event,
        target: this.target
      });
    }
  },
  directives: {
    focustrap: FocusTrap,
    ripple: Ripple
  },
  components: {
    Portal: script$9
  }
};
var _hoisted_1$i = ["aria-modal"];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-anchored-overlay",
        onEnter: $options.onEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "dialog",
            "aria-modal": $data.visible,
            onClick: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            "class": _ctx.cx("root")
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.hide,
            keydownCallback: function keydownCallback(event) {
              return $options.onButtonKeydown(event);
            }
          }) : (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            "class": _ctx.cx("content"),
            onClick: _cache[0] || (_cache[0] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onMousedown: _cache[1] || (_cache[1] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onKeydown: _cache[2] || (_cache[2] = function() {
              return $options.onContentKeydown && $options.onContentKeydown.apply($options, arguments);
            })
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16))], 16, _hoisted_1$i)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
script$6.render = render$5;
const _hoisted_1$h = { class: "header" };
const _hoisted_2$e = { class: "buttons" };
const _hoisted_3$d = { class: "number" };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "Changelog",
  setup(__props) {
    const changelogStore = useChangelogStore(), indexStore = useIndexStore(), kofi = useTemplateRef("kofi"), kofiToggle = (event) => {
      kofi.value?.toggle(event);
    }, visible = /* @__PURE__ */ ref(true);
    onMounted(() => {
      changelogStore.checkLog();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "#statsChangelog" }, [
        createVNode(unref(script$6), {
          ref_key: "kofi",
          ref: kofi
        }, {
          default: withCtx(() => [..._cache[1] || (_cache[1] = [
            createBaseVNode("iframe", {
              id: "kofiframe",
              src: "https://ko-fi.com/daisukejigen/?hidefeed=true&widget=true&embed=true&preview=true",
              style: { "border": "none", "width": "100%", "padding": "4px", "background": "#f9f9f9" },
              height: "712",
              title: "daisukejigen"
            }, null, -1)
          ])]),
          _: 1
        }, 512),
        unref(changelogStore).showLog ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          visible.value ? (openBlock(), createBlock(unref(script$7), { key: 0 }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$h, [
                _cache[2] || (_cache[2] = createBaseVNode("div", { class: "title" }, [
                  createBaseVNode("span", null, "WaniKani Stats has been updated")
                ], -1)),
                createBaseVNode("div", _hoisted_2$e, [
                  createVNode(unref(script$g), {
                    onClick: kofiToggle,
                    outlined: "",
                    rounded: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(script$8), {
                        src: unref(indexStore).kofiImage,
                        alt: "ko-fi",
                        width: "16"
                      }, null, 8, ["src"])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(script$g), {
                    outlined: "",
                    rounded: "",
                    onClick: _cache[0] || (_cache[0] = ($event) => visible.value = false)
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(FontAwesomeIcon), { icon: unref(faXmark) }, null, 8, ["icon"])
                    ]),
                    _: 1
                  })
                ])
              ]),
              createBaseVNode("ul", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(changelogStore).logSinceLast, (version2, index2) => {
                  return openBlock(), createElementBlock("li", {
                    class: "version",
                    key: index2
                  }, [
                    createBaseVNode("span", _hoisted_3$d, toDisplayString(version2.version.toFixed(2)) + ":", 1),
                    createBaseVNode("ul", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(version2.changes, (change, index22) => {
                        return openBlock(), createElementBlock("li", { key: index22 }, toDisplayString(change), 1);
                      }), 128))
                    ])
                  ]);
                }), 128))
              ])
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ]);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const Changelog = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-c6a65fa3"]]);
var script$5 = {
  name: "BarsIcon",
  "extends": script$j
};
function _toConsumableArray$2(r2) {
  return _arrayWithoutHoles$2(r2) || _iterableToArray$2(r2) || _unsupportedIterableToArray$2(r2) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$2(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$2(r2, a2) : void 0;
  }
}
function _iterableToArray$2(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$2(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$2(r2);
}
function _arrayLikeToArray$2(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$2(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M13.3226 3.6129H0.677419C0.497757 3.6129 0.325452 3.54152 0.198411 3.41448C0.0713707 3.28744 0 3.11514 0 2.93548C0 2.75581 0.0713707 2.58351 0.198411 2.45647C0.325452 2.32943 0.497757 2.25806 0.677419 2.25806H13.3226C13.5022 2.25806 13.6745 2.32943 13.8016 2.45647C13.9286 2.58351 14 2.75581 14 2.93548C14 3.11514 13.9286 3.28744 13.8016 3.41448C13.6745 3.54152 13.5022 3.6129 13.3226 3.6129ZM13.3226 7.67741H0.677419C0.497757 7.67741 0.325452 7.60604 0.198411 7.479C0.0713707 7.35196 0 7.17965 0 6.99999C0 6.82033 0.0713707 6.64802 0.198411 6.52098C0.325452 6.39394 0.497757 6.32257 0.677419 6.32257H13.3226C13.5022 6.32257 13.6745 6.39394 13.8016 6.52098C13.9286 6.64802 14 6.82033 14 6.99999C14 7.17965 13.9286 7.35196 13.8016 7.479C13.6745 7.60604 13.5022 7.67741 13.3226 7.67741ZM0.677419 11.7419H13.3226C13.5022 11.7419 13.6745 11.6706 13.8016 11.5435C13.9286 11.4165 14 11.2442 14 11.0645C14 10.8848 13.9286 10.7125 13.8016 10.5855C13.6745 10.4585 13.5022 10.3871 13.3226 10.3871H0.677419C0.497757 10.3871 0.325452 10.4585 0.198411 10.5855C0.0713707 10.7125 0 10.8848 0 11.0645C0 11.2442 0.0713707 11.4165 0.198411 11.5435C0.325452 11.6706 0.497757 11.7419 0.677419 11.7419Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$5.render = render$4;
var style = "\n    .p-menubar {\n        display: flex;\n        align-items: center;\n        background: dt('menubar.background');\n        border: 1px solid dt('menubar.border.color');\n        border-radius: dt('menubar.border.radius');\n        color: dt('menubar.color');\n        padding: dt('menubar.padding');\n        gap: dt('menubar.gap');\n    }\n\n    .p-menubar-start,\n    .p-megamenu-end {\n        display: flex;\n        align-items: center;\n    }\n\n    .p-menubar-root-list,\n    .p-menubar-submenu {\n        display: flex;\n        margin: 0;\n        padding: 0;\n        list-style: none;\n        outline: 0 none;\n    }\n\n    .p-menubar-root-list {\n        align-items: center;\n        flex-wrap: wrap;\n        gap: dt('menubar.gap');\n    }\n\n    .p-menubar-root-list > .p-menubar-item > .p-menubar-item-content {\n        border-radius: dt('menubar.base.item.border.radius');\n    }\n\n    .p-menubar-root-list > .p-menubar-item > .p-menubar-item-content > .p-menubar-item-link {\n        padding: dt('menubar.base.item.padding');\n    }\n\n    .p-menubar-item-content {\n        transition:\n            background dt('menubar.transition.duration'),\n            color dt('menubar.transition.duration');\n        border-radius: dt('menubar.item.border.radius');\n        color: dt('menubar.item.color');\n    }\n\n    .p-menubar-item-link {\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        text-decoration: none;\n        overflow: hidden;\n        position: relative;\n        color: inherit;\n        padding: dt('menubar.item.padding');\n        gap: dt('menubar.item.gap');\n        user-select: none;\n        outline: 0 none;\n    }\n\n    .p-menubar-item-label {\n        line-height: 1;\n    }\n\n    .p-menubar-item-icon {\n        color: dt('menubar.item.icon.color');\n    }\n\n    .p-menubar-submenu-icon {\n        color: dt('menubar.submenu.icon.color');\n        margin-left: auto;\n        font-size: dt('menubar.submenu.icon.size');\n        width: dt('menubar.submenu.icon.size');\n        height: dt('menubar.submenu.icon.size');\n    }\n\n    .p-menubar-submenu .p-menubar-submenu-icon:dir(rtl) {\n        margin-left: 0;\n        margin-right: auto;\n    }\n\n    .p-menubar-item.p-focus > .p-menubar-item-content {\n        color: dt('menubar.item.focus.color');\n        background: dt('menubar.item.focus.background');\n    }\n\n    .p-menubar-item.p-focus > .p-menubar-item-content .p-menubar-item-icon {\n        color: dt('menubar.item.icon.focus.color');\n    }\n\n    .p-menubar-item.p-focus > .p-menubar-item-content .p-menubar-submenu-icon {\n        color: dt('menubar.submenu.icon.focus.color');\n    }\n\n    .p-menubar-item:not(.p-disabled) > .p-menubar-item-content:hover {\n        color: dt('menubar.item.focus.color');\n        background: dt('menubar.item.focus.background');\n    }\n\n    .p-menubar-item:not(.p-disabled) > .p-menubar-item-content:hover .p-menubar-item-icon {\n        color: dt('menubar.item.icon.focus.color');\n    }\n\n    .p-menubar-item:not(.p-disabled) > .p-menubar-item-content:hover .p-menubar-submenu-icon {\n        color: dt('menubar.submenu.icon.focus.color');\n    }\n\n    .p-menubar-item-active > .p-menubar-item-content {\n        color: dt('menubar.item.active.color');\n        background: dt('menubar.item.active.background');\n    }\n\n    .p-menubar-item-active > .p-menubar-item-content .p-menubar-item-icon {\n        color: dt('menubar.item.icon.active.color');\n    }\n\n    .p-menubar-item-active > .p-menubar-item-content .p-menubar-submenu-icon {\n        color: dt('menubar.submenu.icon.active.color');\n    }\n\n    .p-menubar-submenu {\n        display: none;\n        position: absolute;\n        min-width: 12.5rem;\n        z-index: 1;\n        background: dt('menubar.submenu.background');\n        border: 1px solid dt('menubar.submenu.border.color');\n        border-radius: dt('menubar.submenu.border.radius');\n        box-shadow: dt('menubar.submenu.shadow');\n        color: dt('menubar.submenu.color');\n        flex-direction: column;\n        padding: dt('menubar.submenu.padding');\n        gap: dt('menubar.submenu.gap');\n    }\n\n    .p-menubar-submenu .p-menubar-separator {\n        border-block-start: 1px solid dt('menubar.separator.border.color');\n    }\n\n    .p-menubar-submenu .p-menubar-item {\n        position: relative;\n    }\n\n    .p-menubar-submenu > .p-menubar-item-active > .p-menubar-submenu {\n        display: block;\n        left: 100%;\n        top: 0;\n    }\n\n    .p-menubar-end {\n        margin-left: auto;\n        align-self: center;\n    }\n\n    .p-menubar-end:dir(rtl) {\n        margin-left: 0;\n        margin-right: auto;\n    }\n\n    .p-menubar-button {\n        display: none;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        width: dt('menubar.mobile.button.size');\n        height: dt('menubar.mobile.button.size');\n        position: relative;\n        color: dt('menubar.mobile.button.color');\n        border: 0 none;\n        background: transparent;\n        border-radius: dt('menubar.mobile.button.border.radius');\n        transition:\n            background dt('menubar.transition.duration'),\n            color dt('menubar.transition.duration'),\n            outline-color dt('menubar.transition.duration');\n        outline-color: transparent;\n    }\n\n    .p-menubar-button:hover {\n        color: dt('menubar.mobile.button.hover.color');\n        background: dt('menubar.mobile.button.hover.background');\n    }\n\n    .p-menubar-button:focus-visible {\n        box-shadow: dt('menubar.mobile.button.focus.ring.shadow');\n        outline: dt('menubar.mobile.button.focus.ring.width') dt('menubar.mobile.button.focus.ring.style') dt('menubar.mobile.button.focus.ring.color');\n        outline-offset: dt('menubar.mobile.button.focus.ring.offset');\n    }\n\n    .p-menubar-mobile {\n        position: relative;\n    }\n\n    .p-menubar-mobile .p-menubar-button {\n        display: flex;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list {\n        position: absolute;\n        display: none;\n        width: 100%;\n        flex-direction: column;\n        top: 100%;\n        left: 0;\n        z-index: 1;\n        padding: dt('menubar.submenu.padding');\n        background: dt('menubar.submenu.background');\n        border: 1px solid dt('menubar.submenu.border.color');\n        box-shadow: dt('menubar.submenu.shadow');\n        border-radius: dt('menubar.submenu.border.radius');\n        gap: dt('menubar.submenu.gap');\n    }\n\n    .p-menubar-mobile .p-menubar-root-list:dir(rtl) {\n        left: auto;\n        right: 0;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list > .p-menubar-item > .p-menubar-item-content > .p-menubar-item-link {\n        padding: dt('menubar.item.padding');\n    }\n\n    .p-menubar-mobile-active .p-menubar-root-list {\n        display: flex;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list .p-menubar-item {\n        width: 100%;\n        position: static;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list .p-menubar-separator {\n        border-block-start: 1px solid dt('menubar.separator.border.color');\n    }\n\n    .p-menubar-mobile .p-menubar-root-list > .p-menubar-item > .p-menubar-item-content .p-menubar-submenu-icon {\n        margin-left: auto;\n        transition: transform 0.2s;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list > .p-menubar-item > .p-menubar-item-content .p-menubar-submenu-icon:dir(rtl),\n    .p-menubar-mobile .p-menubar-submenu-icon:dir(rtl) {\n        margin-left: 0;\n        margin-right: auto;\n    }\n\n    .p-menubar-mobile .p-menubar-root-list > .p-menubar-item-active > .p-menubar-item-content .p-menubar-submenu-icon {\n        transform: rotate(-180deg);\n    }\n\n    .p-menubar-mobile .p-menubar-submenu .p-menubar-submenu-icon {\n        transition: transform 0.2s;\n        transform: rotate(90deg);\n    }\n\n    .p-menubar-mobile .p-menubar-item-active > .p-menubar-item-content .p-menubar-submenu-icon {\n        transform: rotate(-90deg);\n    }\n\n    .p-menubar-mobile .p-menubar-submenu {\n        width: 100%;\n        position: static;\n        box-shadow: none;\n        border: 0 none;\n        padding-inline-start: dt('menubar.submenu.mobile.indent');\n        padding-inline-end: 0;\n    }\n";
var inlineStyles = {
  submenu: function submenu(_ref2) {
    var instance2 = _ref2.instance, processedItem = _ref2.processedItem;
    return {
      display: instance2.isItemActive(processedItem) ? "flex" : "none"
    };
  }
};
var classes = {
  root: function root5(_ref2) {
    var instance2 = _ref2.instance;
    return ["p-menubar p-component", {
      "p-menubar-mobile": instance2.queryMatches,
      "p-menubar-mobile-active": instance2.mobileActive
    }];
  },
  start: "p-menubar-start",
  button: "p-menubar-button",
  rootList: "p-menubar-root-list",
  item: function item(_ref3) {
    var instance2 = _ref3.instance, processedItem = _ref3.processedItem;
    return ["p-menubar-item", {
      "p-menubar-item-active": instance2.isItemActive(processedItem),
      "p-focus": instance2.isItemFocused(processedItem),
      "p-disabled": instance2.isItemDisabled(processedItem)
    }];
  },
  itemContent: "p-menubar-item-content",
  itemLink: "p-menubar-item-link",
  itemIcon: "p-menubar-item-icon",
  itemLabel: "p-menubar-item-label",
  submenuIcon: "p-menubar-submenu-icon",
  submenu: "p-menubar-submenu",
  separator: "p-menubar-separator",
  end: "p-menubar-end"
};
var MenubarStyle = BaseStyle.extend({
  name: "menubar",
  style,
  classes,
  inlineStyles
});
var script$4 = {
  name: "AngleDownIcon",
  "extends": script$j
};
function _toConsumableArray$1(r2) {
  return _arrayWithoutHoles$1(r2) || _iterableToArray$1(r2) || _unsupportedIterableToArray$1(r2) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$1(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$1(r2, a2) : void 0;
  }
}
function _iterableToArray$1(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles$1(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$1(r2);
}
function _arrayLikeToArray$1(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$1(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$4.render = render$3;
var script$3 = {
  name: "AngleRightIcon",
  "extends": script$j
};
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$3.render = render$2;
var script$2 = {
  name: "BaseMenubar",
  "extends": script$k,
  props: {
    model: {
      type: Array,
      "default": null
    },
    buttonProps: {
      type: null,
      "default": null
    },
    breakpoint: {
      type: String,
      "default": "960px"
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: MenubarStyle,
  provide: function provide8() {
    return {
      $pcMenubar: this,
      $parentInstance: this
    };
  }
};
var script$1 = {
  name: "MenubarSub",
  hostName: "Menubar",
  "extends": script$k,
  emits: ["item-mouseenter", "item-click", "item-mousemove"],
  props: {
    items: {
      type: Array,
      "default": null
    },
    root: {
      type: Boolean,
      "default": false
    },
    popup: {
      type: Boolean,
      "default": false
    },
    mobileActive: {
      type: Boolean,
      "default": false
    },
    templates: {
      type: Object,
      "default": null
    },
    level: {
      type: Number,
      "default": 0
    },
    menuId: {
      type: String,
      "default": null
    },
    focusedItemId: {
      type: String,
      "default": null
    },
    activeItemPath: {
      type: Object,
      "default": null
    }
  },
  list: null,
  methods: {
    getItemId: function getItemId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key);
    },
    getItemKey: function getItemKey(processedItem) {
      return this.getItemId(processedItem);
    },
    getItemProp: function getItemProp(processedItem, name, params) {
      return processedItem && processedItem.item ? m$6(processedItem.item[name], params) : void 0;
    },
    getItemLabel: function getItemLabel(processedItem) {
      return this.getItemProp(processedItem, "label");
    },
    getItemLabelId: function getItemLabelId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key, "_label");
    },
    getPTOptions: function getPTOptions2(processedItem, index2, key) {
      return this.ptm(key, {
        context: {
          item: processedItem.item,
          index: index2,
          active: this.isItemActive(processedItem),
          focused: this.isItemFocused(processedItem),
          disabled: this.isItemDisabled(processedItem),
          level: this.level
        }
      });
    },
    isItemActive: function isItemActive(processedItem) {
      return this.activeItemPath.some(function(path) {
        return path.key === processedItem.key;
      });
    },
    isItemVisible: function isItemVisible(processedItem) {
      return this.getItemProp(processedItem, "visible") !== false;
    },
    isItemDisabled: function isItemDisabled(processedItem) {
      return this.getItemProp(processedItem, "disabled");
    },
    isItemFocused: function isItemFocused(processedItem) {
      return this.focusedItemId === this.getItemId(processedItem);
    },
    isItemGroup: function isItemGroup(processedItem) {
      return s$e(processedItem.items);
    },
    onItemClick: function onItemClick(event, processedItem) {
      this.getItemProp(processedItem, "command", {
        originalEvent: event,
        item: processedItem.item
      });
      this.$emit("item-click", {
        originalEvent: event,
        processedItem,
        isFocus: true
      });
    },
    onItemMouseEnter: function onItemMouseEnter(event, processedItem) {
      this.$emit("item-mouseenter", {
        originalEvent: event,
        processedItem
      });
    },
    onItemMouseMove: function onItemMouseMove(event, processedItem) {
      this.$emit("item-mousemove", {
        originalEvent: event,
        processedItem
      });
    },
    getAriaPosInset: function getAriaPosInset(index2) {
      return index2 - this.calculateAriaSetSize.slice(0, index2).length + 1;
    },
    getMenuItemProps: function getMenuItemProps(processedItem, index2) {
      return {
        action: mergeProps({
          "class": this.cx("itemLink"),
          tabindex: -1
        }, this.getPTOptions(processedItem, index2, "itemLink")),
        icon: mergeProps({
          "class": [this.cx("itemIcon"), this.getItemProp(processedItem, "icon")]
        }, this.getPTOptions(processedItem, index2, "itemIcon")),
        label: mergeProps({
          "class": this.cx("itemLabel")
        }, this.getPTOptions(processedItem, index2, "itemLabel")),
        submenuicon: mergeProps({
          "class": this.cx("submenuIcon")
        }, this.getPTOptions(processedItem, index2, "submenuIcon"))
      };
    }
  },
  computed: {
    calculateAriaSetSize: function calculateAriaSetSize() {
      var _this = this;
      return this.items.filter(function(processedItem) {
        return _this.isItemVisible(processedItem) && _this.getItemProp(processedItem, "separator");
      });
    },
    getAriaSetSize: function getAriaSetSize() {
      var _this2 = this;
      return this.items.filter(function(processedItem) {
        return _this2.isItemVisible(processedItem) && !_this2.getItemProp(processedItem, "separator");
      }).length;
    }
  },
  components: {
    AngleRightIcon: script$3,
    AngleDownIcon: script$4
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$1$1 = ["id", "aria-label", "aria-disabled", "aria-expanded", "aria-haspopup", "aria-setsize", "aria-posinset", "data-p-active", "data-p-focused", "data-p-disabled"];
var _hoisted_2$d = ["onClick", "onMouseenter", "onMousemove"];
var _hoisted_3$c = ["href", "target"];
var _hoisted_4$6 = ["id"];
var _hoisted_5$6 = ["id"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_MenubarSub = resolveComponent("MenubarSub", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("ul", mergeProps({
    "class": $props.level === 0 ? _ctx.cx("rootList") : _ctx.cx("submenu")
  }, $props.level === 0 ? _ctx.ptm("rootList") : _ctx.ptm("submenu")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.items, function(processedItem, index2) {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.getItemKey(processedItem)
    }, [$options.isItemVisible(processedItem) && !$options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
      key: 0,
      id: $options.getItemId(processedItem),
      style: $options.getItemProp(processedItem, "style"),
      "class": [_ctx.cx("item", {
        processedItem
      }), $options.getItemProp(processedItem, "class")],
      role: "menuitem",
      "aria-label": $options.getItemLabel(processedItem),
      "aria-disabled": $options.isItemDisabled(processedItem) || void 0,
      "aria-expanded": $options.isItemGroup(processedItem) ? $options.isItemActive(processedItem) : void 0,
      "aria-haspopup": $options.isItemGroup(processedItem) && !$options.getItemProp(processedItem, "to") ? "menu" : void 0,
      "aria-setsize": $options.getAriaSetSize,
      "aria-posinset": $options.getAriaPosInset(index2)
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "item"), {
      "data-p-active": $options.isItemActive(processedItem),
      "data-p-focused": $options.isItemFocused(processedItem),
      "data-p-disabled": $options.isItemDisabled(processedItem)
    }), [createBaseVNode("div", mergeProps({
      "class": _ctx.cx("itemContent"),
      onClick: function onClick2($event) {
        return $options.onItemClick($event, processedItem);
      },
      onMouseenter: function onMouseenter($event) {
        return $options.onItemMouseEnter($event, processedItem);
      },
      onMousemove: function onMousemove($event) {
        return $options.onItemMouseMove($event, processedItem);
      }
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "itemContent")), [!$props.templates.item ? withDirectives((openBlock(), createElementBlock("a", mergeProps({
      key: 0,
      href: $options.getItemProp(processedItem, "url"),
      "class": _ctx.cx("itemLink"),
      target: $options.getItemProp(processedItem, "target"),
      tabindex: "-1"
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "itemLink")), [$props.templates.itemicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.itemicon), {
      key: 0,
      item: processedItem.item,
      "class": normalizeClass(_ctx.cx("itemIcon"))
    }, null, 8, ["item", "class"])) : $options.getItemProp(processedItem, "icon") ? (openBlock(), createElementBlock("span", mergeProps({
      key: 1,
      "class": [_ctx.cx("itemIcon"), $options.getItemProp(processedItem, "icon")]
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "itemIcon")), null, 16)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
      id: $options.getItemLabelId(processedItem),
      "class": _ctx.cx("itemLabel")
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "itemLabel")), toDisplayString($options.getItemLabel(processedItem)), 17, _hoisted_4$6), $options.getItemProp(processedItem, "items") ? (openBlock(), createElementBlock(Fragment, {
      key: 2
    }, [$props.templates.submenuicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.submenuicon), {
      key: 0,
      root: $props.root,
      active: $options.isItemActive(processedItem),
      "class": normalizeClass(_ctx.cx("submenuIcon"))
    }, null, 8, ["root", "active", "class"])) : (openBlock(), createBlock(resolveDynamicComponent($props.root ? "AngleDownIcon" : "AngleRightIcon"), mergeProps({
      key: 1,
      "class": _ctx.cx("submenuIcon")
    }, {
      ref_for: true
    }, $options.getPTOptions(processedItem, index2, "submenuIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true)], 16, _hoisted_3$c)), [[_directive_ripple]]) : (openBlock(), createBlock(resolveDynamicComponent($props.templates.item), {
      key: 1,
      item: processedItem.item,
      root: $props.root,
      hasSubmenu: $options.getItemProp(processedItem, "items"),
      label: $options.getItemLabel(processedItem),
      props: $options.getMenuItemProps(processedItem, index2)
    }, null, 8, ["item", "root", "hasSubmenu", "label", "props"]))], 16, _hoisted_2$d), $options.isItemVisible(processedItem) && $options.isItemGroup(processedItem) ? (openBlock(), createBlock(_component_MenubarSub, {
      key: 0,
      id: $options.getItemId(processedItem) + "_list",
      menuId: $props.menuId,
      role: "menu",
      style: normalizeStyle(_ctx.sx("submenu", true, {
        processedItem
      })),
      focusedItemId: $props.focusedItemId,
      items: processedItem.items,
      mobileActive: $props.mobileActive,
      activeItemPath: $props.activeItemPath,
      templates: $props.templates,
      level: $props.level + 1,
      "aria-labelledby": $options.getItemLabelId(processedItem),
      pt: _ctx.pt,
      unstyled: _ctx.unstyled,
      onItemClick: _cache[0] || (_cache[0] = function($event) {
        return _ctx.$emit("item-click", $event);
      }),
      onItemMouseenter: _cache[1] || (_cache[1] = function($event) {
        return _ctx.$emit("item-mouseenter", $event);
      }),
      onItemMousemove: _cache[2] || (_cache[2] = function($event) {
        return _ctx.$emit("item-mousemove", $event);
      })
    }, null, 8, ["id", "menuId", "style", "focusedItemId", "items", "mobileActive", "activeItemPath", "templates", "level", "aria-labelledby", "pt", "unstyled"])) : createCommentVNode("", true)], 16, _hoisted_1$1$1)) : createCommentVNode("", true), $options.isItemVisible(processedItem) && $options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
      key: 1,
      id: $options.getItemId(processedItem),
      "class": [_ctx.cx("separator"), $options.getItemProp(processedItem, "class")],
      style: $options.getItemProp(processedItem, "style"),
      role: "separator"
    }, {
      ref_for: true
    }, _ctx.ptm("separator")), null, 16, _hoisted_5$6)) : createCommentVNode("", true)], 64);
  }), 128))], 16);
}
script$1.render = render$1;
var script = {
  name: "Menubar",
  "extends": script$2,
  inheritAttrs: false,
  emits: ["focus", "blur"],
  matchMediaListener: null,
  data: function data5() {
    return {
      mobileActive: false,
      focused: false,
      focusedItemInfo: {
        index: -1,
        level: 0,
        parentKey: ""
      },
      activeItemPath: [],
      dirty: false,
      query: null,
      queryMatches: false
    };
  },
  watch: {
    activeItemPath: function activeItemPath(newPath) {
      if (s$e(newPath)) {
        this.bindOutsideClickListener();
        this.bindResizeListener();
      } else {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
      }
    }
  },
  outsideClickListener: null,
  container: null,
  menubar: null,
  mounted: function mounted6() {
    this.bindMatchMediaListener();
  },
  beforeUnmount: function beforeUnmount4() {
    this.mobileActive = false;
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    this.unbindMatchMediaListener();
    if (this.container) {
      x$2.clear(this.container);
    }
    this.container = null;
  },
  methods: {
    getItemProp: function getItemProp2(item2, name) {
      return item2 ? m$6(item2[name]) : void 0;
    },
    getItemLabel: function getItemLabel2(item2) {
      return this.getItemProp(item2, "label");
    },
    isItemDisabled: function isItemDisabled2(item2) {
      return this.getItemProp(item2, "disabled");
    },
    isItemVisible: function isItemVisible2(item2) {
      return this.getItemProp(item2, "visible") !== false;
    },
    isItemGroup: function isItemGroup2(item2) {
      return s$e(this.getItemProp(item2, "items"));
    },
    isItemSeparator: function isItemSeparator(item2) {
      return this.getItemProp(item2, "separator");
    },
    getProccessedItemLabel: function getProccessedItemLabel(processedItem) {
      return processedItem ? this.getItemLabel(processedItem.item) : void 0;
    },
    isProccessedItemGroup: function isProccessedItemGroup(processedItem) {
      return processedItem && s$e(processedItem.items);
    },
    toggle: function toggle2(event) {
      var _this = this;
      if (this.mobileActive) {
        this.mobileActive = false;
        x$2.clear(this.menubar);
        this.hide();
      } else {
        this.mobileActive = true;
        x$2.set("menu", this.menubar, this.$primevue.config.zIndex.menu);
        setTimeout(function() {
          _this.show();
        }, 1);
      }
      this.bindOutsideClickListener();
      event.preventDefault();
    },
    show: function show3() {
      bt$1(this.menubar);
    },
    hide: function hide3(event, isFocus) {
      var _this2 = this;
      if (this.mobileActive) {
        this.mobileActive = false;
        setTimeout(function() {
          bt$1(_this2.$refs.menubutton);
        }, 0);
      }
      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      isFocus && bt$1(this.menubar);
      this.dirty = false;
    },
    onFocus: function onFocus2(event) {
      this.focused = true;
      this.focusedItemInfo = this.focusedItemInfo.index !== -1 ? this.focusedItemInfo : {
        index: this.findFirstFocusedItemIndex(),
        level: 0,
        parentKey: ""
      };
      this.$emit("focus", event);
    },
    onBlur: function onBlur2(event) {
      this.focused = false;
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      this.searchValue = "";
      this.dirty = false;
      this.$emit("blur", event);
    },
    onKeyDown: function onKeyDown2(event) {
      var metaKey = event.metaKey || event.ctrlKey;
      switch (event.code) {
        case "ArrowDown":
          this.onArrowDownKey(event);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event);
          break;
        case "ArrowLeft":
          this.onArrowLeftKey(event);
          break;
        case "ArrowRight":
          this.onArrowRightKey(event);
          break;
        case "Home":
          this.onHomeKey(event);
          break;
        case "End":
          this.onEndKey(event);
          break;
        case "Space":
          this.onSpaceKey(event);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event);
          break;
        case "Escape":
          this.onEscapeKey(event);
          break;
        case "Tab":
          this.onTabKey(event);
          break;
        case "PageDown":
        case "PageUp":
        case "Backspace":
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && J$3(event.key)) {
            this.searchItems(event, event.key);
          }
          break;
      }
    },
    onItemChange: function onItemChange(event, type) {
      var processedItem = event.processedItem, isFocus = event.isFocus;
      if (l$j(processedItem)) return;
      var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey, items = processedItem.items;
      var grouped = s$e(items);
      var activeItemPath2 = this.activeItemPath.filter(function(p2) {
        return p2.parentKey !== parentKey && p2.parentKey !== key;
      });
      grouped && activeItemPath2.push(processedItem);
      this.focusedItemInfo = {
        index: index2,
        level,
        parentKey
      };
      grouped && (this.dirty = true);
      isFocus && bt$1(this.menubar);
      if (type === "hover" && this.queryMatches) {
        return;
      }
      this.activeItemPath = activeItemPath2;
    },
    onItemClick: function onItemClick2(event) {
      var originalEvent = event.originalEvent, processedItem = event.processedItem;
      var grouped = this.isProccessedItemGroup(processedItem);
      var root6 = l$j(processedItem.parent);
      var selected = this.isSelected(processedItem);
      if (selected) {
        var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey;
        this.activeItemPath = this.activeItemPath.filter(function(p2) {
          return key !== p2.key && key.startsWith(p2.key);
        });
        this.focusedItemInfo = {
          index: index2,
          level,
          parentKey
        };
        this.dirty = !root6;
        bt$1(this.menubar);
      } else {
        if (grouped) {
          this.onItemChange(event);
        } else {
          var rootProcessedItem = root6 ? processedItem : this.activeItemPath.find(function(p2) {
            return p2.parentKey === "";
          });
          this.hide(originalEvent);
          this.changeFocusedItemIndex(originalEvent, rootProcessedItem ? rootProcessedItem.index : -1);
          this.mobileActive = false;
          bt$1(this.menubar);
        }
      }
    },
    onItemMouseEnter: function onItemMouseEnter2(event) {
      if (this.dirty) {
        this.onItemChange(event, "hover");
      }
    },
    onItemMouseMove: function onItemMouseMove2(event) {
      if (this.focused) {
        this.changeFocusedItemIndex(event, event.processedItem.index);
      }
    },
    menuButtonClick: function menuButtonClick(event) {
      this.toggle(event);
    },
    menuButtonKeydown: function menuButtonKeydown(event) {
      (event.code === "Enter" || event.code === "NumpadEnter" || event.code === "Space") && this.menuButtonClick(event);
    },
    onArrowDownKey: function onArrowDownKey(event) {
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var root6 = processedItem ? l$j(processedItem.parent) : null;
      if (root6) {
        var grouped = this.isProccessedItemGroup(processedItem);
        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          this.onArrowRightKey(event);
        }
      } else {
        var itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
      }
      event.preventDefault();
    },
    onArrowUpKey: function onArrowUpKey(event) {
      var _this3 = this;
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var root6 = l$j(processedItem.parent);
      if (root6) {
        var grouped = this.isProccessedItemGroup(processedItem);
        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          var itemIndex = this.findLastItemIndex();
          this.changeFocusedItemIndex(event, itemIndex);
        }
      } else {
        var parentItem = this.activeItemPath.find(function(p2) {
          return p2.key === processedItem.parentKey;
        });
        if (this.focusedItemInfo.index === 0) {
          this.focusedItemInfo = {
            index: -1,
            parentKey: parentItem ? parentItem.parentKey : ""
          };
          this.searchValue = "";
          this.onArrowLeftKey(event);
          this.activeItemPath = this.activeItemPath.filter(function(p2) {
            return p2.parentKey !== _this3.focusedItemInfo.parentKey;
          });
        } else {
          var _itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
          this.changeFocusedItemIndex(event, _itemIndex);
        }
      }
      event.preventDefault();
    },
    onArrowLeftKey: function onArrowLeftKey(event) {
      var _this4 = this;
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var parentItem = processedItem ? this.activeItemPath.find(function(p2) {
        return p2.key === processedItem.parentKey;
      }) : null;
      if (parentItem) {
        this.onItemChange({
          originalEvent: event,
          processedItem: parentItem
        });
        this.activeItemPath = this.activeItemPath.filter(function(p2) {
          return p2.parentKey !== _this4.focusedItemInfo.parentKey;
        });
        event.preventDefault();
      } else {
        var itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
        event.preventDefault();
      }
    },
    onArrowRightKey: function onArrowRightKey(event) {
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var parentItem = processedItem ? this.activeItemPath.find(function(p2) {
        return p2.key === processedItem.parentKey;
      }) : null;
      if (parentItem) {
        var grouped = this.isProccessedItemGroup(processedItem);
        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          this.onArrowDownKey(event);
        }
      } else {
        var itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
        event.preventDefault();
      }
    },
    onHomeKey: function onHomeKey(event) {
      this.changeFocusedItemIndex(event, this.findFirstItemIndex());
      event.preventDefault();
    },
    onEndKey: function onEndKey(event) {
      this.changeFocusedItemIndex(event, this.findLastItemIndex());
      event.preventDefault();
    },
    onEnterKey: function onEnterKey(event) {
      if (this.focusedItemInfo.index !== -1) {
        var element = z$2(this.menubar, 'li[id="'.concat("".concat(this.focusedItemId), '"]'));
        var anchorElement = element && z$2(element, 'a[data-pc-section="itemlink"]');
        anchorElement ? anchorElement.click() : element && element.click();
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      }
      event.preventDefault();
    },
    onSpaceKey: function onSpaceKey(event) {
      this.onEnterKey(event);
    },
    onEscapeKey: function onEscapeKey(event) {
      if (this.focusedItemInfo.level !== 0) {
        var _focusedItemInfo = this.focusedItemInfo;
        this.hide(event, false);
        this.focusedItemInfo = {
          index: Number(_focusedItemInfo.parentKey.split("_")[0]),
          level: 0,
          parentKey: ""
        };
      }
      event.preventDefault();
    },
    onTabKey: function onTabKey(event) {
      if (this.focusedItemInfo.index !== -1) {
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && this.onItemChange({
          originalEvent: event,
          processedItem
        });
      }
      this.hide();
    },
    bindOutsideClickListener: function bindOutsideClickListener2() {
      var _this5 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event) {
          var isOutsideContainer = _this5.container && !_this5.container.contains(event.target);
          var isOutsideTarget = !(_this5.target && (_this5.target === event.target || _this5.target.contains(event.target)));
          if (isOutsideContainer && isOutsideTarget) {
            _this5.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener, true);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener2() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener, true);
        this.outsideClickListener = null;
      }
    },
    bindResizeListener: function bindResizeListener2() {
      var _this6 = this;
      if (!this.resizeListener) {
        this.resizeListener = function(event) {
          if (!Yt$2()) {
            _this6.hide(event, true);
          }
          _this6.mobileActive = false;
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener2() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    },
    bindMatchMediaListener: function bindMatchMediaListener() {
      var _this7 = this;
      if (!this.matchMediaListener) {
        var query = matchMedia("(max-width: ".concat(this.breakpoint, ")"));
        this.query = query;
        this.queryMatches = query.matches;
        this.matchMediaListener = function() {
          _this7.queryMatches = query.matches;
          _this7.mobileActive = false;
        };
        this.query.addEventListener("change", this.matchMediaListener);
      }
    },
    unbindMatchMediaListener: function unbindMatchMediaListener() {
      if (this.matchMediaListener) {
        this.query.removeEventListener("change", this.matchMediaListener);
        this.matchMediaListener = null;
      }
    },
    isItemMatched: function isItemMatched(processedItem) {
      var _this$getProccessedIt;
      return this.isValidItem(processedItem) && ((_this$getProccessedIt = this.getProccessedItemLabel(processedItem)) === null || _this$getProccessedIt === void 0 ? void 0 : _this$getProccessedIt.toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase()));
    },
    isValidItem: function isValidItem(processedItem) {
      return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item) && this.isItemVisible(processedItem.item);
    },
    isValidSelectedItem: function isValidSelectedItem(processedItem) {
      return this.isValidItem(processedItem) && this.isSelected(processedItem);
    },
    isSelected: function isSelected(processedItem) {
      return this.activeItemPath.some(function(p2) {
        return p2.key === processedItem.key;
      });
    },
    findFirstItemIndex: function findFirstItemIndex() {
      var _this8 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this8.isValidItem(processedItem);
      });
    },
    findLastItemIndex: function findLastItemIndex() {
      var _this9 = this;
      return M$3(this.visibleItems, function(processedItem) {
        return _this9.isValidItem(processedItem);
      });
    },
    findNextItemIndex: function findNextItemIndex(index2) {
      var _this0 = this;
      var matchedItemIndex = index2 < this.visibleItems.length - 1 ? this.visibleItems.slice(index2 + 1).findIndex(function(processedItem) {
        return _this0.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex + index2 + 1 : index2;
    },
    findPrevItemIndex: function findPrevItemIndex(index2) {
      var _this1 = this;
      var matchedItemIndex = index2 > 0 ? M$3(this.visibleItems.slice(0, index2), function(processedItem) {
        return _this1.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex : index2;
    },
    findSelectedItemIndex: function findSelectedItemIndex() {
      var _this10 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this10.isValidSelectedItem(processedItem);
      });
    },
    findFirstFocusedItemIndex: function findFirstFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
    },
    findLastFocusedItemIndex: function findLastFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
    },
    searchItems: function searchItems(event, _char) {
      var _this11 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var itemIndex = -1;
      var matched = false;
      if (this.focusedItemInfo.index !== -1) {
        itemIndex = this.visibleItems.slice(this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this11.isItemMatched(processedItem);
        });
        itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this11.isItemMatched(processedItem);
        }) : itemIndex + this.focusedItemInfo.index;
      } else {
        itemIndex = this.visibleItems.findIndex(function(processedItem) {
          return _this11.isItemMatched(processedItem);
        });
      }
      if (itemIndex !== -1) {
        matched = true;
      }
      if (itemIndex === -1 && this.focusedItemInfo.index === -1) {
        itemIndex = this.findFirstFocusedItemIndex();
      }
      if (itemIndex !== -1) {
        this.changeFocusedItemIndex(event, itemIndex);
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this11.searchValue = "";
        _this11.searchTimeout = null;
      }, 500);
      return matched;
    },
    changeFocusedItemIndex: function changeFocusedItemIndex(event, index2) {
      if (this.focusedItemInfo.index !== index2) {
        this.focusedItemInfo.index = index2;
        this.scrollInView();
      }
    },
    scrollInView: function scrollInView() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      var id = index2 !== -1 ? "".concat(this.$id, "_").concat(index2) : this.focusedItemId;
      var element = z$2(this.menubar, 'li[id="'.concat(id, '"]'));
      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: "nearest",
          inline: "start"
        });
      }
    },
    createProcessedItems: function createProcessedItems(items) {
      var _this12 = this;
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var parent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parentKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var processedItems2 = [];
      items && items.forEach(function(item2, index2) {
        var key = (parentKey !== "" ? parentKey + "_" : "") + index2;
        var newItem = {
          item: item2,
          index: index2,
          level,
          key,
          parent,
          parentKey
        };
        newItem["items"] = _this12.createProcessedItems(item2.items, level + 1, newItem, key);
        processedItems2.push(newItem);
      });
      return processedItems2;
    },
    containerRef: function containerRef2(el) {
      this.container = el;
    },
    menubarRef: function menubarRef(el) {
      this.menubar = el ? el.$el : void 0;
    }
  },
  computed: {
    processedItems: function processedItems() {
      return this.createProcessedItems(this.model || []);
    },
    visibleItems: function visibleItems() {
      var _this13 = this;
      var processedItem = this.activeItemPath.find(function(p2) {
        return p2.key === _this13.focusedItemInfo.parentKey;
      });
      return processedItem ? processedItem.items : this.processedItems;
    },
    focusedItemId: function focusedItemId() {
      return this.focusedItemInfo.index !== -1 ? "".concat(this.$id).concat(s$e(this.focusedItemInfo.parentKey) ? "_" + this.focusedItemInfo.parentKey : "", "_").concat(this.focusedItemInfo.index) : null;
    }
  },
  components: {
    MenubarSub: script$1,
    BarsIcon: script$5
  }
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var _hoisted_1$g = ["aria-haspopup", "aria-expanded", "aria-controls", "aria-label"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_BarsIcon = resolveComponent("BarsIcon");
  var _component_MenubarSub = resolveComponent("MenubarSub");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: $options.containerRef,
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.start ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("start")
  }, _ctx.ptm("start")), [renderSlot(_ctx.$slots, "start")], 16)) : createCommentVNode("", true), renderSlot(_ctx.$slots, _ctx.$slots.button ? "button" : "menubutton", {
    id: _ctx.$id,
    "class": normalizeClass(_ctx.cx("button")),
    toggleCallback: function toggleCallback(event) {
      return $options.menuButtonClick(event);
    }
  }, function() {
    var _ctx$$primevue$config;
    return [_ctx.model && _ctx.model.length > 0 ? (openBlock(), createElementBlock("a", mergeProps({
      key: 0,
      ref: "menubutton",
      role: "button",
      tabindex: "0",
      "class": _ctx.cx("button"),
      "aria-haspopup": _ctx.model.length && _ctx.model.length > 0 ? true : false,
      "aria-expanded": $data.mobileActive,
      "aria-controls": _ctx.$id,
      "aria-label": (_ctx$$primevue$config = _ctx.$primevue.config.locale.aria) === null || _ctx$$primevue$config === void 0 ? void 0 : _ctx$$primevue$config.navigation,
      onClick: _cache[0] || (_cache[0] = function($event) {
        return $options.menuButtonClick($event);
      }),
      onKeydown: _cache[1] || (_cache[1] = function($event) {
        return $options.menuButtonKeydown($event);
      })
    }, _objectSpread(_objectSpread({}, _ctx.buttonProps), _ctx.ptm("button"))), [renderSlot(_ctx.$slots, _ctx.$slots.buttonicon ? "buttonicon" : "menubuttonicon", {}, function() {
      return [createVNode(_component_BarsIcon, normalizeProps(guardReactiveProps(_ctx.ptm("buttonicon"))), null, 16)];
    })], 16, _hoisted_1$g)) : createCommentVNode("", true)];
  }), createVNode(_component_MenubarSub, {
    ref: $options.menubarRef,
    id: _ctx.$id + "_list",
    role: "menubar",
    items: $options.processedItems,
    templates: _ctx.$slots,
    root: true,
    mobileActive: $data.mobileActive,
    tabindex: "0",
    "aria-activedescendant": $data.focused ? $options.focusedItemId : void 0,
    menuId: _ctx.$id,
    focusedItemId: $data.focused ? $options.focusedItemId : void 0,
    activeItemPath: $data.activeItemPath,
    level: 0,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled,
    onFocus: $options.onFocus,
    onBlur: $options.onBlur,
    onKeydown: $options.onKeyDown,
    onItemClick: $options.onItemClick,
    onItemMouseenter: $options.onItemMouseEnter,
    onItemMousemove: $options.onItemMouseMove
  }, null, 8, ["id", "items", "templates", "mobileActive", "aria-activedescendant", "menuId", "focusedItemId", "activeItemPath", "aria-labelledby", "aria-label", "pt", "unstyled", "onFocus", "onBlur", "onKeydown", "onItemClick", "onItemMouseenter", "onItemMousemove"]), _ctx.$slots.end ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("end")
  }, _ctx.ptm("end")), [renderSlot(_ctx.$slots, "end")], 16)) : createCommentVNode("", true)], 16);
}
script.render = render;
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "Menu",
  setup(__props) {
    const indexStore = useIndexStore(), kofi = useTemplateRef("kofi"), kofiToggle = (event) => {
      kofi.value?.toggle(event);
    }, router2 = useRouter();
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script), {
        model: [
          {
            label: "Home",
            command: () => {
              unref(router2).push("/");
            }
          },
          {
            label: "Progress",
            items: [
              {
                label: "Level Up",
                command: () => {
                  unref(router2).push("/LevelProgression");
                }
              },
              {
                label: "Items At Level",
                command: () => {
                  unref(router2).push("/ItemsSummary");
                }
              }
            ]
          },
          {
            label: "Items",
            items: [
              {
                label: "WaniKani",
                command: () => {
                  unref(router2).push("/ItemDetailsWaniKani");
                }
              },
              {
                label: "JLPT",
                command: () => {
                  unref(router2).push("/ItemDetailsJLPT");
                }
              },
              {
                label: "Joyo",
                command: () => {
                  unref(router2).push("/ItemDetailsJoyo");
                }
              }
            ]
          }
        ]
      }, {
        end: withCtx(() => [
          createVNode(unref(script$6), {
            ref_key: "kofi",
            ref: kofi
          }, {
            default: withCtx(() => [..._cache[0] || (_cache[0] = [
              createBaseVNode("iframe", {
                id: "kofiframe",
                src: "https://ko-fi.com/daisukejigen/?hidefeed=true&widget=true&embed=true&preview=true",
                style: { "border": "none", "width": "100%", "padding": "4px", "background": "#f9f9f9" },
                height: "712",
                title: "daisukejigen"
              }, null, -1)
            ])]),
            _: 1
          }, 512),
          createBaseVNode("div", null, [
            createVNode(unref(script$g), {
              onClick: kofiToggle,
              outlined: "",
              rounded: ""
            }, {
              default: withCtx(() => [
                createVNode(unref(script$8), {
                  src: unref(indexStore).kofiImage,
                  alt: "ko-fi",
                  width: "16"
                }, null, 8, ["src"])
              ]),
              _: 1
            })
          ])
        ]),
        _: 1
      }, 8, ["model"]);
    };
  }
});
const _hoisted_1$f = { class: "sitemap__section" };
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "StatsButton",
  setup(__props) {
    const changelogStore = useChangelogStore(), indexStore = useIndexStore();
    onMounted(() => {
    });
    const toggle3 = () => {
      changelogStore.showLog = false;
      const stats = document.getElementById("divStats");
      const wk = document.getElementsByClassName("site-content-container")[0];
      Array.from([stats, wk]).forEach((element) => {
        if (element != null) {
          if (element.classList.contains("hidden")) {
            element.classList.remove("hidden");
          } else {
            element.classList.add("hidden");
          }
        }
      });
      indexStore.visible = !indexStore.visible;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", _hoisted_1$f, [
        createBaseVNode("button", {
          class: "sitemap__section-header sitemap__section-header--stats",
          onClick: toggle3
        }, [..._cache[0] || (_cache[0] = [
          createBaseVNode("span", null, "Stats", -1)
        ])])
      ]);
    };
  }
});
const StatsButton = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-95c4d51b"]]);
const addMenuItem = () => {
  const li2 = document.createElement("li");
  li2.classList.add("sitemap__section");
  li2.id = "sitemapStats";
  document.querySelectorAll("#sitemap .sitemap__section.sitemap--divider")[0]?.before(li2);
};
const scriptUrl = "https://update.greasyfork.org/scripts/501980/1426289/Wanikani%20Open%20Framework%20Turbo%20Events.user.js", setUpListeners = (callback) => {
  wkof.load_script(
    scriptUrl,
    /* use_cache */
    true
  );
  wkof.ready("TurboEvents").then(() => {
    console.log("turbo events ready");
    const urls = [
      //@ts-expect-error cannot find name wkof
      wkof.turbo.common.locations.reviews,
      //@ts-expect-error cannot find name wkof
      wkof.turbo.common.locations.lessons_quiz,
      /^https:\/\/www\.wanikani\.com\/recent-mistakes\/[\d-]+\/quiz.*\/?$/,
      /^https:\/\/www\.wanikani\.com\/subjects\/extra_study.*$/
    ];
    wkof.turbo.add_typical_page_listener(callback, urls);
    wkof.turbo.on.common.dashboard(() => {
      nextTick(() => {
        const indexStore = useIndexStore();
        indexStore.dashboardLoaded = false;
        addMenuItem();
        indexStore.dashboardLoaded = true;
      });
    });
  });
};
class cOverallNumbers {
  kanji;
  radicals;
  vocab;
  constructor() {
    this.kanji = new cOverallNumbersPiece();
    this.radicals = new cOverallNumbersPiece();
    this.vocab = new cOverallNumbersPiece();
  }
  accuracy() {
    return this.totalCorrect() / this.total();
  }
  meaning() {
    return this.meaningCorrect() + this.meaningIncorrect();
  }
  meaningAccuracy() {
    return this.meaningCorrect() / this.meaning();
  }
  meaningCorrect() {
    return this.kanji.meaning.correct + this.radicals.meaning.correct + this.vocab.meaning.correct;
  }
  meaningIncorrect() {
    return this.kanji.meaning.incorrect + this.radicals.meaning.incorrect + this.vocab.meaning.incorrect;
  }
  reading() {
    return this.readingCorrect() + this.readingIncorrect();
  }
  readingAccuracy() {
    return this.readingCorrect() / this.reading();
  }
  readingCorrect() {
    return this.kanji.reading.correct + this.radicals.reading.correct + this.vocab.reading.correct;
  }
  readingIncorrect() {
    return this.kanji.reading.incorrect + this.radicals.reading.incorrect + this.vocab.reading.incorrect;
  }
  total() {
    return this.reading() + this.meaning();
  }
  totalCorrect() {
    return this.meaningCorrect() + this.readingCorrect();
  }
  totalIncorrect() {
    return this.meaningIncorrect() + this.readingIncorrect();
  }
}
class cOverallNumbersPiece {
  meaning;
  reading;
  constructor() {
    this.meaning = new cOverallNumbersSubPiece();
    this.reading = new cOverallNumbersSubPiece();
  }
  accuracy() {
    return (this.reading.correct + this.meaning.correct) / (this.reading.correct + this.reading.incorrect + this.meaning.correct + this.meaning.incorrect);
  }
  meaningAccuracy() {
    return this.meaning.correct / (this.meaning.correct + this.meaning.incorrect);
  }
  readingAccuracy() {
    return this.reading.correct / (this.meaning.correct + this.meaning.incorrect);
  }
}
class cOverallNumbersSubPiece {
  correct;
  incorrect;
  constructor() {
    this.correct = 0;
    this.incorrect = 0;
  }
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const constructFromSymbol = /* @__PURE__ */ Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}
function addMonths(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}
function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function isSameDay(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return +startOfDay(dateLeft_) === +startOfDay(dateRight_);
}
function isDate$1(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
  return !(!isDate$1(date) && typeof date !== "number" || isNaN(+toDate(date)));
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}
function differenceInDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const sign = compareLocalAsc(laterDate_, earlierDate_);
  const difference2 = Math.abs(
    differenceInCalendarDays(laterDate_, earlierDate_)
  );
  laterDate_.setDate(laterDate_.getDate() - sign * difference2);
  const isLastDayNotFull = Number(
    compareLocalAsc(laterDate_, earlierDate_) === -sign
  );
  const result = sign * (difference2 - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function compareLocalAsc(laterDate, earlierDate) {
  const diff = laterDate.getFullYear() - earlierDate.getFullYear() || laterDate.getMonth() - earlierDate.getMonth() || laterDate.getDate() - earlierDate.getDate() || laterDate.getHours() - earlierDate.getHours() || laterDate.getMinutes() - earlierDate.getMinutes() || laterDate.getSeconds() - earlierDate.getSeconds() || laterDate.getMilliseconds() - earlierDate.getMilliseconds();
  if (diff < 0) return -1;
  if (diff > 0) return 1;
  return diff;
}
function endOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function isLastDayOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  return +endOfDay(_date, options) === +endOfMonth(_date, options);
}
function differenceInMonths(laterDate, earlierDate, options) {
  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(workingLaterDate, earlierDate_);
  const difference2 = Math.abs(
    differenceInCalendarMonths(workingLaterDate, earlierDate_)
  );
  if (difference2 < 1) return 0;
  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)
    workingLaterDate.setDate(30);
  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign * difference2);
  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign;
  if (isLastDayOfMonth(laterDate_) && difference2 === 1 && compareAsc(laterDate_, earlierDate_) === 1) {
    isLastMonthNotFull = false;
  }
  const result = sign * (difference2 - +isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(laterDate_, earlierDate_);
  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
  laterDate_.setFullYear(1584);
  earlierDate_.setFullYear(1584);
  const partial = compareAsc(laterDate_, earlierDate_) === -sign;
  const result = sign * (diff - +partial);
  return result === 0 ? 0 : result;
}
function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey$1(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey$1(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date, options?.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}
function parseISO(argument, options) {
  const invalidDate = () => constructFrom(options?.in, NaN);
  const additionalDigits = 2;
  const dateStrings = splitDateString(argument);
  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(+date)) return invalidDate();
  const timestamp = +date;
  let time = 0;
  let offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) return invalidDate();
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) return invalidDate();
  } else {
    const tmpDate = new Date(timestamp + time);
    const result = toDate(0, options?.in);
    result.setFullYear(
      tmpDate.getUTCFullYear(),
      tmpDate.getUTCMonth(),
      tmpDate.getUTCDate()
    );
    result.setHours(
      tmpDate.getUTCHours(),
      tmpDate.getUTCMinutes(),
      tmpDate.getUTCSeconds(),
      tmpDate.getUTCMilliseconds()
    );
    return result;
  }
  return toDate(timestamp + time + offset, options?.in);
}
const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex);
  if (!captures) return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null) return /* @__PURE__ */ new Date(NaN);
  const captures = dateString.match(dateRegex);
  if (!captures) return /* @__PURE__ */ new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN;
  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
const isDateBetweenInclusive = (date, start, end3) => {
  return isSameDay(date, start) || isSameDay(date, end3) || isAfter(date, start) && isBefore(date, end3);
}, percent = (num) => {
  return (num * 100).toFixed(2) + "%";
}, ZeroIfNaN = (num) => Number.isFinite(num) ? num : 0;
function at$1(arr, indices) {
  const result = new Array(indices.length);
  const length = arr.length;
  for (let i2 = 0; i2 < indices.length; i2++) {
    let index2 = indices[i2];
    index2 = Number.isInteger(index2) ? index2 : Math.trunc(index2) || 0;
    if (index2 < 0) {
      index2 += length;
    }
    result[i2] = arr[index2];
  }
  return result;
}
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item2) => !secondSet.has(item2));
}
function flatten(arr, depth = 1) {
  const result = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (let i2 = 0; i2 < arr2.length; i2++) {
      const item2 = arr2[i2];
      if (Array.isArray(item2) && currentDepth < flooredDepth) {
        recursive(item2, currentDepth + 1);
      } else {
        result.push(item2);
      }
    }
  };
  recursive(arr, 0);
  return result;
}
function compareValues(a2, b2, order) {
  if (a2 < b2) {
    return order === "asc" ? -1 : 1;
  }
  if (a2 > b2) {
    return order === "asc" ? 1 : -1;
  }
  return 0;
}
function orderBy(arr, criteria, orders) {
  return arr.slice().sort((a2, b2) => {
    const ordersLength = orders.length;
    for (let i2 = 0; i2 < criteria.length; i2++) {
      const order = ordersLength > i2 ? orders[i2] : orders[ordersLength - 1];
      const criterion = criteria[i2];
      const criterionIsFunction = typeof criterion === "function";
      const valueA = criterionIsFunction ? criterion(a2) : a2[criterion];
      const valueB = criterionIsFunction ? criterion(b2) : b2[criterion];
      const result = compareValues(valueA, valueB, order);
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  });
}
function pullAt(arr, indicesToRemove) {
  const removed = at$1(arr, indicesToRemove);
  const indices = new Set(indicesToRemove.slice().sort((x2, y2) => y2 - x2));
  for (const index2 of indices) {
    arr.splice(index2, 1);
  }
  return removed;
}
function isSymbol(value) {
  return typeof value === "symbol" || value instanceof Symbol;
}
function toNumber(value) {
  if (isSymbol(value)) {
    return NaN;
  }
  return Number(value);
}
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === Infinity || value === -Infinity) {
    const sign = value < 0 ? -1 : 1;
    return sign * Number.MAX_VALUE;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  const finite = toFinite(value);
  const remainder = finite % 1;
  return remainder ? finite - remainder : finite;
}
function takeRight(arr, count, guard) {
  count = count === void 0 ? 1 : toInteger(count);
  if (count <= 0 || arr.length === 0) {
    return [];
  }
  return arr.slice(-count);
}
function sum(nums) {
  let result = 0;
  for (let i2 = 0; i2 < nums.length; i2++) {
    result += nums[i2];
  }
  return result;
}
function mean(nums) {
  return sum(nums) / nums.length;
}
function sumBy(items, getValue) {
  let result = 0;
  for (let i2 = 0; i2 < items.length; i2++) {
    result += getValue(items[i2], i2);
  }
  return result;
}
function meanBy(items, getValue) {
  return sumBy(items, (item2) => getValue(item2)) / items.length;
}
function round(value, precision = 0) {
  if (!Number.isInteger(precision)) {
    throw new Error("Precision must be an integer.");
  }
  const multiplier = Math.pow(10, precision);
  return Math.round(value * multiplier) / multiplier;
}
class cAssignments {
  available_at;
  burned_at;
  created_at;
  hidden;
  passed_at;
  resurrected_at;
  srs_stage;
  started_at;
  subject_id;
  subject_type;
  unlocked_at;
  constructor(data6) {
    Object.assign(this, data6);
  }
}
let cData$1 = class cData {
  amalgamation_subject_ids;
  auxiliary_meanings;
  character_images;
  characters;
  component_subject_ids;
  context_sentences;
  created_at;
  document_url;
  hidden_at;
  lesson_position;
  level;
  meaning_hint;
  meaning_mnemonic;
  meanings;
  parts_of_speech;
  pronunciation_audios;
  reading_hint;
  reading_mnemonic;
  readings;
  slug;
  spaced_repetition_system_id;
  visually_similar_subject_ids;
  constructor(data6) {
    Object.assign(this, cloneDeep(data6));
  }
};
class cItemData {
  assignments;
  data;
  data_updated_at;
  id;
  object;
  review_statistics;
  study_materials;
  url;
  constructor(data6) {
    Object.assign(this, data6);
    this.assignments = new cAssignments(data6.assignments);
    this.data = new cData$1(data6.data);
    this.review_statistics = new cReviewStatistics(data6.review_statistics);
    if (data6.study_materials != void 0)
      this.study_materials = new cStudyMaterials(data6.study_materials);
  }
  //   total(): number {
  //     return this.review_statistics
  //   }
  //   totalCorrect(): number {
  //     return 1
  //   }
  //   totalIncorrect(): number {
  //     return 2
  //   }
}
class cReviewStatistics {
  created_at;
  hidden;
  meaning_correct;
  meaning_current_streak;
  meaning_incorrect;
  meaning_max_streak;
  percentage_correct;
  reading_correct;
  reading_current_streak;
  reading_incorrect;
  reading_max_streak;
  subject_id;
  subject_type;
  constructor(data6) {
    Object.assign(this, data6);
    this.meaning_correct = ZeroIfNaN(this.meaning_correct);
    this.meaning_incorrect = ZeroIfNaN(this.meaning_incorrect);
    this.reading_correct = ZeroIfNaN(this.reading_correct);
    this.reading_incorrect = ZeroIfNaN(this.reading_incorrect);
  }
}
class cStudyMaterials {
  created_at;
  hidden;
  meaning_note;
  meaning_synonyms;
  reading_note;
  subject_id;
  subject_type;
  constructor(data6) {
    Object.assign(this, data6);
  }
}
const useItemDataStore = /* @__PURE__ */ defineStore("itemData", () => {
  const dummyItem = {
    assignments: {
      available_at: "",
      burned_at: "",
      created_at: "",
      hidden: false,
      passed_at: "",
      resurrected_at: null,
      srs_stage: -1,
      started_at: "",
      subject_id: 1,
      subject_type: "",
      unlocked_at: ""
    },
    data: {
      amalgamation_subject_ids: [],
      auxiliary_meanings: [],
      character_images: [],
      characters: "",
      created_at: "",
      document_url: "",
      hidden_at: null,
      lesson_position: 0,
      level: -1,
      meaning_mnemonic: "",
      meanings: [],
      slug: "",
      spaced_repetition_system_id: -1
    },
    data_updated_at: "",
    id: -99,
    object: "",
    review_statistics: {
      created_at: "",
      hidden: false,
      meaning_correct: 0,
      meaning_current_streak: 0,
      meaning_incorrect: 0,
      meaning_max_streak: 0,
      percentage_correct: 0,
      reading_correct: 0,
      reading_current_streak: 0,
      reading_incorrect: 0,
      reading_max_streak: 0,
      subject_id: 0,
      subject_type: ""
    },
    url: ""
  }, itemData = /* @__PURE__ */ ref([]), loadingCount = /* @__PURE__ */ ref(0), OverallNumbers = /* @__PURE__ */ ref(new cOverallNumbers()), types = ["radical", "kanji", "vocabulary", "kana_vocabulary"];
  const fetchItemData = async () => {
    if (itemData.value.length > 0) return;
    itemData.value = [];
    loadingCount.value += 1;
    return wkof.ItemData.get_items({
      wk_items: {
        options: {
          assignments: true,
          review_statistics: true,
          study_materials: true
        }
      }
    }).then(async (items) => {
      itemData.value = items.map((i2) => {
        return new cItemData(i2);
      });
      OverallNumbers.value = new cOverallNumbers();
      debugger;
      itemData.value.forEach(async (d2) => {
        switch (d2.object) {
          case "kanji":
            OverallNumbers.value.kanji.meaning.correct += d2.review_statistics.meaning_correct;
            OverallNumbers.value.kanji.meaning.incorrect += d2.review_statistics.meaning_incorrect;
            OverallNumbers.value.kanji.reading.correct += d2.review_statistics.reading_correct;
            OverallNumbers.value.kanji.reading.incorrect += d2.review_statistics.reading_incorrect;
            return;
          case "radical":
            OverallNumbers.value.radicals.meaning.correct += d2.review_statistics.meaning_correct;
            OverallNumbers.value.radicals.meaning.incorrect += d2.review_statistics.meaning_incorrect;
            OverallNumbers.value.radicals.reading.correct += d2.review_statistics.reading_correct;
            OverallNumbers.value.radicals.reading.incorrect += d2.review_statistics.reading_incorrect;
            return;
          case "vocabulary":
            OverallNumbers.value.vocab.meaning.correct += d2.review_statistics.meaning_correct;
            OverallNumbers.value.vocab.meaning.incorrect += d2.review_statistics.meaning_incorrect;
            OverallNumbers.value.vocab.reading.correct += d2.review_statistics.reading_correct;
            OverallNumbers.value.vocab.reading.incorrect += d2.review_statistics.reading_incorrect;
            return;
        }
      });
    });
  };
  const assignmentsForTypeAndLevel = (type, stages, includeHidden = false) => {
    return itemData.value == null ? [] : stages[0] == -1 ? itemData.value.filter(
      (d2) => d2.object == type && ![1, 2, 3, 4, 5, 6, 7, 8, 9].includes(d2.assignments.srs_stage) && (d2.assignments.hidden == false || includeHidden)
    ) : itemData.value.filter(
      (d2) => d2.object == type && stages.includes(d2.assignments.srs_stage) && (d2.assignments.hidden == false || includeHidden)
    );
  }, blankItem = () => cloneDeep(dummyItem), loading = computed(() => loadingCount.value > 0);
  return {
    assignmentsForTypeAndLevel,
    blankItem,
    fetchItemData,
    itemData,
    loading,
    OverallNumbers,
    types
  };
});
const useUserStore = /* @__PURE__ */ defineStore("user", () => {
  const loadingCount = /* @__PURE__ */ ref(0), userData = /* @__PURE__ */ ref(null);
  const loading = computed(() => loadingCount.value > 0);
  return { loading, userData };
});
function bind2(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e2) {
    return false;
  }
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend3 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a2[key] = bind2(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack2 = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack2[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data6 }) => {
      if (source === _global && data6 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$1(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend: extend3,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message2, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError$1.call(axiosError, msg, errCode, config2, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (utils$1.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build3(value, path) {
    if (utils$1.isUndefined(value)) return;
    if (stack2.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build3(el, path ? path.concat(key) : [key]);
      }
    });
    stack2.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build3(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data6, options) {
  return toFormData$1(data6, new platform.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data6, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data6);
    if (isObjectPayload && utils$1.isHTMLForm(data6)) {
      data6 = new FormData(data6);
    }
    const isFormData2 = utils$1.isFormData(data6);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data6)) : data6;
    }
    if (utils$1.isArrayBuffer(data6) || utils$1.isBuffer(data6) || utils$1.isStream(data6) || utils$1.isFile(data6) || utils$1.isBlob(data6) || utils$1.isReadableStream(data6)) {
      return data6;
    }
    if (utils$1.isArrayBufferView(data6)) {
      return data6.buffer;
    }
    if (utils$1.isURLSearchParams(data6)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data6.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data6, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data6)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data6 } : data6,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data6);
    }
    return data6;
  }],
  transformResponse: [function transformResponse(data6) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data6) || utils$1.isReadableStream(data6)) {
      return data6;
    }
    if (data6 && utils$1.isString(data6) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data6, this.parseReviver);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data6;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = /* @__PURE__ */ Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config2 = this || defaults;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data6 = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data6 = fn.call(config2, data6, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data6;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message2, config2, request) {
  AxiosError$1.call(this, message2 == null ? "canceled" : message2, AxiosError$1.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener2, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded2 = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded2 - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded2 <= total;
    bytesNotified = loaded2;
    const data6 = {
      loaded: loaded2,
      total,
      progress: total ? loaded2 / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded2) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener2(data6);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded2) => throttled[0]({
    lengthComputable,
    total,
    loaded: loaded2
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure, sameSite) {
      if (typeof document === "undefined") return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils$1.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils$1.isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (utils$1.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils$1.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined") return null;
      const match2 = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match2 ? decodeURIComponent(match2[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data: data6, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils$1.isFormData(data6)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils$1.isFunction(data6.getHeaders)) {
      const formHeaders = data6.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config2 = resolveConfig(config2);
    let requestData = _config2.data;
    const requestHeaders = AxiosHeaders$1.from(_config2.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config2;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config2.cancelToken && _config2.cancelToken.unsubscribe(onCanceled);
      _config2.signal && _config2.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config2.method.toUpperCase(), _config2.url, true);
    request.timeout = _config2.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError2(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config2, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config2.timeout ? "timeout of " + _config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config2.transitional || transitionalDefaults;
      if (_config2.timeoutErrorMessage) {
        timeoutErrorMessage = _config2.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config2.withCredentials)) {
      request.withCredentials = !!_config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config2.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config2.cancelToken || _config2.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config2.cancelToken && _config2.cancelToken.subscribe(onCanceled);
      if (_config2.signal) {
        _config2.signal.aborted ? onCanceled() : _config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config2.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end3;
  while (pos < len) {
    end3 = pos + chunkSize;
    yield chunk.slice(pos, end3);
    pos = end3;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const { isFunction } = utils$1;
const globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils$1.global);
const {
  ReadableStream: ReadableStream$1,
  TextEncoder
} = utils$1.global;
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const factory = (env) => {
  env = utils$1.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction(Request);
  const isResponseSupported = isFunction(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream$1(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config2) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config2) => {
    let {
      url,
      method,
      data: data6,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config2);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data6)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data6,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data6) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data6 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data6,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve2, reject) => {
        settle(resolve2, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError$1.from(err, err && err.code, config2, request);
    }
  };
};
const seedCache = /* @__PURE__ */ new Map();
const getFetch = (config2) => {
  let env = config2 && config2.env || {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i2 = len, seed, target, map = seedCache;
  while (i2--) {
    seed = seeds[i2];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
getFetch();
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: {
    get: getFetch
  }
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
function getAdapter$1(adapters2, config2) {
  adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
  const { length } = adapters2;
  let nameOrAdapter;
  let adapter;
  const rejectedReasons = {};
  for (let i2 = 0; i2 < length; i2++) {
    nameOrAdapter = adapters2[i2];
    let id;
    adapter = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter === void 0) {
        throw new AxiosError$1(`Unknown adapter '${id}'`);
      }
    }
    if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
      break;
    }
    rejectedReasons[id || "#" + i2] = adapter;
  }
  if (!adapter) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError$1(
      `There is no suitable adapter to dispatch the request ` + s2,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter;
}
const adapters = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: getAdapter$1,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults.adapter, config2);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION$1 = "1.13.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator6(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator6, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator6 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator6 ? validator6(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator6 = schema[opt];
    if (validator6) {
      const value = options[opt];
      const result = value === void 0 || validator6(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator5 = {
  assertOptions,
  validators: validators$1
};
const validators = validator5.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack2;
          } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack2;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator5.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator5.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator5.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data6, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data6
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message2, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener2) {
    if (this.reason) {
      listener2(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener2);
    } else {
      this._listeners = [listener2];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener2) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener2);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind2(Axios$1.prototype.request, context);
  utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create2(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
const instance = axios.create({
  baseURL: "https://api.wanikani.com/v2/"
});
instance.interceptors.request.use((config2) => {
  const userStore = useUserStore();
  config2.headers["Authorization"] = "Bearer " + userStore.userData?.apikey;
  return config2;
});
instance.interceptors.response.use((response) => {
  const data6 = response.data.data;
  if (response.data.pages !== void 0) {
    if (response.data.pages.next_url !== null) {
      response.config.url = response.data.pages.next_url;
      return instance.request(response.config).then((ret) => {
        return data6.concat(ret);
      });
    } else {
      return data6;
    }
  } else {
    return data6;
  }
});
class cData2 {
  abandoned_at;
  completed_at;
  created_at;
  level;
  passed_at;
  reset_at;
  started_at;
  unlocked_at;
  constructor(data6) {
    Object.assign(this, data6);
  }
  timeToComplete() {
    return differenceInDays(
      this.completed_at == null ? /* @__PURE__ */ new Date() : new Date(this.completed_at),
      new Date(this.started_at)
    );
  }
  timeToPass() {
    return differenceInDays(
      this.passed_at == null ? /* @__PURE__ */ new Date() : new Date(this.passed_at),
      new Date(this.started_at)
    );
  }
  timeToPassFromUnlock() {
    return differenceInDays(
      this.passed_at == null ? /* @__PURE__ */ new Date() : new Date(this.passed_at),
      new Date(this.unlocked_at)
    );
  }
}
class cLevelProgression {
  data;
  data_updated_at;
  id;
  object;
  url;
  constructor(data6) {
    Object.assign(this, data6);
    this.data = new cData2(data6.data);
  }
}
const useLevelProgressionsStore = /* @__PURE__ */ defineStore("levelProgressions", () => {
  const levelProgressions = /* @__PURE__ */ ref([]), loadingCount = /* @__PURE__ */ ref(0);
  const fetchLevelProgressions = async () => {
    if (levelProgressions.value.length > 0) return;
    return new Promise((resolve2, reject) => {
      loadingCount.value += 1;
      instance.get("level_progressions").then((ret) => {
        levelProgressions.value = ret.filter((o2) => !o2.data.abandoned_at).map((d2) => {
          return new cLevelProgression(d2);
        });
        loadingCount.value -= 1;
      }).catch((error) => {
        console.log(error.message);
      }).then(
        (response) => {
          loadingCount.value -= 1;
          resolve2(response);
        },
        (error) => {
          loadingCount.value -= 1;
          reject(error);
        }
      );
    });
  }, reset = async () => {
    levelProgressions.value = [];
  };
  const loading = computed(() => loadingCount.value > 0);
  return { fetchLevelProgressions, levelProgressions, loading, reset };
});
const useResetsStore = /* @__PURE__ */ defineStore("resets", () => {
  const loadingCount = /* @__PURE__ */ ref(0), resets = /* @__PURE__ */ ref();
  const fetchResets = async () => {
    if (resets.value != void 0) return;
    return new Promise((resolve2, reject) => {
      loadingCount.value += 1;
      instance.get("resets").then((ret) => {
        resets.value = ret;
        loadingCount.value -= 1;
      }).catch((error) => {
        console.log(error.message);
      }).then(
        (response) => {
          loadingCount.value -= 1;
          resolve2(response);
        },
        (error) => {
          loadingCount.value -= 1;
          reject(error);
        }
      );
    });
  }, setResetsInLevelProgression = () => {
    const lps = useLevelProgressionsStore();
    debugger;
    resets.value?.data.forEach((r2) => {
      const originalLevel = r2.data.original_level;
      const resetLevelDateEnd = parseISO(
        takeRight(
          lps.levelProgressions.filter(
            (l2) => l2.data.level == originalLevel && (isBefore(parseISO(l2.data.unlocked_at), parseISO(r2.data.created_at)) || isSameDay(parseISO(l2.data.unlocked_at), parseISO(r2.data.created_at)))
          ),
          1
        )[0]?.data.unlocked_at ?? ""
      );
      if (resetLevelDateEnd == null) return;
      let resetLevelDateStart = parseISO(
        takeRight(
          lps.levelProgressions.filter((l2) => {
            return l2.data.level == r2.data.target_level && isBefore(parseISO(l2.data.unlocked_at), resetLevelDateEnd);
          }),
          1
        )[0]?.data.unlocked_at ?? ""
      );
      if (!isValid(resetLevelDateStart)) resetLevelDateStart = new Date(1990, 0, 0);
      lps.levelProgressions.filter(
        (l2) => isDateBetweenInclusive(
          parseISO(l2.data.unlocked_at),
          resetLevelDateStart,
          resetLevelDateEnd
        )
      )?.forEach((l2) => {
        l2.data.reset_at = r2.data.created_at;
      });
    });
  };
  const loading = computed(() => loadingCount.value > 0);
  return { fetchResets, loading, resets, setResetsInLevelProgression };
});
const loadTurbo = () => {
  wkof.load_script(
    turboUrl,
    /* use_cache */
    true
  );
}, turboUrl = "https://update.greasyfork.org/scripts/501980/1426289/Wanikani%20Open%20Framework%20Turbo%20Events.user.js", wkofCheck = () => {
  const indexStore = useIndexStore();
  console.log("Checking for WaniKani Open Framework");
  if (!window.wkof) {
    if (confirm(
      indexStore.scriptName + " requires Wanikani Open Framework.\nDo you want to be forwarded to the installation instructions?"
    )) {
      window.location.href = "https://community.wanikani.com/t/instructions-installing-wanikani-open-framework/28549";
    }
  }
}, wkofLoad = () => {
  const itemDataStore = useItemDataStore(), resetsStore = useResetsStore();
  const modules = "Apiv2, ItemData", userStore = useUserStore();
  wkof.include(modules);
  wkof.ready(modules).then(() => {
    userStore.userData = wkof.user;
    itemDataStore.fetchItemData();
    resetsStore.fetchResets();
  });
};
const _hoisted_1$e = { class: "main" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const indexStore = useIndexStore(), makeStatsDiv = () => {
      const spotBefore = document.getElementsByClassName("character-header__characters")[0];
      if (spotBefore == null) return;
      const newSpot = document.createElement("div");
      newSpot.id = "statsDiv";
      if (spotBefore == null) {
        console.log("#user-response not found");
      } else {
        spotBefore.after(newSpot);
      }
      indexStore.dashboardLoaded = false;
    };
    onMounted(() => {
      nextTick(() => {
        setUpListeners(() => {
          nextTick(() => {
            console.log("start");
            loadTurbo();
            makeStatsDiv();
          });
        });
        wkofCheck();
        wkofLoad();
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        unref(indexStore).dashboardLoaded ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#sitemapStats"
        }, [
          createVNode(StatsButton)
        ])) : createCommentVNode("", true),
        unref(indexStore).dashboardLoaded ? (openBlock(), createBlock(Changelog, { key: 1 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_1$e, [
          createVNode(_sfc_main$g),
          createVNode(unref(RouterView))
        ])
      ], 64);
    };
  }
});
const _hoisted_1$d = {
  id: "tblAccuracy",
  name: "accuracy"
};
const _hoisted_2$c = { class: "border-bottom" };
const _hoisted_3$b = { class: "radicals" };
const _hoisted_4$5 = { class: "radicals" };
const _hoisted_5$5 = { class: "kanji" };
const _hoisted_6$2 = { class: "kanji" };
const _hoisted_7$2 = { class: "kanji" };
const _hoisted_8$2 = { class: "vocab" };
const _hoisted_9$2 = { class: "vocab" };
const _hoisted_10$1 = { class: "vocab" };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "Accuracy",
  setup(__props) {
    const itemDataStore = useItemDataStore();
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        _cache[9] || (_cache[9] = createBaseVNode("span", { class: "header" }, "Accuracy", -1)),
        createBaseVNode("table", _hoisted_1$d, [
          createBaseVNode("tbody", null, [
            _cache[8] || (_cache[8] = createBaseVNode("tr", { class: "border-bottom" }, [
              createBaseVNode("th"),
              createBaseVNode("th", null, "Reading"),
              createBaseVNode("th", null, "Meaning"),
              createBaseVNode("th", null, "Total")
            ], -1)),
            createBaseVNode("tr", null, [
              _cache[0] || (_cache[0] = createBaseVNode("th", null, "Total Reviews:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.reading()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.meaning()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.total()), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[1] || (_cache[1] = createBaseVNode("th", null, "Correct:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.readingCorrect()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.meaningCorrect()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.totalCorrect()), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[2] || (_cache[2] = createBaseVNode("th", null, "Incorrect:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.readingIncorrect()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.meaningIncorrect()), 1),
              createBaseVNode("td", null, toDisplayString(unref(itemDataStore).OverallNumbers?.totalIncorrect()), 1)
            ]),
            createBaseVNode("tr", _hoisted_2$c, [
              _cache[3] || (_cache[3] = createBaseVNode("th", null, "Accuracy:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.accuracy())), 1),
              createBaseVNode("td", null, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.meaningAccuracy())), 1),
              createBaseVNode("td", null, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.readingAccuracy())), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[4] || (_cache[4] = createBaseVNode("th", null, "Radicals:", -1)),
              _cache[5] || (_cache[5] = createBaseVNode("td", { class: "radicals" }, "---", -1)),
              createBaseVNode("td", _hoisted_3$b, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.radicals.meaningAccuracy())), 1),
              createBaseVNode("td", _hoisted_4$5, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.radicals.accuracy())), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[6] || (_cache[6] = createBaseVNode("th", null, "Kanji:", -1)),
              createBaseVNode("td", _hoisted_5$5, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.kanji.meaningAccuracy())), 1),
              createBaseVNode("td", _hoisted_6$2, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.kanji.readingAccuracy())), 1),
              createBaseVNode("td", _hoisted_7$2, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.kanji.meaningAccuracy())), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[7] || (_cache[7] = createBaseVNode("th", null, "Vocabulary:", -1)),
              createBaseVNode("td", _hoisted_8$2, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.vocab.meaningAccuracy())), 1),
              createBaseVNode("td", _hoisted_9$2, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.vocab.readingAccuracy())), 1),
              createBaseVNode("td", _hoisted_10$1, toDisplayString(unref(percent)(unref(itemDataStore).OverallNumbers?.vocab.accuracy())), 1)
            ])
          ])
        ])
      ], 64);
    };
  }
});
const Accuracy = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-0857b5ad"]]);
const _hoisted_1$c = {
  id: "tblUser",
  name: "user"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "User",
  setup(__props) {
    const userStore = useUserStore();
    onMounted(() => {
    });
    const timeSinceStart = computed(() => {
      if (userStore.userData == null) {
        return 0;
      }
      const today = /* @__PURE__ */ new Date();
      let start = new Date(userStore.userData?.started_at);
      const y2 = differenceInYears(today, start);
      start = addYears(start, y2);
      const m2 = differenceInMonths(today, start);
      start = addMonths(start, m2);
      const d2 = differenceInCalendarDays(today, start);
      return `${y2} years ${m2} months and ${d2} days`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        _cache[4] || (_cache[4] = createBaseVNode("span", { class: "header" }, "Current Status", -1)),
        createBaseVNode("table", _hoisted_1$c, [
          createBaseVNode("tbody", null, [
            createBaseVNode("tr", null, [
              _cache[0] || (_cache[0] = createBaseVNode("th", null, "Username:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(userStore).userData?.username), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[1] || (_cache[1] = createBaseVNode("th", null, "Level", -1)),
              createBaseVNode("td", null, toDisplayString(unref(userStore).userData?.level), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[2] || (_cache[2] = createBaseVNode("th", null, "Start Date:", -1)),
              createBaseVNode("td", null, toDisplayString(unref(format)(unref(userStore).userData?.started_at, "MMMM do y")), 1)
            ]),
            createBaseVNode("tr", null, [
              _cache[3] || (_cache[3] = createBaseVNode("th", null, "Time Since Start:", -1)),
              createBaseVNode("td", null, toDisplayString(timeSinceStart.value), 1)
            ])
          ])
        ])
      ], 64);
    };
  }
});
const User = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-70e4bc14"]]);
const _hoisted_1$b = { class: "container" };
const _hoisted_2$b = { class: "row" };
const _hoisted_3$a = { class: "col" };
const _hoisted_4$4 = { class: "row" };
const _hoisted_5$4 = { class: "col" };
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "HomeView",
  setup(__props) {
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createBaseVNode("div", _hoisted_2$b, [
          createBaseVNode("div", _hoisted_3$a, [
            createVNode(User)
          ])
        ]),
        createBaseVNode("div", _hoisted_4$4, [
          createBaseVNode("div", _hoisted_5$4, [
            createVNode(Accuracy)
          ])
        ])
      ]);
    };
  }
});
const HomeView = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-4b4f69f4"]]);
const _hoisted_1$a = {
  key: 1,
  class: "slug"
};
const _hoisted_2$a = {
  key: 1,
  class: "slug"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ItemDetail",
  props: {
    item: {}
  },
  setup(__props) {
    const indexStore = useIndexStore(), linkUrl = (item2) => {
      if (item2.id == -99) return `https://jisho.org/search/#kanji ${item2.data.slug.replace(" ", "-")}`;
      return item2.object.toLowerCase() == "radical" ? `https://www.wanikani.com/radicals/${item2.data.slug.replace(" ", "-")}` : `https://www.wanikani.com/${item2.object.toLowerCase()}/${item2.data.slug}`;
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$g), {
        as: "a",
        href: linkUrl(__props.item),
        target: "_blank",
        rel: "noopener",
        class: normalizeClass([
          "item",
          __props.item.object,
          "v-center",
          __props.item.assignments.srs_stage == -1 ? "notInWK" : unref(indexStore).stageNumberToName(__props.item.assignments.srs_stage)
        ])
      }, {
        default: withCtx(() => [
          __props.item.object == "radical" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            __props.item.data.characters == null ? (openBlock(), createBlock(unref(script$8), {
              key: 0,
              src: __props.item.data.character_images?.filter((o2) => o2.content_type == "image/svg+xml")[0]?.url
            }, null, 8, ["src"])) : (openBlock(), createElementBlock("span", _hoisted_1$a, toDisplayString(__props.item.data.characters), 1))
          ], 64)) : (openBlock(), createElementBlock("span", _hoisted_2$a, toDisplayString(__props.item.data.slug), 1))
        ]),
        _: 1
      }, 8, ["href", "class"]);
    };
  }
});
const ItemDetail = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-0d6f9005"]]);
const useJlptStore = /* @__PURE__ */ defineStore("jlpt", () => {
  const data6 = {
    kanji: {
      N1: "",
      N2: "",
      N3: "",
      N4: "",
      N5: ""
    },
    "Not In WaniKani": [
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sign of the ox or cow", "1-3AM", "second sign of Chinese zodiac"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["third class", "3rd", "3rd calendar sign"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["help"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["span", "range", "extend over"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sign of the hog", "9-11PM", "twelfth sign of the Chinese zodiac"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["also", "again"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["pass through", "go smoothly"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["five", "five-man squad", "file", "line"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["actor"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["nursing", "attending", "entertainer"],
        onyomi: ["", "", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["however", "but"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["help", "assist"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["strong", "just", "righteous", "peace-loving"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["urge to eat"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["marquis", "lord", "daimyo"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["happiness", "luck"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["emulate", "imitate"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["Yamato", "ancient Japan"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["recollect", "remember"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["Confucian"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["license", "sincerity", "permit"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["be clear", "serene", "cold", "skilful"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["melting", "smelting"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["cold", "strict", "severe"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["lull", "calm", "(kokuji)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["victory song"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["strong"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["imperial order"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["ladle", "one tenth of a go", "dip"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["monme", "3.75 grams", "(kokuji)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["correct", "save", "assist"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sign of the hare or rabbit", "fourth sign of Chinese zodiac", "5-7AM", "east"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["rin", "1/10 sen", "1/10 bu"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["intelligence", "imperial"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["only", "free", "in addition"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["grant", "answer"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["officer", "an official"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["peck", "pick up"],
        onyomi: ["", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["high", "boasting"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["heir", "succeed"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["menacing", "dignity", "majesty", "threaten"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["square jewel", "corner", "angle", "edge"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["model", "molding"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["ground-breaking", "open up farmland"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["one (in documents)"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["star", "god of literature"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["legitimate wife", "direct descent (non-bastard)"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["glad", "pleased", "rejoice"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["chief", "beginning"],
        onyomi: ["", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["wide", "large"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["soothe", "calm", "pacify"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["wee hours", "evening", "early night"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sign of the tiger", "3-5AM", "third sign of Chinese zodiac"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["high", "far"], onyomi: [""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["high", "steep"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["mountains towering in a row"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["be aggravated", "grow worse", "grow bulky", "swell"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["steep", "craggy", "rugged"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["peak", "summit"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["rock", "crag", "boulder"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sign of the snake or serpent", "9-11AM", "sixth sign of Chinese zodiac"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["comma-design"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["southeast"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["II", "two", "second"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["vast", "broad", "wide"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["comet"],
        onyomi: ["", "", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["lad", "boy (ancient)"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["spotted", "mottled", "patterned", "small tiger"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["refined", "gentle"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["wise"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["excuse", "tolerate", "forgive"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["serving our elders"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sincere", "kind", "considerate"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["consider", "reflect", "think"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["all"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["distress", "grieve", "lament", "be anxious"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["wise"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["extract", "selection", "summary", "copy", "spread thin"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["victory", "fast"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["press", "print", "affix a seal", "stamp"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["industry", "kindliness"],
        onyomi: ["", "", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: [
          "axe",
          "1.32 lb",
          "catty",
          "counter for loaves of bread",
          "axe radical (no. 69)"
        ],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["reject", "retreat", "recede", "withdraw", "repel", "repulse"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["at", "in", "on", "as for"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["rising sun", "morning sun"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["flourishing", "successful", "beautiful", "vigorous"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["rise"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["the Pleiades"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["clear"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["advance"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["late", "quiet", "sets (sun)"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["clear"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["morning", "early"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["shine", "light"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["stretch"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["companion", "friend"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["conjunction (astronomy)", "first day of month", "north"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["majestic plural", "imperial we"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["plum"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["woods", "grove"],
        onyomi: ["", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["holly"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["citron"], onyomi: ["", "", ""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["straight grain", "spindle tree", "(kokuji)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["chestnut"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["Japanese Judas-tree", "cinnamon tree"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["paulownia"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["treetops", "twig"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["Chinese parasol tree", "phoenix tree"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["coffin", "casket"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["type of deciduous tree", "grey starling"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["coconut tree"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["camellia"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["willow"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["camphor tree"],
        onyomi: ["", "", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["watchtower", "lookout", "high building"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["hazelnut", "filbert"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["twig", "ornamental evergreen"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["Zelkova tree"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["birch", "dark red"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["mandarin orange"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["cedar", "sandlewood", "spindle tree"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["take pleasure in", "rejoice"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["respect", "revere", "long for"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["strong"], onyomi: ["", ""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["burr", "ball"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["eventide", "tide", "salt water", "opportunity"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["continent", "sandbar", "island", "country"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["alike", "truth"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["sparkling water"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["wide expanse", "abundance", "vigorous"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["pure"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["strand", "beach", "shore"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["kindness", "moisten"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["deep and broad"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["gargle", "rinse mouth"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["water route", "shipping channel"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["excessive", "overflow", "spread out"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", "", "", ""],
        meanings: ["bright", "sunny", "prosperous", "merry"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["burn", "bonfire"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["brilliant"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["shine"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["baron", "peerage", "court rank"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", ""],
        meanings: ["you", "thou", "second person"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["boar"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["beautiful black jewel", "nine"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["sound of jewels"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["precious stone", "gem", "lapis lazuli"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["polish"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["jewel", "tinkling of jewelry"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["ancestral offering receptacle", "coral"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["polish", "brilliant white luster of a gem", "artful smile"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["beautiful as a jewel"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["for the first time", "not until"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["furrow", "thirty tsubo", "ridge", "rib"],
        onyomi: ["", "", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["pox", "smallpox"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["swamp", "shore"], onyomi: [""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["white", "clear"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["eyebrow"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["pupil of the eye"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["nitrate", "saltpeter"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["blue", "green"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["large", "great", "eminent"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["seashore", "beach"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["help"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["fief", "allowance", "pension", "grant", "happiness"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["happiness", "blessed", "good fortune", "auspicious"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["Manchu dynasty", "name given to naturalized foreigners"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["rare", "phenomenal", "dilute (acid)"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["harvest", "ripen"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["angle", "edge", "corner", "power", "majesty"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["good crops", "prosperity", "10**28"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["kiln", "oven", "furnace"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["end", "finish"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["a reed instrument"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["bamboo grass", "(kokuji)"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["counter for articles"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["gauze", "gossamer"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["large"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["pongee (a knotted silk cloth)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["string", "cord", "samisen music"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["brilliant fabric design"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["rule", "synthesize"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["thread", "silk cloth"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["darning", "repair", "mend", "trim", "tidy up", "adjust"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["cocoon"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["venerable old man"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["green", "kingfisher"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["shine", "sparkle", "gleam", "twinkle"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["decrease"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["question mark"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["beginning"],
        onyomi: ["", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["limb", "arms & legs"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["descendent", "issue", "offspring"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["dried meat"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["dilate", "distend", "bulge", "fill out", "swell"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["type of morning glory", "rose of Sharon", "althea"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["glossy", "luster", "glaze", "polish", "charm", "colorful", "captivating"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["lotus", "Mt Fuji"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["parsley"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["garden", "farm", "park"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["eggplant"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["miscanthus reed"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["jasmine"], onyomi: ["", "", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["smiling", "reed used to cover tatami"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["iris"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["the violet"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["bush clover"], onyomi: [""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["sow (seeds)"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["lotus"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["vine", "ivy"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["banana", "plantain"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["butterbur", "bog rhubarb"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["fuel", "firewood", "kindling"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["send forth fragrance", "fragrant", "be scented", "smoke (tobacco)"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["orchid", "Holland"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", "", "", ""],
        meanings: ["fear", "uneasiness", "anxiety", "concern", "expectation", "consideration"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["silkworm"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["inmost", "heart", "mind", "inside"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["neck", "collar", "lapel"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["a coarse camlet"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["Buddhist surplice"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["brown", "woollen kimono"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["imperial edict"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["consult with"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["friendship", "intimacy"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["tedious"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["audience", "audience (with king)"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["mimeograph", "copy"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["grant", "gift", "boon", "results"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["levy", "ode", "prose", "poem", "tribute", "installment"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["strong and brave"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: [
          "sign of the dragon",
          "7-9AM",
          "fifth sign of Chinese zodiac",
          "shin dragon radical (no. 161)"
        ],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["edify", "way", "path"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["pursue", "drive away", "chase", "accomplish", "attain", "commit"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["relay", "in turn", "sending"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["abide by", "follow", "obey", "learn"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["village", "rural community", "right village radical (no. 163)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["cultural progress", "perfume"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: [
          "west",
          "bird",
          "sign of the bird",
          "5-7PM",
          "tenth sign of Chinese zodiac",
          "sake radical (no. 164)"
        ],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["dice", "form", "appearance", "take", "gather", "coloring"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["pig iron"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["weight", "plumb bob", "sinker", "spindle"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["affixed", "attach", "refer to", "append"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["chick", "squab", "duckling", "doll"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["be hazy", "grow dim", "blurred"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["ball"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["rhyme", "elegance", "tone"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["eulogy"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["distribute", "disseminate", "partition", "understand"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["fragrant", "balmy", "favourable"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["charging ahead of others"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["freshwater trout", "smelt"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sea bream", "red snapper"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["male mythical bird"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["large bird", "wild goose", "large", "great", "powerful", "prosperous"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["phoenix"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["hawk"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["Chinese unicorn", "genius", "giraffe", "bright", "shining"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["I", "you", "(kokuji)"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["dark", "black", "many"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["blackened eyebrows"], onyomi: [""] }
    ]
  };
  const toItemData = (d2) => {
    const itemDetailStore = useItemDataStore();
    const id = itemDetailStore.blankItem();
    id.assignments.srs_stage = -1;
    id.object = "kanji";
    id.data.slug = d2.kanji;
    id.data.meanings = [];
    d2.meanings.forEach((m2, i2) => {
      id.data.meanings.push({
        accepted_answer: true,
        meaning: m2,
        primary: i2 == 0
      });
    });
    return id;
  };
  return { data: data6, toItemData };
});
const _hoisted_1$9 = { class: "row" };
const _hoisted_2$9 = { class: "col" };
const _hoisted_3$9 = { class: "level" };
const _hoisted_4$3 = { class: "container" };
const _hoisted_5$3 = { class: "row itemDetails" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "Main",
  setup(__props) {
    const itemDataStore = useItemDataStore(), itemInWK = (slug) => {
      return itemDataStore.itemData.find((i2) => i2.object == "kanji" && i2.data.slug == slug);
    }, jlptStore = useJlptStore(), sortByWK = (items) => {
      const sortedWkitems = orderBy(
        itemDataStore.itemData.filter((d2) => items.split("").includes(d2.data.slug)),
        [(i2) => i2.assignments.srs_stage, (i2) => i2.data.level],
        ["asc", "asc"]
      ).map((r2) => r2.data.slug);
      return [...sortedWkitems, ...difference(items.split(""), sortedWkitems)];
    };
    return (_ctx, _cache) => {
      const _component_BlockUI = resolveComponent("BlockUI");
      return openBlock(), createBlock(_component_BlockUI, {
        blocked: unref(itemDataStore).loading
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(unref(jlptStore).data.kanji).sort().reverse(), (n2) => {
            return openBlock(), createElementBlock("div", {
              key: n2,
              class: "container"
            }, [
              createBaseVNode("div", _hoisted_1$9, [
                createBaseVNode("div", _hoisted_2$9, [
                  createBaseVNode("span", _hoisted_3$9, toDisplayString(n2), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_4$3, [
                createBaseVNode("div", _hoisted_5$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(sortByWK(unref(jlptStore).data.kanji[n2]), (item2) => {
                    return openBlock(), createBlock(ItemDetail, {
                      key: item2,
                      item: itemInWK(item2) ?? unref(jlptStore).toItemData(
                        unref(jlptStore).data["Not In WaniKani"].find(
                          (i2) => i2.kanji == item2
                        )
                      )
                    }, null, 8, ["item"]);
                  }), 128))
                ])
              ])
            ]);
          }), 128))
        ]),
        _: 1
      }, 8, ["blocked"]);
    };
  }
});
const _hoisted_1$8 = { class: "container" };
const _hoisted_2$8 = { class: "row" };
const _hoisted_3$8 = { class: "col" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "JLPTView",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createBaseVNode("div", _hoisted_2$8, [
          createBaseVNode("div", _hoisted_3$8, [
            createVNode(_sfc_main$9)
          ])
        ])
      ]);
    };
  }
});
const useJoyoStore = /* @__PURE__ */ defineStore("joyo", () => {
  const data6 = {
    kanji: {
      "Grade 1": "",
      "Grade 2": "",
      "Grade 3": "",
      "Grade 4": "",
      "Grade 5": "",
      "Grade 6": "",
      "Grade 9": ""
    },
    "Not In WaniKani": [
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["third class", "3rd", "3rd calendar sign"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["spit", "skewer"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["beg", "invite", "ask"],
        onyomi: ["", "", "", "", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["however", "but"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["marquis", "lord", "daimyo"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["companion", "follower"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["emulate", "imitate"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["a wee bit"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["Confucian"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["dark"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["melting", "smelting"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["uncanny", "weird", "threatening", "horrible"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["temple"], onyomi: ["", "", ""] },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", "", "", ""],
        meanings: ["come off", "peel", "fade", "discolor"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["suddenness", "rise"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["imperial order"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["be bent", "slope", "capture"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["fragrant", "stink", "glow", "insinuate", "(kokuji)"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["rin", "1/10 sen", "1/10 bu"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["officer", "an official"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["throat", "choked", "smothered", "stuffy"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["saliva", "sputum"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["throat", "voice"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["metaphor", "compare"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["smell", "sniff", "scent"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["heir", "succeed"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["ridicule", "insult"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["menacing", "dignity", "majesty", "threaten"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["piled high"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["model", "molding"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["close", "shut", "cover", "block", "obstruct"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["fill in"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["ground-breaking", "open up farmland"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["one (in documents)"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["attractive", "bewitching", "calamity"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["jealous", "envy"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["jealous", "envy"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["legitimate wife", "direct descent (non-bastard)"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "-", "-", ""],
        meanings: ["address", "just like", "fortunately"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["wee hours", "evening", "early night"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", ""],
        meanings: ["play with", "tamper", "trifle with"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["II", "two", "second"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["same kind", "collect", "classify", "category", "hedgehog"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["grudge", "show resentment", "be jealous"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["selfish", "arbitrary"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["fear", "be afraid of", "dread"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["distress", "grieve", "lament", "be anxious"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: ["", "", ""], meanings: ["fear"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["disconcerted", "be confused", "lose one's head"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["yearn for", "aspire to", "admire"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["grieve", "relatives"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["extract", "selection", "summary", "copy", "spread thin"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["Latin", "kidnap", "crush"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["wipe", "mop", "swab"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["be imminent", "draw close"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["approach", "draw near", "push open"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["crush", "break", "sprain", "discourage"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["catch", "capture"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["make progress"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["twirl", "twist", "play with"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["gift", "seriousness"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["spot", "blemish", "speck", "patches"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: [
          "axe",
          "1.32 lb",
          "catty",
          "counter for loaves of bread",
          "axe radical (no. 69)"
        ],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["reject", "retreat", "recede", "withdraw", "repel", "repulse"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["flourishing", "successful", "beautiful", "vigorous"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["dark", "foolish"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["dark", "not clear"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["formerly", "once", "before", "ever", "never", "ex-"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["majestic plural", "imperial we"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["stockade", "fence", "weir", "entwine around"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["persimmon"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["beam", "girder", "spar", "unit or column (accounting)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["for the most part", "close up", "flower stem"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["coffin", "casket"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["square character style", "correctness"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["watchtower", "lookout", "high building"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", ""],
        meanings: [
          "break",
          "destroy",
          "censure",
          "be chipped",
          "be scratched",
          "be broken",
          "be ruined"
        ],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["spread out", "wide"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["pan-"],
        onyomi: ["", "", "", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["fertility"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["lewdness", "licentiousness"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["drown", "indulge"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["crush", "smash", "break", "dissipate"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["excessive", "overflow", "spread out"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["broil", "parch", "roast", "boil"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["baron", "peerage", "court rank"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["play", "take pleasure in", "trifle with", "make sport of"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["sphere", "ball"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["emperor's seal"], onyomi: [""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["tile", "gram"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["fear", "majestic", "graciously", "be apprehensive"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["furrow", "thirty tsubo", "ridge", "rib"],
        onyomi: ["", "", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["capital", "suburbs of capital"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["mark", "foot print"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["pox", "smallpox"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["get thin"],
        onyomi: ["", "", "", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["swelling", "boil", "tumor"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["eyebrow"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["nitrate", "saltpeter"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["think", "consider"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["cavern"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["kiln", "oven", "furnace"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["counter for articles"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["paper", "label", "letter", "composition"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["basket", "devote oneself", "seclude oneself", "cage", "coop", "implied"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["be rent", "ripped", "unravel", "run", "begin to open", "smile"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["fine (i.e. not coarse)"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["darning", "repair", "mend", "trim", "tidy up", "adjust"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["cocoon"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["abuse", "insult"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["feel ashamed"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["envious", "be jealous", "covet"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["venerable old man"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["decrease"], onyomi: ["", ""] },
      { kanji: "", kunyomi: [""], meanings: ["elbow", "arm"], onyomi: [""] },
      { kanji: "", kunyomi: ["", ""], meanings: ["thigh", "crotch"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["limb", "arms & legs"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["kidney"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["tumor", "swelling"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["gland"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["knee", "lap"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["small low table", "tray"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["timidity", "heart", "mind", "fear", "cowardly"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["mortar"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["gunwale"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["glossy", "luster", "glaze", "polish", "charm", "colorful", "captivating"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["torment", "scold", "chastise"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["wither", "droop", "lame"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["arrowroot", "kudzu"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: ["cover", "lid", "flap"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["cover", "shade", "mantle", "capsize", "be ruined"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["fuel", "firewood", "kindling"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["send forth fragrance", "fragrant", "be scented", "smoke (tobacco)"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", "", "", "", ""],
        meanings: ["fear", "uneasiness", "anxiety", "concern", "expectation", "consideration"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["silkworm"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["inmost", "heart", "mind", "inside"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["sleeve", "wing (building)", "extension", "give cold shoulder"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["cuff", "hem", "foot of mountain"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["brown", "woollen kimono"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["obituary"], onyomi: [""] },
      { kanji: "", kunyomi: [""], meanings: ["imperial edict"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["visit a temple", "arrive", "attain"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["discussion", "methods called for", "selection", "result"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["truth", "clarity", "abandon", "give up"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["harmony"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["audience", "audience (with king)"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["mimeograph", "copy"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["form", "appearance", "countenance"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["covet", "indulge in"],
        onyomi: ["", "", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", ""],
        meanings: ["grant", "gift", "boon", "results"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["levy", "ode", "prose", "poem", "tribute", "installment"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["remains", "clue", "footprint"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["kick"], onyomi: ["", ""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["pungent", "spicy", "harsh", "cruel", "severe"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["pursue", "drive away", "chase", "accomplish", "attain", "commit"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["relay", "in turn", "sending"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["go upstream", "retrace the past"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["abide by", "follow", "obey", "learn"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["awake", "be disillusioned", "sober up"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["dice", "form", "appearance", "take", "gather", "coloring"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["kettle", "cauldron", "iron pot"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["confinement", "to tie"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["affixed", "attach", "refer to", "append"],
        onyomi: [""]
      },
      { kanji: "", kunyomi: [""], meanings: ["rhyme", "elegance", "tone"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["distribute", "disseminate", "partition", "understand"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", "", ""],
        meanings: [
          "suddenly",
          "immediately",
          "in a hurry",
          "arrange",
          "stay in place",
          "bow",
          "kowtow"
        ],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: ["", ""], meanings: ["cheeks", "jaw"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["jaw", "chin", "gill"],
        onyomi: [""]
      },
      {
        kanji: "",
        kunyomi: ["", ""],
        meanings: ["mochi rice cake"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: ["", "", "", ""],
        meanings: ["food", "bait", "prey", "tempting profit"],
        onyomi: ["", ""]
      },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["bone", "body", "corpse"],
        onyomi: ["", ""]
      },
      { kanji: "", kunyomi: [""], meanings: ["foot of a mountain"], onyomi: [""] },
      {
        kanji: "",
        kunyomi: [""],
        meanings: ["noodles", "wheat flour"],
        onyomi: ["", ""]
      }
    ]
  };
  const toItemData = (d2) => {
    const itemDetailStore = useItemDataStore();
    const id = itemDetailStore.blankItem();
    id.assignments.srs_stage = -1;
    id.object = "kanji";
    id.data.slug = d2.kanji;
    id.data.meanings = [];
    d2.meanings.forEach((m2, i2) => {
      id.data.meanings.push({
        accepted_answer: true,
        meaning: m2,
        primary: i2 == 0
      });
    });
    return id;
  };
  return { data: data6, toItemData };
});
const _hoisted_1$7 = { class: "row" };
const _hoisted_2$7 = { class: "col" };
const _hoisted_3$7 = { class: "level" };
const _hoisted_4$2 = { class: "container" };
const _hoisted_5$2 = { class: "row itemDetails" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "Main",
  setup(__props) {
    const itemDataStore = useItemDataStore(), itemInWK = (slug) => {
      return itemDataStore.itemData.find((i2) => i2.object == "kanji" && i2.data.slug == slug);
    }, joyoStore = useJoyoStore(), sortByWK = (items) => {
      const sortedWkitems = orderBy(
        itemDataStore.itemData.filter((d2) => items.split("").includes(d2.data.slug)),
        [(i2) => i2.assignments.srs_stage, (i2) => i2.data.level],
        ["asc", "asc"]
      ).map((r2) => r2.data.slug);
      return [...sortedWkitems, ...difference(items.split(""), sortedWkitems)];
    };
    return (_ctx, _cache) => {
      const _component_BlockUI = resolveComponent("BlockUI");
      return openBlock(), createBlock(_component_BlockUI, {
        blocked: unref(itemDataStore).loading
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(unref(joyoStore).data.kanji).sort(), (n2) => {
            return openBlock(), createElementBlock("div", {
              key: n2,
              class: "container"
            }, [
              createBaseVNode("div", _hoisted_1$7, [
                createBaseVNode("div", _hoisted_2$7, [
                  createBaseVNode("span", _hoisted_3$7, toDisplayString(n2), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_4$2, [
                createBaseVNode("div", _hoisted_5$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(sortByWK(unref(joyoStore).data.kanji[n2]), (item2) => {
                    return openBlock(), createBlock(ItemDetail, {
                      key: item2,
                      item: itemInWK(item2) ?? unref(joyoStore).toItemData(
                        unref(joyoStore).data["Not In WaniKani"].find(
                          (i2) => i2.kanji == item2
                        )
                      )
                    }, null, 8, ["item"]);
                  }), 128))
                ])
              ])
            ]);
          }), 128))
        ]),
        _: 1
      }, 8, ["blocked"]);
    };
  }
});
const _hoisted_1$6 = { class: "container" };
const _hoisted_2$6 = { class: "row" };
const _hoisted_3$6 = { class: "col" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "JoyoView",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$6, [
          createBaseVNode("div", _hoisted_3$6, [
            createVNode(_sfc_main$7)
          ])
        ])
      ]);
    };
  }
});
const _hoisted_1$5 = { class: "row" };
const _hoisted_2$5 = { class: "col" };
const _hoisted_3$5 = { class: "level" };
const _hoisted_4$1 = { class: "row" };
const _hoisted_5$1 = { class: "col" };
const _hoisted_6$1 = { class: "row" };
const _hoisted_7$1 = { class: "col" };
const _hoisted_8$1 = { class: "type" };
const _hoisted_9$1 = { class: "row itemDetails" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "WaniKani",
  setup(__props) {
    const itemDataStore = useItemDataStore(), userStore = useUserStore();
    onMounted(() => {
      itemDataStore.fetchItemData();
    });
    return (_ctx, _cache) => {
      const _component_BlockUI = resolveComponent("BlockUI");
      return openBlock(), createBlock(_component_BlockUI, {
        blocked: unref(itemDataStore).loading
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(userStore).userData?.level, (n2) => {
            return openBlock(), createElementBlock("div", {
              key: n2,
              class: "container"
            }, [
              createBaseVNode("div", _hoisted_1$5, [
                createBaseVNode("div", _hoisted_2$5, [
                  createBaseVNode("span", _hoisted_3$5, "Level " + toDisplayString(n2), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_4$1, [
                createBaseVNode("div", _hoisted_5$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(itemDataStore).types.filter((t2) => t2 != "kana_vocabulary"), (type) => {
                    return openBlock(), createElementBlock("div", {
                      class: "container",
                      key: type
                    }, [
                      createBaseVNode("div", _hoisted_6$1, [
                        createBaseVNode("div", _hoisted_7$1, [
                          createBaseVNode("span", _hoisted_8$1, toDisplayString(type), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_9$1, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(itemDataStore).itemData.filter(
                          (i2) => i2.object == type && i2.data.level == n2
                        ), (item2) => {
                          return openBlock(), createBlock(ItemDetail, {
                            item: item2,
                            key: item2.id
                          }, null, 8, ["item"]);
                        }), 128))
                      ])
                    ]);
                  }), 128))
                ])
              ])
            ]);
          }), 128))
        ]),
        _: 1
      }, 8, ["blocked"]);
    };
  }
});
const WaniKani = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-68f88925"]]);
const _hoisted_1$4 = { class: "container" };
const _hoisted_2$4 = { class: "row" };
const _hoisted_3$4 = { class: "col" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "WaniKaniView",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$4, [
          createBaseVNode("div", _hoisted_3$4, [
            createVNode(WaniKani)
          ])
        ])
      ]);
    };
  }
});
function t(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, a2 = Array(e2); i2 < e2; i2++) a2[i2] = t2[i2];
  return a2;
}
function e(t2) {
  if (void 0 === t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t2;
}
function i(t2, e2) {
  if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
}
function a(t2, e2) {
  for (var i2 = 0; i2 < e2.length; i2++) {
    var a2 = e2[i2];
    a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, x(a2.key), a2);
  }
}
function s(t2, e2, i2) {
  return e2 && a(t2.prototype, e2), i2 && a(t2, i2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
}
function r(t2, e2) {
  var i2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
  if (!i2) {
    if (Array.isArray(t2) || (i2 = m$1(t2)) || e2) {
      i2 && (t2 = i2);
      var a2 = 0, s2 = function() {
      };
      return { s: s2, n: function() {
        return a2 >= t2.length ? { done: true } : { done: false, value: t2[a2++] };
      }, e: function(t3) {
        throw t3;
      }, f: s2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var r2, n2 = true, o2 = false;
  return { s: function() {
    i2 = i2.call(t2);
  }, n: function() {
    var t3 = i2.next();
    return n2 = t3.done, t3;
  }, e: function(t3) {
    o2 = true, r2 = t3;
  }, f: function() {
    try {
      n2 || null == i2.return || i2.return();
    } finally {
      if (o2) throw r2;
    }
  } };
}
function n(t2) {
  var i2 = c();
  return function() {
    var a2, s2 = l(t2);
    if (i2) {
      var r2 = l(this).constructor;
      a2 = Reflect.construct(s2, arguments, r2);
    } else a2 = s2.apply(this, arguments);
    return (function(t3, i3) {
      if (i3 && ("object" == typeof i3 || "function" == typeof i3)) return i3;
      if (void 0 !== i3) throw new TypeError("Derived constructors may only return object or undefined");
      return e(t3);
    })(this, a2);
  };
}
function o(t2, e2, i2) {
  return (e2 = x(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
function l(t2) {
  return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, l(t2);
}
function h(t2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && g(t2, e2);
}
function c() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
    })));
  } catch (t3) {
  }
  return (c = function() {
    return !!t2;
  })();
}
function d(t2, e2) {
  var i2 = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(t2);
    e2 && (a2 = a2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    }))), i2.push.apply(i2, a2);
  }
  return i2;
}
function u(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? d(Object(i2), true).forEach((function(e3) {
      o(t2, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : d(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t2;
}
function g(t2, e2) {
  return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, g(t2, e2);
}
function p(t2, e2) {
  return (function(t3) {
    if (Array.isArray(t3)) return t3;
  })(t2) || (function(t3, e3) {
    var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
    if (null != i2) {
      var a2, s2, r2, n2, o2 = [], l2 = true, h2 = false;
      try {
        if (r2 = (i2 = i2.call(t3)).next, 0 === e3) {
          if (Object(i2) !== i2) return;
          l2 = false;
        } else for (; !(l2 = (a2 = r2.call(i2)).done) && (o2.push(a2.value), o2.length !== e3); l2 = true) ;
      } catch (t4) {
        h2 = true, s2 = t4;
      } finally {
        try {
          if (!l2 && null != i2.return && (n2 = i2.return(), Object(n2) !== n2)) return;
        } finally {
          if (h2) throw s2;
        }
      }
      return o2;
    }
  })(t2, e2) || m$1(t2, e2) || (function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  })();
}
function f(e2) {
  return (function(e3) {
    if (Array.isArray(e3)) return t(e3);
  })(e2) || (function(t2) {
    if ("undefined" != typeof Symbol && null != t2[Symbol.iterator] || null != t2["@@iterator"]) return Array.from(t2);
  })(e2) || m$1(e2) || (function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  })();
}
function x(t2) {
  var e2 = (function(t3, e3) {
    if ("object" != typeof t3 || !t3) return t3;
    var i2 = t3[Symbol.toPrimitive];
    if (void 0 !== i2) {
      var a2 = i2.call(t3, e3);
      if ("object" != typeof a2) return a2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === e3 ? String : Number)(t3);
  })(t2, "string");
  return "symbol" == typeof e2 ? e2 : e2 + "";
}
function b(t2) {
  return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
  }, b(t2);
}
function m$1(e2, i2) {
  if (e2) {
    if ("string" == typeof e2) return t(e2, i2);
    var a2 = {}.toString.call(e2).slice(8, -1);
    return "Object" === a2 && e2.constructor && (a2 = e2.constructor.name), "Map" === a2 || "Set" === a2 ? Array.from(e2) : "Arguments" === a2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a2) ? t(e2, i2) : void 0;
  }
}
var v = (function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
    var i2 = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), n2 = parseInt(i2[1], 10), o2 = parseInt(i2[2], 10);
    return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - n2) * s2) + n2) + "," + (Math.round((a2 - o2) * s2) + o2) + ")";
  } }, { key: "shadeHexColor", value: function(t3, e2) {
    var i2 = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i2 >> 16, n2 = i2 >> 8 & 255, o2 = 255 & i2;
    return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - n2) * s2) + n2) + (Math.round((a2 - o2) * s2) + o2)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e2, i2) {
    return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
  } }], [{ key: "bind", value: function(t3, e2) {
    return function() {
      return t3.apply(e2, arguments);
    };
  } }, { key: "isObject", value: function(t3) {
    return t3 && "object" === b(t3) && !Array.isArray(t3) && null != t3;
  } }, { key: "is", value: function(t3, e2) {
    return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
  } }, { key: "isSafari", value: function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  } }, { key: "listToArray", value: function(t3) {
    var e2, i2 = [];
    for (e2 = 0; e2 < t3.length; e2++) i2[e2] = t3[e2];
    return i2;
  } }, { key: "extend", value: function(t3, e2) {
    var i2 = this;
    "function" != typeof Object.assign && (Object.assign = function(t4) {
      if (null == t4) throw new TypeError("Cannot convert undefined or null to object");
      for (var e3 = Object(t4), i3 = 1; i3 < arguments.length; i3++) {
        var a3 = arguments[i3];
        if (null != a3) for (var s2 in a3) a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
      }
      return e3;
    });
    var a2 = Object.assign({}, t3);
    return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach((function(s2) {
      i2.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
    })), a2;
  } }, { key: "extendArray", value: function(e2, i2) {
    var a2 = [];
    return e2.map((function(e3) {
      a2.push(t2.extend(i2, e3));
    })), e2 = a2;
  } }, { key: "monthMod", value: function(t3) {
    return t3 % 12;
  } }, { key: "clone", value: function(t3) {
    var e2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (null === t3 || "object" !== b(t3)) return t3;
    if (i2.has(t3)) return i2.get(t3);
    if (Array.isArray(t3)) {
      e2 = [], i2.set(t3, e2);
      for (var a2 = 0; a2 < t3.length; a2++) e2[a2] = this.clone(t3[a2], i2);
    } else if (t3 instanceof Date) e2 = new Date(t3.getTime());
    else for (var s2 in e2 = {}, i2.set(t3, e2), t3) t3.hasOwnProperty(s2) && (e2[s2] = this.clone(t3[s2], i2));
    return e2;
  } }, { key: "log10", value: function(t3) {
    return Math.log(t3) / Math.LN10;
  } }, { key: "roundToBase10", value: function(t3) {
    return Math.pow(10, Math.floor(Math.log10(t3)));
  } }, { key: "roundToBase", value: function(t3, e2) {
    return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
  } }, { key: "parseNumber", value: function(t3) {
    return null === t3 ? t3 : parseFloat(t3);
  } }, { key: "stripNumber", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
    return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(t3) {
    return t3.toString().includes("e") ? Math.round(t3) : t3;
  } }, { key: "elementExists", value: function(t3) {
    return !(!t3 || !t3.isConnected);
  } }, { key: "getDimensions", value: function(t3) {
    var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
    return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
  } }, { key: "getBoundingClientRect", value: function(t3) {
    var e2 = t3.getBoundingClientRect();
    return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
  } }, { key: "getLargestStringFromArr", value: function(t3) {
    return t3.reduce((function(t4, e2) {
      return Array.isArray(e2) && (e2 = e2.reduce((function(t5, e3) {
        return t5.length > e3.length ? t5 : e3;
      }))), t4.length > e2.length ? t4 : e2;
    }), 0);
  } }, { key: "hexToRgba", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
    "#" !== t3.substring(0, 1) && (t3 = "#999999");
    var i2 = t3.replace("#", "");
    i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
    for (var a2 = 0; a2 < i2.length; a2++) i2[a2] = parseInt(1 === i2[a2].length ? i2[a2] + i2[a2] : i2[a2], 16);
    return void 0 !== e2 && i2.push(e2), "rgba(" + i2.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(t3) {
    return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(t3) {
    return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t3.length ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(t3) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
  } }, { key: "getPolygonPos", value: function(t3, e2) {
    for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 < e2; s2++) {
      var r2 = {};
      r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
    }
    return i2;
  } }, { key: "polarToCartesian", value: function(t3, e2, i2, a2) {
    var s2 = (a2 - 90) * Math.PI / 180;
    return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
  } }, { key: "escapeString", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i2 = t3.toString().slice();
    return i2 = i2.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e2);
  } }, { key: "negToZero", value: function(t3) {
    return t3 < 0 ? 0 : t3;
  } }, { key: "moveIndexInArray", value: function(t3, e2, i2) {
    if (i2 >= t3.length) for (var a2 = i2 - t3.length + 1; a2--; ) t3.push(void 0);
    return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
  } }, { key: "extractNumber", value: function(t3) {
    return parseFloat(t3.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(t3, e2) {
    for (; (t3 = t3.parentElement) && !t3.classList.contains(e2); ) ;
    return t3;
  } }, { key: "setELstyles", value: function(t3, e2) {
    for (var i2 in e2) e2.hasOwnProperty(i2) && (t3.style.key = e2[i2]);
  } }, { key: "preciseAddition", value: function(t3, e2) {
    var i2 = (String(t3).split(".")[1] || "").length, a2 = (String(e2).split(".")[1] || "").length, s2 = Math.pow(10, Math.max(i2, a2));
    return (Math.round(t3 * s2) + Math.round(e2 * s2)) / s2;
  } }, { key: "isNumber", value: function(t3) {
    return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
  } }, { key: "isFloat", value: function(t3) {
    return Number(t3) === t3 && t3 % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var t3 = window.navigator.userAgent, e2 = t3.indexOf("Edge/");
    return e2 > 0 && parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
  } }, { key: "getGCD", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    for (t3 = Math.round(Math.abs(t3) * a2), e2 = Math.round(Math.abs(e2) * a2); e2; ) {
      var s2 = e2;
      e2 = t3 % e2, t3 = s2;
    }
    return t3 / a2;
  } }, { key: "getPrimeFactors", value: function(t3) {
    for (var e2 = [], i2 = 2; t3 >= 2; ) t3 % i2 == 0 ? (e2.push(i2), t3 /= i2) : i2++;
    return e2;
  } }, { key: "mod", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t3, e2))));
    return (t3 = Math.round(Math.abs(t3) * a2)) % (e2 = Math.round(Math.abs(e2) * a2)) / a2;
  } }]), t2;
})(), y = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "animateLine", value: function(t3, e2, i2, a2) {
    t3.attr(e2).animate(a2).attr(i2);
  } }, { key: "animateMarker", value: function(t3, e2, i2, a2) {
    t3.attr({ opacity: 0 }).animate(e2).attr({ opacity: 1 }).after((function() {
      a2();
    }));
  } }, { key: "animateRect", value: function(t3, e2, i2, a2, s2) {
    t3.attr(e2).animate(a2).attr(i2).after((function() {
      return s2();
    }));
  } }, { key: "animatePathsGradually", value: function(t3) {
    var e2 = t3.el, i2 = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, n2 = t3.pathTo, o2 = t3.speed, l2 = t3.delay, h2 = this.w, c2 = 0;
    h2.config.chart.animations.animateGradually.enabled && (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled && h2.globals.dataChanged && "bar" !== h2.config.chart.type && (c2 = 0), this.morphSVG(e2, i2, a2, "line" !== h2.config.chart.type || h2.globals.comboCharts ? s2 : "stroke", r2, n2, o2, l2 * c2);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach((function(t3) {
      var e2 = t3.el;
      e2.classList.remove("apexcharts-element-hidden"), e2.classList.add("apexcharts-hidden-element-shown");
    }));
  } }, { key: "animationCompleted", value: function(t3) {
    var e2 = this.w;
    e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e2.config.chart.events.animationEnd && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
  } }, { key: "morphSVG", value: function(t3, e2, i2, a2, s2, r2, n2, o2) {
    var l2 = this, h2 = this.w;
    s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
    var c2 = function(t4) {
      return "radar" === h2.config.chart.type && (n2 = 1), "M 0 ".concat(h2.globals.gridHeight);
    };
    (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2.trim() || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h2.globals.shouldAnimate || (n2 = 1), t3.plot(s2).animate(1, o2).plot(s2).animate(n2, o2).plot(r2).after((function() {
      v.isNumber(i2) ? i2 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t3) : "none" !== a2 && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
    }));
  } }]), t2;
})();
const w = {}, k = [];
function A$1(t2, e2) {
  if (Array.isArray(t2)) for (const i2 of t2) A$1(i2, e2);
  else if ("object" != typeof t2) S(Object.getOwnPropertyNames(e2)), w[t2] = Object.assign(w[t2] || {}, e2);
  else for (const e3 in t2) A$1(e3, t2[e3]);
}
function C(t2) {
  return w[t2] || {};
}
function S(t2) {
  k.push(...t2);
}
function L(t2, e2) {
  let i2;
  const a2 = t2.length, s2 = [];
  for (i2 = 0; i2 < a2; i2++) s2.push(e2(t2[i2]));
  return s2;
}
function M(t2) {
  return t2 % 360 * Math.PI / 180;
}
function P(t2) {
  return t2.charAt(0).toUpperCase() + t2.slice(1);
}
function I(t2, e2, i2, a2) {
  return null != e2 && null != i2 || (a2 = a2 || t2.bbox(), null == e2 ? e2 = a2.width / a2.height * i2 : null == i2 && (i2 = a2.height / a2.width * e2)), { width: e2, height: i2 };
}
function T(t2, e2) {
  const i2 = t2.origin;
  let a2 = null != t2.ox ? t2.ox : null != t2.originX ? t2.originX : "center", s2 = null != t2.oy ? t2.oy : null != t2.originY ? t2.originY : "center";
  null != i2 && ([a2, s2] = Array.isArray(i2) ? i2 : "object" == typeof i2 ? [i2.x, i2.y] : [i2, i2]);
  const r2 = "string" == typeof a2, n2 = "string" == typeof s2;
  if (r2 || n2) {
    const { height: t3, width: i3, x: o2, y: l2 } = e2.bbox();
    r2 && (a2 = a2.includes("left") ? o2 : a2.includes("right") ? o2 + i3 : o2 + i3 / 2), n2 && (s2 = s2.includes("top") ? l2 : s2.includes("bottom") ? l2 + t3 : l2 + t3 / 2);
  }
  return [a2, s2];
}
const z = /* @__PURE__ */ new Set(["desc", "metadata", "title"]), X = (t2) => z.has(t2.nodeName), R = (t2, e2, i2 = {}) => {
  const a2 = { ...e2 };
  for (const t3 in a2) a2[t3].valueOf() === i2[t3] && delete a2[t3];
  Object.keys(a2).length ? t2.node.setAttribute("data-svgjs", JSON.stringify(a2)) : (t2.node.removeAttribute("data-svgjs"), t2.node.removeAttribute("svgjs:data"));
}, E = "http://www.w3.org/2000/svg", Y = "http://www.w3.org/2000/xmlns/", H = "http://www.w3.org/1999/xlink", O = { window: "undefined" == typeof window ? null : window, document: "undefined" == typeof document ? null : document };
function F() {
  return O.window;
}
let D = class {
};
const _ = {}, N = "___SYMBOL___ROOT___";
function W(t2, e2 = E) {
  return O.document.createElementNS(e2, t2);
}
function B(t2, e2 = false) {
  if (t2 instanceof D) return t2;
  if ("object" == typeof t2) return U(t2);
  if (null == t2) return new _[N]();
  if ("string" == typeof t2 && "<" !== t2.charAt(0)) return U(O.document.querySelector(t2));
  const i2 = e2 ? O.document.createElement("div") : W("svg");
  return i2.innerHTML = t2, t2 = U(i2.firstChild), i2.removeChild(i2.firstChild), t2;
}
function G(t2, e2) {
  return e2 && (e2 instanceof O.window.Node || e2.ownerDocument && e2 instanceof e2.ownerDocument.defaultView.Node) ? e2 : W(t2);
}
function V(t2) {
  if (!t2) return null;
  if (t2.instance instanceof D) return t2.instance;
  if ("#document-fragment" === t2.nodeName) return new _.Fragment(t2);
  let e2 = P(t2.nodeName || "Dom");
  return "LinearGradient" === e2 || "RadialGradient" === e2 ? e2 = "Gradient" : _[e2] || (e2 = "Dom"), new _[e2](t2);
}
let U = V;
function q(t2, e2 = t2.name, i2 = false) {
  return _[e2] = t2, i2 && (_[N] = t2), S(Object.getOwnPropertyNames(t2.prototype)), t2;
}
let Z = 1e3;
function $(t2) {
  return "Svgjs" + P(t2) + Z++;
}
function J$1(t2) {
  for (let e2 = t2.children.length - 1; e2 >= 0; e2--) J$1(t2.children[e2]);
  return t2.id ? (t2.id = $(t2.nodeName), t2) : t2;
}
function Q(t2, e2) {
  let i2, a2;
  for (a2 = (t2 = Array.isArray(t2) ? t2 : [t2]).length - 1; a2 >= 0; a2--) for (i2 in e2) t2[a2].prototype[i2] = e2[i2];
}
function K(t2) {
  return function(...e2) {
    const i2 = e2[e2.length - 1];
    return !i2 || i2.constructor !== Object || i2 instanceof Array ? t2.apply(this, e2) : t2.apply(this, e2.slice(0, -1)).attr(i2);
  };
}
A$1("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 + 1), this;
}, backward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 ? t2 - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2), this;
}, after: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2 + 1), this;
}, insertBefore: function(t2) {
  return (t2 = B(t2)).before(this), this;
}, insertAfter: function(t2) {
  return (t2 = B(t2)).after(this), this;
} });
const tt = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, et = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, it = /rgb\((\d+),(\d+),(\d+)\)/, at = /(#[a-z_][a-z0-9\-_]*)/i, st = /\)\s*,?\s*/, rt = /\s/g, nt = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, ot = /^rgb\(/, lt = /^(\s+)?$/, ht = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ct = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, dt = /[\s,]+/, ut = /[MLHVCSQTAZ]/i;
function gt(t2) {
  const e2 = Math.round(t2), i2 = Math.max(0, Math.min(255, e2)).toString(16);
  return 1 === i2.length ? "0" + i2 : i2;
}
function pt(t2, e2) {
  for (let i2 = e2.length; i2--; ) if (null == t2[e2[i2]]) return false;
  return true;
}
function ft(t2, e2, i2) {
  return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t2 + 6 * (e2 - t2) * i2 : i2 < 0.5 ? e2 : i2 < 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - i2) * 6 : t2;
}
A$1("Dom", { classes: function() {
  const t2 = this.attr("class");
  return null == t2 ? [] : t2.trim().split(dt);
}, hasClass: function(t2) {
  return -1 !== this.classes().indexOf(t2);
}, addClass: function(t2) {
  if (!this.hasClass(t2)) {
    const e2 = this.classes();
    e2.push(t2), this.attr("class", e2.join(" "));
  }
  return this;
}, removeClass: function(t2) {
  return this.hasClass(t2) && this.attr("class", this.classes().filter((function(e2) {
    return e2 !== t2;
  })).join(" ")), this;
}, toggleClass: function(t2) {
  return this.hasClass(t2) ? this.removeClass(t2) : this.addClass(t2);
} }), A$1("Dom", { css: function(t2, e2) {
  const i2 = {};
  if (0 === arguments.length) return this.node.style.cssText.split(/\s*;\s*/).filter((function(t3) {
    return !!t3.length;
  })).forEach((function(t3) {
    const e3 = t3.split(/\s*:\s*/);
    i2[e3[0]] = e3[1];
  })), i2;
  if (arguments.length < 2) {
    if (Array.isArray(t2)) {
      for (const e3 of t2) {
        const t3 = e3;
        i2[e3] = this.node.style.getPropertyValue(t3);
      }
      return i2;
    }
    if ("string" == typeof t2) return this.node.style.getPropertyValue(t2);
    if ("object" == typeof t2) for (const e3 in t2) this.node.style.setProperty(e3, null == t2[e3] || lt.test(t2[e3]) ? "" : t2[e3]);
  }
  return 2 === arguments.length && this.node.style.setProperty(t2, null == e2 || lt.test(e2) ? "" : e2), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return "none" !== this.css("display");
} }), A$1("Dom", { data: function(t2, e2, i2) {
  if (null == t2) return this.data(L((function(t3, e3) {
    let i3;
    const a2 = t3.length, s2 = [];
    for (i3 = 0; i3 < a2; i3++) e3(t3[i3]) && s2.push(t3[i3]);
    return s2;
  })(this.node.attributes, ((t3) => 0 === t3.nodeName.indexOf("data-"))), ((t3) => t3.nodeName.slice(5))));
  if (t2 instanceof Array) {
    const e3 = {};
    for (const i3 of t2) e3[i3] = this.data(i3);
    return e3;
  }
  if ("object" == typeof t2) for (e2 in t2) this.data(e2, t2[e2]);
  else if (arguments.length < 2) try {
    return JSON.parse(this.attr("data-" + t2));
  } catch (e3) {
    return this.attr("data-" + t2);
  }
  else this.attr("data-" + t2, null === e2 ? null : true === i2 || "string" == typeof e2 || "number" == typeof e2 ? e2 : JSON.stringify(e2));
  return this;
} }), A$1("Dom", { remember: function(t2, e2) {
  if ("object" == typeof arguments[0]) for (const e3 in t2) this.remember(e3, t2[e3]);
  else {
    if (1 === arguments.length) return this.memory()[t2];
    this.memory()[t2] = e2;
  }
  return this;
}, forget: function() {
  if (0 === arguments.length) this._memory = {};
  else for (let t2 = arguments.length - 1; t2 >= 0; t2--) delete this.memory()[arguments[t2]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
class xt {
  constructor(...t2) {
    this.init(...t2);
  }
  static isColor(t2) {
    return t2 && (t2 instanceof xt || this.isRgb(t2) || this.test(t2));
  }
  static isRgb(t2) {
    return t2 && "number" == typeof t2.r && "number" == typeof t2.g && "number" == typeof t2.b;
  }
  static random(t2 = "vibrant", e2) {
    const { random: i2, round: a2, sin: s2, PI: r2 } = Math;
    if ("vibrant" === t2) {
      const t3 = 24 * i2() + 57, e3 = 38 * i2() + 45, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if ("sine" === t2) {
      const t3 = a2(80 * s2(2 * r2 * (e2 = null == e2 ? i2() : e2) / 0.5 + 0.01) + 150), n2 = a2(50 * s2(2 * r2 * e2 / 0.5 + 4.6) + 200), o2 = a2(100 * s2(2 * r2 * e2 / 0.5 + 2.3) + 150);
      return new xt(t3, n2, o2);
    }
    if ("pastel" === t2) {
      const t3 = 8 * i2() + 86, e3 = 17 * i2() + 9, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if ("dark" === t2) {
      const t3 = 10 + 10 * i2(), e3 = 50 * i2() + 86, a3 = 360 * i2();
      return new xt(t3, e3, a3, "lch");
    }
    if ("rgb" === t2) {
      const t3 = 255 * i2(), e3 = 255 * i2(), a3 = 255 * i2();
      return new xt(t3, e3, a3);
    }
    if ("lab" === t2) {
      const t3 = 100 * i2(), e3 = 256 * i2() - 128, a3 = 256 * i2() - 128;
      return new xt(t3, e3, a3, "lab");
    }
    if ("grey" === t2) {
      const t3 = 255 * i2();
      return new xt(t3, t3, t3);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(t2) {
    return "string" == typeof t2 && (nt.test(t2) || ot.test(t2));
  }
  cmyk() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map(((t3) => t3 / 255)), n2 = Math.min(1 - a2, 1 - s2, 1 - r2);
    if (1 === n2) return new xt(0, 0, 0, 1, "cmyk");
    return new xt((1 - a2 - n2) / (1 - n2), (1 - s2 - n2) / (1 - n2), (1 - r2 - n2) / (1 - n2), n2, "cmyk");
  }
  hsl() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map(((t3) => t3 / 255)), n2 = Math.max(a2, s2, r2), o2 = Math.min(a2, s2, r2), l2 = (n2 + o2) / 2, h2 = n2 === o2, c2 = n2 - o2;
    return new xt(360 * (h2 ? 0 : n2 === a2 ? ((s2 - r2) / c2 + (s2 < r2 ? 6 : 0)) / 6 : n2 === s2 ? ((r2 - a2) / c2 + 2) / 6 : n2 === r2 ? ((a2 - s2) / c2 + 4) / 6 : 0), 100 * (h2 ? 0 : l2 > 0.5 ? c2 / (2 - n2 - o2) : c2 / (n2 + o2)), 100 * l2, "hsl");
  }
  init(t2 = 0, e2 = 0, i2 = 0, a2 = 0, s2 = "rgb") {
    if (t2 = t2 || 0, this.space) for (const t3 in this.space) delete this[this.space[t3]];
    if ("number" == typeof t2) s2 = "string" == typeof a2 ? a2 : s2, a2 = "string" == typeof a2 ? 0 : a2, Object.assign(this, { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 });
    else if (t2 instanceof Array) this.space = e2 || ("string" == typeof t2[3] ? t2[3] : t2[4]) || "rgb", Object.assign(this, { _a: t2[0], _b: t2[1], _c: t2[2], _d: t2[3] || 0 });
    else if (t2 instanceof Object) {
      const i3 = (function(t3, e3) {
        const i4 = pt(t3, "rgb") ? { _a: t3.r, _b: t3.g, _c: t3.b, _d: 0, space: "rgb" } : pt(t3, "xyz") ? { _a: t3.x, _b: t3.y, _c: t3.z, _d: 0, space: "xyz" } : pt(t3, "hsl") ? { _a: t3.h, _b: t3.s, _c: t3.l, _d: 0, space: "hsl" } : pt(t3, "lab") ? { _a: t3.l, _b: t3.a, _c: t3.b, _d: 0, space: "lab" } : pt(t3, "lch") ? { _a: t3.l, _b: t3.c, _c: t3.h, _d: 0, space: "lch" } : pt(t3, "cmyk") ? { _a: t3.c, _b: t3.m, _c: t3.y, _d: t3.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return i4.space = e3 || i4.space, i4;
      })(t2, e2);
      Object.assign(this, i3);
    } else if ("string" == typeof t2) if (ot.test(t2)) {
      const e3 = t2.replace(rt, ""), [i3, a3, s3] = it.exec(e3).slice(1, 4).map(((t3) => parseInt(t3)));
      Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: "rgb" });
    } else {
      if (!nt.test(t2)) throw Error("Unsupported string format, can't construct Color");
      {
        const e3 = (t3) => parseInt(t3, 16), [, i3, a3, s3] = et.exec((function(t3) {
          return 4 === t3.length ? ["#", t3.substring(1, 2), t3.substring(1, 2), t3.substring(2, 3), t3.substring(2, 3), t3.substring(3, 4), t3.substring(3, 4)].join("") : t3;
        })(t2)).map(e3);
        Object.assign(this, { _a: i3, _b: a3, _c: s3, _d: 0, space: "rgb" });
      }
    }
    const { _a: r2, _b: n2, _c: o2, _d: l2 } = this, h2 = "rgb" === this.space ? { r: r2, g: n2, b: o2 } : "xyz" === this.space ? { x: r2, y: n2, z: o2 } : "hsl" === this.space ? { h: r2, s: n2, l: o2 } : "lab" === this.space ? { l: r2, a: n2, b: o2 } : "lch" === this.space ? { l: r2, c: n2, h: o2 } : "cmyk" === this.space ? { c: r2, m: n2, y: o2, k: l2 } : {};
    Object.assign(this, h2);
  }
  lab() {
    const { x: t2, y: e2, z: i2 } = this.xyz();
    return new xt(116 * e2 - 16, 500 * (t2 - e2), 200 * (e2 - i2), "lab");
  }
  lch() {
    const { l: t2, a: e2, b: i2 } = this.lab(), a2 = Math.sqrt(e2 ** 2 + i2 ** 2);
    let s2 = 180 * Math.atan2(i2, e2) / Math.PI;
    s2 < 0 && (s2 *= -1, s2 = 360 - s2);
    return new xt(t2, a2, s2, "lch");
  }
  rgb() {
    if ("rgb" === this.space) return this;
    if ("lab" === (t2 = this.space) || "xyz" === t2 || "lch" === t2) {
      let { x: t3, y: e2, z: i2 } = this;
      if ("lab" === this.space || "lch" === this.space) {
        let { l: a3, a: s3, b: r3 } = this;
        if ("lch" === this.space) {
          const { c: t4, h: e3 } = this, i3 = Math.PI / 180;
          s3 = t4 * Math.cos(i3 * e3), r3 = t4 * Math.sin(i3 * e3);
        }
        const n3 = (a3 + 16) / 116, o3 = s3 / 500 + n3, l3 = n3 - r3 / 200, h3 = 16 / 116, c3 = 8856e-6, d2 = 7.787;
        t3 = 0.95047 * (o3 ** 3 > c3 ? o3 ** 3 : (o3 - h3) / d2), e2 = 1 * (n3 ** 3 > c3 ? n3 ** 3 : (n3 - h3) / d2), i2 = 1.08883 * (l3 ** 3 > c3 ? l3 ** 3 : (l3 - h3) / d2);
      }
      const a2 = 3.2406 * t3 + -1.5372 * e2 + -0.4986 * i2, s2 = -0.9689 * t3 + 1.8758 * e2 + 0.0415 * i2, r2 = 0.0557 * t3 + -0.204 * e2 + 1.057 * i2, n2 = Math.pow, o2 = 31308e-7, l2 = a2 > o2 ? 1.055 * n2(a2, 1 / 2.4) - 0.055 : 12.92 * a2, h2 = s2 > o2 ? 1.055 * n2(s2, 1 / 2.4) - 0.055 : 12.92 * s2, c2 = r2 > o2 ? 1.055 * n2(r2, 1 / 2.4) - 0.055 : 12.92 * r2;
      return new xt(255 * l2, 255 * h2, 255 * c2);
    }
    if ("hsl" === this.space) {
      let { h: t3, s: e2, l: i2 } = this;
      if (t3 /= 360, e2 /= 100, i2 /= 100, 0 === e2) {
        i2 *= 255;
        return new xt(i2, i2, i2);
      }
      const a2 = i2 < 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, s2 = 2 * i2 - a2, r2 = 255 * ft(s2, a2, t3 + 1 / 3), n2 = 255 * ft(s2, a2, t3), o2 = 255 * ft(s2, a2, t3 - 1 / 3);
      return new xt(r2, n2, o2);
    }
    if ("cmyk" === this.space) {
      const { c: t3, m: e2, y: i2, k: a2 } = this, s2 = 255 * (1 - Math.min(1, t3 * (1 - a2) + a2)), r2 = 255 * (1 - Math.min(1, e2 * (1 - a2) + a2)), n2 = 255 * (1 - Math.min(1, i2 * (1 - a2) + a2));
      return new xt(s2, r2, n2);
    }
    return this;
    var t2;
  }
  toArray() {
    const { _a: t2, _b: e2, _c: i2, _d: a2, space: s2 } = this;
    return [t2, e2, i2, a2, s2];
  }
  toHex() {
    const [t2, e2, i2] = this._clamped().map(gt);
    return `#${t2}${e2}${i2}`;
  }
  toRgb() {
    const [t2, e2, i2] = this._clamped();
    return `rgb(${t2},${e2},${i2})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), [a2, s2, r2] = [t2, e2, i2].map(((t3) => t3 / 255)), n2 = a2 > 0.04045 ? Math.pow((a2 + 0.055) / 1.055, 2.4) : a2 / 12.92, o2 = s2 > 0.04045 ? Math.pow((s2 + 0.055) / 1.055, 2.4) : s2 / 12.92, l2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92, h2 = (0.4124 * n2 + 0.3576 * o2 + 0.1805 * l2) / 0.95047, c2 = (0.2126 * n2 + 0.7152 * o2 + 0.0722 * l2) / 1, d2 = (0.0193 * n2 + 0.1192 * o2 + 0.9505 * l2) / 1.08883, u2 = h2 > 8856e-6 ? Math.pow(h2, 1 / 3) : 7.787 * h2 + 16 / 116, g2 = c2 > 8856e-6 ? Math.pow(c2, 1 / 3) : 7.787 * c2 + 16 / 116, p2 = d2 > 8856e-6 ? Math.pow(d2, 1 / 3) : 7.787 * d2 + 16 / 116;
    return new xt(u2, g2, p2, "xyz");
  }
  _clamped() {
    const { _a: t2, _b: e2, _c: i2 } = this.rgb(), { max: a2, min: s2, round: r2 } = Math;
    return [t2, e2, i2].map(((t3) => a2(0, s2(r2(t3), 255))));
  }
}
class bt {
  constructor(...t2) {
    this.init(...t2);
  }
  clone() {
    return new bt(this);
  }
  init(t2, e2) {
    const i2 = 0, a2 = 0, s2 = Array.isArray(t2) ? { x: t2[0], y: t2[1] } : "object" == typeof t2 ? { x: t2.x, y: t2.y } : { x: t2, y: e2 };
    return this.x = null == s2.x ? i2 : s2.x, this.y = null == s2.y ? a2 : s2.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    const { x: e2, y: i2 } = this;
    return this.x = t2.a * e2 + t2.c * i2 + t2.e, this.y = t2.b * e2 + t2.d * i2 + t2.f, this;
  }
}
function mt(t2, e2, i2) {
  return Math.abs(e2 - t2) < 1e-6;
}
class vt {
  constructor(...t2) {
    this.init(...t2);
  }
  static formatTransforms(t2) {
    const e2 = "both" === t2.flip || true === t2.flip, i2 = t2.flip && (e2 || "x" === t2.flip) ? -1 : 1, a2 = t2.flip && (e2 || "y" === t2.flip) ? -1 : 1, s2 = t2.skew && t2.skew.length ? t2.skew[0] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewX) ? t2.skewX : 0, r2 = t2.skew && t2.skew.length ? t2.skew[1] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewY) ? t2.skewY : 0, n2 = t2.scale && t2.scale.length ? t2.scale[0] * i2 : isFinite(t2.scale) ? t2.scale * i2 : isFinite(t2.scaleX) ? t2.scaleX * i2 : i2, o2 = t2.scale && t2.scale.length ? t2.scale[1] * a2 : isFinite(t2.scale) ? t2.scale * a2 : isFinite(t2.scaleY) ? t2.scaleY * a2 : a2, l2 = t2.shear || 0, h2 = t2.rotate || t2.theta || 0, c2 = new bt(t2.origin || t2.around || t2.ox || t2.originX, t2.oy || t2.originY), d2 = c2.x, u2 = c2.y, g2 = new bt(t2.position || t2.px || t2.positionX || NaN, t2.py || t2.positionY || NaN), p2 = g2.x, f2 = g2.y, x2 = new bt(t2.translate || t2.tx || t2.translateX, t2.ty || t2.translateY), b2 = x2.x, m2 = x2.y, v2 = new bt(t2.relative || t2.rx || t2.relativeX, t2.ry || t2.relativeY);
    return { scaleX: n2, scaleY: o2, skewX: s2, skewY: r2, shear: l2, theta: h2, rx: v2.x, ry: v2.y, tx: b2, ty: m2, ox: d2, oy: u2, px: p2, py: f2 };
  }
  static fromArray(t2) {
    return { a: t2[0], b: t2[1], c: t2[2], d: t2[3], e: t2[4], f: t2[5] };
  }
  static isMatrixLike(t2) {
    return null != t2.a || null != t2.b || null != t2.c || null != t2.d || null != t2.e || null != t2.f;
  }
  static matrixMultiply(t2, e2, i2) {
    const a2 = t2.a * e2.a + t2.c * e2.b, s2 = t2.b * e2.a + t2.d * e2.b, r2 = t2.a * e2.c + t2.c * e2.d, n2 = t2.b * e2.c + t2.d * e2.d, o2 = t2.e + t2.a * e2.e + t2.c * e2.f, l2 = t2.f + t2.b * e2.e + t2.d * e2.f;
    return i2.a = a2, i2.b = s2, i2.c = r2, i2.d = n2, i2.e = o2, i2.f = l2, i2;
  }
  around(t2, e2, i2) {
    return this.clone().aroundO(t2, e2, i2);
  }
  aroundO(t2, e2, i2) {
    const a2 = t2 || 0, s2 = e2 || 0;
    return this.translateO(-a2, -s2).lmultiplyO(i2).translateO(a2, s2);
  }
  clone() {
    return new vt(this);
  }
  decompose(t2 = 0, e2 = 0) {
    const i2 = this.a, a2 = this.b, s2 = this.c, r2 = this.d, n2 = this.e, o2 = this.f, l2 = i2 * r2 - a2 * s2, h2 = l2 > 0 ? 1 : -1, c2 = h2 * Math.sqrt(i2 * i2 + a2 * a2), d2 = Math.atan2(h2 * a2, h2 * i2), u2 = 180 / Math.PI * d2, g2 = Math.cos(d2), p2 = Math.sin(d2), f2 = (i2 * s2 + a2 * r2) / l2, x2 = s2 * c2 / (f2 * i2 - a2) || r2 * c2 / (f2 * a2 + i2);
    return { scaleX: c2, scaleY: x2, shear: f2, rotate: u2, translateX: n2 - t2 + t2 * g2 * c2 + e2 * (f2 * g2 * c2 - p2 * x2), translateY: o2 - e2 + t2 * p2 * c2 + e2 * (f2 * p2 * c2 + g2 * x2), originX: t2, originY: e2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(t2) {
    if (t2 === this) return true;
    const e2 = new vt(t2);
    return mt(this.a, e2.a) && mt(this.b, e2.b) && mt(this.c, e2.c) && mt(this.d, e2.d) && mt(this.e, e2.e) && mt(this.f, e2.f);
  }
  flip(t2, e2) {
    return this.clone().flipO(t2, e2);
  }
  flipO(t2, e2) {
    return "x" === t2 ? this.scaleO(-1, 1, e2, 0) : "y" === t2 ? this.scaleO(1, -1, 0, e2) : this.scaleO(-1, -1, t2, e2 || t2);
  }
  init(t2) {
    const e2 = vt.fromArray([1, 0, 0, 1, 0, 0]);
    return t2 = t2 instanceof Gt ? t2.matrixify() : "string" == typeof t2 ? vt.fromArray(t2.split(dt).map(parseFloat)) : Array.isArray(t2) ? vt.fromArray(t2) : "object" == typeof t2 && vt.isMatrixLike(t2) ? t2 : "object" == typeof t2 ? new vt().transform(t2) : 6 === arguments.length ? vt.fromArray([].slice.call(arguments)) : e2, this.a = null != t2.a ? t2.a : e2.a, this.b = null != t2.b ? t2.b : e2.b, this.c = null != t2.c ? t2.c : e2.c, this.d = null != t2.d ? t2.d : e2.d, this.e = null != t2.e ? t2.e : e2.e, this.f = null != t2.f ? t2.f : e2.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const t2 = this.a, e2 = this.b, i2 = this.c, a2 = this.d, s2 = this.e, r2 = this.f, n2 = t2 * a2 - e2 * i2;
    if (!n2) throw new Error("Cannot invert " + this);
    const o2 = a2 / n2, l2 = -e2 / n2, h2 = -i2 / n2, c2 = t2 / n2, d2 = -(o2 * s2 + h2 * r2), u2 = -(l2 * s2 + c2 * r2);
    return this.a = o2, this.b = l2, this.c = h2, this.d = c2, this.e = d2, this.f = u2, this;
  }
  lmultiply(t2) {
    return this.clone().lmultiplyO(t2);
  }
  lmultiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(e2, this, this);
  }
  multiply(t2) {
    return this.clone().multiplyO(t2);
  }
  multiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(this, e2, this);
  }
  rotate(t2, e2, i2) {
    return this.clone().rotateO(t2, e2, i2);
  }
  rotateO(t2, e2 = 0, i2 = 0) {
    t2 = M(t2);
    const a2 = Math.cos(t2), s2 = Math.sin(t2), { a: r2, b: n2, c: o2, d: l2, e: h2, f: c2 } = this;
    return this.a = r2 * a2 - n2 * s2, this.b = n2 * a2 + r2 * s2, this.c = o2 * a2 - l2 * s2, this.d = l2 * a2 + o2 * s2, this.e = h2 * a2 - c2 * s2 + i2 * s2 - e2 * a2 + e2, this.f = c2 * a2 + h2 * s2 - e2 * s2 - i2 * a2 + i2, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(t2, e2 = t2, i2 = 0, a2 = 0) {
    3 === arguments.length && (a2 = i2, i2 = e2, e2 = t2);
    const { a: s2, b: r2, c: n2, d: o2, e: l2, f: h2 } = this;
    return this.a = s2 * t2, this.b = r2 * e2, this.c = n2 * t2, this.d = o2 * e2, this.e = l2 * t2 - i2 * t2 + i2, this.f = h2 * e2 - a2 * e2 + a2, this;
  }
  shear(t2, e2, i2) {
    return this.clone().shearO(t2, e2, i2);
  }
  shearO(t2, e2 = 0, i2 = 0) {
    const { a: a2, b: s2, c: r2, d: n2, e: o2, f: l2 } = this;
    return this.a = a2 + s2 * t2, this.c = r2 + n2 * t2, this.e = o2 + l2 * t2 - i2 * t2, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(t2, e2 = t2, i2 = 0, a2 = 0) {
    3 === arguments.length && (a2 = i2, i2 = e2, e2 = t2), t2 = M(t2), e2 = M(e2);
    const s2 = Math.tan(t2), r2 = Math.tan(e2), { a: n2, b: o2, c: l2, d: h2, e: c2, f: d2 } = this;
    return this.a = n2 + o2 * s2, this.b = o2 + n2 * r2, this.c = l2 + h2 * s2, this.d = h2 + l2 * r2, this.e = c2 + d2 * s2 - a2 * s2, this.f = d2 + c2 * r2 - i2 * r2, this;
  }
  skewX(t2, e2, i2) {
    return this.skew(t2, 0, e2, i2);
  }
  skewY(t2, e2, i2) {
    return this.skew(0, t2, e2, i2);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(t2) {
    if (vt.isMatrixLike(t2)) {
      return new vt(t2).multiplyO(this);
    }
    const e2 = vt.formatTransforms(t2), { x: i2, y: a2 } = new bt(e2.ox, e2.oy).transform(this), s2 = new vt().translateO(e2.rx, e2.ry).lmultiplyO(this).translateO(-i2, -a2).scaleO(e2.scaleX, e2.scaleY).skewO(e2.skewX, e2.skewY).shearO(e2.shear).rotateO(e2.theta).translateO(i2, a2);
    if (isFinite(e2.px) || isFinite(e2.py)) {
      const t3 = new bt(i2, a2).transform(s2), r2 = isFinite(e2.px) ? e2.px - t3.x : 0, n2 = isFinite(e2.py) ? e2.py - t3.y : 0;
      s2.translateO(r2, n2);
    }
    return s2.translateO(e2.tx, e2.ty), s2;
  }
  translate(t2, e2) {
    return this.clone().translateO(t2, e2);
  }
  translateO(t2, e2) {
    return this.e += t2 || 0, this.f += e2 || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
function yt() {
  if (!yt.nodes) {
    const t2 = B().size(2, 0);
    t2.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), t2.attr("focusable", "false"), t2.attr("aria-hidden", "true");
    const e2 = t2.path().node;
    yt.nodes = { svg: t2, path: e2 };
  }
  if (!yt.nodes.svg.node.parentNode) {
    const t2 = O.document.body || O.document.documentElement;
    yt.nodes.svg.addTo(t2);
  }
  return yt.nodes;
}
function wt(t2) {
  return !(t2.width || t2.height || t2.x || t2.y);
}
q(vt, "Matrix");
class kt {
  constructor(...t2) {
    this.init(...t2);
  }
  addOffset() {
    return this.x += O.window.pageXOffset, this.y += O.window.pageYOffset, new kt(this);
  }
  init(t2) {
    return t2 = "string" == typeof t2 ? t2.split(dt).map(parseFloat) : Array.isArray(t2) ? t2 : "object" == typeof t2 ? [null != t2.left ? t2.left : t2.x, null != t2.top ? t2.top : t2.y, t2.width, t2.height] : 4 === arguments.length ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = t2[0] || 0, this.y = t2[1] || 0, this.width = this.w = t2[2] || 0, this.height = this.h = t2[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return wt(this);
  }
  merge(t2) {
    const e2 = Math.min(this.x, t2.x), i2 = Math.min(this.y, t2.y), a2 = Math.max(this.x + this.width, t2.x + t2.width) - e2, s2 = Math.max(this.y + this.height, t2.y + t2.height) - i2;
    return new kt(e2, i2, a2, s2);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(t2) {
    t2 instanceof vt || (t2 = new vt(t2));
    let e2 = 1 / 0, i2 = -1 / 0, a2 = 1 / 0, s2 = -1 / 0;
    return [new bt(this.x, this.y), new bt(this.x2, this.y), new bt(this.x, this.y2), new bt(this.x2, this.y2)].forEach((function(r2) {
      r2 = r2.transform(t2), e2 = Math.min(e2, r2.x), i2 = Math.max(i2, r2.x), a2 = Math.min(a2, r2.y), s2 = Math.max(s2, r2.y);
    })), new kt(e2, a2, i2 - e2, s2 - a2);
  }
}
function At(t2, e2, i2) {
  let a2;
  try {
    if (a2 = e2(t2.node), wt(a2) && ((s2 = t2.node) !== O.document && !(O.document.documentElement.contains || function(t3) {
      for (; t3.parentNode; ) t3 = t3.parentNode;
      return t3 === O.document;
    }).call(O.document.documentElement, s2))) throw new Error("Element not in the dom");
  } catch (e3) {
    a2 = i2(t2);
  }
  var s2;
  return a2;
}
A$1({ viewbox: { viewbox(t2, e2, i2, a2) {
  return null == t2 ? new kt(this.attr("viewBox")) : this.attr("viewBox", new kt(t2, e2, i2, a2));
}, zoom(t2, e2) {
  let { width: i2, height: a2 } = this.attr(["width", "height"]);
  if ((i2 || a2) && "string" != typeof i2 && "string" != typeof a2 || (i2 = this.node.clientWidth, a2 = this.node.clientHeight), !i2 || !a2) throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const s2 = this.viewbox(), r2 = i2 / s2.width, n2 = a2 / s2.height, o2 = Math.min(r2, n2);
  if (null == t2) return o2;
  let l2 = o2 / t2;
  l2 === 1 / 0 && (l2 = Number.MAX_SAFE_INTEGER / 100), e2 = e2 || new bt(i2 / 2 / r2 + s2.x, a2 / 2 / n2 + s2.y);
  const h2 = new kt(s2).transform(new vt({ scale: l2, origin: e2 }));
  return this.viewbox(h2);
} } }), q(kt, "Box");
class Ct extends Array {
  constructor(t2 = [], ...e2) {
    if (super(t2, ...e2), "number" == typeof t2) return this;
    this.length = 0, this.push(...t2);
  }
}
Q([Ct], { each(t2, ...e2) {
  return "function" == typeof t2 ? this.map(((e3, i2, a2) => t2.call(e3, e3, i2, a2))) : this.map(((i2) => i2[t2](...e2)));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
const St = ["toArray", "constructor", "each"];
function Lt(t2, e2) {
  return new Ct(L((e2 || O.document).querySelectorAll(t2), (function(t3) {
    return V(t3);
  })));
}
Ct.extend = function(t2) {
  t2 = t2.reduce(((t3, e2) => (St.includes(e2) || "_" === e2[0] || (e2 in Array.prototype && (t3["$" + e2] = Array.prototype[e2]), t3[e2] = function(...t4) {
    return this.each(e2, ...t4);
  }), t3)), {}), Q([Ct], t2);
};
let Mt = 0;
const Pt = {};
function It(t2) {
  let e2 = t2.getEventHolder();
  return e2 === O.window && (e2 = Pt), e2.events || (e2.events = {}), e2.events;
}
function Tt(t2) {
  return t2.getEventTarget();
}
function zt(t2, e2, i2, a2, s2) {
  const r2 = i2.bind(a2 || t2), n2 = B(t2), o2 = It(n2), l2 = Tt(n2);
  e2 = Array.isArray(e2) ? e2 : e2.split(dt), i2._svgjsListenerId || (i2._svgjsListenerId = ++Mt), e2.forEach((function(t3) {
    const e3 = t3.split(".")[0], a3 = t3.split(".")[1] || "*";
    o2[e3] = o2[e3] || {}, o2[e3][a3] = o2[e3][a3] || {}, o2[e3][a3][i2._svgjsListenerId] = r2, l2.addEventListener(e3, r2, s2 || false);
  }));
}
function Xt(t2, e2, i2, a2) {
  const s2 = B(t2), r2 = It(s2), n2 = Tt(s2);
  ("function" != typeof i2 || (i2 = i2._svgjsListenerId)) && (e2 = Array.isArray(e2) ? e2 : (e2 || "").split(dt)).forEach((function(t3) {
    const e3 = t3 && t3.split(".")[0], o2 = t3 && t3.split(".")[1];
    let l2, h2;
    if (i2) r2[e3] && r2[e3][o2 || "*"] && (n2.removeEventListener(e3, r2[e3][o2 || "*"][i2], a2 || false), delete r2[e3][o2 || "*"][i2]);
    else if (e3 && o2) {
      if (r2[e3] && r2[e3][o2]) {
        for (h2 in r2[e3][o2]) Xt(n2, [e3, o2].join("."), h2);
        delete r2[e3][o2];
      }
    } else if (o2) for (t3 in r2) for (l2 in r2[t3]) o2 === l2 && Xt(n2, [t3, o2].join("."));
    else if (e3) {
      if (r2[e3]) {
        for (l2 in r2[e3]) Xt(n2, [e3, l2].join("."));
        delete r2[e3];
      }
    } else {
      for (t3 in r2) Xt(n2, t3);
      !(function(t4) {
        let e4 = t4.getEventHolder();
        e4 === O.window && (e4 = Pt), e4.events && (e4.events = {});
      })(s2);
    }
  }));
}
class Rt extends D {
  addEventListener() {
  }
  dispatch(t2, e2, i2) {
    return (function(t3, e3, i3, a2) {
      const s2 = Tt(t3);
      return e3 instanceof O.window.Event || (e3 = new O.window.CustomEvent(e3, { detail: i3, cancelable: true, ...a2 })), s2.dispatchEvent(e3), e3;
    })(this, t2, e2, i2);
  }
  dispatchEvent(t2) {
    const e2 = this.getEventHolder().events;
    if (!e2) return true;
    const i2 = e2[t2.type];
    for (const e3 in i2) for (const a2 in i2[e3]) i2[e3][a2](t2);
    return !t2.defaultPrevented;
  }
  fire(t2, e2, i2) {
    return this.dispatch(t2, e2, i2), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(t2, e2, i2) {
    return Xt(this, t2, e2, i2), this;
  }
  on(t2, e2, i2, a2) {
    return zt(this, t2, e2, i2, a2), this;
  }
  removeEventListener() {
  }
}
function Et() {
}
q(Rt, "EventTarget");
const Yt = 400, Ht = ">", Ot = 0, Ft = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };
class Dt extends Array {
  constructor(...t2) {
    super(...t2), this.init(...t2);
  }
  clone() {
    return new this.constructor(this);
  }
  init(t2) {
    return "number" == typeof t2 || (this.length = 0, this.push(...this.parse(t2))), this;
  }
  parse(t2 = []) {
    return t2 instanceof Array ? t2 : t2.trim().split(dt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const t2 = [];
    return t2.push(...this), t2;
  }
}
class _t {
  constructor(...t2) {
    this.init(...t2);
  }
  convert(t2) {
    return new _t(this.value, t2);
  }
  divide(t2) {
    return t2 = new _t(t2), new _t(this / t2, this.unit || t2.unit);
  }
  init(t2, e2) {
    return e2 = Array.isArray(t2) ? t2[1] : e2, t2 = Array.isArray(t2) ? t2[0] : t2, this.value = 0, this.unit = e2 || "", "number" == typeof t2 ? this.value = isNaN(t2) ? 0 : isFinite(t2) ? t2 : t2 < 0 ? -34e37 : 34e37 : "string" == typeof t2 ? (e2 = t2.match(tt)) && (this.value = parseFloat(e2[1]), "%" === e2[5] ? this.value /= 100 : "s" === e2[5] && (this.value *= 1e3), this.unit = e2[5]) : t2 instanceof _t && (this.value = t2.valueOf(), this.unit = t2.unit), this;
  }
  minus(t2) {
    return t2 = new _t(t2), new _t(this - t2, this.unit || t2.unit);
  }
  plus(t2) {
    return t2 = new _t(t2), new _t(this + t2, this.unit || t2.unit);
  }
  times(t2) {
    return t2 = new _t(t2), new _t(this * t2, this.unit || t2.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return ("%" === this.unit ? ~~(1e8 * this.value) / 1e6 : "s" === this.unit ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
const Nt = /* @__PURE__ */ new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]), Wt = [];
class Bt extends Rt {
  constructor(t2, e2) {
    super(), this.node = t2, this.type = t2.nodeName, e2 && t2 !== e2 && this.attr(e2);
  }
  add(t2, e2) {
    return (t2 = B(t2)).removeNamespace && this.node instanceof O.window.SVGElement && t2.removeNamespace(), null == e2 ? this.node.appendChild(t2.node) : t2.node !== this.node.childNodes[e2] && this.node.insertBefore(t2.node, this.node.childNodes[e2]), this;
  }
  addTo(t2, e2) {
    return B(t2).put(this, e2);
  }
  children() {
    return new Ct(L(this.node.children, (function(t2) {
      return V(t2);
    })));
  }
  clear() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(t2 = true, e2 = true) {
    this.writeDataToDom();
    let i2 = this.node.cloneNode(t2);
    return e2 && (i2 = J$1(i2)), new this.constructor(i2);
  }
  each(t2, e2) {
    const i2 = this.children();
    let a2, s2;
    for (a2 = 0, s2 = i2.length; a2 < s2; a2++) t2.apply(i2[a2], [a2, i2]), e2 && i2[a2].each(t2, e2);
    return this;
  }
  element(t2, e2) {
    return this.put(new Bt(W(t2), e2));
  }
  first() {
    return V(this.node.firstChild);
  }
  get(t2) {
    return V(this.node.childNodes[t2]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(t2) {
    return this.index(t2) >= 0;
  }
  html(t2, e2) {
    return this.xml(t2, e2, "http://www.w3.org/1999/xhtml");
  }
  id(t2) {
    return void 0 !== t2 || this.node.id || (this.node.id = $(this.type)), this.attr("id", t2);
  }
  index(t2) {
    return [].slice.call(this.node.childNodes).indexOf(t2.node);
  }
  last() {
    return V(this.node.lastChild);
  }
  matches(t2) {
    const e2 = this.node, i2 = e2.matches || e2.matchesSelector || e2.msMatchesSelector || e2.mozMatchesSelector || e2.webkitMatchesSelector || e2.oMatchesSelector || null;
    return i2 && i2.call(e2, t2);
  }
  parent(t2) {
    let e2 = this;
    if (!e2.node.parentNode) return null;
    if (e2 = V(e2.node.parentNode), !t2) return e2;
    do {
      if ("string" == typeof t2 ? e2.matches(t2) : e2 instanceof t2) return e2;
    } while (e2 = V(e2.node.parentNode));
    return e2;
  }
  put(t2, e2) {
    return t2 = B(t2), this.add(t2, e2), t2;
  }
  putIn(t2, e2) {
    return B(t2).add(this, e2);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(t2) {
    return this.node.removeChild(t2.node), this;
  }
  replace(t2) {
    return t2 = B(t2), this.node.parentNode && this.node.parentNode.replaceChild(t2.node, this.node), t2;
  }
  round(t2 = 2, e2 = null) {
    const i2 = 10 ** t2, a2 = this.attr(e2);
    for (const t3 in a2) "number" == typeof a2[t3] && (a2[t3] = Math.round(a2[t3] * i2) / i2);
    return this.attr(a2), this;
  }
  svg(t2, e2) {
    return this.xml(t2, e2, E);
  }
  toString() {
    return this.id();
  }
  words(t2) {
    return this.node.textContent = t2, this;
  }
  wrap(t2) {
    const e2 = this.parent();
    if (!e2) return this.addTo(t2);
    const i2 = e2.index(this);
    return e2.put(t2, i2).put(this);
  }
  writeDataToDom() {
    return this.each((function() {
      this.writeDataToDom();
    })), this;
  }
  xml(t2, e2, i2) {
    if ("boolean" == typeof t2 && (i2 = e2, e2 = t2, t2 = null), null == t2 || "function" == typeof t2) {
      e2 = null == e2 || e2, this.writeDataToDom();
      let i3 = this;
      if (null != t2) {
        if (i3 = V(i3.node.cloneNode(true)), e2) {
          const e3 = t2(i3);
          if (i3 = e3 || i3, false === e3) return "";
        }
        i3.each((function() {
          const e3 = t2(this), i4 = e3 || this;
          false === e3 ? this.remove() : e3 && this !== i4 && this.replace(i4);
        }), true);
      }
      return e2 ? i3.node.outerHTML : i3.node.innerHTML;
    }
    e2 = null != e2 && e2;
    const a2 = W("wrapper", i2), s2 = O.document.createDocumentFragment();
    a2.innerHTML = t2;
    for (let t3 = a2.children.length; t3--; ) s2.appendChild(a2.firstElementChild);
    const r2 = this.parent();
    return e2 ? this.replace(s2) && r2 : this.add(s2);
  }
}
Q(Bt, { attr: function(t2, e2, i2) {
  if (null == t2) {
    t2 = {}, e2 = this.node.attributes;
    for (const i3 of e2) t2[i3.nodeName] = ht.test(i3.nodeValue) ? parseFloat(i3.nodeValue) : i3.nodeValue;
    return t2;
  }
  if (t2 instanceof Array) return t2.reduce(((t3, e3) => (t3[e3] = this.attr(e3), t3)), {});
  if ("object" == typeof t2 && t2.constructor === Object) for (e2 in t2) this.attr(e2, t2[e2]);
  else if (null === e2) this.node.removeAttribute(t2);
  else {
    if (null == e2) return null == (e2 = this.node.getAttribute(t2)) ? Ft[t2] : ht.test(e2) ? parseFloat(e2) : e2;
    "number" == typeof (e2 = Wt.reduce(((e3, i3) => i3(t2, e3, this)), e2)) ? e2 = new _t(e2) : Nt.has(t2) && xt.isColor(e2) ? e2 = new xt(e2) : e2.constructor === Array && (e2 = new Dt(e2)), "leading" === t2 ? this.leading && this.leading(e2) : "string" == typeof i2 ? this.node.setAttributeNS(i2, t2, e2.toString()) : this.node.setAttribute(t2, e2.toString()), !this.rebuild || "font-size" !== t2 && "x" !== t2 || this.rebuild();
  }
  return this;
}, find: function(t2) {
  return Lt(t2, this.node);
}, findOne: function(t2) {
  return V(this.node.querySelector(t2));
} }), q(Bt, "Dom");
let Gt = class extends Bt {
  constructor(t2, e2) {
    super(t2, e2), this.dom = {}, this.node.instance = this, (t2.hasAttribute("data-svgjs") || t2.hasAttribute("svgjs:data")) && this.setData(JSON.parse(t2.getAttribute("data-svgjs")) ?? JSON.parse(t2.getAttribute("svgjs:data")) ?? {});
  }
  center(t2, e2) {
    return this.cx(t2).cy(e2);
  }
  cx(t2) {
    return null == t2 ? this.x() + this.width() / 2 : this.x(t2 - this.width() / 2);
  }
  cy(t2) {
    return null == t2 ? this.y() + this.height() / 2 : this.y(t2 - this.height() / 2);
  }
  defs() {
    const t2 = this.root();
    return t2 && t2.defs();
  }
  dmove(t2, e2) {
    return this.dx(t2).dy(e2);
  }
  dx(t2 = 0) {
    return this.x(new _t(t2).plus(this.x()));
  }
  dy(t2 = 0) {
    return this.y(new _t(t2).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(t2) {
    return this.attr("height", t2);
  }
  move(t2, e2) {
    return this.x(t2).y(e2);
  }
  parents(t2 = this.root()) {
    const e2 = "string" == typeof t2;
    e2 || (t2 = B(t2));
    const i2 = new Ct();
    let a2 = this;
    for (; (a2 = a2.parent()) && a2.node !== O.document && "#document-fragment" !== a2.nodeName && (i2.push(a2), e2 || a2.node !== t2.node) && (!e2 || !a2.matches(t2)); ) if (a2.node === this.root().node) return null;
    return i2;
  }
  reference(t2) {
    if (!(t2 = this.attr(t2))) return null;
    const e2 = (t2 + "").match(at);
    return e2 ? B(e2[1]) : null;
  }
  root() {
    const t2 = this.parent((function(t3) {
      return _[t3];
    })(N));
    return t2 && t2.root();
  }
  setData(t2) {
    return this.dom = t2, this;
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.width(new _t(i2.width)).height(new _t(i2.height));
  }
  width(t2) {
    return this.attr("width", t2);
  }
  writeDataToDom() {
    return R(this, this.dom), super.writeDataToDom();
  }
  x(t2) {
    return this.attr("x", t2);
  }
  y(t2) {
    return this.attr("y", t2);
  }
};
Q(Gt, { bbox: function() {
  const t2 = At(this, ((t3) => t3.getBBox()), ((t3) => {
    try {
      const e2 = t3.clone().addTo(yt().svg).show(), i2 = e2.node.getBBox();
      return e2.remove(), i2;
    } catch (e2) {
      throw new Error(`Getting bbox of element "${t3.node.nodeName}" is not possible: ${e2.toString()}`);
    }
  }));
  return new kt(t2);
}, rbox: function(t2) {
  const e2 = At(this, ((t3) => t3.getBoundingClientRect()), ((t3) => {
    throw new Error(`Getting rbox of element "${t3.node.nodeName}" is not possible`);
  })), i2 = new kt(e2);
  return t2 ? i2.transform(t2.screenCTM().inverseO()) : i2.addOffset();
}, inside: function(t2, e2) {
  const i2 = this.bbox();
  return t2 > i2.x && e2 > i2.y && t2 < i2.x + i2.width && e2 < i2.y + i2.height;
}, point: function(t2, e2) {
  return new bt(t2, e2).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new vt(this.node.getCTM());
}, screenCTM: function() {
  try {
    if ("function" == typeof this.isRoot && !this.isRoot()) {
      const t2 = this.rect(1, 1), e2 = t2.node.getScreenCTM();
      return t2.remove(), new vt(e2);
    }
    return new vt(this.node.getScreenCTM());
  } catch (t2) {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new vt();
  }
} }), q(Gt, "Element");
const jt = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t2, e2) {
  return "color" === e2 ? t2 : t2 + "-" + e2;
} };
["fill", "stroke"].forEach((function(t2) {
  const e2 = {};
  let i2;
  e2[t2] = function(e3) {
    if (void 0 === e3) return this.attr(t2);
    if ("string" == typeof e3 || e3 instanceof xt || xt.isRgb(e3) || e3 instanceof Gt) this.attr(t2, e3);
    else for (i2 = jt[t2].length - 1; i2 >= 0; i2--) null != e3[jt[t2][i2]] && this.attr(jt.prefix(t2, jt[t2][i2]), e3[jt[t2][i2]]);
    return this;
  }, A$1(["Element", "Runner"], e2);
})), A$1(["Element", "Runner"], { matrix: function(t2, e2, i2, a2, s2, r2) {
  return null == t2 ? new vt(this) : this.attr("transform", new vt(t2, e2, i2, a2, s2, r2));
}, rotate: function(t2, e2, i2) {
  return this.transform({ rotate: t2, ox: e2, oy: i2 }, true);
}, skew: function(t2, e2, i2, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ skew: t2, ox: e2, oy: i2 }, true) : this.transform({ skew: [t2, e2], ox: i2, oy: a2 }, true);
}, shear: function(t2, e2, i2) {
  return this.transform({ shear: t2, ox: e2, oy: i2 }, true);
}, scale: function(t2, e2, i2, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ scale: t2, ox: e2, oy: i2 }, true) : this.transform({ scale: [t2, e2], ox: i2, oy: a2 }, true);
}, translate: function(t2, e2) {
  return this.transform({ translate: [t2, e2] }, true);
}, relative: function(t2, e2) {
  return this.transform({ relative: [t2, e2] }, true);
}, flip: function(t2 = "both", e2 = "center") {
  return -1 === "xybothtrue".indexOf(t2) && (e2 = t2, t2 = "both"), this.transform({ flip: t2, origin: e2 }, true);
}, opacity: function(t2) {
  return this.attr("opacity", t2);
} }), A$1("radius", { radius: function(t2, e2 = t2) {
  return "radialGradient" === (this._element || this).type ? this.attr("r", new _t(t2)) : this.rx(t2).ry(e2);
} }), A$1("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(t2) {
  return new bt(this.node.getPointAtLength(t2));
} }), A$1(["Element", "Runner"], { font: function(t2, e2) {
  if ("object" == typeof t2) {
    for (e2 in t2) this.font(e2, t2[e2]);
    return this;
  }
  return "leading" === t2 ? this.leading(e2) : "anchor" === t2 ? this.attr("text-anchor", e2) : "size" === t2 || "family" === t2 || "weight" === t2 || "stretch" === t2 || "variant" === t2 || "style" === t2 ? this.attr("font-" + t2, e2) : this.attr(t2, e2);
} });
A$1("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce((function(t2, e2) {
  return t2[e2] = function(t3) {
    return null === t3 ? this.off(e2) : this.on(e2, t3), this;
  }, t2;
}), {})), A$1("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  const t2 = (this.attr("transform") || "").split(st).slice(0, -1).map((function(t3) {
    const e2 = t3.trim().split("(");
    return [e2[0], e2[1].split(dt).map((function(t4) {
      return parseFloat(t4);
    }))];
  })).reverse().reduce((function(t3, e2) {
    return "matrix" === e2[0] ? t3.lmultiply(vt.fromArray(e2[1])) : t3[e2[0]].apply(t3, e2[1]);
  }), new vt());
  return t2;
}, toParent: function(t2, e2) {
  if (this === t2) return this;
  if (X(this.node)) return this.addTo(t2, e2);
  const i2 = this.screenCTM(), a2 = t2.screenCTM().inverse();
  return this.addTo(t2, e2).untransform().transform(a2.multiply(i2)), this;
}, toRoot: function(t2) {
  return this.toParent(this.root(), t2);
}, transform: function(t2, e2) {
  if (null == t2 || "string" == typeof t2) {
    const e3 = new vt(this).decompose();
    return null == t2 ? e3 : e3[t2];
  }
  vt.isMatrixLike(t2) || (t2 = { ...t2, origin: T(t2, this) });
  const i2 = new vt(true === e2 ? this : e2 || false).transform(t2);
  return this.attr("transform", i2);
} });
class Vt extends Gt {
  flatten() {
    return this.each((function() {
      if (this instanceof Vt) return this.flatten().ungroup();
    })), this;
  }
  ungroup(t2 = this.parent(), e2 = t2.index(this)) {
    return e2 = -1 === e2 ? t2.children().length : e2, this.each((function(i2, a2) {
      return a2[a2.length - i2 - 1].toParent(t2, e2);
    })), this.remove();
  }
}
q(Vt, "Container");
class Ut extends Vt {
  constructor(t2, e2 = t2) {
    super(G("defs", t2), e2);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
q(Ut, "Defs");
class qt extends Gt {
}
function Zt(t2) {
  return this.attr("rx", t2);
}
function $t(t2) {
  return this.attr("ry", t2);
}
function Jt(t2) {
  return null == t2 ? this.cx() - this.rx() : this.cx(t2 + this.rx());
}
function Qt(t2) {
  return null == t2 ? this.cy() - this.ry() : this.cy(t2 + this.ry());
}
function Kt(t2) {
  return this.attr("cx", t2);
}
function te(t2) {
  return this.attr("cy", t2);
}
function ee(t2) {
  return null == t2 ? 2 * this.rx() : this.rx(new _t(t2).divide(2));
}
function ie(t2) {
  return null == t2 ? 2 * this.ry() : this.ry(new _t(t2).divide(2));
}
q(qt, "Shape");
var ae = Object.freeze({ __proto__: null, cx: Kt, cy: te, height: ie, rx: Zt, ry: $t, width: ee, x: Jt, y: Qt });
class se extends qt {
  constructor(t2, e2 = t2) {
    super(G("ellipse", t2), e2);
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.rx(new _t(i2.width).divide(2)).ry(new _t(i2.height).divide(2));
  }
}
Q(se, ae), A$1("Container", { ellipse: K((function(t2 = 0, e2 = t2) {
  return this.put(new se()).size(t2, e2).move(0, 0);
})) }), q(se, "Ellipse");
class re extends Bt {
  constructor(t2 = O.document.createDocumentFragment()) {
    super(t2);
  }
  xml(t2, e2, i2) {
    if ("boolean" == typeof t2 && (i2 = e2, e2 = t2, t2 = null), null == t2 || "function" == typeof t2) {
      const t3 = new Bt(W("wrapper", i2));
      return t3.add(this.node.cloneNode(true)), t3.xml(false, i2);
    }
    return super.xml(t2, false, i2);
  }
}
function ne(t2, e2) {
  return "radialGradient" === (this._element || this).type ? this.attr({ fx: new _t(t2), fy: new _t(e2) }) : this.attr({ x1: new _t(t2), y1: new _t(e2) });
}
function oe(t2, e2) {
  return "radialGradient" === (this._element || this).type ? this.attr({ cx: new _t(t2), cy: new _t(e2) }) : this.attr({ x2: new _t(t2), y2: new _t(e2) });
}
q(re, "Fragment");
var le = Object.freeze({ __proto__: null, from: ne, to: oe });
class he extends Vt {
  constructor(t2, e2) {
    super(G(t2 + "Gradient", "string" == typeof t2 ? null : t2), e2);
  }
  attr(t2, e2, i2) {
    return "transform" === t2 && (t2 = "gradientTransform"), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
Q(he, le), A$1({ Container: { gradient(...t2) {
  return this.defs().gradient(...t2);
} }, Defs: { gradient: K((function(t2, e2) {
  return this.put(new he(t2)).update(e2);
})) } }), q(he, "Gradient");
class ce extends Vt {
  constructor(t2, e2 = t2) {
    super(G("pattern", t2), e2);
  }
  attr(t2, e2, i2) {
    return "transform" === t2 && (t2 = "patternTransform"), super.attr(t2, e2, i2);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
A$1({ Container: { pattern(...t2) {
  return this.defs().pattern(...t2);
} }, Defs: { pattern: K((function(t2, e2, i2) {
  return this.put(new ce()).update(i2).attr({ x: 0, y: 0, width: t2, height: e2, patternUnits: "userSpaceOnUse" });
})) } }), q(ce, "Pattern");
let de = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("image", t2), e2);
  }
  load(t2, e2) {
    if (!t2) return this;
    const i2 = new O.window.Image();
    return zt(i2, "load", (function(t3) {
      const a2 = this.parent(ce);
      0 === this.width() && 0 === this.height() && this.size(i2.width, i2.height), a2 instanceof ce && 0 === a2.width() && 0 === a2.height() && a2.size(this.width(), this.height()), "function" == typeof e2 && e2.call(this, t3);
    }), this), zt(i2, "load error", (function() {
      Xt(i2);
    })), this.attr("href", i2.src = t2, H);
  }
};
var ue;
ue = function(t2, e2, i2) {
  return "fill" !== t2 && "stroke" !== t2 || ct.test(e2) && (e2 = i2.root().defs().image(e2)), e2 instanceof de && (e2 = i2.root().defs().pattern(0, 0, ((t3) => {
    t3.add(e2);
  }))), e2;
}, Wt.push(ue), A$1({ Container: { image: K((function(t2, e2) {
  return this.put(new de()).size(0, 0).load(t2, e2);
})) } }), q(de, "Image");
class ge extends Dt {
  bbox() {
    let t2 = -1 / 0, e2 = -1 / 0, i2 = 1 / 0, a2 = 1 / 0;
    return this.forEach((function(s2) {
      t2 = Math.max(s2[0], t2), e2 = Math.max(s2[1], e2), i2 = Math.min(s2[0], i2), a2 = Math.min(s2[1], a2);
    })), new kt(i2, a2, t2 - i2, e2 - a2);
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2)) for (let i3 = this.length - 1; i3 >= 0; i3--) this[i3] = [this[i3][0] + t2, this[i3][1] + e2];
    return this;
  }
  parse(t2 = [0, 0]) {
    const e2 = [];
    (t2 = t2 instanceof Array ? Array.prototype.concat.apply([], t2) : t2.trim().split(dt).map(parseFloat)).length % 2 != 0 && t2.pop();
    for (let i2 = 0, a2 = t2.length; i2 < a2; i2 += 2) e2.push([t2[i2], t2[i2 + 1]]);
    return e2;
  }
  size(t2, e2) {
    let i2;
    const a2 = this.bbox();
    for (i2 = this.length - 1; i2 >= 0; i2--) a2.width && (this[i2][0] = (this[i2][0] - a2.x) * t2 / a2.width + a2.x), a2.height && (this[i2][1] = (this[i2][1] - a2.y) * e2 / a2.height + a2.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const t2 = [];
    for (let e2 = 0, i2 = this.length; e2 < i2; e2++) t2.push(this[e2].join(","));
    return t2.join(" ");
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    for (let e2 = this.length; e2--; ) {
      const [i2, a2] = this[e2];
      this[e2][0] = t2.a * i2 + t2.c * a2 + t2.e, this[e2][1] = t2.b * i2 + t2.d * a2 + t2.f;
    }
    return this;
  }
}
const pe = ge;
var fe = Object.freeze({ __proto__: null, MorphArray: pe, height: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.height : this.size(e2.width, t2);
}, width: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.width : this.size(t2, e2.height);
}, x: function(t2) {
  return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
}, y: function(t2) {
  return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
} });
let xe = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("line", t2), e2);
  }
  array() {
    return new ge([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(t2, e2) {
    return this.attr(this.array().move(t2, e2).toLine());
  }
  plot(t2, e2, i2, a2) {
    return null == t2 ? this.array() : (t2 = void 0 !== e2 ? { x1: t2, y1: e2, x2: i2, y2: a2 } : new ge(t2).toLine(), this.attr(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr(this.array().size(i2.width, i2.height).toLine());
  }
};
Q(xe, fe), A$1({ Container: { line: K((function(...t2) {
  return xe.prototype.plot.apply(this.put(new xe()), null != t2[0] ? t2 : [0, 0, 0, 0]);
})) } }), q(xe, "Line");
let be = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("marker", t2), e2);
  }
  height(t2) {
    return this.attr("markerHeight", t2);
  }
  orient(t2) {
    return this.attr("orient", t2);
  }
  ref(t2, e2) {
    return this.attr("refX", t2).attr("refY", e2);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  width(t2) {
    return this.attr("markerWidth", t2);
  }
};
function me(t2, e2) {
  return function(i2) {
    return null == i2 ? this[t2] : (this[t2] = i2, e2 && e2.call(this), this);
  };
}
A$1({ Container: { marker(...t2) {
  return this.defs().marker(...t2);
} }, Defs: { marker: K((function(t2, e2, i2) {
  return this.put(new be()).size(t2, e2).ref(t2 / 2, e2 / 2).viewbox(0, 0, t2, e2).attr("orient", "auto").update(i2);
})) }, marker: { marker(t2, e2, i2, a2) {
  let s2 = ["marker"];
  return "all" !== t2 && s2.push(t2), s2 = s2.join("-"), t2 = arguments[1] instanceof be ? arguments[1] : this.defs().marker(e2, i2, a2), this.attr(s2, t2);
} } }), q(be, "Marker");
const ve = { "-": function(t2) {
  return t2;
}, "<>": function(t2) {
  return -Math.cos(t2 * Math.PI) / 2 + 0.5;
}, ">": function(t2) {
  return Math.sin(t2 * Math.PI / 2);
}, "<": function(t2) {
  return 1 - Math.cos(t2 * Math.PI / 2);
}, bezier: function(t2, e2, i2, a2) {
  return function(s2) {
    return s2 < 0 ? t2 > 0 ? e2 / t2 * s2 : i2 > 0 ? a2 / i2 * s2 : 0 : s2 > 1 ? i2 < 1 ? (1 - a2) / (1 - i2) * s2 + (a2 - i2) / (1 - i2) : t2 < 1 ? (1 - e2) / (1 - t2) * s2 + (e2 - t2) / (1 - t2) : 1 : 3 * s2 * (1 - s2) ** 2 * e2 + 3 * s2 ** 2 * (1 - s2) * a2 + s2 ** 3;
  };
}, steps: function(t2, e2 = "end") {
  e2 = e2.split("-").reverse()[0];
  let i2 = t2;
  return "none" === e2 ? --i2 : "both" === e2 && ++i2, (a2, s2 = false) => {
    let r2 = Math.floor(a2 * t2);
    const n2 = a2 * r2 % 1 == 0;
    return "start" !== e2 && "both" !== e2 || ++r2, s2 && n2 && --r2, a2 >= 0 && r2 < 0 && (r2 = 0), a2 <= 1 && r2 > i2 && (r2 = i2), r2 / i2;
  };
} };
class ye {
  done() {
    return false;
  }
}
class we extends ye {
  constructor(t2 = Ht) {
    super(), this.ease = ve[t2] || t2;
  }
  step(t2, e2, i2) {
    return "number" != typeof t2 ? i2 < 1 ? t2 : e2 : t2 + (e2 - t2) * this.ease(i2);
  }
}
class ke extends ye {
  constructor(t2) {
    super(), this.stepper = t2;
  }
  done(t2) {
    return t2.done;
  }
  step(t2, e2, i2, a2) {
    return this.stepper(t2, e2, i2, a2);
  }
}
function Ae() {
  const t2 = (this._duration || 500) / 1e3, e2 = this._overshoot || 0, i2 = Math.PI, a2 = Math.log(e2 / 100 + 1e-10), s2 = -a2 / Math.sqrt(i2 * i2 + a2 * a2), r2 = 3.9 / (s2 * t2);
  this.d = 2 * s2 * r2, this.k = r2 * r2;
}
Q(class extends ke {
  constructor(t2 = 500, e2 = 0) {
    super(), this.duration(t2).overshoot(e2);
  }
  step(t2, e2, i2, a2) {
    if ("string" == typeof t2) return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0) return e2;
    if (0 === i2) return t2;
    i2 > 100 && (i2 = 16), i2 /= 1e3;
    const s2 = a2.velocity || 0, r2 = -this.d * s2 - this.k * (t2 - e2), n2 = t2 + s2 * i2 + r2 * i2 * i2 / 2;
    return a2.velocity = s2 + r2 * i2, a2.done = Math.abs(e2 - n2) + Math.abs(s2) < 2e-3, a2.done ? e2 : n2;
  }
}, { duration: me("_duration", Ae), overshoot: me("_overshoot", Ae) });
Q(class extends ke {
  constructor(t2 = 0.1, e2 = 0.01, i2 = 0, a2 = 1e3) {
    super(), this.p(t2).i(e2).d(i2).windup(a2);
  }
  step(t2, e2, i2, a2) {
    if ("string" == typeof t2) return t2;
    if (a2.done = i2 === 1 / 0, i2 === 1 / 0) return e2;
    if (0 === i2) return t2;
    const s2 = e2 - t2;
    let r2 = (a2.integral || 0) + s2 * i2;
    const n2 = (s2 - (a2.error || 0)) / i2, o2 = this._windup;
    return false !== o2 && (r2 = Math.max(-o2, Math.min(r2, o2))), a2.error = s2, a2.integral = r2, a2.done = Math.abs(s2) < 1e-3, a2.done ? e2 : t2 + (this.P * s2 + this.I * r2 + this.D * n2);
  }
}, { windup: me("_windup"), p: me("P"), i: me("I"), d: me("D") });
const Ce = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 }, Se = { M: function(t2, e2, i2) {
  return e2.x = i2.x = t2[0], e2.y = i2.y = t2[1], ["M", e2.x, e2.y];
}, L: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["L", t2[0], t2[1]];
}, H: function(t2, e2) {
  return e2.x = t2[0], ["H", t2[0]];
}, V: function(t2, e2) {
  return e2.y = t2[0], ["V", t2[0]];
}, C: function(t2, e2) {
  return e2.x = t2[4], e2.y = t2[5], ["C", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]];
}, S: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["S", t2[0], t2[1], t2[2], t2[3]];
}, Q: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["Q", t2[0], t2[1], t2[2], t2[3]];
}, T: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["T", t2[0], t2[1]];
}, Z: function(t2, e2, i2) {
  return e2.x = i2.x, e2.y = i2.y, ["Z"];
}, A: function(t2, e2) {
  return e2.x = t2[5], e2.y = t2[6], ["A", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]];
} }, Le = "mlhvqtcsaz".split("");
for (let t2 = 0, e2 = Le.length; t2 < e2; ++t2) Se[Le[t2]] = /* @__PURE__ */ (function(t3) {
  return function(e3, i2, a2) {
    if ("H" === t3) e3[0] = e3[0] + i2.x;
    else if ("V" === t3) e3[0] = e3[0] + i2.y;
    else if ("A" === t3) e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
    else for (let t4 = 0, a3 = e3.length; t4 < a3; ++t4) e3[t4] = e3[t4] + (t4 % 2 ? i2.y : i2.x);
    return Se[t3](e3, i2, a2);
  };
})(Le[t2].toUpperCase());
function Me(t2) {
  return t2.segment.length && t2.segment.length - 1 === Ce[t2.segment[0].toUpperCase()];
}
function Pe(t2, e2) {
  t2.inNumber && Ie(t2, false);
  const i2 = ut.test(e2);
  if (i2) t2.segment = [e2];
  else {
    const e3 = t2.lastCommand, i3 = e3.toLowerCase(), a2 = e3 === i3;
    t2.segment = ["m" === i3 ? a2 ? "l" : "L" : e3];
  }
  return t2.inSegment = true, t2.lastCommand = t2.segment[0], i2;
}
function Ie(t2, e2) {
  if (!t2.inNumber) throw new Error("Parser Error");
  t2.number && t2.segment.push(parseFloat(t2.number)), t2.inNumber = e2, t2.number = "", t2.pointSeen = false, t2.hasExponent = false, Me(t2) && Te(t2);
}
function Te(t2) {
  t2.inSegment = false, t2.absolute && (t2.segment = (function(t3) {
    const e2 = t3.segment[0];
    return Se[e2](t3.segment.slice(1), t3.p, t3.p0);
  })(t2)), t2.segments.push(t2.segment);
}
function ze(t2) {
  if (!t2.segment.length) return false;
  const e2 = "A" === t2.segment[0].toUpperCase(), i2 = t2.segment.length;
  return e2 && (4 === i2 || 5 === i2);
}
function Xe(t2) {
  return "E" === t2.lastToken.toUpperCase();
}
const Re = /* @__PURE__ */ new Set([" ", ",", "	", "\n", "\r", "\f"]);
class Ee extends Dt {
  bbox() {
    return yt().path.setAttribute("d", this.toString()), new kt(yt.nodes.path.getBBox());
  }
  move(t2, e2) {
    const i2 = this.bbox();
    if (t2 -= i2.x, e2 -= i2.y, !isNaN(t2) && !isNaN(e2)) for (let i3, a2 = this.length - 1; a2 >= 0; a2--) i3 = this[a2][0], "M" === i3 || "L" === i3 || "T" === i3 ? (this[a2][1] += t2, this[a2][2] += e2) : "H" === i3 ? this[a2][1] += t2 : "V" === i3 ? this[a2][1] += e2 : "C" === i3 || "S" === i3 || "Q" === i3 ? (this[a2][1] += t2, this[a2][2] += e2, this[a2][3] += t2, this[a2][4] += e2, "C" === i3 && (this[a2][5] += t2, this[a2][6] += e2)) : "A" === i3 && (this[a2][6] += t2, this[a2][7] += e2);
    return this;
  }
  parse(t2 = "M0 0") {
    return Array.isArray(t2) && (t2 = Array.prototype.concat.apply([], t2).toString()), (function(t3, e2 = true) {
      let i2 = 0, a2 = "";
      const s2 = { segment: [], inNumber: false, number: "", lastToken: "", inSegment: false, segments: [], pointSeen: false, hasExponent: false, absolute: e2, p0: new bt(), p: new bt() };
      for (; s2.lastToken = a2, a2 = t3.charAt(i2++); ) if (s2.inSegment || !Pe(s2, a2)) if ("." !== a2) if (isNaN(parseInt(a2))) if (Re.has(a2)) s2.inNumber && Ie(s2, false);
      else if ("-" !== a2 && "+" !== a2) if ("E" !== a2.toUpperCase()) {
        if (ut.test(a2)) {
          if (s2.inNumber) Ie(s2, false);
          else {
            if (!Me(s2)) throw new Error("parser Error");
            Te(s2);
          }
          --i2;
        }
      } else s2.number += a2, s2.hasExponent = true;
      else {
        if (s2.inNumber && !Xe(s2)) {
          Ie(s2, false), --i2;
          continue;
        }
        s2.number += a2, s2.inNumber = true;
      }
      else {
        if ("0" === s2.number || ze(s2)) {
          s2.inNumber = true, s2.number = a2, Ie(s2, true);
          continue;
        }
        s2.inNumber = true, s2.number += a2;
      }
      else {
        if (s2.pointSeen || s2.hasExponent) {
          Ie(s2, false), --i2;
          continue;
        }
        s2.inNumber = true, s2.pointSeen = true, s2.number += a2;
      }
      return s2.inNumber && Ie(s2, false), s2.inSegment && Me(s2) && Te(s2), s2.segments;
    })(t2);
  }
  size(t2, e2) {
    const i2 = this.bbox();
    let a2, s2;
    for (i2.width = 0 === i2.width ? 1 : i2.width, i2.height = 0 === i2.height ? 1 : i2.height, a2 = this.length - 1; a2 >= 0; a2--) s2 = this[a2][0], "M" === s2 || "L" === s2 || "T" === s2 ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y) : "H" === s2 ? this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x : "V" === s2 ? this[a2][1] = (this[a2][1] - i2.y) * e2 / i2.height + i2.y : "C" === s2 || "S" === s2 || "Q" === s2 ? (this[a2][1] = (this[a2][1] - i2.x) * t2 / i2.width + i2.x, this[a2][2] = (this[a2][2] - i2.y) * e2 / i2.height + i2.y, this[a2][3] = (this[a2][3] - i2.x) * t2 / i2.width + i2.x, this[a2][4] = (this[a2][4] - i2.y) * e2 / i2.height + i2.y, "C" === s2 && (this[a2][5] = (this[a2][5] - i2.x) * t2 / i2.width + i2.x, this[a2][6] = (this[a2][6] - i2.y) * e2 / i2.height + i2.y)) : "A" === s2 && (this[a2][1] = this[a2][1] * t2 / i2.width, this[a2][2] = this[a2][2] * e2 / i2.height, this[a2][6] = (this[a2][6] - i2.x) * t2 / i2.width + i2.x, this[a2][7] = (this[a2][7] - i2.y) * e2 / i2.height + i2.y);
    return this;
  }
  toString() {
    return (function(t2) {
      let e2 = "";
      for (let i2 = 0, a2 = t2.length; i2 < a2; i2++) e2 += t2[i2][0], null != t2[i2][1] && (e2 += t2[i2][1], null != t2[i2][2] && (e2 += " ", e2 += t2[i2][2], null != t2[i2][3] && (e2 += " ", e2 += t2[i2][3], e2 += " ", e2 += t2[i2][4], null != t2[i2][5] && (e2 += " ", e2 += t2[i2][5], e2 += " ", e2 += t2[i2][6], null != t2[i2][7] && (e2 += " ", e2 += t2[i2][7])))));
      return e2 + " ";
    })(this);
  }
}
const Ye = (t2) => {
  const e2 = typeof t2;
  return "number" === e2 ? _t : "string" === e2 ? xt.isColor(t2) ? xt : dt.test(t2) ? ut.test(t2) ? Ee : Dt : tt.test(t2) ? _t : Oe : Ne.indexOf(t2.constructor) > -1 ? t2.constructor : Array.isArray(t2) ? Dt : "object" === e2 ? _e : Oe;
};
class He {
  constructor(t2) {
    this._stepper = t2 || new we("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(t2) {
    return this._morphObj.morph(this._from, this._to, t2, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce((function(t2, e2) {
      return t2 && e2;
    }), true);
  }
  from(t2) {
    return null == t2 ? this._from : (this._from = this._set(t2), this);
  }
  stepper(t2) {
    return null == t2 ? this._stepper : (this._stepper = t2, this);
  }
  to(t2) {
    return null == t2 ? this._to : (this._to = this._set(t2), this);
  }
  type(t2) {
    return null == t2 ? this._type : (this._type = t2, this);
  }
  _set(t2) {
    this._type || this.type(Ye(t2));
    let e2 = new this._type(t2);
    return this._type === xt && (e2 = this._to ? e2[this._to[4]]() : this._from ? e2[this._from[4]]() : e2), this._type === _e && (e2 = this._to ? e2.align(this._to) : this._from ? e2.align(this._from) : e2), e2 = e2.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(e2.length)).map(Object).map((function(t3) {
      return t3.done = true, t3;
    })), e2;
  }
}
class Oe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return t2 = Array.isArray(t2) ? t2[0] : t2, this.value = t2, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}
class Fe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return Array.isArray(t2) && (t2 = { scaleX: t2[0], scaleY: t2[1], shear: t2[2], rotate: t2[3], translateX: t2[4], translateY: t2[5], originX: t2[6], originY: t2[7] }), Object.assign(this, Fe.defaults, t2), this;
  }
  toArray() {
    const t2 = this;
    return [t2.scaleX, t2.scaleY, t2.shear, t2.rotate, t2.translateX, t2.translateY, t2.originX, t2.originY];
  }
}
Fe.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
const De = (t2, e2) => t2[0] < e2[0] ? -1 : t2[0] > e2[0] ? 1 : 0;
class _e {
  constructor(...t2) {
    this.init(...t2);
  }
  align(t2) {
    const e2 = this.values;
    for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
      if (e2[i2 + 1] === t2[i2 + 1]) {
        if (e2[i2 + 1] === xt && t2[i2 + 7] !== e2[i2 + 7]) {
          const e3 = t2[i2 + 7], a4 = new xt(this.values.splice(i2 + 3, 5))[e3]().toArray();
          this.values.splice(i2 + 3, 0, ...a4);
        }
        i2 += e2[i2 + 2] + 2;
        continue;
      }
      if (!t2[i2 + 1]) return this;
      const a3 = new t2[i2 + 1]().toArray(), s2 = e2[i2 + 2] + 3;
      e2.splice(i2, s2, t2[i2], t2[i2 + 1], t2[i2 + 2], ...a3), i2 += e2[i2 + 2] + 2;
    }
    return this;
  }
  init(t2) {
    if (this.values = [], Array.isArray(t2)) return void (this.values = t2.slice());
    t2 = t2 || {};
    const e2 = [];
    for (const i2 in t2) {
      const a2 = Ye(t2[i2]), s2 = new a2(t2[i2]).toArray();
      e2.push([i2, a2, s2.length, ...s2]);
    }
    return e2.sort(De), this.values = e2.reduce(((t3, e3) => t3.concat(e3)), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const t2 = {}, e2 = this.values;
    for (; e2.length; ) {
      const i2 = e2.shift(), a2 = e2.shift(), s2 = e2.shift(), r2 = e2.splice(0, s2);
      t2[i2] = new a2(r2);
    }
    return t2;
  }
}
const Ne = [Oe, Fe, _e];
class We extends qt {
  constructor(t2, e2 = t2) {
    super(G("path", t2), e2);
  }
  array() {
    return this._array || (this._array = new Ee(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(t2) {
    return null == t2 ? this.bbox().height : this.size(this.bbox().width, t2);
  }
  move(t2, e2) {
    return this.attr("d", this.array().move(t2, e2));
  }
  plot(t2) {
    return null == t2 ? this.array() : this.clear().attr("d", "string" == typeof t2 ? t2 : this._array = new Ee(t2));
  }
  size(t2, e2) {
    const i2 = I(this, t2, e2);
    return this.attr("d", this.array().size(i2.width, i2.height));
  }
  width(t2) {
    return null == t2 ? this.bbox().width : this.size(t2, this.bbox().height);
  }
  x(t2) {
    return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
  }
  y(t2) {
    return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
  }
}
We.prototype.MorphArray = Ee, A$1({ Container: { path: K((function(t2) {
  return this.put(new We()).plot(t2 || new Ee());
})) } }), q(We, "Path");
var Be = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new ge(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(t2, e2) {
  return this.attr("points", this.array().move(t2, e2));
}, plot: function(t2) {
  return null == t2 ? this.array() : this.clear().attr("points", "string" == typeof t2 ? t2 : this._array = new ge(t2));
}, size: function(t2, e2) {
  const i2 = I(this, t2, e2);
  return this.attr("points", this.array().size(i2.width, i2.height));
} });
class Ge extends qt {
  constructor(t2, e2 = t2) {
    super(G("polygon", t2), e2);
  }
}
A$1({ Container: { polygon: K((function(t2) {
  return this.put(new Ge()).plot(t2 || new ge());
})) } }), Q(Ge, fe), Q(Ge, Be), q(Ge, "Polygon");
class je extends qt {
  constructor(t2, e2 = t2) {
    super(G("polyline", t2), e2);
  }
}
A$1({ Container: { polyline: K((function(t2) {
  return this.put(new je()).plot(t2 || new ge());
})) } }), Q(je, fe), Q(je, Be), q(je, "Polyline");
class Ve extends qt {
  constructor(t2, e2 = t2) {
    super(G("rect", t2), e2);
  }
}
Q(Ve, { rx: Zt, ry: $t }), A$1({ Container: { rect: K((function(t2, e2) {
  return this.put(new Ve()).size(t2, e2);
})) } }), q(Ve, "Rect");
class Ue {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(t2) {
    const e2 = void 0 !== t2.next ? t2 : { value: t2, next: null, prev: null };
    return this._last ? (e2.prev = this._last, this._last.next = e2, this._last = e2) : (this._last = e2, this._first = e2), e2;
  }
  remove(t2) {
    t2.prev && (t2.prev.next = t2.next), t2.next && (t2.next.prev = t2.prev), t2 === this._last && (this._last = t2.prev), t2 === this._first && (this._first = t2.next), t2.prev = null, t2.next = null;
  }
  shift() {
    const t2 = this._first;
    return t2 ? (this._first = t2.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, t2.value) : null;
  }
}
const qe = { nextDraw: null, frames: new Ue(), timeouts: new Ue(), immediates: new Ue(), timer: () => O.window.performance || O.window.Date, transforms: [], frame(t2) {
  const e2 = qe.frames.push({ run: t2 });
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, timeout(t2, e2) {
  e2 = e2 || 0;
  const i2 = qe.timer().now() + e2, a2 = qe.timeouts.push({ run: t2, time: i2 });
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), a2;
}, immediate(t2) {
  const e2 = qe.immediates.push(t2);
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, cancelFrame(t2) {
  null != t2 && qe.frames.remove(t2);
}, clearTimeout(t2) {
  null != t2 && qe.timeouts.remove(t2);
}, cancelImmediate(t2) {
  null != t2 && qe.immediates.remove(t2);
}, _draw(t2) {
  let e2 = null;
  const i2 = qe.timeouts.last();
  for (; (e2 = qe.timeouts.shift()) && (t2 >= e2.time ? e2.run() : qe.timeouts.push(e2), e2 !== i2); ) ;
  let a2 = null;
  const s2 = qe.frames.last();
  for (; a2 !== s2 && (a2 = qe.frames.shift()); ) a2.run(t2);
  let r2 = null;
  for (; r2 = qe.immediates.shift(); ) r2();
  qe.nextDraw = qe.timeouts.first() || qe.frames.first() ? O.window.requestAnimationFrame(qe._draw) : null;
} }, Ze = function(t2) {
  const e2 = t2.start, i2 = t2.runner.duration();
  return { start: e2, duration: i2, end: e2 + i2, runner: t2.runner };
}, $e = function() {
  const t2 = O.window;
  return (t2.performance || t2.Date).now();
};
class Je extends Rt {
  constructor(t2 = $e) {
    super(), this._timeSource = t2, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const t2 = this.getLastRunnerInfo(), e2 = t2 ? t2.runner.duration() : 0;
    return (t2 ? t2.start : this._time) + e2;
  }
  getEndTimeOfTimeline() {
    const t2 = this._runners.map(((t3) => t3.start + t3.runner.duration()));
    return Math.max(0, ...t2);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(t2) {
    return this._runners[this._runnerIds.indexOf(t2)] || null;
  }
  pause() {
    return this._paused = true, this._continue();
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  play() {
    return this._paused = false, this.updateTime()._continue();
  }
  reverse(t2) {
    const e2 = this.speed();
    if (null == t2) return this.speed(-e2);
    const i2 = Math.abs(e2);
    return this.speed(t2 ? -i2 : i2);
  }
  schedule(t2, e2, i2) {
    if (null == t2) return this._runners.map(Ze);
    let a2 = 0;
    const s2 = this.getEndTime();
    if (e2 = e2 || 0, null == i2 || "last" === i2 || "after" === i2) a2 = s2;
    else if ("absolute" === i2 || "start" === i2) a2 = e2, e2 = 0;
    else if ("now" === i2) a2 = this._time;
    else if ("relative" === i2) {
      const i3 = this.getRunnerInfoById(t2.id);
      i3 && (a2 = i3.start + e2, e2 = 0);
    } else {
      if ("with-last" !== i2) throw new Error('Invalid value for the "when" parameter');
      {
        const t3 = this.getLastRunnerInfo();
        a2 = t3 ? t3.start : this._time;
      }
    }
    t2.unschedule(), t2.timeline(this);
    const r2 = t2.persist(), n2 = { persist: null === r2 ? this._persist : r2, start: a2 + e2, runner: t2 };
    return this._lastRunnerId = t2.id, this._runners.push(n2), this._runners.sort(((t3, e3) => t3.start - e3.start)), this._runnerIds = this._runners.map(((t3) => t3.runner.id)), this.updateTime()._continue(), this;
  }
  seek(t2) {
    return this.time(this._time + t2);
  }
  source(t2) {
    return null == t2 ? this._timeSource : (this._timeSource = t2, this);
  }
  speed(t2) {
    return null == t2 ? this._speed : (this._speed = t2, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(t2) {
    return null == t2 ? this._time : (this._time = t2, this._continue(true));
  }
  unschedule(t2) {
    const e2 = this._runnerIds.indexOf(t2.id);
    return e2 < 0 || (this._runners.splice(e2, 1), this._runnerIds.splice(e2, 1), t2.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(t2 = false) {
    return qe.cancelFrame(this._nextFrame), this._nextFrame = null, t2 ? this._stepImmediate() : (this._paused || (this._nextFrame = qe.frame(this._step)), this);
  }
  _stepFn(t2 = false) {
    const e2 = this._timeSource();
    let i2 = e2 - this._lastSourceTime;
    t2 && (i2 = 0);
    const a2 = this._speed * i2 + (this._time - this._lastStepTime);
    this._lastSourceTime = e2, t2 || (this._time += a2, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let t3 = this._runners.length; t3--; ) {
      const e3 = this._runners[t3], i3 = e3.runner;
      this._time - e3.start <= 0 && i3.reset();
    }
    let s2 = false;
    for (let t3 = 0, e3 = this._runners.length; t3 < e3; t3++) {
      const i3 = this._runners[t3], r2 = i3.runner;
      let n2 = a2;
      const o2 = this._time - i3.start;
      if (o2 <= 0) {
        s2 = true;
        continue;
      }
      if (o2 < n2 && (n2 = o2), !r2.active()) continue;
      if (r2.step(n2).done) {
        if (true !== i3.persist) {
          r2.duration() - r2.time() + this._time + i3.persist < this._time && (r2.unschedule(), --t3, --e3);
        }
      } else s2 = true;
    }
    return s2 && !(this._speed < 0 && 0 === this._time) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = true, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, false), this._stepImmediate = this._stepFn.bind(this, true);
  }
}
A$1({ Element: { timeline: function(t2) {
  return null == t2 ? (this._timeline = this._timeline || new Je(), this._timeline) : (this._timeline = t2, this);
} } });
class Qe extends Rt {
  constructor(t2) {
    super(), this.id = Qe.id++, t2 = "function" == typeof (t2 = null == t2 ? Yt : t2) ? new ke(t2) : t2, this._element = null, this._timeline = null, this.done = false, this._queue = [], this._duration = "number" == typeof t2 && t2, this._isDeclarative = t2 instanceof ke, this._stepper = this._isDeclarative ? t2 : new we(), this._history = {}, this.enabled = true, this._time = 0, this._lastTime = 0, this._reseted = true, this.transforms = new vt(), this.transformId = 1, this._haveReversed = false, this._reverse = false, this._loopsDone = 0, this._swing = false, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(t2, e2, i2) {
    let a2 = 1, s2 = false, r2 = 0;
    return e2 = e2 ?? Ot, i2 = i2 || "last", "object" != typeof (t2 = t2 ?? Yt) || t2 instanceof ye || (e2 = t2.delay ?? e2, i2 = t2.when ?? i2, s2 = t2.swing || s2, a2 = t2.times ?? a2, r2 = t2.wait ?? r2, t2 = t2.duration ?? Yt), { duration: t2, delay: e2, swing: s2, times: a2, wait: r2, when: i2 };
  }
  active(t2) {
    return null == t2 ? this.enabled : (this.enabled = t2, this);
  }
  addTransform(t2) {
    return this.transforms.lmultiplyO(t2), this;
  }
  after(t2) {
    return this.on("finished", t2);
  }
  animate(t2, e2, i2) {
    const a2 = Qe.sanitise(t2, e2, i2), s2 = new Qe(a2.duration);
    return this._timeline && s2.timeline(this._timeline), this._element && s2.element(this._element), s2.loop(a2).schedule(a2.delay, a2.when);
  }
  clearTransform() {
    return this.transforms = new vt(), this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter(((t2) => !t2.isTransform)));
  }
  delay(t2) {
    return this.animate(0, t2);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(t2) {
    return this.queue(null, t2);
  }
  ease(t2) {
    return this._stepper = new we(t2), this;
  }
  element(t2) {
    return null == t2 ? this._element : (this._element = t2, t2._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(t2, e2, i2) {
    return "object" == typeof t2 && (e2 = t2.swing, i2 = t2.wait, t2 = t2.times), this._times = t2 || 1 / 0, this._swing = e2 || false, this._wait = i2 || 0, true === this._times && (this._times = 1 / 0), this;
  }
  loops(t2) {
    const e2 = this._duration + this._wait;
    if (null == t2) {
      const t3 = Math.floor(this._time / e2), i3 = (this._time - t3 * e2) / this._duration;
      return Math.min(t3 + i3, this._times);
    }
    const i2 = t2 % 1, a2 = e2 * Math.floor(t2) + this._duration * i2;
    return this.time(a2);
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  position(t2) {
    const e2 = this._time, i2 = this._duration, a2 = this._wait, s2 = this._times, r2 = this._swing, n2 = this._reverse;
    let o2;
    if (null == t2) {
      const t3 = function(t4) {
        const e3 = r2 * Math.floor(t4 % (2 * (a2 + i2)) / (a2 + i2)), s3 = e3 && !n2 || !e3 && n2, o3 = Math.pow(-1, s3) * (t4 % (a2 + i2)) / i2 + s3;
        return Math.max(Math.min(o3, 1), 0);
      }, l3 = s2 * (a2 + i2) - a2;
      return o2 = e2 <= 0 ? Math.round(t3(1e-5)) : e2 < l3 ? t3(e2) : Math.round(t3(l3 - 1e-5)), o2;
    }
    const l2 = Math.floor(this.loops()), h2 = r2 && l2 % 2 == 0;
    return o2 = l2 + (h2 && !n2 || n2 && h2 ? t2 : 1 - t2), this.loops(o2);
  }
  progress(t2) {
    return null == t2 ? Math.min(1, this._time / this.duration()) : this.time(t2 * this.duration());
  }
  queue(t2, e2, i2, a2) {
    this._queue.push({ initialiser: t2 || Et, runner: e2 || Et, retarget: i2, isTransform: a2, initialised: false, finished: false });
    return this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = true), this;
  }
  reverse(t2) {
    return this._reverse = null == t2 ? !this._reverse : t2, this;
  }
  schedule(t2, e2, i2) {
    if (t2 instanceof Je || (i2 = e2, e2 = t2, t2 = this.timeline()), !t2) throw Error("Runner cannot be scheduled without timeline");
    return t2.schedule(this, e2, i2), this;
  }
  step(t2) {
    if (!this.enabled) return this;
    t2 = null == t2 ? 16 : t2, this._time += t2;
    const e2 = this.position(), i2 = this._lastPosition !== e2 && this._time >= 0;
    this._lastPosition = e2;
    const a2 = this.duration(), s2 = this._lastTime <= 0 && this._time > 0, r2 = this._lastTime < a2 && this._time >= a2;
    this._lastTime = this._time, s2 && this.fire("start", this);
    const n2 = this._isDeclarative;
    this.done = !n2 && !r2 && this._time >= a2, this._reseted = false;
    let o2 = false;
    return (i2 || n2) && (this._initialise(i2), this.transforms = new vt(), o2 = this._run(n2 ? t2 : e2), this.fire("step", this)), this.done = this.done || o2 && n2, r2 && this.fire("finished", this), this;
  }
  time(t2) {
    if (null == t2) return this._time;
    const e2 = t2 - this._time;
    return this.step(e2), this;
  }
  timeline(t2) {
    return void 0 === t2 ? this._timeline : (this._timeline = t2, this);
  }
  unschedule() {
    const t2 = this.timeline();
    return t2 && t2.unschedule(this), this;
  }
  _initialise(t2) {
    if (t2 || this._isDeclarative) for (let e2 = 0, i2 = this._queue.length; e2 < i2; ++e2) {
      const i3 = this._queue[e2], a2 = this._isDeclarative || !i3.initialised && t2;
      t2 = !i3.finished, a2 && t2 && (i3.initialiser.call(this), i3.initialised = true);
    }
  }
  _rememberMorpher(t2, e2) {
    if (this._history[t2] = { morpher: e2, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const t3 = this.timeline();
      t3 && t3.play();
    }
  }
  _run(t2) {
    let e2 = true;
    for (let i2 = 0, a2 = this._queue.length; i2 < a2; ++i2) {
      const a3 = this._queue[i2], s2 = a3.runner.call(this, t2);
      a3.finished = a3.finished || true === s2, e2 = e2 && a3.finished;
    }
    return e2;
  }
  _tryRetarget(t2, e2, i2) {
    if (this._history[t2]) {
      if (!this._history[t2].caller.initialised) {
        const e3 = this._queue.indexOf(this._history[t2].caller);
        return this._queue.splice(e3, 1), false;
      }
      this._history[t2].caller.retarget ? this._history[t2].caller.retarget.call(this, e2, i2) : this._history[t2].morpher.to(e2), this._history[t2].caller.finished = false;
      const a2 = this.timeline();
      return a2 && a2.play(), true;
    }
    return false;
  }
}
Qe.id = 0;
class Ke {
  constructor(t2 = new vt(), e2 = -1, i2 = true) {
    this.transforms = t2, this.id = e2, this.done = i2;
  }
  clearTransformsFromQueue() {
  }
}
Q([Qe, Ke], { mergeWith(t2) {
  return new Ke(t2.transforms.lmultiply(this.transforms), t2.id);
} });
const ti = (t2, e2) => t2.lmultiplyO(e2), ei = (t2) => t2.transforms;
function ii() {
  const t2 = this._transformationRunners.runners.map(ei).reduce(ti, new vt());
  this.transform(t2), this._transformationRunners.merge(), 1 === this._transformationRunners.length() && (this._frameId = null);
}
class ai {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(t2) {
    if (this.runners.includes(t2)) return;
    const e2 = t2.id + 1;
    return this.runners.push(t2), this.ids.push(e2), this;
  }
  clearBefore(t2) {
    const e2 = this.ids.indexOf(t2 + 1) || 1;
    return this.ids.splice(0, e2, 0), this.runners.splice(0, e2, new Ke()).forEach(((t3) => t3.clearTransformsFromQueue())), this;
  }
  edit(t2, e2) {
    const i2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(i2, 1, t2 + 1), this.runners.splice(i2, 1, e2), this;
  }
  getByID(t2) {
    return this.runners[this.ids.indexOf(t2 + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let t2 = null;
    for (let e2 = 0; e2 < this.runners.length; ++e2) {
      const i2 = this.runners[e2];
      if (t2 && i2.done && t2.done && (!i2._timeline || !i2._timeline._runnerIds.includes(i2.id)) && (!t2._timeline || !t2._timeline._runnerIds.includes(t2.id))) {
        this.remove(i2.id);
        const a2 = i2.mergeWith(t2);
        this.edit(t2.id, a2), t2 = a2, --e2;
      } else t2 = i2;
    }
    return this;
  }
  remove(t2) {
    const e2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(e2, 1), this.runners.splice(e2, 1), this;
  }
}
A$1({ Element: { animate(t2, e2, i2) {
  const a2 = Qe.sanitise(t2, e2, i2), s2 = this.timeline();
  return new Qe(a2.duration).loop(a2).element(this).timeline(s2.play()).schedule(a2.delay, a2.when);
}, delay(t2, e2) {
  return this.animate(0, t2, e2);
}, _clearTransformRunnersBefore(t2) {
  this._transformationRunners.clearBefore(t2.id);
}, _currentTransform(t2) {
  return this._transformationRunners.runners.filter(((e2) => e2.id <= t2.id)).map(ei).reduce(ti, new vt());
}, _addRunner(t2) {
  this._transformationRunners.add(t2), qe.cancelImmediate(this._frameId), this._frameId = qe.immediate(ii.bind(this));
}, _prepareRunner() {
  null == this._frameId && (this._transformationRunners = new ai().add(new Ke(new vt(this))));
} } });
Q(Qe, { attr(t2, e2) {
  return this.styleAttr("attr", t2, e2);
}, css(t2, e2) {
  return this.styleAttr("css", t2, e2);
}, styleAttr(t2, e2, i2) {
  if ("string" == typeof e2) return this.styleAttr(t2, { [e2]: i2 });
  let a2 = e2;
  if (this._tryRetarget(t2, a2)) return this;
  let s2 = new He(this._stepper).to(a2), r2 = Object.keys(a2);
  return this.queue((function() {
    s2 = s2.from(this.element()[t2](r2));
  }), (function(e3) {
    return this.element()[t2](s2.at(e3).valueOf()), s2.done();
  }), (function(e3) {
    const i3 = Object.keys(e3), n2 = (o2 = r2, i3.filter(((t3) => !o2.includes(t3))));
    var o2;
    if (n2.length) {
      const e4 = this.element()[t2](n2), i4 = new _e(s2.from()).valueOf();
      Object.assign(i4, e4), s2.from(i4);
    }
    const l2 = new _e(s2.to()).valueOf();
    Object.assign(l2, e3), s2.to(l2), r2 = i3, a2 = e3;
  })), this._rememberMorpher(t2, s2), this;
}, zoom(t2, e2) {
  if (this._tryRetarget("zoom", t2, e2)) return this;
  let i2 = new He(this._stepper).to(new _t(t2));
  return this.queue((function() {
    i2 = i2.from(this.element().zoom());
  }), (function(t3) {
    return this.element().zoom(i2.at(t3), e2), i2.done();
  }), (function(t3, a2) {
    e2 = a2, i2.to(t3);
  })), this._rememberMorpher("zoom", i2), this;
}, transform(t2, e2, i2) {
  if (e2 = t2.relative || e2, this._isDeclarative && !e2 && this._tryRetarget("transform", t2)) return this;
  const a2 = vt.isMatrixLike(t2);
  i2 = null != t2.affine ? t2.affine : null != i2 ? i2 : !a2;
  const s2 = new He(this._stepper).type(i2 ? Fe : vt);
  let r2, n2, o2, l2, h2;
  return this.queue((function() {
    n2 = n2 || this.element(), r2 = r2 || T(t2, n2), h2 = new vt(e2 ? void 0 : n2), n2._addRunner(this), e2 || n2._clearTransformRunnersBefore(this);
  }), (function(c2) {
    e2 || this.clearTransform();
    const { x: d2, y: u2 } = new bt(r2).transform(n2._currentTransform(this));
    let g2 = new vt({ ...t2, origin: [d2, u2] }), p2 = this._isDeclarative && o2 ? o2 : h2;
    if (i2) {
      g2 = g2.decompose(d2, u2), p2 = p2.decompose(d2, u2);
      const t3 = g2.rotate, e3 = p2.rotate, i3 = [t3 - 360, t3, t3 + 360], a3 = i3.map(((t4) => Math.abs(t4 - e3))), s3 = Math.min(...a3), r3 = a3.indexOf(s3);
      g2.rotate = i3[r3];
    }
    e2 && (a2 || (g2.rotate = t2.rotate || 0), this._isDeclarative && l2 && (p2.rotate = l2)), s2.from(p2), s2.to(g2);
    const f2 = s2.at(c2);
    return l2 = f2.rotate, o2 = new vt(f2), this.addTransform(o2), n2._addRunner(this), s2.done();
  }), (function(e3) {
    (e3.origin || "center").toString() !== (t2.origin || "center").toString() && (r2 = T(e3, n2)), t2 = { ...e3, origin: r2 };
  }), true), this._isDeclarative && this._rememberMorpher("transform", s2), this;
}, x(t2) {
  return this._queueNumber("x", t2);
}, y(t2) {
  return this._queueNumber("y", t2);
}, ax(t2) {
  return this._queueNumber("ax", t2);
}, ay(t2) {
  return this._queueNumber("ay", t2);
}, dx(t2 = 0) {
  return this._queueNumberDelta("x", t2);
}, dy(t2 = 0) {
  return this._queueNumberDelta("y", t2);
}, dmove(t2, e2) {
  return this.dx(t2).dy(e2);
}, _queueNumberDelta(t2, e2) {
  if (e2 = new _t(e2), this._tryRetarget(t2, e2)) return this;
  const i2 = new He(this._stepper).to(e2);
  let a2 = null;
  return this.queue((function() {
    a2 = this.element()[t2](), i2.from(a2), i2.to(a2 + e2);
  }), (function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  }), (function(t3) {
    i2.to(a2 + new _t(t3));
  })), this._rememberMorpher(t2, i2), this;
}, _queueObject(t2, e2) {
  if (this._tryRetarget(t2, e2)) return this;
  const i2 = new He(this._stepper).to(e2);
  return this.queue((function() {
    i2.from(this.element()[t2]());
  }), (function(e3) {
    return this.element()[t2](i2.at(e3)), i2.done();
  })), this._rememberMorpher(t2, i2), this;
}, _queueNumber(t2, e2) {
  return this._queueObject(t2, new _t(e2));
}, cx(t2) {
  return this._queueNumber("cx", t2);
}, cy(t2) {
  return this._queueNumber("cy", t2);
}, move(t2, e2) {
  return this.x(t2).y(e2);
}, amove(t2, e2) {
  return this.ax(t2).ay(e2);
}, center(t2, e2) {
  return this.cx(t2).cy(e2);
}, size(t2, e2) {
  let i2;
  return t2 && e2 || (i2 = this._element.bbox()), t2 || (t2 = i2.width / i2.height * e2), e2 || (e2 = i2.height / i2.width * t2), this.width(t2).height(e2);
}, width(t2) {
  return this._queueNumber("width", t2);
}, height(t2) {
  return this._queueNumber("height", t2);
}, plot(t2, e2, i2, a2) {
  if (4 === arguments.length) return this.plot([t2, e2, i2, a2]);
  if (this._tryRetarget("plot", t2)) return this;
  const s2 = new He(this._stepper).type(this._element.MorphArray).to(t2);
  return this.queue((function() {
    s2.from(this._element.array());
  }), (function(t3) {
    return this._element.plot(s2.at(t3)), s2.done();
  })), this._rememberMorpher("plot", s2), this;
}, leading(t2) {
  return this._queueNumber("leading", t2);
}, viewbox(t2, e2, i2, a2) {
  return this._queueObject("viewbox", new kt(t2, e2, i2, a2));
}, update(t2) {
  return "object" != typeof t2 ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", t2.offset), this);
} }), Q(Qe, { rx: Zt, ry: $t, from: ne, to: oe }), q(Qe, "Runner");
class si extends Vt {
  constructor(t2, e2 = t2) {
    super(G("svg", t2), e2), this.namespace();
  }
  defs() {
    return this.isRoot() ? V(this.node.querySelector("defs")) || this.put(new Ut()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof O.window.SVGElement) && "#document-fragment" !== this.node.parentNode.nodeName;
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: E, version: "1.1" }).attr("xmlns:xlink", H, Y) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, Y).attr("xmlns:svgjs", null, Y);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
A$1({ Container: { nested: K((function() {
  return this.put(new si());
})) } }), q(si, "Svg", true);
let ri = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("symbol", t2), e2);
  }
};
A$1({ Container: { symbol: K((function() {
  return this.put(new ri());
})) } }), q(ri, "Symbol");
var ni = Object.freeze({ __proto__: null, amove: function(t2, e2) {
  return this.ax(t2).ay(e2);
}, ax: function(t2) {
  return this.attr("x", t2);
}, ay: function(t2) {
  return this.attr("y", t2);
}, build: function(t2) {
  return this._build = !!t2, this;
}, center: function(t2, e2, i2 = this.bbox()) {
  return this.cx(t2, i2).cy(e2, i2);
}, cx: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cx : this.attr("x", this.attr("x") + t2 - e2.cx);
}, cy: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cy : this.attr("y", this.attr("y") + t2 - e2.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(t2, e2, i2 = this.bbox()) {
  return this.x(t2, i2).y(e2, i2);
}, plain: function(t2) {
  return false === this._build && this.clear(), this.node.appendChild(O.document.createTextNode(t2)), this;
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.attr("x", this.attr("x") + t2 - e2.x);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.attr("y", this.attr("y") + t2 - e2.y);
} });
class oi extends qt {
  constructor(t2, e2 = t2) {
    super(G("text", t2), e2), this.dom.leading = this.dom.leading ?? new _t(1.3), this._rebuild = true, this._build = false;
  }
  leading(t2) {
    return null == t2 ? this.dom.leading : (this.dom.leading = new _t(t2), this.rebuild());
  }
  rebuild(t2) {
    if ("boolean" == typeof t2 && (this._rebuild = t2), this._rebuild) {
      const t3 = this;
      let e2 = 0;
      const i2 = this.dom.leading;
      this.each((function(a2) {
        if (X(this.node)) return;
        const s2 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), r2 = i2 * new _t(s2);
        this.dom.newLined && (this.attr("x", t3.attr("x")), "\n" === this.text() ? e2 += r2 : (this.attr("dy", a2 ? r2 + e2 : 0), e2 = 0));
      })), this.fire("rebuild");
    }
    return this;
  }
  setData(t2) {
    return this.dom = t2, this.dom.leading = new _t(t2.leading || 1.3), this;
  }
  writeDataToDom() {
    return R(this, this.dom, { leading: 1.3 }), this;
  }
  text(t2) {
    if (void 0 === t2) {
      const e2 = this.node.childNodes;
      let i2 = 0;
      t2 = "";
      for (let a2 = 0, s2 = e2.length; a2 < s2; ++a2) "textPath" === e2[a2].nodeName || X(e2[a2]) ? 0 === a2 && (i2 = a2 + 1) : (a2 !== i2 && 3 !== e2[a2].nodeType && true === V(e2[a2]).dom.newLined && (t2 += "\n"), t2 += e2[a2].textContent);
      return t2;
    }
    if (this.clear().build(true), "function" == typeof t2) t2.call(this, this);
    else for (let e2 = 0, i2 = (t2 = (t2 + "").split("\n")).length; e2 < i2; e2++) this.newLine(t2[e2]);
    return this.build(false).rebuild();
  }
}
Q(oi, ni), A$1({ Container: { text: K((function(t2 = "") {
  return this.put(new oi()).text(t2);
})), plain: K((function(t2 = "") {
  return this.put(new oi()).plain(t2);
})) } }), q(oi, "Text");
class li extends qt {
  constructor(t2, e2 = t2) {
    super(G("tspan", t2), e2), this._build = false;
  }
  dx(t2) {
    return this.attr("dx", t2);
  }
  dy(t2) {
    return this.attr("dy", t2);
  }
  newLine() {
    this.dom.newLined = true;
    const t2 = this.parent();
    if (!(t2 instanceof oi)) return this;
    const e2 = t2.index(this), i2 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), a2 = t2.dom.leading * new _t(i2);
    return this.dy(e2 ? a2 : 0).attr("x", t2.x());
  }
  text(t2) {
    return null == t2 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t2 ? (this.clear().build(true), t2.call(this, this), this.build(false)) : this.plain(t2), this);
  }
}
Q(li, ni), A$1({ Tspan: { tspan: K((function(t2 = "") {
  const e2 = new li();
  return this._build || this.clear(), this.put(e2).text(t2);
})) }, Text: { newLine: function(t2 = "") {
  return this.tspan(t2).newLine();
} } }), q(li, "Tspan");
class hi extends qt {
  constructor(t2, e2 = t2) {
    super(G("circle", t2), e2);
  }
  radius(t2) {
    return this.attr("r", t2);
  }
  rx(t2) {
    return this.attr("r", t2);
  }
  ry(t2) {
    return this.rx(t2);
  }
  size(t2) {
    return this.radius(new _t(t2).divide(2));
  }
}
Q(hi, { x: Jt, y: Qt, cx: Kt, cy: te, width: ee, height: ie }), A$1({ Container: { circle: K((function(t2 = 0) {
  return this.put(new hi()).size(t2).move(0, 0);
})) } }), q(hi, "Circle");
class ci extends Vt {
  constructor(t2, e2 = t2) {
    super(G("clipPath", t2), e2);
  }
  remove() {
    return this.targets().forEach((function(t2) {
      t2.unclip();
    })), super.remove();
  }
  targets() {
    return Lt("svg [clip-path*=" + this.id() + "]");
  }
}
A$1({ Container: { clip: K((function() {
  return this.defs().put(new ci());
})) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(t2) {
  const e2 = t2 instanceof ci ? t2 : this.parent().clip().add(t2);
  return this.attr("clip-path", "url(#" + e2.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), q(ci, "ClipPath");
class di extends Gt {
  constructor(t2, e2 = t2) {
    super(G("foreignObject", t2), e2);
  }
}
A$1({ Container: { foreignObject: K((function(t2, e2) {
  return this.put(new di()).size(t2, e2);
})) } }), q(di, "ForeignObject");
var ui = Object.freeze({ __proto__: null, dmove: function(t2, e2) {
  return this.children().forEach(((i2) => {
    let a2;
    try {
      a2 = i2.node instanceof F().SVGSVGElement ? new kt(i2.attr(["x", "y", "width", "height"])) : i2.bbox();
    } catch (t3) {
      return;
    }
    const s2 = new vt(i2), r2 = s2.translate(t2, e2).transform(s2.inverse()), n2 = new bt(a2.x, a2.y).transform(r2);
    i2.move(n2.x, n2.y);
  })), this;
}, dx: function(t2) {
  return this.dmove(t2, 0);
}, dy: function(t2) {
  return this.dmove(0, t2);
}, height: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.height : this.size(e2.width, t2, e2);
}, move: function(t2 = 0, e2 = 0, i2 = this.bbox()) {
  const a2 = t2 - i2.x, s2 = e2 - i2.y;
  return this.dmove(a2, s2);
}, size: function(t2, e2, i2 = this.bbox()) {
  const a2 = I(this, t2, e2, i2), s2 = a2.width / i2.width, r2 = a2.height / i2.height;
  return this.children().forEach(((t3) => {
    const e3 = new bt(i2).transform(new vt(t3).inverse());
    t3.scale(s2, r2, e3.x, e3.y);
  })), this;
}, width: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.width : this.size(t2, e2.height, e2);
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.move(t2, e2.y, e2);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.move(e2.x, t2, e2);
} });
class gi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("g", t2), e2);
  }
}
Q(gi, ui), A$1({ Container: { group: K((function() {
  return this.put(new gi());
})) } }), q(gi, "G");
class pi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("a", t2), e2);
  }
  target(t2) {
    return this.attr("target", t2);
  }
  to(t2) {
    return this.attr("href", t2, H);
  }
}
Q(pi, ui), A$1({ Container: { link: K((function(t2) {
  return this.put(new pi()).to(t2);
})) }, Element: { unlink() {
  const t2 = this.linker();
  if (!t2) return this;
  const e2 = t2.parent();
  if (!e2) return this.remove();
  const i2 = e2.index(t2);
  return e2.add(this, i2), t2.remove(), this;
}, linkTo(t2) {
  let e2 = this.linker();
  return e2 || (e2 = new pi(), this.wrap(e2)), "function" == typeof t2 ? t2.call(e2, e2) : e2.to(t2), this;
}, linker() {
  const t2 = this.parent();
  return t2 && "a" === t2.node.nodeName.toLowerCase() ? t2 : null;
} } }), q(pi, "A");
class fi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("mask", t2), e2);
  }
  remove() {
    return this.targets().forEach((function(t2) {
      t2.unmask();
    })), super.remove();
  }
  targets() {
    return Lt("svg [mask*=" + this.id() + "]");
  }
}
A$1({ Container: { mask: K((function() {
  return this.defs().put(new fi());
})) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(t2) {
  const e2 = t2 instanceof fi ? t2 : this.parent().mask().add(t2);
  return this.attr("mask", "url(#" + e2.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), q(fi, "Mask");
class xi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("stop", t2), e2);
  }
  update(t2) {
    return ("number" == typeof t2 || t2 instanceof _t) && (t2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", new _t(t2.offset)), this;
  }
}
A$1({ Gradient: { stop: function(t2, e2, i2) {
  return this.put(new xi()).update(t2, e2, i2);
} } }), q(xi, "Stop");
class bi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("style", t2), e2);
  }
  addText(t2 = "") {
    return this.node.textContent += t2, this;
  }
  font(t2, e2, i2 = {}) {
    return this.rule("@font-face", { fontFamily: t2, src: e2, ...i2 });
  }
  rule(t2, e2) {
    return this.addText((function(t3, e3) {
      if (!t3) return "";
      if (!e3) return t3;
      let i2 = t3 + "{";
      for (const t4 in e3) i2 += t4.replace(/([A-Z])/g, (function(t5, e4) {
        return "-" + e4.toLowerCase();
      })) + ":" + e3[t4] + ";";
      return i2 += "}", i2;
    })(t2, e2));
  }
}
A$1("Dom", { style(t2, e2) {
  return this.put(new bi()).rule(t2, e2);
}, fontface(t2, e2, i2) {
  return this.put(new bi()).font(t2, e2, i2);
} }), q(bi, "Style");
class mi extends oi {
  constructor(t2, e2 = t2) {
    super(G("textPath", t2), e2);
  }
  array() {
    const t2 = this.track();
    return t2 ? t2.array() : null;
  }
  plot(t2) {
    const e2 = this.track();
    let i2 = null;
    return e2 && (i2 = e2.plot(t2)), null == t2 ? i2 : this;
  }
  track() {
    return this.reference("href");
  }
}
A$1({ Container: { textPath: K((function(t2, e2) {
  return t2 instanceof oi || (t2 = this.text(t2)), t2.path(e2);
})) }, Text: { path: K((function(t2, e2 = true) {
  const i2 = new mi();
  let a2;
  if (t2 instanceof We || (t2 = this.defs().path(t2)), i2.attr("href", "#" + t2, H), e2) for (; a2 = this.node.firstChild; ) i2.node.appendChild(a2);
  return this.put(i2);
})), textPath() {
  return this.findOne("textPath");
} }, Path: { text: K((function(t2) {
  return t2 instanceof oi || (t2 = new oi().addTo(this.parent()).text(t2)), t2.path(this);
})), targets() {
  return Lt("svg textPath").filter(((t2) => (t2.attr("href") || "").includes(this.id())));
} } }), mi.prototype.MorphArray = Ee, q(mi, "TextPath");
class vi extends qt {
  constructor(t2, e2 = t2) {
    super(G("use", t2), e2);
  }
  use(t2, e2) {
    return this.attr("href", (e2 || "") + "#" + t2, H);
  }
}
A$1({ Container: { use: K((function(t2, e2) {
  return this.put(new vi()).use(t2, e2);
})) } }), q(vi, "Use");
const yi = B;
Q([si, ri, de, ce, be], C("viewbox")), Q([xe, je, Ge, We], C("marker")), Q(oi, C("Text")), Q(We, C("Path")), Q(Ut, C("Defs")), Q([oi, li], C("Tspan")), Q([Ve, se, he, Qe], C("radius")), Q(Rt, C("EventTarget")), Q(Bt, C("Dom")), Q(Gt, C("Element")), Q(qt, C("Shape")), Q([Vt, re], C("Container")), Q(he, C("Gradient")), Q(Qe, C("Runner")), Ct.extend([...new Set(k)]), (function(t2 = []) {
  Ne.push(...[].concat(t2));
})([_t, xt, kt, vt, Dt, ge, Ee, bt]), Q(Ne, { to(t2) {
  return new He().type(this.constructor).from(this.toArray()).to(t2);
}, fromArray(t2) {
  return this.init(t2), this;
}, toConsumable() {
  return this.toArray();
}, morph(t2, e2, i2, a2, s2) {
  return this.fromArray(t2.map((function(t3, r2) {
    return a2.step(t3, e2[r2], i2, s2[r2], s2);
  })));
} });
class wi extends Gt {
  constructor(t2) {
    super(G("filter", t2), t2), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = true;
  }
  put(t2, e2) {
    return !(t2 = super.put(t2, e2)).attr("in") && this.$autoSetIn && t2.attr("in", this.$source), t2.attr("result") || t2.attr("result", t2.id()), t2;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return Lt('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}
class ki extends Gt {
  constructor(t2, e2) {
    super(t2, e2), this.result(this.id());
  }
  in(t2) {
    if (null == t2) {
      const t3 = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
    }
    return this.attr("in", t2);
  }
  result(t2) {
    return this.attr("result", t2);
  }
  toString() {
    return this.result();
  }
}
const Ai = (t2) => function(...e2) {
  for (let i2 = t2.length; i2--; ) null != e2[i2] && this.attr(t2[i2], e2[i2]);
}, Ci = { blend: Ai(["in", "in2", "mode"]), colorMatrix: Ai(["type", "values"]), composite: Ai(["in", "in2", "operator"]), convolveMatrix: function(t2) {
  t2 = new Dt(t2).toString(), this.attr({ order: Math.sqrt(t2.split(" ").length), kernelMatrix: t2 });
}, diffuseLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: Ai(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: Ai(["in", "dx", "dy", "stdDeviation"]), flood: Ai(["flood-color", "flood-opacity"]), gaussianBlur: function(t2 = 0, e2 = t2) {
  this.attr("stdDeviation", t2 + " " + e2);
}, image: function(t2) {
  this.attr("href", t2, H);
}, morphology: Ai(["operator", "radius"]), offset: Ai(["dx", "dy"]), specularLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: Ai([]), turbulence: Ai(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach(((t2) => {
  const e2 = P(t2), i2 = Ci[t2];
  wi[e2 + "Effect"] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
    update(t3) {
      return i2.apply(this, t3), this;
    }
  }, wi.prototype[t2] = K((function(t3, ...i3) {
    const a2 = new wi[e2 + "Effect"]();
    return null == t3 ? this.put(a2) : ("function" == typeof t3 ? t3.call(a2, a2) : i3.unshift(t3), this.put(a2).update(i3));
  }));
})), Q(wi, { merge(t2) {
  const e2 = this.put(new wi.MergeEffect());
  if ("function" == typeof t2) return t2.call(e2, e2), e2;
  return (t2 instanceof Array ? t2 : [...arguments]).forEach(((t3) => {
    t3 instanceof wi.MergeNode ? e2.put(t3) : e2.mergeNode(t3);
  })), e2;
}, componentTransfer(t2 = {}) {
  const e2 = this.put(new wi.ComponentTransferEffect());
  if ("function" == typeof t2) return t2.call(e2, e2), e2;
  if (!(t2.r || t2.g || t2.b || t2.a)) {
    t2 = { r: t2, g: t2, b: t2, a: t2 };
  }
  for (const i2 in t2) e2.add(new wi["Func" + i2.toUpperCase()](t2[i2]));
  return e2;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach(((t2) => {
  const e2 = P(t2);
  wi[e2] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
  };
}));
["funcR", "funcG", "funcB", "funcA"].forEach((function(t2) {
  const e2 = wi[P(t2)], i2 = K((function() {
    return this.put(new e2());
  }));
  wi.ComponentTransferEffect.prototype[t2] = i2;
}));
["distantLight", "pointLight", "spotLight"].forEach(((t2) => {
  const e2 = wi[P(t2)], i2 = K((function() {
    return this.put(new e2());
  }));
  wi.DiffuseLightingEffect.prototype[t2] = i2, wi.SpecularLightingEffect.prototype[t2] = i2;
})), Q(wi.MergeEffect, { mergeNode(t2) {
  return this.put(new wi.MergeNode()).attr("in", t2);
} }), Q(Ut, { filter: function(t2) {
  const e2 = this.put(new wi());
  return "function" == typeof t2 && t2.call(e2, e2), e2;
} }), Q(Vt, { filter: function(t2) {
  return this.defs().filter(t2);
} }), Q(Gt, { filterWith: function(t2) {
  const e2 = t2 instanceof wi ? t2 : this.defs().filter(t2);
  return this.attr("filter", e2);
}, unfilter: function(t2) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
const Si = { blend: function(t2, e2) {
  return this.parent() && this.parent().blend(this, t2, e2);
}, colorMatrix: function(t2, e2) {
  return this.parent() && this.parent().colorMatrix(t2, e2).in(this);
}, componentTransfer: function(t2) {
  return this.parent() && this.parent().componentTransfer(t2).in(this);
}, composite: function(t2, e2) {
  return this.parent() && this.parent().composite(this, t2, e2);
}, convolveMatrix: function(t2) {
  return this.parent() && this.parent().convolveMatrix(t2).in(this);
}, diffuseLighting: function(t2, e2, i2, a2) {
  return this.parent() && this.parent().diffuseLighting(t2, i2, a2).in(this);
}, displacementMap: function(t2, e2, i2, a2) {
  return this.parent() && this.parent().displacementMap(this, t2, e2, i2, a2);
}, dropShadow: function(t2, e2, i2) {
  return this.parent() && this.parent().dropShadow(this, t2, e2, i2).in(this);
}, flood: function(t2, e2) {
  return this.parent() && this.parent().flood(t2, e2);
}, gaussianBlur: function(t2, e2) {
  return this.parent() && this.parent().gaussianBlur(t2, e2).in(this);
}, image: function(t2) {
  return this.parent() && this.parent().image(t2);
}, merge: function(t2) {
  return t2 = t2 instanceof Array ? t2 : [...t2], this.parent() && this.parent().merge(this, ...t2);
}, morphology: function(t2, e2) {
  return this.parent() && this.parent().morphology(t2, e2).in(this);
}, offset: function(t2, e2) {
  return this.parent() && this.parent().offset(t2, e2).in(this);
}, specularLighting: function(t2, e2, i2, a2, s2) {
  return this.parent() && this.parent().specularLighting(t2, i2, a2, s2).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(t2, e2, i2, a2, s2) {
  return this.parent() && this.parent().turbulence(t2, e2, i2, a2, s2).in(this);
} };
Q(ki, Si), Q(wi.MergeEffect, { in: function(t2) {
  return t2 instanceof wi.MergeNode ? this.add(t2, 0) : this.add(new wi.MergeNode().in(t2), 0), this;
} }), Q([wi.CompositeEffect, wi.BlendEffect, wi.DisplacementMapEffect], { in2: function(t2) {
  if (null == t2) {
    const t3 = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
  }
  return this.attr("in2", t2);
} }), wi.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var Li = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
    var i2 = this.w;
    t3.unfilter(true), new wi().size("120%", "180%", "-5%", "-40%"), i2.config.chart.dropShadow.enabled && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
  } }, { key: "applyFilter", value: function(t3, e2, i2) {
    var a2, s2 = this, r2 = this.w;
    if (t3.unfilter(true), "none" !== i2) {
      var n2, o2, l2 = r2.config.chart.dropShadow, h2 = "lighten" === i2 ? 2 : 0.3;
      if (t3.filterWith((function(t4) {
        t4.colorMatrix({ type: "matrix", values: "\n          ".concat(h2, " 0 0 0 0\n          0 ").concat(h2, " 0 0 0\n          0 0 ").concat(h2, " 0 0\n          0 0 0 1 0\n        "), in: "SourceGraphic", result: "brightness" }), l2.enabled && s2.addShadow(t4, e2, l2, "brightness");
      })), !l2.noUserSpaceOnUse) null === (n2 = t3.filterer()) || void 0 === n2 || null === (o2 = n2.node) || void 0 === o2 || o2.setAttribute("filterUnits", "userSpaceOnUse");
      this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node);
    } else this.getDefaultFilter(t3, e2);
  } }, { key: "addShadow", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = i2.blur, o2 = i2.top, l2 = i2.left, h2 = i2.color, c2 = i2.opacity;
    if (h2 = Array.isArray(h2) ? h2[e2] : h2, (null === (s2 = r2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.length) > 0 && -1 === r2.config.chart.dropShadow.enabledOnSeries.indexOf(e2)) return t3;
    t3.offset({ in: a2, dx: l2, dy: o2, result: "offset" }), t3.gaussianBlur({ in: "offset", stdDeviation: n2, result: "blur" }), t3.flood({ "flood-color": h2, "flood-opacity": c2, result: "flood" }), t3.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), t3.merge(["shadow", a2]);
  } }, { key: "dropShadow", value: function(t3, e2) {
    var i2, a2, s2, r2, n2, o2 = this, l2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, h2 = this.w;
    if (t3.unfilter(true), v.isMsEdge() && "radialBar" === h2.config.chart.type) return t3;
    if ((null === (i2 = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === i2 ? void 0 : i2.length) > 0 && -1 === (null === (s2 = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.indexOf(l2))) return t3;
    (t3.filterWith((function(t4) {
      o2.addShadow(t4, l2, e2, "SourceGraphic");
    })), e2.noUserSpaceOnUse) || (null === (r2 = t3.filterer()) || void 0 === r2 || null === (n2 = r2.node) || void 0 === n2 || n2.setAttribute("filterUnits", "userSpaceOnUse"));
    return this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node), t3;
  } }, { key: "setSelectionFilter", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (void 0 !== a2.globals.selectedDataPoints[e2] && a2.globals.selectedDataPoints[e2].indexOf(i2) > -1) {
      t3.node.setAttribute("selected", true);
      var s2 = a2.config.states.active.filter;
      "none" !== s2 && this.applyFilter(t3, e2, s2.type);
    }
  } }, { key: "_scaleFilterSize", value: function(t3) {
    if (t3) {
      !(function(e2) {
        for (var i2 in e2) e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    }
  } }]), t2;
})(), Mi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "roundPathCorners", value: function(t3, e2) {
    function i2(t4, e3, i3) {
      var s3 = e3.x - t4.x, r3 = e3.y - t4.y, n3 = Math.sqrt(s3 * s3 + r3 * r3);
      return a2(t4, e3, Math.min(1, i3 / n3));
    }
    function a2(t4, e3, i3) {
      return { x: t4.x + (e3.x - t4.x) * i3, y: t4.y + (e3.y - t4.y) * i3 };
    }
    function s2(t4, e3) {
      t4.length > 2 && (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
    }
    function r2(t4) {
      return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
    }
    t3.indexOf("NaN") > -1 && (t3 = "");
    var n2 = t3.split(/[,\s]/).reduce((function(t4, e3) {
      var i3 = e3.match(/^([a-zA-Z])(.+)/);
      return i3 ? (t4.push(i3[1]), t4.push(i3[2])) : t4.push(e3), t4;
    }), []).reduce((function(t4, e3) {
      return parseFloat(e3) == e3 && t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
    }), []), o2 = [];
    if (n2.length > 1) {
      var l2 = r2(n2[0]), h2 = null;
      "Z" == n2[n2.length - 1][0] && n2[0].length > 2 && (h2 = ["L", l2.x, l2.y], n2[n2.length - 1] = h2), o2.push(n2[0]);
      for (var c2 = 1; c2 < n2.length; c2++) {
        var d2 = o2[o2.length - 1], u2 = n2[c2], g2 = u2 == h2 ? n2[1] : n2[c2 + 1];
        if (g2 && d2 && d2.length > 2 && "L" == u2[0] && g2.length > 2 && "L" == g2[0]) {
          var p2, f2, x2 = r2(d2), b2 = r2(u2), m2 = r2(g2);
          p2 = i2(b2, x2, e2), f2 = i2(b2, m2, e2), s2(u2, p2), u2.origPoint = b2, o2.push(u2);
          var v2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = ["C", v2.x, v2.y, y2.x, y2.y, f2.x, f2.y];
          w2.origPoint = b2, o2.push(w2);
        } else o2.push(u2);
      }
      if (h2) {
        var k2 = r2(o2[o2.length - 1]);
        o2.push(["Z"]), s2(o2[0], k2);
      }
    } else o2 = n2;
    return o2.reduce((function(t4, e3) {
      return t4 + e3.join(" ") + " ";
    }), "");
  } }, { key: "drawLine", value: function(t3, e2, i2, a2) {
    var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, o2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": n2, "stroke-linecap": o2 });
  } }, { key: "drawRect", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, o2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h2 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
    return c2.attr({ x: t3, y: e2, width: i2 > 0 ? i2 : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: n2, "stroke-width": null !== o2 ? o2 : 0, stroke: null !== l2 ? l2 : "none", "stroke-dasharray": h2 }), c2.node.setAttribute("fill", r2), c2;
  } }, { key: "drawPolygon", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i2 });
  } }, { key: "drawCircle", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    t3 < 0 && (t3 = 0);
    var i2 = this.w.globals.dom.Paper.circle(2 * t3);
    return null !== e2 && i2.attr(e2), i2;
  } }, { key: "drawPath", value: function(t3) {
    var e2 = t3.d, i2 = void 0 === e2 ? "" : e2, a2 = t3.stroke, s2 = void 0 === a2 ? "#a8a8a8" : a2, r2 = t3.strokeWidth, n2 = void 0 === r2 ? 1 : r2, o2 = t3.fill, l2 = t3.fillOpacity, h2 = void 0 === l2 ? 1 : l2, c2 = t3.strokeOpacity, d2 = void 0 === c2 ? 1 : c2, u2 = t3.classes, g2 = t3.strokeLinecap, p2 = void 0 === g2 ? null : g2, f2 = t3.strokeDashArray, x2 = void 0 === f2 ? 0 : f2, b2 = this.w;
    return null === p2 && (p2 = b2.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: o2, "fill-opacity": h2, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p2, "stroke-width": n2, "stroke-dasharray": x2, class: u2 });
  } }, { key: "group", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
    return null !== t3 && e2.attr(t3), e2;
  } }, { key: "move", value: function(t3, e2) {
    var i2 = ["M", t3, e2].join(" ");
    return i2;
  } }, { key: "line", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = null;
    return null === i2 ? a2 = [" L", t3, e2].join(" ") : "H" === i2 ? a2 = [" H", t3].join(" ") : "V" === i2 && (a2 = [" V", e2].join(" ")), a2;
  } }, { key: "curve", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = ["C", t3, e2, i2, a2, s2, r2].join(" ");
    return n2;
  } }, { key: "quadraticCurve", value: function(t3, e2, i2, a2) {
    return ["Q", t3, e2, i2, a2].join(" ");
  } }, { key: "arc", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = "A";
    arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (o2 = "a");
    var l2 = [o2, t3, e2, i2, a2, s2, r2, n2].join(" ");
    return l2;
  } }, { key: "renderPaths", value: function(t3) {
    var e2, i2 = t3.j, a2 = t3.realIndex, s2 = t3.pathFrom, r2 = t3.pathTo, n2 = t3.stroke, o2 = t3.strokeWidth, l2 = t3.strokeLinecap, h2 = t3.fill, c2 = t3.animationDelay, d2 = t3.initialSpeed, g2 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.chartType, x2 = t3.shouldClipToGrid, b2 = void 0 === x2 || x2, m2 = t3.bindEventsOnPaths, v2 = void 0 === m2 || m2, w2 = t3.drawShadow, k2 = void 0 === w2 || w2, A2 = this.w, C2 = new Li(this.ctx), S2 = new y(this.ctx), L2 = this.w.config.chart.animations.enabled, M2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled;
    if (s2 && s2.startsWith("M 0 0") && r2) {
      var P2 = r2.match(/^M\s+[\d.-]+\s+[\d.-]+/);
      P2 && (s2 = s2.replace(/^M\s+0\s+0/, P2[0]));
    }
    var I2 = !!(L2 && !A2.globals.resized || M2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
    I2 ? e2 = s2 : (e2 = r2, A2.globals.animationEnded = true);
    var T2 = A2.config.stroke.dashArray, z2 = 0;
    z2 = Array.isArray(T2) ? T2[a2] : A2.config.stroke.dashArray;
    var X2 = this.drawPath({ d: e2, stroke: n2, strokeWidth: o2, fill: h2, fillOpacity: 1, classes: p2, strokeLinecap: l2, strokeDashArray: z2 });
    X2.attr("index", a2), b2 && ("bar" === f2 && !A2.globals.isHorizontal || A2.globals.comboCharts ? X2.attr({ "clip-path": "url(#gridRectBarMask".concat(A2.globals.cuid, ")") }) : X2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") })), A2.config.chart.dropShadow.enabled && k2 && C2.dropShadow(X2, A2.config.chart.dropShadow, a2), v2 && (X2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, X2)), X2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, X2)), X2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, X2))), X2.attr({ pathTo: r2, pathFrom: s2 });
    var R2 = { el: X2, j: i2, realIndex: a2, pathFrom: s2, pathTo: r2, fill: h2, strokeWidth: o2, delay: c2 };
    return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || S2.showDelayedElements() : S2.animatePathsGradually(u(u({}, R2), {}, { speed: d2 })), A2.globals.dataChanged && M2 && I2 && S2.animatePathsGradually(u(u({}, R2), {}, { speed: g2 })), X2;
  } }, { key: "drawPattern", value: function(t3, e2, i2) {
    var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(e2, i2, (function(r2) {
      "horizontalLines" === t3 ? r2.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : "verticalLines" === t3 ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : "slantedLines" === t3 ? r2.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : "squares" === t3 ? r2.rect(e2, i2).fill("none").stroke({ color: a2, width: s2 }) : "circles" === t3 && r2.circle(e2).fill("none").stroke({ color: a2, width: s2 });
    }));
  } }, { key: "drawGradient", value: function(t3, e2, i2, a2, s2) {
    var r2, n2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : [], h2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c2 = this.w;
    e2.length < 9 && 0 === e2.indexOf("#") && (e2 = v.hexToRgba(e2, a2)), i2.length < 9 && 0 === i2.indexOf("#") && (i2 = v.hexToRgba(i2, s2));
    var d2 = 0, u2 = 1, g2 = 1, p2 = null;
    null !== o2 && (d2 = void 0 !== o2[0] ? o2[0] / 100 : 0, u2 = void 0 !== o2[1] ? o2[1] / 100 : 1, g2 = void 0 !== o2[2] ? o2[2] / 100 : 1, p2 = void 0 !== o2[3] ? o2[3] / 100 : null);
    var f2 = !("donut" !== c2.config.chart.type && "pie" !== c2.config.chart.type && "polarArea" !== c2.config.chart.type && "bubble" !== c2.config.chart.type);
    if (r2 = l2 && 0 !== l2.length ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", (function(t4) {
      (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach((function(e3) {
        t4.stop(e3.offset / 100, e3.color, e3.opacity);
      }));
    })) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", (function(t4) {
      t4.stop(d2, e2, a2), t4.stop(u2, i2, s2), t4.stop(g2, i2, s2), null !== p2 && t4.stop(p2, e2, a2);
    })), f2) {
      var x2 = c2.globals.gridWidth / 2, b2 = c2.globals.gridHeight / 2;
      "bubble" !== c2.config.chart.type ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: x2, cy: b2, r: n2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else "vertical" === t3 ? r2.from(0, 0).to(0, 1) : "diagonal" === t3 ? r2.from(0, 0).to(1, 1) : "horizontal" === t3 ? r2.from(0, 1).to(1, 1) : "diagonal2" === t3 && r2.from(1, 0).to(0, 1);
    return r2;
  } }, { key: "getTextBasedOnMaxWidth", value: function(t3) {
    var e2 = t3.text, i2 = t3.maxWidth, a2 = t3.fontSize, s2 = t3.fontFamily, r2 = this.getTextRects(e2, a2, s2), n2 = r2.width / e2.length, o2 = Math.floor(i2 / n2);
    return i2 < r2.width ? e2.slice(0, o2 - 3) + "..." : e2;
  } }, { key: "drawText", value: function(t3) {
    var e2 = this, i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.fontSize, o2 = t3.fontFamily, l2 = t3.fontWeight, h2 = t3.foreColor, c2 = t3.opacity, d2 = t3.maxWidth, g2 = t3.cssClass, p2 = void 0 === g2 ? "" : g2, f2 = t3.isPlainText, x2 = void 0 === f2 || f2, b2 = t3.dominantBaseline, m2 = void 0 === b2 ? "auto" : b2, v2 = this.w;
    void 0 === s2 && (s2 = "");
    var y2 = s2;
    r2 || (r2 = "start"), h2 && h2.length || (h2 = v2.config.chart.foreColor), o2 = o2 || v2.config.chart.fontFamily, l2 = l2 || "regular";
    var w2, k2 = { maxWidth: d2, fontSize: n2 = n2 || "11px", fontFamily: o2 };
    return Array.isArray(s2) ? w2 = v2.globals.dom.Paper.text((function(t4) {
      for (var i3 = 0; i3 < s2.length; i3++) y2 = s2[i3], d2 && (y2 = e2.getTextBasedOnMaxWidth(u({ text: s2[i3] }, k2))), 0 === i3 ? t4.tspan(y2) : t4.tspan(y2).newLine();
    })) : (d2 && (y2 = this.getTextBasedOnMaxWidth(u({ text: s2 }, k2))), w2 = x2 ? v2.globals.dom.Paper.plain(s2) : v2.globals.dom.Paper.text((function(t4) {
      return t4.tspan(y2);
    }))), w2.attr({ x: i2, y: a2, "text-anchor": r2, "dominant-baseline": m2, "font-size": n2, "font-family": o2, "font-weight": l2, fill: h2, class: "apexcharts-text " + p2 }), w2.node.style.fontFamily = o2, w2.node.style.opacity = c2, w2;
  } }, { key: "getMarkerPath", value: function(t3, e2, i2, a2) {
    var s2 = "";
    switch (i2) {
      case "cross":
        s2 = "M ".concat(t3 - (a2 /= 1.4), " ").concat(e2 - a2, " L ").concat(t3 + a2, " ").concat(e2 + a2, "  M ").concat(t3 - a2, " ").concat(e2 + a2, " L ").concat(t3 + a2, " ").concat(e2 - a2);
        break;
      case "plus":
        s2 = "M ".concat(t3 - (a2 /= 1.12), " ").concat(e2, " L ").concat(t3 + a2, " ").concat(e2, "  M ").concat(t3, " ").concat(e2 - a2, " L ").concat(t3, " ").concat(e2 + a2);
        break;
      case "star":
      case "sparkle":
        var r2 = 5;
        a2 *= 1.15, "sparkle" === i2 && (a2 /= 1.1, r2 = 4);
        for (var n2 = Math.PI / r2, o2 = 0; o2 <= 2 * r2; o2++) {
          var l2 = o2 * n2, h2 = o2 % 2 == 0 ? a2 : a2 / 2;
          s2 += (0 === o2 ? "M" : "L") + (t3 + h2 * Math.sin(l2)) + "," + (e2 - h2 * Math.cos(l2));
        }
        s2 += "Z";
        break;
      case "triangle":
        s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2 + a2, " \n             Z");
        break;
      case "square":
      case "rect":
        s2 = "M ".concat(t3 - (a2 /= 1.125), " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 + a2, " \n           L ").concat(t3 - a2, " ").concat(e2 + a2, " \n           Z");
        break;
      case "diamond":
        a2 *= 1.05, s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2, " \n             L ").concat(t3, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2, " \n            Z");
        break;
      case "line":
        s2 = "M ".concat(t3 - (a2 /= 1.1), " ").concat(e2, " \n           L ").concat(t3 + a2, " ").concat(e2);
        break;
      default:
        a2 *= 2, s2 = "M ".concat(t3, ", ").concat(e2, " \n           m -").concat(a2 / 2, ", 0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 ").concat(a2, ",0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 -").concat(a2, ",0");
    }
    return s2;
  } }, { key: "drawMarkerShape", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.drawPath({ d: this.getMarkerPath(t3, e2, i2, a2, s2), stroke: s2.pointStrokeColor, strokeDashArray: s2.pointStrokeDashArray, strokeWidth: s2.pointStrokeWidth, fill: s2.pointFillColor, fillOpacity: s2.pointFillOpacity, strokeOpacity: s2.pointStrokeOpacity });
    return r2.attr({ cx: t3, cy: e2, shape: s2.shape, class: s2.class ? s2.class : "" }), r2;
  } }, { key: "drawMarker", value: function(t3, e2, i2) {
    t3 = t3 || 0;
    var a2 = i2.pSize || 0;
    return v.isNumber(e2) || (a2 = 0, e2 = 0), this.drawMarkerShape(t3, e2, null == i2 ? void 0 : i2.shape, a2, u(u({}, i2), "line" === i2.shape || "plus" === i2.shape || "cross" === i2.shape ? { pointStrokeColor: i2.pointFillColor, pointStrokeOpacity: i2.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    if ("function" == typeof i2.config.chart.events.dataPointMouseEnter && i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), ("none" === i2.config.states.active.filter.type || "true" !== t3.node.getAttribute("selected")) && "none" !== i2.config.states.hover.filter.type && !i2.globals.isTouchDevice) {
      var n2 = i2.config.states.hover.filter;
      a2.applyFilter(t3, s2, n2.type);
    }
  } }, { key: "pathMouseLeave", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    "function" == typeof i2.config.chart.events.dataPointMouseLeave && i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), "none" !== i2.config.states.active.filter.type && "true" === t3.node.getAttribute("selected") || "none" !== i2.config.states.hover.filter.type && a2.getDefaultFilter(t3, s2);
  } }, { key: "pathMouseDown", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), n2 = "false";
    if ("true" === t3.node.getAttribute("selected")) {
      if (t3.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
        var o2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
        i2.globals.selectedDataPoints[s2].splice(o2, 1);
      }
    } else {
      if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
        i2.globals.selectedDataPoints = [];
        var l2 = i2.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h2 = i2.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), c2 = function(t4) {
          Array.prototype.forEach.call(t4, (function(t5) {
            t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
          }));
        };
        c2(l2), c2(h2);
      }
      t3.node.setAttribute("selected", "true"), n2 = "true", void 0 === i2.globals.selectedDataPoints[s2] && (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
    }
    if ("true" === n2) {
      var d2 = i2.config.states.active.filter;
      if ("none" !== d2) a2.applyFilter(t3, s2, d2.type);
      else if ("none" !== i2.config.states.hover.filter && !i2.globals.isTouchDevice) {
        var u2 = i2.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    } else if ("none" !== i2.config.states.active.filter.type) if ("none" === i2.config.states.hover.filter.type || i2.globals.isTouchDevice) a2.getDefaultFilter(t3, s2);
    else {
      u2 = i2.config.states.hover.filter;
      a2.applyFilter(t3, s2, u2.type);
    }
    "function" == typeof i2.config.chart.events.dataPointSelection && i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
  } }, { key: "rotateAroundCenter", value: function(t3) {
    var e2 = {};
    return t3 && "function" == typeof t3.getBBox && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
  } }, { key: "getTextRects", value: function(t3, e2, i2, a2) {
    var s2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r2 = this.w, n2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i2, foreColor: "#fff", opacity: 0 });
    a2 && n2.attr("transform", a2), r2.globals.dom.Paper.add(n2);
    var o2 = n2.bbox();
    return s2 || (o2 = n2.node.getBoundingClientRect()), n2.remove(), { width: o2.width, height: o2.height };
  } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i2) {
    if ("function" == typeof t3.getComputedTextLength && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i2 / 1.1)) {
      for (var a2 = e2.length - 3; a2 > 0; a2 -= 3) if (t3.getSubStringLength(0, a2) <= i2 / 1.1) return void (t3.textContent = e2.substring(0, a2) + "...");
      t3.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(t3, e2) {
    for (var i2 in e2) e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
  } }]), t2;
})(), Pi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getStackedSeriesTotals", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = this.w, i2 = [];
    if (0 === e2.globals.series.length) return i2;
    for (var a2 = 0; a2 < e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
      for (var s2 = 0, r2 = 0; r2 < e2.globals.series.length; r2++) void 0 !== e2.globals.series[r2][a2] && -1 === t3.indexOf(r2) && (s2 += e2.globals.series[r2][a2]);
      i2.push(s2);
    }
    return i2;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return null === t3 ? this.w.config.series.reduce((function(t4, e2) {
      return t4 + e2;
    }), 0) : this.w.globals.series[t3].reduce((function(t4, e2) {
      return t4 + e2;
    }), 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.globals.seriesGroups.forEach((function(a2) {
      var s2 = [];
      e2.config.series.forEach((function(t4, i3) {
        a2.indexOf(e2.globals.seriesNames[i3]) > -1 && s2.push(i3);
      }));
      var r2 = e2.globals.series.map((function(t4, e3) {
        return -1 === s2.indexOf(e3) ? e3 : -1;
      })).filter((function(t4) {
        return -1 !== t4;
      }));
      i2.push(t3.getStackedSeriesTotals(r2));
    })), i2;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = [], a2 = [], s2 = [], r2 = t3.series.length > e2.yaxis.length || e2.yaxis.some((function(t4) {
      return Array.isArray(t4.seriesName);
    }));
    e2.series.forEach((function(t4, e3) {
      s2.push(e3), a2.push(null);
    })), e2.yaxis.forEach((function(t4, e3) {
      i2[e3] = [];
    }));
    var n2 = [];
    e2.yaxis.forEach((function(t4, a3) {
      var o3 = false;
      if (t4.seriesName) {
        var l3 = [];
        Array.isArray(t4.seriesName) ? l3 = t4.seriesName : l3.push(t4.seriesName), l3.forEach((function(t5) {
          e2.series.forEach((function(e3, n3) {
            if (e3.name === t5) {
              var l4 = n3;
              a3 === n3 || r2 ? !r2 || s2.indexOf(n3) > -1 ? i2[a3].push([a3, n3]) : console.warn("Series '" + e3.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i2[n3].push([n3, a3]), l4 = a3), o3 = true, -1 !== (l4 = s2.indexOf(l4)) && s2.splice(l4, 1);
            }
          }));
        }));
      }
      o3 || n2.push(a3);
    })), i2 = i2.map((function(t4, e3) {
      var i3 = [];
      return t4.forEach((function(t5) {
        a2[t5[1]] = t5[0], i3.push(t5[1]);
      })), i3;
    }));
    for (var o2 = e2.yaxis.length - 1, l2 = 0; l2 < n2.length && (o2 = n2[l2], i2[o2] = [], s2); l2++) {
      var h2 = s2[0];
      s2.shift(), i2[o2].push(h2), a2[h2] = o2;
    }
    s2.forEach((function(t4) {
      i2[o2].push(t4), a2[t4] = o2;
    })), t3.seriesYAxisMap = i2.map((function(t4) {
      return t4;
    })), t3.seriesYAxisReverseMap = a2.map((function(t4) {
      return t4;
    })), t3.seriesYAxisMap.forEach((function(t4, i3) {
      t4.forEach((function(t5) {
        e2.series[t5] && void 0 === e2.series[t5].group && (e2.series[t5].group = "apexcharts-axis-".concat(i3.toString()));
      }));
    }));
  } }, { key: "isSeriesNull", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return 0 === (null === t3 ? this.w.config.series.filter((function(t4) {
      return null !== t4;
    })) : this.w.config.series[t3].data.filter((function(t4) {
      return null !== t4;
    }))).length;
  } }, { key: "seriesHaveSameValues", value: function(t3) {
    return this.w.globals.series[t3].every((function(t4, e2, i2) {
      return t4 === i2[0];
    }));
  } }, { key: "getCategoryLabels", value: function(t3) {
    var e2 = this.w, i2 = t3.slice();
    return e2.config.xaxis.convertedCatToNumeric && (i2 = t3.map((function(t4, i3) {
      return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
    }))), i2;
  } }, { key: "getLargestSeries", value: function() {
    var t3 = this.w;
    t3.globals.maxValsInArrayIndex = t3.globals.series.map((function(t4) {
      return t4.length;
    })).indexOf(Math.max.apply(Math, t3.globals.series.map((function(t4) {
      return t4.length;
    }))));
  } }, { key: "getLargestMarkerSize", value: function() {
    var t3 = this.w, e2 = 0;
    return t3.globals.markers.size.forEach((function(t4) {
      e2 = Math.max(e2, t4);
    })), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach((function(t4) {
      e2 = Math.max(e2, t4.size);
    })), e2 > 0 && (t3.config.markers.hover.size > 0 ? e2 = t3.config.markers.hover.size : e2 += t3.config.markers.hover.sizeOffset), t3.globals.markers.largestSize = e2, e2;
  } }, { key: "getSeriesTotals", value: function() {
    var t3 = this.w;
    t3.globals.seriesTotals = t3.globals.series.map((function(t4, e2) {
      var i2 = 0;
      if (Array.isArray(t4)) for (var a2 = 0; a2 < t4.length; a2++) i2 += t4[a2];
      else i2 += t4;
      return i2;
    }));
  } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
    var i2 = this.w;
    return i2.globals.series.map((function(a2, s2) {
      for (var r2 = 0, n2 = 0; n2 < a2.length; n2++) i2.globals.seriesX[s2][n2] > t3 && i2.globals.seriesX[s2][n2] < e2 && (r2 += a2[n2]);
      return r2;
    }));
  } }, { key: "getPercentSeries", value: function() {
    var t3 = this.w;
    t3.globals.seriesPercent = t3.globals.series.map((function(e2, i2) {
      var a2 = [];
      if (Array.isArray(e2)) for (var s2 = 0; s2 < e2.length; s2++) {
        var r2 = t3.globals.stackedSeriesTotals[s2], n2 = 0;
        r2 && (n2 = 100 * e2[s2] / r2), a2.push(n2);
      }
      else {
        var o2 = 100 * e2 / t3.globals.seriesTotals.reduce((function(t4, e3) {
          return t4 + e3;
        }), 0);
        a2.push(o2);
      }
      return a2;
    }));
  } }, { key: "getCalculatedRatios", value: function() {
    var t3, e2, i2, a2 = this, s2 = this.w, r2 = s2.globals, n2 = [], o2 = 0, l2 = [], h2 = 0.1, c2 = 0;
    if (r2.yRange = [], r2.isMultipleYAxis) for (var d2 = 0; d2 < r2.minYArr.length; d2++) r2.yRange.push(Math.abs(r2.minYArr[d2] - r2.maxYArr[d2])), l2.push(0);
    else r2.yRange.push(Math.abs(r2.minY - r2.maxY));
    r2.xRange = Math.abs(r2.maxX - r2.minX), r2.zRange = Math.abs(r2.maxZ - r2.minZ);
    for (var u2 = 0; u2 < r2.yRange.length; u2++) n2.push(r2.yRange[u2] / r2.gridHeight);
    if (e2 = r2.xRange / r2.gridWidth, t3 = r2.yRange / r2.gridWidth, i2 = r2.xRange / r2.gridHeight, (o2 = r2.zRange / r2.gridHeight * 16) || (o2 = 1), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (r2.hasNegs = true), s2.globals.seriesYAxisReverseMap.length > 0) {
      var g2 = function(t4, e3) {
        var i3 = s2.config.yaxis[s2.globals.seriesYAxisReverseMap[e3]], r3 = t4 < 0 ? -1 : 1;
        return t4 = Math.abs(t4), i3.logarithmic && (t4 = a2.getBaseLog(i3.logBase, t4)), -r3 * t4 / n2[e3];
      };
      if (r2.isMultipleYAxis) {
        l2 = [];
        for (var p2 = 0; p2 < n2.length; p2++) l2.push(g2(r2.minYArr[p2], p2));
      } else (l2 = []).push(g2(r2.minY, 0)), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (h2 = -r2.minY / t3, c2 = r2.minX / e2);
    } else (l2 = []).push(0), h2 = 0, c2 = 0;
    return { yRatio: n2, invertedYRatio: t3, zRatio: o2, xRatio: e2, invertedXRatio: i2, baseLineInvertedY: h2, baseLineY: l2, baseLineX: c2 };
  } }, { key: "getLogSeries", value: function(t3) {
    var e2 = this, i2 = this.w;
    return i2.globals.seriesLog = t3.map((function(t4, a2) {
      var s2 = i2.globals.seriesYAxisReverseMap[a2];
      return i2.config.yaxis[s2] && i2.config.yaxis[s2].logarithmic ? t4.map((function(t5) {
        return null === t5 ? null : e2.getLogVal(i2.config.yaxis[s2].logBase, t5, a2);
      })) : t4;
    })), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(t3, e2) {
    if (null === t3) return null;
    var i2 = this.w, a2 = i2.globals.seriesYAxisReverseMap[e2];
    return i2.config.yaxis[a2] && i2.config.yaxis[a2].logarithmic ? this.getLogVal(i2.config.yaxis[a2].logBase, t3, e2) : t3;
  } }, { key: "getBaseLog", value: function(t3, e2) {
    return Math.log(e2) / Math.log(t3);
  } }, { key: "getLogVal", value: function(t3, e2, i2) {
    if (e2 <= 0) return 0;
    var a2 = this.w, s2 = 0 === a2.globals.minYArr[i2] ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (0 === a2.globals.maxYArr[i2] ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
    return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
  } }, { key: "getLogYRatios", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = this.w.globals;
    return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map((function(t4, s2) {
      var r2 = i2.globals.seriesYAxisReverseMap[s2];
      if (i2.config.yaxis[r2] && e2.w.config.yaxis[r2].logarithmic) {
        var n2, o2 = -Number.MAX_VALUE, l2 = Number.MIN_VALUE;
        return a2.seriesLog.forEach((function(t5, e3) {
          t5.forEach((function(t6) {
            i2.config.yaxis[e3] && i2.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), l2 = Math.min(t6, l2));
          }));
        })), n2 = Math.pow(a2.yRange[s2], Math.abs(l2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = n2 / a2.gridHeight, n2;
      }
    })), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = [];
    return t3.series.length > 0 && e2.forEach((function(e3) {
      var n2 = [], o2 = [];
      t3.i.forEach((function(i3, a3) {
        s2.config.series[i3].group === e3 && (n2.push(t3.series[a3]), o2.push(i3));
      })), n2.length > 0 && r2.push(a2.draw(n2, i2, o2));
    })), r2;
  } }], [{ key: "checkComboSeries", value: function(t3, e2) {
    var i2 = false, a2 = 0, s2 = 0;
    return void 0 === e2 && (e2 = "line"), t3.length && void 0 !== t3[0].type && t3.forEach((function(t4) {
      "bar" !== t4.type && "column" !== t4.type && "candlestick" !== t4.type && "boxPlot" !== t4.type || a2++, void 0 !== t4.type && t4.type !== e2 && s2++;
    })), s2 > 0 && (i2 = true), { comboBarCount: a2, comboCharts: i2 };
  } }, { key: "extendArrayProps", value: function(t3, e2, i2) {
    var a2, s2, r2, n2, o2, l2;
    (null !== (a2 = e2) && void 0 !== a2 && a2.yaxis && (e2 = t3.extendYAxis(e2, i2)), null !== (s2 = e2) && void 0 !== s2 && s2.annotations) && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), null !== (r2 = e2) && void 0 !== r2 && null !== (n2 = r2.annotations) && void 0 !== n2 && n2.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), null !== (o2 = e2) && void 0 !== o2 && null !== (l2 = o2.annotations) && void 0 !== l2 && l2.points && (e2 = t3.extendPointAnnotations(e2)));
    return e2;
  } }]), t2;
})(), Ii = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2;
  }
  return s(t2, [{ key: "setOrientations", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.w;
    if ("vertical" === t3.label.orientation) {
      var a2 = null !== e2 ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
      if (null !== s2) {
        var r2 = s2.getBoundingClientRect();
        s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4);
        var n2 = "top" === t3.label.position ? r2.width : -r2.width;
        s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + n2);
        var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), l2 = o2.x, h2 = o2.y;
        s2.setAttribute("transform", "rotate(-90 ".concat(l2, " ").concat(h2, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
    var i2 = this.w;
    if (!t3 || !e2.label.text || !String(e2.label.text).trim()) return null;
    var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding, n2 = r2.left, o2 = r2.right, l2 = r2.top, h2 = r2.bottom;
    if ("vertical" === e2.label.orientation) {
      var c2 = [n2, o2, l2, h2];
      l2 = c2[0], h2 = c2[1], n2 = c2[2], o2 = c2[3];
    }
    var d2 = s2.left - a2.left - n2, u2 = s2.top - a2.top - l2, g2 = this.annoCtx.graphics.drawRect(d2 - i2.globals.barPadForNumericAxis, u2, s2.width + n2 + o2, s2.height + l2 + h2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
    return e2.id && g2.node.classList.add(e2.id), g2;
  } }, { key: "annotationsBackground", value: function() {
    var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
      var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
      if (r2) {
        var n2 = r2.parentNode, o2 = t3.addBackgroundToAnno(r2, i3);
        o2 && (n2.insertBefore(o2.node, r2), i3.label.mouseEnter && o2.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave && o2.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t3, i3)), i3.label.click && o2.node.addEventListener("click", i3.label.click.bind(t3, i3)));
      }
    };
    e2.config.annotations.xaxis.forEach((function(t4, e3) {
      return i2(t4, e3, "xaxis");
    })), e2.config.annotations.yaxis.forEach((function(t4, e3) {
      return i2(t4, e3, "yaxis");
    })), e2.config.annotations.points.forEach((function(t4, e3) {
      return i2(t4, e3, "point");
    }));
  } }, { key: "getY1Y2", value: function(t3, e2) {
    var i2, a2 = this.w, s2 = "y1" === t3 ? e2.y : e2.y2, r2 = false;
    if (this.annoCtx.invertAxis) {
      var n2 = a2.config.xaxis.convertedCatToNumeric ? a2.globals.categoryLabels : a2.globals.labels, o2 = n2.indexOf(s2), l2 = a2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(o2 + 1, ")"));
      i2 = l2 ? parseFloat(l2.getAttribute("y")) : (a2.globals.gridHeight / n2.length - 1) * (o2 + 1) - a2.globals.barHeight, void 0 !== e2.seriesIndex && a2.globals.barHeight && (i2 -= a2.globals.barHeight / 2 * (a2.globals.series.length - 1) - a2.globals.barHeight * e2.seriesIndex);
    } else {
      var h2, c2 = a2.globals.seriesYAxisMap[e2.yAxisIndex][0], d2 = a2.config.yaxis[e2.yAxisIndex].logarithmic ? new Pi(this.annoCtx.ctx).getLogVal(a2.config.yaxis[e2.yAxisIndex].logBase, s2, c2) / a2.globals.yLogRatio[c2] : (s2 - a2.globals.minYArr[c2]) / (a2.globals.yRange[c2] / a2.globals.gridHeight);
      i2 = a2.globals.gridHeight - Math.min(Math.max(d2, 0), a2.globals.gridHeight), r2 = d2 > a2.globals.gridHeight || d2 < 0, !e2.marker || void 0 !== e2.y && null !== e2.y || (i2 = 0), null !== (h2 = a2.config.yaxis[e2.yAxisIndex]) && void 0 !== h2 && h2.reversed && (i2 = d2);
    }
    return "string" == typeof s2 && s2.includes("px") && (i2 = parseFloat(s2)), { yP: i2, clipped: r2 };
  } }, { key: "getX1X2", value: function(t3, e2) {
    var i2 = this.w, a2 = "x1" === t3 ? e2.x : e2.x2, s2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, r2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, n2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = false, l2 = this.annoCtx.inversedReversedAxis ? (r2 - a2) / (n2 / i2.globals.gridWidth) : (a2 - s2) / (n2 / i2.globals.gridWidth);
    return "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || i2.config.chart.sparkline.enabled || (l2 = this.getStringX(a2)), "string" == typeof a2 && a2.includes("px") && (l2 = parseFloat(a2)), null == a2 && e2.marker && (l2 = i2.globals.gridWidth), void 0 !== e2.seriesIndex && i2.globals.barWidth && !this.annoCtx.invertAxis && (l2 -= i2.globals.barWidth / 2 * (i2.globals.series.length - 1) - i2.globals.barWidth * e2.seriesIndex), "number" != typeof l2 && (l2 = 0, o2 = true), parseFloat(l2.toFixed(10)) > parseFloat(i2.globals.gridWidth.toFixed(10)) ? (l2 = i2.globals.gridWidth, o2 = true) : l2 < 0 && (l2 = 0, o2 = true), { x: l2, clipped: o2 };
  } }, { key: "getStringX", value: function(t3) {
    var e2 = this.w, i2 = t3;
    e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
    var a2 = e2.globals.labels.map((function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    })).indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a2 + 1, ")"));
    return s2 && (i2 = parseFloat(s2.getAttribute("x"))), i2;
  } }]), t2;
})(), Ti = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), n2 = r2.x, o2 = r2.clipped, l2 = true, h2 = t3.label.text, c2 = t3.strokeDashArray;
    if (v.isNumber(n2)) {
      if (null === t3.x2 || void 0 === t3.x2) {
        if (!o2) {
          var d2 = this.annoCtx.graphics.drawLine(n2 + t3.offsetX, 0 + t3.offsetY, n2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, c2, t3.borderWidth);
          e2.appendChild(d2.node), t3.id && d2.node.classList.add(t3.id);
        }
      } else {
        var u2 = this.helpers.getX1X2("x2", t3);
        if (a2 = u2.x, l2 = u2.clipped, a2 < n2) {
          var g2 = n2;
          n2 = a2, a2 = g2;
        }
        var p2 = this.annoCtx.graphics.drawRect(n2 + t3.offsetX, 0 + t3.offsetY, a2 - n2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, c2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
      if (!o2 || !l2) {
        var f2 = this.annoCtx.graphics.getTextRects(h2, parseFloat(t3.label.style.fontSize)), x2 = "top" === t3.label.position ? 4 : "center" === t3.label.position ? s2.globals.gridHeight / 2 + ("vertical" === t3.label.orientation ? f2.width / 2 : 0) : s2.globals.gridHeight, b2 = this.annoCtx.graphics.drawText({ x: n2 + t3.label.offsetX, y: x2 + t3.label.offsetY - ("vertical" === t3.label.orientation ? "top" === t3.label.position ? f2.width / 2 - 12 : -f2.width / 2 : 0), text: h2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        b2.attr({ rel: i2 }), e2.appendChild(b2.node), this.annoCtx.helpers.setOrientations(t3, i2);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return e2.config.annotations.xaxis.map((function(e3, a2) {
      t3.addXaxisAnnotation(e3, i2.node, a2);
    })), i2;
  } }]), t2;
})(), zi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return s(t2, [{ key: "isValidDate", value: function(t3) {
    return "number" != typeof t3 && !isNaN(this.parseDate(t3));
  } }, { key: "getTimeStamp", value: function(t3) {
    return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
  } }, { key: "getDate", value: function(t3) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
  } }, { key: "parseDate", value: function(t3) {
    var e2 = Date.parse(t3);
    if (!isNaN(e2)) return this.getTimeStamp(t3);
    var i2 = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i2 = this.getTimeStamp(i2);
  } }, { key: "parseDateWithTimezone", value: function(t3) {
    return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(t3, e2) {
    var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(f(i2.months)), r2 = [""].concat(f(i2.shortMonths)), n2 = [""].concat(f(i2.days)), o2 = [""].concat(f(i2.shortDays));
    function l2(t4, e3) {
      var i3 = t4 + "";
      for (e3 = e3 || 2; i3.length < e3; ) i3 = "0" + i3;
      return i3;
    }
    var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h2)).replace(/(^|[^\\])yy/g, "$1" + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h2);
    var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
    var d2 = a2 ? t3.getUTCDate() : t3.getDate();
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + n2[0])).replace(/(^|[^\\])ddd/g, "$1" + o2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
    var u2 = a2 ? t3.getUTCHours() : t3.getHours(), g2 = u2 > 12 ? u2 - 12 : 0 === u2 ? 12 : u2;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(u2))).replace(/(^|[^\\])H/g, "$1" + u2)).replace(/(^|[^\\])hh+/g, "$1" + l2(g2))).replace(/(^|[^\\])h/g, "$1" + g2);
    var p2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
    e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(p2))).replace(/(^|[^\\])m/g, "$1" + p2);
    var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
    e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
    var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
    e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
    var m2 = u2 < 12 ? "AM" : "PM";
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + m2)).replace(/(^|[^\\])T/g, "$1" + m2.charAt(0));
    var v2 = m2.toLowerCase();
    e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + v2)).replace(/(^|[^\\])t/g, "$1" + v2.charAt(0));
    var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
    if (!a2) {
      var k2 = (y2 = Math.abs(y2)) % 60;
      w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
    }
    e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
    var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
    return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i2) {
    var a2 = this.w;
    void 0 !== a2.config.xaxis.min && (t3 = a2.config.xaxis.min), void 0 !== a2.config.xaxis.max && (e2 = a2.config.xaxis.max);
    var s2 = this.getDate(t3), r2 = this.getDate(e2), n2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), o2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(n2[6], 10), maxMillisecond: parseInt(o2[6], 10), minSecond: parseInt(n2[5], 10), maxSecond: parseInt(o2[5], 10), minMinute: parseInt(n2[4], 10), maxMinute: parseInt(o2[4], 10), minHour: parseInt(n2[3], 10), maxHour: parseInt(o2[3], 10), minDate: parseInt(n2[2], 10), maxDate: parseInt(o2[2], 10), minMonth: parseInt(n2[1], 10) - 1, maxMonth: parseInt(o2[1], 10) - 1, minYear: parseInt(n2[0], 10), maxYear: parseInt(o2[0], 10) };
  } }, { key: "isLeapYear", value: function(t3) {
    return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i2) {
    return this.determineDaysOfMonths(t3, e2) - i2;
  } }, { key: "determineDaysOfYear", value: function(t3) {
    var e2 = 365;
    return this.isLeapYear(t3) && (e2 = 366), e2;
  } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i2) {
    var a2 = this.daysCntOfYear[e2] + i2;
    return e2 > 1 && this.isLeapYear() && a2++, a2;
  } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
    var i2 = 30;
    switch (t3 = v.monthMod(t3), true) {
      case this.months30.indexOf(t3) > -1:
        2 === t3 && (i2 = this.isLeapYear(e2) ? 29 : 28);
        break;
      case this.months31.indexOf(t3) > -1:
      default:
        i2 = 31;
    }
    return i2;
  } }]), t2;
})(), Xi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
  }
  return s(t2, [{ key: "xLabelFormat", value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if ("datetime" === s2.config.xaxis.type && void 0 === s2.config.xaxis.labels.formatter && void 0 === s2.config.tooltip.x.formatter) {
      var r2 = new zi(this.ctx);
      return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
    }
    return t3(e2, i2, a2);
  } }, { key: "defaultGeneralFormatter", value: function(t3) {
    return Array.isArray(t3) ? t3.map((function(t4) {
      return t4;
    })) : t3;
  } }, { key: "defaultYFormatter", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (v.isNumber(t3)) if (0 !== a2.globals.yValueDecimal) t3 = t3.toFixed(void 0 !== e2.decimalsInFloat ? e2.decimalsInFloat : a2.globals.yValueDecimal);
    else {
      var s2 = t3.toFixed(0);
      t3 = t3 == s2 ? s2 : t3.toFixed(1);
    }
    return t3;
  } }, { key: "setLabelFormatters", value: function() {
    var t3 = this, e2 = this.w;
    return e2.globals.xaxisTooltipFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttKeyFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttZFormatter = function(t4) {
      return t4;
    }, e2.globals.legendFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, void 0 !== e2.config.xaxis.labels.formatter ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
      if (v.isNumber(t4)) {
        if (!e2.config.xaxis.convertedCatToNumeric && "numeric" === e2.config.xaxis.type) {
          if (v.isNumber(e2.config.xaxis.decimalsInFloat)) return t4.toFixed(e2.config.xaxis.decimalsInFloat);
          var i2 = e2.globals.maxX - e2.globals.minX;
          return i2 > 0 && i2 < 100 ? t4.toFixed(1) : t4.toFixed(0);
        }
        if (e2.globals.isBarHorizontal) {
          if (e2.globals.maxY - e2.globals.minYArr < 4) return t4.toFixed(1);
        }
        return t4.toFixed(0);
      }
      return t4;
    }, "function" == typeof e2.config.tooltip.x.formatter ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, "function" == typeof e2.config.xaxis.tooltip.formatter && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || void 0 !== e2.config.tooltip.y.formatter) && (e2.globals.ttVal = e2.config.tooltip.y), void 0 !== e2.config.tooltip.z.formatter && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), void 0 !== e2.config.legend.formatter && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach((function(i2, a2) {
      void 0 !== i2.labels.formatter ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
        return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map((function(e3) {
          return t3.defaultYFormatter(e3, i2, a2);
        })) : t3.defaultYFormatter(s2, i2, a2) : s2;
      };
    })), e2.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var t3 = this.w;
    if ("heatmap" === t3.config.chart.type) {
      t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
      var e2 = t3.globals.seriesNames.reduce((function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }), 0);
      t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
    }
  } }]), t2;
})(), Ri = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getLabel", value: function(t3, e2, i2, a2) {
    var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", n2 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], o2 = this.w, l2 = void 0 === t3[a2] ? "" : t3[a2], h2 = l2, c2 = o2.globals.xLabelFormatter, d2 = o2.config.xaxis.labels.formatter, u2 = false, g2 = new Xi(this.ctx), p2 = l2;
    n2 && (h2 = g2.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 }), void 0 !== d2 && (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 })));
    var f2, x2;
    e2.length > 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach((function(t4) {
      "month" === t4.unit ? x2 = "year" : "day" === t4.unit ? x2 = "month" : "hour" === t4.unit ? x2 = "day" : "minute" === t4.unit && (x2 = "hour");
    })), u2 = x2 === f2, i2 = e2[a2].position, h2 = e2[a2].value) : "datetime" === o2.config.xaxis.type && void 0 === d2 && (h2 = ""), void 0 === h2 && (h2 = ""), h2 = Array.isArray(h2) ? h2 : h2.toString();
    var b2 = new Mi(this.ctx), m2 = {};
    m2 = o2.globals.rotateXLabels && n2 ? b2.getTextRects(h2, parseInt(r2, 10), null, "rotate(".concat(o2.config.xaxis.labels.rotate, " 0 0)"), false) : b2.getTextRects(h2, parseInt(r2, 10));
    var v2 = !o2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h2) && ("NaN" === String(h2) || s2.indexOf(h2) >= 0 && v2) && (h2 = ""), { x: i2, text: h2, textRect: m2, isBold: u2 };
  } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
    return "dataPoints" === s2 && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = ""), e2;
  } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (0 === t3 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
      var n2 = s2[s2.length - 1];
      e2.x < n2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + n2.x && (e2.text = "");
    }
    return e2;
  } }, { key: "checkForReversedLabels", value: function(t3, e2) {
    var i2 = this.w;
    return i2.config.yaxis[t3] && i2.config.yaxis[t3].reversed && e2.reverse(), e2;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(t3) {
    var e2 = this.w.globals;
    return !e2.seriesYAxisMap[t3].some((function(t4) {
      return -1 === e2.collapsedSeriesIndices.indexOf(t4);
    }));
  } }, { key: "translateYAxisIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.globals, a2 = e2.config.yaxis;
    return i2.series.length > a2.length || a2.some((function(t4) {
      return Array.isArray(t4.seriesName);
    })) ? t3 : i2.seriesYAxisReverseMap[t3];
  } }, { key: "isYAxisHidden", value: function(t3) {
    var e2 = this.w, i2 = e2.config.yaxis[t3];
    if (!i2.show || this.yAxisAllSeriesCollapsed(t3)) return true;
    if (!i2.showForNullSeries) {
      var a2 = e2.globals.seriesYAxisMap[t3], s2 = new Pi(this.ctx);
      return a2.every((function(t4) {
        return s2.isSeriesNull(t4);
      }));
    }
    return false;
  } }, { key: "getYAxisForeColor", value: function(t3, e2) {
    var i2 = this.w;
    return Array.isArray(t3) && i2.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
  } }, { key: "drawYAxisTicks", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.translateY + o2.config.yaxis[s2].labels.offsetY;
    if (o2.globals.isBarHorizontal ? h2 = 0 : "heatmap" === o2.config.chart.type && (h2 += r2 / 2), a2.show && e2 > 0) {
      true === o2.config.yaxis[s2].opposite && (t3 += a2.width);
      for (var c2 = e2; c2 >= 0; c2--) {
        var d2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, h2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, h2 + a2.offsetY, a2.color);
        n2.add(d2), h2 += r2;
      }
    }
  } }]), t2;
})(), Ei = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx), this.axesUtils = new Ri(this.annoCtx);
  }
  return s(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i2) {
    var a2, s2 = this.w, r2 = t3.strokeDashArray, n2 = this.helpers.getY1Y2("y1", t3), o2 = n2.yP, l2 = n2.clipped, h2 = true, c2 = false, d2 = t3.label.text;
    if (null === t3.y2 || void 0 === t3.y2) {
      if (!l2) {
        c2 = true;
        var u2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
        e2.appendChild(u2.node), t3.id && u2.node.classList.add(t3.id);
      }
    } else {
      if (a2 = (n2 = this.helpers.getY1Y2("y2", t3)).yP, h2 = n2.clipped, a2 > o2) {
        var g2 = o2;
        o2 = a2, a2 = g2;
      }
      if (!l2 || !h2) {
        c2 = true;
        var p2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
    }
    if (c2) {
      var f2 = "right" === t3.label.position ? s2.globals.gridWidth : "center" === t3.label.position ? s2.globals.gridWidth / 2 : 0, x2 = this.annoCtx.graphics.drawText({ x: f2 + t3.label.offsetX, y: (null != a2 ? a2 : o2) + t3.label.offsetY - 3, text: d2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
      x2.attr({ rel: i2 }), e2.appendChild(x2.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
    var e2 = this.w;
    e2.globals.gridWidth;
    return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return e2.config.annotations.yaxis.forEach((function(e3, a2) {
      e3.yAxisIndex = t3.axesUtils.translateYAxisIndex(e3.yAxisIndex), t3.axesUtils.isYAxisHidden(e3.yAxisIndex) && t3.axesUtils.yAxisAllSeriesCollapsed(e3.yAxisIndex) || t3.addYaxisAnnotation(e3, i2.node, a2);
    })), i2;
  } }]), t2;
})(), Yi = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i2) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(t3.seriesIndex) > -1)) {
      var a2 = this.helpers.getX1X2("x1", t3), s2 = a2.x, r2 = a2.clipped, n2 = (a2 = this.helpers.getY1Y2("y1", t3)).yP, o2 = a2.clipped;
      if (v.isNumber(s2) && !o2 && !r2) {
        var l2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, h2 = this.annoCtx.graphics.drawMarker(s2 + t3.marker.offsetX, n2 + t3.marker.offsetY, l2);
        e2.appendChild(h2.node);
        var c2 = t3.label.text ? t3.label.text : "", d2 = this.annoCtx.graphics.drawText({ x: s2 + t3.label.offsetX, y: n2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: c2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        if (d2.attr({ rel: i2 }), e2.appendChild(d2.node), t3.customSVG.SVG) {
          var u2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
          u2.attr({ transform: "translate(".concat(s2 + t3.customSVG.offsetX, ", ").concat(n2 + t3.customSVG.offsetY, ")") }), u2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(u2.node);
        }
        if (t3.image.path) {
          var g2 = t3.image.width ? t3.image.width : 20, p2 = t3.image.height ? t3.image.height : 20;
          h2 = this.annoCtx.addImage({ x: s2 + t3.image.offsetX - g2 / 2, y: n2 + t3.image.offsetY - p2 / 2, width: g2, height: p2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t3.mouseEnter && h2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && h2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3)), t3.click && h2.node.addEventListener("click", t3.click.bind(this, t3));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return e2.config.annotations.points.map((function(e3, a2) {
      t3.addPointAnnotation(e3, i2.node, a2);
    })), i2;
  } }]), t2;
})();
var Hi = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, Oi = (function() {
  function t2() {
    i(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, showDuplicates: false, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return s(t2, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "", locales: [Hi], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, allowMouseWheelZoom: true, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: true, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
      return t3 + "%";
    } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce((function(t4, e2) {
        return t4 + e2;
      }), 0) / t3.globals.series.length + "%";
    } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t3) {
      return t3;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
      return t3;
    } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce((function(t4, e2) {
        return t4 + e2;
      }), 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
      return null !== t3 ? t3 : "";
    }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", backgroundColor: void 0, borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: true, clusterGroupedSeriesOrientation: "vertical", labels: { colors: void 0, useSeriesColors: false }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken" } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
      return t3 ? t3 + ": " : "";
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), t2;
})(), Fi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new Mi(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new Ii(this), this.xAxisAnnotations = new Ti(this), this.yAxisAnnotations = new Ei(this), this.pointsAnnotations = new Yi(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return s(t2, [{ key: "drawAxesAnnotations", value: function() {
    var t3 = this.w;
    if (t3.globals.axisCharts && t3.globals.dataPoints) {
      for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], n2 = [i2.node, e2.node, a2.node], o2 = 0; o2 < 3; o2++) t3.globals.dom.elGraphical.add(r2[o2]), !s2 || t3.globals.resized || t3.globals.dataChanged || "scatter" !== t3.config.chart.type && "bubble" !== t3.config.chart.type && t3.globals.dataPoints > 1 && n2[o2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: n2[o2], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.images.map((function(e2, i2) {
      t3.addImage(e2, i2);
    }));
  } }, { key: "drawTextAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.texts.map((function(e2, i2) {
      t3.addText(e2, i2);
    }));
  } }, { key: "addXaxisAnnotation", value: function(t3, e2, i2) {
    this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
  } }, { key: "addYaxisAnnotation", value: function(t3, e2, i2) {
    this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
  } }, { key: "addPointAnnotation", value: function(t3, e2, i2) {
    this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
  } }, { key: "addText", value: function(t3, e2) {
    var i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.foreColor, o2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, u2 = t3.borderWidth, g2 = t3.strokeDashArray, p2 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = void 0 === x2 ? ".apexcharts-svg" : x2, m2 = t3.paddingLeft, v2 = void 0 === m2 ? 4 : m2, y2 = t3.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t3.paddingBottom, A2 = void 0 === k2 ? 2 : k2, C2 = t3.paddingTop, S2 = void 0 === C2 ? 2 : C2, L2 = this.w, M2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || "start", fontSize: o2 || "12px", fontWeight: h2 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: n2 || L2.config.chart.foreColor, cssClass: c2 }), P2 = L2.globals.dom.baseEl.querySelector(b2);
    P2 && P2.appendChild(M2.node);
    var I2 = M2.bbox();
    if (s2) {
      var T2 = this.graphics.drawRect(I2.x - v2, I2.y - S2, I2.width + v2 + w2, I2.height + A2 + S2, p2, d2 || "transparent", 1, u2, f2, g2);
      P2.insertBefore(T2.node, M2.node);
    }
  } }, { key: "addImage", value: function(t3, e2) {
    var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = void 0 === s2 ? 0 : s2, n2 = t3.y, o2 = void 0 === n2 ? 0 : n2, l2 = t3.width, h2 = void 0 === l2 ? 20 : l2, c2 = t3.height, d2 = void 0 === c2 ? 20 : c2, u2 = t3.appendTo, g2 = void 0 === u2 ? ".apexcharts-svg" : u2, p2 = i2.globals.dom.Paper.image(a2);
    p2.size(h2, d2).move(r2, o2);
    var f2 = i2.globals.dom.baseEl.querySelector(g2);
    return f2 && f2.appendChild(p2.node), p2;
  } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
  } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i2) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
  } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i2) {
    return void 0 === this.invertAxis && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
  } }, { key: "addAnnotationExternal", value: function(t3) {
    var e2 = t3.params, i2 = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, n2 = a2, o2 = n2.w, l2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h2 = l2.childNodes.length + 1, c2 = new Oi(), d2 = Object.assign({}, "xaxis" === s2 ? c2.xAxisAnnotation : "yaxis" === s2 ? c2.yAxisAnnotation : c2.pointAnnotation), u2 = v.extend(d2, e2);
    switch (s2) {
      case "xaxis":
        this.addXaxisAnnotation(u2, l2, h2);
        break;
      case "yaxis":
        this.addYaxisAnnotation(u2, l2, h2);
        break;
      case "point":
        this.addPointAnnotation(u2, l2, h2);
    }
    var g2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h2, "']")), p2 = this.helpers.addBackgroundToAnno(g2, u2);
    return p2 && l2.insertBefore(p2.node, g2), i2 && o2.globals.memory.methodsToExec.push({ context: n2, id: u2.id ? u2.id : v.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
  } }, { key: "clearAnnotations", value: function(t3) {
    for (var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), a2 = e2.globals.memory.methodsToExec.length - 1; a2 >= 0; a2--) "addText" !== e2.globals.memory.methodsToExec[a2].label && "addAnnotation" !== e2.globals.memory.methodsToExec[a2].label || e2.globals.memory.methodsToExec.splice(a2, 1);
    i2 = v.listToArray(i2), Array.prototype.forEach.call(i2, (function(t4) {
      for (; t4.firstChild; ) t4.removeChild(t4.firstChild);
    }));
  } }, { key: "removeAnnotation", value: function(t3, e2) {
    var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e2));
    a2 && (i2.globals.memory.methodsToExec.map((function(t4, a3) {
      t4.id === e2 && i2.globals.memory.methodsToExec.splice(a3, 1);
    })), Object.keys(i2.config.annotations).forEach((function(t4) {
      var a3 = i2.config.annotations[t4];
      Array.isArray(a3) && (i2.config.annotations[t4] = a3.filter((function(t5) {
        return t5.id !== e2;
      })));
    })), Array.prototype.forEach.call(a2, (function(t4) {
      t4.parentElement.removeChild(t4);
    })));
  } }]), t2;
})(), Di = function(t2) {
  var e2, i2 = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, n2 = t2.y1, o2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], u2 = l2.config.series[s2].name ? l2.config.series[s2].name : "", g2 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
  ("function" == typeof p2 && (u2 = p2(u2, f2)), null !== (e2 = l2.config.series[s2].data[r2]) && void 0 !== e2 && e2.x && (d2 = l2.config.series[s2].data[r2].x), i2) || "datetime" === l2.config.xaxis.type && (d2 = new Xi(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(a2).formatDate, w: l2 }));
  "function" == typeof g2 && (d2 = g2(d2, f2)), Number.isFinite(n2) && Number.isFinite(o2) && (h2 = n2, c2 = o2);
  var x2 = "", b2 = "", m2 = l2.globals.colors[s2];
  if (void 0 === l2.config.tooltip.x.formatter) if ("datetime" === l2.config.xaxis.type) {
    var v2 = new zi(a2);
    x2 = v2.formatDate(v2.getDate(h2), l2.config.tooltip.x.format), b2 = v2.formatDate(v2.getDate(c2), l2.config.tooltip.x.format);
  } else x2 = h2, b2 = c2;
  else x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
  return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: m2, seriesName: u2 };
}, _i = function(t2) {
  var e2 = t2.color, i2 = t2.seriesName, a2 = t2.ylabel, s2 = t2.start, r2 = t2.end, n2 = t2.seriesIndex, o2 = t2.dataPointIndex, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(n2);
  s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
  var h2 = l2.yLbFormatter(t2.w.globals.series[n2][o2]), c2 = '<span class="value start-value">\n  '.concat(s2, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i2 || "") + '</span></div><div> <span class="category">' + a2 + ": </span> " + (t2.w.globals.comboCharts ? "rangeArea" === t2.w.config.series[n2].type || "rangeBar" === t2.w.config.series[n2].type ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
}, Ni = (function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(t3) {
    this.hideYAxis();
    return v.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t3, e2) {
      var i2 = e2.w.config.series[e2.seriesIndex].name;
      return null !== t3 ? i2 + ": " + t3 : "";
    }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: false }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), u(u({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
  } }, { key: "candlestick", value: function() {
    var t3 = this;
    return { stroke: { width: 1 }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i2, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var t3 = this;
    return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i2, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
      e2.ctx;
      var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = function() {
        var t4 = s2.globals.seriesRangeStart[i2][a2];
        return s2.globals.seriesRangeEnd[i2][a2] - t4;
      };
      return s2.globals.comboCharts ? "rangeBar" === s2.config.series[i2].type || "rangeArea" === s2.config.series[i2].type ? r2() : t3 : r2();
    }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
      return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? (function(t4) {
        var e2 = Di(u(u({}, t4), {}, { isTimeline: true })), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.startVal, n2 = e2.endVal;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      })(t3) : (function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      })(t3);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(t3) {
    var e2, i2;
    return null !== (e2 = t3.plotOptions.bar) && void 0 !== e2 && e2.barHeight || (t3.plotOptions.bar.barHeight = 2), null !== (i2 = t3.plotOptions.bar) && void 0 !== i2 && i2.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
      return (function(t4) {
        var e2 = Di(t4), i2 = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i2, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      })(t3);
    } } };
  } }, { key: "brush", value: function(t3) {
    return v.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
  } }, { key: "stacked100", value: function(t3) {
    t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
    var e2 = t3.dataLabels.formatter;
    return t3.yaxis.forEach((function(e3, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    })), "bar" === t3.chart.type && (t3.dataLabels.formatter = e2 || function(t4) {
      return "number" == typeof t4 && t4 ? t4.toFixed(0) + "%" : t4;
    }), t3;
  } }, { key: "stackedBars", value: function() {
    var t3 = this.bar();
    return u(u({}, t3), {}, { plotOptions: u(u({}, t3.plotOptions), {}, { bar: u(u({}, t3.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(t3) {
    return t3.xaxis.convertedCatToNumeric = true, t3;
  } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i2) {
    t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
      return v.isNumber(t4) ? Math.floor(t4) : t4;
    };
    var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
    return i2 && i2.length && (s2 = i2.map((function(t4) {
      return Array.isArray(t4) ? t4 : String(t4);
    }))), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
      return v.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
    }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(t3) {
      return t3;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(t3, e2, i2, a2, s2) {
    var r2 = t3.globals.seriesCandleO[e2][i2], n2 = t3.globals.seriesCandleH[e2][i2], o2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h2 = t3.globals.seriesCandleC[e2][i2];
    return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + n2 + "</span></div>" + (o2 ? "<div>".concat(a2[2], ': <span class="value">') + o2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h2 + "</span></div></div>";
  } }]), t2;
})(), Wi = (function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function(t3) {
    var e2 = t3.responsiveOverride, i2 = this.opts, a2 = new Oi(), s2 = new Ni(i2);
    this.chartType = i2.chart.type, i2 = this.extendYAxis(i2), i2 = this.extendAnnotations(i2);
    var r2 = a2.init(), n2 = {};
    if (i2 && "object" === b(i2)) {
      var o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, m2 = {};
      m2 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i2.chart.type) ? s2[i2.chart.type]() : s2.line(), null !== (o2 = i2.plotOptions) && void 0 !== o2 && null !== (l2 = o2.bar) && void 0 !== l2 && l2.isFunnel && (m2 = s2.funnel()), i2.chart.stacked && "bar" === i2.chart.type && (m2 = s2.stackedBars()), null !== (h2 = i2.chart.brush) && void 0 !== h2 && h2.enabled && (m2 = s2.brush(m2)), null !== (c2 = i2.plotOptions) && void 0 !== c2 && null !== (d2 = c2.line) && void 0 !== d2 && d2.isSlopeChart && (m2 = s2.slope()), i2.chart.stacked && "100%" === i2.chart.stackType && (i2 = s2.stacked100(i2)), null !== (u2 = i2.plotOptions) && void 0 !== u2 && null !== (g2 = u2.bar) && void 0 !== g2 && g2.isDumbbell && (i2 = s2.dumbbell(i2)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i2), i2.xaxis = i2.xaxis || window.Apex.xaxis || {}, e2 || (i2.xaxis.convertedCatToNumeric = false), (null !== (p2 = (i2 = this.checkForCatToNumericXAxis(this.chartType, m2, i2)).chart.sparkline) && void 0 !== p2 && p2.enabled || null !== (f2 = window.Apex.chart) && void 0 !== f2 && null !== (x2 = f2.sparkline) && void 0 !== x2 && x2.enabled) && (m2 = s2.sparkline(m2)), n2 = v.extend(r2, m2);
    }
    var y2 = v.extend(n2, window.Apex);
    return r2 = v.extend(y2, i2), r2 = this.handleUserInputErrors(r2);
  } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i2) {
    var a2, s2, r2 = new Ni(i2), n2 = ("bar" === t3 || "boxPlot" === t3) && (null === (a2 = i2.plotOptions) || void 0 === a2 || null === (s2 = a2.bar) || void 0 === s2 ? void 0 : s2.horizontal), o2 = "pie" === t3 || "polarArea" === t3 || "donut" === t3 || "radar" === t3 || "radialBar" === t3 || "heatmap" === t3, l2 = "datetime" !== i2.xaxis.type && "numeric" !== i2.xaxis.type, h2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
    return n2 || o2 || !l2 || "between" === h2 || (i2 = r2.convertCatToNumeric(i2)), i2;
  } }, { key: "extendYAxis", value: function(t3, e2) {
    var i2 = new Oi();
    (void 0 === t3.yaxis || !t3.yaxis || Array.isArray(t3.yaxis) && 0 === t3.yaxis.length) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = v.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [v.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = v.extendArray(t3.yaxis, i2.yAxis);
    var a2 = false;
    t3.yaxis.forEach((function(t4) {
      t4.logarithmic && (a2 = true);
    }));
    var s2 = t3.series;
    return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map((function(e3, a3) {
      if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3]) return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
      var r2 = v.extend(i2.yAxis, t3.yaxis[0]);
      return r2.show = false, r2;
    }))), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t3;
  } }, { key: "extendAnnotations", value: function(t3) {
    return void 0 === t3.annotations && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
  } }, { key: "extendYAxisAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.yaxis = v.extendArray(void 0 !== t3.annotations.yaxis ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
  } }, { key: "extendXAxisAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.xaxis = v.extendArray(void 0 !== t3.annotations.xaxis ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
  } }, { key: "extendPointAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.points = v.extendArray(void 0 !== t3.annotations.points ? t3.annotations.points : [], e2.pointAnnotation), t3;
  } }, { key: "checkForDarkTheme", value: function(t3) {
    t3.theme && "dark" === t3.theme.mode && (t3.tooltip || (t3.tooltip = {}), "light" !== t3.tooltip.theme && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.theme.palette || (t3.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(t3) {
    var e2 = t3;
    if (e2.tooltip.shared && e2.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if ("bar" === e2.chart.type && e2.plotOptions.bar.horizontal) {
      if (e2.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
    }
    return "bar" !== e2.chart.type && "rangeBar" !== e2.chart.type || e2.tooltip.shared && "barWidth" === e2.xaxis.crosshairs.width && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e2.chart.type && "boxPlot" !== e2.chart.type || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
  } }]), t2;
})(), Bi = (function() {
  function t2() {
    i(this, t2);
  }
  return s(t2, [{ key: "initGlobalVars", value: function(t3) {
    t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.lastWheelExecution = 0, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0, t3.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(t3) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: "pan" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.pan, selectionEnabled: "selection" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t3.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(t3) {
    var e2 = this.globalVars(t3);
    return this.initGlobalVars(e2), e2.initialConfig = v.extend({}, t3), e2.initialSeries = v.clone(t3.series), e2.lastXAxis = v.clone(e2.initialConfig.xaxis), e2.lastYAxis = v.clone(e2.initialConfig.yaxis), e2;
  } }]), t2;
})(), Gi = (function() {
  function t2(e2) {
    i(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = new Wi(this.opts).init({ responsiveOverride: false });
    return { config: t3, globals: new Bi().init(t3) };
  } }]), t2;
})(), ji = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return s(t2, [{ key: "clippedImgArea", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, n2 = t3.image, o2 = 0, l2 = 0;
    void 0 === t3.width && void 0 === t3.height ? void 0 !== i2.fill.image.width && void 0 !== i2.fill.image.height ? (o2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (o2 = r2 + 1, l2 = r2) : (o2 = t3.width, l2 = t3.height);
    var h2 = document.createElementNS(e2.globals.SVGNS, "pattern");
    Mi.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: o2 + "px", height: l2 + "px" });
    var c2 = document.createElementNS(e2.globals.SVGNS, "image");
    h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", n2), Mi.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: o2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
  } }, { key: "getSeriesIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.config.chart.type;
    return ("bar" === i2 || "rangeBar" === i2) && e2.config.plotOptions.bar.distributed || "heatmap" === i2 || "treemap" === i2 ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(t3, e2) {
    var i2, a2 = this.w, s2 = null, n2 = null, o2 = r(t3);
    try {
      for (o2.s(); !(i2 = o2.n()).done; ) {
        var l2 = i2.value;
        l2 >= e2.threshold ? (null === s2 || l2 > s2) && (s2 = l2) : (null === n2 || l2 < n2) && (n2 = l2);
      }
    } catch (t4) {
      o2.e(t4);
    } finally {
      o2.f();
    }
    null === s2 && (s2 = e2.threshold), null === n2 && (n2 = e2.threshold);
    var h2 = s2 - e2.threshold + (e2.threshold - n2);
    0 === h2 && (h2 = 1);
    var c2 = 100 - (e2.threshold - n2) / h2 * 100;
    return [{ offset: c2 = Math.max(0, Math.min(c2, 100)), color: e2.colorAboveThreshold, opacity: a2.config.fill.opacity }, { offset: 0, color: e2.colorBelowThreshold, opacity: a2.config.fill.opacity }];
  } }, { key: "fillPath", value: function(t3) {
    var e2, i2, a2, s2 = this.w;
    this.opts = t3;
    var r2, n2, o2, l2 = this.w.config;
    this.seriesIndex = this.getSeriesIndex(t3);
    var h2 = l2.plotOptions.line.colors.colorAboveThreshold && l2.plotOptions.line.colors.colorBelowThreshold, c2 = this.getFillColors()[this.seriesIndex];
    void 0 !== s2.globals.seriesColors[this.seriesIndex] && (c2 = s2.globals.seriesColors[this.seriesIndex]), "function" == typeof c2 && (c2 = c2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: s2 }));
    var d2, u2, g2, p2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), x2 = Array.isArray(l2.fill.opacity) ? l2.fill.opacity[this.seriesIndex] : l2.fill.opacity, b2 = "gradient" === p2 || h2;
    (t3.color && (c2 = t3.color), null !== (e2 = s2.config.series[this.seriesIndex]) && void 0 !== e2 && null !== (i2 = e2.data) && void 0 !== i2 && null !== (a2 = i2[t3.dataPointIndex]) && void 0 !== a2 && a2.fillColor) && (c2 = null === (d2 = s2.config.series[this.seriesIndex]) || void 0 === d2 || null === (u2 = d2.data) || void 0 === u2 || null === (g2 = u2[t3.dataPointIndex]) || void 0 === g2 ? void 0 : g2.fillColor);
    c2 || (c2 = "#fff", console.warn("undefined color - ApexCharts"));
    var m2 = c2;
    if (-1 === c2.indexOf("rgb") ? -1 === c2.indexOf("#") ? m2 = c2 : c2.length < 9 && (m2 = v.hexToRgba(c2, x2)) : c2.indexOf("rgba") > -1 ? x2 = v.getOpacityFromRGBA(c2) : m2 = v.hexToRgba(v.rgb2hex(c2), x2), t3.opacity && (x2 = t3.opacity), "pattern" === p2 && (n2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: n2, fillColor: c2, fillOpacity: x2, defaultColor: m2 })), b2) {
      var y2 = f(l2.fill.gradient.colorStops) || [], w2 = l2.fill.gradient.type;
      h2 && (y2[this.seriesIndex] = this.computeColorStops(s2.globals.series[this.seriesIndex], l2.plotOptions.line.colors), w2 = "vertical"), o2 = this.handleGradientFill({ type: w2, fillConfig: t3.fillConfig, fillColor: c2, fillOpacity: x2, colorStops: y2, i: this.seriesIndex });
    }
    if ("image" === p2) {
      var k2 = l2.fill.image.src, A2 = t3.patternID ? t3.patternID : "", C2 = "pattern".concat(s2.globals.cuid).concat(t3.seriesNumber + 1).concat(A2);
      -1 === this.patternIDs.indexOf(C2) && (this.clippedImgArea({ opacity: x2, image: Array.isArray(k2) ? t3.seriesNumber < k2.length ? k2[t3.seriesNumber] : k2[0] : k2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: C2 }), this.patternIDs.push(C2)), r2 = "url(#".concat(C2, ")");
    } else r2 = b2 ? o2 : "pattern" === p2 ? n2 : m2;
    return t3.solid && (r2 = m2), r2;
  } }, { key: "getFillType", value: function(t3) {
    var e2 = this.w;
    return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
    return t3.globals.comboCharts ? "line" === t3.config.series[this.seriesIndex].type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : "line" === e2.chart.type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), void 0 !== i2.fillColors && (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
  } }, { key: "handlePatternFill", value: function(t3) {
    var e2 = t3.fillConfig, i2 = t3.patternFill, a2 = t3.fillColor, s2 = t3.fillOpacity, r2 = t3.defaultColor, n2 = this.w.config.fill;
    e2 && (n2 = e2);
    var o2 = this.opts, l2 = new Mi(this.ctx), h2 = Array.isArray(n2.pattern.strokeWidth) ? n2.pattern.strokeWidth[this.seriesIndex] : n2.pattern.strokeWidth, c2 = a2;
    Array.isArray(n2.pattern.style) ? i2 = void 0 !== n2.pattern.style[o2.seriesNumber] ? l2.drawPattern(n2.pattern.style[o2.seriesNumber], n2.pattern.width, n2.pattern.height, c2, h2, s2) : r2 : i2 = l2.drawPattern(n2.pattern.style, n2.pattern.width, n2.pattern.height, c2, h2, s2);
    return i2;
  } }, { key: "handleGradientFill", value: function(t3) {
    var e2 = t3.type, i2 = t3.fillColor, a2 = t3.fillOpacity, s2 = t3.fillConfig, r2 = t3.colorStops, n2 = t3.i, o2 = this.w.config.fill;
    s2 && (o2 = u(u({}, o2), s2));
    var l2 = this.opts, h2 = new Mi(this.ctx), c2 = new v();
    e2 = e2 || o2.gradient.type;
    var d2, g2 = i2, p2 = void 0 === o2.gradient.opacityFrom ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[n2] : o2.gradient.opacityFrom;
    g2.indexOf("rgba") > -1 && (p2 = v.getOpacityFromRGBA(g2));
    var f2 = void 0 === o2.gradient.opacityTo ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[n2] : o2.gradient.opacityTo;
    if (void 0 === o2.gradient.gradientToColors || 0 === o2.gradient.gradientToColors.length) d2 = "dark" === o2.gradient.shade ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? v.rgb2hex(i2) : i2) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? v.rgb2hex(i2) : i2);
    else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
      var x2 = o2.gradient.gradientToColors[l2.seriesNumber];
      d2 = x2, x2.indexOf("rgba") > -1 && (f2 = v.getOpacityFromRGBA(x2));
    } else d2 = i2;
    if (o2.gradient.gradientFrom && (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo && (d2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
      var b2 = g2;
      g2 = d2, d2 = b2;
    }
    return g2.indexOf("rgb") > -1 && (g2 = v.rgb2hex(g2)), d2.indexOf("rgb") > -1 && (d2 = v.rgb2hex(d2)), h2.drawGradient(e2, g2, d2, p2, f2, l2.size, o2.gradient.stops, r2, n2);
  } }]), t2;
})(), Vi = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setGlobalMarkerSize", value: function() {
    var t3 = this.w;
    if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
      if (t3.globals.markers.size.length < t3.globals.series.length + 1) for (var e2 = 0; e2 <= t3.globals.series.length; e2++) void 0 === t3.globals.markers.size[e2] && t3.globals.markers.size.push(t3.globals.markers.size[0]);
    } else t3.globals.markers.size = t3.config.series.map((function(e3) {
      return t3.config.markers.size;
    }));
  } }, { key: "plotChartMarkers", value: function(t3) {
    var e2 = t3.pointsPos, i2 = t3.seriesIndex, a2 = t3.j, s2 = t3.pSize, r2 = t3.alwaysDrawMarker, n2 = void 0 !== r2 && r2, o2 = t3.isVirtualPoint, l2 = void 0 !== o2 && o2, h2 = this.w, c2 = i2, d2 = e2, u2 = null, g2 = new Mi(this.ctx), p2 = h2.config.markers.discrete && h2.config.markers.discrete.length;
    if (Array.isArray(d2.x)) for (var f2 = 0; f2 < d2.x.length; f2++) {
      var x2 = void 0, b2 = a2, m2 = !v.isNumber(d2.y[f2]);
      0 === h2.globals.markers.largestSize && h2.globals.hasNullValues && null !== h2.globals.series[c2][a2 + 1] && !l2 && (m2 = true), 1 === a2 && 0 === f2 && (b2 = 0), 1 === a2 && 1 === f2 && (b2 = 1);
      var y2 = "apexcharts-marker";
      if ("line" !== h2.config.chart.type && "area" !== h2.config.chart.type || h2.globals.comboCharts || h2.config.tooltip.intersect || (y2 += " no-pointer-events"), (Array.isArray(h2.config.markers.size) ? h2.globals.markers.size[i2] > 0 : h2.config.markers.size > 0) || n2 || p2) {
        m2 || (y2 += " w".concat(v.randomId()));
        var w2 = this.getMarkerConfig({ cssClass: y2, seriesIndex: i2, dataPointIndex: b2 });
        if (h2.config.series[c2].data[b2] && (h2.config.series[c2].data[b2].fillColor && (w2.pointFillColor = h2.config.series[c2].data[b2].fillColor), h2.config.series[c2].data[b2].strokeColor && (w2.pointStrokeColor = h2.config.series[c2].data[b2].strokeColor)), void 0 !== s2 && (w2.pSize = s2), (d2.x[f2] < -h2.globals.markers.largestSize || d2.x[f2] > h2.globals.gridWidth + h2.globals.markers.largestSize || d2.y[f2] < -h2.globals.markers.largestSize || d2.y[f2] > h2.globals.gridHeight + h2.globals.markers.largestSize) && (w2.pSize = 0), !m2) (h2.globals.markers.size[i2] > 0 || n2 || p2) && !u2 && (u2 = g2.group({ class: n2 || p2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h2.globals.cuid, ")")), (x2 = g2.drawMarker(d2.x[f2], d2.y[f2], w2)).attr("rel", b2), x2.attr("j", b2), x2.attr("index", i2), x2.node.setAttribute("default-marker-size", w2.pSize), new Li(this.ctx).setSelectionFilter(x2, i2, b2), this.addEvents(x2), u2 && u2.add(x2);
      } else void 0 === h2.globals.pointsArray[i2] && (h2.globals.pointsArray[i2] = []), h2.globals.pointsArray[i2].push([d2.x[f2], d2.y[f2]]);
    }
    return u2;
  } }, { key: "getMarkerConfig", value: function(t3) {
    var e2 = t3.cssClass, i2 = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = void 0 === a2 ? null : a2, r2 = t3.radius, n2 = void 0 === r2 ? null : r2, o2 = t3.size, l2 = void 0 === o2 ? null : o2, h2 = t3.strokeWidth, c2 = void 0 === h2 ? null : h2, d2 = this.w, u2 = this.getMarkerStyle(i2), g2 = null === l2 ? d2.globals.markers.size[i2] : l2, p2 = d2.config.markers;
    return null !== s2 && p2.discrete.length && p2.discrete.map((function(t4) {
      t4.seriesIndex === i2 && t4.dataPointIndex === s2 && (u2.pointStrokeColor = t4.strokeColor, u2.pointFillColor = t4.fillColor, g2 = t4.size, u2.pointShape = t4.shape);
    })), { pSize: null === n2 ? g2 : n2, pRadius: null !== n2 ? n2 : p2.radius, pointStrokeWidth: null !== c2 ? c2 : Array.isArray(p2.strokeWidth) ? p2.strokeWidth[i2] : p2.strokeWidth, pointStrokeColor: u2.pointStrokeColor, pointFillColor: u2.pointFillColor, shape: u2.pointShape || (Array.isArray(p2.shape) ? p2.shape[i2] : p2.shape), class: e2, pointStrokeOpacity: Array.isArray(p2.strokeOpacity) ? p2.strokeOpacity[i2] : p2.strokeOpacity, pointStrokeDashArray: Array.isArray(p2.strokeDashArray) ? p2.strokeDashArray[i2] : p2.strokeDashArray, pointFillOpacity: Array.isArray(p2.fillOpacity) ? p2.fillOpacity[i2] : p2.fillOpacity, seriesIndex: i2 };
  } }, { key: "addEvents", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
  } }, { key: "getMarkerStyle", value: function(t3) {
    var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
  } }]), t2;
})(), Ui = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = i2.realIndex, n2 = i2.pointsPos, o2 = i2.zRatio, l2 = i2.elParent, h2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
    if (h2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(n2.x)) for (var c2 = 0; c2 < n2.x.length; c2++) {
      var d2 = e2 + 1, u2 = true;
      0 === e2 && 0 === c2 && (d2 = 0), 0 === e2 && 1 === c2 && (d2 = 1);
      var g2 = a2.globals.markers.size[r2];
      if (o2 !== 1 / 0) {
        var p2 = a2.config.plotOptions.bubble;
        g2 = a2.globals.seriesZ[r2][d2], p2.zScaling && (g2 /= o2), p2.minBubbleRadius && g2 < p2.minBubbleRadius && (g2 = p2.minBubbleRadius), p2.maxBubbleRadius && g2 > p2.maxBubbleRadius && (g2 = p2.maxBubbleRadius);
      }
      var f2 = n2.x[c2], x2 = n2.y[c2];
      if (g2 = g2 || 0, null !== x2 && void 0 !== a2.globals.series[r2][d2] || (u2 = false), u2) {
        var b2 = this.drawPoint(f2, x2, g2, r2, d2, e2);
        h2.add(b2);
      }
      l2.add(h2);
    }
  } }, { key: "drawPoint", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this.w, o2 = a2, l2 = new y(this.ctx), h2 = new Li(this.ctx), c2 = new ji(this.ctx), d2 = new Vi(this.ctx), u2 = new Mi(this.ctx), g2 = d2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: o2, dataPointIndex: s2, radius: "bubble" === n2.config.chart.type || n2.globals.comboCharts && n2.config.series[a2] && "bubble" === n2.config.series[a2].type ? i2 : null }), p2 = c2.fillPath({ seriesNumber: a2, dataPointIndex: s2, color: g2.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[a2][r2] }), f2 = u2.drawMarker(t3, e2, g2);
    if (n2.config.series[o2].data[s2] && n2.config.series[o2].data[s2].fillColor && (p2 = n2.config.series[o2].data[s2].fillColor), f2.attr({ fill: p2 }), n2.config.chart.dropShadow.enabled) {
      var x2 = n2.config.chart.dropShadow;
      h2.dropShadow(f2, x2, a2);
    }
    if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized) n2.globals.animationEnded = true;
    else {
      var b2 = n2.config.chart.animations.speed;
      l2.animateMarker(f2, b2, n2.globals.easing, (function() {
        window.setTimeout((function() {
          l2.animationCompleted(f2);
        }), 100);
      }));
    }
    return f2.attr({ rel: s2, j: s2, index: a2, "default-marker-size": g2.pSize }), h2.setSelectionFilter(f2, a2, s2), d2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
  } }, { key: "centerTextInBubble", value: function(t3) {
    var e2 = this.w;
    return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), t2;
})(), qi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = this.w, l2 = false, h2 = new Mi(this.ctx).getTextRects(i2, n2), c2 = h2.width, d2 = h2.height;
    e2 < 0 && (e2 = 0), e2 > o2.globals.gridHeight + d2 && (e2 = o2.globals.gridHeight + d2 / 2), void 0 === o2.globals.dataLabelsRects[a2] && (o2.globals.dataLabelsRects[a2] = []), o2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
    var u2 = o2.globals.dataLabelsRects[a2].length - 2, g2 = void 0 !== o2.globals.lastDrawnDataLabelsIndexes[a2] ? o2.globals.lastDrawnDataLabelsIndexes[a2][o2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
    if (void 0 !== o2.globals.dataLabelsRects[a2][u2]) {
      var p2 = o2.globals.dataLabelsRects[a2][g2];
      (t3 > p2.x + p2.width || e2 > p2.y + p2.height || e2 + d2 < p2.y || t3 + c2 < p2.x) && (l2 = true);
    }
    return (0 === s2 || r2) && (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
  } }, { key: "drawDataLabel", value: function(t3) {
    var e2 = this, i2 = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, n2 = t3.isRangeStart, o2 = t3.strokeWidth, l2 = void 0 === o2 ? 2 : o2, h2 = this.w, c2 = new Mi(this.ctx), d2 = h2.config.dataLabels, u2 = 0, g2 = 0, p2 = r2, f2 = null;
    if (-1 !== h2.globals.collapsedSeriesIndices.indexOf(s2) || !d2.enabled || !Array.isArray(a2.x)) return f2;
    f2 = c2.group({ class: "apexcharts-data-labels" });
    for (var x2 = 0; x2 < a2.x.length; x2++) if (u2 = a2.x[x2] + d2.offsetX, g2 = a2.y[x2] + d2.offsetY + l2, !isNaN(u2)) {
      1 === r2 && 0 === x2 && (p2 = 0), 1 === r2 && 1 === x2 && (p2 = 1);
      var b2 = h2.globals.series[s2][p2];
      "rangeArea" === i2 && (b2 = n2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
      var m2 = "", v2 = function(t4) {
        return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
      };
      if ("bubble" === h2.config.chart.type) m2 = v2(b2 = h2.globals.seriesZ[s2][p2]), g2 = a2.y[x2], g2 = new Ui(this.ctx).centerTextInBubble(g2, s2, p2).y;
      else void 0 !== b2 && (m2 = v2(b2));
      var y2 = h2.config.dataLabels.textAnchor;
      h2.globals.isSlopeChart && (y2 = 0 === p2 ? "end" : p2 === h2.config.series[s2].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: u2, y: g2, text: m2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels, textAnchor: y2 });
    }
    return f2;
  } }, { key: "plotDataLabelsText", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, u2 = t3.color, g2 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection, f2 = t3.className, x2 = null;
    if (Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0) return x2;
    var b2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
    p2 && (b2 = this.dataLabelsCorrection(a2, s2, o2, r2, n2, g2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = b2.x, s2 = b2.y), b2.textRects && (a2 < -20 - b2.textRects.width || a2 > e2.globals.gridWidth + b2.textRects.width + 30) && (o2 = "");
    var m2 = e2.globals.dataLabels.style.colors[r2];
    (("bar" === e2.config.chart.type || "rangeBar" === e2.config.chart.type) && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (m2 = e2.globals.dataLabels.style.colors[n2]), "function" == typeof m2 && (m2 = m2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: n2, w: e2 })), u2 && (m2 = u2);
    var v2 = d2.offsetX, y2 = d2.offsetY;
    if ("bar" !== e2.config.chart.type && "rangeBar" !== e2.config.chart.type || (v2 = 0, y2 = 0), e2.globals.isSlopeChart && (0 !== n2 && (v2 = -2 * d2.offsetX + 5), 0 !== n2 && n2 !== e2.config.series[r2].data.length - 1 && (v2 = 0)), b2.drawnextLabel) {
      if ((x2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + v2, y: s2 + y2, foreColor: m2, textAnchor: l2 || d2.textAnchor, text: o2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" })).attr({ class: f2 || "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
        var w2 = d2.dropShadow;
        new Li(this.ctx).dropShadow(x2, w2);
      }
      c2.add(x2), void 0 === e2.globals.lastDrawnDataLabelsIndexes[r2] && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(n2);
    }
    return x2;
  } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, n2 = e2.width, o2 = e2.height, l2 = new Mi(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, n2 + 2 * s2, o2 + r2, a2.borderRadius, "transparent" !== i2.config.chart.background && i2.config.chart.background ? i2.config.chart.background : "#fff", a2.opacity, a2.borderWidth, a2.borderColor);
    a2.dropShadow.enabled && new Li(this.ctx).dropShadow(l2, a2.dropShadow);
    return l2;
  } }, { key: "dataLabelsBackground", value: function() {
    var t3 = this.w;
    if ("bubble" !== t3.config.chart.type) for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0; i2 < e2.length; i2++) {
      var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
      if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
        a2.parentNode.insertBefore(r2.node, a2);
        var n2 = t3.config.dataLabels.background.backgroundColor || a2.getAttribute("fill");
        t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: n2 }) : r2.attr({ fill: n2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
      }
    }
  } }, { key: "bringForward", value: function() {
    for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < e2.length; a2++) i2 && i2.insertBefore(e2[a2], i2.nextSibling);
  } }]), t2;
})(), Zi = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return s(t2, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(t3) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(v.escapeString(t3), "']"));
  } }, { key: "isSeriesHidden", value: function(t3) {
    var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute("data:realIndex"), 10);
    return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
  } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
    var i2 = this.w;
    function a2(i3) {
      for (var a3 = 0; a3 < i3.length; a3++) i3[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
    }
    a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
  } }, { key: "showSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
  } }, { key: "hideSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w, s2 = v.clone(a2.globals.initialSeries);
    a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(t3) {
    for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++) e2.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t3[i2].data = []);
    return t3;
  } }, { key: "highlightSeries", value: function(t3) {
    var e2 = this.w, i2 = this.getSeriesByName(t3), a2 = parseInt(null == i2 ? void 0 : i2.getAttribute("data:realIndex"), 10), s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), r2 = null, n2 = null, o2 = null;
    if (e2.globals.axisCharts || "radialBar" === e2.config.chart.type) if (e2.globals.axisCharts) {
      r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a2, "']")), n2 = e2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a2, "']"));
      var l2 = e2.globals.seriesYAxisReverseMap[a2];
      o2 = e2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l2, "']"));
    } else r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "']"));
    else r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "'] path"));
    for (var h2 = 0; h2 < s2.length; h2++) s2[h2].classList.add(this.legendInactiveClass);
    if (r2) e2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== n2 && n2.classList.remove(this.legendInactiveClass), null !== o2 && o2.classList.remove(this.legendInactiveClass);
    else for (var c2 = 0; c2 < s2.length; c2++) s2[c2].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
    var i2 = this.w;
    e2 || (e2 = t3.target);
    var a2 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if ("mousemove" === t3.type) {
      var s2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i2.globals.seriesNames[s2]);
    } else if ("mouseout" === t3.type) for (var r2 = 0; r2 < a2.length; r2++) a2[r2].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
    var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
      for (var e3 = 0; e3 < s2.length; e3++) s2[e3].classList[t4](i2.legendInactiveClass);
    };
    if ("mousemove" === t3.type) {
      var n2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      r2("add");
      var o2 = a2.config.plotOptions.heatmap.colorScale.ranges;
      !(function(t4, e3) {
        for (var a3 = 0; a3 < s2.length; a3++) {
          var r3 = Number(s2[a3].getAttribute("val"));
          r3 >= t4.from && (r3 < t4.to || t4.to === e3 && r3 === e3) && s2[a3].classList.remove(i2.legendInactiveClass);
        }
      })(o2[n2], o2.reduce((function(t4, e3) {
        return Math.max(t4, e3.to);
      }), 0));
    } else "mouseout" === t3.type && r2("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i2 = this.w, a2 = 0;
    if (i2.config.series.length > 1) {
      for (var s2 = i2.config.series.map((function(t4, a3) {
        return t4.data && t4.data.length > 0 && -1 === i2.globals.collapsedSeriesIndices.indexOf(a3) && (!i2.globals.comboCharts || 0 === e2.length || e2.length && e2.indexOf(i2.config.series[a3].type) > -1) ? a3 : -1;
      })), r2 = "asc" === t3 ? 0 : s2.length - 1; "asc" === t3 ? r2 < s2.length : r2 >= 0; "asc" === t3 ? r2++ : r2--) if (-1 !== s2[r2]) {
        a2 = s2[r2];
        break;
      }
    }
    return a2;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map((function(t3, e2) {
      return "bar" === t3.type || "column" === t3.type ? e2 : -1;
    })).filter((function(t3) {
      return -1 !== t3;
    })) : this.w.config.series.map((function(t3, e2) {
      return e2;
    }));
  } }, { key: "getPreviousPaths", value: function() {
    var t3 = this.w;
    function e2(e3, i3, a3) {
      for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute("data:realIndex") }, n2 = 0; n2 < s3.length; n2++) if (s3[n2].hasAttribute("pathTo")) {
        var o2 = s3[n2].getAttribute("pathTo");
        r2.paths.push({ d: o2 });
      }
      t3.globals.previousPaths.push(r2);
    }
    t3.globals.previousPaths = [];
    ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach((function(i3) {
      for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0; r2 < s3.length; r2++) e2(s3, r2, i3);
    }));
    var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
    if (i2.length > 0) for (var a2 = function(e3) {
      for (var i3 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
        var e4 = function(e5) {
          return i3[t4].getAttribute(e5);
        }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
        a3.push({ rect: s4, color: i3[t4].getAttribute("color") });
      }, r2 = 0; r2 < i3.length; r2++) s3(r2);
      t3.globals.previousPaths.push(a3);
    }, s2 = 0; s2 < i2.length; s2++) a2(s2);
    t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var t3 = this.w;
    t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
  } }, { key: "handleNoData", value: function() {
    var t3 = this.w, e2 = t3.config.noData, i2 = new Mi(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
    if (t3.globals.noData = true, t3.globals.animationEnded = true, "left" === e2.align ? (a2 = 10, r2 = "start") : "right" === e2.align && (a2 = t3.globals.svgWidth - 10, r2 = "end"), "top" === e2.verticalAlign ? s2 = 50 : "bottom" === e2.verticalAlign && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, void 0 !== e2.text && "" !== e2.text) {
      var n2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      t3.globals.dom.Paper.add(n2);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
    for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++) if (0 === t3[i2].length) for (var a2 = 0; a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++) t3[i2].push(0);
    return t3;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0; a2 < i2.length - 1; a2++) if (i2[a2][0] !== i2[a2 + 1][0]) {
      t3 = false;
      break;
    }
    return e2.globals.allSeriesHasEqualX = t3, t3;
  } }, { key: "filteredSeriesX", value: function() {
    var t3 = this.w.globals.seriesX.map((function(t4) {
      return t4.length > 0 ? t4 : [];
    }));
    return t3;
  } }]), t2;
})(), $i = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && null !== t3[this.activeSeriesIndex].data[0] && void 0 !== t3[this.activeSeriesIndex].data[0].x && null !== t3[this.activeSeriesIndex].data[0]) return true;
  } }, { key: "isFormat2DArray", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && void 0 !== t3[this.activeSeriesIndex].data[0] && null !== t3[this.activeSeriesIndex].data[0] && t3[this.activeSeriesIndex].data[0].constructor === Array) return true;
  } }, { key: "handleFormat2DArray", value: function(t3, e2) {
    for (var i2 = this.w.config, a2 = this.w.globals, s2 = "boxPlot" === i2.chart.type || "boxPlot" === i2.series[e2].type, r2 = 0; r2 < t3[e2].data.length; r2++) if (void 0 !== t3[e2].data[r2][1] && (Array.isArray(t3[e2].data[r2][1]) && 4 === t3[e2].data[r2][1].length && !s2 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), "datetime" === i2.xaxis.type) {
      var n2 = new Date(t3[e2].data[r2][0]);
      n2 = new Date(n2).getTime(), this.twoDSeriesX.push(n2);
    } else this.twoDSeriesX.push(t3[e2].data[r2][0]);
    for (var o2 = 0; o2 < t3[e2].data.length; o2++) void 0 !== t3[e2].data[o2][2] && (this.threeDSeries.push(t3[e2].data[o2][2]), a2.isDataXYZ = true);
  } }, { key: "handleFormatXY", value: function(t3, e2) {
    var i2 = this.w.config, a2 = this.w.globals, s2 = new zi(this.ctx), r2 = e2;
    a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
    for (var n2 = 0; n2 < t3[e2].data.length; n2++) void 0 !== t3[e2].data[n2].y && (Array.isArray(t3[e2].data[n2].y) ? this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y[t3[e2].data[n2].y.length - 1])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y))), void 0 !== t3[e2].data[n2].goals && Array.isArray(t3[e2].data[n2].goals) ? (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[n2].goals)) : (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
    for (var o2 = 0; o2 < t3[r2].data.length; o2++) {
      var l2 = "string" == typeof t3[r2].data[o2].x, h2 = Array.isArray(t3[r2].data[o2].x), c2 = !h2 && !!s2.isValidDate(t3[r2].data[o2].x);
      if (l2 || c2) if (l2 || i2.xaxis.convertedCatToNumeric) {
        var d2 = a2.isBarHorizontal && a2.isRangeData;
        "datetime" !== i2.xaxis.type || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x), isNaN(t3[r2].data[o2].x) || "category" === this.w.config.xaxis.type || "string" == typeof t3[r2].data[o2].x || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x));
      } else "datetime" === i2.xaxis.type ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[o2].x)));
      else h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[o2].x));
    }
    if (t3[e2].data[0] && void 0 !== t3[e2].data[0].z) {
      for (var u2 = 0; u2 < t3[e2].data.length; u2++) this.threeDSeries.push(t3[e2].data[u2].z);
      a2.isDataXYZ = true;
    }
  } }, { key: "handleRangeData", value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i2.seriesRangeStart[e2] = void 0 === a2.start ? [] : a2.start, i2.seriesRangeEnd[e2] = void 0 === a2.end ? [] : a2.end, i2.seriesRange[e2] = a2.rangeUniques, i2.seriesRange.forEach((function(t4, e3) {
      t4 && t4.forEach((function(t5, e4) {
        t5.y.forEach((function(e5, i3) {
          for (var a3 = 0; a3 < t5.y.length; a3++) if (i3 !== a3) {
            var s2 = e5.y1, r2 = e5.y2, n2 = t5.y[a3].y1;
            s2 <= t5.y[a3].y2 && n2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
          }
        }));
      }));
    })), a2;
  } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
    var i2 = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
  } }, { key: "handleRangeDataFormat", value: function(t3, e2, i2) {
    var a2 = [], s2 = [], r2 = e2[i2].data.filter((function(t4, e3, i3) {
      return e3 === i3.findIndex((function(e4) {
        return e4.x === t4.x;
      }));
    })).map((function(t4, e3) {
      return { x: t4.x, overlaps: [], y: [] };
    }));
    if ("array" === t3) for (var n2 = 0; n2 < e2[i2].data.length; n2++) Array.isArray(e2[i2].data[n2]) ? (a2.push(e2[i2].data[n2][1][0]), s2.push(e2[i2].data[n2][1][1])) : (a2.push(e2[i2].data[n2]), s2.push(e2[i2].data[n2]));
    else if ("xy" === t3) for (var o2 = function(t4) {
      var n3 = Array.isArray(e2[i2].data[t4].y), o3 = v.randomId(), l3 = e2[i2].data[t4].x, h2 = { y1: n3 ? e2[i2].data[t4].y[0] : e2[i2].data[t4].y, y2: n3 ? e2[i2].data[t4].y[1] : e2[i2].data[t4].y, rangeName: o3 };
      e2[i2].data[t4].rangeName = o3;
      var c2 = r2.findIndex((function(t5) {
        return t5.x === l3;
      }));
      r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
    }, l2 = 0; l2 < e2[i2].data.length; l2++) o2(l2);
    return { start: a2, end: s2, rangeUniques: r2 };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = "boxPlot" === a2.config.chart.type || "boxPlot" === a2.config.series[i2].type, r2 = [], n2 = [], o2 = [], l2 = [], h2 = [];
    if ("array" === t3) if (s2 && 6 === e2[i2].data[0].length || !s2 && 5 === e2[i2].data[0].length) for (var c2 = 0; c2 < e2[i2].data.length; c2++) r2.push(e2[i2].data[c2][1]), n2.push(e2[i2].data[c2][2]), s2 ? (o2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h2.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h2.push(e2[i2].data[c2][4]));
    else for (var d2 = 0; d2 < e2[i2].data.length; d2++) Array.isArray(e2[i2].data[d2][1]) && (r2.push(e2[i2].data[d2][1][0]), n2.push(e2[i2].data[d2][1][1]), s2 ? (o2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h2.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h2.push(e2[i2].data[d2][1][3])));
    else if ("xy" === t3) for (var u2 = 0; u2 < e2[i2].data.length; u2++) Array.isArray(e2[i2].data[u2].y) && (r2.push(e2[i2].data[u2].y[0]), n2.push(e2[i2].data[u2].y[1]), s2 ? (o2.push(e2[i2].data[u2].y[2]), l2.push(e2[i2].data[u2].y[3]), h2.push(e2[i2].data[u2].y[4])) : (l2.push(e2[i2].data[u2].y[2]), h2.push(e2[i2].data[u2].y[3])));
    return { o: r2, h: n2, m: o2, l: l2, c: h2 };
  } }, { key: "parseDataAxisCharts", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a2 = this.w.config, s2 = this.w.globals, r2 = new zi(i2), n2 = a2.labels.length > 0 ? a2.labels.slice() : a2.xaxis.categories.slice();
    s2.isRangeBar = "rangeBar" === a2.chart.type && s2.isBarHorizontal, s2.hasXaxisGroups = "category" === a2.xaxis.type && a2.xaxis.group.groups.length > 0, s2.hasXaxisGroups && (s2.groups = a2.xaxis.group.groups), t3.forEach((function(t4, e3) {
      void 0 !== t4.name ? s2.seriesNames.push(t4.name) : s2.seriesNames.push("series-" + parseInt(e3 + 1, 10));
    })), this.coreUtils.setSeriesYAxisMappings();
    var o2 = [], l2 = f(new Set(a2.series.map((function(t4) {
      return t4.group;
    }))));
    a2.series.forEach((function(t4, e3) {
      var i3 = l2.indexOf(t4.group);
      o2[i3] || (o2[i3] = []), o2[i3].push(s2.seriesNames[e3]);
    })), s2.seriesGroups = o2;
    for (var h2 = function() {
      for (var t4 = 0; t4 < n2.length; t4++) if ("string" == typeof n2[t4]) {
        if (!r2.isValidDate(n2[t4])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
        e2.twoDSeriesX.push(r2.parseDate(n2[t4]));
      } else e2.twoDSeriesX.push(n2[t4]);
    }, c2 = 0; c2 < t3.length; c2++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t3[c2].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if ("rangeBar" !== a2.chart.type && "rangeArea" !== a2.chart.type && "rangeBar" !== t3[c2].type && "rangeArea" !== t3[c2].type || (s2.isRangeData = true, this.handleRangeData(t3, c2)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t3, c2) : this.isFormatXY() && this.handleFormatXY(t3, c2), "candlestick" !== a2.chart.type && "candlestick" !== t3[c2].type && "boxPlot" !== a2.chart.type && "boxPlot" !== t3[c2].type || this.handleCandleStickBoxData(t3, c2), s2.series.push(this.twoDSeries), s2.labels.push(this.twoDSeriesX), s2.seriesX.push(this.twoDSeriesX), s2.seriesGoals = this.seriesGoals, c2 !== this.activeSeriesIndex || this.fallbackToCategory || (s2.isXNumeric = true);
      else {
        "datetime" === a2.xaxis.type ? (s2.isXNumeric = true, h2(), s2.seriesX.push(this.twoDSeriesX)) : "numeric" === a2.xaxis.type && (s2.isXNumeric = true, n2.length > 0 && (this.twoDSeriesX = n2, s2.seriesX.push(this.twoDSeriesX))), s2.labels.push(this.twoDSeriesX);
        var d2 = t3[c2].data.map((function(t4) {
          return v.parseNumber(t4);
        }));
        s2.series.push(d2);
      }
      s2.seriesZ.push(this.threeDSeries), void 0 !== t3[c2].color ? s2.seriesColors.push(t3[c2].color) : s2.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config;
    e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
    for (var a2 = 0; a2 < e2.series.length; a2++) void 0 === e2.seriesNames[a2] && e2.seriesNames.push("series-" + (a2 + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(t3) {
    var e2 = this.w.config, i2 = this.w.globals;
    if (e2.xaxis.categories.length > 0) i2.labels = e2.xaxis.categories;
    else if (e2.labels.length > 0) i2.labels = e2.labels.slice();
    else if (this.fallbackToCategory) {
      if (i2.labels = i2.labels[0], i2.seriesRange.length && (i2.seriesRange.map((function(t4) {
        t4.forEach((function(t5) {
          i2.labels.indexOf(t5.x) < 0 && t5.x && i2.labels.push(t5.x);
        }));
      })), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric) new Ni(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
    } else this._generateExternalLabels(t3);
  } }, { key: "_generateExternalLabels", value: function(t3) {
    var e2 = this.w.globals, i2 = this.w.config, a2 = [];
    if (e2.axisCharts) {
      if (e2.series.length > 0) if (this.isFormatXY()) for (var s2 = i2.series.map((function(t4, e3) {
        return t4.data.filter((function(t5, e4, i3) {
          return i3.findIndex((function(e5) {
            return e5.x === t5.x;
          })) === e4;
        }));
      })), r2 = s2.reduce((function(t4, e3, i3, a3) {
        return a3[t4].length > e3.length ? t4 : i3;
      }), 0), n2 = 0; n2 < s2[r2].length; n2++) a2.push(n2 + 1);
      else for (var o2 = 0; o2 < e2.series[e2.maxValsInArrayIndex].length; o2++) a2.push(o2 + 1);
      e2.seriesX = [];
      for (var l2 = 0; l2 < t3.length; l2++) e2.seriesX.push(a2);
      this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
    }
    if (0 === a2.length) {
      a2 = e2.axisCharts ? [] : e2.series.map((function(t4, e3) {
        return e3 + 1;
      }));
      for (var h2 = 0; h2 < t3.length; h2++) e2.seriesX.push(a2);
    }
    e2.labels = a2, i2.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map((function(t4) {
      return i2.xaxis.labels.formatter(t4);
    }))), e2.noLabelsProvided = true;
  } }, { key: "parseData", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i2.chart.stacked) {
      var s2 = new Zi(this.ctx);
      a2.series = s2.setNullSeriesToZeroValues(a2.series);
    }
    this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && ("numeric" !== i2.xaxis.type || 0 !== i2.labels.length || 0 !== i2.xaxis.categories.length) || this.handleExternalLabelsData(t3);
    for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), n2 = 0; n2 < r2.length; n2++) if (Array.isArray(r2[n2])) {
      a2.isMultiLineX = true;
      break;
    }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var t3 = this.w, e2 = [];
    t3.globals.seriesYAxisMap.forEach((function(i2, a2) {
      var s2 = 0;
      i2.forEach((function(e3) {
        -1 !== t3.globals.collapsedSeriesIndices.indexOf(e3) && s2++;
      })), s2 > 0 && s2 == i2.length && e2.push(a2);
    })), t3.globals.ignoreYAxisIndexes = e2.map((function(t4) {
      return t4;
    }));
  } }]), t2;
})(), Ji = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "svgStringToNode", value: function(t3) {
    return new DOMParser().parseFromString(t3, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(t3, e2) {
    var i2 = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
    t3.setAttributeNS(null, "width", i2 * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a2);
  } }, { key: "getSvgString", value: function(t3) {
    var e2 = this;
    return new Promise((function(i2) {
      var a2 = e2.w, s2 = t3 || a2.config.chart.toolbar.export.scale || a2.config.chart.toolbar.export.width / a2.globals.svgWidth;
      s2 || (s2 = 1);
      var r2 = a2.globals.svgWidth * s2, n2 = a2.globals.svgHeight * s2, o2 = a2.globals.dom.elWrap.cloneNode(true);
      o2.style.width = r2 + "px", o2.style.height = n2 + "px";
      var l2 = new XMLSerializer().serializeToString(o2), h2 = '\n        <svg xmlns="http://www.w3.org/2000/svg"\n          version="1.1"\n          xmlns:xlink="http://www.w3.org/1999/xlink"\n          class="apexcharts-svg"\n          xmlns:data="ApexChartsNS"\n          transform="translate(0, 0)"\n          width="'.concat(a2.globals.svgWidth, 'px" height="').concat(a2.globals.svgHeight, 'px">\n          <foreignObject width="100%" height="100%">\n            <div xmlns="http://www.w3.org/1999/xhtml" style="width:').concat(r2, "px; height:").concat(n2, 'px;">\n            <style type="text/css">\n              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n                display: none;\n              }\n            </style>\n              ').concat(l2, "\n            </div>\n          </foreignObject>\n        </svg>\n      "), c2 = e2.svgStringToNode(h2);
      1 !== s2 && e2.scaleSvgNode(c2, s2), e2.convertImagesToBase64(c2).then((function() {
        h2 = new XMLSerializer().serializeToString(c2), i2(h2.replace(/&nbsp;/g, "&#160;"));
      }));
    }));
  } }, { key: "convertImagesToBase64", value: function(t3) {
    var e2 = this, i2 = t3.getElementsByTagName("image"), a2 = Array.from(i2).map((function(t4) {
      var i3 = t4.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return i3 && !i3.startsWith("data:") ? e2.getBase64FromUrl(i3).then((function(e3) {
        t4.setAttributeNS("http://www.w3.org/1999/xlink", "href", e3);
      })).catch((function(t5) {
        console.error("Error converting image to base64:", t5);
      })) : Promise.resolve();
    }));
    return Promise.all(a2);
  } }, { key: "getBase64FromUrl", value: function(t3) {
    return new Promise((function(e2, i2) {
      var a2 = new Image();
      a2.crossOrigin = "Anonymous", a2.onload = function() {
        var t4 = document.createElement("canvas");
        t4.width = a2.width, t4.height = a2.height, t4.getContext("2d").drawImage(a2, 0, 0), e2(t4.toDataURL());
      }, a2.onerror = i2, a2.src = t3;
    }));
  } }, { key: "svgUrl", value: function() {
    var t3 = this;
    return new Promise((function(e2) {
      t3.getSvgString().then((function(t4) {
        var i2 = new Blob([t4], { type: "image/svg+xml;charset=utf-8" });
        e2(URL.createObjectURL(i2));
      }));
    }));
  } }, { key: "dataURI", value: function(t3) {
    var e2 = this;
    return new Promise((function(i2) {
      var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1, r2 = document.createElement("canvas");
      r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
      var n2 = "transparent" !== a2.config.chart.background && a2.config.chart.background ? a2.config.chart.background : "#fff", o2 = r2.getContext("2d");
      o2.fillStyle = n2, o2.fillRect(0, 0, r2.width * s2, r2.height * s2), e2.getSvgString(s2).then((function(t4) {
        var e3 = "data:image/svg+xml," + encodeURIComponent(t4), a3 = new Image();
        a3.crossOrigin = "anonymous", a3.onload = function() {
          if (o2.drawImage(a3, 0, 0), r2.msToBlob) {
            var t5 = r2.msToBlob();
            i2({ blob: t5 });
          } else {
            var e4 = r2.toDataURL("image/png");
            i2({ imgURI: e4 });
          }
        }, a3.src = e3;
      }));
    }));
  } }, { key: "exportToSVG", value: function() {
    var t3 = this;
    this.svgUrl().then((function(e2) {
      t3.triggerDownload(e2, t3.w.config.chart.toolbar.export.svg.filename, ".svg");
    }));
  } }, { key: "exportToPng", value: function() {
    var t3 = this, e2 = this.w.config.chart.toolbar.export.scale, i2 = this.w.config.chart.toolbar.export.width, a2 = e2 ? { scale: e2 } : i2 ? { width: i2 } : void 0;
    this.dataURI(a2).then((function(e3) {
      var i3 = e3.imgURI, a3 = e3.blob;
      a3 ? navigator.msSaveOrOpenBlob(a3, t3.w.globals.chartID + ".png") : t3.triggerDownload(i3, t3.w.config.chart.toolbar.export.png.filename, ".png");
    }));
  } }, { key: "exportToCSV", value: function(t3) {
    var e2 = this, i2 = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = void 0 === s2 ? "," : s2, n2 = t3.lineDelimiter, o2 = void 0 === n2 ? "\n" : n2, l2 = this.w;
    i2 || (i2 = l2.config.series);
    var h2 = [], c2 = [], d2 = "", u2 = l2.globals.series.map((function(t4, e3) {
      return -1 === l2.globals.collapsedSeriesIndices.indexOf(e3) ? t4 : [];
    })), g2 = function(t4) {
      return "function" == typeof l2.config.chart.toolbar.export.csv.categoryFormatter ? l2.config.chart.toolbar.export.csv.categoryFormatter(t4) : "datetime" === l2.config.xaxis.type && String(t4).length >= 10 ? new Date(t4).toDateString() : v.isNumber(t4) ? t4 : t4.split(r2).join("");
    }, p2 = function(t4) {
      return "function" == typeof l2.config.chart.toolbar.export.csv.valueFormatter ? l2.config.chart.toolbar.export.csv.valueFormatter(t4) : t4;
    }, x2 = Math.max.apply(Math, f(i2.map((function(t4) {
      return t4.data ? t4.data.length : 0;
    })))), b2 = new $i(this.ctx), m2 = new Ri(this.ctx), y2 = function(t4) {
      var i3 = "";
      if (l2.globals.axisCharts) {
        if ("category" === l2.config.xaxis.type || l2.config.xaxis.convertedCatToNumeric) if (l2.globals.isBarHorizontal) {
          var a3 = l2.globals.yLabelFormatters[0], s3 = new Zi(e2.ctx).getActiveConfigSeriesIndex();
          i3 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
        } else i3 = m2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
        "datetime" === l2.config.xaxis.type && (l2.config.xaxis.categories.length ? i3 = l2.config.xaxis.categories[t4] : l2.config.labels.length && (i3 = l2.config.labels[t4]));
      } else i3 = l2.config.labels[t4];
      return null === i3 ? "nullvalue" : (Array.isArray(i3) && (i3 = i3.join(" ")), v.isNumber(i3) ? i3 : i3.split(r2).join(""));
    }, w2 = function(t4, e3) {
      if (h2.length && 0 === e3 && c2.push(h2.join(r2)), t4.data) {
        t4.data = t4.data.length && t4.data || f(Array(x2)).map((function() {
          return "";
        }));
        for (var a3 = 0; a3 < t4.data.length; a3++) {
          h2 = [];
          var s3 = y2(a3);
          if ("nullvalue" !== s3) {
            if (s3 || (b2.isFormatXY() ? s3 = i2[e3].data[a3].x : b2.isFormat2DArray() && (s3 = i2[e3].data[a3] ? i2[e3].data[a3][0] : "")), 0 === e3) {
              h2.push(g2(s3));
              for (var n3 = 0; n3 < l2.globals.series.length; n3++) {
                var o3, d3 = b2.isFormatXY() ? null === (o3 = i2[n3].data[a3]) || void 0 === o3 ? void 0 : o3.y : u2[n3][a3];
                h2.push(p2(d3));
              }
            }
            ("candlestick" === l2.config.chart.type || t4.type && "candlestick" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), ("boxPlot" === l2.config.chart.type || t4.type && "boxPlot" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleM[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), "rangeBar" === l2.config.chart.type && (h2.pop(), h2.push(l2.globals.seriesRangeStart[e3][a3]), h2.push(l2.globals.seriesRangeEnd[e3][a3])), h2.length && c2.push(h2.join(r2));
          }
        }
      }
    };
    h2.push(l2.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l2.config.chart.type ? (h2.push("minimum"), h2.push("q1"), h2.push("median"), h2.push("q3"), h2.push("maximum")) : "candlestick" === l2.config.chart.type ? (h2.push("open"), h2.push("high"), h2.push("low"), h2.push("close")) : "rangeBar" === l2.config.chart.type ? (h2.push("minimum"), h2.push("maximum")) : i2.map((function(t4, e3) {
      var i3 = (t4.name ? t4.name : "series-".concat(e3)) + "";
      l2.globals.axisCharts && h2.push(i3.split(r2).join("") ? i3.split(r2).join("") : "series-".concat(e3));
    })), l2.globals.axisCharts || (h2.push(l2.config.chart.toolbar.export.csv.headerValue), c2.push(h2.join(r2))), l2.globals.allSeriesHasEqualX || !l2.globals.axisCharts || l2.config.xaxis.categories.length || l2.config.labels.length ? i2.map((function(t4, e3) {
      l2.globals.axisCharts ? w2(t4, e3) : ((h2 = []).push(g2(l2.globals.labels[e3])), h2.push(p2(u2[e3])), c2.push(h2.join(r2)));
    })) : (function() {
      var t4 = /* @__PURE__ */ new Set(), e3 = {};
      i2.forEach((function(a3, s3) {
        null == a3 || a3.data.forEach((function(a4) {
          var r3, n3;
          if (b2.isFormatXY()) r3 = a4.x, n3 = a4.y;
          else {
            if (!b2.isFormat2DArray()) return;
            r3 = a4[0], n3 = a4[1];
          }
          e3[r3] || (e3[r3] = Array(i2.length).fill("")), e3[r3][s3] = p2(n3), t4.add(r3);
        }));
      })), h2.length && c2.push(h2.join(r2)), Array.from(t4).sort().forEach((function(t5) {
        c2.push([g2(t5), e3[t5].join(r2)]);
      }));
    })(), d2 += c2.join(o2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + d2), a2 || l2.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(t3, e2, i2) {
    var a2 = document.createElement("a");
    a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
  } }]), t2;
})(), Qi = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.axesUtils = new Ri(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length > 0 && !s2.globals.isBarHorizontal && (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories && (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s2.config.xaxis.position ? this.offY = 0 : this.offY = s2.globals.gridHeight, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
  }
  return s(t2, [{ key: "drawXaxis", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
    i2.add(a2);
    for (var s2 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++) s2.push(this.xaxisLabels[r2]);
    if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, (function(t4, e3) {
      return e3;
    })), t3.globals.hasXaxisGroups) {
      var n2 = t3.globals.groups;
      s2 = [];
      for (var o2 = 0; o2 < n2.length; o2++) s2.push(n2[o2].title);
      var l2 = {};
      t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, (function(t4, e3) {
        return n2[t4].cols * e3;
      }), l2);
    }
    if (void 0 !== t3.config.xaxis.title.text) {
      var h2 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t3.config.xaxis.position ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
      h2.add(c2), i2.add(h2);
    }
    if (t3.config.xaxis.axisBorder.show) {
      var d2 = t3.globals.barPadForNumericAxis, u2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && t3.config.grid.show ? this.elgrid.elGridBorders.add(u2) : i2.add(u2);
    }
    return i2;
  } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, u2 = l2.xaxisFontSize || this.xaxisFontSize, g2 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, m2 = a2.length, v2 = "category" === d2.config.xaxis.type ? d2.globals.dataPoints : m2;
    if (0 === v2 && m2 > v2 && (v2 = m2), s2) {
      var y2 = Math.max(Number(d2.config.xaxis.tickAmount) || 1, v2 > 1 ? v2 - 1 : v2);
      n2 = d2.globals.gridWidth / Math.min(y2, m2 - 1), b2 = b2 + r2(0, n2) / 2 + d2.config.xaxis.labels.offsetX;
    } else n2 = d2.globals.gridWidth / v2, b2 = b2 + r2(0, n2) + d2.config.xaxis.labels.offsetX;
    for (var w2 = function(s3) {
      var l3 = b2 - r2(s3, n2) / 2 + d2.config.xaxis.labels.offsetX;
      0 === s3 && 1 === m2 && n2 / 2 === b2 && 1 === v2 && (l3 = d2.globals.gridWidth / 2);
      var y3 = o2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, u2, t3), w3 = 28;
      d2.globals.rotateXLabels && t3 && (w3 = 22), d2.config.xaxis.title.text && "top" === d2.config.xaxis.position && (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(u2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = void 0 !== d2.config.xaxis.tickAmount && "dataPoints" !== d2.config.xaxis.tickAmount && "datetime" !== d2.config.xaxis.type ? o2.axesUtils.checkLabelBasedOnTickamount(s3, y3, m2) : o2.axesUtils.checkForOverflowingLabels(s3, y3, m2, h2, c2);
      if (d2.config.xaxis.labels.show) {
        var k3 = e2.drawText({ x: y3.x, y: o2.offY + d2.config.xaxis.labels.offsetY + w3 - ("top" === d2.config.xaxis.position ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: u2, fontFamily: g2, foreColor: Array.isArray(p2) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
        if (i2.add(k3), k3.on("click", (function(t4) {
          if ("function" == typeof d2.config.chart.events.xAxisLabelClick) {
            var e3 = Object.assign({}, d2, { labelIndex: s3 });
            d2.config.chart.events.xAxisLabelClick(t4, o2.ctx, e3);
          }
        })), t3) {
          var A2 = document.createElementNS(d2.globals.SVGNS, "title");
          A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), "" !== y3.text && (h2.push(y3.text), c2.push(y3));
        }
      }
      s3 < m2 - 1 && (b2 += r2(s3 + 1, n2));
    }, k2 = 0; k2 <= m2 - 1; k2++) w2(k2);
  } }, { key: "drawXaxisInversed", value: function(t3) {
    var e2, i2, a2 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, o2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + n2 + ", 0)" });
    o2.add(l2);
    var h2 = [];
    if (s2.config.yaxis[t3].show) for (var c2 = 0; c2 < this.xaxisLabels.length; c2++) h2.push(this.xaxisLabels[c2]);
    e2 = s2.globals.gridHeight / h2.length, i2 = -e2 / 2.2;
    var d2 = s2.globals.yLabelFormatters[0], u2 = s2.config.yaxis[0].labels;
    if (u2.show) for (var g2 = function(n3) {
      var o3 = void 0 === h2[n3] ? "" : h2[n3];
      o3 = d2(o3, { seriesIndex: t3, dataPointIndex: n3, w: s2 });
      var c3 = a2.axesUtils.getYAxisForeColor(u2.style.colors, t3), g3 = 0;
      Array.isArray(o3) && (g3 = o3.length / 2 * parseInt(u2.style.fontSize, 10));
      var p3 = u2.offsetX - 15, f3 = "end";
      a2.yaxis.opposite && (f3 = "start"), "left" === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = "start") : "center" === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = "middle") : "right" === s2.config.yaxis[0].labels.align && (f3 = "end");
      var x3 = r2.drawText({ x: p3, y: i2 + e2 + u2.offsetY - g3, text: o3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[n3] : c3, fontSize: u2.style.fontSize, fontFamily: u2.style.fontFamily, fontWeight: u2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + u2.style.cssClass, maxWidth: u2.maxWidth });
      l2.add(x3), x3.on("click", (function(t4) {
        if ("function" == typeof s2.config.chart.events.xAxisLabelClick) {
          var e3 = Object.assign({}, s2, { labelIndex: n3 });
          s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
        }
      }));
      var b3 = document.createElementNS(s2.globals.SVGNS, "title");
      if (b3.textContent = Array.isArray(o3) ? o3.join(" ") : o3, x3.node.appendChild(b3), 0 !== s2.config.yaxis[t3].labels.rotate) {
        var m3 = r2.rotateAroundCenter(x3.node);
        x3.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(m3.y, ")"));
      }
      i2 += e2;
    }, p2 = 0; p2 <= h2.length - 1; p2++) g2(p2);
    if (void 0 !== s2.config.yaxis[0].title.text) {
      var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + n2 + ", 0)" }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
      f2.add(x2), o2.add(f2);
    }
    var b2 = 0;
    this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
    var m2 = s2.config.xaxis.axisBorder;
    if (m2.show) {
      var v2 = r2.drawLine(s2.globals.padHorizontal + m2.offsetX + b2, 1 + m2.offsetY, s2.globals.padHorizontal + m2.offsetX + b2, s2.globals.gridHeight + m2.offsetY, m2.color, 0);
      this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(v2) : o2.add(v2);
    }
    return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, o2), o2;
  } }, { key: "drawXaxisTicks", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = t3;
    if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
      var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
      if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, "top" === a2.config.xaxis.position && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
        var n2 = new Mi(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
        i2.add(n2), n2.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
    if (t3.globals.timescaleLabels.length > 0) for (var s2 = 0; s2 < i2; s2++) a2 = this.xaxisLabels[s2].position, e2.push(a2);
    else for (var r2 = i2, n2 = 0; n2 < r2; n2++) {
      var o2 = r2;
      t3.globals.isXNumeric && "bar" !== t3.config.chart.type && (o2 -= 1), a2 += t3.globals.gridWidth / o2, e2.push(a2);
    }
    return e2;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways) for (var n2 = 0; n2 < a2.length; n2++) {
      var o2 = e2.rotateAroundCenter(a2[n2]);
      o2.y = o2.y - 1, o2.x = o2.x + 1, a2[n2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(o2.x, " ").concat(o2.y, ")")), a2[n2].setAttribute("text-anchor", "end");
      i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
      var l2 = a2[n2].childNodes;
      t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, (function(i3) {
        e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - ("bottom" === t3.config.legend.position ? 20 : 10));
      }));
    }
    else !(function() {
      for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 < a2.length; s3++) {
        var r3 = a2[s3].childNodes;
        t3.config.xaxis.labels.trim && "datetime" !== t3.config.xaxis.type && Array.prototype.forEach.call(r3, (function(t4) {
          e2.placeTextWithEllipsis(t4, t4.textContent, i3);
        }));
      }
    })();
    if (s2.length > 0) {
      var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
      h2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
      for (var d2 = 0; d2 < r2.length; d2++) e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), t2;
})(), Ki = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.xaxisLabels = a2.globals.labels.slice(), this.axesUtils = new Ri(e2), this.isRangeBar = a2.globals.seriesRange.length && a2.globals.isBarHorizontal, a2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a2.globals.timescaleLabels.slice());
  }
  return s(t2, [{ key: "drawGridArea", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w, i2 = new Mi(this.ctx);
    t3 || (t3 = i2.group({ class: "apexcharts-grid" }));
    var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
    return t3.add(s2), t3.add(a2), t3;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var t3 = this.renderGrid();
      return this.drawGridArea(t3.el), t3;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? Math.max.apply(Math, f(t3.config.stroke.width)) : t3.config.stroke.width, s2 = function(t4) {
      var i3 = document.createElementNS(e2.SVGNS, "clipPath");
      return i3.setAttribute("id", t4), i3;
    };
    e2.dom.elGridRectMask = s2("gridRectMask".concat(e2.cuid)), e2.dom.elGridRectBarMask = s2("gridRectBarMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = s2("gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = s2("forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = s2("nonForecastMask".concat(e2.cuid));
    var r2 = 0, n2 = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(t3.config.chart.type) || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (r2 = Math.max(t3.config.grid.padding.left, e2.barPadForNumericAxis), n2 = Math.max(t3.config.grid.padding.right, e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 / 2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + 4, e2.gridHeight + a2 + 4, 0, "#fff"), e2.dom.elGridRectBar = i2.drawRect(-a2 / 2 - r2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + n2 + r2 + 4, e2.gridHeight + a2 + 4, 0, "#fff");
    var o2 = t3.globals.markers.largestSize;
    e2.dom.elGridRectMarker = i2.drawRect(-o2, -o2, e2.gridWidth + 2 * o2, e2.gridHeight + 2 * o2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectBarMask.appendChild(e2.dom.elGridRectBar.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
    var l2 = e2.dom.baseEl.querySelector("defs");
    l2.appendChild(e2.dom.elGridRectMask), l2.appendChild(e2.dom.elGridRectBarMask), l2.appendChild(e2.dom.elGridRectMarkerMask), l2.appendChild(e2.dom.elForecastMask), l2.appendChild(e2.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(t3) {
    var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w;
    if (!(0 === e2 && l2.globals.skipFirstTimelinelabel || e2 === n2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || "radar" === l2.config.chart.type)) {
      l2.config.grid.xaxis.lines.show && this._drawGridLine({ i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 });
      var h2 = 0;
      if (l2.globals.hasXaxisGroups && "between" === l2.config.xaxis.tickPlacement) {
        var c2 = l2.globals.groups;
        if (c2) {
          for (var d2 = 0, u2 = 0; d2 < e2 && u2 < c2.length; u2++) d2 += c2[u2].cols;
          d2 === e2 && (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
        }
      }
      new Qi(this.ctx).drawXaxisTicks(i2, h2, l2.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(t3) {
    var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w, h2 = o2.node.classList.contains("apexcharts-gridlines-horizontal"), c2 = l2.globals.barPadForNumericAxis, d2 = 0 === a2 && 0 === r2 || 0 === i2 && 0 === s2 || a2 === l2.globals.gridHeight && r2 === l2.globals.gridHeight || l2.globals.isBarHorizontal && (0 === e2 || e2 === n2 - 1), u2 = new Mi(this).drawLine(i2 - (h2 ? c2 : 0), a2, s2 + (h2 ? c2 : 0), r2, l2.config.grid.borderColor, l2.config.grid.strokeDashArray);
    u2.node.classList.add("apexcharts-gridline"), d2 && l2.config.grid.show ? this.elGridBorders.add(u2) : o2.add(u2);
  } }, { key: "_drawGridBandRect", value: function(t3) {
    var e2 = t3.c, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.type, o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.barPadForNumericAxis, c2 = o2.config.grid[n2].colors[e2], d2 = l2.drawRect(i2 - ("row" === n2 ? h2 : 0), a2, s2 + ("row" === n2 ? 2 * h2 : 0), r2, 0, c2, o2.config.grid[n2].opacity);
    this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(o2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(n2));
  } }, { key: "_drawXYLines", value: function(t3) {
    var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
    if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
      var r2, n2 = s2.globals.padHorizontal, o2 = s2.globals.gridHeight;
      s2.globals.timescaleLabels.length ? (function(t4) {
        for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, n3 = t4.x2, o3 = t4.y2, l3 = 0; l3 < a3; l3++) s3 = e2.xaxisLabels[l3].position, n3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: n3, y2: o3, xCount: i2, parent: e2.elgridLinesV });
      })({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }) : (s2.globals.isXNumeric && (i2 = s2.globals.xAxisScale.result.length), (function(t4) {
        for (var a3 = t4.xC, r3 = t4.x1, n3 = t4.y1, o3 = t4.x2, l3 = t4.y2, h3 = 0; h3 < a3 + (s2.globals.isXNumeric ? 0 : 1); h3++) 0 === h3 && 1 === a3 && 1 === s2.globals.dataPoints && (o3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: n3, x2: o3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), o3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
      })({ xC: i2, x1: n2, y1: 0, x2: r2, y2: o2 }));
    }
    if (s2.config.grid.yaxis.lines.show) {
      var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
      this.isRangeBar && (d2 = s2.globals.labels.length);
      for (var u2 = 0; u2 < d2 + (this.isRangeBar ? 1 : 0); u2++) this._drawGridLine({ i: u2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
    }
  } }, { key: "_drawInvertedXYLines", value: function(t3) {
    var e2 = t3.xCount, i2 = this.w;
    if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show) for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, n2 = 0; n2 < e2 + 1; n2++) {
      i2.config.grid.xaxis.lines.show && this._drawGridLine({ i: n2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new Qi(this.ctx).drawXaxisTicks(s2, 0, i2.globals.dom.elGraphical), a2 = s2 += i2.globals.gridWidth / e2;
    }
    if (i2.config.grid.yaxis.lines.show) for (var o2 = 0, l2 = 0, h2 = i2.globals.gridWidth, c2 = 0; c2 < i2.globals.dataPoints + 1; c2++) this._drawGridLine({ i: c2, xCount: i2.globals.dataPoints + 1, x1: 0, y1: o2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = o2 += i2.globals.gridHeight / i2.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = new Mi(this.ctx);
    this.elg = i2.group({ class: "apexcharts-grid" }), this.elgridLinesH = i2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var a2 = 0; a2 < e2.seriesYAxisMap.length && e2.ignoreYAxisIndexes.includes(a2); ) a2++;
    a2 === e2.seriesYAxisMap.length && (a2 = 0);
    var s2, r2 = e2.yAxisScale[a2].result.length - 1;
    if (!e2.isBarHorizontal || this.isRangeBar) {
      var n2, o2, l2;
      if (s2 = this.xaxisLabels.length, this.isRangeBar) r2 = e2.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (s2 = t3.config.xaxis.tickAmount), (null === (n2 = e2.yAxisScale) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.result) || void 0 === l2 ? void 0 : l2.length) > 0 && "datetime" !== t3.config.xaxis.type && (s2 = e2.yAxisScale[a2].result.length - 1);
      this._drawXYLines({ xCount: s2, tickAmount: r2 });
    } else s2 = r2, r2 = e2.xTickAmount, this._drawInvertedXYLines({ xCount: s2, tickAmount: r2 });
    return this.drawGridBands(s2, r2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e2.gridWidth / s2 };
  } }, { key: "drawGridBands", value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w;
    if ((null === (i2 = r2.config.grid.row.colors) || void 0 === i2 ? void 0 : i2.length) > 0 && (function(t4, i3, a3, n3, o3, l3) {
      for (var h3 = 0, c3 = 0; h3 < i3; h3++, c3++) c3 >= r2.config.grid[t4].colors.length && (c3 = 0), s2._drawGridBandRect({ c: c3, x1: a3, y1: n3, x2: o3, y2: l3, type: t4 }), n3 += r2.globals.gridHeight / e2;
    })("row", e2, 0, 0, r2.globals.gridWidth, r2.globals.gridHeight / e2), (null === (a2 = r2.config.grid.column.colors) || void 0 === a2 ? void 0 : a2.length) > 0) {
      var n2 = r2.globals.isBarHorizontal || "on" !== r2.config.xaxis.tickPlacement || "category" !== r2.config.xaxis.type && !r2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1;
      r2.globals.isXNumeric && (n2 = r2.globals.xAxisScale.result.length - 1);
      for (var o2 = r2.globals.padHorizontal, l2 = r2.globals.padHorizontal + r2.globals.gridWidth / n2, h2 = r2.globals.gridHeight, c2 = 0, d2 = 0; c2 < t3; c2++, d2++) {
        var u2;
        if (d2 >= r2.config.grid.column.colors.length && (d2 = 0), "datetime" === r2.config.xaxis.type) o2 = this.xaxisLabels[c2].position, l2 = ((null === (u2 = this.xaxisLabels[c2 + 1]) || void 0 === u2 ? void 0 : u2.position) || r2.globals.gridWidth) - this.xaxisLabels[c2].position;
        this._drawGridBandRect({ c: d2, x1: o2, y1: 0, x2: l2, y2: h2, type: "column" }), o2 += r2.globals.gridWidth / n2;
      }
    }
  } }]), t2;
})(), ta = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "niceScale", value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o2 = 1e-11, l2 = this.w, h2 = l2.globals;
    h2.isBarHorizontal ? (i2 = l2.config.xaxis, a2 = Math.max((h2.svgWidth - 100) / 25, 2)) : (i2 = l2.config.yaxis[n2], a2 = Math.max((h2.svgHeight - 100) / 15, 2)), v.isNumber(a2) || (a2 = 10), s2 = void 0 !== i2.min && null !== i2.min, r2 = void 0 !== i2.max && null !== i2.min;
    var c2 = void 0 !== i2.stepSize && null !== i2.stepSize, d2 = void 0 !== i2.tickAmount && null !== i2.tickAmount, u2 = d2 ? i2.tickAmount : h2.niceScaleDefaultTicks[Math.min(Math.round(a2 / 2), h2.niceScaleDefaultTicks.length - 1)];
    if (h2.isMultipleYAxis && !d2 && h2.multiAxisTickAmount > 0 && (u2 = h2.multiAxisTickAmount, d2 = true), u2 = "dataPoints" === u2 ? h2.dataPoints - 1 : Math.abs(Math.round(u2)), (t3 === Number.MIN_VALUE && 0 === e2 || !v.isNumber(t3) && !v.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE) && (t3 = v.isNumber(i2.min) ? i2.min : 0, e2 = v.isNumber(i2.max) ? i2.max : t3 + u2, h2.allSeriesCollapsed = false), t3 > e2) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var g2 = e2;
      e2 = t3, t3 = g2;
    } else t3 === e2 && (t3 = 0 === t3 ? 0 : t3 - 1, e2 = 0 === e2 ? 2 : e2 + 1);
    var p2 = [];
    u2 < 1 && (u2 = 1);
    var f2 = u2, x2 = Math.abs(e2 - t3);
    !s2 && t3 > 0 && t3 / x2 < 0.15 && (t3 = 0, s2 = true), !r2 && e2 < 0 && -e2 / x2 < 0.15 && (e2 = 0, r2 = true);
    var b2 = (x2 = Math.abs(e2 - t3)) / f2, m2 = b2, y2 = Math.floor(Math.log10(m2)), w2 = Math.pow(10, y2), k2 = Math.ceil(m2 / w2);
    if (b2 = m2 = (k2 = h2.niceScaleAllowedMagMsd[0 === h2.yValueDecimal ? 0 : 1][k2]) * w2, h2.isBarHorizontal && i2.stepSize && "datetime" !== i2.type ? (b2 = i2.stepSize, c2 = true) : c2 && (b2 = i2.stepSize), c2 && i2.forceNiceScale) {
      var A2 = Math.floor(Math.log10(b2));
      b2 *= Math.pow(10, y2 - A2);
    }
    if (s2 && r2) {
      var C2 = x2 / f2;
      if (d2) if (c2) if (0 != v.mod(x2, b2)) {
        var S2 = v.getGCD(b2, C2);
        b2 = C2 / S2 < 10 ? S2 : C2;
      } else 0 == v.mod(b2, C2) ? b2 = C2 : (C2 = b2, d2 = false);
      else b2 = C2;
      else if (c2) 0 == v.mod(x2, b2) ? C2 = b2 : b2 = C2;
      else if (0 == v.mod(x2, b2)) C2 = b2;
      else {
        C2 = x2 / (f2 = Math.ceil(x2 / b2));
        var L2 = v.getGCD(x2, b2);
        x2 / L2 < a2 && (C2 = L2), b2 = C2;
      }
      f2 = Math.round(x2 / b2);
    } else {
      if (s2 || r2) {
        if (r2) if (d2) t3 = e2 - b2 * f2;
        else {
          var M2 = t3;
          t3 = b2 * Math.floor(t3 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (t3 = e2 - b2 * u2, t3 += b2 * Math.floor((M2 - t3) / b2));
        }
        else if (s2) if (d2) e2 = t3 + b2 * f2;
        else {
          var P2 = e2;
          e2 = b2 * Math.ceil(e2 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (e2 = t3 + b2 * u2, e2 += b2 * Math.ceil((P2 - e2) / b2));
        }
      } else if (h2.isMultipleYAxis && d2) {
        var I2 = b2 * Math.floor(t3 / b2), T2 = I2 + b2 * f2;
        T2 < e2 && (b2 *= 2), T2 = e2, e2 = (t3 = I2) + b2 * f2, x2 = Math.abs(e2 - t3), t3 > 0 && t3 < Math.abs(T2 - e2) && (t3 = 0, e2 = b2 * f2), e2 < 0 && -e2 < Math.abs(I2 - t3) && (e2 = 0, t3 = -b2 * f2);
      } else t3 = b2 * Math.floor(t3 / b2), e2 = b2 * Math.ceil(e2 / b2);
      x2 = Math.abs(e2 - t3), b2 = v.getGCD(x2, b2), f2 = Math.round(x2 / b2);
    }
    if (d2 || s2 || r2 || (f2 = Math.ceil((x2 - o2) / (b2 + o2))) > 16 && v.getPrimeFactors(f2).length < 2 && f2++, !d2 && i2.forceNiceScale && 0 === h2.yValueDecimal && f2 > x2 && (f2 = x2, b2 = Math.round(x2 / f2)), f2 > a2 && (!d2 && !c2 || i2.forceNiceScale)) {
      var z2 = v.getPrimeFactors(f2), X2 = z2.length - 1, R2 = f2;
      t: for (var E2 = 0; E2 < X2; E2++) for (var Y2 = 0; Y2 <= X2 - E2; Y2++) {
        for (var H2 = Math.min(Y2 + E2, X2), O2 = R2, F2 = 1, D2 = Y2; D2 <= H2; D2++) F2 *= z2[D2];
        if ((O2 /= F2) < a2) {
          R2 = O2;
          break t;
        }
      }
      b2 = R2 === f2 ? x2 : x2 / R2, f2 = Math.round(x2 / b2);
    }
    h2.isMultipleYAxis && 0 == h2.multiAxisTickAmount && h2.ignoreYAxisIndexes.indexOf(n2) < 0 && (h2.multiAxisTickAmount = f2);
    var _2 = t3 - b2, N2 = b2 * o2;
    do {
      _2 += b2, p2.push(v.stripNumber(_2, 7));
    } while (e2 - _2 > N2);
    return { result: p2, niceMin: p2[0], niceMax: p2[p2.length - 1] };
  } }, { key: "linearScale", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r2 = Math.abs(e2 - t3), n2 = [];
    if (t3 === e2) return { result: n2 = [t3], niceMin: n2[0], niceMax: n2[n2.length - 1] };
    "dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a2, r2)) && (i2 = this.w.globals.dataPoints - 1), s2 || (s2 = r2 / i2), s2 = Math.round(100 * (s2 + Number.EPSILON)) / 100, i2 === Number.MAX_VALUE && (i2 = 5, s2 = 1);
    for (var o2 = t3; i2 >= 0; ) n2.push(o2), o2 = v.preciseAddition(o2, s2), i2 -= 1;
    return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(t3, e2, i2) {
    e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i2)); r2 < s2; r2++) a2.push(Math.pow(i2, r2));
    return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
  } }, { key: "logarithmicScale", value: function(t3, e2, i2) {
    e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
    for (var a2 = [], s2 = Math.log(e2) / Math.log(i2), r2 = Math.log(t3) / Math.log(i2), n2 = s2 - r2, o2 = Math.round(n2), l2 = n2 / o2, h2 = 0, c2 = r2; h2 < o2; h2++, c2 += l2) a2.push(Math.pow(i2, c2));
    return a2.push(Math.pow(i2, s2)), { result: a2, niceMin: t3, niceMax: e2 };
  } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i2) {
    var a2 = t3;
    if (void 0 !== e2 && this.w.config.yaxis[e2].labels.formatter && void 0 === this.w.config.yaxis[e2].tickAmount) {
      var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
      v.isNumber(s2) && 0 === this.w.globals.yValueDecimal && (a2 = Math.ceil(i2));
    }
    return a2 < t3 ? a2 : t3;
  } }, { key: "setYScaleForIndex", value: function(t3, e2, i2) {
    var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
    void 0 === a2.yAxisScale[t3] && (a2.yAxisScale[t3] = []);
    var n2 = Math.abs(i2 - e2);
    r2.logarithmic && n2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && n2 > 5 ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i2, r2.logBase) : this.logarithmicScale(e2, i2, r2.logBase)) : i2 !== -Number.MAX_VALUE && v.isNumber(i2) && e2 !== Number.MAX_VALUE && v.isNumber(e2) ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.niceScale(e2, i2, t3)) : a2.yAxisScale[t3] = this.niceScale(Number.MIN_VALUE, 0, t3);
  } }, { key: "setXScale", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals;
    if (e2 !== -Number.MAX_VALUE && v.isNumber(e2)) {
      var s2 = a2.xTickAmount;
      a2.xAxisScale = this.linearScale(t3, e2, s2, 0, i2.config.xaxis.stepSize);
    } else a2.xAxisScale = this.linearScale(0, 10, 10);
    return a2.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var t3 = this, e2 = this.w.config, i2 = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var a2 = i2.seriesYAxisMap, s2 = i2.minYArr, r2 = i2.maxYArr;
    i2.allSeriesCollapsed = true, i2.barGroups = [], a2.forEach((function(a3, n2) {
      var o2 = [];
      a3.forEach((function(t4) {
        var i3, a4 = null === (i3 = e2.series[t4]) || void 0 === i3 ? void 0 : i3.group;
        o2.indexOf(a4) < 0 && o2.push(a4);
      })), a3.length > 0 ? (function() {
        var l2, h2, c2 = Number.MAX_VALUE, d2 = -Number.MAX_VALUE, u2 = c2, g2 = d2;
        if (e2.chart.stacked) !(function() {
          var t4 = new Array(i2.dataPoints).fill(0), s3 = [], r3 = [], p3 = [];
          o2.forEach((function() {
            s3.push(t4.map((function() {
              return Number.MIN_VALUE;
            }))), r3.push(t4.map((function() {
              return Number.MIN_VALUE;
            }))), p3.push(t4.map((function() {
              return Number.MIN_VALUE;
            })));
          }));
          for (var f3 = function(t5) {
            !l2 && e2.series[a3[t5]].type && (l2 = e2.series[a3[t5]].type);
            var c3 = a3[t5];
            h2 = e2.series[c3].group ? e2.series[c3].group : "axis-".concat(n2), !(i2.collapsedSeriesIndices.indexOf(c3) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(c3) < 0) || (i2.allSeriesCollapsed = false, o2.forEach((function(t6, a4) {
              if (e2.series[c3].group === t6) for (var n3 = 0; n3 < i2.series[c3].length; n3++) {
                var o3 = i2.series[c3][n3];
                o3 >= 0 ? r3[a4][n3] += o3 : p3[a4][n3] += o3, s3[a4][n3] += o3, u2 = Math.min(u2, o3), g2 = Math.max(g2, o3);
              }
            }))), "bar" !== l2 && "column" !== l2 || i2.barGroups.push(h2);
          }, x2 = 0; x2 < a3.length; x2++) f3(x2);
          l2 || (l2 = e2.chart.type), "bar" === l2 || "column" === l2 ? o2.forEach((function(t5, e3) {
            c2 = Math.min(c2, Math.min.apply(null, p3[e3])), d2 = Math.max(d2, Math.max.apply(null, r3[e3]));
          })) : (o2.forEach((function(t5, e3) {
            u2 = Math.min(u2, Math.min.apply(null, s3[e3])), g2 = Math.max(g2, Math.max.apply(null, s3[e3]));
          })), c2 = u2, d2 = g2), c2 === Number.MIN_VALUE && d2 === Number.MIN_VALUE && (d2 = -Number.MAX_VALUE);
        })();
        else for (var p2 = 0; p2 < a3.length; p2++) {
          var f2 = a3[p2];
          c2 = Math.min(c2, s2[f2]), d2 = Math.max(d2, r2[f2]), !(i2.collapsedSeriesIndices.indexOf(f2) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(f2) < 0) || (i2.allSeriesCollapsed = false);
        }
        void 0 !== e2.yaxis[n2].min && (c2 = "function" == typeof e2.yaxis[n2].min ? e2.yaxis[n2].min(c2) : e2.yaxis[n2].min), void 0 !== e2.yaxis[n2].max && (d2 = "function" == typeof e2.yaxis[n2].max ? e2.yaxis[n2].max(d2) : e2.yaxis[n2].max), i2.barGroups = i2.barGroups.filter((function(t4, e3, i3) {
          return i3.indexOf(t4) === e3;
        })), t3.setYScaleForIndex(n2, c2, d2), a3.forEach((function(t4) {
          s2[t4] = i2.yAxisScale[n2].niceMin, r2[t4] = i2.yAxisScale[n2].niceMax;
        }));
      })() : t3.setYScaleForIndex(n2, 0, -Number.MAX_VALUE);
    }));
  } }]), t2;
})(), ea = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new ta(e2);
  }
  return s(t2, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, n2 = -Number.MAX_VALUE, o2 = Number.MIN_VALUE;
    null === a2 && (a2 = t3 + 1);
    var l2 = r2.series, h2 = l2, c2 = l2;
    "candlestick" === s2.chart.type ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : "boxPlot" === s2.chart.type ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
    var d2 = false;
    if (r2.seriesX.length >= a2) {
      var u2, g2 = null === (u2 = r2.brushSource) || void 0 === u2 ? void 0 : u2.w.config.chart.brush;
      (s2.chart.zoom.enabled && s2.chart.zoom.autoScaleYaxis || null != g2 && g2.enabled && null != g2 && g2.autoScaleYaxis) && (d2 = true);
    }
    for (var p2 = t3; p2 < a2; p2++) {
      r2.dataPoints = Math.max(r2.dataPoints, l2[p2].length);
      var f2 = s2.series[p2].type;
      r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter((function(t4) {
        return void 0 !== t4;
      })).length), r2.labels.length && "datetime" !== s2.xaxis.type && 0 !== r2.series.reduce((function(t4, e3) {
        return t4 + e3.length;
      }), 0) && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
      var x2 = 0, b2 = l2[p2].length - 1;
      if (d2) {
        if (s2.xaxis.min) for (; x2 < b2 && r2.seriesX[p2][x2] < s2.xaxis.min; x2++) ;
        if (s2.xaxis.max) for (; b2 > x2 && r2.seriesX[p2][b2] > s2.xaxis.max; b2--) ;
      }
      for (var m2 = x2; m2 <= b2 && m2 < r2.series[p2].length; m2++) {
        var y2 = l2[p2][m2];
        if (null !== y2 && v.isNumber(y2)) {
          var w2, k2, A2, C2;
          switch (void 0 !== (null === (w2 = c2[p2]) || void 0 === w2 ? void 0 : w2[m2]) && (n2 = Math.max(n2, c2[p2][m2]), e2 = Math.min(e2, c2[p2][m2])), void 0 !== (null === (k2 = h2[p2]) || void 0 === k2 ? void 0 : k2[m2]) && (e2 = Math.min(e2, h2[p2][m2]), i2 = Math.max(i2, h2[p2][m2])), f2) {
            case "candlestick":
              void 0 !== r2.seriesCandleC[p2][m2] && (n2 = Math.max(n2, r2.seriesCandleH[p2][m2]), e2 = Math.min(e2, r2.seriesCandleL[p2][m2]));
              break;
            case "boxPlot":
              void 0 !== r2.seriesCandleC[p2][m2] && (n2 = Math.max(n2, r2.seriesCandleC[p2][m2]), e2 = Math.min(e2, r2.seriesCandleO[p2][m2]));
          }
          f2 && "candlestick" !== f2 && "boxPlot" !== f2 && "rangeArea" !== f2 && "rangeBar" !== f2 && (n2 = Math.max(n2, r2.series[p2][m2]), e2 = Math.min(e2, r2.series[p2][m2])), r2.seriesGoals[p2] && r2.seriesGoals[p2][m2] && Array.isArray(r2.seriesGoals[p2][m2]) && r2.seriesGoals[p2][m2].forEach((function(t4) {
            n2 = Math.max(n2, t4.value), e2 = Math.min(e2, t4.value);
          })), i2 = n2, y2 = v.noExponents(y2), v.isFloat(y2) && (r2.yValueDecimal = Math.max(r2.yValueDecimal, y2.toString().split(".")[1].length)), o2 > (null === (A2 = h2[p2]) || void 0 === A2 ? void 0 : A2[m2]) && (null === (C2 = h2[p2]) || void 0 === C2 ? void 0 : C2[m2]) < 0 && (o2 = h2[p2][m2]);
        } else r2.hasNullValues = true;
      }
      "bar" !== f2 && "column" !== f2 || (o2 < 0 && n2 < 0 && (n2 = 0, i2 = Math.max(i2, 0)), o2 === Number.MIN_VALUE && (o2 = 0, e2 = Math.min(e2, 0)));
    }
    return "rangeBar" === s2.chart.type && r2.seriesRangeStart.length && r2.isBarHorizontal && (o2 = e2), "bar" === s2.chart.type && (o2 < 0 && n2 < 0 && (n2 = 0), o2 === Number.MIN_VALUE && (o2 = 0)), { minY: o2, maxY: n2, lowestY: e2, highestY: i2 };
  } }, { key: "setYRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
    var i2, a2 = Number.MAX_VALUE;
    if (t3.isMultipleYAxis) {
      a2 = Number.MAX_VALUE;
      for (var s2 = 0; s2 < t3.series.length; s2++) i2 = this.getMinYMaxY(s2), t3.minYArr[s2] = i2.lowestY, t3.maxYArr[s2] = i2.highestY, a2 = Math.min(a2, i2.lowestY);
    }
    if (i2 = this.getMinYMaxY(0, a2, null, t3.series.length), "bar" === e2.chart.type ? (t3.minY = i2.minY, t3.maxY = i2.maxY) : (t3.minY = i2.lowestY, t3.maxY = i2.highestY), a2 = i2.lowestY, e2.chart.stacked && this._setStackedMinMax(), "line" === e2.chart.type || "area" === e2.chart.type || "scatter" === e2.chart.type || "candlestick" === e2.chart.type || "boxPlot" === e2.chart.type || "rangeBar" === e2.chart.type && !t3.isBarHorizontal ? t3.minY === Number.MIN_VALUE && a2 !== -Number.MAX_VALUE && a2 !== t3.maxY && (t3.minY = a2) : t3.minY = t3.minY !== Number.MIN_VALUE ? Math.min(i2.minY, t3.minY) : i2.minY, e2.yaxis.forEach((function(e3, i3) {
      void 0 !== e3.max && ("number" == typeof e3.max ? t3.maxYArr[i3] = e3.max : "function" == typeof e3.max && (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), void 0 !== e3.min && ("number" == typeof e3.min ? t3.minYArr[i3] = e3.min : "function" == typeof e3.min && (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
    })), t3.isBarHorizontal) {
      ["min", "max"].forEach((function(i3) {
        void 0 !== e2.xaxis[i3] && "number" == typeof e2.xaxis[i3] && ("min" === i3 ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
      }));
    }
    return t3.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t3.minY = a2) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.minY, t3.maxYArr[0] = t3.maxY), t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], e2.series.forEach((function(i3) {
      switch (i3.type || e2.chart.type) {
        case "bar":
        case "column":
          t3.barGroups.push(i3.group);
          break;
        case "line":
          t3.lineGroups.push(i3.group);
          break;
        case "area":
          t3.areaGroups.push(i3.group);
      }
    })), t3.barGroups = t3.barGroups.filter((function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    })), t3.lineGroups = t3.lineGroups.filter((function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    })), t3.areaGroups = t3.areaGroups.filter((function(t4, e3, i3) {
      return i3.indexOf(t4) === e3;
    })), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i2 = "numeric" === e2.xaxis.type || "datetime" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
    if (t3.isXNumeric && (function() {
      for (var e3 = 0; e3 < t3.series.length; e3++) if (t3.labels[e3]) for (var i3 = 0; i3 < t3.labels[e3].length; i3++) null !== t3.labels[e3][i3] && v.isNumber(t3.labels[e3][i3]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
    })(), t3.noLabelsProvided && 0 === e2.xaxis.categories.length && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
      var a2 = 10;
      if (void 0 === e2.xaxis.tickAmount) a2 = Math.round(t3.svgWidth / 150), "numeric" === e2.xaxis.type && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && 0 !== t3.dataPoints && (a2 = t3.dataPoints - 1);
      else if ("dataPoints" === e2.xaxis.tickAmount) {
        if (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric) {
          var s2 = Math.round(t3.maxX - t3.minX);
          s2 < 30 && (a2 = s2 - 1);
        }
      } else a2 = e2.xaxis.tickAmount;
      if (t3.xTickAmount = a2, void 0 !== e2.xaxis.max && "number" == typeof e2.xaxis.max && (t3.maxX = e2.xaxis.max), void 0 !== e2.xaxis.min && "number" == typeof e2.xaxis.min && (t3.minX = e2.xaxis.min), void 0 !== e2.xaxis.range && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE) if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
        for (var r2 = [], n2 = t3.minX - 1; n2 < t3.maxX; n2++) r2.push(n2 + 1);
        t3.xAxisScale = { result: r2, niceMin: r2[0], niceMax: r2[r2.length - 1] };
      } else t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
      else t3.xAxisScale = this.scales.linearScale(0, a2, a2, 0, e2.xaxis.stepSize), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1, 0, e2.xaxis.stepSize), t3.seriesX = t3.labels.slice());
      i2 && (t3.labels = t3.xAxisScale.result.slice());
    }
    return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
  } }, { key: "setZRange", value: function() {
    var t3 = this.w.globals;
    if (t3.isDataXYZ) {
      for (var e2 = 0; e2 < t3.series.length; e2++) if (void 0 !== t3.seriesZ[e2]) for (var i2 = 0; i2 < t3.seriesZ[e2].length; i2++) null !== t3.seriesZ[e2][i2] && v.isNumber(t3.seriesZ[e2][i2]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    if (t3.minX === t3.maxX) {
      var i2 = new zi(this.ctx);
      if ("datetime" === e2.xaxis.type) {
        var a2 = i2.getDate(t3.minX);
        e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
        var s2 = i2.getDate(t3.maxX);
        e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
      } else ("numeric" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var t3 = this.w.globals;
    t3.isXNumeric && t3.seriesX.forEach((function(e2, i2) {
      if (e2.length) {
        1 === e2.length && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
        var a2 = e2.slice();
        a2.sort((function(t4, e3) {
          return t4 - e3;
        })), a2.forEach((function(e3, i3) {
          if (i3 > 0) {
            var s2 = e3 - a2[i3 - 1];
            s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
          }
        })), 1 !== t3.dataPoints && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
      }
    }));
  } }, { key: "_setStackedMinMax", value: function() {
    var t3 = this, e2 = this.w.globals;
    if (e2.series.length) {
      var i2 = e2.seriesGroups;
      i2.length || (i2 = [this.w.globals.seriesNames.map((function(t4) {
        return t4;
      }))]);
      var a2 = {}, s2 = {};
      i2.forEach((function(i3) {
        a2[i3] = [], s2[i3] = [], t3.w.config.series.map((function(t4, a3) {
          return i3.indexOf(e2.seriesNames[a3]) > -1 ? a3 : null;
        })).filter((function(t4) {
          return null !== t4;
        })).forEach((function(r2) {
          for (var n2 = 0; n2 < e2.series[e2.maxValsInArrayIndex].length; n2++) {
            var o2, l2, h2, c2;
            void 0 === a2[i3][n2] && (a2[i3][n2] = 0, s2[i3][n2] = 0), (t3.w.config.chart.stacked && !e2.comboCharts || t3.w.config.chart.stacked && e2.comboCharts && (!t3.w.config.chart.stackOnlyBar || "bar" === (null === (o2 = t3.w.config.series) || void 0 === o2 || null === (l2 = o2[r2]) || void 0 === l2 ? void 0 : l2.type) || "column" === (null === (h2 = t3.w.config.series) || void 0 === h2 || null === (c2 = h2[r2]) || void 0 === c2 ? void 0 : c2.type))) && null !== e2.series[r2][n2] && v.isNumber(e2.series[r2][n2]) && (e2.series[r2][n2] > 0 ? a2[i3][n2] += parseFloat(e2.series[r2][n2]) + 1e-4 : s2[i3][n2] += parseFloat(e2.series[r2][n2]));
          }
        }));
      })), Object.entries(a2).forEach((function(t4) {
        var i3 = p(t4, 1)[0];
        a2[i3].forEach((function(t5, r2) {
          e2.maxY = Math.max(e2.maxY, a2[i3][r2]), e2.minY = Math.min(e2.minY, s2[i3][r2]);
        }));
      }));
    }
  } }]), t2;
})(), ia = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xAxisoffX = "bottom" === s2.config.xaxis.position ? s2.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ri(e2);
  }
  return s(t2, [{ key: "drawYaxis", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.yaxis[t3].labels.style, s2 = a2.fontSize, r2 = a2.fontFamily, n2 = a2.fontWeight, o2 = i2.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(".concat(e2.globals.translateYAxisX[t3], ", 0)") });
    if (this.axesUtils.isYAxisHidden(t3)) return o2;
    var l2 = i2.group({ class: "apexcharts-yaxis-texts-g" });
    o2.add(l2);
    var h2 = e2.globals.yAxisScale[t3].result.length - 1, c2 = e2.globals.gridHeight / h2, d2 = e2.globals.yLabelFormatters[t3], u2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice());
    if (e2.config.yaxis[t3].labels.show) {
      var g2 = e2.globals.translateY + e2.config.yaxis[t3].labels.offsetY;
      e2.globals.isBarHorizontal ? g2 = 0 : "heatmap" === e2.config.chart.type && (g2 -= c2 / 2), g2 += parseInt(s2, 10) / 3;
      for (var p2 = h2; p2 >= 0; p2--) {
        var f2 = d2(u2[p2], p2, e2), x2 = e2.config.yaxis[t3].labels.padding;
        e2.config.yaxis[t3].opposite && 0 !== e2.config.yaxis.length && (x2 *= -1);
        var b2 = this.getTextAnchor(e2.config.yaxis[t3].labels.align, e2.config.yaxis[t3].opposite), m2 = this.axesUtils.getYAxisForeColor(a2.colors, t3), y2 = Array.isArray(m2) ? m2[p2] : m2, w2 = v.listToArray(e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-label tspan"))).map((function(t4) {
          return t4.textContent;
        })), k2 = i2.drawText({ x: x2, y: g2, text: w2.includes(f2) && !e2.config.yaxis[t3].labels.showDuplicates ? "" : f2, textAnchor: b2, fontSize: s2, fontFamily: r2, fontWeight: n2, maxWidth: e2.config.yaxis[t3].labels.maxWidth, foreColor: y2, isPlainText: false, cssClass: "apexcharts-yaxis-label ".concat(a2.cssClass) });
        l2.add(k2), this.addTooltip(k2, f2), 0 !== e2.config.yaxis[t3].labels.rotate && this.rotateLabel(i2, k2, firstLabel, e2.config.yaxis[t3].labels.rotate), g2 += c2;
      }
    }
    return this.addYAxisTitle(i2, o2, t3), this.addAxisBorder(i2, o2, t3, h2, c2), o2;
  } }, { key: "getTextAnchor", value: function(t3, e2) {
    return "left" === t3 ? "start" : "center" === t3 ? "middle" : "right" === t3 ? "end" : e2 ? "start" : "end";
  } }, { key: "addTooltip", value: function(t3, e2) {
    var i2 = document.createElementNS(this.w.globals.SVGNS, "title");
    i2.textContent = Array.isArray(e2) ? e2.join(" ") : e2, t3.node.appendChild(i2);
  } }, { key: "rotateLabel", value: function(t3, e2, i2, a2) {
    var s2 = t3.rotateAroundCenter(i2.node), r2 = t3.rotateAroundCenter(e2.node);
    e2.node.setAttribute("transform", "rotate(".concat(a2, " ").concat(s2.x, " ").concat(r2.y, ")"));
  } }, { key: "addYAxisTitle", value: function(t3, e2, i2) {
    var a2 = this.w;
    if (void 0 !== a2.config.yaxis[i2].title.text) {
      var s2 = t3.group({ class: "apexcharts-yaxis-title" }), r2 = a2.config.yaxis[i2].opposite ? a2.globals.translateYAxisX[i2] : 0, n2 = t3.drawText({ x: r2, y: a2.globals.gridHeight / 2 + a2.globals.translateY + a2.config.yaxis[i2].title.offsetY, text: a2.config.yaxis[i2].title.text, textAnchor: "end", foreColor: a2.config.yaxis[i2].title.style.color, fontSize: a2.config.yaxis[i2].title.style.fontSize, fontWeight: a2.config.yaxis[i2].title.style.fontWeight, fontFamily: a2.config.yaxis[i2].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(a2.config.yaxis[i2].title.style.cssClass) });
      s2.add(n2), e2.add(s2);
    }
  } }, { key: "addAxisBorder", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w, n2 = r2.config.yaxis[i2].axisBorder, o2 = 31 + n2.offsetX;
    if (r2.config.yaxis[i2].opposite && (o2 = -31 - n2.offsetX), n2.show) {
      var l2 = t3.drawLine(o2, r2.globals.translateY + n2.offsetY - 2, o2, r2.globals.gridHeight + r2.globals.translateY + n2.offsetY + 2, n2.color, 0, n2.width);
      e2.add(l2);
    }
    r2.config.yaxis[i2].axisTicks.show && this.axesUtils.drawYAxisTicks(o2, a2, n2, r2.config.yaxis[i2].axisTicks, i2, s2, e2);
  } }, { key: "drawYaxisInversed", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
    a2.add(s2);
    var r2 = e2.globals.yAxisScale[t3].result.length - 1, n2 = e2.globals.gridWidth / r2 + 0.1, o2 = n2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice()), c2 = e2.globals.timescaleLabels;
    if (c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), e2.config.xaxis.labels.show) for (var d2 = c2.length ? 0 : r2; c2.length ? d2 < c2.length : d2 >= 0; c2.length ? d2++ : d2--) {
      var u2 = l2(h2[d2], d2, e2), g2 = e2.globals.gridWidth + e2.globals.padHorizontal - (o2 - n2 + e2.config.xaxis.labels.offsetX);
      if (c2.length) {
        var p2 = this.axesUtils.getLabel(h2, c2, g2, d2, this.drawnLabels, this.xaxisFontSize);
        g2 = p2.x, u2 = p2.text, this.drawnLabels.push(p2.text), 0 === d2 && e2.globals.skipFirstTimelinelabel && (u2 = ""), d2 === h2.length - 1 && e2.globals.skipLastTimelinelabel && (u2 = "");
      }
      var f2 = i2.drawText({ x: g2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - ("top" === e2.config.xaxis.position ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label ".concat(e2.config.xaxis.labels.style.cssClass) });
      s2.add(f2), f2.tspan(u2), this.addTooltip(f2, u2), o2 += n2;
    }
    return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
  } }, { key: "inversedYAxisBorder", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = e2.config.xaxis.axisBorder;
    if (a2.show) {
      var s2 = 0;
      "bar" === e2.config.chart.type && e2.globals.isXNumeric && (s2 -= 15);
      var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
      this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
    }
  } }, { key: "inversedYAxisTitleText", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx);
    if (void 0 !== e2.config.xaxis.title.text) {
      var a2 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(e2.config.xaxis.title.style.cssClass) });
      a2.add(s2), t3.add(a2);
    }
  } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g")), r2 = s2 ? s2.getBoundingClientRect() : { width: 0, height: 0 }, n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text")), o2 = n2 ? n2.getBoundingClientRect() : { width: 0, height: 0 };
    if (n2) {
      var l2 = this.xPaddingForYAxisTitle(t3, r2, o2, e2);
      n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
      var h2 = a2.rotateAroundCenter(n2);
      n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, " ").concat(h2.x, " ").concat(h2.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 0, n2 = 10;
    return void 0 === s2.config.yaxis[t3].title.text || t3 < 0 ? { xPos: r2, padd: 0 } : (a2 ? r2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2 : (r2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal && (n2 = 25, r2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: r2, padd: n2 });
  } }, { key: "setYAxisXPosition", value: function(t3, e2) {
    var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, n2 = 1;
    i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.forEach((function(o2, l2) {
      var h2 = i2.globals.ignoreYAxisIndexes.includes(l2) || !o2.show || o2.floating || 0 === t3[l2].width, c2 = t3[l2].width + e2[l2].width;
      o2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + n2, h2 || (n2 += c2 + 20), i2.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h2 || (r2 += c2 + 20), i2.globals.translateYAxisX[l2] = a2 + o2.labels.offsetX);
    }));
  } }, { key: "setYAxisTextAlignments", value: function() {
    var t3 = this.w;
    v.listToArray(t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach((function(e2, i2) {
      var a2 = t3.config.yaxis[i2];
      if (a2 && !a2.floating && void 0 !== a2.labels.align) {
        var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = v.listToArray(t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"))), n2 = s2.getBoundingClientRect();
        r2.forEach((function(t4) {
          t4.setAttribute("text-anchor", a2.labels.align);
        })), "left" !== a2.labels.align || a2.opposite ? "center" === a2.labels.align ? s2.setAttribute("transform", "translate(".concat(n2.width / 2 * (a2.opposite ? 1 : -1), ", 0)")) : "right" === a2.labels.align && a2.opposite && s2.setAttribute("transform", "translate(".concat(n2.width, ", 0)")) : s2.setAttribute("transform", "translate(-".concat(n2.width, ", 0)"));
      }
    }));
  } }]), t2;
})(), aa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = v.bind(this.documentEvent, this);
  }
  return s(t2, [{ key: "addEventListener", value: function(t3, e2) {
    var i2 = this.w;
    i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
  } }, { key: "removeEventListener", value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      var a2 = i2.globals.events[t3].indexOf(e2);
      -1 !== a2 && i2.globals.events[t3].splice(a2, 1);
    }
  } }, { key: "fireEvent", value: function(t3, e2) {
    var i2 = this.w;
    if (i2.globals.events.hasOwnProperty(t3)) {
      e2 && e2.length || (e2 = []);
      for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0; r2 < s2; r2++) a2[r2].apply(null, e2);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
    this.ctx.eventList.forEach((function(t4) {
      a2.addEventListener(t4, (function(t5) {
        var a3 = null === t5.target.getAttribute("i") && -1 !== e2.globals.capturedSeriesIndex ? e2.globals.capturedSeriesIndex : t5.target.getAttribute("i"), s2 = null === t5.target.getAttribute("j") && -1 !== e2.globals.capturedDataPointIndex ? e2.globals.capturedDataPointIndex : t5.target.getAttribute("j"), r2 = Object.assign({}, e2, { seriesIndex: e2.globals.axisCharts ? a3 : 0, dataPointIndex: s2 });
        "mousemove" === t5.type || "touchmove" === t5.type ? "function" == typeof e2.config.chart.events.mouseMove && e2.config.chart.events.mouseMove(t5, i2, r2) : "mouseleave" === t5.type || "touchleave" === t5.type ? "function" == typeof e2.config.chart.events.mouseLeave && e2.config.chart.events.mouseLeave(t5, i2, r2) : ("mouseup" === t5.type && 1 === t5.which || "touchend" === t5.type) && ("function" == typeof e2.config.chart.events.click && e2.config.chart.events.click(t5, i2, r2), i2.ctx.events.fireEvent("click", [t5, i2, r2]));
      }), { capture: false, passive: true });
    })), this.ctx.eventList.forEach((function(i3) {
      e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
    })), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(t3) {
    var e2 = this.w, i2 = t3.target.className;
    if ("click" === t3.type) {
      var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
      a2 && a2.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i2 && a2.classList.remove("apexcharts-menu-open");
    }
    e2.globals.clientX = "touchmove" === t3.type ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = "touchmove" === t3.type ? t3.touches[0].clientY : t3.clientY;
  } }]), t2;
})(), sa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
    var e2 = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i2 = e2.filter((function(e3) {
      return e3.name === t3;
    }))[0];
    if (!i2) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var a2 = v.extend(Hi, i2);
    this.w.globals.locale = a2.options;
  } }]), t2;
})(), ra = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawAxis", value: function(t3, e2) {
    var i2, a2, s2 = this, r2 = this.w.globals, n2 = this.w.config, o2 = new Qi(this.ctx, e2), l2 = new ia(this.ctx, e2);
    r2.axisCharts && "radar" !== t3 && (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i2 = o2.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a2)) : (i2 = o2.drawXaxis(), r2.dom.elGraphical.add(i2), n2.yaxis.map((function(t4, e3) {
      if (-1 === r2.ignoreYAxisIndexes.indexOf(e3) && (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), "back" === s2.w.config.grid.position)) {
        var i3 = r2.dom.Paper.children()[1];
        i3.remove(), r2.dom.Paper.add(i3);
      }
    }))));
  } }]), t2;
})(), na = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawXCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Li(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, n2 = a2.colorFrom, o2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, u2 = s2.left, g2 = s2.top, p2 = s2.blur, f2 = s2.color, x2 = s2.opacity, b2 = t3.config.xaxis.crosshairs.fill.color;
    if (t3.config.xaxis.crosshairs.show) {
      "gradient" === r2 && (b2 = e2.drawGradient("vertical", n2, o2, l2, h2, null, c2, null));
      var m2 = e2.drawRect();
      1 === t3.config.xaxis.crosshairs.width && (m2 = e2.drawLine());
      var y2 = t3.globals.gridHeight;
      (!v.isNumber(y2) || y2 < 0) && (y2 = 0);
      var w2 = t3.config.xaxis.crosshairs.width;
      (!v.isNumber(w2) || w2 < 0) && (w2 = 0), m2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2, width: w2, height: y2, fill: b2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (m2 = i2.dropShadow(m2, { left: u2, top: g2, blur: p2, color: f2, opacity: x2 })), t3.globals.dom.elGraphical.add(m2);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
    if (t3.config.yaxis[0].crosshairs.show) {
      var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
      s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
    }
    var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
    r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
  } }]), t2;
})(), oa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.config;
    if (0 !== a2.responsive.length) {
      var s2 = a2.responsive.slice();
      s2.sort((function(t4, e3) {
        return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
      })).reverse();
      var r2 = new Wi({}), n2 = function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a3 = s2[0].breakpoint, n3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (n3 > a3) {
          var o3 = v.clone(i2.globals.initialConfig);
          o3.series = v.clone(i2.config.series);
          var l2 = Pi.extendArrayProps(r2, o3, i2);
          t4 = v.extend(l2, t4), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
        } else for (var h2 = 0; h2 < s2.length; h2++) n3 < s2[h2].breakpoint && (t4 = Pi.extendArrayProps(r2, s2[h2].options, i2), t4 = v.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
      };
      if (t3) {
        var o2 = Pi.extendArrayProps(r2, t3, i2);
        o2 = v.extend(i2.config, o2), n2(o2 = v.extend(o2, t3));
      } else n2({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(t3) {
    var e2 = new Wi(t3).init({ responsiveOverride: true });
    this.w.config = e2;
  } }]), t2;
})(), la = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.colors = [], this.isColorFn = false, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return s(t2, [{ key: "checkHeatmapDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return "treemap" === e2.type && i2.treemap && i2.treemap.distributed || "heatmap" === e2.type && i2.heatmap && i2.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i2 = t3.plotOptions;
    return i2.bar && i2.bar.distributed && ("bar" === e2.type || "rangeBar" === e2.type);
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var t3 = this.w, e2 = new v();
    t3.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t3.config.theme.mode || "light"));
    var i2 = f(t3.config.colors || t3.config.fill.colors || []);
    t3.globals.colors = this.getColors(i2), this.applySeriesColors(t3.globals.seriesColors, t3.globals.colors), t3.config.theme.monochrome.enabled && (t3.globals.colors = this.getMonochromeColors(t3.config.theme.monochrome, t3.globals.series, e2));
    var a2 = t3.globals.colors.slice();
    this.pushExtraColors(t3.globals.colors), this.applyColorTypes(["fill", "stroke"], a2), this.applyDataLabelsColors(a2), this.applyRadarPolygonsColors(), this.applyMarkersColors(a2);
  } }, { key: "getColors", value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3 && 0 !== t3.length ? Array.isArray(t3) && t3.length > 0 && "function" == typeof t3[0] ? (this.isColorFn = true, i2.config.series.map((function(a2, s2) {
      var r2 = t3[s2] || t3[0];
      return "function" == typeof r2 ? r2({ value: i2.globals.axisCharts ? i2.globals.series[s2][0] || 0 : i2.globals.series[s2], seriesIndex: s2, dataPointIndex: s2, w: e2.w }) : r2;
    }))) : t3 : this.predefined();
  } }, { key: "applySeriesColors", value: function(t3, e2) {
    t3.forEach((function(t4, i2) {
      t4 && (e2[i2] = t4);
    }));
  } }, { key: "getMonochromeColors", value: function(t3, e2, i2) {
    var a2 = t3.color, s2 = t3.shadeIntensity, r2 = t3.shadeTo, n2 = this.isBarDistributed || this.isHeatmapDistributed ? e2[0].length * e2.length : e2.length, o2 = 1 / (n2 / s2), l2 = 0;
    return Array.from({ length: n2 }, (function() {
      var t4 = "dark" === r2 ? i2.shadeColor(-1 * l2, a2) : i2.shadeColor(l2, a2);
      return l2 += o2, t4;
    }));
  } }, { key: "applyColorTypes", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    t3.forEach((function(t4) {
      a2.globals[t4].colors = void 0 === a2.config[t4].colors ? i2.isColorFn ? a2.config.colors : e2 : a2.config[t4].colors.slice(), i2.pushExtraColors(a2.globals[t4].colors);
    }));
  } }, { key: "applyDataLabelsColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.dataLabels.style.colors = void 0 === e2.config.dataLabels.style.colors ? t3 : e2.config.dataLabels.style.colors.slice(), this.pushExtraColors(e2.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var t3 = this.w;
    t3.globals.radarPolygons.fill.colors = void 0 === t3.config.plotOptions.radar.polygons.fill.colors ? ["dark" === t3.config.theme.mode ? "#343A3F" : "none"] : t3.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t3.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.markers.colors = void 0 === e2.config.markers.colors ? t3 : e2.config.markers.colors.slice(), this.pushExtraColors(e2.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
    if (null === i2 && (i2 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a2.config.chart.type && a2.config.plotOptions.heatmap && a2.config.plotOptions.heatmap.colorScale.inverse), i2 && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2) for (var r2 = s2 - t3.length, n2 = 0; n2 < r2; n2++) t3.push(t3[n2]);
  } }, { key: "updateThemeOptions", value: function(t3) {
    t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
    var e2 = t3.theme.mode, i2 = "dark" === e2 ? "palette4" : "light" === e2 ? "palette1" : t3.theme.palette || "palette1", a2 = "dark" === e2 ? "#f6f7f8" : "light" === e2 ? "#373d3f" : t3.chart.foreColor || "#373d3f";
    return t3.tooltip.theme = e2 || "light", t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
  } }, { key: "predefined", value: function() {
    var t3 = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return t3[this.w.config.theme.palette] || t3.default;
  } }]), t2;
})(), ha = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(t3) {
    var e2 = this.w, i2 = "title" === t3 ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = "middle";
    if ("left" === i2.align ? (a2 = 10, r2 = "start") : "right" === i2.align && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, void 0 !== i2.text) {
      var n2 = new Mi(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
      n2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(n2);
    }
  } }]), t2;
})(), ca = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
    var e2 = this.w, i2 = 0, a2 = 0, s2 = "title" === t3 ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
    if (null !== r2 && !s2) {
      var n2 = r2.getBoundingClientRect();
      i2 = n2.width, a2 = e2.globals.axisCharts ? n2.height + 5 : n2.height;
    }
    return { width: i2, height: a2 };
  } }, { key: "getLegendsRect", value: function() {
    var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
    t3.config.legend.height || "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
    var i2 = Object.assign({}, v.getBoundingClientRect(e2));
    return null !== e2 && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: 0 === i2.height ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t3.config.legend.position && "right" !== t3.config.legend.position || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    e2.config.series.forEach((function(s3, r3) {
      s3.data.forEach((function(s4, n3) {
        var o2;
        o2 = e2.globals.series[r3][n3], a2 = e2.config.dataLabels.formatter(o2, { ctx: t3.dCtx.ctx, seriesIndex: r3, dataPointIndex: n3, w: e2 }), i2.push(a2);
      }));
    }));
    var a2 = v.getLargestStringFromArr(i2), s2 = new Mi(this.dCtx.ctx), r2 = e2.config.dataLabels.style, n2 = s2.getTextRects(a2, parseInt(r2.fontSize), r2.fontFamily);
    return { width: 1.05 * n2.width, height: n2.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
    var i2 = t3;
    if (this.w.globals.isMultiLineX) {
      var a2 = e2.map((function(t4, e3) {
        return Array.isArray(t4) ? t4.length : 1;
      })), s2 = Math.max.apply(Math, f(a2));
      i2 = e2[a2.indexOf(s2)];
    }
    return i2;
  } }]), t2;
})(), da = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getxAxisLabelsCoords", value: function() {
    var t3, e2 = this.w, i2 = e2.globals.labels.slice();
    if (e2.config.xaxis.convertedCatToNumeric && 0 === i2.length && (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
      var a2 = this.getxAxisTimeScaleLabelsCoords();
      t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
    } else {
      this.dCtx.lgWidthForSideLegends = "left" !== e2.config.legend.position && "right" !== e2.config.legend.position || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var s2 = e2.globals.xLabelFormatter, r2 = v.getLargestStringFromArr(i2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
      e2.globals.isBarHorizontal && (n2 = r2 = e2.globals.yAxisScale[0].result.reduce((function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }), 0));
      var o2 = new Xi(this.dCtx.ctx), l2 = r2;
      r2 = o2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), n2 = o2.xLabelFormat(s2, n2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && void 0 === r2 || "" === String(r2).trim()) && (n2 = r2 = "1");
      var h2 = new Mi(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
      if (r2 !== n2 && (d2 = h2.getTextRects(n2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i2.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e2.config.xaxis.labels.rotate || e2.config.xaxis.labels.rotateAlways) {
        if (!e2.globals.isBarHorizontal) {
          e2.globals.rotateXLabels = true;
          var u2 = function(t4) {
            return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
          };
          c2 = u2(r2), r2 !== n2 && (d2 = u2(n2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
        }
      } else e2.globals.rotateXLabels = false;
    }
    return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var t3, e2 = this.w;
    if (!e2.globals.hasXaxisGroups) return { width: 0, height: 0 };
    var i2, a2 = (null === (t3 = e2.config.xaxis.group.style) || void 0 === t3 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map((function(t4) {
      return t4.title;
    })), r2 = v.getLargestStringFromArr(s2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), o2 = new Mi(this.dCtx.ctx), l2 = o2.getTextRects(r2, a2), h2 = l2;
    return r2 !== n2 && (h2 = o2.getTextRects(n2, a2)), i2 = { width: l2.width >= h2.width ? l2.width : h2.width, height: l2.height >= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var t3 = this.w, e2 = 0, i2 = 0;
    if (void 0 !== t3.config.xaxis.title.text) {
      var a2 = new Mi(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
      e2 = a2.width, i2 = a2.height;
    }
    return { width: e2, height: i2 };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var t3, e2 = this.w;
    this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
    var i2 = this.dCtx.timescaleLabels.map((function(t4) {
      return t4.value;
    })), a2 = i2.reduce((function(t4, e3) {
      return void 0 === t4 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
    }), 0);
    return 1.05 * (t3 = new Mi(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length > e2.globals.gridWidth && 0 !== e2.config.xaxis.labels.rotate && (e2.globals.overlappingXLabels = true), t3;
  } }, { key: "additionalPaddingXLabels", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, n2 = t3.width;
    a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
    var o2 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l2 = function(t4, o3) {
      s2.yaxis.length > 1 && (function(t5) {
        return -1 !== a2.collapsedSeriesIndices.indexOf(t5);
      })(o3) || (function(t5) {
        if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
          var o4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + n2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = o4.position - n2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = "right" === i2.config.legend.position && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
          l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h2 < -(t5.show && !t5.floating || "bar" !== s2.chart.type && "candlestick" !== s2.chart.type && "rangeBar" !== s2.chart.type && "boxPlot" !== s2.chart.type ? 10 : n2 / 1.75) && (a2.skipFirstTimelinelabel = true);
        } else "datetime" === r2 ? e2.dCtx.gridPad.right < n2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : "datetime" !== r2 && e2.dCtx.gridPad.right < n2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i2.config.xaxis.labels.trim && (e2.dCtx.xPadRight = n2 / 2 + 1);
      })(t4);
    };
    s2.yaxis.forEach((function(t4, i3) {
      o2 ? (e2.dCtx.gridPad.left < n2 && (e2.dCtx.xPadLeft = n2 / 2 + 1), e2.dCtx.xPadRight = n2 / 2 + 1) : l2(t4, i3);
    }));
  } }]), t2;
})(), ua = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getyAxisLabelsCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new Ri(this.dCtx.ctx);
    return e2.config.yaxis.map((function(r2, n2) {
      var o2 = { seriesIndex: n2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[n2], h2 = 0;
      if (!s2.isYAxisHidden(n2) && r2.labels.show && void 0 !== r2.labels.minWidth && (h2 = r2.labels.minWidth), !s2.isYAxisHidden(n2) && r2.labels.show && l2.result.length) {
        var c2 = e2.globals.yLabelFormatters[n2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, u2 = l2.result.reduce((function(t4, e3) {
          var i3, a3;
          return (null === (i3 = String(c2(t4, o2))) || void 0 === i3 ? void 0 : i3.length) > (null === (a3 = String(c2(e3, o2))) || void 0 === a3 ? void 0 : a3.length) ? t4 : e3;
        }), d2), g2 = u2 = c2(u2, o2);
        if (void 0 !== u2 && 0 !== u2.length || (u2 = l2.niceMax), e2.globals.isBarHorizontal) {
          a2 = 0;
          var p2 = e2.globals.labels.slice();
          u2 = v.getLargestStringFromArr(p2), u2 = c2(u2, { seriesIndex: n2, dataPointIndex: -1, w: e2 }), g2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(u2, p2);
        }
        var f2 = new Mi(t3.dCtx.ctx), x2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), b2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false), m2 = b2;
        u2 !== g2 && (m2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false)), i2.push({ width: (h2 > m2.width || h2 > b2.width ? h2 : m2.width > b2.width ? m2.width : b2.width) + a2, height: m2.height > b2.height ? m2.height : b2.height });
      } else i2.push({ width: 0, height: 0 });
    })), i2;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = [];
    return e2.config.yaxis.map((function(e3, a2) {
      if (e3.show && void 0 !== e3.title.text) {
        var s2 = new Mi(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), n2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
        i2.push({ width: n2.width, height: n2.height });
      } else i2.push({ width: 0, height: 0 });
    })), i2;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new Ri(this.dCtx.ctx), n2 = function(n3, o2) {
      var l2 = t3.config.yaxis[o2].floating, h2 = 0;
      n3.width > 0 && !l2 ? (h2 = n3.width + s2, (function(e3) {
        return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
      })(o2) && (h2 = h2 - n3.width - s2)) : h2 = l2 || r2.isYAxisHidden(o2) ? 0 : 5, t3.config.yaxis[o2].opposite ? a2 += h2 : i2 += h2, e2 += h2;
    };
    return t3.globals.yLabelsCoords.map((function(t4, e3) {
      n2(t4, e3);
    })), t3.globals.yTitleCoords.map((function(t4, e3) {
      n2(t4, e3);
    })), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
  } }]), t2;
})(), ga = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
    var e2 = this.w, i2 = e2.config, a2 = e2.globals;
    if (a2.noData || a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.series.length) return 0;
    var s2 = function(t4) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(t4);
    }, r2 = i2.chart.type, n2 = 0, o2 = s2(r2) ? i2.series.length : 1;
    a2.comboBarCount > 0 && (o2 = a2.comboBarCount), a2.collapsedSeries.forEach((function(t4) {
      s2(t4.type) && (o2 -= 1);
    })), i2.chart.stacked && (o2 = 1);
    var l2 = s2(r2) || a2.comboBarCount > 0, h2 = Math.abs(a2.initialMaxX - a2.initialMinX);
    if (l2 && a2.isXNumeric && !a2.isBarHorizontal && o2 > 0 && 0 !== h2) {
      h2 <= 3 && (h2 = a2.dataPoints);
      var c2 = h2 / t3, d2 = a2.minXDiff && a2.minXDiff / c2 > 0 ? a2.minXDiff / c2 : 0;
      d2 > t3 / 2 && (d2 /= 2), (n2 = d2 * parseInt(i2.plotOptions.bar.columnWidth, 10) / 100) < 1 && (n2 = 1), a2.barPadForNumericAxis = n2;
    }
    return n2;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !i2.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach((function(s3) {
      void 0 !== e2.config[s3].text ? a2 += e2.config[s3].margin : a2 += t3.dCtx.isSparkline || !i2.axisCharts ? 0 : 5;
    })), !e2.config.legend.show || "bottom" !== e2.config.legend.position || e2.config.legend.floating || i2.axisCharts || (a2 += 10);
    var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i2.gridHeight -= s2.height + r2.height + a2, i2.translateY += s2.height + r2.height + a2;
  } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
    var i2 = this.w, a2 = new Ri(this.dCtx.ctx);
    i2.config.yaxis.forEach((function(s2, r2) {
      -1 !== i2.globals.ignoreYAxisIndexes.indexOf(r2) || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i2.globals.translateX -= e2[r2].width + t3[r2].width + parseInt(s2.labels.style.fontSize, 10) / 1.2 + 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
    }));
  } }]), t2;
})(), pa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ca(this), this.dimYAxis = new ua(this), this.dimXAxis = new da(this), this.dimGrid = new ga(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return s(t2, [{ key: "plotCoords", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var a2 = Array.isArray(e2.config.stroke.width) ? Math.max.apply(Math, f(e2.config.stroke.width)) : e2.config.stroke.width;
    this.isSparkline && ((e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach((function(e3) {
      var i3 = p(e3, 2), a3 = i3[0], s3 = i3[1];
      t3.gridPad[a3] = Math.max(s3, t3.w.globals.markers.largestSize / 1.5);
    })), this.gridPad.top = Math.max(a2 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a2 / 2, this.gridPad.bottom)), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var s2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
    i2.gridWidth = i2.gridWidth - 2 * s2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (s2 > 0 ? s2 : 0), i2.translateY = i2.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
    i2.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map((function(t4, i3) {
      e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
    })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var r2 = this.dimXAxis.getxAxisLabelsCoords(), n2 = this.dimXAxis.getxAxisGroupLabelsCoords(), o2 = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(r2, o2, n2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
    var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
    i2.xAxisLabelsHeight = this.xAxisHeight - o2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
    var c2 = 10;
    ("radar" === e2.config.chart.type || this.isSparkline) && (l2 = 0, h2 = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e2.config.chart.type) && (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || "treemap" === e2.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r2);
    var d2 = function() {
      i2.translateX = l2 + t3.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || "treemap" === e2.config.chart.type ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2 - 2 * t3.datalabelsCoords.width;
    };
    switch ("top" === e2.config.xaxis.position && (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
      case "bottom":
        i2.translateY = c2, d2();
        break;
      case "top":
        i2.translateY = this.lgRect.height + c2, d2();
        break;
      case "left":
        i2.translateY = c2, i2.translateX = this.lgRect.width + l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i2.translateY = c2, i2.translateX = l2 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(s2, a2), new ia(this.ctx).setYAxisXPosition(a2, s2);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
    t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
    var s2 = "pie" === i2.chart.type || "polarArea" === i2.chart.type || "donut" === i2.chart.type ? "pie" : "radialBar", r2 = i2.plotOptions[s2].offsetY, n2 = i2.plotOptions[s2].offsetX;
    if (!i2.legend.show || i2.legend.floating) {
      e2.gridHeight = e2.svgHeight;
      var o2 = e2.dom.elWrap.getBoundingClientRect().width;
      return e2.gridWidth = Math.min(o2, e2.gridHeight), e2.translateY = r2, void (e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2);
    }
    switch (i2.legend.position) {
      case "bottom":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "top":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "left":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + this.lgRect.width + a2;
        break;
      case "right":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, n2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, o2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && "bottom" === a2.config.legend.position ? 10 : 0;
    this.xAxisHeight = r2 * n2 + s2 * o2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
    var h2 = 0, c2 = 0;
    a2.config.yaxis.forEach((function(t4) {
      h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
    })), this.yAxisWidth < h2 && (this.yAxisWidth = h2), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
  } }]), t2;
})(), fa = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lgCtx = e2;
  }
  return s(t2, [{ key: "getLegendStyles", value: function() {
    var t3, e2, i2, a2 = document.createElement("style");
    a2.setAttribute("type", "text/css");
    var s2 = (null === (t3 = this.lgCtx.ctx) || void 0 === t3 || null === (e2 = t3.opts) || void 0 === e2 || null === (i2 = e2.chart) || void 0 === i2 ? void 0 : i2.nonce) || this.w.config.chart.nonce;
    s2 && a2.setAttribute("nonce", s2);
    var r2 = document.createTextNode("\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apexcharts-legend-group-horizontal {\n        flex-direction: column;\n      }\n      .apexcharts-legend-group {\n        display: flex;\n      }\n      .apexcharts-legend-group-vertical {\n        flex-direction: column-reverse;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n        align-items: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n        align-items: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }\n\n    ");
    return a2.appendChild(r2), a2;
  } }, { key: "getLegendDimensions", value: function() {
    var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
    return { clwh: t3.height, clww: e2 };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.axisCharts || "radialBar" === a2.config.chart.type) {
      a2.globals.resized = true;
      var s2 = null, r2 = null;
      if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2) [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach((function(t4) {
        i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
      }));
      else this.hideSeries({ seriesEl: s2, realIndex: r2 });
    } else {
      var n2 = a2.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), o2 = a2.config.chart.type;
      if ("pie" === o2 || "polarArea" === o2 || "donut" === o2) {
        var l2 = a2.config.plotOptions.pie.donut.labels;
        new Mi(this.lgCtx.ctx).pathMouseDown(n2, null), this.lgCtx.ctx.pie.printDataLabelsInner(n2.node, l2);
      }
      n2.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(t3) {
    var e2 = t3.realIndex, i2 = this.w, a2 = i2.globals, s2 = v.clone(i2.config.series);
    if (a2.axisCharts) {
      var r2 = i2.config.yaxis[a2.seriesYAxisReverseMap[e2]], n2 = { index: e2, data: s2[e2].data.slice(), type: s2[e2].type || i2.config.chart.type };
      if (r2 && r2.show && r2.showAlways) a2.ancillaryCollapsedSeriesIndices.indexOf(e2) < 0 && (a2.ancillaryCollapsedSeries.push(n2), a2.ancillaryCollapsedSeriesIndices.push(e2));
      else if (a2.collapsedSeriesIndices.indexOf(e2) < 0) {
        a2.collapsedSeries.push(n2), a2.collapsedSeriesIndices.push(e2);
        var o2 = a2.risingSeries.indexOf(e2);
        a2.risingSeries.splice(o2, 1);
      }
    } else a2.collapsedSeries.push({ index: e2, data: s2[e2] }), a2.collapsedSeriesIndices.push(e2);
    return a2.allSeriesCollapsed = a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i2.config.series.length, this._getSeriesBasedOnCollapsedState(s2);
  } }, { key: "hideSeries", value: function(t3) {
    for (var e2 = t3.seriesEl, i2 = t3.realIndex, a2 = this.w, s2 = this.getSeriesAfterCollapsing({ realIndex: i2 }), r2 = e2.childNodes, n2 = 0; n2 < r2.length; n2++) r2[n2].classList.contains("apexcharts-series-markers-wrap") && (r2[n2].classList.contains("apexcharts-hide") ? r2[n2].classList.remove("apexcharts-hide") : r2[n2].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = v.clone(a2.config.series);
    if (t3.length > 0) {
      for (var r2 = 0; r2 < t3.length; r2++) t3[r2].index === i2 && (a2.globals.axisCharts ? s2[i2].data = t3[r2].data.slice() : s2[i2] = t3[r2].data, "number" != typeof s2[i2] && (s2[i2].hidden = false), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2));
      s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
    var e2 = this.w, i2 = 0;
    return e2.globals.axisCharts ? t3.forEach((function(a2, s2) {
      e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) < 0 || (t3[s2].data = [], i2++);
    })) : t3.forEach((function(a2, s2) {
      !e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && (t3[s2] = 0, i2++);
    })), e2.globals.allSeriesCollapsed = i2 === t3.length, t3;
  } }]), t2;
})(), xa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new fa(this);
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.legend.showForSingleSeries && 1 === e2.series.length || this.isBarsDistributed || e2.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (a2 || !e2.axisCharts) && i2.legend.show) {
      for (; e2.dom.elLegendWrap.firstChild; ) e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
      this.drawLegends(), "bottom" === i2.legend.position || "top" === i2.legend.position ? this.legendAlignHorizontal() : "right" !== i2.legend.position && "left" !== i2.legend.position || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(t3) {
    var e2 = t3.i, i2 = t3.fillcolor, a2 = this.w, s2 = document.createElement("span");
    s2.classList.add("apexcharts-legend-marker");
    var r2 = a2.config.legend.markers.shape || a2.config.markers.shape, n2 = r2;
    Array.isArray(r2) && (n2 = r2[e2]);
    var o2 = Array.isArray(a2.config.legend.markers.size) ? parseFloat(a2.config.legend.markers.size[e2]) : parseFloat(a2.config.legend.markers.size), l2 = Array.isArray(a2.config.legend.markers.offsetX) ? parseFloat(a2.config.legend.markers.offsetX[e2]) : parseFloat(a2.config.legend.markers.offsetX), h2 = Array.isArray(a2.config.legend.markers.offsetY) ? parseFloat(a2.config.legend.markers.offsetY[e2]) : parseFloat(a2.config.legend.markers.offsetY), c2 = Array.isArray(a2.config.legend.markers.strokeWidth) ? parseFloat(a2.config.legend.markers.strokeWidth[e2]) : parseFloat(a2.config.legend.markers.strokeWidth), d2 = s2.style;
    if (d2.height = 2 * (o2 + c2) + "px", d2.width = 2 * (o2 + c2) + "px", d2.left = l2 + "px", d2.top = h2 + "px", a2.config.legend.markers.customHTML) d2.background = "transparent", d2.color = i2[e2], Array.isArray(a2.config.legend.markers.customHTML) ? a2.config.legend.markers.customHTML[e2] && (s2.innerHTML = a2.config.legend.markers.customHTML[e2]()) : s2.innerHTML = a2.config.legend.markers.customHTML();
    else {
      var g2 = new Vi(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n2), seriesIndex: e2, strokeWidth: c2, size: o2 }), p2 = window.SVG().addTo(s2).size("100%", "100%"), f2 = new Mi(this.ctx).drawMarker(0, 0, u(u({}, g2), {}, { pointFillColor: Array.isArray(i2) ? i2[e2] : g2.pointFillColor, shape: n2 }));
      a2.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach((function(t4) {
        t4.node.classList.contains("apexcharts-marker-triangle") ? t4.node.style.transform = "translate(50%, 45%)" : t4.node.style.transform = "translate(50%, 50%)";
      })), p2.add(f2);
    }
    return s2;
  } }, { key: "drawLegends", value: function() {
    var t3 = this, e2 = this, i2 = this.w, a2 = i2.config.legend.fontFamily, s2 = i2.globals.seriesNames, r2 = i2.config.legend.markers.fillColors ? i2.config.legend.markers.fillColors.slice() : i2.globals.colors.slice();
    if ("heatmap" === i2.config.chart.type) {
      var n2 = i2.config.plotOptions.heatmap.colorScale.ranges;
      s2 = n2.map((function(t4) {
        return t4.name ? t4.name : t4.from + " - " + t4.to;
      })), r2 = n2.map((function(t4) {
        return t4.color;
      }));
    } else this.isBarsDistributed && (s2 = i2.globals.labels.slice());
    i2.config.legend.customLegendItems.length && (s2 = i2.config.legend.customLegendItems);
    var o2 = i2.globals.legendFormatter, l2 = i2.config.legend.inverseOrder, h2 = [];
    i2.globals.seriesGroups.length > 1 && i2.config.legend.clusterGroupedSeries && i2.globals.seriesGroups.forEach((function(t4, e3) {
      h2[e3] = document.createElement("div"), h2[e3].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(e3)), "horizontal" === i2.config.legend.clusterGroupedSeriesOrientation ? i2.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h2[e3].classList.add("apexcharts-legend-group-vertical");
    }));
    for (var c2 = function(e3) {
      var n3, l3 = o2(s2[e3], { seriesIndex: e3, w: i2 }), c3 = false, d3 = false;
      if (i2.globals.collapsedSeries.length > 0) for (var u2 = 0; u2 < i2.globals.collapsedSeries.length; u2++) i2.globals.collapsedSeries[u2].index === e3 && (c3 = true);
      if (i2.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var g2 = 0; g2 < i2.globals.ancillaryCollapsedSeriesIndices.length; g2++) i2.globals.ancillaryCollapsedSeriesIndices[g2] === e3 && (d3 = true);
      var p2 = t3.createLegendMarker({ i: e3, fillcolor: r2 });
      Mi.setAttrs(p2, { rel: e3 + 1, "data:collapsed": c3 || d3 }), (c3 || d3) && p2.classList.add("apexcharts-inactive-legend");
      var f2 = document.createElement("div"), x2 = document.createElement("span");
      x2.classList.add("apexcharts-legend-text"), x2.innerHTML = Array.isArray(l3) ? l3.join(" ") : l3;
      var b2 = i2.config.legend.labels.useSeriesColors ? i2.globals.colors[e3] : Array.isArray(i2.config.legend.labels.colors) ? null === (n3 = i2.config.legend.labels.colors) || void 0 === n3 ? void 0 : n3[e3] : i2.config.legend.labels.colors;
      b2 || (b2 = i2.config.chart.foreColor), x2.style.color = b2, x2.style.fontSize = parseFloat(i2.config.legend.fontSize) + "px", x2.style.fontWeight = i2.config.legend.fontWeight, x2.style.fontFamily = a2 || i2.config.chart.fontFamily, Mi.setAttrs(x2, { rel: e3 + 1, i: e3, "data:default-text": encodeURIComponent(l3), "data:collapsed": c3 || d3 }), f2.appendChild(p2), f2.appendChild(x2);
      var m2 = new Pi(t3.ctx);
      i2.config.legend.showForZeroSeries || 0 === m2.getSeriesTotalByIndex(e3) && m2.seriesHaveSameValues(e3) && !m2.isSeriesNull(e3) && -1 === i2.globals.collapsedSeriesIndices.indexOf(e3) && -1 === i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) && f2.classList.add("apexcharts-hidden-zero-series");
      i2.config.legend.showForNullSeries || m2.isSeriesNull(e3) && -1 === i2.globals.collapsedSeriesIndices.indexOf(e3) && -1 === i2.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) && f2.classList.add("apexcharts-hidden-null-series"), h2.length ? i2.globals.seriesGroups.forEach((function(t4, a3) {
        var s3;
        t4.includes(null === (s3 = i2.config.series[e3]) || void 0 === s3 ? void 0 : s3.name) && (i2.globals.dom.elLegendWrap.appendChild(h2[a3]), h2[a3].appendChild(f2));
      })) : i2.globals.dom.elLegendWrap.appendChild(f2), i2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i2.config.legend.horizontalAlign)), i2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i2.config.legend.position), f2.classList.add("apexcharts-legend-series"), f2.style.margin = "".concat(i2.config.legend.itemMargin.vertical, "px ").concat(i2.config.legend.itemMargin.horizontal, "px"), i2.globals.dom.elLegendWrap.style.width = i2.config.legend.width ? i2.config.legend.width + "px" : "", i2.globals.dom.elLegendWrap.style.height = i2.config.legend.height ? i2.config.legend.height + "px" : "", Mi.setAttrs(f2, { rel: e3 + 1, seriesName: v.escapeString(s2[e3]), "data:collapsed": c3 || d3 }), (c3 || d3) && f2.classList.add("apexcharts-inactive-legend"), i2.config.legend.onItemClick.toggleDataSeries || f2.classList.add("apexcharts-no-click");
    }, d2 = l2 ? s2.length - 1 : 0; l2 ? d2 >= 0 : d2 <= s2.length - 1; l2 ? d2-- : d2++) c2(d2);
    i2.globals.dom.elWrap.addEventListener("click", e2.onLegendClick, true), i2.config.legend.onItemHover.highlightDataSeries && 0 === i2.config.legend.customLegendItems.length && (i2.globals.dom.elWrap.addEventListener("mousemove", e2.onLegendHovered, true), i2.globals.dom.elWrap.addEventListener("mouseout", e2.onLegendHovered, true));
  } }, { key: "setLegendWrapXY", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.globals.dom.elLegendWrap, s2 = a2.clientHeight, r2 = 0, n2 = 0;
    if ("bottom" === i2.config.legend.position) n2 = i2.globals.svgHeight - Math.min(s2, i2.globals.svgHeight / 2) - 5;
    else if ("top" === i2.config.legend.position) {
      var o2 = new pa(this.ctx), l2 = o2.dimHelpers.getTitleSubtitleCoords("title").height, h2 = o2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      n2 = (l2 > 0 ? l2 - 10 : 0) + (h2 > 0 ? h2 - 10 : 0);
    }
    a2.style.position = "absolute", r2 = r2 + t3 + i2.config.legend.offsetX, n2 = n2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = n2 + "px", "right" === i2.config.legend.position && (a2.style.left = "auto", a2.style.right = 25 + i2.config.legend.offsetX + "px");
    ["width", "height"].forEach((function(t4) {
      a2.style[t4] && (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + "px");
    }));
  } }, { key: "legendAlignHorizontal", value: function() {
    var t3 = this.w;
    t3.globals.dom.elLegendWrap.style.right = 0;
    var e2 = new pa(this.ctx), i2 = e2.dimHelpers.getTitleSubtitleCoords("title"), a2 = e2.dimHelpers.getTitleSubtitleCoords("subtitle"), s2 = 0;
    "top" === t3.config.legend.position && (s2 = i2.height + a2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, s2);
  } }, { key: "legendAlignVertical", value: function() {
    var t3 = this.w, e2 = this.legendHelpers.getLegendDimensions(), i2 = 0;
    "left" === t3.config.legend.position && (i2 = 20), "right" === t3.config.legend.position && (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
  } }, { key: "onLegendHovered", value: function(t3) {
    var e2 = this.w, i2 = t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
    if ("heatmap" === e2.config.chart.type || this.isBarsDistributed) {
      if (i2) {
        var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new Zi(this.ctx).highlightRangeInSeries(t3, t3.target);
      }
    } else !t3.target.classList.contains("apexcharts-inactive-legend") && i2 && new Zi(this.ctx).toggleSeriesOnHover(t3, t3.target);
  } }, { key: "onLegendClick", value: function(t3) {
    var e2 = this.w;
    if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
      var i2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = "true" === t3.target.getAttribute("data:collapsed"), s2 = this.w.config.chart.events.legendClick;
      "function" == typeof s2 && s2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
      var r2 = this.w.config.legend.markers.onClick;
      "function" == typeof r2 && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), "treemap" !== e2.config.chart.type && "heatmap" !== e2.config.chart.type && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a2);
    }
  } }]), t2;
})(), ba = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a2.globals.minX, this.maxX = a2.globals.maxX;
  }
  return s(t2, [{ key: "createToolbar", value: function() {
    var t3 = this, e2 = this.w, i2 = function() {
      return document.createElement("div");
    }, a2 = i2();
    if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s2 = 0; s2 < this.t.customIcons.length; s2++) this.elCustomIcons.push(i2());
    var r2 = [], n2 = function(i3, a3, s3) {
      var n3 = i3.toLowerCase();
      t3.t[n3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: "string" == typeof t3.t[n3] ? t3.t[n3] : s3, title: t3.localeValues[i3], class: "apexcharts-".concat(n3, "-icon") });
    };
    n2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
    var o2 = function(i3) {
      t3.t[i3] && e2.config.chart[i3].enabled && r2.push({ el: "zoom" === i3 ? t3.elZoom : t3.elSelection, icon: "string" == typeof t3.t[i3] ? t3.t[i3] : "zoom" === i3 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues["zoom" === i3 ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
    };
    o2("zoom"), o2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), n2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var l2 = 0; l2 < this.elCustomIcons.length; l2++) r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
    r2.forEach((function(t4, e3) {
      t4.index && v.moveIndexInArray(r2, e3, t4.index);
    }));
    for (var h2 = 0; h2 < r2.length; h2++) Mi.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
    this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(t3) {
    this.elMenuItems = [], t3.appendChild(this.elMenu), Mi.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i2 = 0; i2 < e2.length; i2++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e2[i2].title, Mi.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var t3 = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((function(e3) {
      e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
    }));
    for (var e2 = 0; e2 < this.t.customIcons.length; e2++) this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(t3) {
    this.ctx.getSyncedCharts().forEach((function(e2) {
      e2.ctx.toolbar.toggleOtherControls();
      var i2 = "selection" === t3 ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = "selection" === t3 ? "selectionEnabled" : "zoomEnabled";
      e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
    }));
  } }, { key: "getToolbarIconsReference", value: function() {
    var t3 = this.w;
    this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
    this.toggleOtherControls(), "pan" === t3 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
    var e2 = "pan" === t3 ? this.elPan : this.elZoom, i2 = "pan" === t3 ? this.elZoom : this.elPan;
    e2 && e2.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach((function(t3) {
      t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
    }));
  } }, { key: "toggleOtherControls", value: function() {
    var t3 = this, e2 = this.w;
    e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach((function(e3) {
      e3 && e3.classList.remove(t3.selectedClass);
    }));
  } }, { key: "handleZoomIn", value: function() {
    var t3 = this.w;
    t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
    var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
    t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var t3 = this.w;
    if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !("datetime" === t3.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
      var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
      t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
    var i2 = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
  } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
    var i2 = this.w;
    if (void 0 !== t3 || void 0 !== e2) {
      if (!(i2.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 < 2))) {
        var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
        s2 && (a2 = s2.xaxis);
        var r2 = { xaxis: a2 }, n2 = v.clone(i2.globals.initialConfig.yaxis);
        i2.config.chart.group || (r2.yaxis = n2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, n2);
      }
    } else this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(t3, e2) {
    "function" == typeof this.ev.zoomed && (this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 }), this.ctx.events.fireEvent("zoomed", { xaxis: t3, yaxis: e2 }));
  } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
    var i2 = null;
    return "function" == typeof this.ev.beforeZoom && (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
  } }, { key: "toggleMenu", value: function() {
    var t3 = this;
    window.setTimeout((function() {
      t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
    }), 0);
  } }, { key: "handleDownload", value: function(t3) {
    var e2 = this.w, i2 = new Ji(this.ctx);
    switch (t3) {
      case "svg":
        i2.exportToSVG(this.ctx);
        break;
      case "png":
        i2.exportToPng(this.ctx);
        break;
      case "csv":
        i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(t3) {
    this.ctx.getSyncedCharts().forEach((function(t4) {
      var e2 = t4.w;
      if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e2.config.chart.events.beforeResetZoom) {
        var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
        i2 && t4.updateHelpers.revertDefaultAxisMinMax(i2);
      }
      "function" == typeof e2.config.chart.events.zoomed && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
      var a2 = t4.ctx.series.emptyCollapsedSeries(v.clone(e2.globals.initialSeries));
      t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
    }));
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), t2;
})(), ma = (function(t2) {
  h(a2, ba);
  var e2 = n(a2);
  function a2(t3) {
    var s2;
    return i(this, a2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new Mi(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2.debounceTimer = null, s2.debounceDelay = 100, s2.wheelDelay = 400, s2;
  }
  return s(a2, [{ key: "init", value: function(t3) {
    var e3 = this, i2 = t3.xyRatios, a3 = this.w, s2 = this;
    this.xyRatios = i2, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a3.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new kt(0, 0, a3.globals.gridWidth, a3.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a3.globals.dom.Paper.add(this.zoomRect), a3.globals.dom.Paper.add(this.selectionRect), "x" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a3.globals.gridWidth, maxY: a3.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : "y" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a3.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a3.globals.dom.baseEl.querySelector("".concat(a3.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((function(t4) {
      e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i2), { capture: false, passive: true });
    })), a3.config.chart.zoom.enabled && a3.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s2.mouseWheelEvent.bind(s2), { capture: false, passive: false });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(t3, e3) {
    var i2 = this.w, a3 = this.ctx.toolbar, s2 = i2.globals.zoomEnabled ? i2.config.chart.zoom.type : i2.config.chart.selection.type, r2 = i2.config.chart.toolbar.autoSelected;
    if (e3.shiftKey ? (this.shiftWasPressed = true, a3.enableZoomPanFromToolbar("pan" === r2 ? "zoom" : "pan")) : this.shiftWasPressed && (a3.enableZoomPanFromToolbar(r2), this.shiftWasPressed = false), e3.target) {
      var n2, o2 = e3.target.classList;
      if (e3.target.parentNode && null !== e3.target.parentNode && (n2 = e3.target.parentNode.classList), !(o2.contains("apexcharts-legend-marker") || o2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
        if (this.clientX = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientX : "touchend" === e3.type ? e3.changedTouches[0].clientX : e3.clientX, this.clientY = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientY : "touchend" === e3.type ? e3.changedTouches[0].clientY : e3.clientY, "mousedown" === e3.type && 1 === e3.which || "touchstart" === e3.type) {
          var l2 = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - l2.left - i2.globals.barPadForNumericAxis, this.startY = this.clientY - l2.top, this.dragged = false, this.w.globals.mousedown = true;
        }
        ("mousemove" === e3.type && 1 === e3.which || "touchmove" === e3.type) && (this.dragged = true, i2.globals.panEnabled ? (i2.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: s2, xyRatios: t3 })) : (this.w.globals.mousedown && i2.globals.zoomEnabled || this.w.globals.mousedown && i2.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: s2 }))), "mouseup" !== e3.type && "touchend" !== e3.type && "mouseleave" !== e3.type || this.handleMouseUp({ zoomtype: s2 }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(t3) {
    var e3, i2 = t3.zoomtype, a3 = t3.isResized, s2 = this.w, r2 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    r2 && (this.w.globals.mousedown || a3) && (this.endX = this.clientX - r2.left - s2.globals.barPadForNumericAxis, this.endY = this.clientY - r2.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (s2.globals.zoomEnabled || s2.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: i2 })), s2.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = false, this.w.globals.mousedown = false;
  } }, { key: "mouseWheelEvent", value: function(t3) {
    var e3 = this, i2 = this.w;
    t3.preventDefault();
    var a3 = Date.now();
    a3 - i2.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout((function() {
      a3 - i2.globals.lastWheelExecution > e3.wheelDelay && (e3.executeMouseWheelZoom(t3), i2.globals.lastWheelExecution = a3);
    }), this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(t3) {
    var e3, i2 = this.w;
    this.minX = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, this.maxX = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    var a3 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    if (a3) {
      var s2, r2, n2, o2 = (t3.clientX - a3.left) / a3.width, l2 = this.minX, h2 = this.maxX, c2 = h2 - l2;
      if (t3.deltaY < 0) {
        var d2 = l2 + o2 * c2;
        r2 = d2 - (s2 = 0.5 * c2) / 2, n2 = d2 + s2 / 2;
      } else r2 = l2 - (s2 = 1.5 * c2) / 2, n2 = h2 + s2 / 2;
      if (!i2.globals.isRangeBar) {
        r2 = Math.max(r2, i2.globals.initialMinX), n2 = Math.min(n2, i2.globals.initialMaxX);
        var u2 = 0.01 * (i2.globals.initialMaxX - i2.globals.initialMinX);
        if (n2 - r2 < u2) {
          var g2 = (r2 + n2) / 2;
          r2 = g2 - u2 / 2, n2 = g2 + u2 / 2;
        }
      }
      var p2 = this._getNewMinXMaxX(r2, n2);
      isNaN(p2.minX) || isNaN(p2.maxX) || this.zoomUpdateOptions(p2.minX, p2.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var t3 = this, e3 = this.w;
    if (this.selectionRect) {
      var i2 = this.selectionRect.node.getBoundingClientRect();
      i2.width > 0 && i2.height > 0 && (this.selectionRect.select(false).resize(false), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(t4, e4, i3, a3, s2) {
        return "l" === s2 || "r" === s2 ? t4.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : t4.circle(0);
      }, updateHandle: function(t4, e4) {
        return t4.center(e4[0], e4[1]);
      } }).resize().on("resize", (function() {
        var i3 = e3.globals.zoomEnabled ? e3.config.chart.zoom.type : e3.config.chart.selection.type;
        t3.handleMouseUp({ zoomtype: i3, isResized: true });
      })));
    }
  } }, { key: "preselectedSelection", value: function() {
    var t3 = this.w, e3 = this.xyRatios;
    if (!t3.globals.zoomEnabled) {
      if (void 0 !== t3.globals.selection && null !== t3.globals.selection) this.drawSelectionRect(u(u({}, t3.globals.selection), {}, { translateX: t3.globals.translateX, translateY: t3.globals.translateY }));
      else if (void 0 !== t3.config.chart.selection.xaxis.min && void 0 !== t3.config.chart.selection.xaxis.max) {
        var i2 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a3 = t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i2;
        t3.globals.isRangeBar && (i2 = (t3.config.chart.selection.xaxis.min - t3.globals.yAxisScale[0].niceMin) / e3.invertedYRatio, a3 = (t3.config.chart.selection.xaxis.max - t3.config.chart.selection.xaxis.min) / e3.invertedYRatio);
        var s2 = { x: i2, y: 0, width: a3, height: t3.globals.gridHeight, translateX: t3.globals.translateX, translateY: t3.globals.translateY, selectionEnabled: true };
        this.drawSelectionRect(s2), this.makeSelectionRectDraggable(), "function" == typeof t3.config.chart.events.selection && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(t3) {
    var e3 = t3.x, i2 = t3.y, a3 = t3.width, s2 = t3.height, r2 = t3.translateX, n2 = void 0 === r2 ? 0 : r2, o2 = t3.translateY, l2 = void 0 === o2 ? 0 : o2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
    if (this.dragged || null !== h2.globals.selection) {
      var u2 = { transform: "translate(" + n2 + ", " + l2 + ")" };
      h2.globals.zoomEnabled && this.dragged && (a3 < 0 && (a3 = 1), c2.attr({ x: e3, y: i2, width: a3, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h2.config.chart.zoom.zoomedArea.stroke.opacity }), Mi.setAttrs(c2.node, u2)), h2.globals.selectionEnabled && (d2.attr({ x: e3, y: i2, width: a3 > 0 ? a3 : 0, height: s2 > 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, "fill-opacity": h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, "stroke-width": h2.config.chart.selection.stroke.width, "stroke-dasharray": h2.config.chart.selection.stroke.dashArray, "stroke-opacity": h2.config.chart.selection.stroke.opacity }), Mi.setAttrs(d2.node, u2));
    }
  } }, { key: "hideSelectionRect", value: function(t3) {
    t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(t3) {
    var e3 = t3.context, i2 = t3.zoomtype, a3 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), n2 = s2.startX - 1, o2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - a3.globals.barPadForNumericAxis, d2 = s2.clientY - r2.top, g2 = c2 - n2, p2 = d2 - o2, f2 = { translateX: a3.globals.translateX, translateY: a3.globals.translateY };
    return Math.abs(g2 + n2) > a3.globals.gridWidth ? g2 = a3.globals.gridWidth - n2 : c2 < 0 && (g2 = n2), n2 > c2 && (l2 = true, g2 = Math.abs(g2)), o2 > d2 && (h2 = true, p2 = Math.abs(p2)), f2 = u(u({}, f2 = "x" === i2 ? { x: l2 ? n2 - g2 : n2, y: 0, width: g2, height: a3.globals.gridHeight } : "y" === i2 ? { x: 0, y: h2 ? o2 - p2 : o2, width: a3.globals.gridWidth, height: p2 } : { x: l2 ? n2 - g2 : n2, y: h2 ? o2 - p2 : o2, width: g2, height: p2 }), {}, { translateX: a3.globals.translateX, translateY: a3.globals.translateY }), s2.drawSelectionRect(f2), s2.selectionDragging("resizing"), f2;
  } }, { key: "selectionDragging", value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    if (e3) {
      e3.preventDefault();
      var s2 = e3.detail, r2 = s2.handler, n2 = s2.box, o2 = n2.x, l2 = n2.y;
      o2 < this.constraints.x && (o2 = this.constraints.x), l2 < this.constraints.y && (l2 = this.constraints.y), n2.x2 > this.constraints.x2 && (o2 = this.constraints.x2 - n2.w), n2.y2 > this.constraints.y2 && (l2 = this.constraints.y2 - n2.h), r2.move(o2, l2);
      var h2 = this.xyRatios, c2 = this.selectionRect, d2 = 0;
      "resizing" === t3 && (d2 = 30);
      var u2 = function(t4) {
        return parseFloat(c2.node.getAttribute(t4));
      }, g2 = { x: u2("x"), y: u2("y"), width: u2("width"), height: u2("height") };
      a3.globals.selection = g2, "function" == typeof a3.config.chart.events.selection && a3.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((function() {
        var t4, e4, s3, r3, n3 = i2.gridRect.getBoundingClientRect(), o3 = c2.node.getBoundingClientRect();
        a3.globals.isRangeBar ? (t4 = a3.globals.yAxisScale[0].niceMin + (o3.left - n3.left) * h2.invertedYRatio, e4 = a3.globals.yAxisScale[0].niceMin + (o3.right - n3.left) * h2.invertedYRatio, s3 = 0, r3 = 1) : (t4 = a3.globals.xAxisScale.niceMin + (o3.left - n3.left) * h2.xRatio, e4 = a3.globals.xAxisScale.niceMin + (o3.right - n3.left) * h2.xRatio, s3 = a3.globals.yAxisScale[0].niceMin + (n3.bottom - o3.bottom) * h2.yRatio[0], r3 = a3.globals.yAxisScale[0].niceMax - (o3.top - n3.top) * h2.yRatio[0]);
        var l3 = { xaxis: { min: t4, max: e4 }, yaxis: { min: s3, max: r3 } };
        a3.config.chart.events.selection(i2.ctx, l3), a3.config.chart.brush.enabled && void 0 !== a3.config.chart.events.brushScrolled && a3.config.chart.events.brushScrolled(i2.ctx, l3);
      }), d2));
    }
  } }, { key: "selectionDrawn", value: function(t3) {
    var e3, i2, a3 = t3.context, s2 = t3.zoomtype, r2 = this.w, n2 = a3, o2 = this.xyRatios, l2 = this.ctx.toolbar, h2 = r2.globals.zoomEnabled ? n2.zoomRect.node.getBoundingClientRect() : n2.selectionRect.node.getBoundingClientRect(), c2 = n2.gridRect.getBoundingClientRect(), d2 = h2.left - c2.left - r2.globals.barPadForNumericAxis, u2 = h2.right - c2.left - r2.globals.barPadForNumericAxis, g2 = h2.top - c2.top, p2 = h2.bottom - c2.top;
    r2.globals.isRangeBar ? (e3 = r2.globals.yAxisScale[0].niceMin + d2 * o2.invertedYRatio, i2 = r2.globals.yAxisScale[0].niceMin + u2 * o2.invertedYRatio) : (e3 = r2.globals.xAxisScale.niceMin + d2 * o2.xRatio, i2 = r2.globals.xAxisScale.niceMin + u2 * o2.xRatio);
    var f2 = [], x2 = [];
    if (r2.config.yaxis.forEach((function(t4, e4) {
      var i3 = r2.globals.seriesYAxisMap[e4][0], a4 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * g2, s3 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i3] * p2;
      f2.push(a4), x2.push(s3);
    })), n2.dragged && (n2.dragX > 10 || n2.dragY > 10) && e3 !== i2) {
      if (r2.globals.zoomEnabled) {
        var b2 = v.clone(r2.globals.initialConfig.yaxis), m2 = v.clone(r2.globals.initialConfig.xaxis);
        if (r2.globals.zoomed = true, r2.config.xaxis.convertedCatToNumeric && (e3 = Math.floor(e3), i2 = Math.floor(i2), e3 < 1 && (e3 = 1, i2 = r2.globals.dataPoints), i2 - e3 < 2 && (i2 = e3 + 1)), "xy" !== s2 && "x" !== s2 || (m2 = { min: e3, max: i2 }), "xy" !== s2 && "y" !== s2 || b2.forEach((function(t4, e4) {
          b2[e4].min = x2[e4], b2[e4].max = f2[e4];
        })), l2) {
          var y2 = l2.getBeforeZoomRange(m2, b2);
          y2 && (m2 = y2.xaxis ? y2.xaxis : m2, b2 = y2.yaxis ? y2.yaxis : b2);
        }
        var w2 = { xaxis: m2 };
        r2.config.chart.group || (w2.yaxis = b2), n2.ctx.updateHelpers._updateOptions(w2, false, n2.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof r2.config.chart.events.zoomed && l2.zoomCallback(m2, b2);
      } else if (r2.globals.selectionEnabled) {
        var k2, A2 = null;
        k2 = { min: e3, max: i2 }, "xy" !== s2 && "y" !== s2 || (A2 = v.clone(r2.config.yaxis)).forEach((function(t4, e4) {
          A2[e4].min = x2[e4], A2[e4].max = f2[e4];
        })), r2.globals.selection = n2.selection, "function" == typeof r2.config.chart.events.selection && r2.config.chart.events.selection(n2.ctx, { xaxis: k2, yaxis: A2 });
      }
    }
  } }, { key: "panDragging", value: function(t3) {
    var e3 = t3.context, i2 = this.w, a3 = e3;
    if (void 0 !== i2.globals.lastClientPosition.x) {
      var s2 = i2.globals.lastClientPosition.x - a3.clientX, r2 = i2.globals.lastClientPosition.y - a3.clientY;
      Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
    }
    i2.globals.lastClientPosition = { x: a3.clientX, y: a3.clientY };
    var n2 = i2.globals.isRangeBar ? i2.globals.minY : i2.globals.minX, o2 = i2.globals.isRangeBar ? i2.globals.maxY : i2.globals.maxX;
    a3.panScrolled(n2, o2);
  } }, { key: "panScrolled", value: function(t3, e3) {
    var i2 = this.w, a3 = this.xyRatios, s2 = v.clone(i2.globals.initialConfig.yaxis), r2 = a3.xRatio, n2 = i2.globals.minX, o2 = i2.globals.maxX;
    i2.globals.isRangeBar && (r2 = a3.invertedYRatio, n2 = i2.globals.minY, o2 = i2.globals.maxY), "left" === this.moveDirection ? (t3 = n2 + i2.globals.gridWidth / 15 * r2, e3 = o2 + i2.globals.gridWidth / 15 * r2) : "right" === this.moveDirection && (t3 = n2 - i2.globals.gridWidth / 15 * r2, e3 = o2 - i2.globals.gridWidth / 15 * r2), i2.globals.isRangeBar || (t3 < i2.globals.initialMinX || e3 > i2.globals.initialMaxX) && (t3 = n2, e3 = o2);
    var l2 = { xaxis: { min: t3, max: e3 } };
    i2.config.chart.group || (l2.yaxis = s2), this.updateScrolledChart(l2, t3, e3);
  } }, { key: "updateScrolledChart", value: function(t3, e3, i2) {
    var a3 = this.w;
    if (this.ctx.updateHelpers._updateOptions(t3, false, false), "function" == typeof a3.config.chart.events.scrolled) {
      var s2 = { xaxis: { min: e3, max: i2 } };
      a3.config.chart.events.scrolled(this.ctx, s2), this.ctx.events.fireEvent("scrolled", s2);
    }
  } }]), a2;
})(), va = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
  }
  return s(t2, [{ key: "getNearestValues", value: function(t3) {
    var e2 = t3.hoverArea, i2 = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, n2 = i2.getBoundingClientRect(), o2 = n2.width, l2 = n2.height, h2 = o2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
    !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = o2 / r2.globals.dataPoints);
    var u2 = a2 - n2.left - r2.globals.barPadForNumericAxis, g2 = s2 - n2.top;
    u2 < 0 || g2 < 0 || u2 > o2 || g2 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
    var p2 = Math.round(u2 / h2), f2 = Math.floor(g2 / c2);
    d2 && !r2.config.xaxis.convertedCatToNumeric && (p2 = Math.ceil(u2 / h2), p2 -= 1);
    var x2 = null, b2 = null, m2 = r2.globals.seriesXvalues.map((function(t4) {
      return t4.filter((function(t5) {
        return v.isNumber(t5);
      }));
    })), y2 = r2.globals.seriesYvalues.map((function(t4) {
      return t4.filter((function(t5) {
        return v.isNumber(t5);
      }));
    }));
    if (r2.globals.isXNumeric) {
      var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = u2 * (w2.width / o2), A2 = g2 * (w2.height / l2);
      x2 = (b2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = b2.j, null !== x2 && r2.globals.hasNullValues && (m2 = r2.globals.seriesXvalues[x2], p2 = (b2 = this.closestInArray(k2, m2)).j);
    }
    return r2.globals.capturedSeriesIndex = null === x2 ? -1 : x2, (!p2 || p2 < 1) && (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: x2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: u2, hoverY: g2 };
  } }, { key: "getFirstActiveXArray", value: function(t3) {
    for (var e2 = this.w, i2 = 0, a2 = t3.map((function(t4, e3) {
      return t4.length > 0 ? e3 : -1;
    })), s2 = 0; s2 < a2.length; s2++) if (-1 !== a2[s2] && -1 === e2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) {
      i2 = a2[s2];
      break;
    }
    return i2;
  } }, { key: "closestInMultiArray", value: function(t3, e2, i2, a2) {
    for (var s2, r2 = this.w, n2 = 1 / 0, o2 = null, l2 = null, h2 = 0; h2 < i2.length; h2++) if (s2 = h2, -1 === r2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === r2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) for (var c2 = i2[h2], d2 = a2[h2], u2 = Math.min(c2.length, d2.length), g2 = 0; g2 < u2; g2++) {
      var p2 = t3 - c2[g2], f2 = Math.sqrt(p2 * p2);
      if (!r2.globals.allSeriesHasEqualX) {
        var x2 = e2 - d2[g2];
        f2 = Math.sqrt(p2 * p2 + x2 * x2);
      }
      f2 < n2 && (n2 = f2, o2 = h2, l2 = g2);
    }
    return { index: o2, j: l2 };
  } }, { key: "closestInArray", value: function(t3, e2) {
    for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0; r2 < e2.length; r2++) {
      var n2 = Math.abs(t3 - e2[r2]);
      n2 < s2 && (s2 = n2, a2 = r2);
    }
    return { j: a2 };
  } }, { key: "isXoverlap", value: function(t3) {
    var e2 = [], i2 = this.w.globals.seriesX.filter((function(t4) {
      return void 0 !== t4[0];
    }));
    if (i2.length > 0) for (var a2 = 0; a2 < i2.length - 1; a2++) void 0 !== i2[a2][t3] && void 0 !== i2[a2 + 1][t3] && i2[a2][t3] !== i2[a2 + 1][t3] && e2.push("unEqual");
    return 0 === e2.length;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0; i2 < e2.length - 1; i2++) if (e2[i2].data.length !== e2[i2 + 1].data.length) {
      t3 = false;
      break;
    }
    return t3;
  } }, { key: "getBarsHeight", value: function(t3) {
    return f(t3).reduce((function(t4, e2) {
      return t4 + e2.getBBox().height;
    }), 0);
  } }, { key: "getElMarkers", value: function(t3) {
    return "number" == typeof t3 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i2 = f(i2), e2 && (i2 = i2.filter((function(e3) {
      var i3 = Number(e3.getAttribute("data:realIndex"));
      return -1 === t3.w.globals.collapsedSeriesIndices.indexOf(i3);
    }))), i2.sort((function(t4, e3) {
      var i3 = Number(t4.getAttribute("data:realIndex")), a3 = Number(e3.getAttribute("data:realIndex"));
      return a3 < i3 ? 1 : a3 > i3 ? -1 : 0;
    }));
    var a2 = [];
    return i2.forEach((function(t4) {
      a2.push(t4.querySelector(".apexcharts-marker"));
    })), a2;
  } }, { key: "hasMarkers", value: function(t3) {
    return this.getElMarkers(t3).length > 0;
  } }, { key: "getPathFromPoint", value: function(t3, e2) {
    var i2 = Number(t3.getAttribute("cx")), a2 = Number(t3.getAttribute("cy")), s2 = t3.getAttribute("shape");
    return new Mi(this.ctx).getMarkerPath(i2, a2, s2, e2);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(t3) {
    var e2 = this.w, i2 = e2.config.markers.hover.size;
    return void 0 === i2 && (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    0 === i2.allTooltipSeriesGroups.length && (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var a2 = i2.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++) "enable" === t3 ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
  } }]), t2;
})(), ya = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new va(e2);
  }
  return s(t2, [{ key: "drawSeriesTexts", value: function(t3) {
    var e2 = t3.shared, i2 = void 0 === e2 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = void 0 === s2 ? 0 : s2, n2 = t3.j, o2 = void 0 === n2 ? null : n2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
    void 0 !== d2.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: o2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i2, r2);
    var u2 = this.getValuesToPrint({ i: r2, j: o2 });
    this.printLabels({ i: r2, j: o2, values: u2, ttItems: a2, shared: i2, e: c2 });
    var g2 = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = g2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g2.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(t3) {
    var e2, i2 = this, a2 = t3.i, s2 = t3.j, r2 = t3.values, n2 = t3.ttItems, o2 = t3.shared, l2 = t3.e, h2 = this.w, c2 = [], d2 = function(t4) {
      return h2.globals.seriesGoals[t4] && h2.globals.seriesGoals[t4][s2] && Array.isArray(h2.globals.seriesGoals[t4][s2]);
    }, g2 = r2.xVal, p2 = r2.zVal, f2 = r2.xAxisTTVal, x2 = "", b2 = h2.globals.colors[a2];
    null !== s2 && h2.config.plotOptions.bar.distributed && (b2 = h2.globals.colors[s2]);
    for (var m2 = function(t4, r3) {
      var m3 = i2.getFormatters(a2);
      x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: a2, seriesIndex: a2, j: s2 }), "treemap" === h2.config.chart.type && (x2 = m3.yLbTitleFormatter(String(h2.config.series[a2].data[s2].x), { series: h2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: h2 }));
      var v3 = h2.config.tooltip.inverseOrder ? r3 : t4;
      if (h2.globals.axisCharts) {
        var y3 = function(t5) {
          var e3, i3, a3, r4;
          return h2.globals.isRangeData ? m3.yLbFormatter(null === (e3 = h2.globals.seriesRangeStart) || void 0 === e3 || null === (i3 = e3[t5]) || void 0 === i3 ? void 0 : i3[s2], { series: h2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: s2, w: h2 }) + " - " + m3.yLbFormatter(null === (a3 = h2.globals.seriesRangeEnd) || void 0 === a3 || null === (r4 = a3[t5]) || void 0 === r4 ? void 0 : r4[s2], { series: h2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: s2, w: h2 }) : m3.yLbFormatter(h2.globals.series[t5][s2], { series: h2.globals.series, seriesIndex: t5, dataPointIndex: s2, w: h2 });
        };
        if (o2) m3 = i2.getFormatters(v3), x2 = i2.getSeriesName({ fn: m3.yLbTitleFormatter, index: v3, seriesIndex: a2, j: s2 }), b2 = h2.globals.colors[v3], e2 = y3(v3), d2(v3) && (c2 = h2.globals.seriesGoals[v3][s2].map((function(t5) {
          return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: v3, dataPointIndex: s2, w: h2 }) };
        })));
        else {
          var w2, k2 = null == l2 || null === (w2 = l2.target) || void 0 === w2 ? void 0 : w2.getAttribute("fill");
          k2 && (-1 !== k2.indexOf("url") ? -1 !== k2.indexOf("Pattern") && (b2 = h2.globals.dom.baseEl.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : b2 = k2), e2 = y3(a2), d2(a2) && Array.isArray(h2.globals.seriesGoals[a2][s2]) && (c2 = h2.globals.seriesGoals[a2][s2].map((function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: a2, dataPointIndex: s2, w: h2 }) };
          })));
        }
      }
      null === s2 && (e2 = m3.yLbFormatter(h2.globals.series[a2], u(u({}, h2), {}, { seriesIndex: a2, dataPointIndex: a2 }))), i2.DOMHandling({ i: a2, t: v3, j: s2, ttItems: n2, values: { val: e2, goalVals: c2, xVal: g2, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: o2, pColor: b2 });
    }, v2 = 0, y2 = h2.globals.series.length - 1; v2 < h2.globals.series.length; v2++, y2--) m2(v2, y2);
  } }, { key: "getFormatters", value: function(t3) {
    var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
    return void 0 !== i2.globals.ttVal ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].title && i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, "function" == typeof i2.globals.ttVal.title.formatter && (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, "function" != typeof a2 && (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
      return t4;
    }), "function" != typeof e2 && (e2 = function(t4) {
      return t4 ? t4 + ": " : "";
    }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
  } }, { key: "getSeriesName", value: function(t3) {
    var e2 = t3.fn, i2 = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
    return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
  } }, { key: "DOMHandling", value: function(t3) {
    t3.i;
    var e2 = t3.t, i2 = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, n2 = t3.shared, o2 = t3.pColor, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, u2 = s2.xVal, g2 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
    f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = o2, f2[0].style.display = "none"), h2.showTooltipTitle && (null === h2.tooltipTitle && (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h2.tooltipTitle.innerHTML = u2), h2.isXAxisTooltipEnabled && (h2.xaxisTooltipText.innerHTML = "" !== g2 ? g2 : u2);
    var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
    x2 && (x2.innerHTML = r2 || "");
    var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
    b2 && (b2.innerHTML = void 0 !== c2 ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (o2 = l2.config.tooltip.marker.fillColors[e2]), l2.config.tooltip.fillSeriesColor ? f2[0].style.backgroundColor = o2 : f2[0].style.color = o2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
    var m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
    if (d2.length && l2.globals.seriesGoals[e2]) {
      var y2 = function() {
        var t4 = "<div>", e3 = "<div>";
        d2.forEach((function(i3, a3) {
          t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e3 += "<div>".concat(i3.val, "</div>");
        })), m2.innerHTML = t4 + "</div>", v2.innerHTML = e3 + "</div>";
      };
      n2 ? l2.globals.seriesGoals[e2][i2] && Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (m2.innerHTML = "", v2.innerHTML = "") : y2();
    } else m2.innerHTML = "", v2.innerHTML = "";
    null !== p2 && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p2 ? p2 : "");
    if (n2 && f2[0]) {
      if (l2.config.tooltip.hideEmptySeries) {
        var w2 = a2[e2].querySelector(".apexcharts-tooltip-marker"), k2 = a2[e2].querySelector(".apexcharts-tooltip-text");
        0 == parseFloat(c2) ? (w2.style.display = "none", k2.style.display = "none") : (w2.style.display = "block", k2.style.display = "block");
      }
      null == c2 || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 || Array.isArray(h2.tConfig.enabledOnSeries) && -1 === h2.tConfig.enabledOnSeries.indexOf(e2) ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display;
    } else Array.isArray(h2.tConfig.enabledOnSeries) && -1 === h2.tConfig.enabledOnSeries.indexOf(e2) && (f2[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(t3, e2) {
    var i2 = this.w;
    if (t3) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e2));
      a2 && (a2.classList.add("apexcharts-active"), a2.style.display = i2.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(t3) {
    var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", n2 = "", o2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
    null === i2 ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && "treemap" !== a2.config.chart.type ? (r2 = s2[e2][i2], 0 === s2[e2].length && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = new $i(this.ctx).isFormatXY() ? void 0 !== a2.config.series[e2].data[i2] ? a2.config.series[e2].data[i2].x : "" : void 0 !== a2.globals.labels[i2] ? a2.globals.labels[i2] : "";
    var d2 = r2;
    a2.globals.isXNumeric && "datetime" === a2.config.xaxis.type ? r2 = new Xi(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
    return void 0 !== a2.config.tooltip.x.formatter && (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (o2 = c2(a2.globals.seriesZ[e2][i2], a2)), n2 = "function" == typeof a2.config.xaxis.tooltip.formatter ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(n2) ? n2.join(" ") : n2, zVal: o2 };
  } }, { key: "handleCustomTooltip", value: function(t3) {
    var e2 = t3.i, i2 = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, n2 = this.ttCtx.getElTooltip(), o2 = r2.config.tooltip.custom;
    Array.isArray(o2) && o2[e2] && (o2 = o2[e2]);
    var l2 = o2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
    "string" == typeof l2 || "number" == typeof l2 ? n2.innerHTML = l2 : (l2 instanceof Element || "string" == typeof l2.nodeName) && (n2.innerHTML = "", n2.appendChild(l2.cloneNode(true)));
  } }]), t2;
})(), wa = (function() {
  function t2(e2) {
    i(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
  }
  return s(t2, [{ key: "moveXCrosshairs", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, n2 = a2.globals.labels.slice().length;
    if (null !== e2 && (r2 = a2.globals.gridWidth / n2 * e2), null === s2 || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
      var o2 = r2;
      "tickWidth" !== a2.config.xaxis.crosshairs.width && "barWidth" !== a2.config.xaxis.crosshairs.width || (o2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(o2);
    }
  } }, { key: "moveYCrosshairs", value: function(t3) {
    var e2 = this.ttCtx;
    null !== e2.ycrosshairs && Mi.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), null !== e2.ycrosshairsHidden && Mi.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
  } }, { key: "moveXAxisTooltip", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    if (null !== i2.xaxisTooltip && 0 !== i2.xcrosshairsWidth) {
      i2.xaxisTooltip.classList.add("apexcharts-active");
      var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
      if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
        t3 += e2.globals.translateX;
        var s2;
        s2 = new Mi(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + "px", i2.xaxisTooltip.style.left = t3 + "px", i2.xaxisTooltip.style.top = a2 + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(t3) {
    var e2 = this.w, i2 = this.ttCtx;
    null === i2.yaxisTTEls && (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var a2 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect(), n2 = r2.height, o2 = e2.globals.translateYAxisX[t3] - 2;
    e2.config.yaxis[t3].opposite && (o2 -= r2.width), s2 -= n2 / 2, -1 === e2.globals.ignoreYAxisIndexes.indexOf(t3) && s2 > 0 && s2 < e2.globals.gridHeight ? (i2.yaxisTTEls[t3].classList.add("apexcharts-active"), i2.yaxisTTEls[t3].style.top = s2 + "px", i2.yaxisTTEls[t3].style.left = o2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i2.yaxisTTEls[t3].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), n2 = s2.tooltipRect, o2 = null !== i2 ? parseFloat(i2) : 1, l2 = parseFloat(t3) + o2 + 5, h2 = parseFloat(e2) + o2 / 2;
    if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - n2.ttWidth - o2 - 10), l2 > a2.globals.gridWidth - n2.ttWidth - 10 && (l2 = a2.globals.gridWidth - n2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
      var c2 = s2.getElGrid().getBoundingClientRect();
      (l2 = s2.e.clientX - c2.left) > a2.globals.gridWidth / 2 && (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) > a2.globals.gridHeight / 2 && (h2 -= s2.tooltipRect.ttHeight);
    } else a2.globals.isBarHorizontal || n2.ttHeight / 2 + h2 > a2.globals.gridHeight && (h2 = a2.globals.gridHeight - n2.ttHeight + a2.globals.translateY);
    isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h2 + "px");
  } }, { key: "moveMarkers", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx;
    if (i2.globals.markers.size[t3] > 0) for (var s2 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0; r2 < s2.length; r2++) parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
    else a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
  } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
    var i2, a2, s2, r2, n2 = this.w, o2 = this.ttCtx, l2 = new Mi(this.ctx), h2 = n2.globals.pointsArray, c2 = o2.tooltipUtil.getHoverMarkerSize(e2), d2 = n2.config.series[e2].type;
    if (!d2 || "column" !== d2 && "candlestick" !== d2 && "boxPlot" !== d2) {
      s2 = null === (i2 = h2[e2][t3]) || void 0 === i2 ? void 0 : i2[0], r2 = (null === (a2 = h2[e2][t3]) || void 0 === a2 ? void 0 : a2[1]) || 0;
      var u2 = n2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers path"));
      if (u2 && r2 < n2.globals.gridHeight && r2 > 0) {
        var g2 = u2.getAttribute("shape"), p2 = l2.getMarkerPath(s2, r2, g2, 1.5 * c2);
        u2.setAttribute("d", p2);
      }
      this.moveXCrosshairs(s2), o2.fixedTooltip || this.moveTooltip(s2, r2, c2);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
    var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, n2 = a2.globals.pointsArray, o2 = new Zi(this.ctx), l2 = new Mi(this.ctx);
    e2 = o2.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h2 = i2.tooltipUtil.getHoverMarkerSize(e2);
    if (n2[e2] && (s2 = n2[e2][t3][0], r2 = n2[e2][t3][1]), !isNaN(s2)) {
      var c2 = i2.tooltipUtil.getAllMarkers();
      if (c2.length) for (var d2 = 0; d2 < a2.globals.series.length; d2++) {
        var u2 = n2[d2];
        if (a2.globals.comboCharts && void 0 === u2 && c2.splice(d2, 0, null), u2 && u2.length) {
          var g2 = n2[d2][t3][1], p2 = void 0;
          c2[d2].setAttribute("cx", s2);
          var f2 = c2[d2].getAttribute("shape");
          if ("rangeArea" === a2.config.chart.type && !a2.globals.comboCharts) {
            var x2 = t3 + a2.globals.series[d2].length;
            p2 = n2[d2][x2][1], g2 -= Math.abs(g2 - p2) / 2;
          }
          if (null !== g2 && !isNaN(g2) && g2 < a2.globals.gridHeight + h2 && g2 + h2 > 0) {
            var b2 = l2.getMarkerPath(s2, g2, f2, h2);
            c2[d2].setAttribute("d", b2);
          } else c2[d2].setAttribute("d", "");
        }
      }
      this.moveXCrosshairs(s2), i2.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, h2);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ttCtx, s2 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length;
    i2.config.chart.stacked && (s2 = i2.globals.barGroups.length);
    var r2 = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
    i2.globals.isBarHorizontal && (r2 = new Zi(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "']"));
    n2 || "number" != typeof e2 || (n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "']")));
    var o2 = n2 ? parseFloat(n2.getAttribute("cx")) : 0, l2 = n2 ? parseFloat(n2.getAttribute("cy")) : 0, h2 = n2 ? parseFloat(n2.getAttribute("barWidth")) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = n2 && (n2.classList.contains("apexcharts-candlestick-area") || n2.classList.contains("apexcharts-boxPlot-area"));
    i2.globals.isXNumeric ? (n2 && !d2 && (o2 -= s2 % 2 != 0 ? h2 / 2 : 0), n2 && d2 && (o2 -= h2 / 2)) : i2.globals.isBarHorizontal || (o2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(o2) && (o2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 > i2.globals.gridHeight && (l2 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(o2), a2.fixedTooltip || this.moveTooltip(o2, l2 || i2.globals.gridHeight);
  } }]), t2;
})(), ka = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new wa(e2);
  }
  return s(t2, [{ key: "drawDynamicPoints", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i2 = new Vi(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    a2 = f(a2), t3.config.chart.stacked && a2.sort((function(t4, e3) {
      return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
    }));
    for (var s2 = 0; s2 < a2.length; s2++) {
      var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
      if (null !== r2) {
        var n2 = void 0, o2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        "line" !== t3.config.chart.type && "area" !== t3.config.chart.type || t3.globals.comboCharts || t3.config.tooltip.intersect || (o2 += " no-pointer-events");
        var l2 = i2.getMarkerConfig({ cssClass: o2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
        (n2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
        var h2 = document.createElementNS(t3.globals.SVGNS, "g");
        h2.classList.add("apexcharts-series-markers"), h2.appendChild(n2.node), r2.appendChild(h2);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w;
    "bubble" !== s2.config.chart.type && this.newPointSize(t3, e2);
    var r2 = e2.getAttribute("cx"), n2 = e2.getAttribute("cy");
    if (null !== i2 && null !== a2 && (r2 = i2, n2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
      if ("radar" === s2.config.chart.type) {
        var o2 = this.ttCtx.getElGrid().getBoundingClientRect();
        r2 = this.ttCtx.e.clientX - o2.left;
      }
      this.tooltipPosition.moveTooltip(r2, n2, s2.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(t3) {
    for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n2 = e2.config.markers.hover.size, o2 = 0; o2 < r2.length; o2++) {
      var l2 = r2[o2].getAttribute("rel"), h2 = r2[o2].getAttribute("index");
      if (void 0 === n2 && (n2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
        i2.newPointSize(s2, r2[o2]);
        var c2 = r2[o2].getAttribute("cx"), d2 = r2[o2].getAttribute("cy");
        i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, n2);
      } else i2.oldPointSize(r2[o2]);
    }
  } }, { key: "newPointSize", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = 0 === t3 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
    if ("0" !== s2.getAttribute("default-marker-size")) {
      var r2 = parseInt(s2.getAttribute("index"), 10);
      void 0 === a2 && (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0);
      var n2 = this.ttCtx.tooltipUtil.getPathFromPoint(e2, a2);
      e2.setAttribute("d", n2);
    }
  } }, { key: "oldPointSize", value: function(t3) {
    var e2 = parseFloat(t3.getAttribute("default-marker-size")), i2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3, e2);
    t3.setAttribute("d", i2);
  } }, { key: "resetPointsSize", value: function() {
    for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0; e2 < t3.length; e2++) {
      var i2 = parseFloat(t3[e2].getAttribute("default-marker-size"));
      if (v.isNumber(i2) && i2 > 0) {
        var a2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3[e2], i2);
        t3[e2].setAttribute("d", a2);
      } else t3[e2].setAttribute("d", "M0,0");
    }
  } }]), t2;
})(), Aa = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w;
    var a2 = this.w;
    this.ttCtx = e2, this.isVerticalGroupedRangeBar = !a2.globals.isBarHorizontal && "rangeBar" === a2.config.chart.type && a2.config.plotOptions.bar.rangeBarGroupRows;
  }
  return s(t2, [{ key: "getAttr", value: function(t3, e2) {
    return parseFloat(t3.target.getAttribute(e2));
  } }, { key: "handleHeatTreeTooltip", value: function(t3) {
    var e2 = t3.e, i2 = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, n2 = this.ttCtx, o2 = this.w;
    if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
      var l2 = this.getAttr(e2, "i"), h2 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), u2 = this.getAttr(e2, "width"), g2 = this.getAttr(e2, "height");
      if (n2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h2, shared: false, e: e2 }), o2.globals.capturedSeriesIndex = l2, o2.globals.capturedDataPointIndex = h2, a2 = c2 + n2.tooltipRect.ttWidth / 2 + u2, s2 = d2 + n2.tooltipRect.ttHeight / 2 - g2 / 2, n2.tooltipPosition.moveXCrosshairs(c2 + u2 / 2), a2 > o2.globals.gridWidth / 2 && (a2 = c2 - n2.tooltipRect.ttWidth / 2 + u2), n2.w.config.tooltip.followCursor) {
        var p2 = o2.globals.dom.elWrap.getBoundingClientRect();
        a2 = o2.globals.clientX - p2.left - (a2 > o2.globals.gridWidth / 2 ? n2.tooltipRect.ttWidth : 0), s2 = o2.globals.clientY - p2.top - (s2 > o2.globals.gridHeight / 2 ? n2.tooltipRect.ttHeight : 0);
      }
    }
    return { x: a2, y: s2 };
  } }, { key: "handleMarkerTooltip", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, n2 = t3.y, o2 = this.w, l2 = this.ttCtx;
    if (a2.target.classList.contains("apexcharts-marker")) {
      var h2 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
      if (i2 = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
        var u2 = v.findAncestor(s2.paths, "apexcharts-series");
        u2 && (e2 = parseInt(u2.getAttribute("data:realIndex"), 10));
      }
      if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect && o2.config.tooltip.shared, e: a2 }), "mouseup" === a2.type && l2.markerClick(a2, e2, i2), o2.globals.capturedSeriesIndex = e2, o2.globals.capturedDataPointIndex = i2, r2 = h2, n2 = c2 + o2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
        var g2 = l2.getElGrid().getBoundingClientRect();
        n2 = l2.e.clientY + o2.globals.translateY - g2.top;
      }
      d2 < 0 && (n2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, n2);
    }
    return { x: r2, y: n2 };
  } }, { key: "handleBarTooltip", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = this.ttCtx, o2 = n2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
    if (null !== d2.j || 0 !== d2.barHeight || 0 !== d2.barWidth) {
      e2 = d2.i;
      var u2 = d2.j;
      if (r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) && (c2 = r2.globals.svgHeight - n2.tooltipRect.ttHeight), parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), h2 + n2.tooltipRect.ttWidth > r2.globals.gridWidth ? h2 -= n2.tooltipRect.ttWidth : h2 < 0 && (h2 = 0), n2.w.config.tooltip.followCursor) {
        var g2 = n2.getElGrid().getBoundingClientRect();
        c2 = n2.e.clientY - g2.top;
      }
      null === n2.tooltip && (n2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? n2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : n2.tooltipPosition.moveXCrosshairs(l2)), !n2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars()) && (c2 = c2 + r2.globals.translateY - n2.tooltipRect.ttHeight / 2, o2.style.left = h2 + r2.globals.translateX + "px", o2.style.top = c2 + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(t3) {
    var e2 = this, i2 = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, n2 = this.ttCtx, o2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, u2 = i2.target.classList;
    if (u2.contains("apexcharts-bar-area") || u2.contains("apexcharts-candlestick-area") || u2.contains("apexcharts-boxPlot-area") || u2.contains("apexcharts-rangebar-area")) {
      var g2 = i2.target, p2 = g2.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
      d2 = p2.height;
      var b2 = p2.width, m2 = parseInt(g2.getAttribute("cx"), 10), v2 = parseInt(g2.getAttribute("cy"), 10);
      c2 = parseFloat(g2.getAttribute("barWidth"));
      var y2 = "touchmove" === i2.type ? i2.touches[0].clientX : i2.clientX;
      r2 = parseInt(g2.getAttribute("j"), 10), o2 = parseInt(g2.parentNode.getAttribute("rel"), 10) - 1;
      var w2 = g2.getAttribute("data-range-y1"), k2 = g2.getAttribute("data-range-y2");
      s2.globals.comboCharts && (o2 = parseInt(g2.parentNode.getAttribute("data:realIndex"), 10));
      var A2 = function(t4) {
        return s2.globals.isXNumeric ? m2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? m2 + b2 / 2 : m2 - n2.dataPointsDividedWidth + b2 / 2;
      }, C2 = function() {
        return v2 - n2.dataPointsDividedHeight + x2 / 2 - n2.tooltipRect.ttHeight / 2;
      };
      n2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: o2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !n2.showOnIntersect && s2.config.tooltip.shared, e: i2 }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = C2()) : (l2 = A2(), h2 = i2.clientY - f2.top - n2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = m2) < n2.xyRatios.baseLineInvertedY && (l2 = m2 - n2.tooltipRect.ttWidth), h2 = C2()) : (l2 = A2(), h2 = v2);
    }
    return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: o2, j: r2 };
  } }]), t2;
})(), Ca = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.ttCtx = e2;
  }
  return s(t2, [{ key: "drawXaxisTooltip", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = "bottom" === t3.config.xaxis.position;
    e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
    var a2 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
    e2.isXAxisTooltipEnabled && (null === t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var t3 = this.w, e2 = this.ttCtx, i2 = 0; i2 < t3.config.yaxis.length; i2++) {
      var a2 = t3.config.yaxis[i2].opposite || t3.config.yaxis[i2].crosshairs.opposite;
      e2.yaxisOffX = a2 ? t3.globals.gridWidth + 1 : 1;
      var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2, a2 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r2 = t3.globals.dom.elWrap;
      null === t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2)) && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), 0 === i2 && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i2] = document.createElement("div"), e2.yaxisTooltipText[i2].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i2]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
    if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
      var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== a2 && "barWidth" === t3.config.xaxis.crosshairs.width) {
        var s2 = parseFloat(a2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = s2;
      } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
        var r2 = t3.globals.labels.length;
        e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
      }
    } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
      var n2 = t3.globals.labels.length;
      e2.xcrosshairsWidth = t3.globals.gridWidth / n2;
    } else if ("barWidth" === t3.config.xaxis.crosshairs.width) {
      var o2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== o2) {
        var l2 = parseFloat(o2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = l2;
      } else e2.xcrosshairsWidth = 1;
    }
    t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), null !== i2 && e2.xcrosshairsWidth > 0 && i2.setAttribute("width", e2.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var t3 = this.w, e2 = this.ttCtx;
    e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i2) {
    var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals, n2 = r2.seriesYAxisMap[t3];
    if (a2.yaxisTooltips[t3] && n2.length > 0) {
      var o2 = r2.yLabelFormatters[t3], l2 = a2.getElGrid().getBoundingClientRect(), h2 = n2[0], c2 = 0;
      i2.yRatio.length > 1 && (c2 = h2);
      var d2 = (e2 - l2.top) * i2.yRatio[c2], u2 = r2.maxYArr[h2] - r2.minYArr[h2], g2 = r2.minYArr[h2] + (u2 - d2);
      s2.config.yaxis[t3].reversed && (g2 = r2.maxYArr[h2] - (u2 - d2)), a2.tooltipPosition.moveYCrosshairs(e2 - l2.top), a2.yaxisTooltipText[t3].innerHTML = o2(g2), a2.tooltipPosition.moveYAxisTooltip(t3);
    }
  } }]), t2;
})(), Sa = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.tConfig = a2.config.tooltip, this.tooltipUtil = new va(this), this.tooltipLabels = new ya(this), this.tooltipPosition = new wa(this), this.marker = new ka(this), this.intersect = new Aa(this), this.axesTooltip = new Ca(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return s(t2, [{ key: "getElTooltip", value: function(t3) {
    return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(t3) {
    var e2 = this.w;
    this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map((function(t4, i3) {
      return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
    })), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
    var i2 = document.createElement("div");
    if (i2.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme || "light")), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var a2 = new Qi(this.ctx);
      this.xAxisTicksPositions = a2.getXAxisTicksPositions();
    }
    if (!e2.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e2.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e2.config.markers.size && 0 !== e2.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
      this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
      var s2 = e2.globals.series.length;
      (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
      var n3 = document.createElement("div");
      n3.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r3)), n3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1;
      var o2 = document.createElement("span");
      o2.classList.add("apexcharts-tooltip-marker"), i2.config.tooltip.fillSeriesColor ? o2.style.backgroundColor = i2.globals.colors[r3] : o2.style.color = i2.globals.colors[r3];
      var l2 = i2.config.markers.shape, h2 = l2;
      Array.isArray(l2) && (h2 = l2[r3]), o2.setAttribute("shape", h2), n3.appendChild(o2);
      var c2 = document.createElement("div");
      c2.classList.add("apexcharts-tooltip-text"), c2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, c2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach((function(t4) {
        var e3 = document.createElement("div");
        e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
        var i3 = document.createElement("span");
        i3.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i3);
        var a3 = document.createElement("span");
        a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), c2.appendChild(e3);
      })), n3.appendChild(c2), s2.appendChild(n3), a2.push(n3);
    }, n2 = 0; n2 < t3; n2++) r2(n2);
    return a2;
  } }, { key: "addSVGEvents", value: function() {
    var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !("bar" !== e2 && "candlestick" !== e2 && "boxPlot" !== e2 && "rangeBar" !== e2), s2 = "area" === e2 || "line" === e2 || "scatter" === e2 || "bubble" === e2 || "radar" === e2, r2 = t3.globals.dom.Paper.node, n2 = this.getElGrid();
    n2 && (this.seriesBound = n2.getBoundingClientRect());
    var o2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: n2, tooltipEl: i2, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
    if (t3.globals.axisCharts && (s2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e2 && "treemap" !== e2 || (o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o2 && o2.length)) for (var d2 = 0; d2 < o2.length; d2++) l2.push(o2[d2].getAttribute("cy")), h2.push(o2[d2].getAttribute("cx"));
    if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r2], c2);
    else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect) this.addDatapointEventsListeners(c2);
    else if (!t3.globals.axisCharts || "heatmap" === e2 || "treemap" === e2) {
      var u2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(u2, c2);
    }
    if (this.showOnIntersect) {
      var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      g2.length > 0 && this.addPathsEventListeners(g2, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, n2 = this.tConfig.fixed.offsetY, o2 = this.tConfig.fixed.position.toLowerCase();
    return o2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), o2.indexOf("bottom") > -1 && (n2 = n2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = n2 + "px", { x: r2, y: n2, ttWidth: a2, ttHeight: s2 };
  } }, { key: "addDatapointEventsListeners", value: function(t3) {
    var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(e2, t3);
  } }, { key: "addPathsEventListeners", value: function(t3, e2) {
    for (var i2 = this, a2 = function(a3) {
      var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((function(e3) {
        return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
      }));
    }, s2 = 0; s2 < t3.length; s2++) a2(s2);
  } }, { key: "onSeriesHover", value: function(t3, e2) {
    var i2 = this, a2 = Date.now() - this.lastHoverTime;
    a2 >= 20 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout((function() {
      i2.seriesHover(t3, e2);
    }), 20 - a2));
  } }, { key: "seriesHover", value: function(t3, e2) {
    var i2 = this;
    this.lastHoverTime = Date.now();
    var a2 = [], s2 = this.w;
    s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || 0 === s2.globals.dataPoints) || (a2.length ? a2.forEach((function(a3) {
      var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
      a3.w.globals.minX === i2.w.globals.minX && a3.w.globals.maxX === i2.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
    })) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
  } }, { key: "seriesHoverByContext", value: function(t3) {
    var e2 = t3.chartCtx, i2 = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, n2 = this.getElTooltip(e2);
    if (n2) {
      if (i2.tooltipRect = { x: 0, y: 0, ttWidth: n2.getBoundingClientRect().width, ttHeight: n2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
        if (this.tConfig.onDatasetHover.highlightDataSeries) new Zi(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
      }
      r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }), i2.fixedTooltip && i2.drawFixedTooltipRect();
    }
  } }, { key: "axisChartsTooltips", value: function(t3) {
    var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = s2.elGrid.getBoundingClientRect(), o2 = "touchmove" === a2.type ? a2.touches[0].clientX : a2.clientX, l2 = "touchmove" === a2.type ? a2.touches[0].clientY : a2.clientY;
    if (this.clientY = l2, this.clientX = o2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < n2.top || l2 > n2.top + n2.height) this.handleMouseOut(s2);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
        var h2 = parseInt(s2.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h2) < 0) return void this.handleMouseOut(s2);
      }
      var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), u2 = [];
      r2.config.chart.group && (u2 = this.ctx.getSyncedCharts());
      var g2 = r2.globals.xyCharts || "bar" === r2.config.chart.type && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
      if ("mousemove" === a2.type || "touchmove" === a2.type || "mouseup" === a2.type) {
        if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length) return;
        null !== d2 && d2.classList.add("apexcharts-active");
        var p2 = this.yaxisTooltips.filter((function(t4) {
          return true === t4;
        }));
        if (null !== this.ycrosshairs && p2.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect || u2.length > 1) this.handleStickyTooltip(a2, o2, l2, s2);
        else if ("heatmap" === r2.config.chart.type || "treemap" === r2.config.chart.type) {
          var f2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
          e2 = f2.x, i2 = f2.y, c2.style.left = e2 + "px", c2.style.top = i2 + "px";
        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
        if (this.yaxisTooltips.length) for (var x2 = 0; x2 < r2.config.yaxis.length; x2++) this.axesTooltip.drawYaxisTooltipText(x2, l2, this.xyRatios);
        r2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s2.tooltipEl.classList.add("apexcharts-active");
      } else "mouseout" !== a2.type && "touchend" !== a2.type || this.handleMouseOut(s2);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(t3) {
    var e2 = t3.e, i2 = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i2.paths.getAttribute("rel"), n2 = this.getElTooltip(), o2 = s2.globals.dom.elWrap.getBoundingClientRect();
    if ("mousemove" === e2.type || "touchmove" === e2.type) {
      s2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), n2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
      var l2 = s2.globals.clientX - o2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - o2.top - a2.ttHeight - 10;
      if (n2.style.left = l2 + "px", n2.style.top = h2 + "px", s2.config.legend.tooltipHoverFormatter) {
        var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
        this.legendLabels[c2].innerHTML = d2;
      }
    } else "mouseout" !== e2.type && "touchend" !== e2.type || (n2.classList.remove("apexcharts-active"), s2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t4) {
      var e3 = t4.getAttribute("data:default-text");
      t4.innerHTML = decodeURIComponent(e3);
    })));
  } }, { key: "handleStickyTooltip", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), n2 = r2.j, o2 = r2.capturedSeries;
    s2.globals.collapsedSeriesIndices.includes(o2) && (o2 = null);
    var l2 = a2.elGrid.getBoundingClientRect();
    if (r2.hoverX < 0 || r2.hoverX > l2.width) this.handleMouseOut(a2);
    else if (null !== o2) this.handleStickyCapturedSeries(t3, o2, a2, n2);
    else if (this.tooltipUtil.isXoverlap(n2) || s2.globals.isBarHorizontal) {
      var h2 = s2.globals.series.findIndex((function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      }));
      this.create(t3, this, h2, n2, a2.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i2, a2) {
    var s2 = this.w;
    if (!this.tConfig.shared && null === s2.globals.series[e2][a2]) return void this.handleMouseOut(i2);
    if (void 0 !== s2.globals.series[e2][a2]) this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false);
    else if (this.tooltipUtil.isXoverlap(a2)) {
      var r2 = s2.globals.series.findIndex((function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      }));
      this.create(t3, this, r2, a2, i2.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var t3 = this.w, e2 = new Mi(this.ctx), i2 = t3.globals.dom.Paper.find(".apexcharts-bar-area"), a2 = 0; a2 < i2.length; a2++) e2.pathMouseLeave(i2[a2]);
  } }, { key: "handleMouseOut", value: function(t3) {
    var e2 = this.w, i2 = this.getElXCrosshairs();
    if (e2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e2.config.chart.type && this.marker.resetPointsSize(), null !== i2 && i2.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      null === this.yaxisTTEls && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++) this.yaxisTTEls[a2].classList.remove("apexcharts-active");
    }
    e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t4) {
      var e3 = t4.getAttribute("data:default-text");
      t4.innerHTML = decodeURIComponent(e3);
    }));
  } }, { key: "markerClick", value: function(t3, e2, i2) {
    var a2 = this.w;
    "function" == typeof a2.config.chart.events.markerClick && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
  } }, { key: "create", value: function(t3, e2, i2, a2, s2) {
    var r2, n2, o2, l2, h2, c2, d2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, A2 = this.w, C2 = e2;
    "mouseup" === t3.type && this.markerClick(t3, i2, a2), null === k2 && (k2 = this.tConfig.shared);
    var S2 = this.tooltipUtil.hasMarkers(i2), L2 = this.tooltipUtil.getElBars(), M2 = function() {
      A2.globals.markers.largestSize > 0 ? C2.marker.enlargePoints(a2) : C2.tooltipPosition.moveDynamicPointsOnHover(a2);
    };
    if (A2.config.legend.tooltipHoverFormatter) {
      var P2 = A2.config.legend.tooltipHoverFormatter, I2 = Array.from(this.legendLabels);
      I2.forEach((function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      }));
      for (var T2 = 0; T2 < I2.length; T2++) {
        var z2 = I2[T2], X2 = parseInt(z2.getAttribute("i"), 10), R2 = decodeURIComponent(z2.getAttribute("data:default-text")), E2 = P2(R2, { seriesIndex: k2 ? X2 : i2, dataPointIndex: a2, w: A2 });
        if (k2) z2.innerHTML = A2.globals.collapsedSeriesIndices.indexOf(X2) < 0 ? E2 : R2;
        else if (z2.innerHTML = X2 === i2 ? E2 : R2, i2 === X2) break;
      }
    }
    var Y2 = u(u({ ttItems: s2, i: i2, j: a2 }, void 0 !== (null === (r2 = A2.globals.seriesRange) || void 0 === r2 || null === (n2 = r2[i2]) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.y[0]) || void 0 === l2 ? void 0 : l2.y1) && { y1: null === (h2 = A2.globals.seriesRange) || void 0 === h2 || null === (c2 = h2[i2]) || void 0 === c2 || null === (d2 = c2[a2]) || void 0 === d2 || null === (g2 = d2.y[0]) || void 0 === g2 ? void 0 : g2.y1 }), void 0 !== (null === (p2 = A2.globals.seriesRange) || void 0 === p2 || null === (f2 = p2[i2]) || void 0 === f2 || null === (x2 = f2[a2]) || void 0 === x2 || null === (b2 = x2.y[0]) || void 0 === b2 ? void 0 : b2.y2) && { y2: null === (m2 = A2.globals.seriesRange) || void 0 === m2 || null === (v2 = m2[i2]) || void 0 === v2 || null === (y2 = v2[a2]) || void 0 === y2 || null === (w2 = y2.y[0]) || void 0 === w2 ? void 0 : w2.y2 });
    if (k2) {
      if (C2.tooltipLabels.drawSeriesTexts(u(u({}, Y2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), S2) M2();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L2), this.barSeriesHeight > 0)) {
        var H2 = new Mi(this.ctx), O2 = A2.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(a2, "']"));
        this.deactivateHoverFilter(), C2.tooltipUtil.getAllMarkers(true).length && !this.barSeriesHeight && M2(), C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2);
        for (var F2 = 0; F2 < O2.length; F2++) H2.pathMouseEnter(O2[F2]);
      }
    } else C2.tooltipLabels.drawSeriesTexts(u({ shared: false }, Y2)), this.tooltipUtil.hasBars() && C2.tooltipPosition.moveStickyTooltipOverBars(a2, i2), S2 && C2.tooltipPosition.moveMarkers(i2, a2);
  } }]), t2;
})(), La = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return s(t2, [{ key: "handleBarDataLabels", value: function(t3) {
    var e2, i2, a2 = t3.x, s2 = t3.y, r2 = t3.y1, n2 = t3.y2, o2 = t3.i, l2 = t3.j, h2 = t3.realIndex, c2 = t3.columnGroupIndex, d2 = t3.series, g2 = t3.barHeight, p2 = t3.barWidth, f2 = t3.barXPosition, x2 = t3.barYPosition, b2 = t3.visibleSeries, m2 = this.w, v2 = new Mi(this.barCtx.ctx), y2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h2] : this.barCtx.strokeWidth;
    m2.globals.isXNumeric && !m2.globals.isBarHorizontal ? (e2 = a2 + parseFloat(p2 * (b2 + 1)), i2 = s2 + parseFloat(g2 * (b2 + 1)) - y2) : (e2 = a2 + parseFloat(p2 * b2), i2 = s2 + parseFloat(g2 * b2));
    var w2, k2 = null, A2 = a2, C2 = s2, S2 = {}, L2 = m2.config.dataLabels, M2 = this.barCtx.barOptions.dataLabels, P2 = this.barCtx.barOptions.dataLabels.total;
    void 0 !== x2 && this.barCtx.isRangeBar && (i2 = x2, C2 = x2), void 0 !== f2 && this.barCtx.isVerticalGroupedRangeBar && (e2 = f2, A2 = f2);
    var I2 = L2.offsetX, T2 = L2.offsetY, z2 = { width: 0, height: 0 };
    if (m2.config.dataLabels.enabled) {
      var X2 = m2.globals.series[o2][l2];
      z2 = v2.getTextRects(m2.config.dataLabels.formatter ? m2.config.dataLabels.formatter(X2, u(u({}, m2), {}, { seriesIndex: o2, dataPointIndex: l2, w: m2 })) : m2.globals.yLabelFormatters[0](X2), parseFloat(L2.style.fontSize));
    }
    var R2 = { x: a2, y: s2, i: o2, j: l2, realIndex: h2, columnGroupIndex: c2, bcx: e2, bcy: i2, barHeight: g2, barWidth: p2, textRects: z2, strokeWidth: y2, dataLabelsX: A2, dataLabelsY: C2, dataLabelsConfig: L2, barDataLabelsConfig: M2, barTotalDataLabelsConfig: P2, offX: I2, offY: T2 };
    return S2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(R2) : this.calculateColumnsDataLabelsPosition(R2), w2 = this.drawCalculatedDataLabels({ x: S2.dataLabelsX, y: S2.dataLabelsY, val: this.barCtx.isRangeBar ? [r2, n2] : "100%" === m2.config.chart.stackType ? d2[h2][l2] : m2.globals.series[h2][l2], i: h2, j: l2, barWidth: p2, barHeight: g2, textRects: z2, dataLabelsConfig: L2 }), m2.config.chart.stacked && P2.enabled && (k2 = this.drawTotalDataLabels({ x: S2.totalDataLabelsX, y: S2.totalDataLabelsY, barWidth: p2, barHeight: g2, realIndex: h2, textAnchor: S2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h2, j: l2 }), dataLabelsConfig: L2, barTotalDataLabelsConfig: P2 })), { dataLabelsPos: S2, dataLabels: w2, totalDataLabels: k2 };
  } }, { key: "getStackedTotalDataLabel", value: function(t3) {
    var e2 = t3.realIndex, i2 = t3.j, a2 = this.w, s2 = this.barCtx.stackedSeriesTotals[i2];
    return this.totalFormatter && (s2 = this.totalFormatter(s2, u(u({}, a2), {}, { seriesIndex: e2, dataPointIndex: i2, w: a2 }))), s2;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex;
    t3.columnGroupIndex;
    var n2, o2, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, u2 = t3.textRects, g2 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, m2 = t3.strokeWidth, v2 = t3.offX, y2 = t3.offY, w2 = h2;
    d2 = Math.abs(d2);
    var k2 = "vertical" === i2.config.plotOptions.bar.dataLabels.orientation, A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: a2, j: s2 }).zeroEncounters;
    h2 -= m2 / 2;
    var C2 = i2.globals.gridWidth / i2.globals.dataPoints;
    if (this.barCtx.isVerticalGroupedRangeBar ? g2 += c2 / 2 : (g2 = i2.globals.isXNumeric ? h2 - c2 / 2 + v2 : h2 - C2 + c2 / 2 + v2, !i2.config.chart.stacked && A2 > 0 && i2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g2 -= c2 * A2)), k2) {
      g2 = g2 + u2.height / 2 - m2 / 2 - 2;
    }
    var S2 = i2.globals.series[a2][s2] < 0, L2 = l2;
    switch (this.barCtx.isReversed && (L2 = l2 + (S2 ? d2 : -d2)), x2.position) {
      case "center":
        p2 = k2 ? S2 ? L2 - d2 / 2 + y2 : L2 + d2 / 2 - y2 : S2 ? L2 - d2 / 2 + u2.height / 2 + y2 : L2 + d2 / 2 + u2.height / 2 - y2;
        break;
      case "bottom":
        p2 = k2 ? S2 ? L2 - d2 + y2 : L2 + d2 - y2 : S2 ? L2 - d2 + u2.height + m2 + y2 : L2 + d2 - u2.height / 2 + m2 - y2;
        break;
      case "top":
        p2 = k2 ? S2 ? L2 + y2 : L2 - y2 : S2 ? L2 - u2.height / 2 - y2 : L2 + u2.height + y2;
    }
    var M2 = L2;
    if (i2.globals.seriesGroups.forEach((function(t4) {
      var i3;
      null === (i3 = e2.barCtx[t4.join(",")]) || void 0 === i3 || i3.prevY.forEach((function(t5) {
        M2 = S2 ? Math.max(t5[s2], M2) : Math.min(t5[s2], M2);
      }));
    })), this.barCtx.lastActiveBarSerieIndex === r2 && b2.enabled) {
      var P2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), f2.fontSize);
      n2 = S2 ? M2 - P2.height / 2 - y2 - b2.offsetY + 18 : M2 + P2.height + y2 + b2.offsetY - 18;
      var I2 = C2;
      o2 = w2 + (i2.globals.isXNumeric ? -c2 * i2.globals.barGroups.length / 2 : i2.globals.barGroups.length * c2 / 2 - (i2.globals.barGroups.length - 1) * c2 - I2) + b2.offsetX;
    }
    return i2.config.chart.stacked || (p2 < 0 ? p2 = 0 + m2 : p2 + u2.height / 3 > i2.globals.gridHeight && (p2 = i2.globals.gridHeight - m2)), { bcx: h2, bcy: l2, dataLabelsX: g2, dataLabelsY: p2, totalDataLabelsX: o2, totalDataLabelsY: n2, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = t3.x, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, u2 = t3.strokeWidth, g2 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, m2 = i2.globals.gridHeight / i2.globals.dataPoints, v2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
    h2 = Math.abs(h2);
    var y2, w2, k2 = o2 - (this.barCtx.isRangeBar ? 0 : m2) + l2 / 2 + c2.height / 2 + b2 - 3;
    !i2.config.chart.stacked && v2 > 0 && i2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (k2 -= l2 * v2);
    var A2 = "start", C2 = i2.globals.series[s2][r2] < 0, S2 = a2;
    switch (this.barCtx.isReversed && (S2 = a2 + (C2 ? -h2 : h2), A2 = C2 ? "start" : "end"), p2.position) {
      case "center":
        d2 = C2 ? S2 + h2 / 2 - x2 : Math.max(c2.width / 2, S2 - h2 / 2) + x2;
        break;
      case "bottom":
        d2 = C2 ? S2 + h2 - u2 - x2 : S2 - h2 + u2 + x2;
        break;
      case "top":
        d2 = C2 ? S2 - u2 - x2 : S2 - u2 + x2;
    }
    var L2 = S2;
    if (i2.globals.seriesGroups.forEach((function(t4) {
      var i3;
      null === (i3 = e2.barCtx[t4.join(",")]) || void 0 === i3 || i3.prevX.forEach((function(t5) {
        L2 = C2 ? Math.min(t5[r2], L2) : Math.max(t5[r2], L2);
      }));
    })), this.barCtx.lastActiveBarSerieIndex === n2 && f2.enabled) {
      var M2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n2, j: r2 }), g2.fontSize);
      C2 ? (y2 = L2 - u2 - x2 - f2.offsetX, A2 = "end") : y2 = L2 + x2 + f2.offsetX + (this.barCtx.isReversed ? -(h2 + u2) : u2), w2 = k2 - c2.height / 2 + M2.height / 2 + f2.offsetY + u2, i2.globals.barGroups.length > 1 && (w2 -= i2.globals.barGroups.length / 2 * (l2 / 2));
    }
    return i2.config.chart.stacked || ("start" === g2.textAnchor ? d2 - c2.width < 0 ? d2 = C2 ? c2.width + u2 : u2 : d2 + c2.width > i2.globals.gridWidth && (d2 = C2 ? i2.globals.gridWidth - u2 : i2.globals.gridWidth - c2.width - u2) : "middle" === g2.textAnchor ? d2 - c2.width / 2 < 0 ? d2 = c2.width / 2 + u2 : d2 + c2.width / 2 > i2.globals.gridWidth && (d2 = i2.globals.gridWidth - c2.width / 2 - u2) : "end" === g2.textAnchor && (d2 < 1 ? d2 = c2.width + u2 : d2 + 1 > i2.globals.gridWidth && (d2 = i2.globals.gridWidth - c2.width - u2))), { bcx: a2, bcy: o2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
  } }, { key: "drawCalculatedDataLabels", value: function(t3) {
    var e2 = t3.x, i2 = t3.y, a2 = t3.val, s2 = t3.i, r2 = t3.j, n2 = t3.textRects, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.dataLabelsConfig, c2 = this.w, d2 = "rotate(0)";
    "vertical" === c2.config.plotOptions.bar.dataLabels.orientation && (d2 = "rotate(-90, ".concat(e2, ", ").concat(i2, ")"));
    var g2 = new qi(this.barCtx.ctx), p2 = new Mi(this.barCtx.ctx), f2 = h2.formatter, x2 = null, b2 = c2.globals.collapsedSeriesIndices.indexOf(s2) > -1;
    if (h2.enabled && !b2) {
      x2 = p2.group({ class: "apexcharts-data-labels", transform: d2 });
      var m2 = "";
      void 0 !== a2 && (m2 = f2(a2, u(u({}, c2), {}, { seriesIndex: s2, dataPointIndex: r2, w: c2 }))), !a2 && c2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (m2 = "");
      var v2 = c2.globals.series[s2][r2] < 0, y2 = c2.config.plotOptions.bar.dataLabels.position;
      if ("vertical" === c2.config.plotOptions.bar.dataLabels.orientation && ("top" === y2 && (h2.textAnchor = v2 ? "end" : "start"), "center" === y2 && (h2.textAnchor = "middle"), "bottom" === y2 && (h2.textAnchor = v2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) l2 < p2.getTextRects(m2, parseFloat(h2.style.fontSize)).width && (m2 = "");
      c2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(l2) && (m2 = "") : n2.height / 1.6 > Math.abs(o2) && (m2 = ""));
      var w2 = u({}, h2);
      this.barCtx.isHorizontal && a2 < 0 && ("start" === h2.textAnchor ? w2.textAnchor = "end" : "end" === h2.textAnchor && (w2.textAnchor = "start")), g2.plotDataLabelsText({ x: e2, y: i2, text: m2, i: s2, j: r2, parent: x2, dataLabelsConfig: w2, alwaysDrawDataLabel: true, offsetCorrection: true });
    }
    return x2;
  } }, { key: "drawTotalDataLabels", value: function(t3) {
    var e2 = t3.x, i2 = t3.y, a2 = t3.val, s2 = t3.realIndex, r2 = t3.textAnchor, n2 = t3.barTotalDataLabelsConfig;
    this.w;
    var o2, l2 = new Mi(this.barCtx.ctx);
    return n2.enabled && void 0 !== e2 && void 0 !== i2 && this.barCtx.lastActiveBarSerieIndex === s2 && (o2 = l2.drawText({ x: e2, y: i2, foreColor: n2.style.color, text: a2, textAnchor: r2, fontFamily: n2.style.fontFamily, fontSize: n2.style.fontSize, fontWeight: n2.style.fontWeight })), o2;
  } }]), t2;
})(), Ma = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.barCtx = e2;
  }
  return s(t2, [{ key: "initVariables", value: function(t3) {
    var e2 = this.w;
    this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i2 = 0; i2 < t3.length; i2++) if (t3[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric) for (var a2 = 0; a2 < t3[i2].length; a2++) e2.globals.seriesX[i2][a2] > e2.globals.minX && e2.globals.seriesX[i2][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
    else this.barCtx.visibleItems = e2.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(e2.globals.series), v.isSafari() && (this.arrBorderRadius = this.arrBorderRadius.map((function(t4) {
      return t4.map((function(t5) {
        return "none";
      }));
    }))), 0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
  } }, { key: "initialPositions", value: function(t3) {
    var e2, i2, a2, s2, r2, n2, o2, l2, h2 = this.w, c2 = h2.globals.dataPoints;
    this.barCtx.isRangeBar && (c2 = h2.globals.labels.length);
    var d2 = this.barCtx.seriesLen;
    if (h2.config.plotOptions.bar.rangeBarGroupRows && (d2 = 1), this.barCtx.isHorizontal) r2 = (a2 = h2.globals.gridHeight / c2) / d2, h2.globals.isXNumeric && (r2 = (a2 = h2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), r2 = r2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (r2 = parseInt(this.barCtx.barOptions.barHeight, 10)), l2 = this.barCtx.baseLineInvertedY + h2.globals.padHorizontal + (this.barCtx.isReversed ? h2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (l2 = h2.globals.gridWidth / 2), i2 = (a2 - r2 * this.barCtx.seriesLen) / 2;
    else {
      if (s2 = h2.globals.gridWidth / this.barCtx.visibleItems, h2.config.xaxis.convertedCatToNumeric && (s2 = h2.globals.gridWidth / h2.globals.dataPoints), n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h2.globals.isXNumeric) {
        var u2 = this.barCtx.xRatio;
        h2.globals.minXDiff && 0.5 !== h2.globals.minXDiff && h2.globals.minXDiff / u2 > 0 && (s2 = h2.globals.minXDiff / u2), (n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (n2 = 1);
      }
      if (-1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (n2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = h2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h2.globals.isXNumeric) e2 = this.barCtx.getBarXForNumericXAxis({ x: e2, j: 0, realIndex: t3, barWidth: n2 }).x;
      else e2 = h2.globals.padHorizontal + v.noExponents(s2 - n2 * this.barCtx.seriesLen) / 2;
    }
    return h2.globals.barHeight = r2, h2.globals.barWidth = n2, { x: e2, y: i2, yDivision: a2, xDivision: s2, barHeight: r2, barWidth: n2, zeroH: o2, zeroW: l2 };
  } }, { key: "initializeStackedPrevVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach((function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].prevY = [], t3[e2].prevX = [], t3[e2].prevYF = [], t3[e2].prevXF = [], t3[e2].prevYVal = [], t3[e2].prevXVal = [];
    }));
  } }, { key: "initializeStackedXYVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach((function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].xArrj = [], t3[e2].xArrjF = [], t3[e2].xArrjVal = [], t3[e2].yArrj = [], t3[e2].yArrjF = [], t3[e2].yArrjVal = [];
    }));
  } }, { key: "getPathFillColor", value: function(t3, e2, i2, a2) {
    var s2, r2, n2, o2, l2 = this.w, h2 = this.barCtx.ctx.fill, c2 = null, d2 = this.barCtx.barOptions.distributed ? i2 : e2, u2 = false;
    this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function(a3) {
      t3[e2][i2] >= a3.from && t3[e2][i2] <= a3.to && (c2 = a3.color, u2 = true);
    }));
    return { color: h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i2, color: c2, value: t3[e2][i2], fillConfig: null === (s2 = l2.config.series[e2].data[i2]) || void 0 === s2 ? void 0 : s2.fill, fillType: null !== (r2 = l2.config.series[e2].data[i2]) && void 0 !== r2 && null !== (n2 = r2.fill) && void 0 !== n2 && n2.type ? null === (o2 = l2.config.series[e2].data[i2]) || void 0 === o2 ? void 0 : o2.fill.type : Array.isArray(l2.config.fill.type) ? l2.config.fill.type[a2] : l2.config.fill.type }), useRangeColor: u2 };
  } }, { key: "getStrokeWidth", value: function(t3, e2, i2) {
    var a2 = 0, s2 = this.w;
    return void 0 === this.barCtx.series[t3][e2] || null === this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = true : this.barCtx.isNullValue = false, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
  } }, { key: "createBorderRadiusArr", value: function(t3) {
    var e2, i2 = this.w, a2 = !this.w.config.chart.stacked || i2.config.plotOptions.bar.borderRadius <= 0, s2 = t3.length, n2 = 0 | (null === (e2 = t3[0]) || void 0 === e2 ? void 0 : e2.length), o2 = Array.from({ length: s2 }, (function() {
      return Array(n2).fill(a2 ? "top" : "none");
    }));
    if (a2) return o2;
    for (var l2 = 0; l2 < n2; l2++) {
      for (var h2 = [], c2 = [], d2 = 0, u2 = 0; u2 < s2; u2++) {
        var g2 = t3[u2][l2];
        g2 > 0 ? (h2.push(u2), d2++) : g2 < 0 && (c2.push(u2), d2++);
      }
      if (h2.length > 0 && 0 === c2.length) if (1 === h2.length) o2[h2[0]][l2] = "both";
      else {
        var p2, f2 = h2[0], x2 = h2[h2.length - 1], b2 = r(h2);
        try {
          for (b2.s(); !(p2 = b2.n()).done; ) {
            var m2 = p2.value;
            o2[m2][l2] = m2 === f2 ? "bottom" : m2 === x2 ? "top" : "none";
          }
        } catch (t4) {
          b2.e(t4);
        } finally {
          b2.f();
        }
      }
      else if (c2.length > 0 && 0 === h2.length) if (1 === c2.length) o2[c2[0]][l2] = "both";
      else {
        var v2, y2 = Math.max.apply(Math, c2), w2 = Math.min.apply(Math, c2), k2 = r(c2);
        try {
          for (k2.s(); !(v2 = k2.n()).done; ) {
            var A2 = v2.value;
            o2[A2][l2] = A2 === y2 ? "bottom" : A2 === w2 ? "top" : "none";
          }
        } catch (t4) {
          k2.e(t4);
        } finally {
          k2.f();
        }
      }
      else if (h2.length > 0 && c2.length > 0) {
        var C2, S2 = h2[h2.length - 1], L2 = r(h2);
        try {
          for (L2.s(); !(C2 = L2.n()).done; ) {
            var M2 = C2.value;
            o2[M2][l2] = M2 === S2 ? "top" : "none";
          }
        } catch (t4) {
          L2.e(t4);
        } finally {
          L2.f();
        }
        var P2, I2 = Math.max.apply(Math, c2), T2 = r(c2);
        try {
          for (T2.s(); !(P2 = T2.n()).done; ) {
            var z2 = P2.value;
            o2[z2][l2] = z2 === I2 ? "bottom" : "none";
          }
        } catch (t4) {
          T2.e(t4);
        } finally {
          T2.f();
        }
      } else if (1 === d2) {
        o2[h2[0] || c2[0]][l2] = "both";
      }
    }
    return o2;
  } }, { key: "barBackground", value: function(t3) {
    var e2 = t3.j, i2 = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, n2 = t3.y2, o2 = t3.elSeries, l2 = this.w, h2 = new Mi(this.barCtx.ctx), c2 = new Zi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i2) {
      e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], u2 = h2.drawRect(void 0 !== a2 ? a2 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s2 ? s2 : l2.globals.gridWidth, void 0 !== n2 ? n2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
      o2.add(u2), u2.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(t3) {
    var e2, i2 = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) && void 0 !== e2 && e2.columnWidthOffset && (x2 = a2 - g2.config.series[c2].data[u2].columnWidthOffset / 2, f2 = i2 + g2.config.series[c2].data[u2].columnWidthOffset);
    var b2 = n2 / 2, m2 = x2 + b2, v2 = x2 + f2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 - b2 * y2, r2 += 1e-3 + b2 * y2;
    var w2 = p2.move(m2, s2), k2 = p2.move(m2, s2), A2 = p2.line(v2, s2);
    if (g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false)), w2 = w2 + p2.line(m2, r2) + p2.line(v2, r2) + A2 + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), k2 = k2 + p2.line(m2, s2) + A2 + A2 + A2 + A2 + A2 + p2.line(m2, s2) + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), "none" !== this.arrBorderRadius[c2][u2] && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).yArrj.push(r2 - b2 * y2), C2.yArrjF.push(Math.abs(s2 - r2 + n2 * y2)), C2.yArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "getBarpaths", value: function(t3) {
    var e2, i2 = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i2, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) && void 0 !== e2 && e2.barHeightOffset && (f2 = i2 - g2.config.series[c2].data[u2].barHeightOffset / 2, x2 = a2 + g2.config.series[c2].data[u2].barHeightOffset);
    var b2 = n2 / 2, m2 = f2 + b2, v2 = f2 + x2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 + b2 * y2, r2 += 1e-3 - b2 * y2;
    var w2 = p2.move(s2, m2), k2 = p2.move(s2, m2);
    g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false));
    var A2 = p2.line(s2, v2);
    if (w2 = w2 + p2.line(r2, m2) + p2.line(r2, v2) + A2 + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), k2 = k2 + p2.line(s2, m2) + A2 + A2 + A2 + A2 + A2 + p2.line(s2, m2) + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), "none" !== this.arrBorderRadius[c2][u2] && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).xArrj.push(r2 + b2 * y2), C2.xArrjF.push(Math.abs(s2 - r2 - n2 * y2)), C2.xArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "checkZeroSeries", value: function(t3) {
    for (var e2 = t3.series, i2 = this.w, a2 = 0; a2 < e2.length; a2++) {
      for (var s2 = 0, r2 = 0; r2 < e2[i2.globals.maxValsInArrayIndex].length; r2++) s2 += e2[a2][r2];
      0 === s2 && this.barCtx.zeroSerieses.push(a2);
    }
  } }, { key: "getXForValue", value: function(t3, e2) {
    var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
    return null != t3 && (i2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i2;
  } }, { key: "getYForValue", value: function(t3, e2, i2) {
    var a2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e2 : null;
    return null != t3 && (a2 = e2 - t3 / this.barCtx.yRatio[i2] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[i2] : 0)), a2;
  } }, { key: "getGoalValues", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = this, l2 = this.w, h2 = [], c2 = function(a3, s3) {
      var l3;
      h2.push((o(l3 = {}, t3, "x" === t3 ? n2.getXForValue(a3, e2, false) : n2.getYForValue(a3, i2, r2, false)), o(l3, "attrs", s3), l3));
    };
    if (l2.globals.seriesGoals[a2] && l2.globals.seriesGoals[a2][s2] && Array.isArray(l2.globals.seriesGoals[a2][s2]) && l2.globals.seriesGoals[a2][s2].forEach((function(t4) {
      c2(t4.value, t4);
    })), this.barCtx.barOptions.isDumbbell && l2.globals.seriesRange.length) {
      var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: "x" === t3 ? 0 : l2.globals.markers.size[a2], strokeWidth: "x" === t3 ? l2.globals.markers.size[a2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d2[a2]) ? d2[a2][0] : d2[a2] };
      c2(l2.globals.seriesRangeStart[a2][s2], g2), c2(l2.globals.seriesRangeEnd[a2][s2], u(u({}, g2), {}, { strokeColor: Array.isArray(d2[a2]) ? d2[a2][1] : d2[a2] }));
    }
    return h2;
  } }, { key: "drawGoalLine", value: function(t3) {
    var e2 = t3.barXPosition, i2 = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, n2 = t3.barHeight, o2 = new Mi(this.barCtx.ctx), l2 = o2.group({ className: "apexcharts-bar-goals-groups" });
    l2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h2 = null;
    return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach((function(t4) {
      if (t4.x >= -1 && t4.x <= o2.w.globals.gridWidth + 1) {
        var e3 = void 0 !== t4.attrs.strokeHeight ? t4.attrs.strokeHeight : n2 / 2, a3 = i2 + e3 + n2 / 2;
        h2 = o2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    })) : Array.isArray(s2) && s2.forEach((function(t4) {
      if (t4.y >= -1 && t4.y <= o2.w.globals.gridHeight + 1) {
        var i3 = void 0 !== t4.attrs.strokeWidth ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
        h2 = o2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    })), l2;
  } }, { key: "drawBarShadow", value: function(t3) {
    var e2 = t3.prevPaths, i2 = t3.currPaths, a2 = t3.color, s2 = this.w, r2 = e2.x, n2 = e2.x1, o2 = e2.barYPosition, l2 = i2.x, h2 = i2.x1, c2 = i2.barYPosition, d2 = o2 + i2.barHeight, u2 = new Mi(this.barCtx.ctx), g2 = new v(), p2 = u2.move(n2, d2) + u2.line(r2, d2) + u2.line(l2, c2) + u2.line(h2, c2) + u2.line(n2, d2) + ("around" === s2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[realIndex][j] ? " Z" : " z");
    return u2.drawPath({ d: p2, fill: g2.shadeColor(0.5, v.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(t3) {
    var e2, i2 = t3.i, a2 = t3.j, s2 = this.w, r2 = 0, n2 = 0;
    return (s2.config.plotOptions.bar.horizontal ? s2.globals.series.map((function(t4, e3) {
      return e3;
    })) : (null === (e2 = s2.globals.columnSeries) || void 0 === e2 ? void 0 : e2.i.map((function(t4) {
      return t4;
    }))) || []).forEach((function(t4) {
      var e3 = s2.globals.seriesPercent[t4][a2];
      e3 && r2++, t4 < i2 && 0 === e3 && n2++;
    })), { nonZeroColumns: r2, zeroEncounters: n2 };
  } }, { key: "getGroupIndex", value: function(t3) {
    var e2 = this.w, i2 = e2.globals.seriesGroups.findIndex((function(i3) {
      return i3.indexOf(e2.globals.seriesNames[t3]) > -1;
    })), a2 = this.barCtx.columnGroupIndices, s2 = a2.indexOf(i2);
    return s2 < 0 && (a2.push(i2), s2 = a2.length - 1), { groupIndex: i2, columnGroupIndex: s2 };
  } }]), t2;
})(), Pa = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var s2 = this.w;
    this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal && s2.globals.seriesRange.length && s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a2, null !== this.xyRatios && (this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.invertedXRatio = a2.invertedXRatio, this.invertedYRatio = a2.invertedYRatio, this.baseLineY = a2.baseLineY, this.baseLineInvertedY = a2.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var r2 = new Zi(this.ctx);
    this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var n2 = r2.getBarSeriesIndices(), o2 = new Pi(this.ctx);
    this.stackedSeriesTotals = o2.getStackedSeriesTotals(this.w.config.series.map((function(t3, e3) {
      return -1 === n2.indexOf(e3) ? e3 : -1;
    })).filter((function(t3) {
      return -1 !== t3;
    }))), this.barHelpers = new Ma(this);
  }
  return s(t2, [{ key: "draw", value: function(t3, e2) {
    var i2 = this.w, a2 = new Mi(this.ctx), s2 = new Pi(this.ctx, i2);
    t3 = s2.getLogSeries(t3), this.series = t3, this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    var r2 = a2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i2.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var n2 = 0, o2 = 0; n2 < t3.length; n2++, o2++) {
      var l2, h2, c2, d2, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = i2.globals.comboCharts ? e2[n2] : n2, m2 = this.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = a2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: v.escapeString(i2.globals.seriesNames[b2]), "data:realIndex": b2 });
      this.ctx.series.addCollapsedClassToSeries(y2, b2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
      var w2 = 0, k2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[b2], this.translationsIndex = b2);
      var A2 = this.translationsIndex;
      this.isReversed = i2.config.yaxis[this.yaxisIndex] && i2.config.yaxis[this.yaxisIndex].reversed;
      var C2 = this.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, h2 = C2.yDivision, d2 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, l2 = C2.xDivision, c2 = C2.zeroH, this.isHorizontal || x2.push(g2 + k2 / 2);
      var S2 = a2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 });
      i2.globals.delayedElements.push({ el: S2.node }), S2.node.classList.add("apexcharts-element-hidden");
      var L2 = a2.group({ class: "apexcharts-bar-goals-markers" }), M2 = a2.group({ class: "apexcharts-bar-shadows" });
      i2.globals.delayedElements.push({ el: M2.node }), M2.node.classList.add("apexcharts-element-hidden");
      for (var P2 = 0; P2 < t3[n2].length; P2++) {
        var I2 = this.barHelpers.getStrokeWidth(n2, P2, b2), T2 = null, z2 = { indexes: { i: n2, j: P2, realIndex: b2, translationsIndex: A2, bc: o2 }, x: g2, y: p2, strokeWidth: I2, elSeries: y2 };
        this.isHorizontal ? (T2 = this.drawBarPaths(u(u({}, z2), {}, { barHeight: w2, zeroW: d2, yDivision: h2 })), k2 = this.series[n2][P2] / this.invertedYRatio) : (T2 = this.drawColumnPaths(u(u({}, z2), {}, { xDivision: l2, barWidth: k2, zeroH: c2 })), w2 = this.series[n2][P2] / this.yRatio[A2]);
        var X2 = this.barHelpers.getPathFillColor(t3, n2, P2, b2);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && P2 > 0) {
          var R2, E2 = this.barHelpers.drawBarShadow({ color: "string" == typeof X2.color && -1 === (null === (R2 = X2.color) || void 0 === R2 ? void 0 : R2.indexOf("url")) ? X2.color : v.hexToRgba(i2.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: T2 });
          if (M2.add(E2), i2.config.chart.dropShadow.enabled) new Li(this.ctx).dropShadow(E2, i2.config.chart.dropShadow, b2);
        }
        this.pathArr.push(T2);
        var Y2 = this.barHelpers.drawGoalLine({ barXPosition: T2.barXPosition, barYPosition: T2.barYPosition, goalX: T2.goalX, goalY: T2.goalY, barHeight: w2, barWidth: k2 });
        Y2 && L2.add(Y2), p2 = T2.y, g2 = T2.x, P2 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), this.renderSeries(u(u({ realIndex: b2, pathFill: X2.color }, X2.useRangeColor ? { lineFill: X2.color } : {}), {}, { j: P2, i: n2, columnGroupIndex: m2, pathFrom: T2.pathFrom, pathTo: T2.pathTo, strokeWidth: I2, elSeries: y2, x: g2, y: p2, series: t3, barHeight: Math.abs(T2.barHeight ? T2.barHeight : w2), barWidth: Math.abs(T2.barWidth ? T2.barWidth : k2), elDataLabelsWrap: S2, elGoalsMarkers: L2, elBarShadows: M2, visibleSeries: this.visibleI, type: "bar" }));
      }
      i2.globals.seriesXvalues[b2] = x2, i2.globals.seriesYvalues[b2] = f2, r2.add(y2);
    }
    return r2;
  } }, { key: "renderSeries", value: function(t3) {
    var e2 = t3.realIndex, i2 = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, n2 = t3.columnGroupIndex, o2 = t3.pathFrom, l2 = t3.pathTo, h2 = t3.strokeWidth, c2 = t3.elSeries, d2 = t3.x, u2 = t3.y, g2 = t3.y1, p2 = t3.y2, f2 = t3.series, x2 = t3.barHeight, b2 = t3.barWidth, m2 = t3.barXPosition, v2 = t3.barYPosition, y2 = t3.elDataLabelsWrap, w2 = t3.elGoalsMarkers, k2 = t3.elBarShadows, A2 = t3.visibleSeries, C2 = t3.type, S2 = t3.classes, L2 = this.w, M2 = new Mi(this.ctx), P2 = false;
    if (!a2) {
      var I2 = "function" == typeof L2.globals.stroke.colors[e2] ? (function(t4) {
        var e3, i3 = L2.config.stroke.colors;
        return Array.isArray(i3) && i3.length > 0 && ((e3 = i3[t4]) || (e3 = ""), "function" == typeof e3) ? e3({ value: L2.globals.series[t4][s2], dataPointIndex: s2, w: L2 }) : e3;
      })(e2) : L2.globals.stroke.colors[e2];
      a2 = this.barOptions.distributed ? L2.globals.stroke.colors[s2] : I2;
    }
    var T2 = new La(this).handleBarDataLabels({ x: d2, y: u2, y1: g2, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, columnGroupIndex: n2, barHeight: x2, barWidth: b2, barXPosition: m2, barYPosition: v2, visibleSeries: A2 });
    L2.globals.isBarHorizontal || (T2.dataLabelsPos.dataLabelsX + b2 < 0 || T2.dataLabelsPos.dataLabelsX - b2 > L2.globals.gridWidth) && (P2 = true), L2.config.series[r2].data[s2] && L2.config.series[r2].data[s2].strokeColor && (a2 = L2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i2 = "none");
    var z2 = s2 / L2.config.chart.animations.animateGradually.delay * (L2.config.chart.animations.speed / L2.globals.dataPoints) / 2.4;
    if (!P2) {
      var X2 = M2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: o2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: L2.config.stroke.lineCap, fill: i2, animationDelay: z2, initialSpeed: L2.config.chart.animations.speed, dataChangeSpeed: L2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(C2, "-area ").concat(S2), chartType: C2 });
      X2.attr("clip-path", "url(#gridRectBarMask".concat(L2.globals.cuid, ")"));
      var R2 = L2.config.forecastDataPoints;
      R2.count > 0 && s2 >= L2.globals.dataPoints - R2.count && (X2.node.setAttribute("stroke-dasharray", R2.dashArray), X2.node.setAttribute("stroke-width", R2.strokeWidth), X2.node.setAttribute("fill-opacity", R2.fillOpacity)), void 0 !== g2 && void 0 !== p2 && (X2.attr("data-range-y1", g2), X2.attr("data-range-y2", p2)), new Li(this.ctx).setSelectionFilter(X2, e2, s2), c2.add(X2), X2.attr({ cy: T2.dataLabelsPos.bcy, cx: T2.dataLabelsPos.bcx, j: s2, val: L2.globals.series[r2][s2], barHeight: x2, barWidth: b2 }), null !== T2.dataLabels && y2.add(T2.dataLabels), T2.totalDataLabels && y2.add(T2.totalDataLabels), c2.add(y2), w2 && c2.add(w2), k2 && c2.add(k2);
    }
    return c2;
  } }, { key: "drawBarPaths", value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i2.i, u2 = i2.j;
    if (c2.globals.isXNumeric) e2 = (o2 = (c2.globals.seriesX[d2][u2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
    else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var g2 = this.barHelpers.getZeroValueEncounters({ i: d2, j: u2 }), p2 = g2.nonZeroColumns, f2 = g2.zeroEncounters;
      p2 > 0 && (a2 = this.seriesLen * a2 / p2), e2 = o2 + a2 * this.visibleI, e2 -= a2 * f2;
    } else e2 = o2 + a2 * this.visibleI;
    this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d2][u2], r2) - r2) / 2), n2 = this.barHelpers.getXForValue(this.series[d2][u2], r2);
    var x2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, i: d2, j: u2, w: c2 });
    return c2.globals.isXNumeric || (o2 += l2), this.barHelpers.barBackground({ j: u2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, x1: r2, x: n2, y: o2, goalX: this.barHelpers.getGoalValues("x", r2, null, d2, u2), barYPosition: e2, barHeight: a2 };
  } }, { key: "drawColumnPaths", value: function(t3) {
    var e2, i2 = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, n2 = t3.barWidth, o2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i2.realIndex, u2 = i2.translationsIndex, g2 = i2.i, p2 = i2.j, f2 = i2.bc;
    if (c2.globals.isXNumeric) {
      var x2 = this.getBarXForNumericXAxis({ x: a2, j: p2, realIndex: d2, barWidth: n2 });
      a2 = x2.x, e2 = x2.barXPosition;
    } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: p2 }), m2 = b2.nonZeroColumns, v2 = b2.zeroEncounters;
      m2 > 0 && (n2 = this.seriesLen * n2 / m2), e2 = a2 + n2 * this.visibleI, e2 -= n2 * v2;
    } else e2 = a2 + n2 * this.visibleI;
    s2 = this.barHelpers.getYForValue(this.series[g2][p2], o2, u2);
    var y2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: n2, y1: o2, y2: s2, strokeWidth: l2, isReversed: this.isReversed, series: this.series, realIndex: d2, i: g2, j: p2, w: c2 });
    return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: f2, j: p2, i: g2, x1: e2 - l2 / 2 - n2 * this.visibleI, x2: n2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: y2.pathTo, pathFrom: y2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, o2, g2, p2, u2), barXPosition: e2, barWidth: n2 };
  } }, { key: "getBarXForNumericXAxis", value: function(t3) {
    var e2 = t3.x, i2 = t3.barWidth, a2 = t3.realIndex, s2 = t3.j, r2 = this.w, n2 = a2;
    return r2.globals.seriesX[a2].length || (n2 = r2.globals.maxValsInArrayIndex), v.isNumber(r2.globals.seriesX[n2][s2]) && (e2 = (r2.globals.seriesX[n2][s2] - r2.globals.minX) / this.xRatio - i2 * this.seriesLen / 2), { barXPosition: e2 + i2 * this.visibleI, x: e2 };
  } }, { key: "getPreviousPath", value: function(t3, e2) {
    for (var i2 = this.w, a2 = "M 0 0", s2 = 0; s2 < i2.globals.previousPaths.length; s2++) {
      var r2 = i2.globals.previousPaths[s2];
      r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && void 0 !== i2.globals.previousPaths[s2].paths[e2] && (a2 = i2.globals.previousPaths[s2].paths[e2].d);
    }
    return a2;
  } }]), t2;
})(), Ia = (function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i2 = this, a3 = this.w;
    this.graphics = new Mi(this.ctx), this.bar = new Pa(this.ctx, this.xyRatios);
    var s2 = new Pi(this.ctx, a3);
    t3 = s2.getLogSeries(t3), this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), "100%" === a3.config.chart.stackType && (t3 = a3.globals.comboCharts ? e3.map((function(t4) {
      return a3.globals.seriesPercent[t4];
    })) : a3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
    for (var r2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n2 = 0, o2 = 0, l2 = function(s3, l3) {
      var h3 = void 0, c3 = void 0, d2 = void 0, g2 = void 0, p2 = a3.globals.comboCharts ? e3[s3] : s3, f2 = i2.barHelpers.getGroupIndex(p2), x2 = f2.groupIndex, b2 = f2.columnGroupIndex;
      i2.groupCtx = i2[a3.globals.seriesGroups[x2]];
      var m2 = [], y2 = [], w2 = 0;
      i2.yRatio.length > 1 && (i2.yaxisIndex = a3.globals.seriesYAxisReverseMap[p2][0], w2 = p2), i2.isReversed = a3.config.yaxis[i2.yaxisIndex] && a3.config.yaxis[i2.yaxisIndex].reversed;
      var k2 = i2.graphics.group({ class: "apexcharts-series", seriesName: v.escapeString(a3.globals.seriesNames[p2]), rel: s3 + 1, "data:realIndex": p2 });
      i2.ctx.series.addCollapsedClassToSeries(k2, p2);
      var A2 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": p2 }), C2 = i2.graphics.group({ class: "apexcharts-bar-goals-markers" }), S2 = 0, L2 = 0, M2 = i2.initialPositions(n2, o2, h3, c3, d2, g2, w2);
      o2 = M2.y, S2 = M2.barHeight, c3 = M2.yDivision, g2 = M2.zeroW, n2 = M2.x, L2 = M2.barWidth, h3 = M2.xDivision, d2 = M2.zeroH, a3.globals.barHeight = S2, a3.globals.barWidth = L2, i2.barHelpers.initializeStackedXYVars(i2), 1 === i2.groupCtx.prevY.length && i2.groupCtx.prevY[0].every((function(t4) {
        return isNaN(t4);
      })) && (i2.groupCtx.prevY[0] = i2.groupCtx.prevY[0].map((function() {
        return d2;
      })), i2.groupCtx.prevYF[0] = i2.groupCtx.prevYF[0].map((function() {
        return 0;
      })));
      for (var P2 = 0; P2 < a3.globals.dataPoints; P2++) {
        var I2 = i2.barHelpers.getStrokeWidth(s3, P2, p2), T2 = { indexes: { i: s3, j: P2, realIndex: p2, translationsIndex: w2, bc: l3 }, strokeWidth: I2, x: n2, y: o2, elSeries: k2, columnGroupIndex: b2, seriesGroup: a3.globals.seriesGroups[x2] }, z2 = null;
        i2.isHorizontal ? (z2 = i2.drawStackedBarPaths(u(u({}, T2), {}, { zeroW: g2, barHeight: S2, yDivision: c3 })), L2 = i2.series[s3][P2] / i2.invertedYRatio) : (z2 = i2.drawStackedColumnPaths(u(u({}, T2), {}, { xDivision: h3, barWidth: L2, zeroH: d2 })), S2 = i2.series[s3][P2] / i2.yRatio[w2]);
        var X2 = i2.barHelpers.drawGoalLine({ barXPosition: z2.barXPosition, barYPosition: z2.barYPosition, goalX: z2.goalX, goalY: z2.goalY, barHeight: S2, barWidth: L2 });
        X2 && C2.add(X2), o2 = z2.y, n2 = z2.x, m2.push(n2), y2.push(o2);
        var R2 = i2.barHelpers.getPathFillColor(t3, s3, P2, p2), E2 = "", Y2 = a3.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        ("bottom" === i2.barHelpers.arrBorderRadius[p2][P2] && a3.globals.series[p2][P2] > 0 || "top" === i2.barHelpers.arrBorderRadius[p2][P2] && a3.globals.series[p2][P2] < 0) && (E2 = Y2), k2 = i2.renderSeries(u(u({ realIndex: p2, pathFill: R2.color }, R2.useRangeColor ? { lineFill: R2.color } : {}), {}, { j: P2, i: s3, columnGroupIndex: b2, pathFrom: z2.pathFrom, pathTo: z2.pathTo, strokeWidth: I2, elSeries: k2, x: n2, y: o2, series: t3, barHeight: S2, barWidth: L2, elDataLabelsWrap: A2, elGoalsMarkers: C2, type: "bar", visibleSeries: b2, classes: E2 }));
      }
      a3.globals.seriesXvalues[p2] = m2, a3.globals.seriesYvalues[p2] = y2, i2.groupCtx.prevY.push(i2.groupCtx.yArrj), i2.groupCtx.prevYF.push(i2.groupCtx.yArrjF), i2.groupCtx.prevYVal.push(i2.groupCtx.yArrjVal), i2.groupCtx.prevX.push(i2.groupCtx.xArrj), i2.groupCtx.prevXF.push(i2.groupCtx.xArrjF), i2.groupCtx.prevXVal.push(i2.groupCtx.xArrjVal), r2.add(k2);
    }, h2 = 0, c2 = 0; h2 < t3.length; h2++, c2++) l2(h2, c2);
    return r2;
  } }, { key: "initialPositions", value: function(t3, e3, i2, a3, s2, r2, n2) {
    var o2, l2, h2 = this.w;
    if (this.isHorizontal) {
      a3 = h2.globals.gridHeight / h2.globals.dataPoints;
      var c2 = h2.config.plotOptions.bar.barHeight;
      o2 = -1 === String(c2).indexOf("%") ? parseInt(c2, 10) : a3 * parseInt(c2, 10) / 100, r2 = h2.globals.padHorizontal + (this.isReversed ? h2.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e3 = (a3 - o2) / 2;
    } else {
      l2 = i2 = h2.globals.gridWidth / h2.globals.dataPoints;
      var d2 = h2.config.plotOptions.bar.columnWidth;
      h2.globals.isXNumeric && h2.globals.dataPoints > 1 ? l2 = (i2 = h2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d2).indexOf("%") ? l2 = parseInt(d2, 10) : l2 *= parseInt(d2, 10) / 100, s2 = this.isReversed ? this.baseLineY[n2] : h2.globals.gridHeight - this.baseLineY[n2], t3 = h2.globals.padHorizontal + (i2 - l2) / 2;
    }
    var u2 = h2.globals.barGroups.length || 1;
    return { x: t3, y: e3, yDivision: a3, xDivision: i2, barHeight: o2 / u2, barWidth: l2 / u2, zeroH: s2, zeroW: r2 };
  } }, { key: "drawStackedBarPaths", value: function(t3) {
    for (var e3, i2 = t3.indexes, a3 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.columnGroupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, u2 = this.w, g2 = o2 + l2 * a3, p2 = i2.i, f2 = i2.j, x2 = i2.realIndex, b2 = i2.translationsIndex, m2 = 0, v2 = 0; v2 < this.groupCtx.prevXF.length; v2++) m2 += this.groupCtx.prevXF[v2][f2];
    var y2 = p2;
    if (u2.config.series[x2].name && (y2 = h2.indexOf(u2.config.series[x2].name)), y2 > 0) {
      var w2 = r2;
      this.groupCtx.prevXVal[y2 - 1][f2] < 0 ? w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] + m2 - 2 * (this.isReversed ? m2 : 0) : this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevXVal[y2 - 1][f2] >= 0 && (w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevX[y2 - 1][f2] - m2 + 2 * (this.isReversed ? m2 : 0)), e3 = w2;
    } else e3 = r2;
    n2 = null === this.series[p2][f2] ? e3 : e3 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
    var k2 = this.barHelpers.getBarpaths({ barYPosition: g2, barHeight: a3, x1: e3, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i2.realIndex, seriesGroup: h2, i: p2, j: f2, w: u2 });
    return this.barHelpers.barBackground({ j: f2, i: p2, y1: g2, y2: a3, elSeries: d2 }), o2 += c2, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p2, f2, b2), barXPosition: e3, barYPosition: g2, x: n2, y: o2 };
  } }, { key: "drawStackedColumnPaths", value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x, a3 = t3.y, s2 = t3.xDivision, r2 = t3.barWidth, n2 = t3.zeroH, o2 = t3.columnGroupIndex, l2 = t3.seriesGroup, h2 = t3.elSeries, c2 = this.w, d2 = e3.i, u2 = e3.j, g2 = e3.bc, p2 = e3.realIndex, f2 = e3.translationsIndex;
    if (c2.globals.isXNumeric) {
      var x2 = c2.globals.seriesX[p2][u2];
      x2 || (x2 = 0), i2 = (x2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.barGroups.length;
    }
    for (var b2, m2 = i2 + o2 * r2, v2 = 0, y2 = 0; y2 < this.groupCtx.prevYF.length; y2++) v2 += isNaN(this.groupCtx.prevYF[y2][u2]) ? 0 : this.groupCtx.prevYF[y2][u2];
    var w2 = d2;
    if (l2 && (w2 = l2.indexOf(c2.globals.seriesNames[p2])), w2 > 0 && !c2.globals.isXNumeric || w2 > 0 && c2.globals.isXNumeric && c2.globals.seriesX[p2 - 1][u2] === c2.globals.seriesX[p2][u2]) {
      var k2, A2, C2, S2 = Math.min(this.yRatio.length + 1, p2 + 1);
      if (void 0 !== this.groupCtx.prevY[w2 - 1] && this.groupCtx.prevY[w2 - 1].length) for (var L2 = 1; L2 < S2; L2++) {
        var M2;
        if (!isNaN(null === (M2 = this.groupCtx.prevY[w2 - L2]) || void 0 === M2 ? void 0 : M2[u2])) {
          C2 = this.groupCtx.prevY[w2 - L2][u2];
          break;
        }
      }
      for (var P2 = 1; P2 < S2; P2++) {
        var I2, T2;
        if ((null === (I2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === I2 ? void 0 : I2[u2]) < 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 - v2 + 2 * (this.isReversed ? v2 : 0) : C2;
          break;
        }
        if ((null === (T2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === T2 ? void 0 : T2[u2]) >= 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 : C2 + v2 - 2 * (this.isReversed ? v2 : 0);
          break;
        }
      }
      void 0 === A2 && (A2 = c2.globals.gridHeight), b2 = null !== (k2 = this.groupCtx.prevYF[0]) && void 0 !== k2 && k2.every((function(t4) {
        return 0 === t4;
      })) && this.groupCtx.prevYF.slice(1, w2).every((function(t4) {
        return t4.every((function(t5) {
          return isNaN(t5);
        }));
      })) ? n2 : A2;
    } else b2 = n2;
    a3 = this.series[d2][u2] ? b2 - this.series[d2][u2] / this.yRatio[f2] + 2 * (this.isReversed ? this.series[d2][u2] / this.yRatio[f2] : 0) : b2;
    var z2 = this.barHelpers.getColumnPaths({ barXPosition: m2, barWidth: r2, y1: b2, y2: a3, yRatio: this.yRatio[f2], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: l2, realIndex: e3.realIndex, i: d2, j: u2, w: c2 });
    return this.barHelpers.barBackground({ bc: g2, j: u2, i: d2, x1: m2, x2: r2, elSeries: h2 }), { pathTo: z2.pathTo, pathFrom: z2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, n2, d2, u2), barXPosition: m2, x: c2.globals.isXNumeric ? i2 : i2 + s2, y: a3 };
  } }]), a2;
})(), Ta = (function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3, i2) {
    var a3 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.globals.comboCharts ? e3 : s2.config.chart.type, o2 = new ji(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s2.config.plotOptions.bar.horizontal, this.isOHLC = this.candlestickOptions && "ohlc" === this.candlestickOptions.type;
    var l2 = new Pi(this.ctx, s2);
    t3 = l2.getLogSeries(t3), this.series = t3, this.yRatio = l2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    for (var h2 = r2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), c2 = function(e4) {
      a3.isBoxPlot = "boxPlot" === s2.config.chart.type || "boxPlot" === s2.config.series[e4].type;
      var n3, l3, c3, d3, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = s2.globals.comboCharts ? i2[e4] : e4, m2 = a3.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = r2.group({ class: "apexcharts-series", seriesName: v.escapeString(s2.globals.seriesNames[b2]), rel: e4 + 1, "data:realIndex": b2 });
      a3.ctx.series.addCollapsedClassToSeries(y2, b2), t3[e4].length > 0 && (a3.visibleI = a3.visibleI + 1);
      var w2, k2, A2 = 0;
      a3.yRatio.length > 1 && (a3.yaxisIndex = s2.globals.seriesYAxisReverseMap[b2][0], A2 = b2);
      var C2 = a3.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, l3 = C2.yDivision, d3 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, n3 = C2.xDivision, c3 = C2.zeroH, x2.push(g2 + k2 / 2);
      for (var S2 = r2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 }), L2 = r2.group({ class: "apexcharts-bar-goals-markers" }), M2 = function(i3) {
        var r3 = a3.barHelpers.getStrokeWidth(e4, i3, b2), h3 = null, v2 = { indexes: { i: e4, j: i3, realIndex: b2, translationsIndex: A2 }, x: g2, y: p2, strokeWidth: r3, elSeries: y2 };
        h3 = a3.isHorizontal ? a3.drawHorizontalBoxPaths(u(u({}, v2), {}, { yDivision: l3, barHeight: w2, zeroW: d3 })) : a3.drawVerticalBoxPaths(u(u({}, v2), {}, { xDivision: n3, barWidth: k2, zeroH: c3 })), p2 = h3.y, g2 = h3.x;
        var C3 = a3.barHelpers.drawGoalLine({ barXPosition: h3.barXPosition, barYPosition: h3.barYPosition, goalX: h3.goalX, goalY: h3.goalY, barHeight: w2, barWidth: k2 });
        C3 && L2.add(C3), i3 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), h3.pathTo.forEach((function(n4, l4) {
          var c4 = !a3.isBoxPlot && a3.candlestickOptions.wick.useFillColor ? h3.color[l4] : s2.globals.stroke.colors[e4], d4 = o2.fillPath({ seriesNumber: b2, dataPointIndex: i3, color: h3.color[l4], value: t3[e4][i3] });
          a3.renderSeries({ realIndex: b2, pathFill: d4, lineFill: c4, j: i3, i: e4, pathFrom: h3.pathFrom, pathTo: n4, strokeWidth: r3, elSeries: y2, x: g2, y: p2, series: t3, columnGroupIndex: m2, barHeight: w2, barWidth: k2, elDataLabelsWrap: S2, elGoalsMarkers: L2, visibleSeries: a3.visibleI, type: s2.config.chart.type });
        }));
      }, P2 = 0; P2 < s2.globals.dataPoints; P2++) M2(P2);
      s2.globals.seriesXvalues[b2] = x2, s2.globals.seriesYvalues[b2] = f2, h2.add(y2);
    }, d2 = 0; d2 < t3.length; d2++) c2(d2);
    return h2;
  } }, { key: "drawVerticalBoxPaths", value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x;
    t3.y;
    var a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.zeroH, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = o2.config.plotOptions.candlestick.colors, u2 = this.boxOptions.colors, g2 = e3.realIndex, p2 = function(t4) {
      return Array.isArray(t4) ? t4[g2] : t4;
    }, f2 = p2(d2.upward), x2 = p2(d2.downward), b2 = this.yRatio[e3.translationsIndex], m2 = this.getOHLCValue(g2, c2), v2 = r2, y2 = r2, w2 = m2.o < m2.c ? [f2] : [x2];
    this.isBoxPlot && (w2 = [p2(u2.lower), p2(u2.upper)]);
    var k2 = Math.min(m2.o, m2.c), A2 = Math.max(m2.o, m2.c), C2 = m2.m;
    o2.globals.isXNumeric && (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.xRatio - s2 / 2);
    var S2 = i2 + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (k2 = r2, A2 = r2) : (k2 = r2 - k2 / b2, A2 = r2 - A2 / b2, v2 = r2 - m2.h / b2, y2 = r2 - m2.l / b2, C2 = r2 - m2.m / b2);
    var L2 = l2.move(S2, r2), M2 = l2.move(S2 + s2 / 2, k2);
    if (o2.globals.previousPaths.length > 0 && (M2 = this.getPreviousPath(g2, c2, true)), this.isOHLC) {
      var P2 = S2 + s2 / 2, I2 = r2 - m2.o / b2, T2 = r2 - m2.c / b2;
      L2 = [l2.move(P2, v2) + l2.line(P2, y2) + l2.move(P2, I2) + l2.line(S2, I2) + l2.move(P2, T2) + l2.line(S2 + s2, T2)];
    } else L2 = this.isBoxPlot ? [l2.move(S2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 4, v2) + l2.line(S2 + s2 - s2 / 4, v2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2, C2) + l2.line(S2, C2) + l2.line(S2, k2 + n2 / 2), l2.move(S2, C2) + l2.line(S2 + s2, C2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 - s2 / 4, y2) + l2.line(S2 + s2 / 4, y2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2, A2) + l2.line(S2, C2) + "z"] : [l2.move(S2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2 - n2 / 2)];
    return M2 += l2.move(S2, k2), o2.globals.isXNumeric || (i2 += a3), { pathTo: L2, pathFrom: M2, x: i2, y: A2, goalY: this.barHelpers.getGoalValues("y", null, r2, h2, c2, e3.translationsIndex), barXPosition: S2, color: w2 };
  } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
    var e3 = t3.indexes;
    t3.x;
    var i2 = t3.y, a3 = t3.yDivision, s2 = t3.barHeight, r2 = t3.zeroW, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = this.boxOptions.colors.lower;
    this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var u2 = this.invertedYRatio, g2 = e3.realIndex, p2 = this.getOHLCValue(g2, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), m2 = Math.max(p2.o, p2.c), v2 = p2.m;
    o2.globals.isXNumeric && (i2 = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.invertedXRatio - s2 / 2);
    var y2 = i2 + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (b2 = r2, m2 = r2) : (b2 = r2 + b2 / u2, m2 = r2 + m2 / u2, f2 = r2 + p2.h / u2, x2 = r2 + p2.l / u2, v2 = r2 + p2.m / u2);
    var w2 = l2.move(r2, y2), k2 = l2.move(b2, y2 + s2 / 2);
    return o2.globals.previousPaths.length > 0 && (k2 = this.getPreviousPath(g2, c2, true)), w2 = [l2.move(b2, y2) + l2.line(b2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2 - s2 / 4) + l2.line(f2, y2 + s2 / 2 + s2 / 4) + l2.line(f2, y2 + s2 / 2) + l2.line(b2, y2 + s2 / 2) + l2.line(b2, y2 + s2) + l2.line(v2, y2 + s2) + l2.line(v2, y2) + l2.line(b2 + n2 / 2, y2), l2.move(v2, y2) + l2.line(v2, y2 + s2) + l2.line(m2, y2 + s2) + l2.line(m2, y2 + s2 / 2) + l2.line(x2, y2 + s2 / 2) + l2.line(x2, y2 + s2 - s2 / 4) + l2.line(x2, y2 + s2 / 4) + l2.line(x2, y2 + s2 / 2) + l2.line(m2, y2 + s2 / 2) + l2.line(m2, y2) + l2.line(v2, y2) + "z"], k2 += l2.move(b2, y2), o2.globals.isXNumeric || (i2 += a3), { pathTo: w2, pathFrom: k2, x: m2, y: i2, goalX: this.barHelpers.getGoalValues("x", r2, null, h2, c2), barYPosition: y2, color: d2 };
  } }, { key: "getOHLCValue", value: function(t3, e3) {
    var i2 = this.w, a3 = new Pi(this.ctx, i2), s2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleH[t3][e3], t3), r2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleO[t3][e3], t3), n2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleM[t3][e3], t3), o2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleC[t3][e3], t3), l2 = a3.getLogValAtSeriesIndex(i2.globals.seriesCandleL[t3][e3], t3);
    return { o: this.isBoxPlot ? s2 : r2, h: this.isBoxPlot ? r2 : s2, m: n2, l: this.isBoxPlot ? o2 : l2, c: this.isBoxPlot ? l2 : o2 };
  } }]), a2;
})(), za = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkColorRange", value: function() {
    var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
    return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map((function(t4, i3) {
      t4.from <= 0 && (e2 = true);
    })), e2;
  } }, { key: "getShadeColor", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = 1, n2 = s2.config.plotOptions[t3].shadeIntensity, o2 = this.determineColor(t3, e2, i2);
    s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? o2.percent < 0 ? o2.percent / 100 * (1.25 * n2) : (1 - o2.percent / 100) * (1.25 * n2) : o2.percent <= 0 ? 1 - (1 + o2.percent / 100) * n2 : (1 - o2.percent / 100) * n2 : (r2 = 1 - o2.percent / 100, "treemap" === t3 && (r2 = (1 - o2.percent / 100) * (1.25 * n2)));
    var l2 = o2.color, h2 = new v();
    if (s2.config.plotOptions[t3].enableShades) if ("dark" === this.w.config.theme.mode) {
      var c2 = h2.shadeColor(-1 * r2, o2.color);
      l2 = v.hexToRgba(v.isColorHex(c2) ? c2 : v.rgb2hex(c2), s2.config.fill.opacity);
    } else {
      var d2 = h2.shadeColor(r2, o2.color);
      l2 = v.hexToRgba(v.isColorHex(d2) ? d2 : v.rgb2hex(d2), s2.config.fill.opacity);
    }
    return { color: l2, colorProps: o2 };
  } }, { key: "determineColor", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], n2 = r2.colorScale.inverse ? i2 : e2;
    r2.distributed && "treemap" === a2.config.chart.type && (n2 = i2);
    var o2 = a2.globals.colors[n2], l2 = null, h2 = Math.min.apply(Math, f(a2.globals.series[e2])), c2 = Math.max.apply(Math, f(a2.globals.series[e2]));
    r2.distributed || "heatmap" !== t3 || (h2 = a2.globals.minY, c2 = a2.globals.maxY), void 0 !== r2.colorScale.min && (h2 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
    var d2 = Math.abs(c2) + Math.abs(h2), u2 = 100 * s2 / (0 === d2 ? d2 - 1e-6 : d2);
    r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map((function(t4, e3) {
      if (s2 >= t4.from && s2 <= t4.to) {
        o2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
        var i3 = Math.abs(c2) + Math.abs(h2);
        u2 = 100 * s2 / (0 === i3 ? i3 - 1e-6 : i3);
      }
    }));
    return { color: o2, foreColor: l2, percent: u2 };
  } }, { key: "calculateDataLabels", value: function(t3) {
    var e2 = t3.text, i2 = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, n2 = t3.colorProps, o2 = t3.fontSize, l2 = this.w.config.dataLabels, h2 = new Mi(this.ctx), c2 = new qi(this.ctx), d2 = null;
    if (l2.enabled) {
      d2 = h2.group({ class: "apexcharts-data-labels" });
      var u2 = l2.offsetX, g2 = l2.offsetY, p2 = i2 + u2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + g2;
      c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: n2.foreColor, parent: d2, fontSize: o2, dataLabelsConfig: l2 });
    }
    return d2;
  } }, { key: "addListeners", value: function(t3) {
    var e2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
  } }]), t2;
})(), Xa = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new za(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a2 = i2.group({ class: "apexcharts-heatmap" });
    a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
    var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, n2 = 0, o2 = false;
    this.negRange = this.helpers.checkColorRange();
    var l2 = t3.slice();
    e2.config.yaxis[0].reversed && (o2 = true, l2.reverse());
    for (var h2 = o2 ? 0 : l2.length - 1; o2 ? h2 < l2.length : h2 >= 0; o2 ? h2++ : h2--) {
      var c2 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: v.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
      if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
        var d2 = e2.config.chart.dropShadow;
        new Li(this.ctx).dropShadow(c2, d2, h2);
      }
      for (var u2 = 0, g2 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0, f2 = 0; f2 < e2.globals.dataPoints; f2++) if (e2.globals.seriesX.length && !e2.globals.allSeriesHasEqualX && e2.globals.minX + e2.globals.minXDiff * f2 < e2.globals.seriesX[h2][p2]) u2 += s2;
      else {
        if (p2 >= l2[h2].length) break;
        var x2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = x2.color, m2 = x2.colorProps;
        if ("image" === e2.config.fill.type) b2 = new ji(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? m2.percent < 0 ? 1 - (1 + m2.percent / 100) : g2 + m2.percent / 100 : m2.percent / 100, patternID: v.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
        var y2 = this.rectRadius, w2 = i2.drawRect(u2, n2, s2, r2, y2);
        if (w2.attr({ cx: u2, cy: n2 }), w2.node.classList.add("apexcharts-heatmap-rect"), c2.add(w2), w2.attr({ fill: b2, i: h2, index: h2, j: p2, val: t3[h2][p2], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(w2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
          var k2 = 1;
          e2.globals.resized || (k2 = e2.config.chart.animations.speed), this.animateHeatMap(w2, u2, n2, s2, r2, k2);
        }
        if (e2.globals.dataChanged) {
          var A2 = 1;
          if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
            A2 = this.dynamicAnim.speed;
            var C2 = e2.globals.previousPaths[h2] && e2.globals.previousPaths[h2][p2] && e2.globals.previousPaths[h2][p2].color;
            C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(w2, v.isColorHex(C2) ? C2 : v.rgb2hex(C2), v.isColorHex(b2) ? b2 : v.rgb2hex(b2), A2);
          }
        }
        var S2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), L2 = this.helpers.calculateDataLabels({ text: S2, x: u2 + s2 / 2, y: n2 + r2 / 2, i: h2, j: p2, colorProps: m2, series: l2 });
        null !== L2 && c2.add(L2), u2 += s2, p2++;
      }
      n2 += r2, a2.add(c2);
    }
    var M2 = e2.globals.yAxisScale[0].result.slice();
    return e2.config.yaxis[0].reversed ? M2.unshift("") : M2.push(""), e2.globals.yAxisScale[0].result = M2, a2;
  } }, { key: "animateHeatMap", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new y(this.ctx);
    n2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, (function() {
      n2.animationCompleted(t3);
    }));
  } }, { key: "animateHeatColor", value: function(t3, e2, i2, a2) {
    t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
  } }]), t2;
})(), Ra = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i2, a2) {
    var s2 = this.w, r2 = s2.config.yaxis[0], n2 = s2.globals.yLabelFormatters[0];
    return new Mi(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: n2(a2, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
  } }]), t2;
})(), Ea = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = Math.min(a2.globals.gridWidth, a2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a2.globals.gridWidth / 2, "radialBar" === a2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a2.config.plotOptions.pie.endAngle - a2.config.plotOptions.pie.startAngle), this.initialAngle = a2.config.plotOptions.pie.startAngle % this.fullAngle, a2.globals.radialSize = this.defaultSize / 2.05 - a2.config.stroke.width - (a2.config.chart.sparkline.enabled ? 0 : a2.config.chart.dropShadow.blur), this.donutSize = a2.globals.radialSize * parseInt(a2.config.plotOptions.pie.donut.size, 10) / 100;
    var s2 = a2.config.plotOptions.pie.customScale, r2 = a2.globals.gridWidth / 2, n2 = a2.globals.gridHeight / 2;
    this.translateX = r2 - r2 * s2, this.translateY = n2 - n2 * s2, this.dataLabelsGroup = new Mi(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s2, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = a2.group({ class: "apexcharts-pie" });
    if (i2.globals.noData) return s2;
    for (var r2 = 0, n2 = 0; n2 < t3.length; n2++) r2 += v.negToZero(t3[n2]);
    var o2 = [], l2 = a2.group();
    0 === r2 && (r2 = 1e-5), t3.forEach((function(t4) {
      e2.maxY = Math.max(e2.maxY, t4);
    })), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), "back" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s2);
    for (var h2 = 0; h2 < t3.length; h2++) {
      var c2 = this.fullAngle * v.negToZero(t3[h2]) / r2;
      o2.push(c2), "polarArea" === this.chartType ? (o2[h2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[h2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
    }
    if (i2.globals.dataChanged) {
      for (var d2, u2 = 0, g2 = 0; g2 < i2.globals.previousPaths.length; g2++) u2 += v.negToZero(i2.globals.previousPaths[g2]);
      for (var p2 = 0; p2 < i2.globals.previousPaths.length; p2++) d2 = this.fullAngle * v.negToZero(i2.globals.previousPaths[p2]) / u2, this.prevSectorAngleArr.push(d2);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
      var f2 = a2.drawCircle(this.donutSize);
      f2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), l2.add(f2);
    }
    var x2 = this.drawArcs(o2, t3);
    if (this.sliceLabels.forEach((function(t4) {
      x2.add(t4);
    })), l2.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), l2.add(x2), s2.add(l2), this.donutDataLabels.show) {
      var b2 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      s2.add(b2);
    }
    return "front" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s2), s2;
  } }, { key: "drawArcs", value: function(t3, e2) {
    var i2 = this.w, a2 = new Li(this.ctx), s2 = new Mi(this.ctx), r2 = new ji(this.ctx), n2 = s2.group({ class: "apexcharts-slices" }), o2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
    this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
    for (var d2 = 0; d2 < t3.length; d2++) {
      var u2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: v.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
      n2.add(u2), l2 = c2, h2 = (o2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
      var g2 = h2 < o2 ? this.fullAngle + h2 - o2 : h2 - o2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), x2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
      if (x2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(x2, 0, d2), i2.config.chart.dropShadow.enabled) {
        var b2 = i2.config.chart.dropShadow;
        a2.dropShadow(x2, b2, d2);
      }
      this.addListeners(x2, this.donutDataLabels), Mi.setAttrs(x2.node, { "data:angle": g2, "data:startAngle": o2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
      var m2 = { x: 0, y: 0 };
      "pie" === this.chartType || "polarArea" === this.chartType ? m2 = v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle) : "donut" === this.chartType && (m2 = v.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle)), u2.add(x2);
      var y2 = 0;
      if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (y2 = g2 / this.fullAngle * i2.config.chart.animations.speed) && (y2 = 1), this.animDur = y2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: y2 }), i2.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && x2.node.addEventListener("mouseup", this.pieClicked.bind(this, d2)), void 0 !== i2.globals.selectedDataPoints[0] && i2.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i2.config.dataLabels.enabled) {
        var w2 = m2.x, k2 = m2.y, A2 = 100 * g2 / this.fullAngle + "%";
        if (0 !== g2 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
          var C2 = i2.config.dataLabels.formatter;
          void 0 !== C2 && (A2 = C2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
          var S2 = i2.globals.dataLabels.style.colors[d2], L2 = s2.group({ class: "apexcharts-datalabels" }), M2 = s2.drawText({ x: w2, y: k2, text: A2, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: S2 });
          if (L2.add(M2), i2.config.dataLabels.dropShadow.enabled) {
            var P2 = i2.config.dataLabels.dropShadow;
            a2.dropShadow(M2, P2);
          }
          M2.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && false === i2.globals.resized && (M2.node.classList.add("apexcharts-pie-label-delay"), M2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(L2);
        }
      }
    }
    return n2;
  } }, { key: "addListeners", value: function(t3, e2) {
    var i2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
  } }, { key: "animatePaths", value: function(t3, e2) {
    var i2 = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, n2 = e2.startAngle;
    void 0 !== e2.prevStartAngle && void 0 !== e2.prevEndAngle && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 && (a2 + n2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + n2) : a2 + n2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + n2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, n2, a2, s2, e2);
  } }, { key: "animateArc", value: function(t3, e2, i2, a2, s2, r2) {
    var n2, o2 = this, l2 = this.w, h2 = new y(this.ctx), c2 = r2.size;
    (isNaN(e2) || isNaN(s2)) && (e2 = i2, s2 = a2, r2.dur = 0);
    var d2 = a2, u2 = i2, g2 = e2 < i2 ? this.fullAngle + e2 - i2 : e2 - i2;
    l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (n2 = o2.getPiePath({ me: o2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: n2 })), 0 !== r2.dur ? t3.animate(r2.dur, r2.animBeginArr[r2.i]).after((function() {
      "pie" !== o2.chartType && "donut" !== o2.chartType && "polarArea" !== o2.chartType || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": o2.strokeWidth }), r2.i === l2.config.series.length - 1 && h2.animationCompleted(t3);
    })).during((function(l3) {
      d2 = g2 + (a2 - g2) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, u2 = e2 - s2 + (i2 - (e2 - s2)) * l3), n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2 });
    })) : (n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2, "stroke-width": o2.strokeWidth }));
  } }, { key: "pieClicked", value: function(t3) {
    var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.findOne(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3));
    if ("true" !== r2.attr("data:pieClicked")) {
      var n2 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(n2, (function(t4) {
        t4.setAttribute("data:pieClicked", "false");
        var e3 = t4.getAttribute("data:pathOrig");
        e3 && t4.setAttribute("d", e3);
      })), i2.globals.capturedDataPointIndex = t3, r2.attr("data:pieClicked", "true");
      var o2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
      e2 = a2.getPiePath({ me: a2, startAngle: o2, angle: l2, size: s2 }), 360 !== l2 && r2.plot(e2);
    } else {
      r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
      var h2 = r2.attr("data:pathOrig");
      r2.attr({ d: h2 });
    }
  } }, { key: "getChangedPath", value: function(t3, e2) {
    var i2 = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
  } }, { key: "getPiePath", value: function(t3) {
    var e2, i2 = t3.me, a2 = t3.startAngle, s2 = t3.angle, r2 = t3.size, n2 = new Mi(this.ctx), o2 = a2, l2 = Math.PI * (o2 - 90) / 180, h2 = s2 + a2;
    Math.ceil(h2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h2) > this.fullAngle && (h2 -= this.fullAngle);
    var c2 = Math.PI * (h2 - 90) / 180, d2 = i2.centerX + r2 * Math.cos(l2), u2 = i2.centerY + r2 * Math.sin(l2), g2 = i2.centerX + r2 * Math.cos(c2), p2 = i2.centerY + r2 * Math.sin(c2), f2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, h2), x2 = v.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, o2), b2 = s2 > 180 ? 1 : 0, m2 = ["M", d2, u2, "A", r2, r2, 0, b2, 1, g2, p2];
    return e2 = "donut" === i2.chartType ? [].concat(m2, ["L", f2.x, f2.y, "A", i2.donutSize, i2.donutSize, 0, b2, 0, x2.x, x2.y, "L", d2, u2, "z"]).join(" ") : "pie" === i2.chartType || "polarArea" === i2.chartType ? [].concat(m2, ["L", i2.centerX, i2.centerY, "L", d2, u2]).join(" ") : [].concat(m2).join(" "), n2.roundPathCorners(e2, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(t3) {
    var e2 = this.w, i2 = new ta(this.ctx), a2 = new Mi(this.ctx), s2 = new Ra(this.ctx), r2 = a2.group(), n2 = a2.group(), o2 = i2.niceScale(0, Math.ceil(this.maxY), 0), l2 = o2.result.reverse(), h2 = o2.result.length;
    this.maxY = o2.niceMax;
    for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), u2 = 0; u2 < h2 - 1; u2++) {
      var g2 = a2.drawCircle(c2);
      if (g2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
        var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, u2, l2[u2]);
        n2.add(p2);
      }
      r2.add(g2), c2 -= d2;
    }
    this.drawSpokes(t3), t3.add(r2), t3.add(n2);
  } }, { key: "renderInnerDataLabels", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = e2.total.show;
    t3.node.innerHTML = "", t3.node.style.opacity = i2.opacity;
    var n2, o2, l2 = i2.centerX, h2 = this.donutDataLabels.total.label ? i2.centerY : i2.centerY - i2.centerY / 6;
    n2 = void 0 === e2.name.color ? a2.globals.colors[0] : e2.name.color;
    var c2 = e2.name.fontSize, d2 = e2.name.fontFamily, u2 = e2.name.fontWeight;
    o2 = void 0 === e2.value.color ? a2.config.chart.foreColor : e2.value.color;
    var g2 = e2.value.formatter, p2 = "", f2 = "";
    if (r2 ? (n2 = e2.total.color, c2 = e2.total.fontSize, d2 = e2.total.fontFamily, u2 = e2.total.fontWeight, f2 = this.donutDataLabels.total.label ? e2.total.label : "", p2 = e2.total.formatter(a2)) : 1 === a2.globals.series.length && (p2 = g2(a2.globals.series[0], a2), f2 = a2.globals.seriesNames[0]), f2 && (f2 = e2.name.formatter(f2, e2.total.show, a2)), e2.name.show) {
      var x2 = s2.drawText({ x: l2, y: h2 + parseFloat(e2.name.offsetY), text: f2, textAnchor: "middle", foreColor: n2, fontSize: c2, fontWeight: u2, fontFamily: d2 });
      x2.node.classList.add("apexcharts-datalabel-label"), t3.add(x2);
    }
    if (e2.value.show) {
      var b2 = e2.name.show ? parseFloat(e2.value.offsetY) + 16 : e2.value.offsetY, m2 = s2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: "middle", foreColor: o2, fontWeight: e2.value.fontWeight, fontSize: e2.value.fontSize, fontFamily: e2.value.fontFamily });
      m2.node.classList.add("apexcharts-datalabel-value"), t3.add(m2);
    }
    return t3;
  } }, { key: "printInnerLabels", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w;
    a2 ? s2 = void 0 === t3.name.color ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
    var n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i2 = (0, t3.value.formatter)(i2, r2), a2 || "function" != typeof t3.total.formatter || (i2 = t3.total.formatter(r2));
    var l2 = e2 === t3.total.label;
    e2 = this.donutDataLabels.total.label ? t3.name.formatter(e2, l2, r2) : "", null !== n2 && (n2.textContent = e2), null !== o2 && (o2.textContent = i2), null !== n2 && (n2.style.fill = s2);
  } }, { key: "printDataLabelsInner", value: function(t3, e2) {
    var i2 = this.w, a2 = t3.getAttribute("data:value"), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
    i2.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
    var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    null !== r2 && (r2.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
    if (0 !== s2.strokeWidth) {
      for (var r2 = [], n2 = 360 / i2.globals.series.length, o2 = 0; o2 < i2.globals.series.length; o2++) r2.push(v.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + n2 * o2));
      r2.forEach((function(i3, r3) {
        var n3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
        t3.add(n3);
      }));
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var t3 = this.w;
    if (this.donutDataLabels.show) {
      var e2 = t3.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i2 = this.renderInnerDataLabels(e2, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      t3.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i2);
    }
  } }]), t2;
})(), Ya = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var a2 = this.w;
    this.graphics = new Mi(this.ctx), this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = a2.globals.svgHeight < a2.globals.svgWidth ? a2.globals.gridHeight : a2.globals.gridWidth, this.isLog = a2.config.yaxis[0].logarithmic, this.logBase = a2.config.yaxis[0].logBase, this.coreUtils = new Pi(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a2.globals.maxY, 0) : a2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a2.globals.minY, this.polygons = a2.config.plotOptions.radar.polygons, this.strokeWidth = a2.config.stroke.show ? a2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a2.config.chart.dropShadow.blur, a2.config.xaxis.labels.show && (this.size = this.size - a2.globals.xAxisLabelsWidth / 1.75), void 0 !== a2.config.plotOptions.radar.size && (this.size = a2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new ji(this.ctx), s2 = [], r2 = new qi(this.ctx);
    t3.length && (this.dataPointsLen = t3[i2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var n2 = i2.globals.gridWidth / 2, o2 = i2.globals.gridHeight / 2, l2 = n2 + i2.config.plotOptions.radar.offsetX, h2 = o2 + i2.config.plotOptions.radar.offsetY, c2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(l2 || 0, ", ").concat(h2 || 0, ")") }), d2 = [], g2 = null, p2 = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach((function(t4, n3) {
      var o3 = t4.length === i2.globals.dataPoints, l3 = e2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": o3, seriesName: v.escapeString(i2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
      e2.dataRadiusOfPercent[n3] = [], e2.dataRadius[n3] = [], e2.angleArr[n3] = [], t4.forEach((function(t5, i3) {
        var a3 = Math.abs(e2.maxValue - e2.minValue);
        t5 -= e2.minValue, e2.isLog && (t5 = e2.coreUtils.getLogVal(e2.logBase, t5, 0)), e2.dataRadiusOfPercent[n3][i3] = t5 / a3, e2.dataRadius[n3][i3] = e2.dataRadiusOfPercent[n3][i3] * e2.size, e2.angleArr[n3][i3] = i3 * e2.disAngle;
      })), d2 = e2.getDataPointsPos(e2.dataRadius[n3], e2.angleArr[n3]);
      var h3 = e2.createPaths(d2, { x: 0, y: 0 });
      g2 = e2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p2 = e2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), i2.globals.delayedElements.push({ el: g2.node, index: n3 });
      var c3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: i2.config.chart.animations.speed, dataChangeSpeed: i2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i2.globals.stroke.colors[n3], strokeLineCap: i2.config.stroke.lineCap }, f3 = null;
      i2.globals.previousPaths.length > 0 && (f3 = e2.getPreviousPath(n3));
      for (var x2 = 0; x2 < h3.linePathsTo.length; x2++) {
        var b2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.linePathsFrom[x2] : f3, pathTo: h3.linePathsTo[x2], strokeWidth: Array.isArray(e2.strokeWidth) ? e2.strokeWidth[n3] : e2.strokeWidth, fill: "none", drawShadow: false }));
        l3.add(b2);
        var m2 = a2.fillPath({ seriesNumber: n3 }), y2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.areaPathsFrom[x2] : f3, pathTo: h3.areaPathsTo[x2], strokeWidth: 0, fill: m2, drawShadow: false }));
        if (i2.config.chart.dropShadow.enabled) {
          var w2 = new Li(e2.ctx), k2 = i2.config.chart.dropShadow;
          w2.dropShadow(y2, Object.assign({}, k2, { noUserSpaceOnUse: true }), n3);
        }
        l3.add(y2);
      }
      t4.forEach((function(t5, a3) {
        var s3 = new Vi(e2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: a3 }), o4 = e2.graphics.drawMarker(d2[a3].x, d2[a3].y, s3);
        o4.attr("rel", a3), o4.attr("j", a3), o4.attr("index", n3), o4.node.setAttribute("default-marker-size", s3.pSize);
        var h4 = e2.graphics.group({ class: "apexcharts-series-markers" });
        h4 && h4.add(o4), g2.add(h4), l3.add(g2);
        var c4 = i2.config.dataLabels;
        if (c4.enabled) {
          var f4 = c4.formatter(i2.globals.series[n3][a3], { seriesIndex: n3, dataPointIndex: a3, w: i2 });
          r2.plotDataLabelsText({ x: d2[a3].x, y: d2[a3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: u({}, c4) });
        }
        l3.add(p2);
      })), s2.push(l3);
    })), this.drawPolygons({ parent: c2 }), i2.config.xaxis.labels.show) {
      var f2 = this.drawXAxisTexts();
      c2.add(f2);
    }
    return s2.forEach((function(t4) {
      c2.add(t4);
    })), c2.add(this.yaxisLabels), c2;
  } }, { key: "drawPolygons", value: function(t3) {
    for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new Ra(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), n2 = r2.length, o2 = [], l2 = this.size / (n2 - 1), h2 = 0; h2 < n2; h2++) o2[h2] = l2 * h2;
    o2.reverse();
    var c2 = [], d2 = [];
    o2.forEach((function(t4, i3) {
      var a3 = v.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
      a3.forEach((function(t5, a4) {
        if (0 === i3) {
          var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
          d2.push(r3);
        }
        0 === a4 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
      })), c2.push(s3);
    })), c2.forEach((function(t4, s3) {
      var r3 = e2.polygons.strokeColors, n3 = e2.polygons.strokeWidth, o3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(n3) ? n3[s3] : n3, i2.globals.radarPolygons.fill.colors[s3]);
      a2.add(o3);
    })), d2.forEach((function(t4) {
      a2.add(t4);
    })), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function(t4, i3) {
      var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
      e2.yaxisLabels.add(a3);
    }));
  } }, { key: "drawXAxisTexts", value: function() {
    var t3 = this, e2 = this.w, i2 = e2.config.xaxis.labels, a2 = this.graphics.group({ class: "apexcharts-xaxis" }), s2 = v.getPolygonPos(this.size, this.dataPointsLen);
    return e2.globals.labels.forEach((function(r2, n2) {
      var o2 = e2.config.xaxis.labels.formatter, l2 = new qi(t3.ctx);
      if (s2[n2]) {
        var h2 = t3.getTextPos(s2[n2], t3.size), c2 = o2(r2, { seriesIndex: -1, dataPointIndex: n2, w: e2 });
        l2.plotDataLabelsText({ x: h2.newX, y: h2.newY, text: c2, textAnchor: h2.textAnchor, i: n2, j: n2, parent: a2, className: "apexcharts-xaxis-label", color: Array.isArray(i2.style.colors) && i2.style.colors[n2] ? i2.style.colors[n2] : "#a8a8a8", dataLabelsConfig: u({ textAnchor: h2.textAnchor, dropShadow: { enabled: false } }, i2), offsetCorrection: false }).on("click", (function(i3) {
          if ("function" == typeof e2.config.chart.events.xAxisLabelClick) {
            var a3 = Object.assign({}, e2, { labelIndex: n2 });
            e2.config.chart.events.xAxisLabelClick(i3, t3.ctx, a3);
          }
        }));
      }
    })), a2;
  } }, { key: "createPaths", value: function(t3, e2) {
    var i2 = this, a2 = [], s2 = [], r2 = [], n2 = [];
    if (t3.length) {
      s2 = [this.graphics.move(e2.x, e2.y)], n2 = [this.graphics.move(e2.x, e2.y)];
      var o2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
      t3.forEach((function(e3, a3) {
        o2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (o2 += "Z", l2 += "Z");
      })), a2.push(o2), r2.push(l2);
    }
    return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: n2, areaPathsTo: r2 };
  } }, { key: "getTextPos", value: function(t3, e2) {
    var i2 = "middle", a2 = t3.x, s2 = t3.y;
    return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i2 = "start", a2 += 10) : t3.x < 0 && (i2 = "end", a2 -= 10) : i2 = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
  } }, { key: "getPreviousPath", value: function(t3) {
    for (var e2 = this.w, i2 = null, a2 = 0; a2 < e2.globals.previousPaths.length; a2++) {
      var s2 = e2.globals.previousPaths[a2];
      s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && void 0 !== e2.globals.previousPaths[a2].paths[0] && (i2 = e2.globals.previousPaths[a2].paths[0].d);
    }
    return i2;
  } }, { key: "getDataPointsPos", value: function(t3, e2) {
    var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
    t3 = t3 || [], e2 = e2 || [];
    for (var a2 = [], s2 = 0; s2 < i2; s2++) {
      var r2 = {};
      r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
    }
    return a2;
  } }]), t2;
})(), Ha = (function(t2) {
  h(r2, Ea);
  var a2 = n(r2);
  function r2(t3) {
    var s2;
    i(this, r2), (s2 = a2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
    var n2 = s2.w;
    return s2.startAngle = n2.config.plotOptions.radialBar.startAngle, s2.endAngle = n2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(n2.config.plotOptions.radialBar.endAngle - n2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = n2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = n2.config.plotOptions.radialBar.track.endAngle, s2.barLabels = s2.w.config.plotOptions.radialBar.barLabels, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), 360 === s2.endAngle && (s2.endAngle = 359.99), s2.margin = parseInt(n2.config.plotOptions.radialBar.track.margin, 10), s2.onBarLabelClick = s2.onBarLabelClick.bind(e(s2)), s2;
  }
  return s(r2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: "apexcharts-radialbar" });
    if (e2.globals.noData) return a3;
    var s2 = i2.group(), r3 = this.defaultSize / 2, n2 = e2.globals.gridWidth / 2, o2 = this.defaultSize / 2.05;
    e2.config.chart.sparkline.enabled || (o2 = o2 - e2.config.stroke.width - e2.config.chart.dropShadow.blur);
    var l2 = e2.globals.fill.colors;
    if (e2.config.plotOptions.radialBar.track.show) {
      var h2 = this.drawTracks({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 });
      s2.add(h2);
    }
    var c2 = this.drawArcs({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 }), d2 = 360;
    e2.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
    var u2 = (360 - d2) / 360;
    if (e2.globals.radialSize = o2 - o2 * u2, this.radialDataLabels.value.show) {
      var g2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      e2.globals.radialSize += g2 * u2;
    }
    return s2.add(c2.g), "front" === e2.config.plotOptions.radialBar.hollow.position && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a3.add(s2), a3;
  } }, { key: "drawTracks", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = i2.group({ class: "apexcharts-tracks" }), s2 = new Li(this.ctx), r3 = new ji(this.ctx), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    for (var o2 = 0; o2 < t3.series.length; o2++) {
      var l2 = i2.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      a3.add(l2), l2.attr({ rel: o2 + 1 }), t3.size = t3.size - n2 - this.margin;
      var h2 = e2.config.plotOptions.radialBar.track, c2 = r3.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[o2] : h2.background, solid: true }), d2 = this.trackStartAngle, u2 = this.trackEndAngle;
      Math.abs(u2) + Math.abs(d2) >= 360 && (u2 = 360 - Math.abs(this.startAngle) - 0.1);
      var g2 = i2.drawPath({ d: "", stroke: c2, strokeWidth: n2 * parseInt(h2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h2.opacity, classes: "apexcharts-radialbar-area" });
      if (h2.dropShadow.enabled) {
        var p2 = h2.dropShadow;
        s2.dropShadow(g2, p2);
      }
      l2.add(g2), g2.attr("id", "apexcharts-radialbarTrack-" + o2), this.animatePaths(g2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: u2, startAngle: d2, size: t3.size, i: o2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true });
    }
    return a3;
  } }, { key: "drawArcs", value: function(t3) {
    var e2 = this.w, i2 = new Mi(this.ctx), a3 = new ji(this.ctx), s2 = new Li(this.ctx), r3 = i2.group(), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    var o2 = e2.config.plotOptions.radialBar.hollow.background, l2 = t3.size - n2 * t3.series.length - this.margin * t3.series.length - n2 * parseInt(e2.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e2.config.plotOptions.radialBar.hollow.margin;
    void 0 !== e2.config.plotOptions.radialBar.hollow.image && (o2 = this.drawHollowImage(t3, r3, l2, o2));
    var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: o2 || "transparent" });
    if (e2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var d2 = e2.config.plotOptions.radialBar.hollow.dropShadow;
      s2.dropShadow(c2, d2);
    }
    var u2 = 1;
    !this.radialDataLabels.total.show && e2.globals.series.length > 1 && (u2 = 0);
    var g2 = null;
    if (this.radialDataLabels.show) {
      var p2 = e2.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      g2 = this.renderInnerDataLabels(p2, this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: u2 });
    }
    "back" === e2.config.plotOptions.radialBar.hollow.position && (r3.add(c2), g2 && r3.add(g2));
    var f2 = false;
    e2.config.plotOptions.radialBar.inverseOrder && (f2 = true);
    for (var x2 = f2 ? t3.series.length - 1 : 0; f2 ? x2 >= 0 : x2 < t3.series.length; f2 ? x2-- : x2++) {
      var b2 = i2.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: v.escapeString(e2.globals.seriesNames[x2]) });
      r3.add(b2), b2.attr({ rel: x2 + 1, "data:realIndex": x2 }), this.ctx.series.addCollapsedClassToSeries(b2, x2), t3.size = t3.size - n2 - this.margin;
      var m2 = a3.fillPath({ seriesNumber: x2, size: t3.size, value: t3.series[x2] }), y2 = this.startAngle, w2 = void 0, k2 = v.negToZero(t3.series[x2] > 100 ? 100 : t3.series[x2]) / 100, A2 = Math.round(this.totalAngle * k2) + this.startAngle, C2 = void 0;
      e2.globals.dataChanged && (w2 = this.startAngle, C2 = Math.round(this.totalAngle * v.negToZero(e2.globals.previousPaths[x2]) / 100) + w2), Math.abs(A2) + Math.abs(y2) > 360 && (A2 -= 0.01), Math.abs(C2) + Math.abs(w2) > 360 && (C2 -= 0.01);
      var S2 = A2 - y2, L2 = Array.isArray(e2.config.stroke.dashArray) ? e2.config.stroke.dashArray[x2] : e2.config.stroke.dashArray, M2 = i2.drawPath({ d: "", stroke: m2, strokeWidth: n2, fill: "none", fillOpacity: e2.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + x2, strokeDashArray: L2 });
      if (Mi.setAttrs(M2.node, { "data:angle": S2, "data:value": t3.series[x2] }), e2.config.chart.dropShadow.enabled) {
        var P2 = e2.config.chart.dropShadow;
        s2.dropShadow(M2, P2, x2);
      }
      if (s2.setSelectionFilter(M2, 0, x2), this.addListeners(M2, this.radialDataLabels), b2.add(M2), M2.attr({ index: 0, j: x2 }), this.barLabels.enabled) {
        var I2 = v.polarToCartesian(t3.centerX, t3.centerY, t3.size, y2), T2 = this.barLabels.formatter(e2.globals.seriesNames[x2], { seriesIndex: x2, w: e2 }), z2 = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || z2.push("apexcharts-no-click");
        var X2 = this.barLabels.useSeriesColors ? e2.globals.colors[x2] : e2.config.chart.foreColor;
        X2 || (X2 = e2.config.chart.foreColor);
        var R2 = I2.x + this.barLabels.offsetX, E2 = I2.y + this.barLabels.offsetY, Y2 = i2.drawText({ x: R2, y: E2, text: T2, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: X2, cssClass: z2.join(" ") });
        Y2.on("click", this.onBarLabelClick), Y2.attr({ rel: x2 + 1 }), 0 !== y2 && Y2.attr({ "transform-origin": "".concat(R2, " ").concat(E2), transform: "rotate(".concat(y2, " 0 0)") }), b2.add(Y2);
      }
      var H2 = 0;
      !this.initialAnim || e2.globals.resized || e2.globals.dataChanged || (H2 = e2.config.chart.animations.speed), e2.globals.dataChanged && (H2 = e2.config.chart.animations.dynamicAnimation.speed), this.animDur = H2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: A2, startAngle: y2, prevEndAngle: C2, prevStartAngle: w2, size: t3.size, i: x2, totalItems: 2, animBeginArr: this.animBeginArr, dur: H2, shouldSetPrevPaths: true });
    }
    return { g: r3, elHollow: c2, dataLabels: g2 };
  } }, { key: "drawHollow", value: function(t3) {
    var e2 = new Mi(this.ctx).drawCircle(2 * t3.size);
    return e2.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e2;
  } }, { key: "drawHollowImage", value: function(t3, e2, i2, a3) {
    var s2 = this.w, r3 = new ji(this.ctx), n2 = v.randomId(), o2 = s2.config.plotOptions.radialBar.hollow.image;
    if (s2.config.plotOptions.radialBar.hollow.imageClipped) r3.clippedImgArea({ width: i2, height: i2, image: o2, patternID: "pattern".concat(s2.globals.cuid).concat(n2) }), a3 = "url(#pattern".concat(s2.globals.cuid).concat(n2, ")");
    else {
      var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
      if (void 0 === l2 && void 0 === h2) {
        var c2 = s2.globals.dom.Paper.image(o2, (function(e3) {
          this.move(t3.centerX - e3.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e3.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
        }));
        e2.add(c2);
      } else {
        var d2 = s2.globals.dom.Paper.image(o2, (function(e3) {
          this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
        }));
        e2.add(d2);
      }
    }
    return a3;
  } }, { key: "getStrokeWidth", value: function(t3) {
    var e2 = this.w;
    return t3.size * (100 - parseInt(e2.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(t3) {
    var e2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, i2 = this.barLabels.onClick, a3 = this.w;
    i2 && i2(a3.globals.seriesNames[e2], { w: a3, seriesIndex: e2 });
  } }]), r2;
})(), Oa = (function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i2 = this.w, a3 = new Mi(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = i2.globals.seriesRangeStart, this.seriesRangeEnd = i2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
    for (var s2 = a3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r2 = 0; r2 < t3.length; r2++) {
      var n2, o2, l2, h2, c2 = void 0, d2 = void 0, g2 = i2.globals.comboCharts ? e3[r2] : r2, p2 = this.barHelpers.getGroupIndex(g2).columnGroupIndex, f2 = a3.group({ class: "apexcharts-series", seriesName: v.escapeString(i2.globals.seriesNames[g2]), rel: r2 + 1, "data:realIndex": g2 });
      this.ctx.series.addCollapsedClassToSeries(f2, g2), t3[r2].length > 0 && (this.visibleI = this.visibleI + 1);
      var x2 = 0, b2 = 0, m2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i2.globals.seriesYAxisReverseMap[g2][0], m2 = g2);
      var y2 = this.barHelpers.initialPositions(g2);
      d2 = y2.y, h2 = y2.zeroW, c2 = y2.x, b2 = y2.barWidth, x2 = y2.barHeight, n2 = y2.xDivision, o2 = y2.yDivision, l2 = y2.zeroH;
      for (var w2 = a3.group({ class: "apexcharts-datalabels", "data:realIndex": g2 }), k2 = a3.group({ class: "apexcharts-rangebar-goals-markers" }), A2 = 0; A2 < i2.globals.dataPoints; A2++) {
        var C2 = this.barHelpers.getStrokeWidth(r2, A2, g2), S2 = this.seriesRangeStart[r2][A2], L2 = this.seriesRangeEnd[r2][A2], M2 = null, P2 = null, I2 = null, T2 = { x: c2, y: d2, strokeWidth: C2, elSeries: f2 }, z2 = this.seriesLen;
        if (i2.config.plotOptions.bar.rangeBarGroupRows && (z2 = 1), void 0 === i2.config.series[r2].data[A2]) break;
        if (this.isHorizontal) {
          I2 = d2 + x2 * this.visibleI;
          var X2 = (o2 - x2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var R2 = this.detectOverlappingBars({ i: r2, j: A2, barYPosition: I2, srty: X2, barHeight: x2, yDivision: o2, initPositions: y2 });
            x2 = R2.barHeight, I2 = R2.barYPosition;
          }
          b2 = (M2 = this.drawRangeBarPaths(u({ indexes: { i: r2, j: A2, realIndex: g2 }, barHeight: x2, barYPosition: I2, zeroW: h2, yDivision: o2, y1: S2, y2: L2 }, T2))).barWidth;
        } else {
          i2.globals.isXNumeric && (c2 = (i2.globals.seriesX[r2][A2] - i2.globals.minX) / this.xRatio - b2 / 2), P2 = c2 + b2 * this.visibleI;
          var E2 = (n2 - b2 * z2) / 2;
          if (i2.config.series[r2].data[A2].x) {
            var Y2 = this.detectOverlappingBars({ i: r2, j: A2, barXPosition: P2, srtx: E2, barWidth: b2, xDivision: n2, initPositions: y2 });
            b2 = Y2.barWidth, P2 = Y2.barXPosition;
          }
          x2 = (M2 = this.drawRangeColumnPaths(u({ indexes: { i: r2, j: A2, realIndex: g2, translationsIndex: m2 }, barWidth: b2, barXPosition: P2, zeroH: l2, xDivision: n2 }, T2))).barHeight;
        }
        var H2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: I2, goalX: M2.goalX, goalY: M2.goalY, barHeight: x2, barWidth: b2 });
        H2 && k2.add(H2), d2 = M2.y, c2 = M2.x;
        var O2 = this.barHelpers.getPathFillColor(t3, r2, A2, g2);
        this.renderSeries({ realIndex: g2, pathFill: O2.color, lineFill: O2.useRangeColor ? O2.color : i2.globals.stroke.colors[g2], j: A2, i: r2, x: c2, y: d2, y1: S2, y2: L2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: x2, barWidth: b2, barXPosition: P2, barYPosition: I2, columnGroupIndex: p2, elDataLabelsWrap: w2, elGoalsMarkers: k2, visibleSeries: this.visibleI, type: "rangebar" });
      }
      s2.add(f2);
    }
    return s2;
  } }, { key: "detectOverlappingBars", value: function(t3) {
    var e3 = t3.i, i2 = t3.j, a3 = t3.barYPosition, s2 = t3.barXPosition, r2 = t3.srty, n2 = t3.srtx, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.yDivision, c2 = t3.xDivision, d2 = t3.initPositions, u2 = this.w, g2 = [], p2 = u2.config.series[e3].data[i2].rangeName, f2 = u2.config.series[e3].data[i2].x, x2 = Array.isArray(f2) ? f2.join(" ") : f2, b2 = u2.globals.labels.map((function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    })).indexOf(x2), m2 = u2.globals.seriesRange[e3].findIndex((function(t4) {
      return t4.x === x2 && t4.overlaps.length > 0;
    }));
    return this.isHorizontal ? (a3 = u2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + o2 * this.visibleI + h2 * b2, m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (a3 = (o2 = d2.barHeight / g2.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o2 * (this.visibleI + g2.indexOf(p2)) + h2 * b2)) : (b2 > -1 && !u2.globals.timescaleLabels.length && (s2 = u2.config.plotOptions.bar.rangeBarGroupRows ? n2 + c2 * b2 : n2 + l2 * this.visibleI + c2 * b2), m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (s2 = (l2 = d2.barWidth / g2.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + g2.indexOf(p2)) + c2 * b2)), { barYPosition: a3, barXPosition: s2, barHeight: o2, barWidth: l2 };
  } }, { key: "drawRangeColumnPaths", value: function(t3) {
    var e3 = t3.indexes, i2 = t3.x, a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.barXPosition, n2 = t3.zeroH, o2 = this.w, l2 = e3.i, h2 = e3.j, c2 = e3.realIndex, d2 = e3.translationsIndex, u2 = this.yRatio[d2], g2 = this.getRangeValue(c2, h2), p2 = Math.min(g2.start, g2.end), f2 = Math.max(g2.start, g2.end);
    void 0 === this.series[l2][h2] || null === this.series[l2][h2] ? p2 = n2 : (p2 = n2 - p2 / u2, f2 = n2 - f2 / u2);
    var x2 = Math.abs(f2 - p2), b2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s2, y1: p2, y2: f2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c2, i: c2, j: h2, w: o2 });
    if (o2.globals.isXNumeric) {
      var m2 = this.getBarXForNumericXAxis({ x: i2, j: h2, realIndex: c2, barWidth: s2 });
      i2 = m2.x, r2 = m2.barXPosition;
    } else i2 += a3;
    return { pathTo: b2.pathTo, pathFrom: b2.pathFrom, barHeight: x2, x: i2, y: g2.start < 0 && g2.end < 0 ? p2 : f2, goalY: this.barHelpers.getGoalValues("y", null, n2, l2, h2, d2), barXPosition: r2 };
  } }, { key: "preventBarOverflow", value: function(t3) {
    var e3 = this.w;
    return t3 < 0 && (t3 = 0), t3 > e3.globals.gridWidth && (t3 = e3.globals.gridWidth), t3;
  } }, { key: "drawRangeBarPaths", value: function(t3) {
    var e3 = t3.indexes, i2 = t3.y, a3 = t3.y1, s2 = t3.y2, r2 = t3.yDivision, n2 = t3.barHeight, o2 = t3.barYPosition, l2 = t3.zeroW, h2 = this.w, c2 = e3.realIndex, d2 = e3.j, u2 = this.preventBarOverflow(l2 + a3 / this.invertedYRatio), g2 = this.preventBarOverflow(l2 + s2 / this.invertedYRatio), p2 = this.getRangeValue(c2, d2), f2 = Math.abs(g2 - u2), x2 = this.barHelpers.getBarpaths({ barYPosition: o2, barHeight: n2, x1: u2, x2: g2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c2, realIndex: c2, j: d2, w: h2 });
    return h2.globals.isXNumeric || (i2 += r2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barWidth: f2, x: p2.start < 0 && p2.end < 0 ? u2 : g2, goalX: this.barHelpers.getGoalValues("x", l2, null, c2, d2), y: i2 };
  } }, { key: "getRangeValue", value: function(t3, e3) {
    var i2 = this.w;
    return { start: i2.globals.seriesRangeStart[t3][e3], end: i2.globals.seriesRangeEnd[t3][e3] };
  } }]), a2;
})(), Fa = (function() {
  function t2(e2) {
    i(this, t2), this.w = e2.w, this.lineCtx = e2;
  }
  return s(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
    var i2 = this.w;
    if (("gradient" === i2.config.fill.type || "gradient" === i2.config.fill.type[t3]) && new Pi(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
      var a2 = e2[t3].slice();
      a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
    }
    return e2;
  } }, { key: "calculatePoints", value: function(t3) {
    var e2 = t3.series, i2 = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.prevY, l2 = this.w, h2 = [], c2 = [], d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
    return l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), 0 === n2 && (h2.push(d2), c2.push(v.isNumber(e2[r2][0]) ? o2 + l2.config.markers.offsetY : null)), h2.push(a2 + l2.config.markers.offsetX), c2.push(v.isNumber(e2[r2][n2 + 1]) ? s2 + l2.config.markers.offsetY : null), { x: h2, y: c2 };
  } }, { key: "checkPreviousPaths", value: function(t3) {
    for (var e2 = t3.pathFromLine, i2 = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 < s2.globals.previousPaths.length; r2++) {
      var n2 = s2.globals.previousPaths[r2];
      ("line" === n2.type || "area" === n2.type) && n2.paths.length > 0 && parseInt(n2.realIndex, 10) === parseInt(a2, 10) && ("line" === n2.type ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : "area" === n2.type && (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
    }
    return { pathFromLine: e2, pathFromArea: i2 };
  } }, { key: "determineFirstPrevY", value: function(t3) {
    var e2, i2, a2, s2 = t3.i, r2 = t3.realIndex, n2 = t3.series, o2 = t3.prevY, l2 = t3.lineYPosition, h2 = t3.translationsIndex, c2 = this.w, d2 = c2.config.chart.stacked && !c2.globals.comboCharts || c2.config.chart.stacked && c2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[r2]) || void 0 === e2 ? void 0 : e2.type) || "column" === (null === (i2 = this.w.config.series[r2]) || void 0 === i2 ? void 0 : i2.type));
    if (void 0 !== (null === (a2 = n2[s2]) || void 0 === a2 ? void 0 : a2[0])) o2 = (l2 = d2 && s2 > 0 ? this.lineCtx.prevSeriesY[s2 - 1][0] : this.lineCtx.zeroY) - n2[s2][0] / this.lineCtx.yRatio[h2] + 2 * (this.lineCtx.isReversed ? n2[s2][0] / this.lineCtx.yRatio[h2] : 0);
    else if (d2 && s2 > 0 && void 0 === n2[s2][0]) {
      for (var u2 = s2 - 1; u2 >= 0; u2--) if (null !== n2[u2][0] && void 0 !== n2[u2][0]) {
        o2 = l2 = this.lineCtx.prevSeriesY[u2][0];
        break;
      }
    }
    return { prevY: o2, lineYPosition: l2 };
  } }]), t2;
})(), Da = function(t2) {
  for (var e2, i2, a2, s2, r2 = (function(t3) {
    for (var e3 = [], i3 = t3[0], a3 = t3[1], s3 = e3[0] = Wa(i3, a3), r3 = 1, n3 = t3.length - 1; r3 < n3; r3++) i3 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Wa(i3, a3)));
    return e3[r3] = s3, e3;
  })(t2), n2 = t2.length - 1, o2 = [], l2 = 0; l2 < n2; l2++) a2 = Wa(t2[l2], t2[l2 + 1]), Math.abs(a2) < 1e-6 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i2 = r2[l2 + 1] / a2) * i2) > 9 && (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i2);
  for (var h2 = 0; h2 <= n2; h2++) s2 = (t2[Math.min(n2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), o2.push([s2 || 0, r2[h2] * s2 || 0]);
  return o2;
}, _a = function(t2) {
  var e2 = Da(t2), i2 = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], n2 = e2[0];
  s2.push(a2, [a2[0] + n2[0], a2[1] + n2[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
  for (var o2 = 2, l2 = e2.length; o2 < l2; o2++) {
    var h2 = t2[o2], c2 = e2[o2];
    s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
  }
  return s2;
}, Na = function(t2, e2, i2) {
  var a2 = t2.slice(e2, i2);
  if (e2) {
    if (i2 - e2 > 1 && a2[1].length < 6) {
      var s2 = a2[0].length;
      a2[1] = [2 * a2[0][s2 - 2] - a2[0][s2 - 4], 2 * a2[0][s2 - 1] - a2[0][s2 - 3]].concat(a2[1]);
    }
    a2[0] = a2[0].slice(-2);
  }
  return a2;
};
function Wa(t2, e2) {
  return (e2[1] - t2[1]) / (e2[0] - t2[0]);
}
var Ba = (function() {
  function t2(e2, a2, s2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = a2, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s2, this.scatter = new Ui(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Fa(this), this.markers = new Vi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i2, a2) {
    var s2, r2 = this.w, n2 = new Mi(this.ctx), o2 = r2.globals.comboCharts ? e2 : r2.config.chart.type, l2 = n2.group({ class: "apexcharts-".concat(o2, "-series apexcharts-plot-series") }), h2 = new Pi(this.ctx, r2);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = h2.getLogSeries(t3), this.yRatio = h2.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var c2 = [], d2 = 0; d2 < t3.length; d2++) {
      t3 = this.lineHelpers.sameValueSeriesFix(d2, t3);
      var g2 = r2.globals.comboCharts ? i2[d2] : d2, p2 = this.yRatio.length > 1 ? g2 : 0;
      this._initSerieVariables(t3, d2, g2);
      var f2 = [], x2 = [], b2 = [], m2 = r2.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g2), r2.globals.isXNumeric && r2.globals.seriesX.length > 0 && (m2 = (r2.globals.seriesX[g2][0] - r2.globals.minX) / this.xRatio), b2.push(m2);
      var v2, y2 = m2, w2 = void 0, k2 = y2, A2 = this.zeroY, C2 = this.zeroY;
      A2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: t3, prevY: A2, lineYPosition: 0, translationsIndex: p2 }).prevY, "monotoneCubic" === r2.config.stroke.curve && null === t3[d2][0] ? f2.push(null) : f2.push(A2), v2 = A2;
      "rangeArea" === o2 && (w2 = C2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: a2, prevY: C2, lineYPosition: 0, translationsIndex: p2 }).prevY, x2.push(null !== f2[0] ? C2 : null));
      var S2 = this._calculatePathsFrom({ type: o2, series: t3, i: d2, realIndex: g2, translationsIndex: p2, prevX: k2, prevY: A2, prevY2: C2 }), L2 = [f2[0]], M2 = [x2[0]], P2 = { type: o2, series: t3, realIndex: g2, translationsIndex: p2, i: d2, x: m2, y: 1, pX: y2, pY: v2, pathsFrom: S2, linePaths: [], areaPaths: [], seriesIndex: i2, lineYPosition: 0, xArrj: b2, yArrj: f2, y2Arrj: x2, seriesRangeEnd: a2 }, I2 = this._iterateOverDataPoints(u(u({}, P2), {}, { iterations: "rangeArea" === o2 ? t3[d2].length - 1 : void 0, isRangeStart: true }));
      if ("rangeArea" === o2) {
        for (var T2 = this._calculatePathsFrom({ series: a2, i: d2, realIndex: g2, prevX: k2, prevY: C2 }), z2 = this._iterateOverDataPoints(u(u({}, P2), {}, { series: a2, xArrj: [m2], yArrj: L2, y2Arrj: M2, pY: w2, areaPaths: I2.areaPaths, pathsFrom: T2, iterations: a2[d2].length - 1, isRangeStart: false })), X2 = I2.linePaths.length / 2, R2 = 0; R2 < X2; R2++) I2.linePaths[R2] = z2.linePaths[R2 + X2] + I2.linePaths[R2];
        I2.linePaths.splice(X2), I2.pathFromLine = z2.pathFromLine + I2.pathFromLine;
      } else I2.pathFromArea += "z";
      this._handlePaths({ type: o2, realIndex: g2, i: d2, paths: I2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c2.push(this.elSeries);
    }
    if (void 0 !== (null === (s2 = r2.config.series[0]) || void 0 === s2 ? void 0 : s2.zIndex) && c2.sort((function(t4, e3) {
      return Number(t4.node.getAttribute("zIndex")) - Number(e3.node.getAttribute("zIndex"));
    })), r2.config.chart.stacked) for (var E2 = c2.length - 1; E2 >= 0; E2--) l2.add(c2[E2]);
    else for (var Y2 = 0; Y2 < c2.length; Y2++) l2.add(c2[Y2]);
    return l2;
  } }, { key: "_initSerieVariables", value: function(t3, e2, i2) {
    var a2 = this.w, s2 = new Mi(this.ctx);
    this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - ("on" === a2.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width;
    var r2 = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = a2.globals.seriesYAxisReverseMap[i2], r2 = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[r2] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r2] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || "end" === a2.config.plotOptions.area.fillTo) && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", zIndex: void 0 !== a2.config.series[i2].zIndex ? a2.config.series[i2].zIndex : i2, seriesName: v.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), a2.globals.hasNullValues) {
      var n2 = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [a2.globals.gridHeight + a2.globals.markers.largestSize] }, seriesIndex: e2, j: 0, pSize: 0.1, alwaysDrawMarker: true, isVirtualPoint: true });
      null !== n2 && this.elPointsMain.add(n2);
    }
    this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
    var o2 = t3[e2].length === a2.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": o2, rel: e2 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
  } }, { key: "_calculatePathsFrom", value: function(t3) {
    var e2, i2, a2, s2, r2 = t3.type, n2 = t3.series, o2 = t3.i, l2 = t3.realIndex, h2 = t3.translationsIndex, c2 = t3.prevX, d2 = t3.prevY, u2 = t3.prevY2, g2 = this.w, p2 = new Mi(this.ctx);
    if (null === n2[o2][0]) {
      for (var f2 = 0; f2 < n2[o2].length; f2++) if (null !== n2[o2][f2]) {
        c2 = this.xDivision * f2, d2 = this.zeroY - n2[o2][f2] / this.yRatio[h2], e2 = p2.move(c2, d2), i2 = p2.move(c2, this.areaBottomY);
        break;
      }
    } else e2 = p2.move(c2, d2), "rangeArea" === r2 && (e2 = p2.move(c2, u2) + p2.line(c2, d2)), i2 = p2.move(c2, this.areaBottomY) + p2.line(c2, d2);
    if (a2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), s2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), g2.globals.previousPaths.length > 0) {
      var x2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
      a2 = x2.pathFromLine, s2 = x2.pathFromArea;
    }
    return { prevX: c2, prevY: d2, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
  } }, { key: "_handlePaths", value: function(t3) {
    var e2 = t3.type, i2 = t3.realIndex, a2 = t3.i, s2 = t3.paths, r2 = this.w, n2 = new Mi(this.ctx), o2 = new ji(this.ctx);
    this.prevSeriesY.push(s2.yArrj), r2.globals.seriesXvalues[i2] = s2.xArrj, r2.globals.seriesYvalues[i2] = s2.yArrj;
    var l2 = r2.config.forecastDataPoints;
    if (l2.count > 0 && "rangeArea" !== e2) {
      var h2 = r2.globals.seriesXvalues[i2][r2.globals.seriesXvalues[i2].length - l2.count - 1], c2 = n2.drawRect(h2, 0, r2.globals.gridWidth, r2.globals.gridHeight, 0);
      r2.globals.dom.elForecastMask.appendChild(c2.node);
      var d2 = n2.drawRect(0, 0, h2, r2.globals.gridHeight, 0);
      r2.globals.dom.elNonForecastMask.appendChild(d2.node);
    }
    this.pointsChart || r2.globals.delayedElements.push({ el: this.elPointsMain.node, index: i2 });
    var g2 = { i: a2, realIndex: i2, animationDelay: a2, initialSpeed: r2.config.chart.animations.speed, dataChangeSpeed: r2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(e2) };
    if ("area" === e2) for (var p2 = o2.fillPath({ seriesNumber: i2 }), f2 = 0; f2 < s2.areaPaths.length; f2++) {
      var x2 = n2.renderPaths(u(u({}, g2), {}, { pathFrom: s2.pathFromArea, pathTo: s2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p2 }));
      this.elSeries.add(x2);
    }
    if (r2.config.stroke.show && !this.pointsChart) {
      var b2 = null;
      if ("line" === e2) b2 = o2.fillPath({ seriesNumber: i2, i: a2 });
      else if ("solid" === r2.config.stroke.fill.type) b2 = r2.globals.stroke.colors[i2];
      else {
        var m2 = r2.config.fill;
        r2.config.fill = r2.config.stroke.fill, b2 = o2.fillPath({ seriesNumber: i2, i: a2 }), r2.config.fill = m2;
      }
      for (var v2 = 0; v2 < s2.linePaths.length; v2++) {
        var y2 = b2;
        "rangeArea" === e2 && (y2 = o2.fillPath({ seriesNumber: i2 }));
        var w2 = u(u({}, g2), {}, { pathFrom: s2.pathFromLine, pathTo: s2.linePaths[v2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: r2.config.stroke.lineCap, fill: "rangeArea" === e2 ? y2 : "none" }), k2 = n2.renderPaths(w2);
        if (this.elSeries.add(k2), k2.attr("fill-rule", "evenodd"), l2.count > 0 && "rangeArea" !== e2) {
          var A2 = n2.renderPaths(w2);
          A2.node.setAttribute("stroke-dasharray", l2.dashArray), l2.strokeWidth && A2.node.setAttribute("stroke-width", l2.strokeWidth), this.elSeries.add(A2), A2.attr("clip-path", "url(#forecastMask".concat(r2.globals.cuid, ")")), k2.attr("clip-path", "url(#nonForecastMask".concat(r2.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(t3) {
    var e2, i2, a2 = this, s2 = t3.type, r2 = t3.series, n2 = t3.iterations, o2 = t3.realIndex, l2 = t3.translationsIndex, h2 = t3.i, c2 = t3.x, d2 = t3.y, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathsFrom, f2 = t3.linePaths, x2 = t3.areaPaths, b2 = t3.seriesIndex, m2 = t3.lineYPosition, y2 = t3.xArrj, w2 = t3.yArrj, k2 = t3.y2Arrj, A2 = t3.isRangeStart, C2 = t3.seriesRangeEnd, S2 = this.w, L2 = new Mi(this.ctx), M2 = this.yRatio, P2 = p2.prevY, I2 = p2.linePath, T2 = p2.areaPath, z2 = p2.pathFromLine, X2 = p2.pathFromArea, R2 = v.isNumber(S2.globals.minYArr[o2]) ? S2.globals.minYArr[o2] : S2.globals.minY;
    n2 || (n2 = S2.globals.dataPoints > 1 ? S2.globals.dataPoints - 1 : S2.globals.dataPoints);
    var E2 = function(t4, e3) {
      return e3 - t4 / M2[l2] + 2 * (a2.isReversed ? t4 / M2[l2] : 0);
    }, Y2 = d2, H2 = S2.config.chart.stacked && !S2.globals.comboCharts || S2.config.chart.stacked && S2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[o2]) || void 0 === e2 ? void 0 : e2.type) || "column" === (null === (i2 = this.w.config.series[o2]) || void 0 === i2 ? void 0 : i2.type)), O2 = S2.config.stroke.curve;
    Array.isArray(O2) && (O2 = Array.isArray(b2) ? O2[b2[h2]] : O2[h2]);
    for (var F2, D2 = 0, _2 = 0; _2 < n2 && 0 !== r2[h2].length; _2++) {
      var N2 = void 0 === r2[h2][_2 + 1] || null === r2[h2][_2 + 1];
      if (S2.globals.isXNumeric) {
        var W2 = S2.globals.seriesX[o2][_2 + 1];
        void 0 === S2.globals.seriesX[o2][_2 + 1] && (W2 = S2.globals.seriesX[o2][n2 - 1]), c2 = (W2 - S2.globals.minX) / this.xRatio;
      } else c2 += this.xDivision;
      if (H2) if (h2 > 0 && S2.globals.collapsedSeries.length < S2.config.series.length - 1) {
        m2 = this.prevSeriesY[(function(t4) {
          for (var e3 = t4; e3 > 0; e3--) {
            if (!(S2.globals.collapsedSeriesIndices.indexOf((null == b2 ? void 0 : b2[e3]) || e3) > -1)) return e3;
            e3--;
          }
          return 0;
        })(h2 - 1)][_2 + 1];
      } else m2 = this.zeroY;
      else m2 = this.zeroY;
      N2 ? d2 = E2(R2, m2) : (d2 = E2(r2[h2][_2 + 1], m2), "rangeArea" === s2 && (Y2 = E2(C2[h2][_2 + 1], m2))), y2.push(null === r2[h2][_2 + 1] ? null : c2), !N2 || "smooth" !== S2.config.stroke.curve && "monotoneCubic" !== S2.config.stroke.curve ? (w2.push(d2), k2.push(Y2)) : (w2.push(null), k2.push(null));
      var B2 = this.lineHelpers.calculatePoints({ series: r2, x: c2, y: d2, realIndex: o2, i: h2, j: _2, prevY: P2 }), G2 = this._createPaths({ type: s2, series: r2, i: h2, realIndex: o2, j: _2, x: c2, y: d2, y2: Y2, xArrj: y2, yArrj: w2, y2Arrj: k2, pX: u2, pY: g2, pathState: D2, segmentStartX: F2, linePath: I2, areaPath: T2, linePaths: f2, areaPaths: x2, curve: O2, isRangeStart: A2 });
      x2 = G2.areaPaths, f2 = G2.linePaths, u2 = G2.pX, g2 = G2.pY, D2 = G2.pathState, F2 = G2.segmentStartX, T2 = G2.areaPath, I2 = G2.linePath, !this.appendPathFrom || S2.globals.hasNullValues || "monotoneCubic" === O2 && "rangeArea" === s2 || (z2 += L2.line(c2, this.areaBottomY), X2 += L2.line(c2, this.areaBottomY)), this.handleNullDataPoints(r2, B2, h2, _2, o2), this._handleMarkersAndLabels({ type: s2, pointsPos: B2, i: h2, j: _2, realIndex: o2, isRangeStart: A2 });
    }
    return { yArrj: w2, xArrj: y2, pathFromArea: X2, areaPaths: x2, pathFromLine: z2, linePaths: f2, linePath: I2, areaPath: T2 };
  } }, { key: "_handleMarkersAndLabels", value: function(t3) {
    var e2 = t3.type, i2 = t3.pointsPos, a2 = t3.isRangeStart, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = this.w, l2 = new qi(this.ctx);
    if (this.pointsChart) this.scatter.draw(this.elSeries, r2, { realIndex: n2, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      o2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h2 = this.markers.plotChartMarkers({ pointsPos: i2, seriesIndex: n2, j: r2 + 1 });
      null !== h2 && this.elPointsMain.add(h2);
    }
    var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i2, i: n2, j: r2 + 1 });
    null !== c2 && this.elDataLabelsWrap.add(c2);
  } }, { key: "_createPaths", value: function(t3) {
    var e2 = t3.type, i2 = t3.series, a2 = t3.i;
    t3.realIndex;
    var s2, r2 = t3.j, n2 = t3.x, o2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathState, f2 = t3.segmentStartX, x2 = t3.linePath, b2 = t3.areaPath, m2 = t3.linePaths, v2 = t3.areaPaths, y2 = t3.curve, w2 = t3.isRangeStart, k2 = new Mi(this.ctx), A2 = this.areaBottomY, C2 = "rangeArea" === e2, S2 = "rangeArea" === e2 && w2;
    switch (y2) {
      case "monotoneCubic":
        var L2 = w2 ? h2 : d2;
        switch (p2) {
          case 0:
            if (null === L2[r2 + 1]) break;
            p2 = 1;
          case 1:
            if (!(C2 ? l2.length === i2[a2].length : r2 === i2[a2].length - 2)) break;
          case 2:
            var M2 = w2 ? l2 : l2.slice().reverse(), P2 = w2 ? L2 : L2.slice().reverse(), I2 = (s2 = P2, M2.map((function(t4, e3) {
              return [t4, s2[e3]];
            })).filter((function(t4) {
              return null !== t4[1];
            }))), T2 = I2.length > 1 ? _a(I2) : I2, z2 = [];
            C2 && (S2 ? v2 = I2 : z2 = v2.reverse());
            var X2 = 0, R2 = 0;
            if ((function(t4, e3) {
              for (var i3 = (function(t5) {
                var e4 = [], i4 = 0;
                return t5.forEach((function(t6) {
                  null !== t6 ? i4++ : i4 > 0 && (e4.push(i4), i4 = 0);
                })), i4 > 0 && e4.push(i4), e4;
              })(t4), a3 = [], s3 = 0, r3 = 0; s3 < i3.length; r3 += i3[s3++]) a3[s3] = Na(e3, r3, r3 + i3[s3]);
              return a3;
            })(P2, T2).forEach((function(t4) {
              X2++;
              var e3 = (function(t5) {
                for (var e4 = "", i4 = 0; i4 < t5.length; i4++) {
                  var a4 = t5[i4], s3 = a4.length;
                  s3 > 4 ? (e4 += "C".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]), e4 += ", ".concat(a4[4], ", ").concat(a4[5])) : s3 > 2 && (e4 += "S".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]));
                }
                return e4;
              })(t4), i3 = R2, a3 = (R2 += t4.length) - 1;
              S2 ? x2 = k2.move(I2[i3][0], I2[i3][1]) + e3 : C2 ? x2 = k2.move(z2[i3][0], z2[i3][1]) + k2.line(I2[i3][0], I2[i3][1]) + e3 + k2.line(z2[a3][0], z2[a3][1]) : (x2 = k2.move(I2[i3][0], I2[i3][1]) + e3, b2 = x2 + k2.line(I2[a3][0], A2) + k2.line(I2[i3][0], A2) + "z", v2.push(b2)), m2.push(x2);
            })), C2 && X2 > 1 && !S2) {
              var E2 = m2.slice(X2).reverse();
              m2.splice(X2), E2.forEach((function(t4) {
                return m2.push(t4);
              }));
            }
            p2 = 0;
        }
        break;
      case "smooth":
        var Y2 = 0.35 * (n2 - u2);
        if (null === i2[a2][r2]) p2 = 0;
        else switch (p2) {
          case 0:
            if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i2[a2][r2 + 1] || void 0 === i2[a2][r2 + 1]) {
              m2.push(x2), v2.push(b2);
              break;
            }
            if (p2 = 1, r2 < i2[a2].length - 2) {
              var H2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
              x2 += H2, b2 += H2;
              break;
            }
          case 1:
            if (null === i2[a2][r2 + 1]) x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
            else {
              var O2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
              x2 += O2, b2 += O2, r2 >= i2[a2].length - 2 && (S2 && (x2 += k2.curve(n2, o2, n2, o2, n2, c2) + k2.move(n2, c2)), b2 += k2.curve(n2, o2, n2, o2, n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
            }
        }
        u2 = n2, g2 = o2;
        break;
      default:
        var F2 = function(t4, e3, i3) {
          var a3 = [];
          switch (t4) {
            case "stepline":
              a3 = k2.line(e3, null, "H") + k2.line(null, i3, "V");
              break;
            case "linestep":
              a3 = k2.line(null, i3, "V") + k2.line(e3, null, "H");
              break;
            case "straight":
              a3 = k2.line(e3, i3);
          }
          return a3;
        };
        if (null === i2[a2][r2]) p2 = 0;
        else switch (p2) {
          case 0:
            if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i2[a2][r2 + 1] || void 0 === i2[a2][r2 + 1]) {
              m2.push(x2), v2.push(b2);
              break;
            }
            if (p2 = 1, r2 < i2[a2].length - 2) {
              var D2 = F2(y2, n2, o2);
              x2 += D2, b2 += D2;
              break;
            }
          case 1:
            if (null === i2[a2][r2 + 1]) x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
            else {
              var _2 = F2(y2, n2, o2);
              x2 += _2, b2 += _2, r2 >= i2[a2].length - 2 && (S2 && (x2 += k2.line(n2, c2)), b2 += k2.line(n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
            }
        }
        u2 = n2, g2 = o2;
    }
    return { linePaths: m2, areaPaths: v2, pX: u2, pY: g2, pathState: p2, segmentStartX: f2, linePath: x2, areaPath: b2 };
  } }, { key: "handleNullDataPoints", value: function(t3, e2, i2, a2, s2) {
    var r2 = this.w;
    if (null === t3[i2][a2] && r2.config.markers.showNullDataPoints || 1 === t3[i2].length) {
      var n2 = this.strokeWidth - r2.config.markers.strokeWidth / 2;
      n2 > 0 || (n2 = 0);
      var o2 = this.markers.plotChartMarkers({ pointsPos: e2, seriesIndex: s2, j: a2 + 1, pSize: n2, alwaysDrawMarker: true });
      null !== o2 && this.elPointsMain.add(o2);
    }
  } }]), t2;
})();
window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ (function() {
  function t2(e3, i3, a3, s3) {
    this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(t3) {
      var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, n3 = r2(t3) / this.height, o2 = r2(t3) / this.width;
      if (this.width >= this.height) for (e4 = 0; e4 < t3.length; e4++) i4.push([a4, s4, a4 + n3, s4 + t3[e4] / n3]), s4 += t3[e4] / n3;
      else for (e4 = 0; e4 < t3.length; e4++) i4.push([a4, s4, a4 + t3[e4] / o2, s4 + o2]), a4 += t3[e4] / o2;
      return i4;
    }, this.cutArea = function(e4) {
      var i4;
      if (this.width >= this.height) {
        var a4 = e4 / this.height, s4 = this.width - a4;
        i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
      } else {
        var r3 = e4 / this.width, n3 = this.height - r3;
        i4 = new t2(this.xoffset, this.yoffset + r3, this.width, n3);
      }
      return i4;
    };
  }
  function e2(e3, a3, s3, n3, o2) {
    n3 = void 0 === n3 ? 0 : n3, o2 = void 0 === o2 ? 0 : o2;
    var l2 = i2((function(t3, e4) {
      var i3, a4 = [], s4 = e4 / r2(t3);
      for (i3 = 0; i3 < t3.length; i3++) a4[i3] = t3[i3] * s4;
      return a4;
    })(e3, a3 * s3), [], new t2(n3, o2, a3, s3), []);
    return (function(t3) {
      var e4, i3, a4 = [];
      for (e4 = 0; e4 < t3.length; e4++) for (i3 = 0; i3 < t3[e4].length; i3++) a4.push(t3[e4][i3]);
      return a4;
    })(l2);
  }
  function i2(t3, e3, s3, n3) {
    var o2, l2, h2;
    if (0 !== t3.length) return o2 = s3.shortestEdge(), (function(t4, e4, i3) {
      var s4;
      if (0 === t4.length) return true;
      (s4 = t4.slice()).push(e4);
      var r3 = a2(t4, i3), n4 = a2(s4, i3);
      return r3 >= n4;
    })(e3, l2 = t3[0], o2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, n3)) : (h2 = s3.cutArea(r2(e3), n3), n3.push(s3.getCoordinates(e3)), i2(t3, [], h2, n3)), n3;
    n3.push(s3.getCoordinates(e3));
  }
  function a2(t3, e3) {
    var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
    return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
  }
  function s2(t3) {
    return t3 && t3.constructor === Array;
  }
  function r2(t3) {
    var e3, i3 = 0;
    for (e3 = 0; e3 < t3.length; e3++) i3 += t3[e3];
    return i3;
  }
  function n2(t3) {
    var e3, i3 = 0;
    if (s2(t3[0])) for (e3 = 0; e3 < t3.length; e3++) i3 += n2(t3[e3]);
    else i3 = r2(t3);
    return i3;
  }
  return function t3(i3, a3, r3, o2, l2) {
    o2 = void 0 === o2 ? 0 : o2, l2 = void 0 === l2 ? 0 : l2;
    var h2, c2, d2 = [], u2 = [];
    if (s2(i3[0])) {
      for (c2 = 0; c2 < i3.length; c2++) d2[c2] = n2(i3[c2]);
      for (h2 = e2(d2, a3, r3, o2, l2), c2 = 0; c2 < i3.length; c2++) u2.push(t3(i3[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
    } else u2 = e2(i3, a3, r3, o2, l2);
    return u2;
  };
})();
var Ga = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new za(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = new Mi(this.ctx), s2 = new ji(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
    if (i2.globals.noData) return r2;
    var n2 = [];
    return t3.forEach((function(t4) {
      var e3 = t4.map((function(t5) {
        return Math.abs(t5);
      }));
      n2.push(e3);
    })), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach((function(t4, i3) {
      t4.data.forEach((function(t5) {
        Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
      }));
    })), window.TreemapSquared.generate(n2, i2.globals.gridWidth, i2.globals.gridHeight).forEach((function(n3, o2) {
      var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: v.escapeString(i2.globals.seriesNames[o2]), rel: o2 + 1, "data:realIndex": o2 });
      if (i2.config.chart.dropShadow.enabled) {
        var h2 = i2.config.chart.dropShadow;
        new Li(e2.ctx).dropShadow(r2, h2, o2);
      }
      var c2 = a2.group({ class: "apexcharts-data-labels" }), d2 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      n3.forEach((function(r3, n4) {
        var h3 = r3[0], c3 = r3[1], u3 = r3[2], g3 = r3[3];
        d2.xMin = Math.min(d2.xMin, h3), d2.yMin = Math.min(d2.yMin, c3), d2.xMax = Math.max(d2.xMax, u3), d2.yMax = Math.max(d2.yMax, g3);
        var p3 = e2.helpers.getShadeColor(i2.config.chart.type, o2, n4, e2.negRange), f3 = p3.color, x3 = s2.fillPath({ color: f3, seriesNumber: o2, dataPointIndex: n4 }), b3 = a2.drawRect(h3, c3, u3 - h3, g3 - c3, i2.config.plotOptions.treemap.borderRadius, "#fff", 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f3 : i2.globals.stroke.colors[o2]);
        b3.attr({ cx: h3, cy: c3, index: o2, i: o2, j: n4, width: u3 - h3, height: g3 - c3, fill: x3 }), b3.node.classList.add("apexcharts-treemap-rect"), e2.helpers.addListeners(b3);
        var m3 = { x: h3 + (u3 - h3) / 2, y: c3 + (g3 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: u3 - h3, height: g3 - c3 };
        if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
          var y3 = 1;
          i2.globals.resized || (y3 = i2.config.chart.animations.speed), e2.animateTreemap(b3, m3, v2, y3);
        }
        if (i2.globals.dataChanged) {
          var w3 = 1;
          e2.dynamicAnim.enabled && i2.globals.shouldAnimate && (w3 = e2.dynamicAnim.speed, i2.globals.previousPaths[o2] && i2.globals.previousPaths[o2][n4] && i2.globals.previousPaths[o2][n4].rect && (m3 = i2.globals.previousPaths[o2][n4].rect), e2.animateTreemap(b3, m3, v2, w3));
        }
        var k3 = e2.getFontSize(r3), A3 = i2.config.dataLabels.formatter(e2.labels[o2][n4], { value: i2.globals.series[o2][n4], seriesIndex: o2, dataPointIndex: n4, w: i2 });
        "truncate" === i2.config.plotOptions.treemap.dataLabels.format && (k3 = parseInt(i2.config.dataLabels.style.fontSize, 10), A3 = e2.truncateLabels(A3, k3, h3, c3, u3, g3));
        var C3 = null;
        i2.globals.series[o2][n4] && (C3 = e2.helpers.calculateDataLabels({ text: A3, x: (h3 + u3) / 2, y: (c3 + g3) / 2 + e2.strokeWidth / 2 + k3 / 3, i: o2, j: n4, colorProps: p3, fontSize: k3, series: t3 })), i2.config.dataLabels.enabled && C3 && e2.rotateToFitLabel(C3, k3, A3, h3, c3, u3, g3), l2.add(b3), null !== C3 && l2.add(C3);
      }));
      var u2 = i2.config.plotOptions.treemap.seriesTitle;
      if (i2.config.series.length > 1 && u2 && u2.show) {
        var g2 = i2.config.series[o2].name || "";
        if (g2 && d2.xMin < 1 / 0 && d2.yMin < 1 / 0) {
          var p2 = u2.offsetX, f2 = u2.offsetY, x2 = u2.borderColor, b2 = u2.borderWidth, m2 = u2.borderRadius, y2 = u2.style, w2 = y2.color || i2.config.chart.foreColor, k2 = { left: y2.padding.left, right: y2.padding.right, top: y2.padding.top, bottom: y2.padding.bottom }, A2 = a2.getTextRects(g2, y2.fontSize, y2.fontFamily), C2 = A2.width + k2.left + k2.right, S2 = A2.height + k2.top + k2.bottom, L2 = d2.xMin + (p2 || 0), M2 = d2.yMin + (f2 || 0), P2 = a2.drawRect(L2, M2, C2, S2, m2, y2.background, 1, b2, x2), I2 = a2.drawText({ x: L2 + k2.left, y: M2 + k2.top + 0.75 * A2.height, text: g2, fontSize: y2.fontSize, fontFamily: y2.fontFamily, fontWeight: y2.fontWeight, foreColor: w2, cssClass: y2.cssClass || "" });
          l2.add(P2), l2.add(I2);
        }
      }
      l2.add(c2), r2.add(l2);
    })), r2;
  } }, { key: "getFontSize", value: function(t3) {
    var e2 = this.w;
    var i2 = (function t4(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0])) for (i3 = 0; i3 < e3.length; i3++) a2 += t4(e3[i3]);
      else for (i3 = 0; i3 < e3.length; i3++) a2 += e3[i3].length;
      return a2;
    })(this.labels) / (function t4(e3) {
      var i3, a2 = 0;
      if (Array.isArray(e3[0])) for (i3 = 0; i3 < e3.length; i3++) a2 += t4(e3[i3]);
      else for (i3 = 0; i3 < e3.length; i3++) a2 += 1;
      return a2;
    })(this.labels);
    return (function(t4, a2) {
      var s2 = t4 * a2, r2 = Math.pow(s2, 0.5);
      return Math.min(r2 / i2, parseInt(e2.config.dataLabels.style.fontSize, 10));
    })(t3[2] - t3[0], t3[3] - t3[1]);
  } }, { key: "rotateToFitLabel", value: function(t3, e2, i2, a2, s2, r2, n2) {
    var o2 = new Mi(this.ctx), l2 = o2.getTextRects(i2, e2);
    if (l2.width + this.w.config.stroke.width + 5 > r2 - a2 && l2.width <= n2 - s2) {
      var h2 = o2.rotateAroundCenter(t3.node);
      t3.node.setAttribute("transform", "rotate(-90 ".concat(h2.x, " ").concat(h2.y, ") translate(").concat(l2.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(t3, e2, i2, a2, s2, r2) {
    var n2 = new Mi(this.ctx), o2 = n2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 > s2 - i2 && r2 - a2 > s2 - i2 ? r2 - a2 : s2 - i2, l2 = n2.getTextBasedOnMaxWidth({ text: t3, maxWidth: o2, fontSize: e2 });
    return t3.length !== l2.length && o2 / e2 < 5 ? "" : l2;
  } }, { key: "animateTreemap", value: function(t3, e2, i2, a2) {
    var s2 = new y(this.ctx);
    s2.animateRect(t3, e2, i2, a2, (function() {
      s2.animationCompleted(t3);
    }));
  } }]), t2;
})(), ja = 86400, Va = 10 / ja, Ua = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return s(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    if (a2.globals.allSeriesCollapsed) return a2.globals.labels = [], a2.globals.timescaleLabels = [], [];
    var s2 = new zi(this.ctx), r2 = (e2 - t3) / 864e5;
    this.determineInterval(r2), a2.globals.disableZoomIn = false, a2.globals.disableZoomOut = false, r2 < Va ? a2.globals.disableZoomIn = true : r2 > 5e4 && (a2.globals.disableZoomOut = true);
    var n2 = s2.getTimeUnitsfromTimestamp(t3, e2, this.utc), o2 = a2.globals.gridWidth / r2, l2 = o2 / 24, h2 = l2 / 60, c2 = h2 / 60, d2 = Math.floor(24 * r2), g2 = Math.floor(1440 * r2), p2 = Math.floor(r2 * ja), f2 = Math.floor(r2), x2 = Math.floor(r2 / 30), b2 = Math.floor(r2 / 365), m2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, v2 = { firstVal: m2, currentMillisecond: m2.minMillisecond, currentSecond: m2.minSecond, currentMinute: m2.minMinute, currentHour: m2.minHour, currentMonthDate: m2.minDate, currentDate: m2.minDate, currentMonth: m2.minMonth, currentYear: m2.minYear, daysWidthOnXAxis: o2, hoursWidthOnXAxis: l2, minutesWidthOnXAxis: h2, secondsWidthOnXAxis: c2, numberOfSeconds: p2, numberOfMinutes: g2, numberOfHours: d2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(v2);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(v2);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(v2);
        break;
      case "hours":
        this.generateHourScale(v2);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(v2);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(v2);
    }
    var y2 = this.timeScaleArray.map((function(t4) {
      var e3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
      return "month" === t4.unit ? u(u({}, e3), {}, { day: 1, value: t4.value + 1 }) : "day" === t4.unit || "hour" === t4.unit ? u(u({}, e3), {}, { value: t4.value }) : "minute" === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.value }) : "second" === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
    }));
    return y2.filter((function(t4) {
      var e3 = 1, s3 = Math.ceil(a2.globals.gridWidth / 120), r3 = t4.value;
      void 0 !== a2.config.xaxis.tickAmount && (s3 = a2.config.xaxis.tickAmount), y2.length > s3 && (e3 = Math.floor(y2.length / s3));
      var n3 = false, o3 = false;
      switch (i2.tickInterval) {
        case "years":
          "year" === t4.unit && (n3 = true);
          break;
        case "half_year":
          e3 = 7, "year" === t4.unit && (n3 = true);
          break;
        case "months":
          e3 = 1, "year" === t4.unit && (n3 = true);
          break;
        case "months_fortnight":
          e3 = 15, "year" !== t4.unit && "month" !== t4.unit || (n3 = true), 30 === r3 && (o3 = true);
          break;
        case "months_days":
          e3 = 10, "month" === t4.unit && (n3 = true), 30 === r3 && (o3 = true);
          break;
        case "week_days":
          e3 = 8, "month" === t4.unit && (n3 = true);
          break;
        case "days":
          e3 = 1, "month" === t4.unit && (n3 = true);
          break;
        case "hours":
          "day" === t4.unit && (n3 = true);
          break;
        case "minutes_fives":
        case "seconds_fives":
          r3 % 5 != 0 && (o3 = true);
          break;
        case "seconds_tens":
          r3 % 10 != 0 && (o3 = true);
      }
      if ("hours" === i2.tickInterval || "minutes_fives" === i2.tickInterval || "seconds_tens" === i2.tickInterval || "seconds_fives" === i2.tickInterval) {
        if (!o3) return true;
      } else if ((r3 % e3 == 0 || n3) && !o3) return true;
    }));
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
    var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
    i2.globals.timescaleLabels = s2.slice(), new pa(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(t3) {
    var e2 = 24 * t3, i2 = 60 * e2;
    switch (true) {
      case t3 / 365 > 5:
        this.tickInterval = "years";
        break;
      case t3 > 800:
        this.tickInterval = "half_year";
        break;
      case t3 > 180:
        this.tickInterval = "months";
        break;
      case t3 > 90:
        this.tickInterval = "months_fortnight";
        break;
      case t3 > 60:
        this.tickInterval = "months_days";
        break;
      case t3 > 30:
        this.tickInterval = "week_days";
        break;
      case t3 > 2:
        this.tickInterval = "days";
        break;
      case e2 > 2.4:
        this.tickInterval = "hours";
        break;
      case i2 > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i2 > 5:
        this.tickInterval = "minutes";
        break;
      case i2 > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i2 > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, n2 = e2.minYear, o2 = 0, l2 = new zi(this.ctx), h2 = "year";
    if (e2.minDate > 1 || e2.minMonth > 0) {
      var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
      o2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, n2 = e2.minYear + 1, this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: n2, month: v.monthMod(i2 + 1) });
    } else 1 === e2.minDate && 0 === e2.minMonth && this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: a2, month: v.monthMod(i2 + 1) });
    for (var d2 = n2, u2 = o2, g2 = 0; g2 < r2; g2++) d2++, u2 = l2.determineDaysOfYear(d2 - 1) * s2 + u2, this.timeScaleArray.push({ position: u2, value: d2, unit: h2, year: d2, month: 1 });
  } }, { key: "generateMonthScale", value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, n2 = t3.numberOfMonths, o2 = a2, l2 = 0, h2 = new zi(this.ctx), c2 = "month", d2 = 0;
    if (e2.minDate > 1) {
      l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, o2 = v.monthMod(a2 + 1);
      var u2 = s2 + d2, g2 = v.monthMod(o2), p2 = o2;
      0 === o2 && (c2 = "year", p2 = u2, g2 = 1, u2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: u2, month: g2 });
    } else this.timeScaleArray.push({ position: l2, value: o2, unit: c2, year: s2, month: v.monthMod(a2) });
    for (var f2 = o2 + 1, x2 = l2, b2 = 0, m2 = 1; b2 < n2; b2++, m2++) {
      0 === (f2 = v.monthMod(f2)) ? (c2 = "year", d2 += 1) : c2 = "month";
      var y2 = this._getYear(s2, f2, d2);
      x2 = h2.determineDaysOfMonths(f2, y2) * r2 + x2;
      var w2 = 0 === f2 ? y2 : f2;
      this.timeScaleArray.push({ position: x2, value: w2, unit: c2, year: y2, month: 0 === f2 ? 1 : f2 }), f2++;
    }
  } }, { key: "generateDayScale", value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, n2 = new zi(this.ctx), o2 = "day", l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i3) {
      return t4 > n2.determineDaysOfMonths(e3 + 1, i3) ? (h2 = 1, o2 = "month", u2 = e3 += 1, e3) : e3;
    }, d2 = (24 - e2.minHour) * s2, u2 = l2, g2 = c2(h2, i2, a2);
    0 === e2.minHour && 1 === e2.minDate ? (d2 = 0, u2 = v.monthMod(e2.minMonth), o2 = "month", h2 = e2.minDate) : 1 !== e2.minDate && 0 === e2.minHour && 0 === e2.minMinute && (d2 = 0, l2 = e2.minDate, u2 = l2, g2 = c2(h2 = l2, i2, a2), 1 !== u2 && (o2 = "day")), this.timeScaleArray.push({ position: d2, value: u2, unit: o2, year: this._getYear(a2, g2, 0), month: v.monthMod(g2), day: h2 });
    for (var p2 = d2, f2 = 0; f2 < r2; f2++) {
      o2 = "day", g2 = c2(h2 += 1, g2, this._getYear(a2, g2, 0));
      var x2 = this._getYear(a2, g2, 0);
      p2 = 24 * s2 + p2;
      var b2 = 1 === h2 ? v.monthMod(g2) : h2;
      this.timeScaleArray.push({ position: p2, value: b2, unit: o2, year: x2, month: v.monthMod(g2), day: b2 });
    }
  } }, { key: "generateHourScale", value: function(t3) {
    var e2 = t3.firstVal, i2 = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, n2 = t3.numberOfHours, o2 = new zi(this.ctx), l2 = "hour", h2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
    }, c2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
    }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), u2 = d2 * r2, g2 = e2.minHour + 1, p2 = g2;
    60 === d2 && (u2 = 0, p2 = g2 = e2.minHour);
    var f2 = i2;
    p2 >= 24 && (p2 = 0, l2 = "day", g2 = f2 += 1);
    var x2 = h2(f2, a2).month;
    x2 = c2(f2, x2), g2 > 31 && (g2 = f2 = 1), this.timeScaleArray.push({ position: u2, value: g2, unit: l2, day: f2, hour: p2, year: s2, month: v.monthMod(x2) }), p2++;
    for (var b2 = u2, m2 = 0; m2 < n2; m2++) {
      if (l2 = "hour", p2 >= 24) p2 = 0, l2 = "day", x2 = h2(f2 += 1, x2).month, x2 = c2(f2, x2);
      var y2 = this._getYear(s2, x2, 0);
      b2 = 60 * r2 + b2;
      var w2 = 0 === p2 ? f2 : p2;
      this.timeScaleArray.push({ position: b2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: v.monthMod(x2) }), p2++;
    }
  } }, { key: "generateMinuteScale", value: function(t3) {
    for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h2 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (60 - i2 - e2 / 1e3) * h2, b2 = 0; b2 < c2; b2++) d2 >= 60 && (d2 = 0, 24 === (f2 += 1) && (f2 = 0)), this.timeScaleArray.push({ position: x2, value: d2, unit: "minute", hour: f2, minute: d2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, d2++;
  } }, { key: "generateSecondScale", value: function(t3) {
    for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h2 = t3.numberOfSeconds, c2 = i2 + 1, d2 = a2, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (1e3 - e2) / 1e3 * l2, b2 = 0; b2 < h2; b2++) c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, 24 === ++f2 && (f2 = 0))), this.timeScaleArray.push({ position: x2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, c2++;
  } }, { key: "createRawDateString", value: function(t3, e2) {
    var i2 = t3.year;
    return 0 === t3.month && (t3.month = 1), i2 += "-" + ("0" + t3.month.toString()).slice(-2), "day" === t3.unit ? i2 += "day" === t3.unit ? "-" + ("0" + e2).slice(-2) : "-01" : i2 += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), "hour" === t3.unit ? i2 += "hour" === t3.unit ? "T" + ("0" + e2).slice(-2) : "T00" : i2 += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), "minute" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), "second" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
  } }, { key: "formatDates", value: function(t3) {
    var e2 = this, i2 = this.w;
    return t3.map((function(t4) {
      var a2 = t4.value.toString(), s2 = new zi(e2.ctx), r2 = e2.createRawDateString(t4, a2), n2 = s2.getDate(s2.parseDate(r2));
      if (e2.utc || (n2 = s2.getDate(s2.parseDateWithTimezone(r2))), void 0 === i2.config.xaxis.labels.format) {
        var o2 = "dd MMM", l2 = i2.config.xaxis.labels.datetimeFormatter;
        "year" === t4.unit && (o2 = l2.year), "month" === t4.unit && (o2 = l2.month), "day" === t4.unit && (o2 = l2.day), "hour" === t4.unit && (o2 = l2.hour), "minute" === t4.unit && (o2 = l2.minute), "second" === t4.unit && (o2 = l2.second), a2 = s2.formatDate(n2, o2);
      } else a2 = s2.formatDate(n2, i2.config.xaxis.labels.format);
      return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
    }));
  } }, { key: "removeOverlappingTS", value: function(t3) {
    var e2, i2 = this, a2 = new Mi(this.ctx), s2 = false;
    t3.length > 0 && t3[0].value && t3.every((function(e3) {
      return e3.value.length === t3[0].value.length;
    })) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
    var r2 = 0, n2 = t3.map((function(n3, o2) {
      if (o2 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
        var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
        return n3.position > h2 + l2 + 10 ? (r2 = o2, n3) : null;
      }
      return n3;
    }));
    return n2 = n2.filter((function(t4) {
      return null !== t4;
    }));
  } }, { key: "_getYear", value: function(t3, e2, i2) {
    return t3 + Math.floor(e2 / 12) + i2;
  } }]), t2;
})(), qa = (function() {
  function t2(e2, a2) {
    i(this, t2), this.ctx = a2, this.w = a2.w, this.el = e2;
  }
  return s(t2, [{ key: "setupElements", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = i2.chart.type;
    e2.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(a2), e2.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(a2), e2.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(a2) && i2.plotOptions.bar.horizontal, e2.chartClass = ".apexcharts".concat(e2.chartID), e2.dom.baseEl = this.el, e2.dom.elWrap = document.createElement("div"), Mi.setAttrs(e2.dom.elWrap, { id: e2.chartClass.substring(1), class: "apexcharts-canvas ".concat(e2.chartClass.substring(1)) }), this.el.appendChild(e2.dom.elWrap), e2.dom.Paper = window.SVG().addTo(e2.dom.elWrap), e2.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i2.chart.offsetX, ", ").concat(i2.chart.offsetY, ")") }), e2.dom.Paper.node.style.background = "dark" !== i2.theme.mode || i2.chart.background ? "light" !== i2.theme.mode || i2.chart.background ? i2.chart.background : "#fff" : "#343A3F", this.setSVGDimensions(), e2.dom.elLegendForeign = document.createElementNS(e2.SVGNS, "foreignObject"), Mi.setAttrs(e2.dom.elLegendForeign, { x: 0, y: 0, width: e2.svgWidth, height: e2.svgHeight }), e2.dom.elLegendWrap = document.createElement("div"), e2.dom.elLegendWrap.classList.add("apexcharts-legend"), e2.dom.elWrap.appendChild(e2.dom.elLegendWrap), e2.dom.Paper.node.appendChild(e2.dom.elLegendForeign), e2.dom.elGraphical = e2.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e2.dom.elDefs = e2.dom.Paper.defs(), e2.dom.Paper.add(e2.dom.elGraphical), e2.dom.elGraphical.add(e2.dom.elDefs);
  } }, { key: "plotChartType", value: function(t3, e2) {
    var i2 = this.w, a2 = this.ctx, s2 = i2.config, r2 = i2.globals, n2 = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, o2 = s2.chart.type || "line", l2 = null, h2 = 0;
    r2.series.forEach((function(e3, a3) {
      var s3 = "column" === t3[a3].type ? "bar" : t3[a3].type || ("column" === o2 ? "bar" : o2);
      n2[s3] ? ("rangeArea" === s3 ? (n2[s3].series.push(r2.seriesRangeStart[a3]), n2[s3].seriesRangeEnd.push(r2.seriesRangeEnd[a3])) : n2[s3].series.push(e3), n2[s3].i.push(a3), "bar" === s3 && (i2.globals.columnSeries = n2.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(s3) ? l2 = s3 : console.warn("You have specified an unrecognized series type (".concat(s3, ").")), o2 !== s3 && "scatter" !== s3 && h2++;
    })), h2 > 0 && (l2 && console.warn("Chart or series type ".concat(l2, " cannot appear with other chart or series types.")), n2.bar.series.length > 0 && s2.plotOptions.bar.horizontal && (h2 -= n2.bar.series.length, n2.bar = { series: [], i: [] }, i2.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), r2.comboCharts || (r2.comboCharts = h2 > 0);
    var c2 = new Ba(a2, e2), d2 = new Ta(a2, e2);
    a2.pie = new Ea(a2);
    var u2 = new Ha(a2);
    a2.rangeBar = new Oa(a2, e2);
    var g2 = new Ya(a2), p2 = [];
    if (r2.comboCharts) {
      var x2, b2, m2 = new Pi(a2);
      if (n2.area.series.length > 0) (x2 = p2).push.apply(x2, f(m2.drawSeriesByGroup(n2.area, r2.areaGroups, "area", c2)));
      if (n2.bar.series.length > 0) if (s2.chart.stacked) {
        var v2 = new Ia(a2, e2);
        p2.push(v2.draw(n2.bar.series, n2.bar.i));
      } else a2.bar = new Pa(a2, e2), p2.push(a2.bar.draw(n2.bar.series, n2.bar.i));
      if (n2.rangeArea.series.length > 0 && p2.push(c2.draw(n2.rangeArea.series, "rangeArea", n2.rangeArea.i, n2.rangeArea.seriesRangeEnd)), n2.line.series.length > 0) (b2 = p2).push.apply(b2, f(m2.drawSeriesByGroup(n2.line, r2.lineGroups, "line", c2)));
      if (n2.candlestick.series.length > 0 && p2.push(d2.draw(n2.candlestick.series, "candlestick", n2.candlestick.i)), n2.boxPlot.series.length > 0 && p2.push(d2.draw(n2.boxPlot.series, "boxPlot", n2.boxPlot.i)), n2.rangeBar.series.length > 0 && p2.push(a2.rangeBar.draw(n2.rangeBar.series, n2.rangeBar.i)), n2.scatter.series.length > 0) {
        var y2 = new Ba(a2, e2, true);
        p2.push(y2.draw(n2.scatter.series, "scatter", n2.scatter.i));
      }
      if (n2.bubble.series.length > 0) {
        var w2 = new Ba(a2, e2, true);
        p2.push(w2.draw(n2.bubble.series, "bubble", n2.bubble.i));
      }
    } else switch (s2.chart.type) {
      case "line":
        p2 = c2.draw(r2.series, "line");
        break;
      case "area":
        p2 = c2.draw(r2.series, "area");
        break;
      case "bar":
        if (s2.chart.stacked) p2 = new Ia(a2, e2).draw(r2.series);
        else a2.bar = new Pa(a2, e2), p2 = a2.bar.draw(r2.series);
        break;
      case "candlestick":
        p2 = new Ta(a2, e2).draw(r2.series, "candlestick");
        break;
      case "boxPlot":
        p2 = new Ta(a2, e2).draw(r2.series, s2.chart.type);
        break;
      case "rangeBar":
        p2 = a2.rangeBar.draw(r2.series);
        break;
      case "rangeArea":
        p2 = c2.draw(r2.seriesRangeStart, "rangeArea", void 0, r2.seriesRangeEnd);
        break;
      case "heatmap":
        p2 = new Xa(a2, e2).draw(r2.series);
        break;
      case "treemap":
        p2 = new Ga(a2, e2).draw(r2.series);
        break;
      case "pie":
      case "donut":
      case "polarArea":
        p2 = a2.pie.draw(r2.series);
        break;
      case "radialBar":
        p2 = u2.draw(r2.series);
        break;
      case "radar":
        p2 = g2.draw(r2.series);
        break;
      default:
        p2 = c2.draw(r2.series);
    }
    return p2;
  } }, { key: "setSVGDimensions", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = t3.config;
    i2.chart.width = i2.chart.width || "100%", i2.chart.height = i2.chart.height || "auto", e2.svgWidth = i2.chart.width, e2.svgHeight = i2.chart.height;
    var a2 = v.getDimensions(this.el), s2 = i2.chart.width.toString().split(/[0-9]+/g).pop();
    "%" === s2 ? v.isNumber(a2[0]) && (0 === a2[0].width && (a2 = v.getDimensions(this.el.parentNode)), e2.svgWidth = a2[0] * parseInt(i2.chart.width, 10) / 100) : "px" !== s2 && "" !== s2 || (e2.svgWidth = parseInt(i2.chart.width, 10));
    var r2 = String(i2.chart.height).toString().split(/[0-9]+/g).pop();
    if ("auto" !== e2.svgHeight && "" !== e2.svgHeight) if ("%" === r2) {
      var n2 = v.getDimensions(this.el.parentNode);
      e2.svgHeight = n2[1] * parseInt(i2.chart.height, 10) / 100;
    } else e2.svgHeight = parseInt(i2.chart.height, 10);
    else e2.svgHeight = e2.axisCharts ? e2.svgWidth / 1.61 : e2.svgWidth / 1.2;
    if (e2.svgWidth = Math.max(e2.svgWidth, 0), e2.svgHeight = Math.max(e2.svgHeight, 0), Mi.setAttrs(e2.dom.Paper.node, { width: e2.svgWidth, height: e2.svgHeight }), "%" !== r2) {
      var o2 = i2.chart.sparkline.enabled ? 0 : e2.axisCharts ? i2.chart.parentHeightOffset : 0;
      e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(e2.svgHeight + o2, "px");
    }
    e2.dom.elWrap.style.width = "".concat(e2.svgWidth, "px"), e2.dom.elWrap.style.height = "".concat(e2.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var t3 = this.w.globals, e2 = t3.translateY, i2 = t3.translateX;
    Mi.setAttrs(t3.dom.elGraphical.node, { transform: "translate(".concat(i2, ", ").concat(e2, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
    a2 += t3.config.grid.padding.bottom, ["top", "bottom"].includes(t3.config.legend.position) && t3.config.legend.show && !t3.config.legend.floating && (i2 = new xa(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
    if (s2 && !t3.config.chart.sparkline.enabled && 0 !== t3.config.plotOptions.radialBar.startAngle) {
      var n2 = v.getBoundingClientRect(s2);
      r2 = n2.bottom;
      var o2 = n2.bottom - n2.top;
      r2 = Math.max(2.05 * t3.globals.radialSize, o2);
    }
    var l2 = Math.ceil(r2 + e2.translateY + i2 + a2);
    e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), t3.config.chart.height && String(t3.config.chart.height).includes("%") || (e2.dom.elWrap.style.height = "".concat(l2, "px"), Mi.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(l2, "px"));
  } }, { key: "coreCalculations", value: function() {
    new ea(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var t3 = this, e2 = function() {
      return t3.w.config.series.map((function() {
        return [];
      }));
    }, i2 = new Bi(), a2 = this.w.globals;
    i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = true, true);
  } }, { key: "xySettings", value: function() {
    var t3 = this.w, e2 = null;
    if (t3.globals.axisCharts) {
      if ("back" === t3.config.xaxis.crosshairs.position && new na(this.ctx).drawXCrosshairs(), "back" === t3.config.yaxis[0].crosshairs.position && new na(this.ctx).drawYCrosshairs(), "datetime" === t3.config.xaxis.type && void 0 === t3.config.xaxis.labels.formatter) {
        this.ctx.timeScale = new Ua(this.ctx);
        var i2 = [];
        isFinite(t3.globals.minX) && isFinite(t3.globals.maxX) && !t3.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minX, t3.globals.maxX) : t3.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minY, t3.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
      }
      e2 = new Pi(this.ctx).getCalculatedRatios();
    }
    return e2;
  } }, { key: "updateSourceChart", value: function(t3) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
  } }, { key: "setupBrushHandler", value: function() {
    var t3 = this, e2 = this.ctx, i2 = this.w;
    if (i2.config.chart.brush.enabled && "function" != typeof i2.config.chart.events.selection) {
      var a2 = Array.isArray(i2.config.chart.brush.targets) ? i2.config.chart.brush.targets : [i2.config.chart.brush.target];
      a2.forEach((function(i3) {
        var a3 = e2.constructor.getChartByID(i3);
        a3.w.globals.brushSource = t3.ctx, "function" != typeof a3.w.config.chart.events.zoomed && (a3.w.config.chart.events.zoomed = function() {
          return t3.updateSourceChart(a3);
        }), "function" != typeof a3.w.config.chart.events.scrolled && (a3.w.config.chart.events.scrolled = function() {
          return t3.updateSourceChart(a3);
        });
      })), i2.config.chart.events.selection = function(t4, i3) {
        a2.forEach((function(t5) {
          e2.constructor.getChartByID(t5).ctx.updateHelpers._updateOptions({ xaxis: { min: i3.xaxis.min, max: i3.xaxis.max } }, false, false, false, false);
        }));
      };
    }
  } }]), t2;
})(), Za = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "_updateOptions", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return new Promise((function(n2) {
      var o2 = [e2.ctx];
      s2 && (o2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (o2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), o2.forEach((function(s3, l2) {
        var h2 = s3.w;
        if (h2.globals.shouldAnimate = a2, i2 || (h2.globals.resized = true, h2.globals.dataChanged = true, a2 && s3.series.getPreviousPaths()), t3 && "object" === b(t3) && (s3.config = new Wi(t3), t3 = Pi.extendArrayProps(s3.config, t3, h2), s3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, h2.config = v.extend(h2.config, t3), r2 && (h2.globals.lastXAxis = t3.xaxis ? v.clone(t3.xaxis) : [], h2.globals.lastYAxis = t3.yaxis ? v.clone(t3.yaxis) : [], h2.globals.initialConfig = v.extend({}, h2.config), h2.globals.initialSeries = v.clone(h2.config.series), t3.series))) {
          for (var c2 = 0; c2 < h2.globals.collapsedSeriesIndices.length; c2++) {
            var d2 = h2.config.series[h2.globals.collapsedSeriesIndices[c2]];
            h2.globals.collapsedSeries[c2].data = h2.globals.axisCharts ? d2.data.slice() : d2;
          }
          for (var u2 = 0; u2 < h2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
            var g2 = h2.config.series[h2.globals.ancillaryCollapsedSeriesIndices[u2]];
            h2.globals.ancillaryCollapsedSeries[u2].data = h2.globals.axisCharts ? g2.data.slice() : g2;
          }
          s3.series.emptyCollapsedSeries(h2.config.series);
        }
        return s3.update(t3).then((function() {
          l2 === o2.length - 1 && n2(s3);
        }));
      }));
    }));
  } }, { key: "_updateSeries", value: function(t3, e2) {
    var i2 = this, a2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return new Promise((function(s2) {
      var r2, n2 = i2.w;
      return n2.globals.shouldAnimate = e2, n2.globals.dataChanged = true, e2 && i2.ctx.series.getPreviousPaths(), n2.globals.axisCharts ? (0 === (r2 = t3.map((function(t4, e3) {
        return i2._extendSeries(t4, e3);
      }))).length && (r2 = [{ data: [] }]), n2.config.series = r2) : n2.config.series = t3.slice(), a2 && (n2.globals.initialConfig.series = v.clone(n2.config.series), n2.globals.initialSeries = v.clone(n2.config.series)), i2.ctx.update().then((function() {
        s2(i2.ctx);
      }));
    }));
  } }, { key: "_extendSeries", value: function(t3, e2) {
    var i2 = this.w, a2 = i2.config.series[e2];
    return u(u({}, i2.config.series[e2]), {}, { name: t3.name ? t3.name : null == a2 ? void 0 : a2.name, color: t3.color ? t3.color : null == a2 ? void 0 : a2.color, type: t3.type ? t3.type : null == a2 ? void 0 : a2.type, group: t3.group ? t3.group : null == a2 ? void 0 : a2.group, hidden: void 0 !== t3.hidden ? t3.hidden : null == a2 ? void 0 : a2.hidden, data: t3.data ? t3.data : null == a2 ? void 0 : a2.data, zIndex: void 0 !== t3.zIndex ? t3.zIndex : e2 });
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    var i2 = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
    return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")) : void 0 === e2 && (a2 = i2.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(t3, "']")), "pie" !== i2.config.chart.type && "polarArea" !== i2.config.chart.type && "donut" !== i2.config.chart.type || this.ctx.pie.pieClicked(t3)), a2 ? (new Mi(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(t3) {
    var e2 = this.w;
    if (["min", "max"].forEach((function(i3) {
      void 0 !== t3.xaxis[i3] && (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
    })), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
      var i2 = new Ni(t3);
      t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
    }
    return t3;
  } }, { key: "forceYAxisUpdate", value: function(t3) {
    return t3.chart && t3.chart.stacked && "100%" === t3.chart.stackType && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach((function(e2, i2) {
      t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
    })) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
  } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
    var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
    t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
    var r2 = function(t4) {
      void 0 !== s2[t4] && (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
    };
    i2.config.yaxis.map((function(t4, a3) {
      i2.globals.zoomed || void 0 !== s2[a3] ? r2(a3) : void 0 !== e2.ctx.opts.yaxis[a3] && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
    }));
  } }]), t2;
})();
!(function() {
  function t2() {
    for (var t3 = arguments.length > 0 && arguments[0] !== h2 ? arguments[0] : [], s3 = arguments.length > 1 ? arguments[1] : h2, r2 = arguments.length > 2 ? arguments[2] : h2, n2 = arguments.length > 3 ? arguments[3] : h2, o2 = arguments.length > 4 ? arguments[4] : h2, l2 = arguments.length > 5 ? arguments[5] : h2, h2 = arguments.length > 6 ? arguments[6] : h2, c2 = t3.slice(s3, r2 || h2), d2 = n2.slice(o2, l2 || h2), u2 = 0, g2 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] }; ; ) {
      if (c2[u2] = e2.call(g2, c2[u2]), d2[u2] = e2.call(p2, d2[u2]), c2[u2][0] != d2[u2][0] || "M" == c2[u2][0] || "A" == c2[u2][0] && (c2[u2][4] != d2[u2][4] || c2[u2][5] != d2[u2][5]) ? (Array.prototype.splice.apply(c2, [u2, 1].concat(a2.call(g2, c2[u2]))), Array.prototype.splice.apply(d2, [u2, 1].concat(a2.call(p2, d2[u2])))) : (c2[u2] = i2.call(g2, c2[u2]), d2[u2] = i2.call(p2, d2[u2])), ++u2 == c2.length && u2 == d2.length) break;
      u2 == c2.length && c2.push(["C", g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1]]), u2 == d2.length && d2.push(["C", p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
    }
    return { start: c2, dest: d2 };
  }
  function e2(t3) {
    switch (t3[0]) {
      case "z":
      case "Z":
        t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
        break;
      case "H":
        t3[0] = "L", t3[2] = this.pos[1];
        break;
      case "V":
        t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
        break;
      case "T":
        t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
        break;
      case "S":
        t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
    }
    return t3;
  }
  function i2(t3) {
    var e3 = t3.length;
    return this.pos = [t3[e3 - 2], t3[e3 - 1]], -1 != "SCQT".indexOf(t3[0]) && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
  }
  function a2(t3) {
    var e3 = [t3];
    switch (t3[0]) {
      case "M":
        return this.pos = this.start = [t3[1], t3[2]], e3;
      case "L":
        t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
        break;
      case "Q":
        t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
        break;
      case "A":
        e3 = (function(t4, e4) {
          var i3, a3, s3, r2, n2, o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2, A2, C2, S2, L2, M2, P2 = Math.abs(e4[1]), I2 = Math.abs(e4[2]), T2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], R2 = e4[6], E2 = e4[7], Y2 = new bt(t4), H2 = new bt(R2, E2), O2 = [];
          if (0 === P2 || 0 === I2 || Y2.x === H2.x && Y2.y === H2.y) return [["C", Y2.x, Y2.y, H2.x, H2.y, H2.x, H2.y]];
          i3 = new bt((Y2.x - H2.x) / 2, (Y2.y - H2.y) / 2).transform(new vt().rotate(T2)), a3 = i3.x * i3.x / (P2 * P2) + i3.y * i3.y / (I2 * I2), a3 > 1 && (P2 *= a3 = Math.sqrt(a3), I2 *= a3);
          s3 = new vt().rotate(T2).scale(1 / P2, 1 / I2).rotate(-T2), Y2 = Y2.transform(s3), H2 = H2.transform(s3), r2 = [H2.x - Y2.x, H2.y - Y2.y], o2 = r2[0] * r2[0] + r2[1] * r2[1], n2 = Math.sqrt(o2), r2[0] /= n2, r2[1] /= n2, l2 = o2 < 4 ? Math.sqrt(1 - o2 / 4) : 0, z2 === X2 && (l2 *= -1);
          h2 = new bt((H2.x + Y2.x) / 2 + l2 * -r2[1], (H2.y + Y2.y) / 2 + l2 * r2[0]), c2 = new bt(Y2.x - h2.x, Y2.y - h2.y), d2 = new bt(H2.x - h2.x, H2.y - h2.y), u2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (u2 *= -1);
          g2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (g2 *= -1);
          X2 && u2 > g2 && (g2 += 2 * Math.PI);
          !X2 && u2 < g2 && (g2 -= 2 * Math.PI);
          for (f2 = Math.ceil(2 * Math.abs(u2 - g2) / Math.PI), b2 = [], m2 = u2, p2 = (g2 - u2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0; k2 <= f2; k2++) y2 = Math.cos(m2), v2 = Math.sin(m2), w2 = new bt(h2.x + y2, h2.y + v2), b2[k2] = [new bt(w2.x + x2 * v2, w2.y - x2 * y2), w2, new bt(w2.x - x2 * v2, w2.y + x2 * y2)], m2 += p2;
          for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new vt().rotate(T2).scale(P2, I2).rotate(-T2), k2 = 0, A2 = b2.length; k2 < A2; k2++) b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
          for (k2 = 1, A2 = b2.length; k2 < A2; k2++) C2 = (w2 = b2[k2 - 1][2]).x, S2 = w2.y, L2 = (w2 = b2[k2][0]).x, M2 = w2.y, R2 = (w2 = b2[k2][1]).x, E2 = w2.y, O2.push(["C", C2, S2, L2, M2, R2, E2]);
          return O2;
        })(this.pos, t3), t3 = e3[0];
    }
    return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
  }
  function s2() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 ? arguments[1] : void 0;
    if (false === e3) return false;
    for (var i3 = e3, a3 = t3.length; i3 < a3; ++i3) if ("M" == t3[i3][0]) return i3;
    return false;
  }
  Q(Ee, { morph: function(e3, i3, a3, r2, n2) {
    for (var o2 = this.parse(e3), l2 = this.parse(i3), h2 = 0, c2 = 0, d2 = false, u2 = false; false !== h2 || false !== c2; ) {
      var g2;
      d2 = s2(o2, false !== h2 && h2 + 1), u2 = s2(l2, false !== c2 && c2 + 1), false === h2 && (h2 = 0 == (g2 = new Ee(p2.start).bbox()).height || 0 == g2.width ? o2.push(o2[0]) - 1 : o2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1), false === c2 && (c2 = 0 == (g2 = new Ee(p2.dest).bbox()).height || 0 == g2.width ? l2.push(l2[0]) - 1 : l2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1);
      var p2 = t2(o2, h2, d2, l2, c2, u2);
      o2 = o2.slice(0, h2).concat(p2.start, false === d2 ? [] : o2.slice(d2)), l2 = l2.slice(0, c2).concat(p2.dest, false === u2 ? [] : l2.slice(u2)), h2 = false !== d2 && h2 + p2.start.length, c2 = false !== u2 && c2 + p2.dest.length;
    }
    this._array = o2, this.destination = new Ee(), this.destination._array = l2;
    var f2 = this.fromArray(o2.map((function(t3, e4) {
      var i4 = l2[e4].map((function(i5, s3) {
        return 0 === s3 ? i5 : r2.step(t3[s3], l2[e4][s3], a3, n2[e4], n2);
      }));
      return i4;
    })));
    return f2;
  } });
})();
const $a = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });
class Ja {
  constructor(t2) {
    t2.remember("_draggable", this), this.el = t2, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(t2) {
    t2 ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: false })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(t2) {
    const e2 = !t2.type.indexOf("mouse");
    if (e2 && 1 !== t2.which && 0 !== t2.buttons) return;
    if (this.el.dispatch("beforedrag", { event: t2, handler: this }).defaultPrevented) return;
    t2.preventDefault(), t2.stopPropagation(), this.init(false), this.box = this.el.bbox(), this.lastClick = this.el.point($a(t2));
    const i2 = (e2 ? "mouseup" : "touchend") + ".drag";
    zt(window, (e2 ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: false }), zt(window, i2, this.endDrag, this, { passive: false }), this.el.fire("dragstart", { event: t2, handler: this, box: this.box });
  }
  drag(t2) {
    const { box: e2, lastClick: i2 } = this, a2 = this.el.point($a(t2)), s2 = a2.x - i2.x, r2 = a2.y - i2.y;
    if (!s2 && !r2) return e2;
    const n2 = e2.x + s2, o2 = e2.y + r2;
    this.box = new kt(n2, o2, e2.w, e2.h), this.lastClick = a2, this.el.dispatch("dragmove", { event: t2, handler: this, box: this.box }).defaultPrevented || this.move(n2, o2);
  }
  move(t2, e2) {
    "svg" === this.el.type ? gi.prototype.move.call(this.el, t2, e2) : this.el.move(t2, e2);
  }
  endDrag(t2) {
    this.drag(t2), this.el.fire("dragend", { event: t2, handler: this, box: this.box }), Xt(window, "mousemove.drag"), Xt(window, "touchmove.drag"), Xt(window, "mouseup.drag"), Xt(window, "touchend.drag"), this.init(true);
  }
}
function Qa(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
}
function Ka([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { draggable(t2 = true) {
  return (this.remember("_draggable") || new Ja(this)).init(t2), this;
} });
let ts = class {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach(((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", Qa(a2, this.el, this.handlePoints, e2));
    }));
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach(((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    }));
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint("t");
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Qa("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map(((t3) => Ka(t3, e2))), this.rotationPoint = Ka(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
const es = (t2) => function(e2 = true, i2 = {}) {
  "object" == typeof e2 && (i2 = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ts ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i2), this;
};
function is(t2, e2, i2, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i2 });
  };
}
function as([t2, e2], { a: i2, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i2 + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { select: es(ts) }), Q([Ge, je, xe], { pointSelect: es(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach(((t2, e2, i2) => {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Qa("point", this.el, this.points, e2));
    }));
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach(((t2, e2, i2) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    }));
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map(((e2) => Ka(e2, t2)));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
class ss {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach(((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i2, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", is(a2, this.el, this.handlePoints, e2));
    }));
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i2, a2) {
    const s2 = a2.at(i2 - 1), r2 = a2[(i2 + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach(((t2, e2, i2) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2, a2);
    }));
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i2 = this.getPoint("t");
    t2.get(0).plot(i2[0], i2[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", is("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map(((t3) => as(t3, e2))), this.rotationPoint = as(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i2, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i2], [s2, i2], [e2, i2], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
const rs = (t2) => function(e2 = true, i2 = {}) {
  "object" == typeof e2 && (i2 = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ss ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i2), this;
};
Q(Gt, { select: rs(ss) }), Q([Ge, je, xe], { pointSelect: rs(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach(((t2, e2, i2) => {
      this.createHandle.call(this, this.selection, t2, e2, i2), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", is("point", this.el, this.points, e2));
    }));
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach(((t2, e2, i2) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i2);
    }));
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map(((e2) => as(e2, t2)));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
const ns = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY }), os = (t2) => {
  let e2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
  for (let r2 = 0; r2 < t2.length; r2++) {
    const n2 = t2[r2];
    e2 = Math.min(e2, n2[0]), i2 = Math.min(i2, n2[1]), a2 = Math.max(a2, n2[0]), s2 = Math.max(s2, n2[1]);
  }
  return new kt(e2, i2, a2 - e2, s2 - i2);
};
class ls {
  constructor(t2) {
    this.el = t2, t2.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(t2, e2) {
    this.preserveAspectRatio = e2.preserveAspectRatio ?? false, this.aroundCenter = e2.aroundCenter ?? false, this.grid = e2.grid ?? 0, this.degree = e2.degree ?? 0, this.el.off(".resize"), t2 && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && ("rot" === this.eventType ? this.rotate(this.lastEvent) : "point" === this.eventType ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(t2) {
    this.eventType = t2.type;
    const { event: e2, index: i2, points: a2 } = t2.detail, s2 = !e2.type.indexOf("mouse");
    if (s2 && 1 !== (e2.which || e2.buttons)) return;
    if (this.el.dispatch("beforeresize", { event: t2, handler: this }).defaultPrevented) return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(ns(e2)), this.index = i2, this.points = a2.slice();
    const r2 = (s2 ? "mousemove" : "touchmove") + ".resize", n2 = (s2 ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    "point" === t2.type ? zt(window, r2, this.movePoint) : "rot" === t2.type ? zt(window, r2, this.rotate) : zt(window, r2, this.resize), zt(window, n2, this.endResize);
  }
  resize(t2) {
    this.lastEvent = t2;
    const e2 = this.snapToGrid(this.el.point(ns(t2)));
    let i2 = e2.x - this.startPoint.x, a2 = e2.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i2 *= 2, a2 *= 2);
    const s2 = this.box.x + i2, r2 = this.box.y + a2, n2 = this.box.x2 + i2, o2 = this.box.y2 + a2;
    let l2 = new kt(this.box);
    if (this.eventType.includes("l") && (l2.x = Math.min(s2, this.box.x2), l2.x2 = Math.max(s2, this.box.x2)), this.eventType.includes("r") && (l2.x = Math.min(n2, this.box.x), l2.x2 = Math.max(n2, this.box.x)), this.eventType.includes("t") && (l2.y = Math.min(r2, this.box.y2), l2.y2 = Math.max(r2, this.box.y2)), this.eventType.includes("b") && (l2.y = Math.min(o2, this.box.y), l2.y2 = Math.max(o2, this.box.y)), l2.width = l2.x2 - l2.x, l2.height = l2.y2 - l2.y, this.preserveAspectRatio) {
      const t3 = l2.width / this.box.width, e3 = l2.height / this.box.height, i3 = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], a3 = (i3.indexOf(this.eventType) + 4) % i3.length, s3 = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[a3];
      let r3 = this.eventType.includes("t") || this.eventType.includes("b") ? e3 : t3;
      r3 = 2 === this.eventType.length ? Math.max(t3, e3) : r3, l2 = (function(t4, e4, i4) {
        const a4 = [[t4.x, t4.y], [t4.x + t4.width, t4.y], [t4.x + t4.width, t4.y + t4.height], [t4.x, t4.y + t4.height]].map((([t5, a5]) => {
          const s4 = t5 - e4[0], r4 = (a5 - e4[1]) * i4;
          return [s4 * i4 + e4[0], r4 + e4[1]];
        }));
        return os(a4);
      })(this.box, s3, r3);
    }
    this.el.dispatch("resize", { box: new kt(l2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.size(l2.width, l2.height).move(l2.x, l2.y);
  }
  movePoint(t2) {
    this.lastEvent = t2;
    const { x: e2, y: i2 } = this.snapToGrid(this.el.point(ns(t2))), a2 = this.el.array().slice();
    a2[this.index] = [e2, i2], this.el.dispatch("resize", { box: os(a2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.plot(a2);
  }
  rotate(t2) {
    this.lastEvent = t2;
    const e2 = this.startPoint, i2 = this.el.point(ns(t2)), { cx: a2, cy: s2 } = this.box, r2 = e2.x - a2, n2 = e2.y - s2, o2 = i2.x - a2, l2 = i2.y - s2, h2 = Math.sqrt(r2 * r2 + n2 * n2) * Math.sqrt(o2 * o2 + l2 * l2);
    if (0 === h2) return;
    let c2 = Math.acos((r2 * o2 + n2 * l2) / h2) / Math.PI * 180;
    if (!c2) return;
    i2.x < e2.x && (c2 = -c2);
    const d2 = new vt(this.el), { x: u2, y: g2 } = new bt(a2, s2).transformO(d2), { rotate: p2 } = d2.decompose(), f2 = this.snapToAngle(p2 + c2) - p2;
    this.el.dispatch("resize", { box: this.box, angle: f2, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.transform(d2.rotateO(f2, u2, g2));
  }
  endResize(t2) {
    "rot" !== this.eventType && "point" !== this.eventType && this.resize(t2), this.lastEvent = null, this.eventType = "", Xt(window, "mousemove.resize touchmove.resize"), Xt(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(t2) {
    return this.grid && (t2.x = Math.round(t2.x / this.grid) * this.grid, t2.y = Math.round(t2.y / this.grid) * this.grid), t2;
  }
  snapToAngle(t2) {
    return this.degree && (t2 = Math.round(t2 / this.degree) * this.degree), t2;
  }
}
Q(Gt, { resize: function(t2 = true, e2 = {}) {
  "object" == typeof t2 && (e2 = t2, t2 = true);
  let i2 = this.remember("_ResizeHandler");
  return i2 || (t2.prototype instanceof ls ? (i2 = new t2(this), t2 = true) : i2 = new ls(this), this.remember("_resizeHandler", i2)), i2.active(t2, e2), this;
} }), void 0 === window.SVG && (window.SVG = yi), void 0 === window.Apex && (window.Apex = {});
var hs = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new y(this.ctx), this.ctx.axes = new ra(this.ctx), this.ctx.core = new qa(this.ctx.el, this.ctx), this.ctx.config = new Wi({}), this.ctx.data = new $i(this.ctx), this.ctx.grid = new Ki(this.ctx), this.ctx.graphics = new Mi(this.ctx), this.ctx.coreUtils = new Pi(this.ctx), this.ctx.crosshairs = new na(this.ctx), this.ctx.events = new aa(this.ctx), this.ctx.exports = new Ji(this.ctx), this.ctx.fill = new ji(this.ctx), this.ctx.localization = new sa(this.ctx), this.ctx.options = new Oi(), this.ctx.responsive = new oa(this.ctx), this.ctx.series = new Zi(this.ctx), this.ctx.theme = new la(this.ctx), this.ctx.formatters = new Xi(this.ctx), this.ctx.titleSubtitle = new ha(this.ctx), this.ctx.legend = new xa(this.ctx), this.ctx.toolbar = new ba(this.ctx), this.ctx.tooltip = new Sa(this.ctx), this.ctx.dimensions = new pa(this.ctx), this.ctx.updateHelpers = new Za(this.ctx), this.ctx.zoomPanSelection = new ma(this.ctx), this.ctx.w.globals.tooltip = new Sa(this.ctx);
  } }]), t2;
})(), cs = (function() {
  function t2(e2) {
    i(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "clear", value: function(t3) {
    var e2 = t3.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
  } }, { key: "killSVG", value: function(t3) {
    t3.each((function() {
      this.removeClass("*"), this.off();
    }), true), t3.clear();
  } }, { key: "clearDomElements", value: function(t3) {
    var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
    a2.parentNode && a2.parentNode.parentNode && !i2 && (a2.parentNode.parentNode.style.minHeight = "unset");
    var s2 = this.w.globals.dom.baseEl;
    s2 && this.ctx.eventList.forEach((function(t4) {
      s2.removeEventListener(t4, e2.ctx.events.documentEvent);
    }));
    var r2 = this.w.globals.dom;
    if (null !== this.ctx.el) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectBarMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
  } }]), t2;
})(), ds = /* @__PURE__ */ new WeakMap();
var us = (function() {
  function t2(e2, a2) {
    i(this, t2), this.opts = a2, this.ctx = this, this.w = new Gi(a2).init(), this.el = e2, this.w.globals.cuid = v.randomId(), this.w.globals.chartID = this.w.config.chart.id ? v.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new hs(this).initModules(), this.lastUpdateOptions = null, this.create = v.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return s(t2, [{ key: "render", value: function() {
    var t3 = this;
    return new Promise((function(e2, i2) {
      if (v.elementExists(t3.el)) {
        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
        var a2 = t3.w.config.chart.events.beforeMount;
        "function" == typeof a2 && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), (function(t4, e3) {
          var i3 = false;
          if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var a3 = t4.getBoundingClientRect();
            "none" !== t4.style.display && 0 !== a3.width || (i3 = true);
          }
          var s3 = new ResizeObserver((function(a4) {
            i3 && e3.call(t4, a4), i3 = true;
          }));
          t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach((function(t5) {
            return s3.observe(t5);
          })) : s3.observe(t4), ds.set(e3, s3);
        })(t3.el.parentNode, t3.parentResizeHandler);
        var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = v.is("ShadowRoot", s2), n2 = t3.el.ownerDocument, o2 = r2 ? s2.getElementById("apexcharts-css") : n2.getElementById("apexcharts-css");
        if (!o2) {
          var l2;
          (o2 = document.createElement("style")).id = "apexcharts-css", o2.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: "";\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape="circle"]::before {\n  content: "\\25CF";\n}\n\n.apexcharts-tooltip-marker[shape="square"]::before,\n.apexcharts-tooltip-marker[shape="rect"]::before {\n  content: "\\25A0";\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape="line"]::before {\n  content: "\\2500";\n}\n\n.apexcharts-tooltip-marker[shape="diamond"]::before {\n  content: "\\25C6";\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape="triangle"]::before {\n  content: "\\25B2";\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape="cross"]::before {\n  content: "\\2715";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="plus"]::before {\n  content: "\\2715";\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="star"]::before {\n  content: "\\2605";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="sparkle"]::before {\n  content: "\\2726";\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-disable-transitions * {\n  transition: none !important;\n}';
          var h2 = (null === (l2 = t3.opts.chart) || void 0 === l2 ? void 0 : l2.nonce) || t3.w.config.chart.nonce;
          h2 && o2.setAttribute("nonce", h2), r2 ? s2.prepend(o2) : n2.head.appendChild(o2);
        }
        var c2 = t3.create(t3.w.config.series, {});
        if (!c2) return e2(t3);
        t3.mount(c2).then((function() {
          "function" == typeof t3.w.config.chart.events.mounted && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(c2);
        })).catch((function(t4) {
          i2(t4);
        }));
      } else i2(new Error("Element not found"));
    }));
  } }, { key: "create", value: function(t3, e2) {
    var i2 = this, a2 = this.w;
    new hs(this).initModules();
    var s2 = this.w.globals;
    if (s2.noData = false, s2.animationEnded = false, !v.elementExists(this.el)) return s2.animationEnded = true, null;
    (this.responsive.checkResponsiveConfig(e2), a2.config.xaxis.convertedCatToNumeric) && new Ni(a2.config).convertCatToNumericXaxis(a2.config, this.ctx);
    if (this.core.setupElements(), "treemap" === a2.config.chart.type && (a2.config.grid.show = false, a2.config.yaxis[0].show = false), 0 === s2.svgWidth) return s2.animationEnded = true, null;
    var r2 = t3;
    t3.forEach((function(t4, e3) {
      t4.hidden && (r2 = i2.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e3 }));
    }));
    var n2 = Pi.checkComboSeries(r2, a2.config.chart.type);
    s2.comboCharts = n2.comboCharts, s2.comboBarCount = n2.comboBarCount;
    var o2 = r2.every((function(t4) {
      return t4.data && 0 === t4.data.length;
    }));
    (0 === r2.length || o2 && s2.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r2), this.theme.init(), new Vi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s2.noData && s2.collapsedSeries.length !== s2.series.length && !a2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s2.axisCharts && (this.core.coreCalculations(), "category" !== a2.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a2.globals.minX, this.ctx.toolbar.maxX = a2.globals.maxX), this.formatters.heatmapLabelFormatters(), new Pi(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var l2 = this.core.xySettings();
    this.grid.createGridMask();
    var h2 = this.core.plotChartType(r2, l2), c2 = new qi(this);
    return c2.bringForward(), a2.config.dataLabels.background.enabled && c2.dataLabelsBackground(), this.core.shiftGraphPosition(), a2.globals.dataPoints > 50 && a2.globals.dom.elWrap.classList.add("apexcharts-disable-transitions"), { elGraph: h2, xyRatios: l2, dimensions: { plot: { left: a2.globals.translateX, top: a2.globals.translateY, width: a2.globals.gridWidth, height: a2.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i2 = this, a2 = i2.w;
    return new Promise((function(s2, r2) {
      if (null === i2.el) return r2(new Error("Not enough data to display or target element not found"));
      (null === e2 || a2.globals.allSeriesCollapsed) && i2.series.handleNoData(), i2.grid = new Ki(i2);
      var n2, o2, l2 = i2.grid.drawGrid();
      (i2.annotations = new Fi(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), "back" === a2.config.grid.position) && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (n2 = l2.elGridBorders) && void 0 !== n2 && n2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      if (Array.isArray(e2.elGraph)) for (var h2 = 0; h2 < e2.elGraph.length; h2++) a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
      else a2.globals.dom.elGraphical.add(e2.elGraph);
      "front" === a2.config.grid.position && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (o2 = l2.elGridBorders) && void 0 !== o2 && o2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      "front" === a2.config.xaxis.crosshairs.position && i2.crosshairs.drawXCrosshairs(), "front" === a2.config.yaxis[0].crosshairs.position && i2.crosshairs.drawYCrosshairs(), "treemap" !== a2.config.chart.type && i2.axes.drawAxis(a2.config.chart.type, l2);
      var c2 = new Qi(t3.ctx, l2), d2 = new ia(t3.ctx, l2);
      if (null !== l2 && (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map((function(t4, e3) {
        -1 === a2.globals.ignoreYAxisIndexes.indexOf(e3) && d2.yAxisTitleRotate(e3, t4.opposite);
      }))), i2.annotations.drawAxesAnnotations(), !a2.globals.noData) {
        if (a2.config.tooltip.enabled && !a2.globals.noData && i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar)) (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
        else {
          var u2 = a2.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach((function(t4) {
            u2[t4] = false;
          }));
        }
        a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
      }
      a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach((function(t4) {
        t4.method(t4.params, false, t4.context);
      })), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
    }));
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), (function(t4, e2) {
      var i2 = ds.get(e2);
      i2 && (i2.disconnect(), ds.delete(e2));
    })(this.el.parentNode, this.parentResizeHandler);
    var t3 = this.w.config.chart.id;
    t3 && Apex._chartInstances.forEach((function(e2, i2) {
      e2.id === v.escapeString(t3) && Apex._chartInstances.splice(i2, 1);
    })), new cs(this.ctx).clear({ isUpdating: false });
  } }, { key: "updateOptions", value: function(t3) {
    var e2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], n2 = this.w;
    return n2.globals.selection = void 0, this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(t3) ? this : (this.lastUpdateOptions = v.clone(t3), t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map((function(t4, i3) {
      return e2.updateHelpers._extendSeries(t4, i3);
    }))), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), n2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2));
  } }, { key: "updateSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
  } }, { key: "appendSeries", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w.config.series.slice();
    return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
  } }, { key: "appendData", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this;
    i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
    for (var a2 = i2.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++) if (null !== t3[s2] && void 0 !== t3[s2]) for (var r2 = 0; r2 < t3[s2].data.length; r2++) a2[s2].data.push(t3[s2].data[r2]);
    return i2.w.config.series = a2, e2 && (i2.w.globals.initialSeries = v.clone(i2.w.config.series)), this.update();
  } }, { key: "update", value: function(t3) {
    var e2 = this;
    return new Promise((function(i2, a2) {
      if (e2.lastUpdateOptions && JSON.stringify(e2.lastUpdateOptions) === JSON.stringify(t3)) return i2(e2);
      e2.lastUpdateOptions = v.clone(t3), new cs(e2.ctx).clear({ isUpdating: true });
      var s2 = e2.create(e2.w.config.series, t3);
      if (!s2) return i2(e2);
      e2.mount(s2).then((function() {
        "function" == typeof e2.w.config.chart.events.updated && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
      })).catch((function(t4) {
        a2(t4);
      }));
    }));
  } }, { key: "getSyncedCharts", value: function() {
    var t3 = this.getGroupedCharts(), e2 = [this];
    return t3.length && (e2 = [], t3.forEach((function(t4) {
      e2.push(t4);
    }))), e2;
  } }, { key: "getGroupedCharts", value: function() {
    var t3 = this;
    return Apex._chartInstances.filter((function(t4) {
      if (t4.group) return true;
    })).map((function(e2) {
      return t3.w.config.chart.group === e2.group ? e2.chart : t3;
    }));
  } }, { key: "toggleSeries", value: function(t3) {
    return this.series.toggleSeries(t3);
  } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
    return this.series.toggleSeriesOnHover(t3, e2);
  } }, { key: "showSeries", value: function(t3) {
    this.series.showSeries(t3);
  } }, { key: "hideSeries", value: function(t3) {
    this.series.hideSeries(t3);
  } }, { key: "highlightSeries", value: function(t3) {
    this.series.highlightSeries(t3);
  } }, { key: "isSeriesHidden", value: function(t3) {
    this.series.isSeriesHidden(t3);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.series.resetSeries(t3, e2);
  } }, { key: "addEventListener", value: function(t3, e2) {
    this.events.addEventListener(t3, e2);
  } }, { key: "removeEventListener", value: function(t3, e2) {
    this.events.removeEventListener(t3, e2);
  } }, { key: "addXaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 && (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addYaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 && (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addPointAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i2 && (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
  } }, { key: "clearAnnotations", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e2 = this;
    t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
  } }, { key: "removeAnnotation", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = this;
    e2 && (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
    return this.coreUtils.getSeriesTotalsXRange(t3, e2);
  } }, { key: "getHighestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    return this.updateHelpers.toggleDataPointSelection(t3, e2);
  } }, { key: "zoomX", value: function(t3, e2) {
    this.ctx.toolbar.zoomUpdateOptions(t3, e2);
  } }, { key: "setLocale", value: function(t3) {
    this.localization.setCurrentLocaleValues(t3);
  } }, { key: "dataURI", value: function(t3) {
    return new Ji(this.ctx).dataURI(t3);
  } }, { key: "getSvgString", value: function(t3) {
    return new Ji(this.ctx).getSvgString(t3);
  } }, { key: "exportToCSV", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Ji(this.ctx).exportToCSV(t3);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var t3 = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((function() {
      t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
    }), 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var t3 = this.w.config.chart.redrawOnWindowResize;
    "function" == typeof t3 && (t3 = t3()), t3 && this._windowResize();
  } }], [{ key: "getChartByID", value: function(t3) {
    var e2 = v.escapeString(t3);
    if (Apex._chartInstances) {
      var i2 = Apex._chartInstances.filter((function(t4) {
        return t4.id === e2;
      }))[0];
      return i2 && i2.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e2 = document.querySelectorAll("[data-apexcharts]"), i2 = 0; i2 < e2.length; i2++) {
      new t2(e2[i2], JSON.parse(e2[i2].getAttribute("data-options"))).render();
    }
  } }, { key: "exec", value: function(t3, e2) {
    var i2 = this.getChartByID(t3);
    if (i2) {
      i2.w.globals.isExecCalled = true;
      var a2 = null;
      if (-1 !== i2.publicMethods.indexOf(e2)) {
        for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), n2 = 2; n2 < s2; n2++) r2[n2 - 2] = arguments[n2];
        a2 = i2[e2].apply(i2, r2);
      }
      return a2;
    }
  } }, { key: "merge", value: function(t3, e2) {
    return v.extend(t3, e2);
  } }]), t2;
})();
const A = [
  "animationEnd",
  "beforeMount",
  "mounted",
  "updated",
  "click",
  "mouseMove",
  "mouseLeave",
  "legendClick",
  "markerClick",
  "selection",
  "dataPointSelection",
  "dataPointMouseEnter",
  "dataPointMouseLeave",
  "beforeZoom",
  "beforeResetZoom",
  "zoomed",
  "scrolled",
  "brushScrolled"
], m = /* @__PURE__ */ defineComponent({
  name: "apexchart",
  props: {
    options: {
      type: Object
    },
    type: {
      type: String
    },
    series: {
      type: Array,
      required: true
    },
    width: {
      default: "100%"
    },
    height: {
      default: "auto"
    }
  },
  // events emitted by this component
  emits: A,
  setup(a2, { emit: x2 }) {
    const g2 = /* @__PURE__ */ ref(null), t2 = /* @__PURE__ */ ref(null), f2 = (e2) => e2 && typeof e2 == "object" && !Array.isArray(e2) && e2 != null, S2 = (e2, n2) => {
      typeof Object.assign != "function" && (function() {
        Object.assign = function(o2) {
          if (o2 == null)
            throw new TypeError("Cannot convert undefined or null to object");
          let v2 = Object(o2);
          for (let i2 = 1; i2 < arguments.length; i2++) {
            let l2 = arguments[i2];
            if (l2 != null)
              for (let p2 in l2)
                l2.hasOwnProperty(p2) && (v2[p2] = l2[p2]);
          }
          return v2;
        };
      })();
      let s2 = Object.assign({}, e2);
      return f2(e2) && f2(n2) && Object.keys(n2).forEach((o2) => {
        f2(n2[o2]) ? o2 in e2 ? s2[o2] = S2(e2[o2], n2[o2]) : Object.assign(s2, {
          [o2]: n2[o2]
        }) : Object.assign(s2, {
          [o2]: n2[o2]
        });
      }), s2;
    }, r2 = async () => {
      if (await nextTick(), t2.value)
        return;
      const e2 = {
        chart: {
          type: a2.type || a2.options.chart.type || "line",
          height: a2.height,
          width: a2.width,
          events: {}
        },
        series: a2.series
      }, n2 = a2.options.chart ? a2.options.chart.events : null;
      A.forEach((o2) => {
        let v2 = (...i2) => x2(o2, ...i2);
        e2.chart.events[o2] = (...i2) => {
          v2(...i2), n2 && n2.hasOwnProperty(o2) && n2[o2](...i2);
        };
      });
      const s2 = S2(a2.options, e2);
      return t2.value = new us(g2.value, s2), t2.value.render();
    }, d2 = () => (h2(), r2()), h2 = () => {
      t2.value.destroy(), t2.value = null;
    }, O2 = (e2, n2) => t2.value.updateSeries(e2, n2), y2 = (e2, n2, s2, o2) => t2.value.updateOptions(e2, n2, s2, o2), j2 = (e2) => t2.value.toggleSeries(e2), P2 = (e2) => {
      t2.value.showSeries(e2);
    }, C2 = (e2) => {
      t2.value.hideSeries(e2);
    }, E2 = (e2, n2) => t2.value.appendSeries(e2, n2), M2 = () => {
      t2.value.resetSeries();
    }, D2 = (e2, n2) => {
      t2.value.toggleDataPointSelection(e2, n2);
    }, L2 = (e2) => t2.value.appendData(e2), R2 = (e2, n2) => t2.value.zoomX(e2, n2), X2 = (e2) => t2.value.dataURI(e2), z2 = (e2) => t2.value.setLocale(e2), I2 = (e2, n2) => {
      t2.value.addXaxisAnnotation(e2, n2);
    }, U2 = (e2, n2) => {
      t2.value.addYaxisAnnotation(e2, n2);
    }, B2 = (e2, n2) => {
      t2.value.addPointAnnotation(e2, n2);
    }, T2 = (e2, n2) => {
      t2.value.removeAnnotation(e2, n2);
    }, Y2 = () => {
      t2.value.clearAnnotations();
    };
    onBeforeMount(() => {
      window.ApexCharts = us;
    }), onMounted(() => {
      g2.value = getCurrentInstance().proxy.$el, r2();
    }), onBeforeUnmount(() => {
      t2.value && h2();
    });
    const u2 = /* @__PURE__ */ toRefs(a2);
    return watch(u2.options, () => {
      !t2.value && a2.options ? r2() : t2.value.updateOptions(a2.options);
    }), watch(
      u2.series,
      () => {
        !t2.value && a2.series ? r2() : t2.value.updateSeries(a2.series);
      },
      { deep: true }
    ), watch(u2.type, () => {
      d2();
    }), watch(u2.width, () => {
      d2();
    }), watch(u2.height, () => {
      d2();
    }), {
      chart: t2,
      init: r2,
      refresh: d2,
      destroy: h2,
      updateOptions: y2,
      updateSeries: O2,
      toggleSeries: j2,
      showSeries: P2,
      hideSeries: C2,
      resetSeries: M2,
      zoomX: R2,
      toggleDataPointSelection: D2,
      appendData: L2,
      appendSeries: E2,
      addXaxisAnnotation: I2,
      addYaxisAnnotation: U2,
      addPointAnnotation: B2,
      removeAnnotation: T2,
      clearAnnotations: Y2,
      setLocale: z2,
      dataURI: X2
    };
  },
  render() {
    return h$8("div", {
      class: "vue-apexcharts"
    });
  }
}), J = (a2) => {
  a2.component(m.name, m);
};
m.install = J;
const _hoisted_1$3 = {
  class: "container",
  id: "tblItems"
};
const _hoisted_2$3 = { class: "row" };
const _hoisted_3$3 = { class: "col" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "ItemsSummaryChart",
  setup(__props) {
    const itemDataStore = useItemDataStore();
    const indexStore = useIndexStore();
    onMounted(() => {
      itemDataStore.fetchItemData();
    });
    const options = computed(() => {
      return {
        chart: {
          height: 650,
          stacked: true,
          stackType: "100%",
          toolbar: {
            show: true
          },
          type: "bar",
          zoom: {
            enabled: true
          }
        },
        colors: ["#000000", "#66DA26", "#F01A96", "#9230AB", "#304ED1", "#188EDC", "#fbc042"],
        dataLabels: {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          formatter: function(val, opts) {
            return `${round(val, 2)}%`;
          }
        },
        title: {
          text: "Items At Level"
        },
        xaxis: {
          categories: Object.values(indexStore.types)
          //   tickAmount:
          //     levelProgressionsStore.levelProgressions == null
          //       ? 1
          //       : levelProgressionsStore.levelProgressions.length,
          //   title: {
          //     text: 'Level'
          //   }
        }
        // yaxis: {
        //   title: {
        //     text: 'Days'
        //   }
        // },
        // tooltip: {
        //   //@ts-ignore
        //   custom: function ({ series, seriesIndex, dataPointIndex, w }) {
        //     if (levelProgressionsStore.levelProgressions == null) {
        //       return ''
        //     }
        //     return (
        //       '<div class="container tooltip">' +
        //       '<div class="row header"><div class="col">' +
        //       '<span> Level ' +
        //       levelProgressionsStore.levelProgressions[dataPointIndex].data.level +
        //       '</span></div></div>' +
        //       '<div class="row"><div class="col">' +
        //       '<span> Started At: ' +
        //       format(
        //         levelProgressionsStore.levelProgressions[dataPointIndex].data.started_at,
        //         'MM/dd/yyyy'
        //       ) +
        //       '</span></div></div>' +
        //       '<div class="row"><div class="col">' +
        //       '<span> Passed At: ' +
        //       format(
        //         levelProgressionsStore.levelProgressions[dataPointIndex].data.passed_at,
        //         'MM/dd/yyyy'
        //       ) +
        //       '</span></div></div>' +
        //       '<div class="row"><div class="col">' +
        //       '<span> Days On Level: ' +
        //       levelProgressionsStore.levelProgressions[dataPointIndex].data.timeToPass +
        //       '</span></div></div>' +
        //       '</div>'
        //     )
        //   }
        // }
      };
    });
    const series = computed(() => {
      const data6 = [];
      Object.keys(indexStore.stages).forEach((l2) => {
        const subData = {
          data: [],
          name: l2
        };
        Object.keys(indexStore.types).forEach((t2) => {
          const y2 = itemDataStore.assignmentsForTypeAndLevel(
            t2,
            //@ts-expect-error has any
            Object.values(indexStore.stages[l2])
          ).length;
          subData.data.push(y2);
        });
        data6.push(subData);
      });
      return data6;
    });
    return (_ctx, _cache) => {
      const _component_BlockUI = resolveComponent("BlockUI");
      return openBlock(), createBlock(_component_BlockUI, {
        blocked: unref(itemDataStore).loading
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$3, [
            createBaseVNode("div", _hoisted_2$3, [
              createBaseVNode("div", _hoisted_3$3, [
                createVNode(unref(m), {
                  stacked: "true",
                  type: "bar",
                  height: "650",
                  options: options.value,
                  series: series.value
                }, null, 8, ["options", "series"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["blocked"]);
    };
  }
});
const _hoisted_1$2 = { class: "container" };
const _hoisted_2$2 = { class: "row" };
const _hoisted_3$2 = { class: "col" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "ItemsSummaryView",
  setup(__props) {
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", _hoisted_2$2, [
          createBaseVNode("div", _hoisted_3$2, [
            createVNode(_sfc_main$3)
          ])
        ])
      ]);
    };
  }
});
const _hoisted_1$1 = { class: "container" };
const _hoisted_2$1 = { class: "row" };
const _hoisted_3$1 = { class: "col" };
const _hoisted_4 = { id: "note" };
const _hoisted_5 = { class: "row" };
const _hoisted_6 = { class: "col" };
const _hoisted_7 = { class: "row" };
const _hoisted_8 = { class: "col" };
const _hoisted_9 = { class: "row" };
const _hoisted_10 = { class: "col" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "TimeOnLevelChart",
  setup(__props) {
    const levelProgressionsStore = useLevelProgressionsStore(), resetsStore = useResetsStore();
    const ignoreLevels = /* @__PURE__ */ ref([]);
    const levelsToCalcAgainst = computed(() => {
      const cl = cloneDeep(levelProgressionsStore.levelProgressions);
      pullAt(cl, ignoreLevels.value);
      return cl;
    });
    const average = computed(() => {
      return meanBy(levelsToCalcAgainst.value, (o2) => o2.data.timeToPass());
    });
    const median = computed(() => {
      const d2 = orderBy(levelsToCalcAgainst.value, [(o2) => o2.data.level], ["asc"]);
      if (d2.length == 0) {
        return 0;
      }
      return d2.length % 2 == 0 ? d2[d2.length / 2]?.data.timeToPass() : mean([
        d2[d2.length / 2 - 0.5]?.data.timeToPass() ?? 0,
        d2[d2.length / 2 + 0.5]?.data.timeToPass() ?? 0
      ]);
    });
    const expectedLevelUp = computed(() => {
      if (levelProgressionsStore.levelProgressions.length == 0) {
        return 0;
      } else {
        const currentLevel = levelsToCalcAgainst.value[levelsToCalcAgainst.value.length - 1];
        const daysSoFar = differenceInCalendarDays(
          /* @__PURE__ */ new Date(),
          new Date(currentLevel?.data.unlocked_at ?? "")
        );
        return average.value - daysSoFar;
      }
    });
    const options = computed(() => {
      return {
        chart: {
          events: {
            dataPointSelection: (event, chartContext, opts) => {
              ignoreLevels.value = flatten(opts.selectedDataPoints);
            }
          },
          selection: {
            enabled: true
          },
          stacked: true
        },
        states: {
          active: {
            allowMultipleDataPointsSelection: true,
            filter: {
              type: "lighten",
              value: 0.35
            }
          }
        },
        subtitle: {
          text: "Click levels to exclude from calculation"
        },
        title: {
          text: "Level Progression"
        },
        tooltip: {
          //@ts-expect-error has any
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          custom: function({ dataPointIndex, series: series2, seriesIndex, w: w2 }) {
            if (levelProgressionsStore.levelProgressions == null) {
              return "";
            }
            return '<div class="container tooltip"><div class="row header"><div class="col"><span> Level ' + levelProgressionsStore.levelProgressions[dataPointIndex]?.data.level + '</span></div></div><div class="row"><div class="col"><span> Unlocked At: ' + format(
              levelProgressionsStore.levelProgressions[dataPointIndex]?.data.unlocked_at ?? "",
              "MM/dd/yyyy"
            ) + '</span></div></div><div class="row"><div class="col"><span> Started At: ' + format(
              levelProgressionsStore.levelProgressions[dataPointIndex]?.data.started_at ?? "",
              "MM/dd/yyyy"
            ) + '</span></div></div><div class="row"><div class="col"><span> Passed At: ' + format(
              levelProgressionsStore.levelProgressions[dataPointIndex]?.data.passed_at ?? "",
              "MM/dd/yyyy"
            ) + '</span></div></div><div class="row"><div class="col"><span> Days On Level: ' + levelProgressionsStore.levelProgressions[dataPointIndex]?.data.timeToPass() + "</span></div></div></div>";
          }
        },
        xaxis: {
          tickAmount: levelProgressionsStore.levelProgressions == null ? 1 : levelProgressionsStore.levelProgressions.length,
          // type: 'category',
          // categories:
          //   indexStore .levelProgressions == null
          //     ? []
          //     : //@ts-ignore
          //       indexStore .levelProgressions.map((l: any) => l.data.level)
          title: {
            text: "Level"
          }
        },
        yaxis: {
          //   min: 0,
          //   max: maxBy(indexStore .levelProgressions, (o) =>
          //     differenceInDays(new Date(o.data.passed_at), new Date(o.data.started_at))
          //   )
          title: {
            text: "Days"
          }
        }
      };
    });
    const series = computed(() => {
      const t2 = [
        // {
        //   data:
        //     levelProgressionsStore.levelProgressions == null
        //       ? []
        //       : levelProgressionsStore.levelProgressions.map((l: any) => {
        //           return {
        //             x: l.data.level.toString(),
        //             y: l.data.timeToPass(),
        //           }
        //         }),
        //   name: 'Time From Start',
        // },
        {
          data: levelProgressionsStore.levelProgressions == null ? [] : levelProgressionsStore.levelProgressions.filter((l2) => l2.data.reset_at == null).map((l2) => {
            return {
              x: l2.data.level.toString(),
              y: l2.data.timeToPassFromUnlock()
            };
          }),
          name: "Time From Unlock"
        }
      ];
      return t2;
    });
    onMounted(() => {
      levelProgressionsStore.fetchLevelProgressions().then(() => {
        resetsStore.setResetsInLevelProgression();
      });
      debugger;
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("div", _hoisted_3$1, [
            withDirectives((openBlock(), createElementBlock("span", _hoisted_4, [
              createVNode(unref(FontAwesomeIcon), { icon: unref(faTriangleExclamation) }, null, 8, ["icon"])
            ])), [
              [
                _directive_tooltip,
                "Due to WaniKani adding the necessary endpoint later on, not all users will have a full history.",
                void 0,
                { top: true }
              ]
            ]),
            createVNode(unref(m), {
              type: "bar",
              height: "350",
              options: options.value,
              series: series.value
            }, null, 8, ["options", "series"])
          ])
        ]),
        createBaseVNode("div", _hoisted_5, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "col-4" }, null, -1)),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "col" }, [
            createBaseVNode("span", { class: "header" }, "Average Level Up Time")
          ], -1)),
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("span", null, toDisplayString(average.value.toFixed(2)), 1)
          ]),
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "col-3" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_7, [
          _cache[3] || (_cache[3] = createBaseVNode("div", { class: "col-4" }, null, -1)),
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "col" }, [
            createBaseVNode("span", { class: "header" }, "Median Level Up Time")
          ], -1)),
          createBaseVNode("div", _hoisted_8, [
            createBaseVNode("span", null, toDisplayString(median.value?.toFixed(2)), 1)
          ]),
          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "col-3" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_9, [
          _cache[6] || (_cache[6] = createBaseVNode("div", { class: "col-4" }, null, -1)),
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "col" }, [
            createBaseVNode("span", { class: "header" }, "Expected Level Up Time")
          ], -1)),
          createBaseVNode("div", _hoisted_10, [
            createBaseVNode("span", null, toDisplayString(expectedLevelUp.value.toFixed(2)), 1)
          ]),
          _cache[8] || (_cache[8] = createBaseVNode("div", { class: "col-3" }, null, -1))
        ])
      ]);
    };
  }
});
const TimeOnLevelChart = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-ad632937"]]);
const _hoisted_1 = { class: "container" };
const _hoisted_2 = { class: "row" };
const _hoisted_3 = { class: "col" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "LevelProgressionView",
  setup(__props) {
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createVNode(TimeOnLevelChart)
          ])
        ])
      ]);
    };
  }
});
const router = createRouter({
  // history: createWebHistory(import.meta.env.BASE_URL),
  history: createMemoryHistory(),
  routes: [
    {
      component: HomeView,
      name: "home",
      path: "/"
    },
    {
      // component: () => import('@/views/LevelProgressionView.vue'),
      component: _sfc_main,
      name: "LevelProgression",
      path: "/LevelProgression"
    },
    {
      // component: () => import('@/views/ItemDetailsView.vue'),
      component: _sfc_main$4,
      name: "ItemDetailsWaniKani",
      path: "/ItemDetailsWaniKani"
    },
    {
      // component: () => import('@/views/ItemDetailsView.vue'),
      component: _sfc_main$8,
      name: "ItemDetailsJLPT",
      path: "/ItemDetailsJLPT"
    },
    {
      // component: () => import('@/views/ItemDetailsView.vue'),
      component: _sfc_main$6,
      name: "ItemDetailsJoyo",
      path: "/ItemDetailsJoyo"
    },
    {
      // component: () => import('@/views/ItemsSummaryView.vue'),
      component: _sfc_main$2,
      name: "ItemsSummary",
      path: "/ItemsSummary"
    }
  ]
});
const MyPreset = ke$1(index, {
  //Your customizations, see the following sections for examples
  primitive: {
    warning: "{yellow.500}"
  },
  semantic: {
    primary: {
      100: "{indigo.100}",
      200: "{indigo.200}",
      300: "{indigo.300}",
      400: "{indigo.400}",
      50: "{indigo.50}",
      500: "{indigo.500}",
      600: "{indigo.600}",
      700: "{indigo.700}",
      800: "{indigo.800}",
      900: "{indigo.900}",
      950: "{indigo.950}"
    }
  }
}), pinia = createPinia();
const app = createApp(_sfc_main$e);
const addStatsDiv = () => {
  const newSpot = document.createElement("div");
  const spotBefore = document.getElementsByClassName("site-content-container")[0];
  newSpot.id = "divStats";
  newSpot.classList.add("hidden");
  if (spotBefore == null) {
    console.log("Could not find dashboard__content");
  } else {
    spotBefore.before(newSpot);
  }
};
function addChangelogDiv() {
  const newSpot = document.createElement("div");
  const spotBefore = document.getElementsByClassName("dashboard__content")[0];
  newSpot.id = "statsChangelog";
  newSpot.classList.add("hidden");
  if (spotBefore == null) {
    console.log("Could not find dashboard__content");
  } else {
    spotBefore.before(newSpot);
  }
}
pinia.use(src_default);
app.use(pinia);
app.use(router);
app.directive("tooltip", Tooltip);
app.use(PrimeVue, {
  theme: {
    options: {
      darkModeSelector: ".dark"
    },
    preset: MyPreset
  }
});
{
  addStatsDiv();
  addChangelogDiv();
  app.mount("#divStats");
}



    // Create our shared stylesheet:
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
:root {
  --stats-enlightened: #00aaff;
  --stats-master: #6680e5;
  --stats-guru: #bb60d2;
  --stats-apprentice: #ff80d5;
  --stats-burned: #faac05;
  --stats-initiate: #aaaaaa;
  --stats-locked: #aaaaaa44;
  --stats-kanji: #f100a1;
  --stats-radical: #00a1f1;
  --stats-vocab: #a100f1;
}

#divUser {
  display: grid;
}

[id^=kofi-widget-overlay] .floatingchat-container-wrap {
  left: 25px;
  bottom: 25px;
}
[id^=kofi-widget-overlay] .floatingchat-container-wrap .kofiimg {
  width: 16px;
}

.v-center {
  display: flex;
  align-items: center;
  height: 100%;
}

body {
  margin: 0;
  padding: 0 !important;
  background-color: #eee;
  color: #212529;
}

.container,
.contianer-sm,
.caontiner-md,
.container-lg,
.container-xl,
.container-full {
  margin-right: auto;
  margin-left: auto;
}

.container-full {
  width: 95vw;
}

@media (min-width: 576px) {
  .container,
  .container-sm {
    width: 540px;
  }
}
@media (min-width: 768px) {
  .container,
  .container-sm,
  .container-md {
    width: 720px;
  }
}
@media (min-width: 992px) {
  .container,
  .container-sm,
  .container-md,
  .container-lg {
    width: 960px;
  }
}
@media (min-width: 1200px) {
  .container,
  .conatiner-sm,
  .container-md,
  .container-lg,
  .container-xl {
    width: 1140px;
  }
}
.row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -0.5rem;
  margin-left: -0.5rem;
  margin-top: -0.5rem;
}

.col {
  flex-grow: 1;
  flex-basis: 0;
  padding: 15px;
  max-width: 95vw;
}

.col-fixed {
  flex: 0 0 auto;
  padding: 15px;
}

@media screen and (min-wdith: 0) {
  .col-xs-1 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 1) !important;
  }
  .col-offset-xs-1 {
    margin-left: calc(8.3333333333% * 1) !important;
  }
  .col-xs-2 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 2) !important;
  }
  .col-offset-xs-2 {
    margin-left: calc(8.3333333333% * 2) !important;
  }
  .col-xs-3 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 3) !important;
  }
  .col-offset-xs-3 {
    margin-left: calc(8.3333333333% * 3) !important;
  }
  .col-xs-4 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 4) !important;
  }
  .col-offset-xs-4 {
    margin-left: calc(8.3333333333% * 4) !important;
  }
  .col-xs-5 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 5) !important;
  }
  .col-offset-xs-5 {
    margin-left: calc(8.3333333333% * 5) !important;
  }
  .col-xs-6 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 6) !important;
  }
  .col-offset-xs-6 {
    margin-left: calc(8.3333333333% * 6) !important;
  }
  .col-xs-7 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 7) !important;
  }
  .col-offset-xs-7 {
    margin-left: calc(8.3333333333% * 7) !important;
  }
  .col-xs-8 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 8) !important;
  }
  .col-offset-xs-8 {
    margin-left: calc(8.3333333333% * 8) !important;
  }
  .col-xs-9 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 9) !important;
  }
  .col-offset-xs-9 {
    margin-left: calc(8.3333333333% * 9) !important;
  }
  .col-xs-10 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 10) !important;
  }
  .col-offset-xs-10 {
    margin-left: calc(8.3333333333% * 10) !important;
  }
  .col-xs-11 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 11) !important;
  }
  .col-offset-xs-11 {
    margin-left: calc(8.3333333333% * 11) !important;
  }
  .col-xs-12 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 12) !important;
  }
  .col-offset-xs-12 {
    margin-left: calc(8.3333333333% * 12) !important;
  }
}
@media screen and (min-wdith: 576px) {
  .col-sm-1 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 1) !important;
  }
  .col-offset-sm-1 {
    margin-left: calc(8.3333333333% * 1) !important;
  }
  .col-sm-2 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 2) !important;
  }
  .col-offset-sm-2 {
    margin-left: calc(8.3333333333% * 2) !important;
  }
  .col-sm-3 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 3) !important;
  }
  .col-offset-sm-3 {
    margin-left: calc(8.3333333333% * 3) !important;
  }
  .col-sm-4 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 4) !important;
  }
  .col-offset-sm-4 {
    margin-left: calc(8.3333333333% * 4) !important;
  }
  .col-sm-5 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 5) !important;
  }
  .col-offset-sm-5 {
    margin-left: calc(8.3333333333% * 5) !important;
  }
  .col-sm-6 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 6) !important;
  }
  .col-offset-sm-6 {
    margin-left: calc(8.3333333333% * 6) !important;
  }
  .col-sm-7 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 7) !important;
  }
  .col-offset-sm-7 {
    margin-left: calc(8.3333333333% * 7) !important;
  }
  .col-sm-8 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 8) !important;
  }
  .col-offset-sm-8 {
    margin-left: calc(8.3333333333% * 8) !important;
  }
  .col-sm-9 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 9) !important;
  }
  .col-offset-sm-9 {
    margin-left: calc(8.3333333333% * 9) !important;
  }
  .col-sm-10 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 10) !important;
  }
  .col-offset-sm-10 {
    margin-left: calc(8.3333333333% * 10) !important;
  }
  .col-sm-11 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 11) !important;
  }
  .col-offset-sm-11 {
    margin-left: calc(8.3333333333% * 11) !important;
  }
  .col-sm-12 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 12) !important;
  }
  .col-offset-sm-12 {
    margin-left: calc(8.3333333333% * 12) !important;
  }
}
@media screen and (min-wdith: 768px) {
  .col-md-1 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 1) !important;
  }
  .col-offset-md-1 {
    margin-left: calc(8.3333333333% * 1) !important;
  }
  .col-md-2 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 2) !important;
  }
  .col-offset-md-2 {
    margin-left: calc(8.3333333333% * 2) !important;
  }
  .col-md-3 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 3) !important;
  }
  .col-offset-md-3 {
    margin-left: calc(8.3333333333% * 3) !important;
  }
  .col-md-4 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 4) !important;
  }
  .col-offset-md-4 {
    margin-left: calc(8.3333333333% * 4) !important;
  }
  .col-md-5 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 5) !important;
  }
  .col-offset-md-5 {
    margin-left: calc(8.3333333333% * 5) !important;
  }
  .col-md-6 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 6) !important;
  }
  .col-offset-md-6 {
    margin-left: calc(8.3333333333% * 6) !important;
  }
  .col-md-7 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 7) !important;
  }
  .col-offset-md-7 {
    margin-left: calc(8.3333333333% * 7) !important;
  }
  .col-md-8 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 8) !important;
  }
  .col-offset-md-8 {
    margin-left: calc(8.3333333333% * 8) !important;
  }
  .col-md-9 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 9) !important;
  }
  .col-offset-md-9 {
    margin-left: calc(8.3333333333% * 9) !important;
  }
  .col-md-10 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 10) !important;
  }
  .col-offset-md-10 {
    margin-left: calc(8.3333333333% * 10) !important;
  }
  .col-md-11 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 11) !important;
  }
  .col-offset-md-11 {
    margin-left: calc(8.3333333333% * 11) !important;
  }
  .col-md-12 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 12) !important;
  }
  .col-offset-md-12 {
    margin-left: calc(8.3333333333% * 12) !important;
  }
}
@media screen and (min-wdith: 992px) {
  .col-lg-1 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 1) !important;
  }
  .col-offset-lg-1 {
    margin-left: calc(8.3333333333% * 1) !important;
  }
  .col-lg-2 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 2) !important;
  }
  .col-offset-lg-2 {
    margin-left: calc(8.3333333333% * 2) !important;
  }
  .col-lg-3 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 3) !important;
  }
  .col-offset-lg-3 {
    margin-left: calc(8.3333333333% * 3) !important;
  }
  .col-lg-4 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 4) !important;
  }
  .col-offset-lg-4 {
    margin-left: calc(8.3333333333% * 4) !important;
  }
  .col-lg-5 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 5) !important;
  }
  .col-offset-lg-5 {
    margin-left: calc(8.3333333333% * 5) !important;
  }
  .col-lg-6 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 6) !important;
  }
  .col-offset-lg-6 {
    margin-left: calc(8.3333333333% * 6) !important;
  }
  .col-lg-7 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 7) !important;
  }
  .col-offset-lg-7 {
    margin-left: calc(8.3333333333% * 7) !important;
  }
  .col-lg-8 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 8) !important;
  }
  .col-offset-lg-8 {
    margin-left: calc(8.3333333333% * 8) !important;
  }
  .col-lg-9 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 9) !important;
  }
  .col-offset-lg-9 {
    margin-left: calc(8.3333333333% * 9) !important;
  }
  .col-lg-10 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 10) !important;
  }
  .col-offset-lg-10 {
    margin-left: calc(8.3333333333% * 10) !important;
  }
  .col-lg-11 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 11) !important;
  }
  .col-offset-lg-11 {
    margin-left: calc(8.3333333333% * 11) !important;
  }
  .col-lg-12 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 12) !important;
  }
  .col-offset-lg-12 {
    margin-left: calc(8.3333333333% * 12) !important;
  }
}
@media screen and (min-wdith: 1200px) {
  .col-xl-1 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 1) !important;
  }
  .col-offset-xl-1 {
    margin-left: calc(8.3333333333% * 1) !important;
  }
  .col-xl-2 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 2) !important;
  }
  .col-offset-xl-2 {
    margin-left: calc(8.3333333333% * 2) !important;
  }
  .col-xl-3 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 3) !important;
  }
  .col-offset-xl-3 {
    margin-left: calc(8.3333333333% * 3) !important;
  }
  .col-xl-4 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 4) !important;
  }
  .col-offset-xl-4 {
    margin-left: calc(8.3333333333% * 4) !important;
  }
  .col-xl-5 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 5) !important;
  }
  .col-offset-xl-5 {
    margin-left: calc(8.3333333333% * 5) !important;
  }
  .col-xl-6 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 6) !important;
  }
  .col-offset-xl-6 {
    margin-left: calc(8.3333333333% * 6) !important;
  }
  .col-xl-7 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 7) !important;
  }
  .col-offset-xl-7 {
    margin-left: calc(8.3333333333% * 7) !important;
  }
  .col-xl-8 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 8) !important;
  }
  .col-offset-xl-8 {
    margin-left: calc(8.3333333333% * 8) !important;
  }
  .col-xl-9 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 9) !important;
  }
  .col-offset-xl-9 {
    margin-left: calc(8.3333333333% * 9) !important;
  }
  .col-xl-10 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 10) !important;
  }
  .col-offset-xl-10 {
    margin-left: calc(8.3333333333% * 10) !important;
  }
  .col-xl-11 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 11) !important;
  }
  .col-offset-xl-11 {
    margin-left: calc(8.3333333333% * 11) !important;
  }
  .col-xl-12 {
    flex: 0 0 auto;
    padding: 15px;
    width: calc(8.3333333333% * 12) !important;
  }
  .col-offset-xl-12 {
    margin-left: calc(8.3333333333% * 12) !important;
  }
}
.col-1 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 1);
}

.col-offset-1 {
  margin-left: calc(8.3333333333% * 1);
}

.col-2 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 2);
}

.col-offset-2 {
  margin-left: calc(8.3333333333% * 2);
}

.col-3 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 3);
}

.col-offset-3 {
  margin-left: calc(8.3333333333% * 3);
}

.col-4 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 4);
}

.col-offset-4 {
  margin-left: calc(8.3333333333% * 4);
}

.col-5 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 5);
}

.col-offset-5 {
  margin-left: calc(8.3333333333% * 5);
}

.col-6 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 6);
}

.col-offset-6 {
  margin-left: calc(8.3333333333% * 6);
}

.col-7 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 7);
}

.col-offset-7 {
  margin-left: calc(8.3333333333% * 7);
}

.col-8 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 8);
}

.col-offset-8 {
  margin-left: calc(8.3333333333% * 8);
}

.col-9 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 9);
}

.col-offset-9 {
  margin-left: calc(8.3333333333% * 9);
}

.col-10 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 10);
}

.col-offset-10 {
  margin-left: calc(8.3333333333% * 10);
}

.col-11 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 11);
}

.col-offset-11 {
  margin-left: calc(8.3333333333% * 11);
}

.col-12 {
  flex: 0 0 auto;
  padding: 15px;
  width: calc(8.3333333333% * 12);
}

.col-offset-12 {
  margin-left: calc(8.3333333333% * 12);
}

label.v.center {
  display: flex;
  align-items: center;
  height: 100%;
}

.app {
  z-index: 9999999;
}[data-v-c6a65fa3] .p-message-text {
  width: 100%;
}
.version[data-v-c6a65fa3] {
  display: flex;
}
.version .number[data-v-c6a65fa3] {
  padding-right: 10px;
}
.header[data-v-c6a65fa3] {
  display: flex;
  flex-grow: 1;
  flex-basis: 0;
}
.header .title[data-v-c6a65fa3] {
  width: 75%;
}
.header .title span[data-v-c6a65fa3] {
  font-size: 2rem;
}
.header .buttons[data-v-c6a65fa3] {
  width: 25%;
}
.header .buttons .p-button[data-v-c6a65fa3] {
  border: none;
}.col[data-v-95c4d51b] {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}#statsChangelog .p-message {
  background: deeppink;
  color: white;
  padding: 20px;
  border-radius: 6px;
  margin-bottom: 20px;
}
#statsChangelog .p-message .hidden {
  display: none;
}
#statsChangelog .p-message-close-button {
  position: relative;
  top: -40px;
  right: -25px;
}.header[data-v-0857b5ad] {
  font-weight: bold;
  font-size: 1.75rem;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
}
.border-bottom[data-v-0857b5ad] {
  border-bottom: 1px solid #dee2e6 !important;
}
#tblAccuracy th[data-v-0857b5ad] {
  font-weight: bold;
}
#tblAccuracy th[data-v-0857b5ad],
#tblAccuracy td[data-v-0857b5ad] {
  padding: 10px;
}
#tblAccuracy .radicals[data-v-0857b5ad] {
  color: var(--stats-radical);
}
#tblAccuracy .kanji[data-v-0857b5ad] {
  color: var(--stats-kanji);
}
#tblAccuracy .vocab[data-v-0857b5ad] {
  color: var(--stats-vocab);
}.header[data-v-70e4bc14] {
  font-weight: bold;
  font-size: 1.75rem;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
}
#tblUser th[data-v-70e4bc14] {
  font-weight: bold;
}
#tblUser th[data-v-70e4bc14],
#tblUser td[data-v-70e4bc14] {
  padding: 10px;
}.header[data-v-4b4f69f4] {
  text-align: center;
}
.col[data-v-4b4f69f4] {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}.container[data-v-0d6f9005] {
  width: 75vw;
}
.item[data-v-0d6f9005] {
  border: 1px solid gray;
  border-radius: 5px;
  min-width: 35px;
  margin: 2px;
  padding: 5px;
}
.item .slug[data-v-0d6f9005] {
  margin: 5px;
  font-size: 1rem;
  margin: 0;
}
.item.apprentice[data-v-0d6f9005], .item.guru[data-v-0d6f9005], .item.master[data-v-0d6f9005], .item.enlightened[data-v-0d6f9005], .item.burned[data-v-0d6f9005], .item.locked[data-v-0d6f9005], .item.initiate[data-v-0d6f9005] {
  color: white;
}
.item.apprentice[data-v-0d6f9005] {
  background-color: var(--stats-apprentice);
}
.item.apprentice[data-v-0d6f9005]:hover {
  background-color: var(--stats-apprentice);
}
.item.notInWK[data-v-0d6f9005] {
  background-color: #9fdf9f;
}
.item.notInWK[data-v-0d6f9005]:hover {
  background-color: #9fdf9f;
}
.item.guru[data-v-0d6f9005] {
  background-color: var(--stats-guru);
}
.item.guru[data-v-0d6f9005]:hover {
  background-color: var(--stats-guru);
}
.item.master[data-v-0d6f9005] {
  background-color: var(--stats-master);
}
.item.master[data-v-0d6f9005]:hover {
  background-color: var(--stats-master);
}
.item.enlightened[data-v-0d6f9005] {
  background-color: var(--stats-enlightened);
}
.item.enlightened[data-v-0d6f9005]:hover {
  background-color: var(--stats-enlightened);
}
.item.burned[data-v-0d6f9005] {
  background-color: var(--stats-burned);
}
.item.burned[data-v-0d6f9005]:hover {
  background-color: var(--stats-burned);
}
.item.locked[data-v-0d6f9005] {
  background-color: var(--stats-locked);
}
.item.locked[data-v-0d6f9005]:hover {
  background-color: var(--stats-locked);
}
.item.initiate[data-v-0d6f9005] {
  background-color: var(--stats-initiate);
}
.item.initiate[data-v-0d6f9005]:hover {
  background-color: var(--stats-initiate);
}
.poItem .slug[data-v-0d6f9005] {
  font-size: 3rem;
}
.poItem .slug[data-v-0d6f9005] img {
  width: 35px;
}
.itemDetails .item[data-v-0d6f9005] img {
  width: 15px;
  filter: invert(100%);
}
.p-button[data-v-0d6f9005] {
  text-decoration: none;
}
.characters[data-v-0d6f9005] {
  font-size: 4rem;
  color: black;
  text-decoration: none;
}
.characters[data-v-0d6f9005]:hover .p-button-label {
  text-decoration: none;
  color: black;
}.level[data-v-68f88925],
.type[data-v-68f88925] {
  font-weight: bold;
}
.col[data-v-68f88925]:has(.level) {
  padding: 1px;
}
.row[data-v-68f88925]:has(.level) {
  background-color: var(--p-gray-200);
}
.itemDetails[data-v-68f88925] {
  display: flex;
  flex-wrap: wrap;
}[data-v-ad632937] .tooltip {
  max-width: 200px;
}
[data-v-ad632937] .vue-apexcharts .header {
  background-color: lightblue;
  font-weight: bold;
}
.fa-triangle-exclamation[data-v-ad632937] {
  color: var(--p-warning);
}
.header[data-v-ad632937] {
  font-weight: bold;
}
`)

// Apply the stylesheet to a document:
document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];