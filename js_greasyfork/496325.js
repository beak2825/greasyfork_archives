// ==UserScript==
// @name         Symfony 翻译文档 forms.html
// @namespace    fireloong
// @version      0.1.2
// @description  翻译文档 forms.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/forms.html
// @match        https://symfony.com/doc/6.4/forms.html
// @match        https://symfony.com/doc/7.1/forms.html
// @match        https://symfony.com/doc/7.2/forms.html
// @match        https://symfony.com/doc/current/forms.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496325/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20formshtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496325/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20formshtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Forms\n        \n            ': '表单',
        'Do you prefer video tutorials? Check out the Symfony Forms screencast series.': '你更喜欢视频教程吗？请查看 <a href="https://symfonycasts.com/screencast/symfony-forms" class="reference external" rel="external noopener noreferrer" target="_blank">Symfony 表单的屏幕录像系列</a>。',
        'Creating and processing HTML forms is hard and repetitive. You need to deal with\nrendering HTML form fields, validating submitted data, mapping the form data\ninto objects and a lot more. Symfony includes a powerful form feature that\nprovides all these features and many more for truly complex scenarios.': '创建和处理 HTML 表单既困难又重复。你需要处理渲染 HTML 表单字段、验证提交的数据、将表单数据映射到对象等等。Symfony 包括一个强大的表单功能，它为真正复杂的场景提供了所有这些功能以及更多功能。',

        'Installation': '安装',
        'In applications using Symfony Flex, run this command to\ninstall the form feature before using it:': '在使用 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a> 的应用中，请在使用表单功能之前运行此命令来安装它：',

        'Usage': '使用',
        'The recommended workflow when working with Symfony forms is the following:': '使用 Symfony 表单时推荐的工作流程如下：',
        'Build the form in a Symfony controller or using a dedicated form class;': '在 Symfony 控制器中构建表单或使用专门的表单类来<strong>构建表单</strong>；',
        'Render the form in a template so the user can edit and submit it;': '在模板中<strong>渲染表单</strong>，以便用户可以编辑并提交它；',
        'Process the form to validate the submitted data, transform it into PHP\ndata and do something with it (e.g. persist it in a database).': '<strong>处理表单</strong>以验证提交的数据，将其转换为 PHP 数据，并对数据进行处理（例如，将其持久化到数据库中）。',
        'Each of these steps is explained in detail in the next sections. To make\nexamples easier to follow, all of them assume that you\'re building a small Todo\nlist application that displays "tasks".': '接下来的部分将详细解释这些步骤。为了让示例更容易理解，所有这些示例都假设你正在构建一个小型的待办事项列表应用程序，用于显示“任务”。',
        'Users create and edit tasks using Symfony forms. Each task is an instance of the\nfollowing Task class:': '用户使用 Symfony 表单创建和编辑任务。每个任务都是以下 <code translate="no" class="notranslate">Task</code> 类的一个实例：',
        'This class is a "plain-old-PHP-object" because, so far, it has nothing to do\nwith Symfony or any other library. It\'s a normal PHP object that directly solves\na problem inside your application (i.e. the need to represent a task in your\napplication). But you can also edit Doctrine entities in the\nsame way.': '这个类是一个“纯旧的 PHP 对象”，因为它到目前为止与 Symfony 或任何其它库都没有关系。它是一个普通的 PHP 对象，直接解决了你应用程序中的一个问题（即，需要在你的应用程序中表示一个任务）。但你也可以用同样的方式编辑 <a href="doctrine.html" class="reference internal">Doctrine 实体</a>。',

        'Form Types': '表单类型',
        'Before creating your first Symfony form, it\'s important to understand the\nconcept of "form type". In other projects, it\'s common to differentiate between\n"forms" and "form fields". In Symfony, all of them are "form types":' : '在创建你的第一个 Symfony 表单之前，理解“表单类型”的概念是很重要的。在其它项目中，区分“表单”和“表单字段”是很常见的。但在 Symfony 中，它们都是“表单类型”：',
        'a single <input type="text"> form field is a "form type" (e.g. TextType);': '一个单一的 <code translate="no" class="notranslate">&lt;input type="text"&gt;</code> 表单字段是一个“表单类型”（例如，<code translate="no" class="notranslate">TextType</code>）；',
        'a group of several HTML fields used to input a postal address is a "form type"\n(e.g. PostalAddressType);': '用于输入地址的一组多个 HTML 字段是一个“表单类型”（例如，<code translate="no" class="notranslate">PostalAddressType</code>）；',
        'an entire <form> with multiple fields to edit a user profile is a\n"form type" (e.g. UserProfileType).': '一个包含多个字段以编辑用户资料的完整 <code translate="no" class="notranslate">&lt;form&gt;</code> 是一个“表单类型”（例如，<code translate="no" class="notranslate">UserProfileType</code>）。',
        'This may be confusing at first, but it will feel natural to you soon enough.\nBesides, it simplifies code and makes "composing" and "embedding" form fields\nmuch easier to implement.': '这在一开始可能会让人困惑，但你很快就会觉得这是很自然的。此外，它简化了代码，使得“组合”和“嵌入”表单字段的实现变得更加容易。',
        'There are tens of form types provided by Symfony\nand you can also create your own form types.': 'Symfony 提供了数十种<a href="reference/forms/types.html" class="reference internal">表单类型</a>，你还可以<a href="form/create_custom_field_type.html" class="reference internal">创建自己的表单类型</a>。',
        'You can use the debug:form to list all the available types, type\nextensions and type guessers in your application:': '你可以使用 <code translate="no" class="notranslate">debug:form</code> 来列出你应用中所有可用的表单类型、类型扩展和类型猜测器：',

        'Building Forms': '构建表单',
        'Symfony provides a "form builder" object which allows you to describe the form\nfields using a fluent interface. Later, this builder creates the actual form\nobject used to render and process contents.': 'Symfony 提供了一个“表单生成器”对象，它允许你使用流畅接口来描述表单字段。之后，这个生成器会创建实际用于渲染和处理内容的表单对象。',

        'Creating Forms in Controllers': '在控制器中创建表单',
        'If your controller extends from the AbstractController,\nuse the createFormBuilder() helper:': '如果你的控制器继承自 <a href="controller.html#the-base-controller-class-services" class="reference internal">AbstractController</a>，请使用 <code translate="no" class="notranslate">createFormBuilder()</code> 辅助函数：',
        "If your controller does not extend from AbstractController, you'll need to\nfetch services in your controller and\nuse the createBuilder() method of the form.factory service.": '如果你的控制器不是从 <code translate="no" class="notranslate">AbstractController</code> 继承的，你需要<a href="controller.html#controller-accessing-services" class="reference internal">在你的控制器中获取服务</a>，并使用 <code translate="no" class="notranslate">form.factory</code> 服务的 <code translate="no" class="notranslate">createBuilder()</code> 方法。',
         "In this example, you've added two fields to your form - task and dueDate\n- corresponding to the task and dueDate properties of the Task\nclass. You've also assigned each a form type (e.g. TextType\nand DateType), represented by its fully qualified class name. Finally, you\nadded a submit button with a custom label for submitting the form to the server.": '在这个例子中，你已经向表单添加了两个字段 - <code translate="no" class="notranslate">task</code> 和 <code translate="no" class="notranslate">dueDate</code> - 分别对应于 <code translate="no" class="notranslate">Task</code> 类的 <code translate="no" class="notranslate">task</code> 和 <code translate="no" class="notranslate">dueDate</code> 属性。你还为每个字段分配了一个<a href="forms.html#form-types" class="reference internal">表单类型</a>（例如，<code translate="no" class="notranslate">TextType</code> 和 <code translate="no" class="notranslate">DateType</code>），这些类型由其完全限定的类名表示。最后，你添加了一个带有自定义标签的提交按钮，用于将表单提交到服务器。',

        'Creating Form Classes': '创建表单类',
        "Symfony recommends putting as little logic as possible in controllers. That's why\nit's better to move complex forms to dedicated classes instead of defining them\nin controller actions. Besides, forms defined in classes can be reused in\nmultiple actions and services.": 'Symfony 建议在控制器中尽可能少地放置逻辑。这就是为什么将复杂的表单移动到专用类中而不是在控制器操作中定义它们更好的原因。此外，在类中定义的表单可以在多个操作和服务中重用。',
        "Form classes are form types that implement\nFormTypeInterface. However, it's better to\nextend from AbstractType, which already\nimplements the interface and provides some utilities:": '表单类是实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/FormTypeInterface.php" class="reference external" title="Symfony\Component\Form\FormTypeInterface" rel="external noopener noreferrer" target="_blank">FormTypeInterface</a> 的<a href="forms.html#form-types" class="reference internal">表单类型</a>。但是，最好从已经实现了接口并提供了一些实用工具的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/AbstractType.php" class="reference external" title="Symfony\Component\Form\AbstractType" rel="external noopener noreferrer" target="_blank">AbstractType</a> 扩展而来：',
        'Install the MakerBundle in your project to generate form classes using\nthe make:form and make:registration-form commands.': '在你的项目中安装 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a>，以便使用 <code translate="no" class="notranslate">make:form</code> 和 <code translate="no" class="notranslate">make:registration-form</code> 命令生成表单类。',
        'The form class contains all the directions needed to create the task form. In\ncontrollers extending from the AbstractController,\nuse the createForm() helper (otherwise, use the create() method of the\nform.factory service):': '表单类包含了创建任务表单所需的所有指令。在继承自 <a href="controller.html#the-base-controller-class-services" class="reference internal">AbstractController</a> 的控制器中，使用 <code translate="no" class="notranslate">createForm()</code> 辅助函数（否则，使用 <code translate="no" class="notranslate">form.factory</code> 服务的 <code translate="no" class="notranslate">create()</code> 方法）：',
        'Every form needs to know the name of the class that holds the underlying data\n(e.g. App\\Entity\\Task). Usually, this is just guessed based off of the\nobject passed to the second argument to createForm() (i.e. $task).\nLater, when you begin embedding forms, this will no\nlonger be sufficient.': '每个表单都需要知道持有底层数据的类的名称（例如，<code translate="no" class="notranslate">App\\Entity\\Task</code>）。通常，这只是基于传递给 <code translate="no" class="notranslate">createForm()</code> 第二个参数的对象（即 <code translate="no" class="notranslate">$task</code>）来猜测的。稍后，当你开始<a href="form/embedded.html" class="reference internal">嵌入表单</a>时，这将不再足够。',
        "So, while not always necessary, it's generally a good idea to explicitly specify\nthe data_class option by adding the following to your form type class:": '因此，虽然并不总是必要的，但通常在表单类型类中添加以下内容以明确指定 <code translate="no" class="notranslate">data_class</code> 选项是一个好主意：',

        'Rendering Forms': '渲染表单',
        'Now that the form has been created, the next step is to render it:': '现在表单已经创建好了，下一步就是渲染它：',
        'Internally, the render() method calls $form->createView() to\ntransform the form into a form view instance.': '在内部，<code translate="no" class="notranslate">render()</code> 方法调用 <code translate="no" class="notranslate">$form-&gt;createView()</code> 将表单转换为表单视图实例。',
        "Prior to Symfony 6.2, you had to use $this->render(..., ['form' => $form->createView()])\nor the renderForm() method to render the form. The renderForm()\nmethod is deprecated in favor of directly passing the FormInterface\ninstance to render().": '在 Symfony 6.2 之前，你必须使用 <code translate="no" class="notranslate">$this-&gt;render(..., [\'form\' =&gt; $form-&gt;createView()])</code> 或 <code translate="no" class="notranslate">renderForm()</code> 方法来渲染表单。为了直接将 <code translate="no" class="notranslate">FormInterface</code> 实例传递给 <code translate="no" class="notranslate">render()</code>，<code translate="no" class="notranslate">renderForm()</code> 方法已被弃用。',
        'Then, use some form helper functions to\nrender the form contents:': '然后，使用一些<a href="form/form_customization.html#reference-form-twig-functions" class="reference internal">表单辅助函数</a>来渲染表单内容：',
        "That's it! The form() function renders all\nfields and the <form> start and end tags. By default, the form method is\nPOST and the target URL is the same that displayed the form, but\nyou can change both.": '就这样！<a href="form/form_customization.html#reference-forms-twig-form" class="reference internal">form() 函数</a>渲染所有字段以及 <code translate="no" class="notranslate">&lt;form&gt;</code> 开始和结束标签。默认情况下，表单方法是 <code translate="no" class="notranslate">POST</code>，目标 URL 是显示表单的同一个 URL，但<a href="forms.html#forms-change-action-method" class="reference internal">你可以更改这两者</a>。',
        'Notice how the rendered task input field has the value of the task\nproperty from the $task object (i.e. "Write a blog post"). This is the first\njob of a form: to take data from an object and translate it into a format that\'s\nsuitable for being rendered in an HTML form.': '注意渲染的 <code translate="no" class="notranslate">task</code> 输入字段如何具有 <code translate="no" class="notranslate">$task</code> 对象中 <code translate="no" class="notranslate">task</code> 属性的值（即“写博客文章”）。这是表单的第一个工作：从对象中获取数据并将其转换为适合在 HTML 表单中渲染的格式。',
        'The form system is smart enough to access the value of the protected\ntask property via the getTask() and setTask() methods on the\nTask class. Unless a property is public, it must have a "getter" and\n"setter" method so that Symfony can get and put data onto the property. For\na boolean property, you can use an "isser" or "hasser" method (e.g.\nisPublished() or hasReminder()) instead of a getter (e.g.\ngetPublished() or getReminder()).': '表单系统足够智能，可以通过 <code translate="no" class="notranslate">Task</code> 类上的 <code translate="no" class="notranslate">getTask()</code> 和 <code translate="no" class="notranslate">setTask()</code> 方法访问受保护的 <code translate="no" class="notranslate">task</code> 属性的值。除非属性是公开的，否则它必须有“getter”和“setter”方法，以便 Symfony 可以将数据获取和放入属性中。对于布尔属性，你可以使用“isser”或“hasser”方法（例如，<code translate="no" class="notranslate">isPublished()</code> 或 <code translate="no" class="notranslate">hasReminder()</code>）而不是 getter（例如，<code translate="no" class="notranslate">getPublished()</code> 或 <code translate="no" class="notranslate">getReminder()</code>）。',
        "As short as this rendering is, it's not very flexible. Usually, you'll need more\ncontrol about how the entire form or some of its fields look. For example, thanks\nto the Bootstrap 5 integration with Symfony forms you\ncan set this option to generate forms compatible with the Bootstrap 5 CSS framework:": '尽管这种渲染方式很短，但它并不够灵活。通常，你需要更多地控制整个表单或其中一些字段的外观。例如，由于 <a href="form/bootstrap5.html" class="reference internal">Symfony 表单与 Bootstrap 5 的集成</a>，你可以设置此选项以生成与 Bootstrap 5 CSS 框架兼容的表单：',
        'The built-in Symfony form themes include\nBootstrap 3, 4 and 5, Foundation 5 and 6, as well as Tailwind 2. You can also\ncreate your own Symfony form theme.': '<a href="form/form_themes.html#symfony-builtin-forms" class="reference internal">Symfony 内置的表单主题</a>包括 Bootstrap 3、4 和 5，Foundation 5 和 6，以及 Tailwind 2。你也可以<a href="form/form_themes.html#create-your-own-form-theme" class="reference internal">创建自己的 Symfony 表单主题</a>。',
        'In addition to form themes, Symfony allows you to\ncustomize the way fields are rendered with\nmultiple functions to render each field part separately (widgets, labels,\nerrors, help messages, etc.)': '除了表单主题之外，Symfony 还允许你通过多个函数<a href="form/form_customization.html" class="reference internal">自定义字段的渲染方式</a>，这些函数可以分别渲染每个字段部分（小部件、标签、错误、帮助消息等）',

        'Processing Forms': '处理表单',
        'The recommended way of processing forms is to\nuse a single action for both rendering the form and handling the form submit.\nYou can use separate actions, but using one action simplifies everything while\nkeeping the code concise and maintainable.': '<a href="best_practices.html#best-practice-handle-form" class="reference internal">处理表单的推荐方式</a>是在渲染表单和处理表单提交时使用单个操作。你可以使用单独的操作，但使用一个操作可以简化一切，同时保持代码的简洁性和可维护性。',
        'Processing a form means to translate user-submitted data back to the properties\nof an object. To make this happen, the submitted data from the user must be\nwritten into the form object:': '处理表单意味着将用户提交的数据转换回对象的属性。为了实现这一点，用户提交的数据必须写入表单对象：',
        'This controller follows a common pattern for handling forms and has three\npossible paths:': '这个控制器遵循处理表单的常见模式，并有三种可能的路径：',
        "When initially loading the page in a browser, the form hasn't been submitted\nyet and $form->isSubmitted() returns false. So, the form is created\nand rendered;": '当在浏览器中首次加载页面时，表单尚未提交，<code translate="no" class="notranslate">$form-&gt;isSubmitted()</code> 返回 <code translate="no" class="notranslate">false</code>。因此，表单被创建并渲染；',
        'When the user submits the form, handleRequest()\nrecognizes this and immediately writes the submitted data back into the\ntask and dueDate properties of the $task object. Then this object\nis validated (validation is explained in the next section). If it is invalid,\nisValid() returns\nfalse and the form is rendered again, but now with validation errors.': '当用户提交表单时，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/FormInterface.php#:~:text=function%20handleRequest" class="reference external" title="Symfony\Component\Form\FormInterface::handleRequest()" rel="external noopener noreferrer" target="_blank">handleRequest()</a> 会识别到这一点，并立即将提交的数据写回 <code translate="no" class="notranslate">$task</code> 对象的 <code translate="no" class="notranslate">task</code> 和 <code translate="no" class="notranslate">dueDate</code> 属性。然后对这个对象进行验证（验证将在下一节中解释）。如果验证失败，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/FormInterface.php#:~:text=function%20isValid" class="reference external" title="Symfony\Component\Form\FormInterface::isValid()" rel="external noopener noreferrer" target="_blank">isValid()</a> 返回 <code translate="no" class="notranslate">false</code>，表单将再次渲染，但这次会显示验证错误。',
        'By passing $form to the render() method (instead of\n$form->createView()), the response code is automatically set to\nHTTP 422 Unprocessable Content. This ensures compatibility with tools\nrelying on the HTTP specification, like Symfony UX Turbo;': '通过将 <code translate="no" class="notranslate">$form</code> 传递给 <code translate="no" class="notranslate">render()</code> 方法（而不是 <code translate="no" class="notranslate">$form-&gt;createView()</code>），响应代码将自动设置为 <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-422-unprocessable-content" class="reference external" rel="external noopener noreferrer" target="_blank">HTTP 422 Unprocessable Content</a>。这确保了与依赖 HTTP 规范的工具（如 <a href="https://ux.symfony.com/turbo" class="reference external">Symfony UX Turbo</a>）的兼容性；',
        'When the user submits the form with valid data, the submitted data is again\nwritten into the form, but this time isValid()\nreturns true. Now you have the opportunity to perform some actions using\nthe $task object (e.g. persisting it to the database) before redirecting\nthe user to some other page (e.g. a "thank you" or "success" page);': '当用户提交带有有效数据的表单时，提交的数据会再次写入表单，但这次 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/FormInterface.php#:~:text=function%20isValid" class="reference external" title="Symfony\Component\Form\FormInterface::isValid()" rel="external noopener noreferrer" target="_blank">isValid()</a> 返回 <code translate="no" class="notranslate">true</code>。现在你有机会在使用 <code translate="no" class="notranslate">$task</code> 对象执行一些操作（例如，将其持久化到数据库中）之前，将用户重定向到其它页面（例如，“谢谢”或“成功”页面）；',
        'Redirecting a user after a successful form submission is a best practice\nthat prevents the user from being able to hit the "Refresh" button of\ntheir browser and re-post the data.': '在表单成功提交后重定向用户是一种最佳实践，可以防止用户点击浏览器的“刷新”按钮并重新提交数据。',
        'If you need more control over exactly when your form is submitted or which\ndata is passed to it, you can\nuse the submit() method to handle form submissions.': '如果你需要更精确地控制表单的提交时间或传递给它的数据，你可以<a href="form/direct_submit.html" class="reference internal">使用 submit() 方法来处理表单提交</a>。',

        'Validating Forms': '验证表单',
        'In the previous section, you learned how a form can be submitted with valid\nor invalid data. In Symfony, the question isn\'t whether the "form" is valid, but\nwhether or not the underlying object ($task in this example) is valid after\nthe form has applied the submitted data to it. Calling $form->isValid() is a\nshortcut that asks the $task object whether or not it has valid data.': '在上一节中，你学习了表单如何提交有效或无效的数据。在 Symfony 中，问题不在于“表单”是否有效，而在于表单将提交的数据应用到它之后，底层对象（在这个例子中是 <code translate="no" class="notranslate">$task</code>）是否有效。调用 <code translate="no" class="notranslate">$form-&gt;isValid()</code> 是一个快捷方式，它询问 <code translate="no" class="notranslate">$task</code> 对象是否具有有效数据。',
        'Before using validation, add support for it in your application:': '在使用验证之前，请在应用程序中添加对它的支持：',
        'Validation is done by adding a set of rules, called (validation) constraints,\nto a class. You can add them either to the entity class or by using the\nconstraints option of form types.': '通过在类中添加一组规则（称为（验证）约束）来完成验证。你可以将它们添加到实体类中，或者使用表单类型的 <a href="reference/forms/types/form.html#reference-form-option-constraints" class="reference internal">constraints 选项</a>来添加它们。',
        'To see the first approach - adding constraints to the entity - in action,\nadd the validation constraints, so that the task field cannot be empty,\nand the dueDate field cannot be empty, and must be a valid DateTimeImmutable\nobject.': '为了看到第一种方法（将约束添加到实体）的实际操作，添加验证约束，以便 <code translate="no" class="notranslate">task</code> 字段不能为空，<code translate="no" class="notranslate">dueDate</code> 字段也不能为空，并且必须是一个有效的 <code translate="no" class="notranslate">DateTimeImmutable</code> 对象。',
        "That's it! If you re-submit the form with invalid data, you'll see the\ncorresponding errors printed out with the form.": '就这样！如果你用无效的数据重新提交表单，你会看到相应的错误与表单一起打印出来。',
        'To see the second approach - adding constraints to the form - refer to\nthis section. Both approaches can be used together.': '要查看第二种方法（将约束添加到表单），请参考<a href="form/without_class.html#form-option-constraints" class="reference internal">本节</a>。这两种方法可以一起使用。',

        'Other Common Form Features': '其它常见的表单功能',
        'Passing Options to Forms': '向表单传递选项',
        'If you create forms in classes, when building\nthe form in the controller you can pass custom options to it as the third optional\nargument of createForm():': '如果你在<a href="forms.html#creating-forms-in-classes" class="reference internal">类中创建表单</a>，那么在控制器中构建表单时，你可以将自定义选项作为 <code translate="no" class="notranslate">createForm()</code> 的第三个可选参数传递给它：',
        'If you try to use the form now, you\'ll see an error message: The option\n"require_due_date" does not exist. That\'s because forms must declare all the\noptions they accept using the configureOptions() method:': '如果你现在尝试使用表单，你会看到一个错误消息：<em>“require_due_date”选项不存在</em>。这是因为表单必须使用 <code translate="no" class="notranslate">configureOptions()</code> 方法声明它们接受的所有选项：',
        'Now you can use this new form option inside the buildForm() method:': '现在你可以在 <code translate="no" class="notranslate">buildForm()</code> 方法中使用这个新的表单选项：',

        'Form Type Options': '表单类型选项',
        'Each form type has a number of options to configure it, as\nexplained in the Symfony form types reference.\nTwo commonly used options are required and label.': '每个<a href="forms.html#form-types" class="reference internal">表单类型</a>都有一系列配置选项，如 <a href="reference/forms/types.html" class="reference internal">Symfony 表单类型参考</a>中所述。两个常用的选项是 <code translate="no" class="notranslate">required</code> 和 <code translate="no" class="notranslate">label</code>。',

        'The required Option': '<code translate="no" class="notranslate">required</code> 选项',
        'The most common option is the required option, which can be applied to any\nfield. By default, this option is set to true, meaning that HTML5-ready\nbrowsers will require you to fill in all fields before submitting the form.': '最常见的选项是 <code translate="no" class="notranslate">required</code> 选项，它可以应用于任何字段。默认情况下，此选项设置为 <code translate="no" class="notranslate">true</code>，意味着 HTML5 兼容的浏览器将要求你在提交表单之前填写所有字段。',
        "If you don't want this behavior, either\ndisable client-side validation for the\nentire form or set the required option to false on one or more fields:": '如果你不希望这种行为，要么<a href="forms.html#forms-html5-validation-disable" class="reference internal">禁用整个表单的客户端验证</a>，要么将一个或多个字段的 <code translate="no" class="notranslate">required</code> 选项设置为 <code translate="no" class="notranslate">false</code>：',
        "The required option does not perform any server-side validation. If a user\nsubmits a blank value for the field (either with an old browser or a web\nservice, for example), it will be accepted as a valid value unless you also use\nSymfony's NotBlank or NotNull validation constraints.": '<code translate="no" class="notranslate">required</code> 选项不会执行任何服务器端验证。如果用户为字段提交了一个空值（例如，使用旧浏览器或网络服务），那么除非你也使用 Symfony 的 <code translate="no" class="notranslate">NotBlank</code> 或 <code translate="no" class="notranslate">NotNull</code> 验证约束，否则它将被接受为有效值。',

        'The label Option': '<code translate="no" class="notranslate">label</code> 选项',
        'By default, the label of form fields are the humanized version of the\nproperty name (user -> User; postalAddress -> Postal Address).\nSet the label option on fields to define their labels explicitly:': '默认情况下，表单字段的标签是属性名称的人性化版本（<code translate="no" class="notranslate">user</code> -&gt; <code translate="no" class="notranslate">User</code>; <code translate="no" class="notranslate">postalAddress</code> -&gt; <code translate="no" class="notranslate">Postal Address</code>）。在字段上设置 <code translate="no" class="notranslate">label</code> 选项以明确定义它们的标签：',
        'By default, <label> tags of required fields are rendered with a\nrequired CSS class, so you can display an asterisk by applying a CSS style:': '默认情况下，<code translate="no" class="notranslate">&lt;label&gt;</code> 标签的必填字段会使用 <code translate="no" class="notranslate">required</code> CSS 类进行渲染，因此你可以通过应用 CSS 样式来显示星号：',

        'Changing the Action and HTTP Method': '更改操作和 HTTP 方法',
        'By default, the <form> tag is rendered with a method="post" attribute,\nand no action attribute. This means that the form is submitted via an HTTP\nPOST request to the same URL under which it was rendered. When building the form,\nuse the setAction() and setMethod() methods to change this:': '默认情况下，<code translate="no" class="notranslate">&lt;form&gt;</code> 标签使用 <code translate="no" class="notranslate">method="post"</code> 属性渲染，并且没有 <code translate="no" class="notranslate">action</code> 属性。这意味着表单将通过 HTTP POST 请求提交到渲染它的相同 URL。在构建表单时，使用 <code translate="no" class="notranslate">setAction()</code> 和 <code translate="no" class="notranslate">setMethod()</code> 方法来更改这些设置：',
        'When building the form in a class, pass the action and method as form options:': '在类中构建表单时，将 action 和 method 作为表单选项传递：',
        'Finally, you can override the action and method in the template by passing them\nto the form() or the form_start() helper functions:': '最后，你可以通过将它们传递给 <code translate="no" class="notranslate">form()</code> 或 <code translate="no" class="notranslate">form_start()</code> 辅助函数来在模板中覆盖 action 和 method：',
        "If the form's method is not GET or POST, but PUT, PATCH or\nDELETE, Symfony will insert a hidden field with the name _method\nthat stores this method. The form will be submitted in a normal POST\nrequest, but Symfony's routing is capable of detecting the\n_method parameter and will interpret it as a PUT, PATCH or\nDELETE request. The http_method_override\noption must be enabled for this to work.": '如果表单的方法不是 <code translate="no" class="notranslate">GET</code> 或 <code translate="no" class="notranslate">POST</code>，而是 <code translate="no" class="notranslate">PUT</code>、<code translate="no" class="notranslate">PATCH</code> 或 <code translate="no" class="notranslate">DELETE</code>，Symfony 会插入一个名为 <code translate="no" class="notranslate">_method</code> 的隐藏字段来存储该方法。表单将以正常的 <code translate="no" class="notranslate">POST</code> 请求提交，但 <a href="routing.html" class="reference internal">Symfony 的路由</a>能够检测到 <code translate="no" class="notranslate">_method</code> 参数，并将其解释为 <code translate="no" class="notranslate">PUT</code>、<code translate="no" class="notranslate">PATCH</code> 或 <code translate="no" class="notranslate">DELETE</code> 请求。要使这工作，必须启用 <a href="reference/configuration/framework.html#configuration-framework-http_method_override" class="reference internal">http_method_override</a> 选项。',

        'Changing the Form Name': '更改表单名称',
        'If you inspect the HTML contents of the rendered form, you\'ll see that the\n<form> name and the field names are generated from the type class name\n(e.g. <form name="task" ...> and <select name="task[dueDate][date][month]" ...>).': '如果你检查渲染后的表单的 HTML 内容，你会看到 <code translate="no" class="notranslate">&lt;form&gt;</code> 名称和字段名称是从类型类名生成的（例如：<code translate="no" class="notranslate">&lt;form name="task" ...&gt;</code> 和 <code translate="no" class="notranslate">&lt;select name="task[dueDate][date][month]" ...&gt;</code>）。',
        'If you want to modify this, use the createNamed()\nmethod:': '如果你想要修改这个，请使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Form/FormFactoryInterface.php#:~:text=function%20createNamed" class="reference external" title="Symfony\Component\Form\FormFactoryInterface::createNamed()" rel="external noopener noreferrer" target="_blank">createNamed()</a> 方法：',
        'You can even suppress the name completely by setting it to an empty string.': '你甚至可以通过将其设置为空字符串来完全禁用名称。',

        'Client-Side HTML Validation': '客户端 HTML 验证',
        'Thanks to HTML5, many browsers can natively enforce certain validation\nconstraints on the client side. The most common validation is activated by\nadding a required attribute on fields that are required. For browsers\nthat support HTML5, this will result in a native browser message being displayed\nif the user tries to submit the form with that field blank.': '由于 HTML5 的出现，许多浏览器可以在客户端原生地执行某些验证约束。最常见的验证是通过在必需字段上添加 <code translate="no" class="notranslate">required</code> 属性来激活的。对于支持 HTML5 的浏览器，如果用户试图提交表单而该字段为空，则会显示一个原生的浏览器消息。',
        'Generated forms take full advantage of this new feature by adding sensible HTML\nattributes that trigger the validation. The client-side validation, however, can\nbe disabled by adding the novalidate attribute to the <form> tag or\nformnovalidate to the submit tag. This is especially useful when you want to\ntest your server-side validation constraints, but are being prevented by your\nbrowser from, for example, submitting blank fields.': '生成的表单通过添加合理的 HTML 属性来充分利用这一新功能，从而触发验证。然而，可以通过在 <code translate="no" class="notranslate">&lt;form&gt;</code> 标签上添加 <code translate="no" class="notranslate">novalidate</code> 属性或在提交标签上添加 <code translate="no" class="notranslate">formnovalidate</code> 属性来禁用客户端验证。当你想要测试服务器端验证约束，但浏览器阻止你（例如，提交空白字段）时，这特别有用。',

        'Form Type Guessing': '表单类型猜测',
        'If the object handled by the form includes validation constraints, Symfony can\nintrospect that metadata to guess the type of your field.\nIn the above example, Symfony can guess from the validation rules that the\ntask field is a normal TextType field and the dueDate field is a\nDateType field.': '如果表单处理的对象包括验证约束，Symfony 可以检查这些元数据来猜测字段的类型。在上面的示例中，Symfony 可以根据验证规则猜测 <code translate="no" class="notranslate">task</code> 字段是一个普通的 <code translate="no" class="notranslate">TextType</code> 字段，而 <code translate="no" class="notranslate">dueDate</code> 字段是一个 <code translate="no" class="notranslate">DateType</code> 字段。',
        'To enable Symfony\'s "guessing mechanism", omit the second argument to the add() method, or\npass null to it:': '要启用 Symfony 的“猜测机制”，请省略 <code translate="no" class="notranslate">add()</code> 方法的第二个参数，或者向它传递 <code translate="no" class="notranslate">null</code>：',
        'When using a specific form validation group,\nthe field type guesser will still consider all validation constraints when\nguessing your field types (including constraints that are not part of the\nvalidation group(s) being used).': '当使用特定的<a href="form/validation_groups.html" class="reference internal">表单验证组</a>时，字段类型猜测器在猜测字段类型时仍会考虑所有验证约束（包括不属于正在使用的验证组的约束）。',

        'Form Type Options Guessing': '表单类型选项猜测',
        'When the guessing mechanism is enabled for some field, in addition to its form type,\nthe following options will be guessed too:': '当为某些字段启用猜测机制时，除了其表单类型外，还会猜测以下选项：',
        '\n                            The required option is guessed based on the validation rules (i.e. is\nthe field NotBlank or NotNull) or the Doctrine metadata (i.e. is the\nfield nullable). This is very useful, as your client-side validation will\nautomatically match your validation rules.\n                    ': '<code translate="no" class="notranslate">required</code> 选项是根据验证规则（即该字段是否为 <code translate="no" class="notranslate">NotBlank</code> 或 <code translate="no" class="notranslate">NotNull</code>）或 Doctrine 元数据（即该字段是否 <code translate="no" class="notranslate">nullable</code>）来猜测的。这非常有用，因为你的客户端验证将自动匹配你的验证规则。',
        "\n                            If the field is some sort of text field, then the maxlength option attribute\nis guessed from the validation constraints (if Length or Range is used)\nor from the Doctrine metadata (via the field's length).\n                    ": '如果字段是某种文本字段，则 <code translate="no" class="notranslate">maxlength</code> 选项属性会根据验证约束（如果使用了 <code translate="no" class="notranslate">Length</code> 或 <code translate="no" class="notranslate">Range</code>）或 <a href="doctrine.html" class="reference internal">Doctrine</a> 元数据（通过字段的长度）来猜测。',
        "If you'd like to change one of the guessed values, override it in the options field array:": '如果你想要更改其中一个猜测的值，请在选项字段数组中覆盖它：',
        "Besides guessing the form type, Symfony also guesses validation constraints\nif you're using a Doctrine entity. Read Databases and the Doctrine ORM\nguide for more information.": '除了猜测表单类型外，如果你正在使用 Doctrine 实体，Symfony 还会猜测<a href="forms.html#validating-forms" class="reference internal">验证约束</a>。有关更多信息，请参阅<a href="doctrine.html#automatic_object_validation" class="reference internal">数据库和 Doctrine ORM</a> 指南。',

        'Unmapped Fields': '未映射字段',
        'When editing an object via a form, all form fields are considered properties of\nthe object. Any fields on the form that do not exist on the object will cause an\nexception to be thrown.': '通过表单编辑对象时，所有表单字段都被视为对象的属性。表单上任何在对象上不存在的字段都将导致抛出异常。',
        'If you need extra fields in the form that won\'t be stored in the object (for\nexample to add an "I agree with these terms" checkbox), set the mapped\noption to false in those fields:': '如果你需要在表单中添加不会存储在对象中的额外字段（例如，添加一个“我同意这些条款”的复选框），请在这些字段中将 <code translate="no" class="notranslate">mapped</code> 选项设置为 <code translate="no" class="notranslate">false</code>：',
        'These "unmapped fields" can be set and accessed in a controller with:': '这些“未映射字段”可以在控制器中设置和访问，使用：',
        "Additionally, if there are any fields on the form that aren't included in\nthe submitted data, those fields will be explicitly set to null.": '另外，如果表单上有任何字段没有包含在提交的数据中，那么这些字段将明确地被设置为 <code translate="no" class="notranslate">null</code>。',

        'Learn more': '了解更多',
        'When building forms, keep in mind that the first goal of a form is to translate\ndata from an object (Task) to an HTML form so that the user can modify that\ndata. The second goal of a form is to take the data submitted by the user and to\nre-apply it to the object.': '在构建表单时，请记住表单的首要目标是将对象（如 <code translate="no" class="notranslate">Task</code>）的数据转换为 HTML 表单，以便用户可以修改这些数据。表单的第二个目标是获取用户提交的数据，并将其重新应用到对象上。',
        "There's a lot more to learn and a lot of powerful tricks in the Symfony forms:": 'Symfony 表单中还有很多要学习的东西，也有很多强大的技巧：',
        'Reference:': '参考：',
        'Form Types Reference': '<a href="reference/forms/types.html">表单类型参考</a>',
        'Advanced Features:': '高级功能：',
        'How to Upload Files': '<a href="controller/upload_file.html">如何上传文件</a>',
        'How to Implement CSRF Protection': '<a href="security/csrf.html">如何实现 CSRF 保护</a>',
        'How to Access Services or Config from Inside a Form': '<a href="form/form_dependencies.html">如何在表单内部访问服务或配置</a>',
        'How to Create a Custom Form Field Type': '<a href="form/create_custom_field_type.html">如何创建自定义表单字段类型</a>',
        'How to Use Data Transformers': '<a href="form/data_transformers.html">如何使用数据转换器</a>',
        'When and How to Use Data Mappers': '<a href="form/data_mappers.html">何时以及如何使用数据映射器</a>',
        'How to Create a Form Type Extension': '<a href="form/create_form_type_extension.html">如何创建表单类型扩展</a>',
        'Creating a custom Type Guesser': '<a href="form/type_guesser.html">创建自定义类型猜测器</a>',
        'Form Themes and Customization:': '表单主题和自定义：',
        'Bootstrap 4 Form Theme': '<a href="form/bootstrap4.html">Bootstrap 4 表单主题</a>',
        'Bootstrap 5 Form Theme': '<a href="form/bootstrap5.html">Bootstrap 5 表单主题</a>',
        'Tailwind CSS Form Theme': '<a href="form/tailwindcss.html">Tailwind CSS 表单主题</a>',
        'How to Customize Form Rendering': '<a href="form/form_customization.html">如何自定义表单渲染</a>',
        'How to Work with Form Themes': '<a href="form/form_themes.html">如何与表单主题一起工作</a>',
        'Events:': '事件：',
        'Form Events': '<a href="form/events.html">表单事件</a>',
        'How to Dynamically Modify Forms Using Form Events': '<a href="form/dynamic_form_modification.html">如何使用表单事件动态修改表单</a>',
        'Validation:': '验证：',
        'How to Define the Validation Groups to Use': '<a href="form/validation_groups.html">如何定义要使用的验证组</a>',
        'How to Dynamically Configure Form Validation Groups': '<a href="form/validation_group_service_resolver.html">如何动态配置表单验证组</a>',
        'How to Choose Validation Groups Based on the Clicked Button': '<a href="form/button_based_validation.html">如何根据点击的按钮选择验证组</a>',
        'How to Disable the Validation of Submitted Data': '<a href="form/disabling_validation.html">如何禁用提交数据的验证</a>',
        'Misc.:': '杂项：',
        'How to Use the submit() Function to Handle Form Submissions': '<a href="form/direct_submit.html">如何使用 submit() 函数处理表单提交</a>',
        'How to Embed Forms': '<a href="form/embedded.html">如何嵌入表单</a>',
        'How to Embed a Collection of Forms': '<a href="form/form_collections.html">如何嵌入表单集合</a>',
        'How to Reduce Code Duplication with "inherit_data"': '<a href="form/inherit_data_option.html">如何使用"inherit_data"减少代码重复</a>',
        'How to Submit a Form with Multiple Buttons': '<a href="form/multiple_buttons.html">如何使用多个按钮提交表单</a>',
        'How to Unit Test your Forms': '<a href="form/unit_testing.html">如何对你的表单进行单元测试</a>',
        'How to Configure empty Data for a Form Class': '<a href="form/use_empty_data.html">如何为表单类配置空数据</a>',
        'How to Use a Form without a Data Class': '<a href="form/without_class.html">如何在没有数据类的情况下使用表单</a>',
    };

    fanyi(translates, 1, true);
})($);
