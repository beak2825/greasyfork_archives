// ==UserScript==
// @name         新版陕西省专业技术人员继续教育刷课脚本
// @namespace    https://jiaobenmiao.com/
// @version      2.2
// @description  该油猴脚本用于 陕西省专业技术人员继续教育 的辅助看课，脚本功能如下：视频自动播放，自动切换任务点
// @author       脚本喵
// @match        https://*.xidian.edu.cn/*
// @resource     Table  https://www.forestpolice.org/ttf/2.0/table.json
// @connect      autohelper.top
// @connect      localhost
// @icon         https://jiaobenmiao.com/img/logo2.jpg
// @grant        GM_addStyle
// @grant        GM_getResourceText
// @grant        GM_info
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// @run-at       document-start
// @license      MIT
// @noframes
// @downloadURL https://update.greasyfork.org/scripts/550744/%E6%96%B0%E7%89%88%E9%99%95%E8%A5%BF%E7%9C%81%E4%B8%93%E4%B8%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E7%BB%A7%E7%BB%AD%E6%95%99%E8%82%B2%E5%88%B7%E8%AF%BE%E8%84%9A%E6%9C%AC.user.js
// @updateURL https://update.greasyfork.org/scripts/550744/%E6%96%B0%E7%89%88%E9%99%95%E8%A5%BF%E7%9C%81%E4%B8%93%E4%B8%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E7%BB%A7%E7%BB%AD%E6%95%99%E8%82%B2%E5%88%B7%E8%AF%BE%E8%84%9A%E6%9C%AC.meta.js
// ==/UserScript==


(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const l=document.createElement("style");l.textContent=e,document.head.append(l)})(` @charset "UTF-8";.el-affix--fixed{position:fixed}.el-aside{box-sizing:border-box;flex-shrink:0;overflow:auto;width:var(--el-aside-width,300px)}.el-autocomplete{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;position:relative;width:var(--el-input-width)}.el-autocomplete__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-autocomplete__popper.el-popper,.el-autocomplete__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-autocomplete__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-autocomplete-suggestion{border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-autocomplete-suggestion__wrap{box-sizing:border-box;max-height:280px;padding:10px 0}.el-autocomplete-suggestion__list{margin:0;padding:0}.el-autocomplete-suggestion li{color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);line-height:34px;list-style:none;margin:0;overflow:hidden;padding:0 20px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.el-autocomplete-suggestion li.highlighted,.el-autocomplete-suggestion li:hover{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.divider{border-top:1px solid var(--el-color-black);margin-top:6px}.el-autocomplete-suggestion li.divider:last-child{margin-bottom:-6px}.el-autocomplete-suggestion.is-loading li{color:var(--el-text-color-secondary);font-size:20px;height:100px;line-height:100px;text-align:center}.el-autocomplete-suggestion.is-loading li:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-autocomplete-suggestion.is-loading li:hover{background-color:var(--el-bg-color-overlay)}.el-autocomplete-suggestion.is-loading .el-icon-loading{vertical-align:middle}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size-small:24px;--el-avatar-size:40px;align-items:center;background:var(--el-avatar-bg-color);box-sizing:border-box;color:var(--el-avatar-text-color);display:inline-flex;font-size:var(--el-avatar-text-size);height:var(--el-avatar-size);justify-content:center;outline:none;overflow:hidden;text-align:center;width:var(--el-avatar-size)}.el-avatar>img{display:block;height:100%;width:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}.el-backtop{--el-backtop-bg-color:var(--el-bg-color-overlay);--el-backtop-text-color:var(--el-color-primary);--el-backtop-hover-bg-color:var(--el-border-color-extra-light);align-items:center;background-color:var(--el-backtop-bg-color);border-radius:50%;box-shadow:var(--el-box-shadow-lighter);color:var(--el-backtop-text-color);cursor:pointer;display:flex;font-size:20px;height:40px;justify-content:center;position:fixed;width:40px;z-index:5}.el-backtop:hover{background-color:var(--el-backtop-hover-bg-color)}.el-backtop__icon{font-size:20px}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;display:inline-block;position:relative;vertical-align:middle;width:-moz-fit-content;width:fit-content}.el-badge__content{align-items:center;background-color:var(--el-badge-bg-color);border:1px solid var(--el-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;font-size:var(--el-badge-font-size);height:var(--el-badge-size);justify-content:center;padding:0 var(--el-badge-padding);white-space:nowrap}.el-badge__content.is-fixed{position:absolute;right:calc(1px + var(--el-badge-size)/2);top:0;transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{border-radius:50%;height:8px;padding:0;right:0;width:8px}.el-badge__content.is-hide-zero{display:none}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-breadcrumb{font-size:14px;line-height:1}.el-breadcrumb:after,.el-breadcrumb:before{content:"";display:table}.el-breadcrumb:after{clear:both}.el-breadcrumb__separator{color:var(--el-text-color-placeholder);font-weight:700;margin:0 9px}.el-breadcrumb__separator.el-icon{font-weight:400;margin:0 6px}.el-breadcrumb__separator.el-icon svg{vertical-align:middle}.el-breadcrumb__item{align-items:center;display:inline-flex;float:left}.el-breadcrumb__inner{color:var(--el-text-color-regular)}.el-breadcrumb__inner a,.el-breadcrumb__inner.is-link{color:var(--el-text-color-primary);font-weight:700;text-decoration:none;transition:var(--el-transition-color)}.el-breadcrumb__inner a:hover,.el-breadcrumb__inner.is-link:hover{color:var(--el-color-primary);cursor:pointer}.el-breadcrumb__item:last-child .el-breadcrumb__inner,.el-breadcrumb__item:last-child .el-breadcrumb__inner a,.el-breadcrumb__item:last-child .el-breadcrumb__inner a:hover,.el-breadcrumb__item:last-child .el-breadcrumb__inner:hover{color:var(--el-text-color-regular);cursor:text;font-weight:400}.el-breadcrumb__item:last-child .el-breadcrumb__separator{display:none}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{content:"";display:table}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.el-button-group>.el-button:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-bottom-left-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-top-right-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button.is-active,.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-dropdown>.el-button{border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color);border-top-left-radius:0}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-text-color-secondary);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base)}.el-button,.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):active,.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;height:var(--el-button-size)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);padding:12px 19px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;height:var(--el-button-size)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;padding:5px 11px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-calendar{--el-calendar-border:var(--el-table-border,1px solid var(--el-border-color-lighter));--el-calendar-header-border-bottom:var(--el-calendar-border);--el-calendar-selected-bg-color:var(--el-color-primary-light-9);--el-calendar-cell-width:85px;background-color:var(--el-fill-color-blank)}.el-calendar__header{border-bottom:var(--el-calendar-header-border-bottom);display:flex;justify-content:space-between;padding:12px 20px}.el-calendar__title{align-self:center;color:var(--el-text-color)}.el-calendar__body{padding:12px 20px 35px}.el-calendar-table{table-layout:fixed;width:100%}.el-calendar-table thead th{color:var(--el-text-color-regular);font-weight:400;padding:12px 0}.el-calendar-table:not(.is-range) td.next,.el-calendar-table:not(.is-range) td.prev{color:var(--el-text-color-placeholder)}.el-calendar-table td{border-bottom:var(--el-calendar-border);border-right:var(--el-calendar-border);transition:background-color var(--el-transition-duration-fast) ease;vertical-align:top}.el-calendar-table td.is-selected{background-color:var(--el-calendar-selected-bg-color)}.el-calendar-table td.is-today{color:var(--el-color-primary)}.el-calendar-table tr:first-child td{border-top:var(--el-calendar-border)}.el-calendar-table tr td:first-child{border-left:var(--el-calendar-border)}.el-calendar-table tr.el-calendar-table__row--hide-border td{border-top:none}.el-calendar-table .el-calendar-day{box-sizing:border-box;height:var(--el-calendar-cell-width);padding:8px}.el-calendar-table .el-calendar-day:hover{background-color:var(--el-calendar-selected-bg-color);cursor:pointer}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank);background-color:var(--el-card-bg-color);border:1px solid var(--el-card-border-color);border-radius:var(--el-card-border-radius);color:var(--el-text-color-primary);overflow:hidden;transition:var(--el-transition-duration)}.el-card.is-always-shadow,.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-card__body{padding:var(--el-card-padding)}.el-card__footer{border-top:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-carousel__item{display:inline-block;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%}.el-carousel__item,.el-carousel__item.is-active{z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item--card,.el-carousel__item.is-animating{transition:transform .4s ease-in-out}.el-carousel__item--card{width:50%}.el-carousel__item--card.is-in-stage{cursor:pointer;z-index:var(--el-index-normal)}.el-carousel__item--card.is-in-stage.is-hover .el-carousel__mask,.el-carousel__item--card.is-in-stage:hover .el-carousel__mask{opacity:.12}.el-carousel__item--card.is-active{z-index:calc(var(--el-index-normal) + 1)}.el-carousel__item--card-vertical{height:50%;width:100%}.el-carousel__mask{background-color:var(--el-color-white);height:100%;left:0;opacity:.24;position:absolute;top:0;transition:var(--el-transition-duration-fast);width:100%}.el-carousel{--el-carousel-arrow-font-size:12px;--el-carousel-arrow-size:36px;--el-carousel-arrow-background:rgba(31,45,61,.11);--el-carousel-arrow-hover-background:rgba(31,45,61,.23);--el-carousel-indicator-width:30px;--el-carousel-indicator-height:2px;--el-carousel-indicator-padding-horizontal:4px;--el-carousel-indicator-padding-vertical:12px;--el-carousel-indicator-out-color:var(--el-border-color-hover);position:relative}.el-carousel--horizontal,.el-carousel--vertical{overflow:hidden}.el-carousel__container{height:300px;position:relative}.el-carousel__arrow{align-items:center;background-color:var(--el-carousel-arrow-background);border:none;border-radius:50%;color:#fff;cursor:pointer;display:inline-flex;font-size:var(--el-carousel-arrow-font-size);height:var(--el-carousel-arrow-size);justify-content:center;margin:0;outline:none;padding:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);transition:var(--el-transition-duration);width:var(--el-carousel-arrow-size);z-index:10}.el-carousel__arrow--left{left:16px}.el-carousel__arrow--right{right:16px}.el-carousel__arrow:hover{background-color:var(--el-carousel-arrow-hover-background)}.el-carousel__arrow i{cursor:pointer}.el-carousel__indicators{list-style:none;margin:0;padding:0;position:absolute;z-index:calc(var(--el-index-normal) + 1)}.el-carousel__indicators--horizontal{bottom:0;left:50%;transform:translate(-50%)}.el-carousel__indicators--vertical{right:0;top:50%;transform:translateY(-50%)}.el-carousel__indicators--outside{bottom:calc(var(--el-carousel-indicator-height) + var(--el-carousel-indicator-padding-vertical)*2);position:static;text-align:center;transform:none}.el-carousel__indicators--outside .el-carousel__indicator:hover button{opacity:.64}.el-carousel__indicators--outside button{background-color:var(--el-carousel-indicator-out-color);opacity:.24}.el-carousel__indicators--right{right:0}.el-carousel__indicators--labels{left:0;right:0;text-align:center;transform:none}.el-carousel__indicators--labels .el-carousel__button{color:#000;font-size:12px;height:auto;padding:2px 18px;width:auto}.el-carousel__indicators--labels .el-carousel__indicator{padding:6px 4px}.el-carousel__indicator{background-color:transparent;cursor:pointer}.el-carousel__indicator:hover button{opacity:.72}.el-carousel__indicator--horizontal{display:inline-block;padding:var(--el-carousel-indicator-padding-vertical) var(--el-carousel-indicator-padding-horizontal)}.el-carousel__indicator--vertical{padding:var(--el-carousel-indicator-padding-horizontal) var(--el-carousel-indicator-padding-vertical)}.el-carousel__indicator--vertical .el-carousel__button{height:calc(var(--el-carousel-indicator-width)/2);width:var(--el-carousel-indicator-height)}.el-carousel__indicator.is-active button{opacity:1}.el-carousel__button{background-color:#fff;border:none;cursor:pointer;display:block;height:var(--el-carousel-indicator-height);margin:0;opacity:.48;outline:none;padding:0;transition:var(--el-transition-duration);width:var(--el-carousel-indicator-width)}.carousel-arrow-left-enter-from,.carousel-arrow-left-leave-active{opacity:0;transform:translateY(-50%) translate(-10px)}.carousel-arrow-right-enter-from,.carousel-arrow-right-leave-active{opacity:0;transform:translateY(-50%) translate(10px)}.el-transitioning{filter:url(#elCarouselHorizontal)}.el-transitioning-vertical{filter:url(#elCarouselVertical)}.el-cascader-panel{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);border-radius:var(--el-cascader-menu-radius);display:flex;font-size:var(--el-cascader-menu-font-size)}.el-cascader-panel.is-bordered{border:var(--el-cascader-menu-border);border-radius:var(--el-cascader-menu-radius)}.el-cascader-menu{border-right:var(--el-cascader-menu-border);box-sizing:border-box;color:var(--el-cascader-menu-text-color);min-width:180px}.el-cascader-menu:last-child{border-right:none}.el-cascader-menu:last-child .el-cascader-node{padding-right:20px}.el-cascader-menu__wrap.el-scrollbar__wrap{height:204px}.el-cascader-menu__list{box-sizing:border-box;list-style:none;margin:0;min-height:100%;padding:6px 0;position:relative}.el-cascader-menu__hover-zone{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.el-cascader-menu__empty-text{align-items:center;color:var(--el-cascader-color-empty);display:flex;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.el-cascader-menu__empty-text .is-loading{margin-right:2px}.el-cascader-node{align-items:center;display:flex;height:34px;line-height:34px;outline:none;padding:0 30px 0 20px;position:relative}.el-cascader-node.is-selectable.in-active-path{color:var(--el-cascader-menu-text-color)}.el-cascader-node.in-active-path,.el-cascader-node.is-active,.el-cascader-node.is-selectable.in-checked-path{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader-node:not(.is-disabled){cursor:pointer}.el-cascader-node:not(.is-disabled):focus,.el-cascader-node:not(.is-disabled):hover{background:var(--el-cascader-node-background-hover)}.el-cascader-node.is-disabled{color:var(--el-cascader-node-color-disabled);cursor:not-allowed}.el-cascader-node__prefix{left:10px;position:absolute}.el-cascader-node__postfix{position:absolute;right:10px}.el-cascader-node__label{flex:1;overflow:hidden;padding:0 8px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.el-cascader-node>.el-checkbox,.el-cascader-node>.el-radio{margin-right:0}.el-cascader-node>.el-radio .el-radio__label{padding-left:0}.el-cascader{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);display:inline-block;font-size:var(--el-font-size-base);line-height:32px;outline:none;position:relative;vertical-align:middle}.el-cascader:not(.is-disabled):hover .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset;cursor:pointer}.el-cascader .el-input{cursor:pointer;display:flex}.el-cascader .el-input .el-input__inner{cursor:pointer;text-overflow:ellipsis}.el-cascader .el-input .el-input__suffix-inner .el-icon svg{vertical-align:middle}.el-cascader .el-input .icon-arrow-down{font-size:14px;transition:transform var(--el-transition-duration)}.el-cascader .el-input .icon-arrow-down.is-reverse{transform:rotate(180deg)}.el-cascader .el-input .icon-circle-close:hover{color:var(--el-input-clear-hover-color,var(--el-text-color-secondary))}.el-cascader .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-cascader--large{font-size:14px;line-height:40px}.el-cascader--large .el-cascader__tags{gap:6px;padding:8px}.el-cascader--large .el-cascader__search-input{height:24px;margin-left:7px}.el-cascader--small{font-size:12px;line-height:24px}.el-cascader--small .el-cascader__tags{gap:4px;padding:2px}.el-cascader--small .el-cascader__search-input{height:20px;margin-left:5px}.el-cascader.is-disabled .el-cascader__label{color:var(--el-disabled-text-color);z-index:calc(var(--el-index-normal) + 1)}.el-cascader__dropdown{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);border-radius:var(--el-cascader-menu-radius);font-size:var(--el-cascader-menu-font-size)}.el-cascader__dropdown.el-popper{background:var(--el-cascader-menu-fill)}.el-cascader__dropdown.el-popper,.el-cascader__dropdown.el-popper .el-popper__arrow:before{border:var(--el-cascader-menu-border)}.el-cascader__dropdown.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper{box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__tags{box-sizing:border-box;display:flex;flex-wrap:wrap;gap:6px;left:0;line-height:normal;padding:4px;position:absolute;right:30px;text-align:left;top:50%;transform:translateY(-50%)}.el-cascader__tags .el-tag{align-items:center;background:var(--el-cascader-tag-background);display:inline-flex;max-width:100%;text-overflow:ellipsis}.el-cascader__tags .el-tag.el-tag--dark,.el-cascader__tags .el-tag.el-tag--plain{background-color:var(--el-tag-bg-color)}.el-cascader__tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__tags .el-tag:not(.is-hit).el-tag--dark,.el-cascader__tags .el-tag:not(.is-hit).el-tag--plain{border-color:var(--el-tag-border-color)}.el-cascader__tags .el-tag>span{flex:1;line-height:normal;overflow:hidden;text-overflow:ellipsis}.el-cascader__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);color:var(--el-color-white);flex:none}.el-cascader__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__tags .el-tag+input{margin-left:0}.el-cascader__tags.is-validate{right:55px}.el-cascader__collapse-tags{white-space:normal;z-index:var(--el-index-normal)}.el-cascader__collapse-tags .el-tag{align-items:center;background:var(--el-fill-color);display:inline-flex;max-width:100%;text-overflow:ellipsis}.el-cascader__collapse-tags .el-tag.el-tag--dark,.el-cascader__collapse-tags .el-tag.el-tag--plain{background-color:var(--el-tag-bg-color)}.el-cascader__collapse-tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__collapse-tags .el-tag:not(.is-hit).el-tag--dark,.el-cascader__collapse-tags .el-tag:not(.is-hit).el-tag--plain{border-color:var(--el-tag-border-color)}.el-cascader__collapse-tags .el-tag>span{flex:1;line-height:normal;overflow:hidden;text-overflow:ellipsis}.el-cascader__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);color:var(--el-color-white);flex:none}.el-cascader__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__collapse-tags .el-tag+input{margin-left:0}.el-cascader__collapse-tags .el-tag{margin:2px 0}.el-cascader__suggestion-panel{border-radius:var(--el-cascader-menu-radius)}.el-cascader__suggestion-list{color:var(--el-cascader-menu-text-color);font-size:var(--el-font-size-base);margin:0;max-height:204px;padding:6px 0;text-align:center}.el-cascader__suggestion-item{align-items:center;cursor:pointer;display:flex;height:34px;justify-content:space-between;outline:none;padding:0 15px;text-align:left}.el-cascader__suggestion-item:focus,.el-cascader__suggestion-item:hover{background:var(--el-cascader-node-background-hover)}.el-cascader__suggestion-item.is-checked{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader__suggestion-item>span{margin-right:10px}.el-cascader__empty-text{color:var(--el-cascader-color-empty);margin:10px 0}.el-cascader__search-input{background:transparent;border:none;box-sizing:border-box;color:var(--el-cascader-menu-text-color);flex:1;height:24px;margin-left:7px;min-width:60px;outline:none;padding:0}.el-cascader__search-input::-moz-placeholder{color:transparent}.el-cascader__search-input::placeholder{color:transparent}.el-check-tag{background-color:var(--el-color-info-light-9);border-radius:var(--el-border-radius-base);color:var(--el-color-info);cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);font-weight:700;line-height:var(--el-font-size-base);padding:7px 15px;transition:var(--el-transition-all)}.el-check-tag:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.el-check-tag--primary.is-checked{background-color:var(--el-color-primary-light-8);color:var(--el-color-primary)}.el-check-tag.el-check-tag--primary.is-checked:hover{background-color:var(--el-color-primary-light-7)}.el-check-tag.el-check-tag--primary.is-checked.is-disabled{background-color:var(--el-color-primary-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--primary.is-checked.is-disabled:hover{background-color:var(--el-color-primary-light-8)}.el-check-tag.el-check-tag--primary.is-disabled{background-color:var(--el-color-info-light-9);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--primary.is-disabled:hover{background-color:var(--el-color-info-light-9)}.el-check-tag.el-check-tag--success.is-checked{background-color:var(--el-color-success-light-8);color:var(--el-color-success)}.el-check-tag.el-check-tag--success.is-checked:hover{background-color:var(--el-color-success-light-7)}.el-check-tag.el-check-tag--success.is-checked.is-disabled{background-color:var(--el-color-success-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--success.is-checked.is-disabled:hover{background-color:var(--el-color-success-light-8)}.el-check-tag.el-check-tag--success.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--success.is-disabled,.el-check-tag.el-check-tag--success.is-disabled:hover{background-color:var(--el-color-success-light-9)}.el-check-tag.el-check-tag--warning.is-checked{background-color:var(--el-color-warning-light-8);color:var(--el-color-warning)}.el-check-tag.el-check-tag--warning.is-checked:hover{background-color:var(--el-color-warning-light-7)}.el-check-tag.el-check-tag--warning.is-checked.is-disabled{background-color:var(--el-color-warning-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--warning.is-checked.is-disabled:hover{background-color:var(--el-color-warning-light-8)}.el-check-tag.el-check-tag--warning.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--warning.is-disabled,.el-check-tag.el-check-tag--warning.is-disabled:hover{background-color:var(--el-color-warning-light-9)}.el-check-tag.el-check-tag--danger.is-checked{background-color:var(--el-color-danger-light-8);color:var(--el-color-danger)}.el-check-tag.el-check-tag--danger.is-checked:hover{background-color:var(--el-color-danger-light-7)}.el-check-tag.el-check-tag--danger.is-checked.is-disabled{background-color:var(--el-color-danger-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--danger.is-checked.is-disabled:hover{background-color:var(--el-color-danger-light-8)}.el-check-tag.el-check-tag--danger.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--danger.is-disabled,.el-check-tag.el-check-tag--danger.is-disabled:hover{background-color:var(--el-color-danger-light-9)}.el-check-tag.el-check-tag--error.is-checked{background-color:var(--el-color-error-light-8);color:var(--el-color-error)}.el-check-tag.el-check-tag--error.is-checked:hover{background-color:var(--el-color-error-light-7)}.el-check-tag.el-check-tag--error.is-checked.is-disabled{background-color:var(--el-color-error-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--error.is-checked.is-disabled:hover{background-color:var(--el-color-error-light-8)}.el-check-tag.el-check-tag--error.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--error.is-disabled,.el-check-tag.el-check-tag--error.is-disabled:hover{background-color:var(--el-color-error-light-9)}.el-check-tag.el-check-tag--info.is-checked{background-color:var(--el-color-info-light-8);color:var(--el-color-info)}.el-check-tag.el-check-tag--info.is-checked:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.el-check-tag--info.is-checked.is-disabled{background-color:var(--el-color-info-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--info.is-checked.is-disabled:hover{background-color:var(--el-color-info-light-8)}.el-check-tag.el-check-tag--info.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--info.is-disabled,.el-check-tag.el-check-tag--info.is-disabled:hover{background-color:var(--el-color-info-light-9)}.el-checkbox-button{--el-checkbox-button-checked-bg-color:var(--el-color-primary);--el-checkbox-button-checked-text-color:var(--el-color-white);--el-checkbox-button-checked-border-color:var(--el-color-primary);display:inline-block;position:relative}.el-checkbox-button__inner{-webkit-appearance:none;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left-color:transparent;border-radius:0;box-sizing:border-box;color:var(--el-button-text-color,var(--el-text-color-regular));cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);line-height:1;margin:0;outline:none;padding:8px 15px;position:relative;text-align:center;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-checkbox-button__inner.is-round{padding:8px 15px}.el-checkbox-button__inner:hover{color:var(--el-color-primary)}.el-checkbox-button__inner [class*=el-icon-]{line-height:.9}.el-checkbox-button__inner [class*=el-icon-]+span{margin-left:5px}.el-checkbox-button__original{margin:0;opacity:0;outline:none;position:absolute;z-index:-1}.el-checkbox-button.is-checked .el-checkbox-button__inner{background-color:var(--el-checkbox-button-checked-bg-color);border-color:var(--el-checkbox-button-checked-border-color);box-shadow:-1px 0 0 0 var(--el-color-primary-light-7);color:var(--el-checkbox-button-checked-text-color)}.el-checkbox-button.is-checked:first-child .el-checkbox-button__inner{border-left-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button.is-disabled .el-checkbox-button__inner{background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));background-image:none;border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none;color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox-button.is-disabled:first-child .el-checkbox-button__inner{border-left-color:var(--el-button-disabled-border-color,var(--el-border-color-light))}.el-checkbox-button:first-child .el-checkbox-button__inner{border-bottom-left-radius:var(--el-border-radius-base);border-left:var(--el-border);border-top-left-radius:var(--el-border-radius-base);box-shadow:none!important}.el-checkbox-button.is-focus .el-checkbox-button__inner{border-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button:last-child .el-checkbox-button__inner{border-bottom-right-radius:var(--el-border-radius-base);border-top-right-radius:var(--el-border-radius-base)}.el-checkbox-button--large .el-checkbox-button__inner{border-radius:0;font-size:var(--el-font-size-base);padding:12px 19px}.el-checkbox-button--large .el-checkbox-button__inner.is-round{padding:12px 19px}.el-checkbox-button--small .el-checkbox-button__inner{border-radius:0;font-size:12px;padding:5px 11px}.el-checkbox-button--small .el-checkbox-button__inner.is-round{padding:5px 11px}.el-checkbox-group{font-size:0;line-height:0}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{flex:0 0 0%;max-width:0}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-1,.el-col-1.is-guttered{display:block}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-2,.el-col-2.is-guttered{display:block}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-3,.el-col-3.is-guttered{display:block}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-4,.el-col-4.is-guttered{display:block}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-5,.el-col-5.is-guttered{display:block}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-6,.el-col-6.is-guttered{display:block}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-7,.el-col-7.is-guttered{display:block}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-8,.el-col-8.is-guttered{display:block}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-9,.el-col-9.is-guttered{display:block}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-10,.el-col-10.is-guttered{display:block}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-11,.el-col-11.is-guttered{display:block}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-12,.el-col-12.is-guttered{display:block}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-13,.el-col-13.is-guttered{display:block}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-14,.el-col-14.is-guttered{display:block}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-15,.el-col-15.is-guttered{display:block}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-16,.el-col-16.is-guttered{display:block}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-17,.el-col-17.is-guttered{display:block}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-18,.el-col-18.is-guttered{display:block}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-19,.el-col-19.is-guttered{display:block}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-20,.el-col-20.is-guttered{display:block}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-21,.el-col-21.is-guttered{display:block}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-22,.el-col-22.is-guttered{display:block}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-23,.el-col-23.is-guttered{display:block}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-24,.el-col-24.is-guttered{display:block}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0{display:none;flex:0 0 0%;max-width:0}.el-col-xs-0.is-guttered{display:none}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-1,.el-col-xs-1.is-guttered{display:block}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-2,.el-col-xs-2.is-guttered{display:block}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xs-3,.el-col-xs-3.is-guttered{display:block}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-4,.el-col-xs-4.is-guttered{display:block}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-5,.el-col-xs-5.is-guttered{display:block}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{flex:0 0 25%;max-width:25%}.el-col-xs-6,.el-col-xs-6.is-guttered{display:block}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-7,.el-col-xs-7.is-guttered{display:block}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-8,.el-col-xs-8.is-guttered{display:block}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xs-9,.el-col-xs-9.is-guttered{display:block}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-10.is-guttered{display:block}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-11.is-guttered{display:block}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-12.is-guttered{display:block}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-13.is-guttered{display:block}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-14.is-guttered{display:block}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-15.is-guttered{display:block}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-16.is-guttered{display:block}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-17.is-guttered{display:block}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-18.is-guttered{display:block}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-19.is-guttered{display:block}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-20.is-guttered{display:block}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-21.is-guttered{display:block}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-22.is-guttered{display:block}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-23.is-guttered{display:block}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-24.is-guttered{display:block}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0{display:none;flex:0 0 0%;max-width:0}.el-col-sm-0.is-guttered{display:none}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-1,.el-col-sm-1.is-guttered{display:block}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-2,.el-col-sm-2.is-guttered{display:block}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{flex:0 0 12.5%;max-width:12.5%}.el-col-sm-3,.el-col-sm-3.is-guttered{display:block}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-4,.el-col-sm-4.is-guttered{display:block}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-5,.el-col-sm-5.is-guttered{display:block}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{flex:0 0 25%;max-width:25%}.el-col-sm-6,.el-col-sm-6.is-guttered{display:block}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-7,.el-col-sm-7.is-guttered{display:block}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-8,.el-col-sm-8.is-guttered{display:block}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{flex:0 0 37.5%;max-width:37.5%}.el-col-sm-9,.el-col-sm-9.is-guttered{display:block}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-10.is-guttered{display:block}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-11.is-guttered{display:block}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-12.is-guttered{display:block}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-13.is-guttered{display:block}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-14.is-guttered{display:block}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-15.is-guttered{display:block}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-16.is-guttered{display:block}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-17.is-guttered{display:block}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-18.is-guttered{display:block}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-19.is-guttered{display:block}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-20.is-guttered{display:block}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-21.is-guttered{display:block}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-22.is-guttered{display:block}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-23.is-guttered{display:block}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-24.is-guttered{display:block}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0{display:none;flex:0 0 0%;max-width:0}.el-col-md-0.is-guttered{display:none}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-1,.el-col-md-1.is-guttered{display:block}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-2,.el-col-md-2.is-guttered{display:block}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{flex:0 0 12.5%;max-width:12.5%}.el-col-md-3,.el-col-md-3.is-guttered{display:block}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-4,.el-col-md-4.is-guttered{display:block}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-5,.el-col-md-5.is-guttered{display:block}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{flex:0 0 25%;max-width:25%}.el-col-md-6,.el-col-md-6.is-guttered{display:block}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-7,.el-col-md-7.is-guttered{display:block}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-8,.el-col-md-8.is-guttered{display:block}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{flex:0 0 37.5%;max-width:37.5%}.el-col-md-9,.el-col-md-9.is-guttered{display:block}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-10.is-guttered{display:block}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-11.is-guttered{display:block}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-12.is-guttered{display:block}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-13.is-guttered{display:block}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-14.is-guttered{display:block}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-15.is-guttered{display:block}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-16.is-guttered{display:block}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-17.is-guttered{display:block}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-18.is-guttered{display:block}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-19.is-guttered{display:block}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-20.is-guttered{display:block}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-21.is-guttered{display:block}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-22.is-guttered{display:block}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-23.is-guttered{display:block}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-24.is-guttered{display:block}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none;flex:0 0 0%;max-width:0}.el-col-lg-0.is-guttered{display:none}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-1,.el-col-lg-1.is-guttered{display:block}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-2,.el-col-lg-2.is-guttered{display:block}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{flex:0 0 12.5%;max-width:12.5%}.el-col-lg-3,.el-col-lg-3.is-guttered{display:block}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-4,.el-col-lg-4.is-guttered{display:block}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-5,.el-col-lg-5.is-guttered{display:block}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{flex:0 0 25%;max-width:25%}.el-col-lg-6,.el-col-lg-6.is-guttered{display:block}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-7,.el-col-lg-7.is-guttered{display:block}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-8,.el-col-lg-8.is-guttered{display:block}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{flex:0 0 37.5%;max-width:37.5%}.el-col-lg-9,.el-col-lg-9.is-guttered{display:block}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-10.is-guttered{display:block}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-11.is-guttered{display:block}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-12.is-guttered{display:block}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-13.is-guttered{display:block}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-14.is-guttered{display:block}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-15.is-guttered{display:block}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-16.is-guttered{display:block}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-17.is-guttered{display:block}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-18.is-guttered{display:block}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-19.is-guttered{display:block}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-20.is-guttered{display:block}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-21.is-guttered{display:block}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-22.is-guttered{display:block}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-23.is-guttered{display:block}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-24.is-guttered{display:block}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none;flex:0 0 0%;max-width:0}.el-col-xl-0.is-guttered{display:none}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-1,.el-col-xl-1.is-guttered{display:block}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-2,.el-col-xl-2.is-guttered{display:block}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xl-3,.el-col-xl-3.is-guttered{display:block}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-4,.el-col-xl-4.is-guttered{display:block}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-5,.el-col-xl-5.is-guttered{display:block}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{flex:0 0 25%;max-width:25%}.el-col-xl-6,.el-col-xl-6.is-guttered{display:block}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-7,.el-col-xl-7.is-guttered{display:block}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-8,.el-col-xl-8.is-guttered{display:block}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xl-9,.el-col-xl-9.is-guttered{display:block}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-10.is-guttered{display:block}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-11.is-guttered{display:block}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-12.is-guttered{display:block}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-13.is-guttered{display:block}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-14.is-guttered{display:block}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-15.is-guttered{display:block}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-16.is-guttered{display:block}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-17.is-guttered{display:block}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-18.is-guttered{display:block}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-19.is-guttered{display:block}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-20.is-guttered{display:block}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-21.is-guttered{display:block}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-22.is-guttered{display:block}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-23.is-guttered{display:block}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-24.is-guttered{display:block}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;margin:0 8px 0 auto;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{border-radius:4px;cursor:pointer;height:20px;margin:0 0 8px 8px;width:20px}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{border-radius:3px;display:flex;height:100%}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{background-color:red;box-sizing:border-box;float:right;height:12px;padding:0 2px;position:relative;width:280px}.el-color-hue-slider__bar{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);height:100%;position:relative}.el-color-hue-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-hue-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-hue-slider.is-vertical{height:180px;padding:2px 0;width:12px}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-svpanel{height:180px;position:relative;width:280px}.el-color-svpanel__black,.el-color-svpanel__white{bottom:0;left:0;position:absolute;right:0;top:0}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,#fff0)}.el-color-svpanel__black{background:linear-gradient(0deg,#000,#0000)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}.el-color-alpha-slider{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px;box-sizing:border-box;height:12px;position:relative;width:280px}.el-color-alpha-slider__bar{background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%;position:relative}.el-color-alpha-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-alpha-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-alpha-slider.is-vertical{height:180px;width:20px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,#fff0 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{clear:both;content:"";display:table}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{color:#000;float:left;font-size:12px;line-height:26px;width:160px}.el-color-picker{display:inline-block;line-height:normal;outline:none;position:relative}.el-color-picker:hover:not(.is-disabled,.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{background-color:#ffffffb3;border-radius:4px;cursor:not-allowed;height:30px;left:1px;position:absolute;top:1px;width:30px;z-index:1}.el-color-picker__trigger{align-items:center;border:1px solid var(--el-border-color);border-radius:4px;box-sizing:border-box;cursor:pointer;display:inline-flex;font-size:0;height:32px;justify-content:center;padding:4px;position:relative;width:32px}.el-color-picker__color{border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);box-sizing:border-box;display:block;height:100%;position:relative;text-align:center;width:100%}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px}.el-color-picker__color-inner{align-items:center;display:inline-flex;height:100%;justify-content:center;width:100%}.el-color-picker .el-color-picker__empty{color:var(--el-text-color-secondary);font-size:12px}.el-color-picker .el-color-picker__icon{align-items:center;color:#fff;display:inline-flex;font-size:12px;justify-content:center}.el-color-picker__panel{background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light);box-sizing:content-box;padding:6px;position:absolute;z-index:10}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-container{box-sizing:border-box;display:flex;flex:1;flex-basis:auto;flex-direction:row;min-width:0}.el-container.is-vertical{flex-direction:column}.el-date-table{font-size:12px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-date-table.is-week-mode .el-date-table__row:hover .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table.is-week-mode .el-date-table__row:hover td.available:hover{color:var(--el-datepicker-text-color)}.el-date-table.is-week-mode .el-date-table__row:hover td:first-child .el-date-table-cell{border-bottom-left-radius:15px;border-top-left-radius:15px;margin-left:5px}.el-date-table.is-week-mode .el-date-table__row:hover td:last-child .el-date-table-cell{border-bottom-right-radius:15px;border-top-right-radius:15px;margin-right:5px}.el-date-table.is-week-mode .el-date-table__row.current .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td{box-sizing:border-box;cursor:pointer;height:30px;padding:4px 0;position:relative;text-align:center;width:32px}.el-date-table td .el-date-table-cell{box-sizing:border-box;height:30px;padding:3px 0}.el-date-table td .el-date-table-cell .el-date-table-cell__text{border-radius:50%;display:block;height:24px;left:50%;line-height:24px;margin:0 auto;position:absolute;transform:translate(-50%);width:24px}.el-date-table td.next-month,.el-date-table td.prev-month{color:var(--el-datepicker-off-text-color)}.el-date-table td.today{position:relative}.el-date-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-date-table td.today.end-date .el-date-table-cell__text,.el-date-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-date-table td.available:hover{color:var(--el-datepicker-hover-text-color)}.el-date-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff}.el-date-table td.current:not(.disabled):focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-date-table td.end-date .el-date-table-cell,.el-date-table td.start-date .el-date-table-cell{color:#fff}.el-date-table td.end-date .el-date-table-cell__text,.el-date-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color)}.el-date-table td.start-date .el-date-table-cell{border-bottom-left-radius:15px;border-top-left-radius:15px;margin-left:5px}.el-date-table td.end-date .el-date-table-cell{border-bottom-right-radius:15px;border-top-right-radius:15px;margin-right:5px}.el-date-table td.disabled .el-date-table-cell{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed;opacity:1}.el-date-table td.selected .el-date-table-cell{border-radius:15px;margin-left:5px;margin-right:5px}.el-date-table td.selected .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);border-radius:15px;color:#fff}.el-date-table td.week{color:var(--el-datepicker-header-text-color);font-size:80%}.el-date-table td:focus{outline:none}.el-date-table th{border-bottom:1px solid var(--el-border-color-lighter);color:var(--el-datepicker-header-text-color);font-weight:400;padding:5px}.el-month-table{border-collapse:collapse;font-size:12px;margin:-1px}.el-month-table td{cursor:pointer;padding:8px 0;position:relative;text-align:center;width:68px}.el-month-table td .el-date-table-cell{box-sizing:border-box;height:48px;padding:6px 0}.el-month-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-month-table td.today.end-date .el-date-table-cell__text,.el-month-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-month-table td.disabled .el-date-table-cell__text{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-month-table td.disabled .el-date-table-cell__text:hover{color:var(--el-text-color-placeholder)}.el-month-table td .el-date-table-cell__text{border-radius:18px;color:var(--el-datepicker-text-color);display:block;height:36px;left:50%;line-height:36px;margin:0 auto;position:absolute;transform:translate(-50%);width:54px}.el-month-table td .el-date-table-cell__text:hover{color:var(--el-datepicker-hover-text-color)}.el-month-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-month-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-month-table td.end-date .el-date-table-cell,.el-month-table td.start-date .el-date-table-cell{color:#fff}.el-month-table td.end-date .el-date-table-cell__text,.el-month-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff}.el-month-table td.start-date .el-date-table-cell{border-bottom-left-radius:24px;border-top-left-radius:24px;margin-left:3px}.el-month-table td.end-date .el-date-table-cell{border-bottom-right-radius:24px;border-top-right-radius:24px;margin-right:3px}.el-month-table td.current:not(.disabled) .el-date-table-cell{border-radius:24px;margin-left:3px;margin-right:3px}.el-month-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff}.el-month-table td:focus-visible{outline:none}.el-month-table td:focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-year-table{border-collapse:collapse;font-size:12px;margin:-1px}.el-year-table .el-icon{color:var(--el-datepicker-icon-color)}.el-year-table td{cursor:pointer;padding:8px 0;position:relative;text-align:center;width:68px}.el-year-table td .el-date-table-cell{box-sizing:border-box;height:48px;padding:6px 0}.el-year-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-year-table td.today.end-date .el-date-table-cell__text,.el-year-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-year-table td.disabled .el-date-table-cell__text{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-year-table td.disabled .el-date-table-cell__text:hover{color:var(--el-text-color-placeholder)}.el-year-table td .el-date-table-cell__text{border-radius:18px;color:var(--el-datepicker-text-color);display:block;height:36px;left:50%;line-height:36px;margin:0 auto;position:absolute;transform:translate(-50%);width:60px}.el-year-table td .el-date-table-cell__text:hover{color:var(--el-datepicker-hover-text-color)}.el-year-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-year-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-year-table td.end-date .el-date-table-cell,.el-year-table td.start-date .el-date-table-cell{color:#fff}.el-year-table td.end-date .el-date-table-cell__text,.el-year-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff}.el-year-table td.start-date .el-date-table-cell{border-bottom-left-radius:24px;border-top-left-radius:24px}.el-year-table td.end-date .el-date-table-cell{border-bottom-right-radius:24px;border-top-right-radius:24px}.el-year-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff}.el-year-table td:focus-visible{outline:none}.el-year-table td:focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{display:inline-block;max-height:192px;overflow:auto;position:relative;vertical-align:top;width:50%}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;overflow:hidden;text-align:center}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;height:30px;left:0;line-height:30px;position:absolute;text-align:center;width:100%;z-index:var(--el-index-normal)}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner,.el-time-spinner__list{padding:0;text-align:center}.el-time-spinner__list{list-style:none;margin:0}.el-time-spinner__list:after,.el-time-spinner__list:before{content:"";display:block;height:80px;width:100%}.el-time-spinner__item{color:var(--el-text-color-regular);font-size:12px;height:32px;line-height:32px}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper,.el-picker__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;position:relative;text-align:left;vertical-align:middle}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{height:var(--el-input-height,var(--el-component-size));width:var(--el-date-editor-width)}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .clear-icon,.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-input-clear-hover-color)}.el-date-editor .el-range__icon{color:var(--el-text-color-placeholder);float:left;font-size:14px;height:inherit}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-text-color-regular);display:inline-block;font-size:var(--el-font-size-base);height:30px;line-height:30px;margin:0;outline:none;padding:0;text-align:center;width:39%}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{align-items:center;color:var(--el-text-color-primary);display:inline-flex;flex:1;font-size:14px;height:100%;justify-content:center;margin:0;overflow-wrap:break-word;padding:0 5px}.el-date-editor .el-range__close-icon{color:var(--el-text-color-placeholder);cursor:pointer;font-size:14px;height:inherit;width:unset}.el-date-editor .el-range__close-icon:hover{color:var(--el-input-clear-hover-color)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{align-items:center;display:inline-flex;padding:0 10px;vertical-align:middle}.el-range-editor.is-active,.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{font-size:14px;line-height:40px}.el-range-editor--large .el-range-input{font-size:14px;height:38px;line-height:38px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{font-size:12px;line-height:24px}.el-range-editor--small .el-range-input{font-size:12px;height:22px;line-height:22px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled,.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{background:var(--el-bg-color-overlay);border-radius:var(--el-popper-border-radius,var(--el-border-radius-base));color:var(--el-text-color-regular);line-height:30px}.el-picker-panel .el-time-panel{background-color:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light);margin:5px 0}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{clear:both;content:"";display:table}.el-picker-panel__content{margin:15px;position:relative}.el-picker-panel__footer{background-color:var(--el-bg-color-overlay);border-top:1px solid var(--el-datepicker-inner-border-color);font-size:0;padding:4px 12px;position:relative;text-align:right}.el-picker-panel__shortcut{background-color:transparent;border:0;color:var(--el-datepicker-text-color);cursor:pointer;display:block;font-size:14px;line-height:28px;outline:none;padding-left:12px;text-align:left;width:100%}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{background-color:transparent;border:1px solid var(--el-fill-color-darker);border-radius:2px;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:24px;outline:none;padding:0 20px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{background:transparent;border:0;color:var(--el-datepicker-icon-color);cursor:pointer;font-size:12px;margin-top:8px;outline:none}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{border-right:1px solid var(--el-datepicker-inner-border-color);bottom:0;box-sizing:border-box;overflow:auto;padding-top:6px;position:absolute;top:0;width:110px}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary);width:322px}.el-date-picker.has-sidebar.has-time{width:434px}.el-date-picker.has-sidebar{width:438px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker .el-picker-panel__content{width:292px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker__editor-wrap{display:table-cell;padding:0 5px;position:relative}.el-date-picker__time-header{border-bottom:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;display:table;font-size:12px;padding:8px 5px 5px;position:relative;width:100%}.el-date-picker__header{padding:12px 12px 0;text-align:center}.el-date-picker__header--bordered{border-bottom:1px solid var(--el-border-color-lighter);margin-bottom:0;padding-bottom:12px}.el-date-picker__header--bordered+.el-picker-panel__content{margin-top:0}.el-date-picker__header-label{color:var(--el-text-color-regular);cursor:pointer;font-size:16px;font-weight:500;line-height:22px;padding:0 5px;text-align:center}.el-date-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label:focus-visible{color:var(--el-datepicker-hover-text-color);outline:none}.el-date-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{cursor:pointer;float:left;line-height:30px;margin-left:10px}.el-date-picker .el-time-panel{position:absolute}.el-date-range-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary);width:646px}.el-date-range-picker.has-sidebar{width:756px}.el-date-range-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker__header{height:28px;position:relative;text-align:center}.el-date-range-picker__header [class*=arrow-left]{float:left}.el-date-range-picker__header [class*=arrow-right]{float:right}.el-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.el-date-range-picker__content{box-sizing:border-box;float:left;margin:0;padding:16px;width:50%}.el-date-range-picker__content.is-left{border-right:1px solid var(--el-datepicker-inner-border-color)}.el-date-range-picker__content .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{border-bottom:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;display:table;font-size:12px;padding:8px 5px 5px;position:relative;width:100%}.el-date-range-picker__time-header>.el-icon-arrow-right{color:var(--el-datepicker-icon-color);display:table-cell;font-size:20px;vertical-align:middle}.el-date-range-picker__time-picker-wrap{display:table-cell;padding:0 5px;position:relative}.el-date-range-picker__time-picker-wrap .el-picker-panel{background:#fff;position:absolute;right:0;top:13px;z-index:1}.el-date-range-picker__time-picker-wrap .el-time-panel{position:absolute}.el-time-range-picker{overflow:visible;width:354px}.el-time-range-picker__content{padding:10px;position:relative;text-align:center;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;display:inline-block;margin:0;padding:4px 7px 7px;width:50%}.el-time-range-picker__header{font-size:14px;margin-bottom:5px;text-align:center}.el-time-range-picker__body{border:1px solid var(--el-datepicker-border-color);border-radius:2px}.el-time-panel{border-radius:2px;box-sizing:content-box;left:0;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:180px;z-index:var(--el-index-top)}.el-time-panel__content{font-size:0;overflow:hidden;position:relative}.el-time-panel__content:after,.el-time-panel__content:before{box-sizing:border-box;content:"";height:32px;left:0;margin-top:-16px;padding-top:6px;position:absolute;right:0;text-align:left;top:50%;z-index:-1}.el-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content:before{border-bottom:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);margin-left:12%;margin-right:12%;padding-left:50%}.el-time-panel__content.has-seconds:after{left:66.6666666667%}.el-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));box-sizing:border-box;height:36px;line-height:25px;padding:4px;text-align:right}.el-time-panel__btn{background-color:transparent;border:none;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:28px;margin:0 5px;outline:none;padding:0 5px}.el-time-panel__btn.confirm{color:var(--el-timepicker-active-color,var(--el-color-primary));font-weight:800}.el-descriptions{--el-descriptions-table-border:1px solid var(--el-border-color-lighter);--el-descriptions-item-bordered-label-background:var(--el-fill-color-light);box-sizing:border-box;color:var(--el-text-color-primary);font-size:var(--el-font-size-base)}.el-descriptions__header{align-items:center;display:flex;justify-content:space-between;margin-bottom:16px}.el-descriptions__title{color:var(--el-text-color-primary);font-size:16px;font-weight:700}.el-descriptions__body{background-color:var(--el-fill-color-blank)}.el-descriptions__body .el-descriptions__table{border-collapse:collapse;width:100%}.el-descriptions__body .el-descriptions__table .el-descriptions__cell{box-sizing:border-box;font-size:14px;line-height:23px;text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-left{text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-center{text-align:center}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-right{text-align:right}.el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{border:var(--el-descriptions-table-border);padding:8px 11px}.el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:12px}.el-descriptions--large{font-size:14px}.el-descriptions--large .el-descriptions__header{margin-bottom:20px}.el-descriptions--large .el-descriptions__header .el-descriptions__title{font-size:16px}.el-descriptions--large .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:14px}.el-descriptions--large .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:12px 15px}.el-descriptions--large .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:16px}.el-descriptions--small{font-size:12px}.el-descriptions--small .el-descriptions__header{margin-bottom:12px}.el-descriptions--small .el-descriptions__header .el-descriptions__title{font-size:14px}.el-descriptions--small .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:12px}.el-descriptions--small .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:4px 7px}.el-descriptions--small .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:8px}.el-descriptions__label.el-descriptions__cell.is-bordered-label{background:var(--el-descriptions-item-bordered-label-background);color:var(--el-text-color-regular);font-weight:700}.el-descriptions__label:not(.is-bordered-label){color:var(--el-text-color-primary);margin-right:16px}.el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:6px}.el-descriptions__content.el-descriptions__cell.is-bordered-content{color:var(--el-text-color-primary)}.el-descriptions__content:not(.is-bordered-label){color:var(--el-text-color-regular)}.el-descriptions--large .el-descriptions__label:not(.is-bordered-label){margin-right:16px}.el-descriptions--large .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:8px}.el-descriptions--small .el-descriptions__label:not(.is-bordered-label){margin-right:12px}.el-descriptions--small .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:4px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-base);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;border-radius:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-divider{position:relative}.el-divider--horizontal{border-top:1px var(--el-border-color) var(--el-border-style);display:block;height:1px;margin:24px 0;width:100%}.el-divider--vertical{border-left:1px var(--el-border-color) var(--el-border-style);display:inline-block;height:1em;margin:0 8px;position:relative;vertical-align:middle;width:1px}.el-divider__text{background-color:var(--el-bg-color);color:var(--el-text-color-primary);font-size:14px;font-weight:500;padding:0 20px;position:absolute}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translate(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-drawer{--el-drawer-bg-color:var(--el-dialog-bg-color,var(--el-bg-color));--el-drawer-padding-primary:var(--el-dialog-padding-primary,20px);background-color:var(--el-drawer-bg-color);box-shadow:var(--el-box-shadow-dark);box-sizing:border-box;display:flex;flex-direction:column;overflow:hidden;position:absolute;transition:all var(--el-transition-duration)}.el-drawer .btt,.el-drawer .ltr,.el-drawer .rtl,.el-drawer .ttb{transform:translate(0)}.el-drawer__sr-focus:focus{outline:none!important}.el-drawer__header{align-items:center;color:#72767b;display:flex;margin-bottom:32px;padding:var(--el-drawer-padding-primary);padding-bottom:0}.el-drawer__header>:first-child{flex:1}.el-drawer__title{flex:1;font-size:16px;line-height:inherit;margin:0}.el-drawer__footer{padding:var(--el-drawer-padding-primary);padding-top:10px;text-align:right}.el-drawer__close-btn{background-color:transparent;border:none;color:inherit;cursor:pointer;display:inline-flex;font-size:var(--el-font-size-extra-large);outline:none}.el-drawer__close-btn:focus i,.el-drawer__close-btn:hover i{color:var(--el-color-primary)}.el-drawer__body{flex:1;overflow:auto;padding:var(--el-drawer-padding-primary)}.el-drawer__body>*{box-sizing:border-box}.el-drawer.ltr,.el-drawer.rtl{bottom:0;height:100%;top:0}.el-drawer.btt,.el-drawer.ttb{left:0;right:0;width:100%}.el-drawer.ltr{left:0}.el-drawer.rtl{right:0}.el-drawer.ttb{top:0}.el-drawer.btt{bottom:0}.el-drawer-fade-enter-active,.el-drawer-fade-leave-active{transition:all var(--el-transition-duration)}.el-drawer-fade-enter-active,.el-drawer-fade-enter-from,.el-drawer-fade-enter-to,.el-drawer-fade-leave-active,.el-drawer-fade-leave-from,.el-drawer-fade-leave-to{overflow:hidden!important}.el-drawer-fade-enter-from,.el-drawer-fade-leave-to{background-color:transparent!important}.el-drawer-fade-enter-from .rtl,.el-drawer-fade-leave-to .rtl{transform:translate(100%)}.el-drawer-fade-enter-from .ltr,.el-drawer-fade-leave-to .ltr{transform:translate(-100%)}.el-drawer-fade-enter-from .ttb,.el-drawer-fade-leave-to .ttb{transform:translateY(-100%)}.el-drawer-fade-enter-from .btt,.el-drawer-fade-leave-to .btt{transform:translateY(100%)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);line-height:1;position:relative;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper,.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:none}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:0}.el-dropdown .el-dropdown__caret-button{align-items:center;border-left:none;display:inline-flex;justify-content:center;padding-left:0;padding-right:0;width:32px}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{background:var(--el-overlay-color-lighter);bottom:-1px;content:"";display:block;left:0;position:absolute;top:-1px;width:1px}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:none}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;left:0;list-style:none;margin:0;padding:5px 0;position:relative;top:0;z-index:var(--el-dropdown-menu-index)}.el-dropdown-menu__item{align-items:center;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:var(--el-font-size-base);line-height:22px;list-style:none;margin:0;outline:none;padding:5px 16px;white-space:nowrap}.el-dropdown-menu__item:not(.is-disabled):focus,.el-dropdown-menu__item:not(.is-disabled):hover{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{border-top:1px solid var(--el-border-color-lighter);margin:6px 0}.el-dropdown-menu__item.is-disabled{color:var(--el-text-color-disabled);cursor:not-allowed}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{font-size:14px;line-height:22px;padding:7px 20px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{font-size:12px;line-height:20px;padding:2px 12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-empty-padding);text-align:center}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{height:100%;-o-object-fit:contain;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:top;width:100%}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:100%;vertical-align:top;width:100%}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);margin:0}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height);padding:var(--el-footer-padding)}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item--label-left .el-form-item__label{justify-content:flex-start}.el-form-item--label-top{display:block}.el-form-item--label-top .el-form-item__label{display:inline-block;height:auto;line-height:22px;margin-bottom:8px;text-align:left;vertical-align:middle}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input-tag__wrapper,.el-form-item.is-error .el-input-tag__wrapper.is-focus,.el-form-item.is-error .el-input-tag__wrapper:focus,.el-form-item.is-error .el-input-tag__wrapper:hover,.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input-group__append .el-input__validateIcon,.el-form-item.is-error .el-input-group__prepend .el-input__validateIcon{display:none}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-header{--el-header-padding:0 20px;--el-header-height:60px;box-sizing:border-box;flex-shrink:0;height:var(--el-header-height);padding:var(--el-header-padding)}.el-image-viewer__wrapper{bottom:0;left:0;position:fixed;right:0;top:0}.el-image-viewer__wrapper:focus{outline:none!important}.el-image-viewer__btn{align-items:center;border-radius:50%;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;opacity:.8;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1}.el-image-viewer__btn .el-icon{cursor:pointer}.el-image-viewer__close{font-size:40px;height:40px;right:40px;top:40px;width:40px}.el-image-viewer__canvas{align-items:center;display:flex;height:100%;justify-content:center;position:static;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.el-image-viewer__actions{background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px;bottom:30px;height:44px;left:50%;padding:0 23px;transform:translate(-50%)}.el-image-viewer__actions__inner{align-items:center;color:#fff;cursor:default;display:flex;font-size:23px;gap:22px;height:100%;justify-content:space-around;padding:0 6px;width:100%}.el-image-viewer__actions__divider{margin:0 -6px}.el-image-viewer__progress{bottom:90px;color:#fff;cursor:default;left:50%;transform:translate(-50%)}.el-image-viewer__prev{left:40px}.el-image-viewer__next,.el-image-viewer__prev{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;top:50%;transform:translateY(-50%);width:44px}.el-image-viewer__next{right:40px;text-indent:2px}.el-image-viewer__close{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;width:44px}.el-image-viewer__mask{background:#000;height:100%;left:0;opacity:.5;position:absolute;top:0;width:100%}.viewer-fade-enter-active{animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{animation:viewer-fade-out var(--el-transition-duration)}@keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{height:100%;width:100%}.el-image{display:inline-block;overflow:hidden;position:relative}.el-image__inner{opacity:1;vertical-align:top}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{left:0;position:absolute;top:0}.el-image__error,.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{align-items:center;color:var(--el-text-color-placeholder);display:flex;font-size:14px;justify-content:center;vertical-align:middle}.el-image__preview{cursor:pointer}.el-input-tag{--el-input-tag-border-color-hover:var(--el-border-color-hover);--el-input-tag-placeholder-color:var(--el-text-color-placeholder);--el-input-tag-disabled-color:var(--el-disabled-text-color);--el-input-tag-disabled-border:var(--el-disabled-border-color);--el-input-tag-font-size:var(--el-font-size-base);--el-input-tag-close-hover-color:var(--el-text-color-secondary);--el-input-tag-text-color:var(--el-text-color-regular);--el-input-tag-input-focus-border-color:var(--el-color-primary);--el-input-tag-width:100%;--el-input-tag-mini-height:var(--el-component-size);--el-input-tag-gap:6px;--el-input-tag-padding:4px;--el-input-tag-inner-padding:8px;--el-input-tag-line-height:24px;align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:var(--el-input-tag-font-size);line-height:var(--el-input-tag-line-height);min-height:var(--el-input-tag-mini-height);padding:var(--el-input-tag-padding);transform:translateZ(0);transition:var(--el-transition-duration);width:var(--el-input-tag-width)}.el-input-tag.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-input-tag.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-input-tag.is-disabled{background-color:var(--el-fill-color-light);cursor:not-allowed}.el-input-tag.is-disabled,.el-input-tag.is-disabled:hover{box-shadow:0 0 0 1px var(--el-input-tag-disabled-border) inset}.el-input-tag.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input-tag.is-disabled .el-input-tag__inner .el-input-tag__input,.el-input-tag.is-disabled .el-input-tag__inner .el-tag{cursor:not-allowed}.el-input-tag__prefix,.el-input-tag__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;padding:0 var(--el-input-tag-inner-padding)}.el-input-tag__suffix{gap:8px}.el-input-tag__inner{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:var(--el-input-tag-gap);max-width:100%;min-width:0;position:relative}.el-input-tag__inner.is-left-space{margin-left:var(--el-input-tag-inner-padding)}.el-input-tag__inner.is-right-space{margin-right:var(--el-input-tag-inner-padding)}.el-input-tag__inner.is-draggable .el-tag{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-input-tag__drop-indicator{background-color:var(--el-color-primary);height:var(--el-input-tag-line-height);position:absolute;top:0;width:1px}.el-input-tag__inner .el-tag{border-color:transparent;cursor:pointer;max-width:100%}.el-input-tag__inner .el-tag.el-tag--plain{border-color:var(--el-tag-border-color)}.el-input-tag__inner .el-tag .el-tag__content{line-height:normal;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-input-tag__input-wrapper{flex:1}.el-input-tag__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-input-tag-text-color);font-family:inherit;font-size:inherit;line-height:inherit;outline:none;padding:0;width:100%}.el-input-tag__input::-moz-placeholder{color:var(--el-input-tag-placeholder-color)}.el-input-tag__input::placeholder{color:var(--el-input-tag-placeholder-color)}.el-input-tag__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-input-tag--large{--el-input-tag-gap:6px;--el-input-tag-padding:8px;--el-input-tag-padding-left:8px;--el-input-tag-font-size:14px}.el-input-tag--small{--el-input-tag-gap:4px;--el-input-tag-padding:2px;--el-input-tag-padding-left:6px;--el-input-tag-font-size:12px;--el-input-tag-line-height:20px;--el-input-tag-mini-height:var(--el-component-size-small)}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder);align-items:center;color:var(--el-link-text-color);cursor:pointer;display:inline-flex;flex-direction:row;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);justify-content:center;outline:none;padding:0;position:relative;text-decoration:none;vertical-align:middle}.el-link.is-hover-underline:hover:after{border-bottom:1px solid var(--el-link-hover-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link.is-underline:after{border-bottom:1px solid var(--el-link-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link:hover:after{border-color:var(--el-link-hover-text-color)}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link__inner{align-items:center;display:inline-flex;justify-content:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link.is-disabled:after{border-color:var(--el-link-disabled-text-color)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{background-color:var(--el-mask-color);bottom:0;left:0;margin:0;position:absolute;right:0;top:0;transition:opacity var(--el-transition-duration);z-index:2000}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{margin-top:calc((0px - var(--el-loading-spinner-size))/2);position:absolute;text-align:center;top:50%;width:100%}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);font-size:14px;margin:3px 0}.el-loading-spinner .circular{animation:loading-rotate 2s linear infinite;display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size)}.el-loading-spinner .path{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-main{--el-main-padding:20px;box-sizing:border-box;display:block;flex:1;flex-basis:auto;overflow:auto;padding:var(--el-main-padding)}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-height:60px;--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{background-color:var(--el-menu-bg-color);border-right:1px solid var(--el-menu-border-color);box-sizing:border-box;list-style:none;margin:0;padding-left:0;position:relative}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level)*var(--el-menu-level-padding));white-space:nowrap}.el-menu:not(.el-menu--collapse) .el-sub-menu__title{padding-right:calc(var(--el-menu-base-level-padding) + var(--el-menu-icon-width))}.el-menu--horizontal{border-right:none;display:flex;flex-wrap:nowrap;height:var(--el-menu-horizontal-height)}.el-menu--horizontal.el-menu--popup-container{height:unset}.el-menu--horizontal.el-menu{border-bottom:1px solid var(--el-menu-border-color)}.el-menu--horizontal>.el-menu-item{align-items:center;border-bottom:2px solid transparent;color:var(--el-menu-text-color);display:inline-flex;height:100%;justify-content:center;margin:0}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:none}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{border-bottom:2px solid transparent;color:var(--el-menu-text-color);height:100%}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-menu-bg-color)}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{align-items:center;background-color:var(--el-menu-bg-color);color:var(--el-menu-text-color);display:flex;height:var(--el-menu-horizontal-sub-item-height);line-height:var(--el-menu-horizontal-sub-item-height);padding:0 10px}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{background-color:var(--el-menu-hover-bg-color);color:var(--el-menu-hover-text-color);outline:none}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding)*2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title>span,.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{display:inline-block;height:0;overflow:hidden;visibility:hidden;width:0}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--collapse .el-sub-menu.is-active .el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--popup{border:none;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light);min-width:200px;padding:5px 0;z-index:100}.el-menu .el-icon{flex-shrink:0}.el-menu-item{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:none}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-menu-item [class^=el-icon]{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{align-items:center;box-sizing:border-box;display:inline-flex;height:100%;left:0;padding:0 var(--el-menu-base-level-padding);position:absolute;top:0;width:100%}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:none}.el-sub-menu__title.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height)}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu .el-icon{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{font-size:12px;margin-right:0;margin-top:-6px;position:absolute;right:var(--el-menu-base-level-padding);top:50%;transition:transform var(--el-transition-duration);width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{color:var(--el-text-color-secondary);font-size:12px;line-height:normal;padding:7px 0 7px var(--el-menu-base-level-padding)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{opacity:0;transition:var(--el-transition-duration-fast)}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-box-shadow:var(--el-box-shadow);--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:12px;--el-messagebox-font-line-height:var(--el-font-line-height-primary);backface-visibility:hidden;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);box-shadow:var(--el-messagebox-box-shadow);box-sizing:border-box;display:inline-block;font-size:var(--el-messagebox-font-size);max-width:var(--el-messagebox-width);overflow:hidden;overflow-wrap:break-word;padding:var(--el-messagebox-padding-primary);position:relative;text-align:left;vertical-align:middle;width:100%}.el-message-box:focus{outline:none!important}.el-overlay.is-message-box .el-overlay-message-box{bottom:0;left:0;overflow:auto;padding:16px;position:fixed;right:0;text-align:center;top:0}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;vertical-align:middle;width:0}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-message-box__header{padding-bottom:var(--el-messagebox-padding-primary)}.el-message-box__header.show-close{padding-right:calc(var(--el-messagebox-padding-primary) + var(--el-message-close-size, 16px))}.el-message-box__title{color:var(--el-messagebox-title-color);font-size:var(--el-messagebox-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:40px;outline:none;padding:0;position:absolute;right:0;top:0;width:40px}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{align-items:center;display:flex;gap:12px}.el-message-box__input{padding-top:12px}.el-message-box__input div.invalid>input,.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{font-size:24px}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0;min-width:0}.el-message-box__message p{line-height:var(--el-messagebox-font-line-height);margin:0}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__btns{align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end;padding-top:var(--el-messagebox-padding-primary)}.el-message-box--center .el-message-box__title{align-items:center;display:flex;gap:6px;justify-content:center}.el-message-box--center .el-message-box__status{font-size:inherit}.el-message-box--center .el-message-box__btns,.el-message-box--center .el-message-box__container{justify-content:center}.fade-in-linear-enter-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@keyframes msgbox-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:11px 15px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary);align-items:center;background-color:var(--el-message-bg-color);border-color:var(--el-message-border-color);border-radius:var(--el-border-radius-base);border-style:var(--el-border-style);border-width:var(--el-border-width);box-sizing:border-box;display:flex;gap:8px;left:50%;max-width:calc(100% - 32px);padding:var(--el-message-padding);position:fixed;top:20px;transform:translate(-50%);transition:opacity var(--el-transition-duration),transform .4s,top .4s;width:-moz-fit-content;width:fit-content}.el-message.is-plain{background-color:var(--el-bg-color-overlay);border-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message .el-message__badge{position:absolute;right:-8px;top:-8px}.el-message__content{font-size:14px;line-height:1;padding:0}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{color:var(--el-message-close-icon-color);cursor:pointer;font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size,16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular);background-color:var(--el-bg-color-overlay);border:1px solid var(--el-notification-border-color);border-radius:var(--el-notification-radius);box-shadow:var(--el-notification-shadow);box-sizing:border-box;display:flex;overflow:hidden;overflow-wrap:break-word;padding:var(--el-notification-padding);position:fixed;transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);width:var(--el-notification-width);z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{flex:1;margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right);min-width:0}.el-notification__title{color:var(--el-notification-title-color);font-size:var(--el-notification-title-font-size);font-weight:700;line-height:var(--el-notification-icon-size);margin:0}.el-notification__content{color:var(--el-notification-content-color);font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0}.el-notification__content p{margin:0}.el-notification .el-notification__icon{flex-shrink:0;font-size:var(--el-notification-icon-size);height:var(--el-notification-icon-size);width:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{color:var(--el-notification-close-color);cursor:pointer;font-size:var(--el-notification-close-font-size);position:absolute;right:15px;top:18px}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translate(100%)}.el-notification-fade-enter-from.left{left:0;transform:translate(-100%)}.el-notification-fade-leave-to{opacity:0}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-page-header.is-contentful .el-page-header__main{border-top:1px solid var(--el-border-color-light);margin-top:16px}.el-page-header__header{align-items:center;display:flex;justify-content:space-between;line-height:24px}.el-page-header__left{align-items:center;display:flex;margin-right:40px;position:relative}.el-page-header__back{align-items:center;cursor:pointer;display:flex}.el-page-header__left .el-divider--vertical{margin:0 16px}.el-page-header__icon{align-items:center;display:flex;font-size:16px;margin-right:10px}.el-page-header__icon .el-icon{font-size:inherit}.el-page-header__title{font-size:14px;font-weight:500}.el-page-header__content{color:var(--el-text-color-primary);font-size:18px}.el-page-header__breadcrumb{margin-bottom:16px}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-button-width-large:40px;--el-pagination-button-height-large:40px;--el-pagination-item-gap:16px;align-items:center;color:var(--el-pagination-text-color);display:flex;font-size:var(--el-pagination-font-size);font-weight:400;white-space:nowrap}.el-pagination .el-input__inner{-moz-appearance:textfield;text-align:center}.el-pagination .el-select{width:128px}.el-pagination button{align-items:center;background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;display:flex;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:none}.el-pagination button.is-active,.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{cursor:default;font-weight:700}.el-pagination button.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pagination button.is-disabled,.el-pagination button:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes,.el-pagination__total{color:var(--el-text-color-regular);font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{align-items:center;color:var(--el-text-color-regular);display:flex;font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{box-sizing:border-box;text-align:center}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{align-items:center;display:flex;flex:1;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{background-color:var(--el-pagination-button-bg-color);margin:0 4px}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{background-color:var(--el-disabled-bg-color);color:var(--el-text-color-placeholder)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{background-color:var(--el-fill-color-dark);color:var(--el-text-color-secondary)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{font-size:var(--el-pagination-font-size-small);height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select{width:100px}.el-pagination--large .btn-next,.el-pagination--large .btn-prev,.el-pagination--large .el-pager li{height:var(--el-pagination-button-height-large);line-height:var(--el-pagination-button-height-large);min-width:var(--el-pagination-button-width-large)}.el-pagination--large .el-select .el-input{width:160px}.el-pager{font-size:0;list-style:none;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-pager,.el-pager li{align-items:center;display:flex}.el-pager li{background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:none}.el-pager li.is-active,.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{cursor:default;font-weight:700}.el-pager li.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pager li.is-disabled,.el-pager li:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-popconfirm__main{align-items:center;display:flex}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{margin-top:8px;text-align:right}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);border:1px solid var(--el-popover-border-color);border-radius:var(--el-popover-border-radius);box-shadow:var(--el-box-shadow-light);box-sizing:border-box;color:var(--el-text-color-regular);font-size:var(--el-popover-font-size);line-height:1.4;min-width:150px;overflow-wrap:break-word;padding:var(--el-popover-padding);z-index:var(--el-index-popper)}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.el-progress{align-items:center;display:flex;line-height:1;position:relative}.el-progress__text{color:var(--el-text-color-regular);font-size:14px;line-height:1;margin-left:5px;min-width:50px}.el-progress__text i{display:block;vertical-align:middle}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{left:0;margin:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);width:100%}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{display:inline-block;vertical-align:middle}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{display:block;margin-right:0;padding-right:0}.el-progress--text-inside .el-progress-bar{margin-right:0;padding-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{box-sizing:border-box;flex-grow:1}.el-progress-bar__outer{background-color:var(--el-border-color-lighter);border-radius:100px;height:6px;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{background-color:var(--el-color-primary);border-radius:100px;height:100%;left:0;line-height:1;position:absolute;text-align:right;top:0;transition:width .6s ease;white-space:nowrap}.el-progress-bar__inner:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{animation:indeterminate 3s infinite;transform:translateZ(0)}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 0,transparent 50%,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 75%,transparent 0,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{color:#fff;display:inline-block;font-size:12px;margin:0 5px;vertical-align:middle}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}.el-radio-button{--el-radio-button-checked-bg-color:var(--el-color-primary);--el-radio-button-checked-text-color:var(--el-color-white);--el-radio-button-checked-border-color:var(--el-color-primary);--el-radio-button-disabled-checked-fill:var(--el-border-color-extra-light)}.el-radio-button,.el-radio-button__inner{display:inline-block;outline:none;position:relative}.el-radio-button__inner{-webkit-appearance:none;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left:0;border-radius:0;box-sizing:border-box;color:var(--el-button-text-color,var(--el-text-color-regular));cursor:pointer;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight,var(--el-font-weight-primary));line-height:1;margin:0;padding:8px 15px;text-align:center;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-radio-button__inner.is-round{padding:8px 15px}.el-radio-button__inner:hover{color:var(--el-color-primary)}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button:first-child .el-radio-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-radio-button.is-active .el-radio-button__original-radio:not(:disabled)+.el-radio-button__inner{background-color:var(--el-radio-button-checked-bg-color,var(--el-color-primary));border-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));box-shadow:-1px 0 0 0 var(--el-radio-button-checked-border-color,var(--el-color-primary));color:var(--el-radio-button-checked-text-color,var(--el-color-white))}.el-radio-button__original-radio{opacity:0;outline:none;position:absolute;z-index:-1}.el-radio-button__original-radio:focus-visible+.el-radio-button__inner{border-left:var(--el-border);border-left-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));border-radius:var(--el-border-radius-base);box-shadow:none;outline:2px solid var(--el-radio-button-checked-border-color);outline-offset:1px;z-index:2}.el-radio-button__original-radio:disabled+.el-radio-button__inner{background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));background-image:none;border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none;color:var(--el-disabled-text-color);cursor:not-allowed}.el-radio-button__original-radio:disabled:checked+.el-radio-button__inner{background-color:var(--el-radio-button-disabled-checked-fill)}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:var(--el-border-radius-base)}.el-radio-button--large .el-radio-button__inner{border-radius:0;font-size:var(--el-font-size-base);padding:12px 19px}.el-radio-button--large .el-radio-button__inner.is-round{padding:12px 19px}.el-radio-button--small .el-radio-button__inner{border-radius:0;font-size:12px;padding:5px 11px}.el-radio-button--small .el-radio-button__inner.is-round{padding:5px 11px}.el-radio-group{align-items:center;display:inline-flex;flex-wrap:wrap;font-size:0}.el-radio{--el-radio-font-size:var(--el-font-size-base);--el-radio-text-color:var(--el-text-color-regular);--el-radio-font-weight:var(--el-font-weight-primary);--el-radio-input-height:14px;--el-radio-input-width:14px;--el-radio-input-border-radius:var(--el-border-radius-circle);--el-radio-input-bg-color:var(--el-fill-color-blank);--el-radio-input-border:var(--el-border);--el-radio-input-border-color:var(--el-border-color);--el-radio-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-radio-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-radio-font-weight);height:32px;margin-right:30px;outline:none;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-radio.el-radio--large{height:40px}.el-radio.el-radio--small{height:24px}.el-radio.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-radio.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-radio.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-radio.is-bordered.el-radio--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-radio.is-bordered.el-radio--large .el-radio__label{font-size:var(--el-font-size-base)}.el-radio.is-bordered.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.is-bordered.el-radio--small{border-radius:var(--el-border-radius-base);padding:0 11px 0 7px}.el-radio.is-bordered.el-radio--small .el-radio__label{font-size:12px}.el-radio.is-bordered.el-radio--small .el-radio__inner{height:12px;width:12px}.el-radio:last-child{margin-right:0}.el-radio__input{cursor:pointer;display:inline-flex;outline:none;position:relative;vertical-align:middle;white-space:nowrap}.el-radio__input.is-disabled .el-radio__inner{border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled .el-radio__inner,.el-radio__input.is-disabled .el-radio__inner:after{background-color:var(--el-disabled-bg-color);cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled.is-checked .el-radio__inner:after{background-color:var(--el-text-color-placeholder)}.el-radio__input.is-disabled+span.el-radio__label{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-radio__input.is-checked .el-radio__inner{background:var(--el-color-primary);border-color:var(--el-color-primary)}.el-radio__input.is-checked .el-radio__inner:after{transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-checked+.el-radio__label{color:var(--el-color-primary)}.el-radio__input.is-focus .el-radio__inner{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner{background-color:var(--el-radio-input-bg-color);border:var(--el-radio-input-border);border-radius:var(--el-radio-input-border-radius);box-sizing:border-box;cursor:pointer;display:inline-block;height:var(--el-radio-input-height);position:relative;width:var(--el-radio-input-width)}.el-radio__inner:hover{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner:after{background-color:var(--el-color-white);border-radius:var(--el-radio-input-border-radius);content:"";height:4px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s ease-in;width:4px}.el-radio__original{bottom:0;left:0;margin:0;opacity:0;outline:none;position:absolute;right:0;top:0;z-index:-1}.el-radio__original:focus-visible+.el-radio__inner{border-radius:var(--el-radio-input-border-radius);outline:2px solid var(--el-radio-input-border-color-hover);outline-offset:1px}.el-radio:focus:not(:focus-visible):not(.is-focus):not(:active):not(.is-disabled) .el-radio__inner{box-shadow:0 0 2px 2px var(--el-radio-input-border-color-hover)}.el-radio__label{font-size:var(--el-radio-font-size);padding-left:8px}.el-radio.el-radio--large .el-radio__label{font-size:14px}.el-radio.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.el-radio--small .el-radio__label{font-size:12px}.el-radio.el-radio--small .el-radio__inner{height:12px;width:12px}.el-rate{--el-rate-height:20px;--el-rate-font-size:var(--el-font-size-base);--el-rate-icon-size:18px;--el-rate-icon-margin:6px;--el-rate-void-color:var(--el-border-color-darker);--el-rate-fill-color:#f7ba2a;--el-rate-disabled-void-color:var(--el-fill-color);--el-rate-text-color:var(--el-text-color-primary);align-items:center;display:inline-flex;height:32px}.el-rate:active,.el-rate:focus{outline:none}.el-rate__item{color:var(--el-rate-void-color);cursor:pointer;display:inline-block;font-size:0;line-height:normal;position:relative;vertical-align:middle}.el-rate .el-rate__icon{display:inline-block;font-size:var(--el-rate-icon-size);margin-right:var(--el-rate-icon-margin);position:relative;transition:var(--el-transition-duration)}.el-rate .el-rate__icon.hover{transform:scale(1.15)}.el-rate .el-rate__icon .path2{left:0;position:absolute;top:0}.el-rate .el-rate__icon.is-active{color:var(--el-rate-fill-color)}.el-rate__decimal{color:var(--el-rate-fill-color);display:inline-block;overflow:hidden}.el-rate__decimal,.el-rate__decimal--box{left:0;position:absolute;top:0}.el-rate__text{color:var(--el-rate-text-color);font-size:var(--el-rate-font-size);vertical-align:middle}.el-rate--large{height:40px}.el-rate--small{height:24px}.el-rate--small .el-rate__icon{font-size:14px}.el-rate.is-disabled .el-rate__item{color:var(--el-rate-disabled-void-color);cursor:auto}.el-result{--el-result-padding:40px 30px;--el-result-icon-font-size:64px;--el-result-title-font-size:20px;--el-result-title-margin-top:20px;--el-result-subtitle-margin-top:10px;--el-result-extra-margin-top:30px;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-result-padding);text-align:center}.el-result__icon svg{height:var(--el-result-icon-font-size);width:var(--el-result-icon-font-size)}.el-result__title{margin-top:var(--el-result-title-margin-top)}.el-result__title p{color:var(--el-text-color-primary);font-size:var(--el-result-title-font-size);line-height:1.3;margin:0}.el-result__subtitle{margin-top:var(--el-result-subtitle-margin-top)}.el-result__subtitle p{color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1.3;margin:0}.el-result__extra{margin-top:var(--el-result-extra-margin-top)}.el-result .icon-primary{--el-result-color:var(--el-color-primary);color:var(--el-result-color)}.el-result .icon-success{--el-result-color:var(--el-color-success);color:var(--el-result-color)}.el-result .icon-warning{--el-result-color:var(--el-color-warning);color:var(--el-result-color)}.el-result .icon-danger{--el-result-color:var(--el-color-danger);color:var(--el-result-color)}.el-result .icon-error{--el-result-color:var(--el-color-error);color:var(--el-result-color)}.el-result .icon-info{--el-result-color:var(--el-color-info);color:var(--el-result-color)}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__title{box-sizing:border-box;color:var(--el-color-info);font-size:12px;line-height:34px;overflow:hidden;padding:0 20px;text-overflow:ellipsis;white-space:nowrap}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transform:translateZ(0);transition:var(--el-transition-duration)}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled,.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag,.el-select__wrapper.is-disabled input{cursor:not-allowed}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__clear{cursor:pointer}.el-select__clear:hover{color:var(--el-select-close-hover-color)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag.el-tag--plain{border-color:var(--el-tag-border-color)}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%;z-index:-1}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper,.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{flex:1}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute;z-index:-1}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;outline:none;padding:0;width:100%}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.el-skeleton{--el-skeleton-circle-size:var(--el-avatar-size)}.el-skeleton__item{background:var(--el-skeleton-color);border-radius:var(--el-border-radius-base);display:inline-block;height:16px;width:100%}.el-skeleton__circle{border-radius:50%;height:var(--el-skeleton-circle-size);line-height:var(--el-skeleton-circle-size);width:var(--el-skeleton-circle-size)}.el-skeleton__button{border-radius:4px;height:40px;width:64px}.el-skeleton__p{width:100%}.el-skeleton__p.is-last{width:61%}.el-skeleton__p.is-first{width:33%}.el-skeleton__text{height:var(--el-font-size-small);width:100%}.el-skeleton__caption{height:var(--el-font-size-extra-small)}.el-skeleton__h1{height:var(--el-font-size-extra-large)}.el-skeleton__h3{height:var(--el-font-size-large)}.el-skeleton__h5{height:var(--el-font-size-medium)}.el-skeleton__image{align-items:center;border-radius:0;display:flex;justify-content:center;width:unset}.el-skeleton__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:22%;width:22%}.el-skeleton{--el-skeleton-color:var(--el-fill-color);--el-skeleton-to-color:var(--el-fill-color-darker)}@keyframes el-skeleton-loading{0%{background-position:100% 50%}to{background-position:0 50%}}.el-skeleton{width:100%}.el-skeleton__first-line,.el-skeleton__paragraph{background:var(--el-skeleton-color);height:16px;margin-top:16px}.el-skeleton.is-animated .el-skeleton__item{animation:el-skeleton-loading 1.4s ease infinite;background:linear-gradient(90deg,var(--el-skeleton-color) 25%,var(--el-skeleton-to-color) 37%,var(--el-skeleton-color) 63%);background-size:400% 100%}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px;align-items:center;display:flex;height:32px;width:100%}.el-slider__runway{background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);cursor:pointer;flex:1;height:var(--el-slider-height);position:relative}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging,.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{background-color:var(--el-slider-main-bg-color);border-bottom-left-radius:var(--el-slider-border-radius);border-top-left-radius:var(--el-slider-border-radius);height:var(--el-slider-height);position:absolute}.el-slider__button-wrapper{background-color:transparent;height:var(--el-slider-button-wrapper-size);line-height:normal;outline:none;position:absolute;text-align:center;top:var(--el-slider-button-wrapper-offset);transform:translate(-50%);-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--el-slider-button-wrapper-size);z-index:1}.el-slider__button-wrapper:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:grab}.el-slider__button-wrapper.dragging{cursor:grabbing}.el-slider__button{background-color:var(--el-color-white);border:2px solid var(--el-slider-main-bg-color);border-radius:50%;box-sizing:border-box;display:inline-block;height:var(--el-slider-button-size);transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:var(--el-slider-button-size)}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:grab}.el-slider__button.dragging{cursor:grabbing}.el-slider__stop{background-color:var(--el-slider-stop-bg-color);border-radius:var(--el-border-radius-circle);height:var(--el-slider-height);position:absolute;transform:translate(-50%);width:var(--el-slider-height)}.el-slider__marks{height:100%;left:12px;top:0;width:18px}.el-slider__marks-text{color:var(--el-color-info);font-size:14px;margin-top:15px;position:absolute;transform:translate(-50%);white-space:pre}.el-slider.is-vertical{display:inline-flex;flex:0;height:100%;position:relative;width:auto}.el-slider.is-vertical .el-slider__runway{height:100%;margin:0 16px;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__bar{border-radius:0 0 3px 3px;height:auto;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__button-wrapper{left:var(--el-slider-button-wrapper-offset);top:auto;transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{left:15px;margin-top:0;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-space{display:inline-flex;vertical-align:top}.el-space__item{display:flex;flex-wrap:wrap}.el-space__item>*{flex:1}.el-space--vertical{flex-direction:column}.el-time-spinner{white-space:nowrap;width:100%}.el-spinner{display:inline-block;vertical-align:middle}.el-spinner-inner{animation:rotate 2s linear infinite;height:50px;width:50px}.el-spinner-inner .path{stroke:var(--el-border-color-lighter);stroke-linecap:round;animation:dash 1.5s ease-in-out infinite}@keyframes rotate{to{transform:rotate(1turn)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}.el-step{flex-shrink:1;position:relative}.el-step:last-of-type .el-step__line{display:none}.el-step:last-of-type.is-flex{flex-basis:auto!important;flex-grow:0;flex-shrink:0}.el-step:last-of-type .el-step__description,.el-step:last-of-type .el-step__main{padding-right:0}.el-step__head{position:relative;width:100%}.el-step__head.is-process{border-color:var(--el-text-color-primary);color:var(--el-text-color-primary)}.el-step__head.is-wait{border-color:var(--el-text-color-placeholder);color:var(--el-text-color-placeholder)}.el-step__head.is-success{border-color:var(--el-color-success);color:var(--el-color-success)}.el-step__head.is-error{border-color:var(--el-color-danger);color:var(--el-color-danger)}.el-step__head.is-finish{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-step__icon{align-items:center;background:var(--el-bg-color);box-sizing:border-box;display:inline-flex;font-size:14px;height:24px;justify-content:center;position:relative;transition:.15s ease-out;width:24px;z-index:1}.el-step__icon.is-text{border:2px solid;border-radius:50%}.el-step__icon.is-icon{width:40px}.el-step__icon-inner{color:inherit;display:inline-block;font-weight:700;line-height:1;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:25px;font-weight:400}.el-step__icon-inner.is-status{transform:translateY(1px)}.el-step__line{background-color:var(--el-text-color-placeholder);border-color:currentColor;position:absolute}.el-step__line-inner{border:1px solid;box-sizing:border-box;display:block;height:0;transition:.15s ease-out;width:0}.el-step__main{text-align:left;white-space:normal}.el-step__title{font-size:16px;line-height:38px}.el-step__title.is-process{color:var(--el-text-color-primary);font-weight:700}.el-step__title.is-wait{color:var(--el-text-color-placeholder)}.el-step__title.is-success{color:var(--el-color-success)}.el-step__title.is-error{color:var(--el-color-danger)}.el-step__title.is-finish{color:var(--el-color-primary)}.el-step__description{font-size:12px;font-weight:400;line-height:20px;margin-top:-5px;padding-right:10%}.el-step__description.is-process{color:var(--el-text-color-primary)}.el-step__description.is-wait{color:var(--el-text-color-placeholder)}.el-step__description.is-success{color:var(--el-color-success)}.el-step__description.is-error{color:var(--el-color-danger)}.el-step__description.is-finish{color:var(--el-color-primary)}.el-step.is-horizontal{display:inline-block}.el-step.is-horizontal .el-step__line{height:2px;left:0;right:0;top:11px}.el-step.is-vertical{display:flex}.el-step.is-vertical .el-step__head{flex-grow:0;width:24px}.el-step.is-vertical .el-step__main{flex-grow:1;padding-left:10px}.el-step.is-vertical .el-step__title{line-height:24px;padding-bottom:8px}.el-step.is-vertical .el-step__line{bottom:0;left:11px;top:0;width:2px}.el-step.is-vertical .el-step__icon.is-icon{width:24px}.el-step.is-center .el-step__head,.el-step.is-center .el-step__main{text-align:center}.el-step.is-center .el-step__description{padding-left:20%;padding-right:20%}.el-step.is-center .el-step__line{left:50%;right:-50%}.el-step.is-simple{align-items:center;display:flex}.el-step.is-simple .el-step__head{font-size:0;padding-right:10px;width:auto}.el-step.is-simple .el-step__icon{background:transparent;font-size:12px;height:16px;width:16px}.el-step.is-simple .el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:18px}.el-step.is-simple .el-step__icon-inner.is-status{transform:scale(.8) translateY(1px)}.el-step.is-simple .el-step__main{align-items:stretch;display:flex;flex-grow:1;position:relative}.el-step.is-simple .el-step__title{font-size:16px;line-height:20px}.el-step.is-simple:not(:last-of-type) .el-step__title{max-width:50%;overflow-wrap:break-word}.el-step.is-simple .el-step__arrow{align-items:center;display:flex;flex-grow:1;justify-content:center}.el-step.is-simple .el-step__arrow:after,.el-step.is-simple .el-step__arrow:before{background:var(--el-text-color-placeholder);content:"";display:inline-block;height:15px;position:absolute;width:1px}.el-step.is-simple .el-step__arrow:before{transform:rotate(-45deg) translateY(-4px);transform-origin:0 0}.el-step.is-simple .el-step__arrow:after{transform:rotate(45deg) translateY(4px);transform-origin:100% 100%}.el-step.is-simple:last-of-type .el-step__arrow{display:none}.el-steps{display:flex}.el-steps--simple{background:var(--el-fill-color-light);border-radius:4px;padding:13px 8%}.el-steps--horizontal{white-space:nowrap}.el-steps--vertical{flex-flow:column;height:100%}.el-table-v2{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);font-size:var(--el-font-size-base)}.el-table-v2 *{box-sizing:border-box}.el-table-v2__root{position:relative}.el-table-v2__root:hover .el-table-v2__main .el-virtual-scrollbar{opacity:1}.el-table-v2__main{background-color:var(--el-bg-color);display:flex;flex-direction:column-reverse;left:0;overflow:hidden;position:absolute;top:0}.el-table-v2__main .el-vl__horizontal,.el-table-v2__main .el-vl__vertical{z-index:2}.el-table-v2__left{background-color:var(--el-bg-color);box-shadow:2px 0 4px #0000000f;display:flex;flex-direction:column-reverse;left:0;overflow:hidden;position:absolute;top:0}.el-table-v2__left .el-virtual-scrollbar{opacity:0}.el-table-v2__left .el-vl__horizontal,.el-table-v2__left .el-vl__vertical{z-index:-1}.el-table-v2__right{background-color:var(--el-bg-color);box-shadow:-2px 0 4px #0000000f;display:flex;flex-direction:column-reverse;overflow:hidden;position:absolute;right:0;top:0}.el-table-v2__right .el-virtual-scrollbar{opacity:0}.el-table-v2__right .el-vl__horizontal,.el-table-v2__right .el-vl__vertical{z-index:-1}.el-table-v2__header-row,.el-table-v2__row{padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__header-wrapper{overflow:hidden}.el-table-v2__header{overflow:hidden;position:relative}.el-table-v2__header .el-checkbox{z-index:0}.el-table-v2__footer{bottom:0;overflow:hidden;right:0}.el-table-v2__empty,.el-table-v2__footer,.el-table-v2__overlay{left:0;position:absolute}.el-table-v2__overlay{bottom:0;right:0;top:0;z-index:9999}.el-table-v2__header-row{border-bottom:var(--el-table-border);display:flex}.el-table-v2__header-cell{align-items:center;background-color:var(--el-table-header-bg-color);color:var(--el-table-header-text-color);display:flex;font-weight:700;height:100%;overflow:hidden;padding:0 8px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table-v2__header-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__header-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__header-cell.is-sortable{cursor:pointer}.el-table-v2__header-cell:hover .el-icon{display:block}.el-table-v2__sort-icon{display:none;opacity:.6;transition:opacity,display var(--el-transition-duration)}.el-table-v2__sort-icon.is-sorting{display:block;opacity:1}.el-table-v2__row{align-items:center;border-bottom:var(--el-table-border);display:flex;transition:background-color var(--el-transition-duration)}.el-table-v2__row.is-hovered,.el-table-v2__row:hover{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row-cell{align-items:center;display:flex;height:100%;overflow:hidden;padding:0 8px}.el-table-v2__row-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__row-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__expand-icon{cursor:pointer;margin:0 4px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table-v2__expand-icon svg{transition:transform var(--el-transition-duration)}.el-table-v2__expand-icon.is-expanded svg{transform:rotate(90deg)}.el-table-v2:not(.is-dynamic) .el-table-v2__cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-table-v2.is-dynamic .el-table-v2__row{align-items:stretch;overflow:hidden}.el-table-v2.is-dynamic .el-table-v2__row .el-table-v2__row-cell{overflow-wrap:break-word}.el-tabs{--el-tabs-header-height:40px;display:flex}.el-tabs__header{align-items:center;display:flex;justify-content:space-between;margin:0 0 15px;padding:0;position:relative}.el-tabs__header-vertical{flex-direction:column}.el-tabs__active-bar{background-color:var(--el-color-primary);bottom:0;height:2px;left:0;list-style:none;position:absolute;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);z-index:1}.el-tabs__new-tab{align-items:center;border:1px solid var(--el-border-color);border-radius:3px;color:var(--el-text-color-primary);cursor:pointer;display:flex;flex-shrink:0;font-size:12px;height:20px;justify-content:center;line-height:20px;margin:10px 0 10px 10px;text-align:center;transition:all .15s;width:20px}.el-tabs__new-tab .is-icon-plus{height:inherit;transform:scale(.8);width:inherit}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__new-tab-vertical{margin-left:0}.el-tabs__nav-wrap{flex:1 auto;margin-bottom:-1px;overflow:hidden;position:relative}.el-tabs__nav-wrap:after{background-color:var(--el-border-color-light);bottom:0;content:"";height:2px;left:0;position:absolute;width:100%;z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{box-sizing:border-box;padding:0 20px}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;line-height:44px;position:absolute;text-align:center;width:20px}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;float:left;position:relative;transition:transform var(--el-transition-duration);white-space:nowrap;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{display:flex;min-width:100%}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{align-items:center;box-sizing:border-box;color:var(--el-text-color-primary);display:flex;font-size:var(--el-font-size-base);font-weight:500;height:var(--el-tabs-header-height);justify-content:center;list-style:none;padding:0 20px;position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:none}.el-tabs__item:focus-visible{border-radius:3px;box-shadow:0 0 2px 2px var(--el-color-primary) inset}.el-tabs__item .is-icon-close{border-radius:50%;margin-left:5px;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs__item .is-icon-close:before{display:inline-block;transform:scale(.9)}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active,.el-tabs__item:hover{color:var(--el-color-primary)}.el-tabs__item:hover{cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{flex-grow:1;overflow:hidden;position:relative}.el-tabs--bottom>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:0}.el-tabs--bottom>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top>.el-tabs__header .el-tabs__item:last-child{padding-right:0}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{font-size:12px;height:14px;overflow:hidden;position:relative;right:-2px;transform-origin:100% 50%;width:0}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{border:1px solid transparent;color:var(--el-text-color-secondary);margin-top:-1px;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item,.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{background-color:var(--el-bg-color-overlay);border-left-color:var(--el-border-color);border-right-color:var(--el-border-color);color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom{flex-direction:column}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-bottom:0;margin-top:-1px}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{bottom:auto;height:auto;top:0;width:2px}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{cursor:pointer;height:30px;line-height:30px;text-align:center;width:100%}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{bottom:0;right:auto}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{bottom:auto;height:100%;top:0;width:2px}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left{flex-direction:row-reverse}.el-tabs--left .el-tabs__header.is-left{margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-bottom:none;border-left:none;border-right:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:none;border-right:1px solid #fff}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-radius:4px 0 0 4px;border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--right .el-tabs__header.is-right{margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:1px solid #fff;border-right:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-left:none;border-radius:0 4px 4px 0}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--top{flex-direction:column-reverse}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{animation:slideInRight-leave var(--el-transition-duration);left:0;position:absolute;right:0}.slideInLeft-enter{animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{animation:slideInLeft-leave var(--el-transition-duration);left:0;position:absolute;right:0}@keyframes slideInRight-enter{0%{opacity:0;transform:translate(100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInRight-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(100%);transform-origin:0 0}}@keyframes slideInLeft-enter{0%{opacity:0;transform:translate(-100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInLeft-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(-100%);transform-origin:0 0}}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.time-select{margin:5px 0;min-width:0}.time-select .el-picker-panel__content{margin:0;max-height:200px}.time-select-item{font-size:14px;line-height:20px;padding:8px 10px}.time-select-item.disabled{color:var(--el-datepicker-border-color);cursor:not-allowed}.time-select-item:hover{background-color:var(--el-fill-color-light);cursor:pointer;font-weight:700}.time-select .time-select-item.selected:not(.disabled){color:var(--el-color-primary);font-weight:700}.el-timeline-item{padding-bottom:20px;position:relative}.el-timeline-item__wrapper{padding-left:28px;position:relative;top:-3px}.el-timeline-item__tail{border-left:2px solid var(--el-timeline-node-color);height:100%;left:4px;position:absolute}.el-timeline-item .el-timeline-item__icon{color:var(--el-color-white);font-size:var(--el-font-size-small)}.el-timeline-item__node{align-items:center;background-color:var(--el-timeline-node-color);border-color:var(--el-timeline-node-color);border-radius:50%;box-sizing:border-box;display:flex;justify-content:center;position:absolute}.el-timeline-item__node--normal{height:var(--el-timeline-node-size-normal);left:-1px;width:var(--el-timeline-node-size-normal)}.el-timeline-item__node--large{height:var(--el-timeline-node-size-large);left:-2px;width:var(--el-timeline-node-size-large)}.el-timeline-item__node.is-hollow{background:var(--el-color-white);border-style:solid;border-width:2px}.el-timeline-item__node--primary{background-color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-timeline-item__node--success{background-color:var(--el-color-success);border-color:var(--el-color-success)}.el-timeline-item__node--warning{background-color:var(--el-color-warning);border-color:var(--el-color-warning)}.el-timeline-item__node--danger{background-color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-timeline-item__node--info{background-color:var(--el-color-info);border-color:var(--el-color-info)}.el-timeline-item__dot{align-items:center;display:flex;justify-content:center;position:absolute}.el-timeline-item__content{color:var(--el-text-color-primary)}.el-timeline-item__timestamp{color:var(--el-text-color-secondary);font-size:var(--el-font-size-small);line-height:1}.el-timeline-item__timestamp.is-top{margin-bottom:8px;padding-top:4px}.el-timeline-item__timestamp.is-bottom{margin-top:8px}.el-timeline{--el-timeline-node-size-normal:12px;--el-timeline-node-size-large:14px;--el-timeline-node-color:var(--el-border-color-light);font-size:var(--el-font-size-base);list-style:none;margin:0}.el-timeline .el-timeline-item:last-child .el-timeline-item__tail{display:none}.el-timeline .el-timeline-item__center{align-items:center;display:flex}.el-timeline .el-timeline-item__center .el-timeline-item__wrapper{width:100%}.el-timeline .el-timeline-item__center .el-timeline-item__tail{top:0}.el-timeline .el-timeline-item__center:first-child .el-timeline-item__tail{height:calc(50% + 10px);top:calc(50% - 10px)}.el-timeline .el-timeline-item__center:last-child .el-timeline-item__tail{display:block;height:calc(50% - 10px)}.el-tooltip-v2__content{--el-tooltip-v2-padding:5px 10px;--el-tooltip-v2-border-radius:4px;--el-tooltip-v2-border-color:var(--el-border-color);background-color:var(--el-color-white);border:1px solid var(--el-border-color);border-radius:var(--el-tooltip-v2-border-radius);color:var(--el-color-black);padding:var(--el-tooltip-v2-padding)}.el-tooltip-v2__arrow{color:var(--el-color-white);height:var(--el-tooltip-v2-arrow-height);left:var(--el-tooltip-v2-arrow-x);pointer-events:none;position:absolute;top:var(--el-tooltip-v2-arrow-y);width:var(--el-tooltip-v2-arrow-width)}.el-tooltip-v2__arrow:after,.el-tooltip-v2__arrow:before{border:var(--el-tooltip-v2-arrow-border-width) solid transparent;content:"";height:0;position:absolute;width:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow{bottom:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow:before{border-bottom:0;border-top-color:var(--el-color-white);border-top-width:var(--el-tooltip-v2-arrow-border-width);top:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow:after{border-bottom:0;border-top-color:var(--el-border-color);border-top-width:var(--el-tooltip-v2-arrow-border-width);top:100%;z-index:-1}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow{top:0}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow:before{border-bottom-color:var(--el-color-white);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow:after{border-bottom-color:var(--el-border-color);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:100%;z-index:-1}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow{right:0}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow:before{border-left-color:var(--el-color-white);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow:after{border-left-color:var(--el-border-color);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:100%;z-index:-1}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow{left:0}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow:before{border-left:0;border-right-color:var(--el-color-white);border-right-width:var(--el-tooltip-v2-arrow-border-width);right:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow:after{border-left:0;border-right-color:var(--el-border-color);border-right-width:var(--el-tooltip-v2-arrow-border-width);right:100%;z-index:-1}.el-tooltip-v2__content.is-dark{--el-tooltip-v2-border-color:transparent;color:var(--el-color-white)}.el-tooltip-v2__content.is-dark,.el-tooltip-v2__content.is-dark .el-tooltip-v2__arrow{background-color:var(--el-color-black);border-color:transparent}.el-transfer{--el-transfer-border-color:var(--el-border-color-lighter);--el-transfer-border-radius:var(--el-border-radius-base);--el-transfer-panel-width:200px;--el-transfer-panel-header-height:40px;--el-transfer-panel-header-bg-color:var(--el-fill-color-light);--el-transfer-panel-footer-height:40px;--el-transfer-panel-body-height:278px;--el-transfer-item-height:30px;--el-transfer-filter-height:32px;font-size:var(--el-font-size-base)}.el-transfer__buttons{display:inline-block;padding:0 30px;vertical-align:middle}.el-transfer__button{vertical-align:top}.el-transfer__button:nth-child(2){margin:0 0 0 10px}.el-transfer__button i,.el-transfer__button span{font-size:14px}.el-transfer__button .el-icon+span{margin-left:0}.el-transfer-panel{background:var(--el-bg-color-overlay);box-sizing:border-box;display:inline-block;max-height:100%;overflow:hidden;position:relative;text-align:left;vertical-align:middle;width:var(--el-transfer-panel-width)}.el-transfer-panel__body{border-bottom:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);border-left:1px solid var(--el-transfer-border-color);border-right:1px solid var(--el-transfer-border-color);height:var(--el-transfer-panel-body-height);overflow:hidden}.el-transfer-panel__body.is-with-footer{border-bottom:none;border-bottom-left-radius:0;border-bottom-right-radius:0}.el-transfer-panel__list{box-sizing:border-box;height:var(--el-transfer-panel-body-height);list-style:none;margin:0;overflow:auto;padding:6px 0}.el-transfer-panel__list.is-filterable{height:calc(100% - var(--el-transfer-filter-height) - 30px);padding-top:0}.el-transfer-panel__item{display:block!important;height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding-left:15px}.el-transfer-panel__item+.el-transfer-panel__item{margin-left:0}.el-transfer-panel__item.el-checkbox{color:var(--el-text-color-regular)}.el-transfer-panel__item:hover{color:var(--el-color-primary)}.el-transfer-panel__item.el-checkbox .el-checkbox__label{box-sizing:border-box;display:block;line-height:var(--el-transfer-item-height);overflow:hidden;padding-left:22px;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-transfer-panel__item .el-checkbox__input{position:absolute;top:8px}.el-transfer-panel__filter{box-sizing:border-box;padding:15px;text-align:center}.el-transfer-panel__filter .el-input__inner{box-sizing:border-box;display:inline-block;font-size:12px;height:var(--el-transfer-filter-height);width:100%}.el-transfer-panel__filter .el-icon-circle-close{cursor:pointer}.el-transfer-panel .el-transfer-panel__header{align-items:center;background:var(--el-transfer-panel-header-bg-color);border:1px solid var(--el-transfer-border-color);border-top-left-radius:var(--el-transfer-border-radius);border-top-right-radius:var(--el-transfer-border-radius);box-sizing:border-box;color:var(--el-color-black);display:flex;height:var(--el-transfer-panel-header-height);margin:0;padding-left:15px}.el-transfer-panel .el-transfer-panel__header .el-checkbox{align-items:center;display:flex;position:relative;width:100%}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label{color:var(--el-text-color-primary);font-size:16px;font-weight:400}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label span{color:var(--el-text-color-secondary);font-size:12px;font-weight:400;position:absolute;right:15px;top:50%;transform:translate3d(0,-50%,0)}.el-transfer-panel .el-transfer-panel__footer{background:var(--el-bg-color-overlay);border:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);height:var(--el-transfer-panel-footer-height);margin:0;padding:0}.el-transfer-panel .el-transfer-panel__footer:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-transfer-panel .el-transfer-panel__footer .el-checkbox{color:var(--el-text-color-regular);padding-left:20px}.el-transfer-panel .el-transfer-panel__empty{color:var(--el-text-color-secondary);height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);margin:0;padding:6px 15px 0;text-align:center}.el-transfer-panel .el-checkbox__label{padding-left:8px}.el-transfer-panel .el-checkbox__inner{border-radius:3px;height:14px;width:14px}.el-transfer-panel .el-checkbox__inner:after{height:6px;left:4px;width:3px}.el-tree{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder);background:var(--el-fill-color-blank);color:var(--el-tree-text-color);cursor:default;font-size:var(--el-font-size-base);position:relative}.el-tree__empty-block{height:100%;min-height:60px;position:relative;text-align:center;width:100%}.el-tree__empty-text{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.el-tree__drop-indicator{background-color:var(--el-color-primary);height:1px;left:0;position:absolute;right:0}.el-tree-node{outline:none;white-space:nowrap}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{--el-checkbox-height:var(--el-tree-node-content-height);align-items:center;cursor:pointer;display:flex;height:var(--el-tree-node-content-height)}.el-tree-node__content>.el-tree-node__expand-icon{box-sizing:content-box;padding:6px}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{color:var(--el-tree-expand-icon-color);cursor:pointer;font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default;visibility:hidden}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{color:var(--el-tree-expand-icon-color);font-size:var(--el-font-size-base);margin-right:8px}.el-tree-node>.el-tree-node__children{background-color:transparent;overflow:hidden}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-tree-select{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree-select__popper .el-tree-node__expand-icon{margin-left:8px}.el-tree-select__popper .el-tree-node.is-checked>.el-tree-node__content .el-select-dropdown__item.selected:after{content:none}.el-tree-select__popper .el-select-dropdown__list>.el-select-dropdown__item{padding-left:32px}.el-tree-select__popper .el-select-dropdown__item{background:transparent!important;flex:1;height:20px;line-height:20px;padding-left:0}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px;align-items:center;cursor:pointer;display:inline-flex;justify-content:center;outline:none}.el-upload.is-disabled{cursor:not-allowed}.el-upload.is-disabled:focus{color:inherit}.el-upload.is-disabled:focus,.el-upload.is-disabled:focus .el-upload-dragger{border-color:var(--el-border-color-darker)}.el-upload.is-disabled .el-upload-dragger{background-color:var(--el-disabled-bg-color);cursor:not-allowed}.el-upload.is-disabled .el-upload-dragger .el-upload__text{color:var(--el-text-color-placeholder)}.el-upload.is-disabled .el-upload-dragger .el-upload__text em{color:var(--el-disabled-text-color)}.el-upload.is-disabled .el-upload-dragger:hover{border-color:var(--el-border-color-darker)}.el-upload__input{display:none}.el-upload__tip{color:var(--el-text-color-regular);font-size:12px;margin-top:7px}.el-upload iframe{filter:alpha(opacity=0);left:0;opacity:0;position:absolute;top:0;z-index:-1}.el-upload--picture-card{--el-upload-picture-card-size:148px;align-items:center;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:var(--el-upload-picture-card-size);justify-content:center;vertical-align:top;width:var(--el-upload-picture-card-size)}.el-upload--picture-card>i{color:var(--el-text-color-secondary);font-size:28px}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{color:var(--el-color-primary)}.el-upload:focus,.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;cursor:pointer;overflow:hidden;padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);position:relative;text-align:center}.el-upload-dragger .el-icon--upload{color:var(--el-text-color-placeholder);font-size:67px;line-height:50px;margin-bottom:16px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary);padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px)}.el-upload-list{list-style:none;margin:10px 0 0;padding:0;position:relative}.el-upload-list__item{border-radius:4px;box-sizing:border-box;color:var(--el-text-color-regular);font-size:14px;margin-bottom:5px;position:relative;transition:all .5s cubic-bezier(.55,0,.1,1);width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{color:var(--el-text-color-regular);cursor:pointer;display:none;opacity:.75;position:absolute;right:5px;top:50%;transform:translateY(-50%);transition:opacity var(--el-transition-duration)}.el-upload-list__item .el-icon--close:hover{color:var(--el-color-primary);opacity:1}.el-upload-list__item .el-icon--close-tip{color:var(--el-color-primary);cursor:pointer;display:none;font-size:12px;font-style:normal;opacity:1;position:absolute;right:5px;top:1px}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;flex-direction:column;justify-content:center;margin-left:4px;width:calc(100% - 30px)}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list__item-name{align-items:center;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);padding:0 4px;text-align:center;transition:color var(--el-transition-duration)}.el-upload-list__item-name .el-icon{color:var(--el-text-color-secondary);margin-right:6px}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{align-items:center;display:none;height:100%;justify-content:center;line-height:inherit;position:absolute;right:5px;top:0;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{color:var(--el-text-color-regular);display:none;font-size:12px;position:absolute;right:10px;top:0}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:inline-flex;height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;overflow:hidden;padding:0;width:var(--el-upload-list-picture-card-size)}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:block;opacity:0}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{height:100%;-o-object-fit:contain;object-fit:contain;width:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{align-items:center;background-color:var(--el-overlay-color-lighter);color:#fff;cursor:default;display:inline-flex;font-size:20px;height:100%;justify-content:center;left:0;opacity:0;position:absolute;top:0;transition:opacity var(--el-transition-duration);width:100%}.el-upload-list--picture-card .el-upload-list__item-actions span{cursor:pointer;display:none}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:16px}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{color:inherit;font-size:inherit;position:static}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{bottom:auto;left:50%;top:50%;transform:translate(-50%,-50%);width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{align-items:center;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:flex;margin-top:10px;overflow:hidden;padding:10px;z-index:0}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{display:inline-flex;opacity:0}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{align-items:center;background-color:var(--el-color-white);display:inline-flex;height:70px;justify-content:center;-o-object-fit:contain;object-fit:contain;position:relative;width:70px;z-index:1}.el-upload-list--picture .el-upload-list__item-status-label{background:var(--el-color-success);height:26px;position:absolute;right:-17px;text-align:center;top:-7px;transform:rotate(45deg);width:46px}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{cursor:default;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:10}.el-upload-cover:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;height:100%;width:100%}.el-upload-cover__label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-cover__label i{color:#fff;font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-cover__progress{display:inline-block;position:static;vertical-align:middle;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{height:100%;left:0;position:absolute;top:0;width:100%}.el-upload-cover__interact{background-color:var(--el-overlay-color-light);bottom:0;height:100%;left:0;position:absolute;text-align:center;width:100%}.el-upload-cover__interact .btn{color:#fff;cursor:pointer;display:inline-block;font-size:14px;margin-top:60px;transition:var(--el-transition-md-fade);vertical-align:middle}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{background-color:#fff;bottom:0;color:var(--el-text-color-primary);font-size:14px;font-weight:400;height:36px;left:0;line-height:36px;margin:0;overflow:hidden;padding:0 10px;position:absolute;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-vl__wrapper{position:relative}.el-vl__wrapper.always-on .el-virtual-scrollbar,.el-vl__wrapper:hover .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity .34s ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{color:var(--el-statistic-title-color);font-size:var(--el-statistic-title-font-size);font-weight:var(--el-statistic-title-font-weight);line-height:20px;margin-bottom:4px}.el-statistic__content{color:var(--el-statistic-content-color);font-size:var(--el-statistic-content-font-size);font-weight:var(--el-statistic-content-font-weight)}.el-statistic__value{display:inline-block}.el-statistic__prefix{display:inline-block;margin-right:4px}.el-statistic__suffix{display:inline-block;margin-left:4px}.el-tour{--el-tour-width:520px;--el-tour-padding-primary:12px;--el-tour-font-line-height:var(--el-font-line-height-primary);--el-tour-title-font-size:16px;--el-tour-title-text-color:var(--el-text-color-primary);--el-tour-title-font-weight:400;--el-tour-close-color:var(--el-color-info);--el-tour-font-size:14px;--el-tour-color:var(--el-text-color-primary);--el-tour-bg-color:var(--el-bg-color);--el-tour-border-radius:4px}.el-tour__hollow{transition:all var(--el-transition-duration) ease}.el-tour__content{border-radius:var(--el-tour-border-radius);box-shadow:var(--el-box-shadow-light);outline:none;overflow-wrap:break-word;padding:var(--el-tour-padding-primary);width:var(--el-tour-width)}.el-tour__arrow,.el-tour__content{background:var(--el-tour-bg-color);box-sizing:border-box}.el-tour__arrow{height:10px;pointer-events:none;position:absolute;transform:rotate(45deg);width:10px}.el-tour__content[data-side^=top] .el-tour__arrow{border-left-color:transparent;border-top-color:transparent}.el-tour__content[data-side^=bottom] .el-tour__arrow{border-bottom-color:transparent;border-right-color:transparent}.el-tour__content[data-side^=left] .el-tour__arrow{border-bottom-color:transparent;border-left-color:transparent}.el-tour__content[data-side^=right] .el-tour__arrow{border-right-color:transparent;border-top-color:transparent}.el-tour__content[data-side^=top] .el-tour__arrow{bottom:-5px}.el-tour__content[data-side^=bottom] .el-tour__arrow{top:-5px}.el-tour__content[data-side^=left] .el-tour__arrow{right:-5px}.el-tour__content[data-side^=right] .el-tour__arrow{left:-5px}.el-tour__closebtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:40px;outline:none;padding:0;position:absolute;right:0;top:0;width:40px}.el-tour__closebtn .el-tour__close{color:var(--el-tour-close-color);font-size:inherit}.el-tour__closebtn:focus .el-tour__close,.el-tour__closebtn:hover .el-tour__close{color:var(--el-color-primary)}.el-tour__header{padding-bottom:var(--el-tour-padding-primary)}.el-tour__header.show-close{padding-right:calc(var(--el-tour-padding-primary) + var(--el-message-close-size, 16px))}.el-tour__title{color:var(--el-tour-title-text-color);font-size:var(--el-tour-title-font-size);font-weight:var(--el-tour-title-font-weight);line-height:var(--el-tour-font-line-height)}.el-tour__body{color:var(--el-tour-text-color);font-size:var(--el-tour-font-size)}.el-tour__body img,.el-tour__body video{max-width:100%}.el-tour__footer{box-sizing:border-box;display:flex;justify-content:space-between;padding-top:var(--el-tour-padding-primary)}.el-tour__content .el-tour-indicators{display:inline-block;flex:1}.el-tour__content .el-tour-indicator{background:var(--el-color-info-light-9);border-radius:50%;display:inline-block;height:6px;margin-right:6px;width:6px}.el-tour__content .el-tour-indicator.is-active{background:var(--el-color-primary)}.el-tour.el-tour--primary{--el-tour-title-text-color:#fff;--el-tour-text-color:#fff;--el-tour-bg-color:var(--el-color-primary);--el-tour-close-color:#fff}.el-tour.el-tour--primary .el-tour__closebtn:focus .el-tour__close,.el-tour.el-tour--primary .el-tour__closebtn:hover .el-tour__close{color:var(--el-tour-title-text-color)}.el-tour.el-tour--primary .el-button--default{background:#fff;border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-tour.el-tour--primary .el-button--primary{border-color:#fff}.el-tour.el-tour--primary .el-tour-indicator{background:#ffffff26}.el-tour.el-tour--primary .el-tour-indicator.is-active{background:#fff}.el-tour-parent--hidden{overflow:hidden}.el-anchor{--el-anchor-bg-color:var(--el-bg-color);--el-anchor-padding-indent:14px;--el-anchor-line-height:22px;--el-anchor-font-size:12px;--el-anchor-color:var(--el-text-color-secondary);--el-anchor-active-color:var(--el-color-primary);--el-anchor-marker-bg-color:var(--el-color-primary);background-color:var(--el-anchor-bg-color);position:relative}.el-anchor__marker{background-color:var(--el-anchor-marker-bg-color);border-radius:4px;opacity:0;position:absolute;z-index:0}.el-anchor.el-anchor--vertical .el-anchor__marker{height:14px;left:0;top:8px;transition:top .25s ease-in-out,opacity .25s;width:4px}.el-anchor.el-anchor--vertical .el-anchor__list{padding-left:var(--el-anchor-padding-indent)}.el-anchor.el-anchor--vertical.el-anchor--underline:before{background-color:#0505050f;content:"";height:100%;left:0;position:absolute;width:2px}.el-anchor.el-anchor--vertical.el-anchor--underline .el-anchor__marker{border-radius:unset;width:2px}.el-anchor.el-anchor--horizontal .el-anchor__marker{bottom:0;height:2px;transition:left .25s ease-in-out,opacity .25s,width .25s;width:20px}.el-anchor.el-anchor--horizontal .el-anchor__list{display:flex;padding-bottom:4px}.el-anchor.el-anchor--horizontal .el-anchor__list .el-anchor__item{padding-left:16px}.el-anchor.el-anchor--horizontal .el-anchor__list .el-anchor__item:first-child{padding-left:0}.el-anchor.el-anchor--horizontal.el-anchor--underline:before{background-color:#0505050f;bottom:0;content:"";height:2px;position:absolute;width:100%}.el-anchor.el-anchor--horizontal.el-anchor--underline .el-anchor__marker{border-radius:unset;height:2px}.el-anchor__item{display:flex;flex-direction:column;overflow:hidden}.el-anchor__link{cursor:pointer;font-size:var(--el-anchor-font-size);line-height:var(--el-anchor-line-height);max-width:100%;outline:none;overflow:hidden;padding:4px 0;text-decoration:none;text-overflow:ellipsis;transition:color var(--el-transition-duration);white-space:nowrap}.el-anchor__link,.el-anchor__link:focus,.el-anchor__link:hover{color:var(--el-anchor-color)}.el-anchor__link.is-active{color:var(--el-anchor-active-color)}.el-anchor .el-anchor__list .el-anchor__item a{display:inline-block}.el-segmented--vertical{flex-direction:column}.el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented{--el-segmented-color:var(--el-text-color-regular);--el-segmented-bg-color:var(--el-fill-color-light);--el-segmented-padding:2px;--el-segmented-item-selected-color:var(--el-color-white);--el-segmented-item-selected-bg-color:var(--el-color-primary);--el-segmented-item-selected-disabled-bg-color:var(--el-color-primary-light-5);--el-segmented-item-hover-color:var(--el-text-color-primary);--el-segmented-item-hover-bg-color:var(--el-fill-color-dark);--el-segmented-item-active-bg-color:var(--el-fill-color-darker);--el-segmented-item-disabled-color:var(--el-text-color-placeholder);align-items:stretch;background:var(--el-segmented-bg-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-segmented-color);display:inline-flex;font-size:14px;min-height:32px;padding:var(--el-segmented-padding)}.el-segmented__group{align-items:stretch;display:flex;position:relative;width:100%}.el-segmented__item-selected{background:var(--el-segmented-item-selected-bg-color);border-radius:calc(var(--el-border-radius-base) - 2px);height:100%;left:0;pointer-events:none;position:absolute;top:0;transition:all .3s;width:10px}.el-segmented__item-selected.is-disabled{background:var(--el-segmented-item-selected-disabled-bg-color)}.el-segmented__item-selected.is-focus-visible:before{border-radius:inherit;content:"";top:0;right:0;bottom:0;left:0;outline:2px solid var(--el-segmented-item-selected-bg-color);outline-offset:1px;position:absolute}.el-segmented__item{align-items:center;border-radius:calc(var(--el-border-radius-base) - 2px);cursor:pointer;display:flex;flex:1;padding:0 11px}.el-segmented__item:not(.is-disabled):not(.is-selected):hover{background:var(--el-segmented-item-hover-bg-color);color:var(--el-segmented-item-hover-color)}.el-segmented__item:not(.is-disabled):not(.is-selected):active{background:var(--el-segmented-item-active-bg-color)}.el-segmented__item.is-selected,.el-segmented__item.is-selected.is-disabled{color:var(--el-segmented-item-selected-color)}.el-segmented__item.is-disabled{color:var(--el-segmented-item-disabled-color);cursor:not-allowed}.el-segmented__item-input{height:0;margin:0;opacity:0;pointer-events:none;position:absolute;width:0}.el-segmented__item-label{flex:1;line-height:normal;overflow:hidden;text-align:center;text-overflow:ellipsis;transition:color .3s;white-space:nowrap;z-index:1}.el-segmented.is-block{display:flex}.el-segmented.is-block .el-segmented__item{min-width:0}.el-segmented--large{border-radius:var(--el-border-radius-base);font-size:16px;min-height:40px}.el-segmented--large .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 2px)}.el-segmented--large .el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented--large .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 2px);padding:0 11px}.el-segmented--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:14px;min-height:24px}.el-segmented--small .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 3px)}.el-segmented--small .el-segmented--vertical .el-segmented__item{padding:7px}.el-segmented--small .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 3px);padding:0 7px}.el-mention{position:relative;width:100%}.el-mention__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-mention__popper.el-popper,.el-mention__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-mention__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-mention-dropdown{--el-mention-font-size:var(--el-font-size-base);--el-mention-bg-color:var(--el-bg-color-overlay);--el-mention-shadow:var(--el-box-shadow-light);--el-mention-border:1px solid var(--el-border-color-light);--el-mention-option-color:var(--el-text-color-regular);--el-mention-option-height:34px;--el-mention-option-min-width:100px;--el-mention-option-hover-background:var(--el-fill-color-light);--el-mention-option-selected-color:var(--el-color-primary);--el-mention-option-disabled-color:var(--el-text-color-placeholder);--el-mention-option-loading-color:var(--el-text-color-secondary);--el-mention-option-loading-padding:10px 0;--el-mention-max-height:174px;--el-mention-padding:6px 0;--el-mention-header-padding:10px;--el-mention-footer-padding:10px}.el-mention-dropdown__item{box-sizing:border-box;color:var(--el-mention-option-color);cursor:pointer;font-size:var(--el-mention-font-size);height:var(--el-mention-option-height);line-height:var(--el-mention-option-height);min-width:var(--el-mention-option-min-width);overflow:hidden;padding:0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-mention-dropdown__item.is-hovering{background-color:var(--el-mention-option-hover-background)}.el-mention-dropdown__item.is-selected{color:var(--el-mention-option-selected-color);font-weight:700}.el-mention-dropdown__item.is-disabled{background-color:unset;color:var(--el-mention-option-disabled-color);cursor:not-allowed}.el-mention-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-mention-dropdown__loading{color:var(--el-mention-option-loading-color);font-size:12px;margin:0;min-width:var(--el-mention-option-min-width);padding:10px 0;text-align:center}.el-mention-dropdown__wrap{max-height:var(--el-mention-max-height)}.el-mention-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:var(--el-mention-padding)}.el-mention-dropdown__header{border-bottom:var(--el-mention-border);padding:var(--el-mention-header-padding)}.el-mention-dropdown__footer{border-top:var(--el-mention-border);padding:var(--el-mention-footer-padding)}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121.3,187.1,255);--el-color-primary-light-5:rgb(159.5,206.5,255);--el-color-primary-light-7:rgb(197.7,225.9,255);--el-color-primary-light-8:rgb(216.8,235.6,255);--el-color-primary-light-9:rgb(235.9,245.3,255);--el-color-primary-dark-2:rgb(51.2,126.4,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(148.6,212.3,117.1);--el-color-success-light-5:rgb(179,224.5,156.5);--el-color-success-light-7:rgb(209.4,236.7,195.9);--el-color-success-light-8:rgb(224.6,242.8,215.6);--el-color-success-light-9:rgb(239.8,248.9,235.3);--el-color-success-dark-2:rgb(82.4,155.2,46.4);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(237.5,189.9,118.5);--el-color-warning-light-5:rgb(242.5,208.5,157.5);--el-color-warning-light-7:rgb(247.5,227.1,196.5);--el-color-warning-light-8:rgb(250,236.4,216);--el-color-warning-light-9:rgb(252.5,245.7,235.5);--el-color-warning-dark-2:rgb(184,129.6,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152.1,152.1);--el-color-danger-light-5:rgb(250,181.5,181.5);--el-color-danger-light-7:rgb(252,210.9,210.9);--el-color-danger-light-8:rgb(253,225.6,225.6);--el-color-danger-light-9:rgb(254,240.3,240.3);--el-color-danger-dark-2:rgb(196,86.4,86.4);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152.1,152.1);--el-color-error-light-5:rgb(250,181.5,181.5);--el-color-error-light-7:rgb(252,210.9,210.9);--el-color-error-light-8:rgb(253,225.6,225.6);--el-color-error-light-9:rgb(254,240.3,240.3);--el-color-error-dark-2:rgb(196,86.4,86.4);--el-color-info:#909399;--el-color-info-light-3:rgb(177.3,179.4,183.6);--el-color-info-light-5:rgb(199.5,201,204);--el-color-info-light-7:rgb(221.7,222.6,224.4);--el-color-info-light-8:rgb(232.8,233.4,234.6);--el-color-info-light-9:rgb(243.9,244.2,244.8);--el-color-info-dark-2:rgb(115.2,117.6,122.4);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:14px;--el-alert-title-with-description-font-size:16px;--el-alert-description-font-size:14px;--el-alert-close-font-size:16px;--el-alert-close-customed-font-size:14px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;align-items:center;background-color:var(--el-color-white);border-radius:var(--el-alert-border-radius-base);box-sizing:border-box;display:flex;margin:0;opacity:1;overflow:hidden;padding:var(--el-alert-padding);position:relative;transition:opacity var(--el-transition-duration-fast);width:100%}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn,.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color)}.el-alert--success.is-light,.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color)}.el-alert--info.is-light,.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color)}.el-alert--warning.is-light,.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color)}.el-alert--error.is-light,.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:flex;flex-direction:column;gap:4px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);margin-right:8px;width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);margin-right:12px;width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:24px}.el-alert__title.with-description{font-size:var(--el-alert-title-with-description-font-size)}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:0}.el-alert .el-alert__close-btn{cursor:pointer;font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;right:16px;top:12px}.el-alert .el-alert__close-btn.is-customed{font-size:var(--el-alert-close-customed-font-size);font-style:normal;line-height:24px;top:8px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px)}.el-input__inner{-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;cursor:not-allowed}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-input-number{display:inline-flex;line-height:30px;position:relative;vertical-align:middle;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large.is-controls-right .el-input--large .el-input__wrapper{padding-right:47px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small.is-controls-right .el-input--small .el-input__wrapper{padding-right:31px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:var(--el-font-size-base);height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table--fit .el-table__inner-wrapper:before{width:100%}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:var(--el-font-size-base)}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:var(--el-font-size-extra-small)}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell,.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{color:var(--el-bg-color)}.el-popper.is-dark,.el-popper.is-dark>.el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark>.el-popper__arrow:before{right:0}.el-popper.is-light,.el-popper.is-light>.el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light>.el-popper__arrow:before{right:0}.el-popper.is-pure{padding:0}.el-popper__arrow,.el-popper__arrow:before{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";transform:rotate(45deg)}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#fff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag,.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-text-color:var(--el-color-white)}.el-tag--dark,.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain,.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.draggable-dialog[data-v-330ab24e]{width:400px;position:fixed;top:0;left:0;background-color:#fff;border-radius:8px;box-shadow:0 4px 12px #00000026;overflow:hidden;z-index:1000}.draggable-dialog .icon[data-v-330ab24e]{width:16px;height:16px;margin-left:auto;cursor:pointer}.draggable-dialog .header-flex[data-v-330ab24e]{display:flex;align-items:center}.draggable-dialog .isexpand[data-v-330ab24e]{margin-bottom:8px;border-bottom:.5px solid #ccc;padding-bottom:4px}.draggable-dialog .draggable-title[data-v-330ab24e]{cursor:move;display:flex;flex-direction:row;justify-content:space-between;align-items:center;height:56px;row-gap:0px;flex-wrap:wrap;align-content:center;background:#4a90e2}.draggable-dialog .draggable-title .avatar-name[data-v-330ab24e]{display:flex;align-items:center}.draggable-dialog .draggable-title .avatar-name .avatar[data-v-330ab24e]{width:30px;height:32px;margin-left:16px}.draggable-dialog .draggable-title .avatar-name .title[data-v-330ab24e]{font-size:18px;font-weight:700;font-family:Roboto;font-weight:600;letter-spacing:0px;font-feature-settings:"kern" on;color:#fff;margin:4px 4px 0 16px}.draggable-dialog .draggable-title .header-settings[data-v-330ab24e]{margin-left:auto;cursor:pointer;font-size:14px;color:#fff;margin-right:16px;display:flex;align-items:center;gap:8px}.draggable-dialog .draggable-title .header-settings .tips[data-v-330ab24e]{width:18px;height:18px;cursor:pointer;margin-left:auto}.draggable-dialog .main-content[data-v-330ab24e]{background:#0000}.tab-bar[data-v-7271a377]{display:flex;align-items:center;gap:8px;width:100%;padding:9px 8px;box-sizing:border-box}.tab-bar .tab-bar-item[data-v-7271a377]{flex:1;display:flex;align-items:center;justify-content:center;gap:4px;cursor:pointer;padding:6px 12px;border-radius:4px;font-size:14px;font-family:Roboto;font-weight:400;line-height:21px;text-align:center;letter-spacing:0px;font-feature-settings:"kern" on}.tab-bar .tab-bar-item[data-v-7271a377]:hover,.tab-bar .tab-bar-item.active[data-v-7271a377]{background-color:#e6f7ff;color:#4a90e2}.content-body[data-v-7271a377]{padding:16px;box-sizing:border-box;background-color:#f5f5f5}.body-box[data-v-7271a377]{border-radius:8px;opacity:1;display:flex;flex-direction:column;padding:12px;gap:0px 10px;flex-wrap:wrap;align-content:flex-start;background:linear-gradient(0deg,#0000,#0000),#fff;box-shadow:0 1px 3px #0000001a}.card-title[data-v-7271a377]{display:flex;align-items:center;gap:4px;font-family:Roboto;font-size:14px;font-weight:600;line-height:21px;letter-spacing:0px;font-feature-settings:"kern" on;color:#333;margin-bottom:8px}.start-parse[data-v-7271a377]{cursor:pointer;height:40px;line-height:40px;border-radius:4px;opacity:1;margin:18px 0;background:#3b82f6;font-family:Roboto;font-size:14px;font-weight:500;text-align:center;letter-spacing:0px;font-feature-settings:"kern" on;color:#fff}.log-generation[data-v-7271a377]{box-sizing:border-box;box-shadow:0 1px 3px #0000001a;background:linear-gradient(0deg,#0000,#0000),#fff;margin-top:16px}.log-generation .log-generation-content[data-v-7271a377]{width:100%;max-height:120px;overflow-y:auto}.log-generation .log-generation-content[data-v-7271a377]::-webkit-scrollbar{width:2px}.log-generation .value[data-v-7271a377]{color:#000;font-size:13px;font-weight:400;line-height:20px;letter-spacing:0px;font-feature-settings:"kern" on;font-family:Roboto}.settings-main[data-v-7271a377]{width:100%;display:flex;flex-direction:column;gap:12px}.settings-section[data-v-7271a377]{width:100%;display:flex;align-items:center}.settings-section .settings-switch[data-v-7271a377]{margin-left:auto}.settings-section .title[data-v-7271a377]{display:flex;flex-direction:column;gap:4px}.settings-section .title .title-text[data-v-7271a377]{height:24px;background:#0000;opacity:1;font-family:Roboto;font-size:16px;font-weight:400;line-height:24px;letter-spacing:0px;font-feature-settings:"kern" on;color:#000}.settings-section .title .sub-title[data-v-7271a377]{opacity:1;font-family:Roboto;font-size:12px;font-weight:400;line-height:18px;letter-spacing:0px;font-feature-settings:"kern" on;color:#666}.guide .guide-content[data-v-7271a377]{display:flex;flex-direction:column;gap:12px;margin-top:8px}.guide .guide-content .guide-content-item[data-v-7271a377]{display:flex;align-items:start;gap:10px}.guide .guide-content .guide-content-item .guide-content-index[data-v-7271a377]{width:20px;height:20px;text-align:center;line-height:20px;border-radius:50%;background-color:#e6f7ff;color:#53aeed}.guide .guide-content .guide-content-item .guide-content-content[data-v-7271a377]{flex:1;color:#333;font-size:13px}.guide .section p[data-v-7271a377]{line-height:24px;color:#303133}.guide .tip[data-v-7271a377]{margin:10px 0}.guide .tip .title[data-v-7271a377]{font-weight:700;margin-bottom:10px}.guide .tip p[data-v-7271a377]{color:#dc3545}.keys .userinfo[data-v-7271a377]{margin:20px 0 0}.keys .userinfo .el-row[data-v-7271a377]{margin-bottom:10px}.keys .validate-key[data-v-7271a377]{margin:10px 0 0;display:flex;gap:10px}.keys .key-btn[data-v-7271a377]{cursor:pointer;width:100%;margin:18px auto} `);

(function () {
  'use strict';

  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_main_001 = __commonJS({
    "main-CdfhhNbq.js"(exports, module) {
      /**
      * @vue/shared v3.5.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function makeMap(str) {
        const map2 = /* @__PURE__ */ Object.create(null);
        for (const key of str.split(",")) map2[key] = 1;
        return (val) => val in map2;
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
      (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      const hasOwnProperty$d = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
      const isArray$1 = Array.isArray;
      const isMap = (val) => toTypeString(val) === "[object Map]";
      const isSet = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction(
        (str) => {
          return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
        }
      );
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize = cacheStringFunction((str) => {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      const toHandlerKey = cacheStringFunction(
        (str) => {
          const s2 = str ? `on${capitalize(str)}` : ``;
          return s2;
        }
      );
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, ...arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](...arg);
        }
      };
      const def = (obj, key, value, writable = false) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          writable,
          value
        });
      };
      const looseToNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      const toNumber$1 = (val) => {
        const n = isString$1(val) ? Number(val) : NaN;
        return isNaN(n) ? val : n;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$1(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$1(value) || isObject$1(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$1(value)) {
          res = value;
        } else if (isArray$1(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$1(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a2, b2) {
        if (a2.length !== b2.length) return false;
        let equal = true;
        for (let i = 0; equal && i < a2.length; i++) {
          equal = looseEqual(a2[i], b2[i]);
        }
        return equal;
      }
      function looseEqual(a2, b2) {
        if (a2 === b2) return true;
        let aValidType = isDate(a2);
        let bValidType = isDate(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
        }
        aValidType = isSymbol$1(a2);
        bValidType = isSymbol$1(b2);
        if (aValidType || bValidType) {
          return a2 === b2;
        }
        aValidType = isArray$1(a2);
        bValidType = isArray$1(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
        }
        aValidType = isObject$1(a2);
        bValidType = isObject$1(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a2).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a2) {
            const aHasKey = a2.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a2) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const isRef$1 = (val) => {
        return !!(val && val["__v_isRef"] === true);
      };
      const toDisplayString = (val) => {
        return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (isRef$1(val)) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce(
              (entries, [key, val2], i) => {
                entries[stringifySymbol(key, i) + " =>"] = val2;
                return entries;
              },
              {}
            )
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
          };
        } else if (isSymbol$1(val)) {
          return stringifySymbol(val);
        } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$2(val)) {
          return String(val);
        }
        return val;
      };
      const stringifySymbol = (v2, i = "") => {
        var _a2;
        return (
          // Symbol.description in es2019+ so we need to cast here to pass
          // the lib: es2016 check
          isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i})` : v2
        );
      };
      /**
      * @vue/reactivity v3.5.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this._isPaused = false;
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        pause() {
          if (this._active) {
            this._isPaused = true;
            let i, l2;
            if (this.scopes) {
              for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                this.scopes[i].pause();
              }
            }
            for (i = 0, l2 = this.effects.length; i < l2; i++) {
              this.effects[i].pause();
            }
          }
        }
        /**
         * Resumes the effect scope, including all child scopes and effects.
         */
        resume() {
          if (this._active) {
            if (this._isPaused) {
              this._isPaused = false;
              let i, l2;
              if (this.scopes) {
                for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                  this.scopes[i].resume();
                }
              }
              for (i = 0, l2 = this.effects.length; i < l2; i++) {
                this.effects[i].resume();
              }
            }
          }
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            this._active = false;
            let i, l2;
            for (i = 0, l2 = this.effects.length; i < l2; i++) {
              this.effects[i].stop();
            }
            this.effects.length = 0;
            for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
              this.cleanups[i]();
            }
            this.cleanups.length = 0;
            if (this.scopes) {
              for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                this.scopes[i].stop(true);
              }
              this.scopes.length = 0;
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
          }
        }
      }
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2, failSilently = false) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      let activeSub;
      const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
      class ReactiveEffect {
        constructor(fn2) {
          this.fn = fn2;
          this.deps = void 0;
          this.depsTail = void 0;
          this.flags = 1 | 4;
          this.next = void 0;
          this.cleanup = void 0;
          this.scheduler = void 0;
          if (activeEffectScope && activeEffectScope.active) {
            activeEffectScope.effects.push(this);
          }
        }
        pause() {
          this.flags |= 64;
        }
        resume() {
          if (this.flags & 64) {
            this.flags &= -65;
            if (pausedQueueEffects.has(this)) {
              pausedQueueEffects.delete(this);
              this.trigger();
            }
          }
        }
        /**
         * @internal
         */
        notify() {
          if (this.flags & 2 && !(this.flags & 32)) {
            return;
          }
          if (!(this.flags & 8)) {
            batch(this);
          }
        }
        run() {
          if (!(this.flags & 1)) {
            return this.fn();
          }
          this.flags |= 2;
          cleanupEffect(this);
          prepareDeps(this);
          const prevEffect = activeSub;
          const prevShouldTrack = shouldTrack;
          activeSub = this;
          shouldTrack = true;
          try {
            return this.fn();
          } finally {
            cleanupDeps(this);
            activeSub = prevEffect;
            shouldTrack = prevShouldTrack;
            this.flags &= -3;
          }
        }
        stop() {
          if (this.flags & 1) {
            for (let link = this.deps; link; link = link.nextDep) {
              removeSub(link);
            }
            this.deps = this.depsTail = void 0;
            cleanupEffect(this);
            this.onStop && this.onStop();
            this.flags &= -2;
          }
        }
        trigger() {
          if (this.flags & 64) {
            pausedQueueEffects.add(this);
          } else if (this.scheduler) {
            this.scheduler();
          } else {
            this.runIfDirty();
          }
        }
        /**
         * @internal
         */
        runIfDirty() {
          if (isDirty(this)) {
            this.run();
          }
        }
        get dirty() {
          return isDirty(this);
        }
      }
      let batchDepth = 0;
      let batchedSub;
      let batchedComputed;
      function batch(sub, isComputed2 = false) {
        sub.flags |= 8;
        if (isComputed2) {
          sub.next = batchedComputed;
          batchedComputed = sub;
          return;
        }
        sub.next = batchedSub;
        batchedSub = sub;
      }
      function startBatch() {
        batchDepth++;
      }
      function endBatch() {
        if (--batchDepth > 0) {
          return;
        }
        if (batchedComputed) {
          let e = batchedComputed;
          batchedComputed = void 0;
          while (e) {
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            e = next;
          }
        }
        let error;
        while (batchedSub) {
          let e = batchedSub;
          batchedSub = void 0;
          while (e) {
            const next = e.next;
            e.next = void 0;
            e.flags &= -9;
            if (e.flags & 1) {
              try {
                ;
                e.trigger();
              } catch (err) {
                if (!error) error = err;
              }
            }
            e = next;
          }
        }
        if (error) throw error;
      }
      function prepareDeps(sub) {
        for (let link = sub.deps; link; link = link.nextDep) {
          link.version = -1;
          link.prevActiveLink = link.dep.activeLink;
          link.dep.activeLink = link;
        }
      }
      function cleanupDeps(sub) {
        let head;
        let tail = sub.depsTail;
        let link = tail;
        while (link) {
          const prev = link.prevDep;
          if (link.version === -1) {
            if (link === tail) tail = prev;
            removeSub(link);
            removeDep(link);
          } else {
            head = link;
          }
          link.dep.activeLink = link.prevActiveLink;
          link.prevActiveLink = void 0;
          link = prev;
        }
        sub.deps = head;
        sub.depsTail = tail;
      }
      function isDirty(sub) {
        for (let link = sub.deps; link; link = link.nextDep) {
          if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
            return true;
          }
        }
        if (sub._dirty) {
          return true;
        }
        return false;
      }
      function refreshComputed(computed2) {
        if (computed2.flags & 4 && !(computed2.flags & 16)) {
          return;
        }
        computed2.flags &= -17;
        if (computed2.globalVersion === globalVersion) {
          return;
        }
        computed2.globalVersion = globalVersion;
        const dep = computed2.dep;
        computed2.flags |= 2;
        if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
          computed2.flags &= -3;
          return;
        }
        const prevSub = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = computed2;
        shouldTrack = true;
        try {
          prepareDeps(computed2);
          const value = computed2.fn(computed2._value);
          if (dep.version === 0 || hasChanged(value, computed2._value)) {
            computed2._value = value;
            dep.version++;
          }
        } catch (err) {
          dep.version++;
          throw err;
        } finally {
          activeSub = prevSub;
          shouldTrack = prevShouldTrack;
          cleanupDeps(computed2);
          computed2.flags &= -3;
        }
      }
      function removeSub(link, soft = false) {
        const { dep, prevSub, nextSub } = link;
        if (prevSub) {
          prevSub.nextSub = nextSub;
          link.prevSub = void 0;
        }
        if (nextSub) {
          nextSub.prevSub = prevSub;
          link.nextSub = void 0;
        }
        if (dep.subs === link) {
          dep.subs = prevSub;
          if (!prevSub && dep.computed) {
            dep.computed.flags &= -5;
            for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
              removeSub(l2, true);
            }
          }
        }
        if (!soft && !--dep.sc && dep.map) {
          dep.map.delete(dep.key);
        }
      }
      function removeDep(link) {
        const { prevDep, nextDep } = link;
        if (prevDep) {
          prevDep.nextDep = nextDep;
          link.prevDep = void 0;
        }
        if (nextDep) {
          nextDep.prevDep = prevDep;
          link.nextDep = void 0;
        }
      }
      let shouldTrack = true;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function cleanupEffect(e) {
        const { cleanup } = e;
        e.cleanup = void 0;
        if (cleanup) {
          const prevSub = activeSub;
          activeSub = void 0;
          try {
            cleanup();
          } finally {
            activeSub = prevSub;
          }
        }
      }
      let globalVersion = 0;
      class Link {
        constructor(sub, dep) {
          this.sub = sub;
          this.dep = dep;
          this.version = dep.version;
          this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
        }
      }
      class Dep {
        constructor(computed2) {
          this.computed = computed2;
          this.version = 0;
          this.activeLink = void 0;
          this.subs = void 0;
          this.map = void 0;
          this.key = void 0;
          this.sc = 0;
        }
        track(debugInfo) {
          if (!activeSub || !shouldTrack || activeSub === this.computed) {
            return;
          }
          let link = this.activeLink;
          if (link === void 0 || link.sub !== activeSub) {
            link = this.activeLink = new Link(activeSub, this);
            if (!activeSub.deps) {
              activeSub.deps = activeSub.depsTail = link;
            } else {
              link.prevDep = activeSub.depsTail;
              activeSub.depsTail.nextDep = link;
              activeSub.depsTail = link;
            }
            addSub(link);
          } else if (link.version === -1) {
            link.version = this.version;
            if (link.nextDep) {
              const next = link.nextDep;
              next.prevDep = link.prevDep;
              if (link.prevDep) {
                link.prevDep.nextDep = next;
              }
              link.prevDep = activeSub.depsTail;
              link.nextDep = void 0;
              activeSub.depsTail.nextDep = link;
              activeSub.depsTail = link;
              if (activeSub.deps === link) {
                activeSub.deps = next;
              }
            }
          }
          return link;
        }
        trigger(debugInfo) {
          this.version++;
          globalVersion++;
          this.notify(debugInfo);
        }
        notify(debugInfo) {
          startBatch();
          try {
            if (false) ;
            for (let link = this.subs; link; link = link.prevSub) {
              if (link.sub.notify()) {
                ;
                link.sub.dep.notify();
              }
            }
          } finally {
            endBatch();
          }
        }
      }
      function addSub(link) {
        link.dep.sc++;
        if (link.sub.flags & 4) {
          const computed2 = link.dep.computed;
          if (computed2 && !link.dep.subs) {
            computed2.flags |= 4 | 16;
            for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
              addSub(l2);
            }
          }
          const currentTail = link.dep.subs;
          if (currentTail !== link) {
            link.prevSub = currentTail;
            if (currentTail) currentTail.nextSub = link;
          }
          link.dep.subs = link;
        }
      }
      const targetMap = /* @__PURE__ */ new WeakMap();
      const ITERATE_KEY = Symbol(
        ""
      );
      const MAP_KEY_ITERATE_KEY = Symbol(
        ""
      );
      const ARRAY_ITERATE_KEY = Symbol(
        ""
      );
      function track(target, type, key) {
        if (shouldTrack && activeSub) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = new Dep());
            dep.map = depsMap;
            dep.key = key;
          }
          {
            dep.track();
          }
        }
      }
      function trigger(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          globalVersion++;
          return;
        }
        const run = (dep) => {
          if (dep) {
            {
              dep.trigger();
            }
          }
        };
        startBatch();
        if (type === "clear") {
          depsMap.forEach(run);
        } else {
          const targetIsArray = isArray$1(target);
          const isArrayIndex = targetIsArray && isIntegerKey(key);
          if (targetIsArray && key === "length") {
            const newLength = Number(newValue);
            depsMap.forEach((dep, key2) => {
              if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
                run(dep);
              }
            });
          } else {
            if (key !== void 0 || depsMap.has(void 0)) {
              run(depsMap.get(key));
            }
            if (isArrayIndex) {
              run(depsMap.get(ARRAY_ITERATE_KEY));
            }
            switch (type) {
              case "add":
                if (!targetIsArray) {
                  run(depsMap.get(ITERATE_KEY));
                  if (isMap(target)) {
                    run(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                } else if (isArrayIndex) {
                  run(depsMap.get("length"));
                }
                break;
              case "delete":
                if (!targetIsArray) {
                  run(depsMap.get(ITERATE_KEY));
                  if (isMap(target)) {
                    run(depsMap.get(MAP_KEY_ITERATE_KEY));
                  }
                }
                break;
              case "set":
                if (isMap(target)) {
                  run(depsMap.get(ITERATE_KEY));
                }
                break;
            }
          }
        }
        endBatch();
      }
      function getDepFromReactive(object, key) {
        const depMap = targetMap.get(object);
        return depMap && depMap.get(key);
      }
      function reactiveReadArray(array) {
        const raw = toRaw(array);
        if (raw === array) return raw;
        track(raw, "iterate", ARRAY_ITERATE_KEY);
        return isShallow(array) ? raw : raw.map(toReactive);
      }
      function shallowReadArray(arr) {
        track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
        return arr;
      }
      const arrayInstrumentations = {
        __proto__: null,
        [Symbol.iterator]() {
          return iterator(this, Symbol.iterator, toReactive);
        },
        concat(...args) {
          return reactiveReadArray(this).concat(
            ...args.map((x2) => isArray$1(x2) ? reactiveReadArray(x2) : x2)
          );
        },
        entries() {
          return iterator(this, "entries", (value) => {
            value[1] = toReactive(value[1]);
            return value;
          });
        },
        every(fn2, thisArg) {
          return apply$1(this, "every", fn2, thisArg, void 0, arguments);
        },
        filter(fn2, thisArg) {
          return apply$1(this, "filter", fn2, thisArg, (v2) => v2.map(toReactive), arguments);
        },
        find(fn2, thisArg) {
          return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
        },
        findIndex(fn2, thisArg) {
          return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
        },
        findLast(fn2, thisArg) {
          return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
        },
        findLastIndex(fn2, thisArg) {
          return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
        },
        // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
        forEach(fn2, thisArg) {
          return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
        },
        includes(...args) {
          return searchProxy(this, "includes", args);
        },
        indexOf(...args) {
          return searchProxy(this, "indexOf", args);
        },
        join(separator) {
          return reactiveReadArray(this).join(separator);
        },
        // keys() iterator only reads `length`, no optimisation required
        lastIndexOf(...args) {
          return searchProxy(this, "lastIndexOf", args);
        },
        map(fn2, thisArg) {
          return apply$1(this, "map", fn2, thisArg, void 0, arguments);
        },
        pop() {
          return noTracking(this, "pop");
        },
        push(...args) {
          return noTracking(this, "push", args);
        },
        reduce(fn2, ...args) {
          return reduce(this, "reduce", fn2, args);
        },
        reduceRight(fn2, ...args) {
          return reduce(this, "reduceRight", fn2, args);
        },
        shift() {
          return noTracking(this, "shift");
        },
        // slice could use ARRAY_ITERATE but also seems to beg for range tracking
        some(fn2, thisArg) {
          return apply$1(this, "some", fn2, thisArg, void 0, arguments);
        },
        splice(...args) {
          return noTracking(this, "splice", args);
        },
        toReversed() {
          return reactiveReadArray(this).toReversed();
        },
        toSorted(comparer) {
          return reactiveReadArray(this).toSorted(comparer);
        },
        toSpliced(...args) {
          return reactiveReadArray(this).toSpliced(...args);
        },
        unshift(...args) {
          return noTracking(this, "unshift", args);
        },
        values() {
          return iterator(this, "values", toReactive);
        }
      };
      function iterator(self2, method, wrapValue) {
        const arr = shallowReadArray(self2);
        const iter = arr[method]();
        if (arr !== self2 && !isShallow(self2)) {
          iter._next = iter.next;
          iter.next = () => {
            const result = iter._next();
            if (result.value) {
              result.value = wrapValue(result.value);
            }
            return result;
          };
        }
        return iter;
      }
      const arrayProto$1 = Array.prototype;
      function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
        const arr = shallowReadArray(self2);
        const needsWrap = arr !== self2 && !isShallow(self2);
        const methodFn = arr[method];
        if (methodFn !== arrayProto$1[method]) {
          const result2 = methodFn.apply(self2, args);
          return needsWrap ? toReactive(result2) : result2;
        }
        let wrappedFn = fn2;
        if (arr !== self2) {
          if (needsWrap) {
            wrappedFn = function(item, index) {
              return fn2.call(this, toReactive(item), index, self2);
            };
          } else if (fn2.length > 2) {
            wrappedFn = function(item, index) {
              return fn2.call(this, item, index, self2);
            };
          }
        }
        const result = methodFn.call(arr, wrappedFn, thisArg);
        return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
      }
      function reduce(self2, method, fn2, args) {
        const arr = shallowReadArray(self2);
        let wrappedFn = fn2;
        if (arr !== self2) {
          if (!isShallow(self2)) {
            wrappedFn = function(acc, item, index) {
              return fn2.call(this, acc, toReactive(item), index, self2);
            };
          } else if (fn2.length > 3) {
            wrappedFn = function(acc, item, index) {
              return fn2.call(this, acc, item, index, self2);
            };
          }
        }
        return arr[method](wrappedFn, ...args);
      }
      function searchProxy(self2, method, args) {
        const arr = toRaw(self2);
        track(arr, "iterate", ARRAY_ITERATE_KEY);
        const res = arr[method](...args);
        if ((res === -1 || res === false) && isProxy(args[0])) {
          args[0] = toRaw(args[0]);
          return arr[method](...args);
        }
        return res;
      }
      function noTracking(self2, method, args = []) {
        pauseTracking();
        startBatch();
        const res = toRaw(self2)[method].apply(self2, args);
        endBatch();
        resetTracking();
        return res;
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      function hasOwnProperty$c(key) {
        if (!isSymbol$1(key)) key = String(key);
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      class BaseReactiveHandler {
        constructor(_isReadonly = false, _isShallow = false) {
          this._isReadonly = _isReadonly;
          this._isShallow = _isShallow;
        }
        get(target, key, receiver) {
          if (key === "__v_skip") return target["__v_skip"];
          const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return isShallow2;
          } else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the receiver is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
              return target;
            }
            return;
          }
          const targetIsArray = isArray$1(target);
          if (!isReadonly2) {
            let fn2;
            if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
              return fn2;
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$c;
            }
          }
          const res = Reflect.get(
            target,
            key,
            // if this is a proxy wrapping a ref, return methods using the raw ref
            // as receiver so that we don't have to call `toRaw` on the ref in all
            // its class methods
            isRef(target) ? target : receiver
          );
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (isShallow2) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$1(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        }
      }
      class MutableReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(false, isShallow2);
        }
        set(target, key, value, receiver) {
          let oldValue = target[key];
          if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
              if (isOldValueReadonly) {
                return false;
              } else {
                oldValue.value = value;
                return true;
              }
            }
          }
          const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(
            target,
            key,
            value,
            isRef(target) ? target : receiver
          );
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        }
        deleteProperty(target, key) {
          const hadKey = hasOwn(target, key);
          target[key];
          const result = Reflect.deleteProperty(target, key);
          if (result && hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        }
        has(target, key) {
          const result = Reflect.has(target, key);
          if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
            track(target, "has", key);
          }
          return result;
        }
        ownKeys(target) {
          track(
            target,
            "iterate",
            isArray$1(target) ? "length" : ITERATE_KEY
          );
          return Reflect.ownKeys(target);
        }
      }
      class ReadonlyReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(true, isShallow2);
        }
        set(target, key) {
          return true;
        }
        deleteProperty(target, key) {
          return true;
        }
      }
      const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
      const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
      const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
      const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
      const toShallow = (value) => value;
      const getProto = (v2) => Reflect.getPrototypeOf(v2);
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          return type === "delete" ? false : type === "clear" ? void 0 : this;
        };
      }
      function createInstrumentations(readonly2, shallow) {
        const instrumentations = {
          get(key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly2) {
              if (hasChanged(key, rawKey)) {
                track(rawTarget, "get", key);
              }
              track(rawTarget, "get", rawKey);
            }
            const { has } = getProto(rawTarget);
            const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
            if (has.call(rawTarget, key)) {
              return wrap(target.get(key));
            } else if (has.call(rawTarget, rawKey)) {
              return wrap(target.get(rawKey));
            } else if (target !== rawTarget) {
              target.get(key);
            }
          },
          get size() {
            const target = this["__v_raw"];
            !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
            return Reflect.get(target, "size", target);
          },
          has(key) {
            const target = this["__v_raw"];
            const rawTarget = toRaw(target);
            const rawKey = toRaw(key);
            if (!readonly2) {
              if (hasChanged(key, rawKey)) {
                track(rawTarget, "has", key);
              }
              track(rawTarget, "has", rawKey);
            }
            return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
          },
          forEach(callback, thisArg) {
            const observed = this;
            const target = observed["__v_raw"];
            const rawTarget = toRaw(target);
            const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
            !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
            return target.forEach((value, key) => {
              return callback.call(thisArg, wrap(value), wrap(key), observed);
            });
          }
        };
        extend(
          instrumentations,
          readonly2 ? {
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear")
          } : {
            add(value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              const target = toRaw(this);
              const proto = getProto(target);
              const hadKey = proto.has.call(target, value);
              if (!hadKey) {
                target.add(value);
                trigger(target, "add", value, value);
              }
              return this;
            },
            set(key, value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              const target = toRaw(this);
              const { has, get: get2 } = getProto(target);
              let hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              const oldValue = get2.call(target, key);
              target.set(key, value);
              if (!hadKey) {
                trigger(target, "add", key, value);
              } else if (hasChanged(value, oldValue)) {
                trigger(target, "set", key, value);
              }
              return this;
            },
            delete(key) {
              const target = toRaw(this);
              const { has, get: get2 } = getProto(target);
              let hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              get2 ? get2.call(target, key) : void 0;
              const result = target.delete(key);
              if (hadKey) {
                trigger(target, "delete", key, void 0);
              }
              return result;
            },
            clear() {
              const target = toRaw(this);
              const hadItems = target.size !== 0;
              const result = target.clear();
              if (hadItems) {
                trigger(
                  target,
                  "clear",
                  void 0,
                  void 0
                );
              }
              return result;
            }
          }
        );
        const iteratorMethods = [
          "keys",
          "values",
          "entries",
          Symbol.iterator
        ];
        iteratorMethods.forEach((method) => {
          instrumentations[method] = createIterableMethod(method, readonly2, shallow);
        });
        return instrumentations;
      }
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = createInstrumentations(isReadonly2, shallow);
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function shallowReadonly(target) {
        return createReactiveObject(
          target,
          true,
          shallowReadonlyHandlers,
          shallowReadonlyCollectionHandlers,
          shallowReadonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$1(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return value ? !!value["__v_raw"] : false;
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
          def(value, "__v_skip", true);
        }
        return value;
      }
      const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
      function isRef(r) {
        return r ? r["__v_isRef"] === true : false;
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, isShallow2) {
          this.dep = new Dep();
          this["__v_isRef"] = true;
          this["__v_isShallow"] = false;
          this._rawValue = isShallow2 ? value : toRaw(value);
          this._value = isShallow2 ? value : toReactive(value);
          this["__v_isShallow"] = isShallow2;
        }
        get value() {
          {
            this.dep.track();
          }
          return this._value;
        }
        set value(newValue) {
          const oldValue = this._rawValue;
          const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
          newValue = useDirectValue ? newValue : toRaw(newValue);
          if (hasChanged(newValue, oldValue)) {
            this._rawValue = newValue;
            this._value = useDirectValue ? newValue : toReactive(newValue);
            {
              this.dep.trigger();
            }
          }
        }
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      function toRefs(object) {
        const ret = isArray$1(object) ? new Array(object.length) : {};
        for (const key in object) {
          ret[key] = propertyToRef(object, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this["__v_isRef"] = true;
          this._value = void 0;
        }
        get value() {
          const val = this._object[this._key];
          return this._value = val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this["__v_isRef"] = true;
          this["__v_isReadonly"] = true;
          this._value = void 0;
        }
        get value() {
          return this._value = this._getter();
        }
      }
      function toRef(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$1(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$1(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
      }
      class ComputedRefImpl {
        constructor(fn2, setter, isSSR) {
          this.fn = fn2;
          this.setter = setter;
          this._value = void 0;
          this.dep = new Dep(this);
          this.__v_isRef = true;
          this.deps = void 0;
          this.depsTail = void 0;
          this.flags = 16;
          this.globalVersion = globalVersion - 1;
          this.next = void 0;
          this.effect = this;
          this["__v_isReadonly"] = !setter;
          this.isSSR = isSSR;
        }
        /**
         * @internal
         */
        notify() {
          this.flags |= 16;
          if (!(this.flags & 8) && // avoid infinite self recursion
          activeSub !== this) {
            batch(this, true);
            return true;
          }
        }
        get value() {
          const link = this.dep.track();
          refreshComputed(this);
          if (link) {
            link.version = this.dep.version;
          }
          return this._value;
        }
        set value(newValue) {
          if (this.setter) {
            this.setter(newValue);
          }
        }
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        if (isFunction$1(getterOrOptions)) {
          getter = getterOrOptions;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, isSSR);
        return cRef;
      }
      const INITIAL_WATCHER_VALUE = {};
      const cleanupMap = /* @__PURE__ */ new WeakMap();
      let activeWatcher = void 0;
      function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
        if (owner) {
          let cleanups = cleanupMap.get(owner);
          if (!cleanups) cleanupMap.set(owner, cleanups = []);
          cleanups.push(cleanupFn);
        }
      }
      function watch$1(source, cb, options = EMPTY_OBJ) {
        const { immediate, deep, once, scheduler, augmentJob, call } = options;
        const reactiveGetter = (source2) => {
          if (deep) return source2;
          if (isShallow(source2) || deep === false || deep === 0)
            return traverse(source2, 1);
          return traverse(source2);
        };
        let effect2;
        let getter;
        let cleanup;
        let boundCleanup;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => reactiveGetter(source);
          forceTrigger = true;
        } else if (isArray$1(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
          getter = () => source.map((s2) => {
            if (isRef(s2)) {
              return s2.value;
            } else if (isReactive(s2)) {
              return reactiveGetter(s2);
            } else if (isFunction$1(s2)) {
              return call ? call(s2, 2) : s2();
            } else ;
          });
        } else if (isFunction$1(source)) {
          if (cb) {
            getter = call ? () => call(source, 2) : source;
          } else {
            getter = () => {
              if (cleanup) {
                pauseTracking();
                try {
                  cleanup();
                } finally {
                  resetTracking();
                }
              }
              const currentEffect = activeWatcher;
              activeWatcher = effect2;
              try {
                return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
              } finally {
                activeWatcher = currentEffect;
              }
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          const depth = deep === true ? Infinity : deep;
          getter = () => traverse(baseGetter(), depth);
        }
        const scope = getCurrentScope();
        const watchHandle = () => {
          effect2.stop();
          if (scope && scope.active) {
            remove(scope.effects, effect2);
          }
        };
        if (once && cb) {
          const _cb = cb;
          cb = (...args) => {
            _cb(...args);
            watchHandle();
          };
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = (immediateFirstRun) => {
          if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
            return;
          }
          if (cb) {
            const newValue = effect2.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue))) {
              if (cleanup) {
                cleanup();
              }
              const currentWatcher = activeWatcher;
              activeWatcher = effect2;
              try {
                const args = [
                  newValue,
                  // pass undefined as the old value when it's changed for the first time
                  oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                  boundCleanup
                ];
                call ? call(cb, 3, args) : (
                  // @ts-expect-error
                  cb(...args)
                );
                oldValue = newValue;
              } finally {
                activeWatcher = currentWatcher;
              }
            }
          } else {
            effect2.run();
          }
        };
        if (augmentJob) {
          augmentJob(job);
        }
        effect2 = new ReactiveEffect(getter);
        effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
        boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
        cleanup = effect2.onStop = () => {
          const cleanups = cleanupMap.get(effect2);
          if (cleanups) {
            if (call) {
              call(cleanups, 4);
            } else {
              for (const cleanup2 of cleanups) cleanup2();
            }
            cleanupMap.delete(effect2);
          }
        };
        if (cb) {
          if (immediate) {
            job(true);
          } else {
            oldValue = effect2.run();
          }
        } else if (scheduler) {
          scheduler(job.bind(null, true), true);
        } else {
          effect2.run();
        }
        watchHandle.pause = effect2.pause.bind(effect2);
        watchHandle.resume = effect2.resume.bind(effect2);
        watchHandle.stop = watchHandle;
        return watchHandle;
      }
      function traverse(value, depth = Infinity, seen) {
        if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        depth--;
        if (isRef(value)) {
          traverse(value.value, depth, seen);
        } else if (isArray$1(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], depth, seen);
          }
        } else if (isSet(value) || isMap(value)) {
          value.forEach((v2) => {
            traverse(v2, depth, seen);
          });
        } else if (isPlainObject$2(value)) {
          for (const key in value) {
            traverse(value[key], depth, seen);
          }
          for (const key of Object.getOwnPropertySymbols(value)) {
            if (Object.prototype.propertyIsEnumerable.call(value, key)) {
              traverse(value[key], depth, seen);
            }
          }
        }
        return value;
      }
      /**
      * @vue/runtime-core v3.5.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const stack = [];
      let isWarning = false;
      function warn$1(msg, ...args) {
        if (isWarning) return;
        isWarning = true;
        pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
              // eslint-disable-next-line no-restricted-syntax
              msg + args.map((a2) => {
                var _a2, _b;
                return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
              }).join(""),
              instance && instance.proxy,
              trace.map(
                ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
              ).join("\n"),
              trace
            ]
          );
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        resetTracking();
        isWarning = false;
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
            last.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
          logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
        const close = `>` + postfix;
        return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
      }
      function formatProps(props) {
        const res = [];
        const keys2 = Object.keys(props);
        keys2.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys2.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (isString$1(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (isFunction$1(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      function callWithErrorHandling(fn2, instance, type, args) {
        try {
          return args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type);
        }
      }
      function callWithAsyncErrorHandling(fn2, instance, type, args) {
        if (isFunction$1(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        if (isArray$1(fn2)) {
          const values = [];
          for (let i = 0; i < fn2.length; i++) {
            values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
          }
          return values;
        }
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          if (errorHandler) {
            pauseTracking();
            callWithErrorHandling(errorHandler, null, 10, [
              err,
              exposedInstance,
              errorInfo
            ]);
            resetTracking();
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
      }
      function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
        if (throwInProd) {
          throw err;
        } else {
          console.error(err);
        }
      }
      const queue = [];
      let flushIndex = -1;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end = queue.length;
        while (start < end) {
          const middle = start + end >>> 1;
          const middleJob = queue[middle];
          const middleJobId = getId(middleJob);
          if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
            start = middle + 1;
          } else {
            end = middle;
          }
        }
        return start;
      }
      function queueJob(job) {
        if (!(job.flags & 1)) {
          const jobId = getId(job);
          const lastJob = queue[queue.length - 1];
          if (!lastJob || // fast path when the job id is larger than the tail
          !(job.flags & 2) && jobId >= getId(lastJob)) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(jobId), 0, job);
          }
          job.flags |= 1;
          queueFlush();
        }
      }
      function queueFlush() {
        if (!currentFlushPromise) {
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$1(cb)) {
          if (activePostFlushCbs && cb.id === -1) {
            activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
          } else if (!(cb.flags & 1)) {
            pendingPostFlushCbs.push(cb);
            cb.flags |= 1;
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.flags & 2) {
            if (instance && cb.id !== instance.uid) {
              continue;
            }
            queue.splice(i, 1);
            i--;
            if (cb.flags & 4) {
              cb.flags &= -2;
            }
            cb();
            if (!(cb.flags & 4)) {
              cb.flags &= -2;
            }
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)].sort(
            (a2, b2) => getId(a2) - getId(b2)
          );
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            const cb = activePostFlushCbs[postFlushIndex];
            if (cb.flags & 4) {
              cb.flags &= -2;
            }
            if (!(cb.flags & 8)) cb();
            cb.flags &= -2;
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
      function flushJobs(seen) {
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && !(job.flags & 8)) {
              if (false) ;
              if (job.flags & 4) {
                job.flags &= ~1;
              }
              callWithErrorHandling(
                job,
                job.i,
                job.i ? 15 : 14
              );
              if (!(job.flags & 4)) {
                job.flags &= ~1;
              }
            }
          }
        } finally {
          for (; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job) {
              job.flags &= -2;
            }
          }
          flushIndex = -1;
          queue.length = 0;
          flushPostFlushCbs();
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx) return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function withDirectives(vnode, directives) {
        if (currentRenderingInstance === null) {
          return vnode;
        }
        const instance = getComponentPublicInstance(currentRenderingInstance);
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (dir) {
            if (isFunction$1(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      const TeleportEndKey = Symbol("_vte");
      const isTeleport = (type) => type.__isTeleport;
      const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
      const resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString$1(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        name: "Teleport",
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                if (parentComponent && parentComponent.isCE) {
                  parentComponent.ce._teleportTarget = container2;
                }
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            };
            const mountToTarget = () => {
              const target = n2.target = resolveTarget(n2.props, querySelector);
              const targetAnchor = prepareAnchor(target, n2, createText, insert);
              if (target) {
                if (namespace !== "svg" && isTargetSVG(target)) {
                  namespace = "svg";
                } else if (namespace !== "mathml" && isTargetMathML(target)) {
                  namespace = "mathml";
                }
                if (!disabled) {
                  mount(target, targetAnchor);
                  updateCssVars(n2, false);
                }
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
              updateCssVars(n2, true);
            }
            if (isTeleportDeferred(n2.props)) {
              queuePostRenderEffect(() => {
                mountToTarget();
                n2.el.__isMounted = true;
              }, parentSuspense);
            } else {
              mountToTarget();
            }
          } else {
            if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
              queuePostRenderEffect(() => {
                TeleportImpl.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
                delete n1.el.__isMounted;
              }, parentSuspense);
              return;
            }
            n2.el = n1.el;
            n2.targetStart = n1.targetStart;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              } else {
                if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                  n2.props.to = n1.props.to;
                }
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
            updateCssVars(n2, disabled);
          }
        },
        remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const {
            shapeFlag,
            children,
            anchor,
            targetStart,
            targetAnchor,
            target,
            props
          } = vnode;
          if (target) {
            hostRemove(targetStart);
            hostRemove(targetAnchor);
          }
          doRemove && hostRemove(anchor);
          if (shapeFlag & 16) {
            const shouldRemove = doRemove || !isTeleportDisabled(props);
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount(
                child,
                parentComponent,
                parentSuspense,
                shouldRemove,
                !!child.dynamicChildren
              );
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              move(
                children[i],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector, insert, createText }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const disabled = isTeleportDisabled(vnode.props);
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (disabled) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetStart = targetNode;
              vnode.targetAnchor = targetNode && nextSibling(targetNode);
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                if (targetAnchor && targetAnchor.nodeType === 8) {
                  if (targetAnchor.data === "teleport start anchor") {
                    vnode.targetStart = targetAnchor;
                  } else if (targetAnchor.data === "teleport anchor") {
                    vnode.targetAnchor = targetAnchor;
                    target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                    break;
                  }
                }
                targetAnchor = nextSibling(targetAnchor);
              }
              if (!vnode.targetAnchor) {
                prepareAnchor(target, vnode, createText, insert);
              }
              hydrateChildren(
                targetNode && nextSibling(targetNode),
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode, disabled);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport$1 = TeleportImpl;
      function updateCssVars(vnode, isDisabled) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node, anchor;
          if (isDisabled) {
            node = vnode.el;
            anchor = vnode.anchor;
          } else {
            node = vnode.targetStart;
            anchor = vnode.targetAnchor;
          }
          while (node && node !== anchor) {
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      function prepareAnchor(target, vnode, createText, insert) {
        const targetStart = vnode.targetStart = createText("");
        const targetAnchor = vnode.targetAnchor = createText("");
        targetStart[TeleportEndKey] = targetAnchor;
        if (target) {
          insert(targetStart, target);
          insert(targetAnchor, target);
        }
        return targetAnchor;
      }
      const leaveCbKey = Symbol("_leaveCb");
      const enterCbKey = Symbol("_enterCb");
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const recursiveGetSubtree = (instance) => {
        const subTree = instance.subTree;
        return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            const child = findNonCommentChild(children);
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getInnerChild$1(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            let enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance,
              // #11061, ensure enterHooks is fresh after clone
              (hooks) => enterHooks = hooks
            );
            if (innerChild.type !== Comment) {
              setTransitionHooks(innerChild, enterHooks);
            }
            let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
            if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
              let leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in" && innerChild.type !== Comment) {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (!(instance.job.flags & 8)) {
                    instance.update();
                  }
                  delete leavingHooks.afterLeave;
                  oldInnerChild = void 0;
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el[leaveCbKey] = () => {
                    earlyRemove();
                    el[leaveCbKey] = void 0;
                    delete enterHooks.delayedLeave;
                    oldInnerChild = void 0;
                  };
                  enterHooks.delayedLeave = () => {
                    delayedLeave();
                    delete enterHooks.delayedLeave;
                    oldInnerChild = void 0;
                  };
                };
              } else {
                oldInnerChild = void 0;
              }
            } else if (oldInnerChild) {
              oldInnerChild = void 0;
            }
            return child;
          };
        }
      };
      function findNonCommentChild(children) {
        let child = children[0];
        if (children.length > 1) {
          for (const c2 of children) {
            if (c2.type !== Comment) {
              child = c2;
              break;
            }
          }
        }
        return child;
      }
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance, postClone) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$1(hook)) {
            if (hook.every((hook2) => hook2.length <= 1)) done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el[leaveCbKey]) {
              el[leaveCbKey](
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
              leavingVNode.el[leaveCbKey]();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el[enterCbKey] = (cancelled) => {
              if (called) return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el[enterCbKey] = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el[enterCbKey]) {
              el[enterCbKey](
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled) => {
              if (called) return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el[leaveCbKey] = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            const hooks2 = resolveTransitionHooks(
              vnode2,
              props,
              state,
              instance,
              postClone
            );
            if (postClone) postClone(hooks2);
            return hooks2;
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getInnerChild$1(vnode) {
        if (!isKeepAlive(vnode)) {
          if (isTeleport(vnode.type) && vnode.children) {
            return findNonCommentChild(vnode.children);
          }
          return vnode;
        }
        const { shapeFlag, children } = vnode;
        if (children) {
          if (shapeFlag & 16) {
            return children[0];
          }
          if (shapeFlag & 32 && isFunction$1(children.default)) {
            return children.default();
          }
        }
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          vnode.transition = hooks;
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function defineComponent(options, extraOptions) {
        return isFunction$1(options) ? (
          // #8236: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      function markAsyncBoundary(instance) {
        instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
      }
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$1(rawRef)) {
          rawRef.forEach(
            (r, i) => setRef(
              r,
              oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
            setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
          }
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref3 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        const rawSetupState = toRaw(setupState);
        const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
          return hasOwn(rawSetupState, key);
        };
        if (oldRef != null && oldRef !== ref3) {
          if (isString$1(oldRef)) {
            refs[oldRef] = null;
            if (canSetSetupRef(oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$1(ref3)) {
          callWithErrorHandling(ref3, owner, 12, [value, refs]);
        } else {
          const _isString = isString$1(ref3);
          const _isRef = isRef(ref3);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                if (isUnmount) {
                  isArray$1(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$1(existing)) {
                    if (_isString) {
                      refs[ref3] = [refValue];
                      if (canSetSetupRef(ref3)) {
                        setupState[ref3] = refs[ref3];
                      }
                    } else {
                      ref3.value = [refValue];
                      if (rawRef.k) refs[rawRef.k] = ref3.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref3] = value;
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = value;
                }
              } else if (_isRef) {
                ref3.value = value;
                if (rawRef.k) refs[rawRef.k] = value;
              } else ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
      getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
      const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
        }, target);
      }
      function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            pauseTracking();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => {
        if (!isInSSRComponentSetup || lifecycle === "sp") {
          injectHook(lifecycle, (...args) => hook(...args), target);
        }
      };
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook(
        "bu"
      );
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook(
        "bum"
      );
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook(
        "sp"
      );
      const onRenderTriggered = createHook("rtg");
      const onRenderTracked = createHook("rtc");
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$1(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
            );
            if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) || // global registration
            resolve(instance.appContext[type], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
      }
      function renderList(source, renderItem, cache, index) {
        let ret;
        const cached = cache;
        const sourceIsArray = isArray$1(source);
        if (sourceIsArray || isString$1(source)) {
          const sourceIsReactiveArray = sourceIsArray && isReactive(source);
          let needsWrap = false;
          if (sourceIsReactiveArray) {
            needsWrap = !isShallow(source);
            source = shallowReadArray(source);
          }
          ret = new Array(source.length);
          for (let i = 0, l2 = source.length; i < l2; i++) {
            ret[i] = renderItem(
              needsWrap ? toReactive(source[i]) : source[i],
              i,
              void 0,
              cached
            );
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached);
          }
        } else if (isObject$1(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached)
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i = 0, l2 = keys2.length; i < l2; i++) {
              const key = keys2[i];
              ret[i] = renderItem(source[key], key, i, cached);
            }
          }
        } else {
          ret = [];
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          if (isArray$1(slot)) {
            for (let j = 0; j < slot.length; j++) {
              slots[slot[j].name] = slot[j].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res) res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
          if (name !== "default") props.name = name;
          return openBlock(), createBlock(
            Fragment,
            null,
            [createVNode("slot", props, fallback && fallback())],
            64
          );
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key;
        const rendered = createBlock(
          Fragment,
          {
            key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
            (!validSlotContent && fallback ? "_fb" : "")
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child)) return true;
          if (child.type === Comment) return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i) => {
        if (!i) return null;
        if (isStatefulComponent(i)) return getComponentPublicInstance(i);
        return getPublicInstance(i.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => i.props,
          $attrs: (i) => i.attrs,
          $slots: (i) => i.slots,
          $refs: (i) => i.refs,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $host: (i) => i.ce,
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i),
          $forceUpdate: (i) => i.f || (i.f = () => {
            queueJob(i.update);
          }),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          if (key === "__v_skip") {
            return true;
          }
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) {
              switch (n) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance.attrs, "get", "");
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i = getCurrentInstance();
        return i.setupContext || (i.setupContext = createSetupContext(i));
      }
      function normalizePropsOrEmits(props) {
        return isArray$1(props) ? props.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$1(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$1(data)) ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c2 = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c2.value,
              set: (v2) => c2.value = v2
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$1(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$1(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components) instance.components = components;
        if (directives) instance.directives = directives;
        if (serverPrefetch) {
          markAsyncBoundary(instance);
        }
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$1(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$1(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v2) => injected.value = v2
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type) {
        callWithAsyncErrorHandling(
          isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$1(raw)) {
          const handler = ctx[raw];
          if (isFunction$1(handler)) {
            {
              watch(getter, handler);
            }
          }
        } else if (isFunction$1(raw)) {
          {
            watch(getter, raw.bind(publicThis));
          }
        } else if (isObject$1(raw)) {
          if (isArray$1(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
          } else {
            const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$1(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else ;
      }
      function resolveMergedOptions(instance) {
        const base = instance.type;
        const { mixins, extends: extendsOptions } = base;
        const {
          mixins: globalMixins,
          optionsCache: cache,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache.get(base);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
            );
          }
          mergeOptions$1(resolved, base, optionMergeStrategies);
        }
        if (isObject$1(base)) {
          cache.set(base, resolved);
        }
        return resolved;
      }
      function mergeOptions$1(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions$1(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m2) => mergeOptions$1(to, m2, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose") ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$1(to) ? to.call(this, this) : to,
            isFunction$1(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$1(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$1(to) && isArray$1(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to) return from;
        if (!from) return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$1(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$1(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new WeakSet();
          const pluginCleanupFns = [];
          let isMounted = false;
          const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v2) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin)) ;
              else if (plugin && isFunction$1(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app, ...options);
              } else if (isFunction$1(plugin)) {
                installedPlugins.add(plugin);
                plugin(app, ...options);
              } else ;
              return app;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app;
            },
            mount(rootContainer, isHydrate, namespace) {
              if (!isMounted) {
                const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                vnode.appContext = context;
                if (namespace === true) {
                  namespace = "svg";
                } else if (namespace === false) {
                  namespace = void 0;
                }
                {
                  render2(vnode, rootContainer, namespace);
                }
                isMounted = true;
                app._container = rootContainer;
                rootContainer.__vue_app__ = app;
                return getComponentPublicInstance(vnode.component);
              }
            },
            onUnmount(cleanupFn) {
              pluginCleanupFns.push(cleanupFn);
            },
            unmount() {
              if (isMounted) {
                callWithAsyncErrorHandling(
                  pluginCleanupFns,
                  app._instance,
                  16
                );
                render2(null, app._container);
                delete app._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app;
            },
            runWithContext(fn2) {
              const lastApp = currentApp;
              currentApp = app;
              try {
                return fn2();
              } finally {
                currentApp = lastApp;
              }
            }
          };
          return app;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance) ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else ;
        }
      }
      function hasInjectionContext() {
        return !!(currentInstance || currentRenderingInstance || currentApp);
      }
      const internalObjectProto = {};
      const createInternalObject = () => Object.create(internalObjectProto);
      const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = createInternalObject();
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance.attrs, "set", "");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                const reset = setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                reset();
              }
            } else {
              value = defaultValue;
            }
            if (instance.ce) {
              instance.ce._setProp(key, value);
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      const mixinPropsCache = /* @__PURE__ */ new WeakMap();
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache = asMixin ? mixinPropsCache : appContext.propsCache;
        const cached = cache.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys2) needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$1(raw)) {
          for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
              const propType = prop.type;
              let shouldCast = false;
              let shouldCastTrue = true;
              if (isArray$1(propType)) {
                for (let index = 0; index < propType.length; ++index) {
                  const type = propType[index];
                  const typeName = isFunction$1(type) && type.name;
                  if (typeName === "Boolean") {
                    shouldCast = true;
                    break;
                  } else if (typeName === "String") {
                    shouldCastTrue = false;
                  }
                }
              } else {
                shouldCast = isFunction$1(propType) && propType.name === "Boolean";
              }
              prop[
                0
                /* shouldCast */
              ] = shouldCast;
              prop[
                1
                /* shouldCastTrue */
              ] = shouldCastTrue;
              if (shouldCast || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$1(comp)) {
          cache.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$" && !isReservedProp(key)) {
          return true;
        }
        return false;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false) ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key)) continue;
          const value = rawSlots[key];
          if (isFunction$1(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const assignSlots = (slots, children, optimized) => {
        for (const key in children) {
          if (optimized || key !== "_") {
            slots[key] = children[key];
          }
        }
      };
      const initSlots = (instance, children, optimized) => {
        const slots = instance.slots = createInternalObject();
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            assignSlots(slots, children, optimized);
            if (optimized) {
              def(slots, "_", type, true);
            }
          } else {
            normalizeObjectSlots(children, slots);
          }
        } else if (children) {
          normalizeVNodeSlots(instance, children);
        }
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              assignSlots(slots, children, optimized);
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
              delete slots[key];
            }
          }
        }
      };
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type, ref: ref3, shapeFlag } = n2;
          switch (type) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, namespace);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else ;
          }
          if (ref3 != null && parentComponent) {
            setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, namespace) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          if (n2.type === "svg") {
            namespace = "svg";
          } else if (n2.type === "math") {
            namespace = "mathml";
          }
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            namespace,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(vnode, namespace),
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(el, key, null, props[key], namespace, parentComponent);
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value, namespace);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = needTransition(parentSuspense, transition);
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
            hostSetElementText(el, "");
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(el, oldProps, newProps, parentComponent, namespace);
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, namespace);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(el, key, prev, next, namespace, parentComponent);
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    namespace,
                    parentComponent
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key)) continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              n2.children || [],
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                namespace,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance, false, optimized);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
          } else {
            setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              namespace,
              optimized
            );
          }
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m: m2, parent, root: root2, type } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              {
                if (root2.ce) {
                  root2.ce._injectChildStyle(type);
                }
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  namespace
                );
                initialVNode.el = subTree.el;
              }
              if (m2) {
                queuePostRenderEffect(m2, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u: u2, parent, vnode } = instance;
              {
                const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                if (nonHydratedAsyncRoot) {
                  if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                  }
                  nonHydratedAsyncRoot.asyncDep.then(() => {
                    if (!instance.isUnmounted) {
                      componentUpdateFn();
                    }
                  });
                  return;
                }
              }
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                namespace
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u2) {
                queuePostRenderEffect(u2, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          instance.scope.on();
          const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
          instance.scope.off();
          const update = instance.update = effect2.run.bind(effect2);
          const job = instance.job = effect2.runIfDirty.bind(effect2);
          job.i = instance;
          job.id = instance.uid;
          effect2.scheduler = () => queueJob(job);
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs(instance);
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition2) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type,
            props,
            ref: ref3,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs,
            cacheIndex
          } = vnode;
          if (patchFlag === -2) {
            optimized = false;
          }
          if (ref3 != null) {
            setRef(ref3, null, parentSuspense, vnode, true);
          }
          if (cacheIndex != null) {
            parentComponent.renderCache[cacheIndex] = void 0;
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #5154
            // when v-once is used inside a block, setBlockTracking(-1) marks the
            // parent block with hasOnce: true
            // so that it doesn't take the fast path during unmount - otherwise
            // components nested in v-once are never unmounted.
            !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end) => {
          let next;
          while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance;
          invalidateMount(m2);
          invalidateMount(a2);
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (job) {
            job.flags |= 8;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          const el = hostNextSibling(vnode.anchor || vnode.el);
          const teleportEnd = el && el[TeleportEndKey];
          return teleportEnd ? hostNextSibling(teleportEnd) : el;
        };
        let isFlushing = false;
        const render2 = (vnode, container, namespace) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(
              container._vnode || null,
              vnode,
              container,
              null,
              null,
              null,
              namespace
            );
          }
          container._vnode = vnode;
          if (!isFlushing) {
            isFlushing = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing = false;
          }
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2)
        };
      }
      function resolveChildrenNamespace({ type, props }, currentNamespace) {
        return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
      }
      function toggleRecurse({ effect: effect2, job }, allowed) {
        if (allowed) {
          effect2.flags |= 32;
          job.flags |= 4;
        } else {
          effect2.flags &= -33;
          job.flags &= -5;
        }
      }
      function needTransition(parentSuspense, transition) {
        return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$1(ch1) && isArray$1(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow && c2.patchFlag !== -2)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i, j, u2, v2, c2;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p2[i] = j;
              result.push(i);
              continue;
            }
            u2 = 0;
            v2 = result.length - 1;
            while (u2 < v2) {
              c2 = u2 + v2 >> 1;
              if (arr[result[c2]] < arrI) {
                u2 = c2 + 1;
              } else {
                v2 = c2;
              }
            }
            if (arrI < arr[result[u2]]) {
              if (u2 > 0) {
                p2[i] = result[u2 - 1];
              }
              result[u2] = i;
            }
          }
        }
        u2 = result.length;
        v2 = result[u2 - 1];
        while (u2-- > 0) {
          result[u2] = v2;
          v2 = p2[v2];
        }
        return result;
      }
      function locateNonHydratedAsyncRoot(instance) {
        const subComponent = instance.subTree.component;
        if (subComponent) {
          if (subComponent.asyncDep && !subComponent.asyncResolved) {
            return subComponent;
          } else {
            return locateNonHydratedAsyncRoot(subComponent);
          }
        }
      }
      function invalidateMount(hooks) {
        if (hooks) {
          for (let i = 0; i < hooks.length; i++)
            hooks[i].flags |= 8;
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      function watchEffect(effect2, options) {
        return doWatch(effect2, null, options);
      }
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, options = EMPTY_OBJ) {
        const { immediate, deep, flush, once } = options;
        const baseWatchOptions = extend({}, options);
        const runsImmediately = cb && immediate || !cb && flush !== "post";
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else if (!runsImmediately) {
            const watchStopHandle = () => {
            };
            watchStopHandle.stop = NOOP;
            watchStopHandle.resume = NOOP;
            watchStopHandle.pause = NOOP;
            return watchStopHandle;
          }
        }
        const instance = currentInstance;
        baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
        let isPre = false;
        if (flush === "post") {
          baseWatchOptions.scheduler = (job) => {
            queuePostRenderEffect(job, instance && instance.suspense);
          };
        } else if (flush !== "sync") {
          isPre = true;
          baseWatchOptions.scheduler = (job, isFirstRun) => {
            if (isFirstRun) {
              job();
            } else {
              queueJob(job);
            }
          };
        }
        baseWatchOptions.augmentJob = (job) => {
          if (cb) {
            job.flags |= 4;
          }
          if (isPre) {
            job.flags |= 2;
            if (instance) {
              job.id = instance.uid;
              job.i = instance;
            }
          }
        };
        const watchHandle = watch$1(source, cb, baseWatchOptions);
        if (isInSSRComponentSetup) {
          if (ssrCleanup) {
            ssrCleanup.push(watchHandle);
          } else if (runsImmediately) {
            watchHandle();
          }
        }
        return watchHandle;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$1(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const reset = setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        reset();
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      const getModelModifiers = (props, modelName) => {
        return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
      };
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted) return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
        if (modifiers) {
          if (modifiers.trim) {
            args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
          }
          if (modifiers.number) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.emitsCache;
        const cached = cache.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache.set(comp, null);
          }
          return null;
        }
        if (isArray$1(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$1(comp)) {
          cache.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          props,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        const prev = setCurrentRenderingInstance(instance);
        let result;
        let fallthroughAttrs;
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = false ? new Proxy(proxyToUse, {
              get(target, key, receiver) {
                warn$1(
                  `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
                );
                return Reflect.get(target, key, receiver);
              }
            }) : proxyToUse;
            result = normalizeVNode(
              render2.call(
                thisProxy,
                proxyToUse,
                renderCache,
                false ? shallowReadonly(props) : props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false) ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                false ? shallowReadonly(props) : props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return shallowReadonly(attrs);
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                false ? shallowReadonly(props) : props,
                null
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs, false, true);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2, null, false, true);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          setTransitionHooks(root2, vnode.transition);
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent) {
          const root2 = parent.subTree;
          if (root2.suspense && root2.suspense.activeBranch === vnode) {
            root2.el = vnode.el;
          }
          if (root2 === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
          } else {
            break;
          }
        }
      }
      const isSuspense = (type) => type.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$1(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value, inVOnce = false) {
        isBlockTreeEnabled += value;
        if (value < 0 && currentBlock && inVOnce) {
          currentBlock.hasOnce = true;
        }
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
          )
        );
      }
      function createBlock(type, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref3,
        ref_key,
        ref_for
      }) => {
        if (typeof ref3 === "number") {
          ref3 = "" + ref3;
        }
        return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
      };
      function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetStart: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$1(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          type = Comment;
        }
        if (isVNode(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag = -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString$1(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject$1(style)) {
            if (isProxy(style) && !isArray$1(style)) {
              style = extend({}, style);
            }
            props.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
        return createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props) return null;
        return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
        const { props, ref: ref3, patchFlag, children, transition } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref3,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetStart: vnode.targetStart,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        if (transition && cloneTransition) {
          setTransitionHooks(
            cloned,
            transition.clone(cloned)
          );
        }
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$1(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (isVNode(child)) {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$1(children)) {
          type = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !isInternalObject(children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$1(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
          } else {
            type = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          job: null,
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          ids: parent ? parent.ids : ["", 0, 0],
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let setInSSRSetupState;
      {
        const g = getGlobalThis();
        const registerGlobalSetter = (key, setter) => {
          let setters;
          if (!(setters = g[key])) setters = g[key] = [];
          setters.push(setter);
          return (v2) => {
            if (setters.length > 1) setters.forEach((set2) => set2(v2));
            else setters[0](v2);
          };
        };
        internalSetCurrentInstance = registerGlobalSetter(
          `__VUE_INSTANCE_SETTERS__`,
          (v2) => currentInstance = v2
        );
        setInSSRSetupState = registerGlobalSetter(
          `__VUE_SSR_SETTERS__`,
          (v2) => isInSSRComponentSetup = v2
        );
      }
      const setCurrentInstance = (instance) => {
        const prev = currentInstance;
        internalSetCurrentInstance(instance);
        instance.scope.on();
        return () => {
          instance.scope.off();
          internalSetCurrentInstance(prev);
        };
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false, optimized = false) {
        isSSR && setInSSRSetupState(isSSR);
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children, optimized);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isSSR && setInSSRSetupState(false);
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
        const { setup } = Component;
        if (setup) {
          pauseTracking();
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          const reset = setCurrentInstance(instance);
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
              instance.props,
              setupContext
            ]
          );
          const isAsyncSetup = isPromise(setupResult);
          resetTracking();
          reset();
          if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
            markAsyncBoundary(instance);
          }
          if (isAsyncSetup) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult);
              }).catch((e) => {
                handleError(e, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult);
          }
        } else {
          finishComponentSetup(instance);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$1(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$1(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else ;
        finishComponentSetup(instance);
      }
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          instance.render = Component.render || NOOP;
        }
        {
          const reset = setCurrentInstance(instance);
          pauseTracking();
          try {
            applyOptions(instance);
          } finally {
            resetTracking();
            reset();
          }
        }
      }
      const attrsProxyHandlers = {
        get(target, key) {
          track(target, "get", "");
          return target[key];
        }
      };
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            attrs: new Proxy(instance.attrs, attrsProxyHandlers),
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getComponentPublicInstance(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        } else {
          return instance.proxy;
        }
      }
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
            name = match[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(
            instance.components || instance.parent.type.components
          ) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return isFunction$1(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
        return c2;
      };
      function h$1(type, propsOrChildren, children) {
        const l2 = arguments.length;
        if (l2 === 2) {
          if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
          } else {
            return createVNode(type, null, propsOrChildren);
          }
        } else {
          if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l2 === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type, propsOrChildren, children);
        }
      }
      const version = "3.5.13";
      const warn = NOOP;
      /**
      * @vue/runtime-dom v3.5.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let policy = void 0;
      const tt$1 = typeof window !== "undefined" && window.trustedTypes;
      if (tt$1) {
        try {
          policy = /* @__PURE__ */ tt$1.createPolicy("vue", {
            createHTML: (val) => val
          });
        } catch (e) {
        }
      }
      const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
      const svgNS = "http://www.w3.org/2000/svg";
      const mathmlNS = "http://www.w3.org/1998/Math/MathML";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, namespace, is, props) => {
          const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, namespace, start, end) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end || !(start = start.nextSibling)) break;
            }
          } else {
            templateContainer.innerHTML = unsafeToTrustedHTML(
              namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
            );
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const vtcKey = Symbol("_vtc");
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const decorate$1 = (t) => {
        t.displayName = "Transition";
        t.props = TransitionPropsValidators;
        return t;
      };
      const Transition = /* @__PURE__ */ decorate$1(
        (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots)
      );
      const callHook = (hook, args = []) => {
        if (isArray$1(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done, isCancelled) => {
          el._enterCancelled = isCancelled;
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            if (!el._enterCancelled) {
              forceReflow();
              addTransitionClass(el, leaveActiveClass);
            } else {
              addTransitionClass(el, leaveActiveClass);
              forceReflow();
            }
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false, void 0, true);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true, void 0, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$1(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n = NumberOf(duration);
          return [n, n];
        }
      }
      function NumberOf(val) {
        const res = toNumber$1(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
        (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
        const _vtc = el[vtcKey];
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el[vtcKey] = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout != null) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve2();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
            end();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
      }
      function toMs(s2) {
        if (s2 === "auto") return 0;
        return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      function patchClass(el, value, isSVG) {
        const transitionClasses = el[vtcKey];
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      const vShowOriginalDisplay = Symbol("_vod");
      const vShowHidden = Symbol("_vsh");
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue) return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el[vShowOriginalDisplay] : "none";
        el[vShowHidden] = !value;
      }
      const CSS_VAR_TEXT = Symbol("");
      const displayRE = /(^|;)\s*display\s*:/;
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString$1(next);
        let hasControlledDisplay = false;
        if (next && !isCssString) {
          if (prev) {
            if (!isString$1(prev)) {
              for (const key in prev) {
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            } else {
              for (const prevStyle of prev.split(";")) {
                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            }
          }
          for (const key in next) {
            if (key === "display") {
              hasControlledDisplay = true;
            }
            setStyle(style, key, next[key]);
          }
        } else {
          if (isCssString) {
            if (prev !== next) {
              const cssVarText = style[CSS_VAR_TEXT];
              if (cssVarText) {
                next += ";" + cssVarText;
              }
              style.cssText = next;
              hasControlledDisplay = displayRE.test(next);
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
        }
        if (vShowOriginalDisplay in el) {
          el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
          if (el[vShowHidden]) {
            style.display = "none";
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray$1(val)) {
          val.forEach((v2) => setStyle(style, name, v2));
        } else {
          if (val == null) val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(
              key,
              isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
            );
          }
        }
      }
      function patchDOMProp(el, key, value, parentComponent, attrName) {
        if (key === "innerHTML" || key === "textContent") {
          if (value != null) {
            el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
          }
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
          const newValue = value == null ? (
            // #11647: value should be set as empty string for null and undefined,
            // but <input type="checkbox"> should be set as 'on'.
            el.type === "checkbox" ? "on" : ""
          ) : String(value);
          if (oldValue !== newValue || !("_value" in el)) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          el._value = value;
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e) {
        }
        needRemove && el.removeAttribute(attrName || key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      const veiKey = Symbol("_vei");
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el[veiKey] || (el[veiKey] = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(
              nextValue,
              instance
            );
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m2;
          while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p$1 = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e) => {
          if (!e._vts) {
            e._vts = Date.now();
          } else if (e._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e, value) {
        if (isArray$1(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
          };
          return value.map(
            (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
          );
        } else {
          return value;
        }
      }
      const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
      key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
      const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
        const isSVG = namespace === "svg";
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(el, key, nextValue);
          if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
            patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
          }
        } else if (
          // #11081 force set props for possible async custom element
          el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
        ) {
          patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && isNativeOn(key) && isFunction$1(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (key === "width" || key === "height") {
          const tag = el.tagName;
          if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
            return false;
          }
        }
        if (isNativeOn(key) && isString$1(value)) {
          return false;
        }
        return key in el;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      const assignKey = Symbol("_assign");
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _2, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue$1(el);
            const checked = el.checked;
            const assign2 = el[assignKey];
            if (isArray$1(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign2(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign2(filtered);
              }
            } else if (isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign2(cloned);
            } else {
              assign2(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        let checked;
        if (isArray$1(value)) {
          checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet(value)) {
          checked = value.has(vnode.props.value);
        } else {
          if (value === oldValue) return;
          checked = looseEqual(value, getCheckboxValue(el, true));
        }
        if (el.checked !== checked) {
          el.checked = checked;
        }
      }
      function getValue$1(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
      };
      const withModifiers = (fn2, modifiers) => {
        const cache = fn2._withMods || (fn2._withMods = {});
        const cacheKey = modifiers.join(".");
        return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
          }
          return fn2(event, ...args);
        });
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        const cache = fn2._withKeys || (fn2._withKeys = {});
        const cacheKey = modifiers.join(".");
        return cache[cacheKey] || (cache[cacheKey] = (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some(
            (k) => k === eventKey || keyNames[k] === eventKey
          )) {
            return fn2(event);
          }
        });
      };
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app = ensureRenderer().createApp(...args);
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container) return;
          const component = app._component;
          if (!isFunction$1(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          if (container.nodeType === 1) {
            container.textContent = "";
          }
          const proxy = mount(container, false, resolveRootNamespace(container));
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app;
      };
      function resolveRootNamespace(container) {
        if (container instanceof SVGElement) {
          return "svg";
        }
        if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
          return "mathml";
        }
      }
      function normalizeContainer(container) {
        if (isString$1(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      /*!
       * pinia v2.3.1
       * (c) 2025 Eduardo San Martin Morote
       * @license MIT
       */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function isPlainObject$1(o2) {
        return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = effectScope(true);
        const state = scope.run(() => ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = markRaw({
          install(app) {
            setActivePinia(pinia2);
            {
              pinia2._a = app;
              app.provide(piniaSymbol, pinia2);
              app.config.globalProperties.$pinia = pinia2;
              toBeInstalled.forEach((plugin) => _p.push(plugin));
              toBeInstalled = [];
            }
          },
          use(plugin) {
            if (!this._a && true) {
              toBeInstalled.push(plugin);
            } else {
              _p.push(plugin);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        return pinia2;
      }
      const noop$1 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && getCurrentScope()) {
          onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn2) => fn2();
      const ACTION_MARKER = Symbol();
      const ACTION_NAME = Symbol();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        } else if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o2) {
        return !!(isRef(o2) && o2.effect);
      }
      function createOptionsStore(id, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id];
        let store;
        function setup() {
          if (!initialState && true) {
            {
              pinia2.state.value[id] = state ? state() : {};
            }
          }
          const localState = toRefs(pinia2.state.value[id]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = markRaw(computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id, setup, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = { deep: true };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          noop$1
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        const action = (fn2, name = "") => {
          if (ACTION_MARKER in fn2) {
            fn2[ACTION_NAME] = name;
            return fn2;
          }
          const wrappedAction = function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name: wrappedAction[ACTION_NAME],
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = fn2.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
          wrappedAction[ACTION_MARKER] = true;
          wrappedAction[ACTION_NAME] = name;
          return wrappedAction;
        };
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = reactive(partialStore);
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
          } else if (typeof prop === "function") {
            const actionValue = action(prop, key);
            {
              setupStore[key] = actionValue;
            }
            optionsForPlugin.actions[key] = prop;
          } else ;
        }
        {
          assign(store, setupStore);
          assign(toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => pinia2.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia2._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function defineStore(idOrOptions, setup, setupOptions) {
        let id;
        let options;
        const isSetupStore = typeof setup === "function";
        {
          id = idOrOptions;
          options = isSetupStore ? setupOptions : setup;
        }
        function useStore2(pinia2, hot) {
          const hasContext = hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          pinia2 = activePinia;
          if (!pinia2._s.has(id)) {
            if (isSetupStore) {
              createSetupStore(id, setup, options, pinia2);
            } else {
              createOptionsStore(id, options, pinia2);
            }
          }
          const store = pinia2._s.get(id);
          return store;
        }
        useStore2.$id = id;
        return useStore2;
      }
      const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
      const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
      const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function jsonParseTransform(key, value) {
        if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
          warnKeyDropped(key);
          return;
        }
        return value;
      }
      function warnKeyDropped(key) {
        console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
      }
      function destr(value, options = {}) {
        if (typeof value !== "string") {
          return value;
        }
        if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
          return value.slice(1, -1);
        }
        const _value = value.trim();
        if (_value.length <= 9) {
          switch (_value.toLowerCase()) {
            case "true": {
              return true;
            }
            case "false": {
              return false;
            }
            case "undefined": {
              return void 0;
            }
            case "null": {
              return null;
            }
            case "nan": {
              return Number.NaN;
            }
            case "infinity": {
              return Number.POSITIVE_INFINITY;
            }
            case "-infinity": {
              return Number.NEGATIVE_INFINITY;
            }
          }
        }
        if (!JsonSigRx.test(value)) {
          if (options.strict) {
            throw new SyntaxError("[destr] Invalid JSON");
          }
          return value;
        }
        try {
          if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
            if (options.strict) {
              throw new Error("[destr] Possible prototype pollution");
            }
            return JSON.parse(value, jsonParseTransform);
          }
          return JSON.parse(value);
        } catch (error) {
          if (options.strict) {
            throw error;
          }
          return value;
        }
      }
      function get$1(obj, path) {
        if (obj == null)
          return void 0;
        let value = obj;
        for (let i = 0; i < path.length; i++) {
          if (value == null || value[path[i]] == null)
            return void 0;
          value = value[path[i]];
        }
        return value;
      }
      function set$1(obj, value, path) {
        if (path.length === 0)
          return value;
        const idx = path[0];
        if (path.length > 1) {
          value = set$1(
            typeof obj !== "object" || obj === null || !Object.prototype.hasOwnProperty.call(obj, idx) ? Number.isInteger(Number(path[1])) ? [] : {} : obj[idx],
            value,
            Array.prototype.slice.call(path, 1)
          );
        }
        if (Number.isInteger(Number(idx)) && Array.isArray(obj))
          return obj.slice()[idx];
        return Object.assign({}, obj, { [idx]: value });
      }
      function unset(obj, path) {
        if (obj == null || path.length === 0)
          return obj;
        if (path.length === 1) {
          if (obj == null)
            return obj;
          if (Number.isInteger(path[0]) && Array.isArray(obj))
            return Array.prototype.slice.call(obj, 0).splice(path[0], 1);
          const result = {};
          for (const p2 in obj)
            result[p2] = obj[p2];
          delete result[path[0]];
          return result;
        }
        if (obj[path[0]] == null) {
          if (Number.isInteger(path[0]) && Array.isArray(obj))
            return Array.prototype.concat.call([], obj);
          const result = {};
          for (const p2 in obj)
            result[p2] = obj[p2];
          return result;
        }
        return set$1(
          obj,
          unset(
            obj[path[0]],
            Array.prototype.slice.call(path, 1)
          ),
          [path[0]]
        );
      }
      function deepPickUnsafe(obj, paths) {
        return paths.map((p2) => p2.split(".")).map((p2) => [p2, get$1(obj, p2)]).filter((t) => t[1] !== void 0).reduce((acc, cur) => set$1(acc, cur[1], cur[0]), {});
      }
      function deepOmitUnsafe(obj, paths) {
        return paths.map((p2) => p2.split(".")).reduce((acc, cur) => unset(acc, cur), obj);
      }
      function hydrateStore(store, {
        storage,
        serializer,
        key,
        debug,
        pick: pick2,
        omit,
        beforeHydrate,
        afterHydrate
      }, context, runHooks = true) {
        try {
          if (runHooks)
            beforeHydrate == null ? void 0 : beforeHydrate(context);
          const fromStorage = storage.getItem(key);
          if (fromStorage) {
            const deserialized = serializer.deserialize(fromStorage);
            const picked = pick2 ? deepPickUnsafe(deserialized, pick2) : deserialized;
            const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
            store.$patch(omitted);
          }
          if (runHooks)
            afterHydrate == null ? void 0 : afterHydrate(context);
        } catch (error) {
          if (debug)
            console.error("[pinia-plugin-persistedstate]", error);
        }
      }
      function persistState(state, {
        storage,
        serializer,
        key,
        debug,
        pick: pick2,
        omit
      }) {
        try {
          const picked = pick2 ? deepPickUnsafe(state, pick2) : state;
          const omitted = omit ? deepOmitUnsafe(picked, omit) : picked;
          const toStorage = serializer.serialize(omitted);
          storage.setItem(key, toStorage);
        } catch (error) {
          if (debug)
            console.error("[pinia-plugin-persistedstate]", error);
        }
      }
      function createPersistence(context, optionsParser, auto) {
        const { pinia: pinia2, store, options: { persist = auto } } = context;
        if (!persist)
          return;
        if (!(store.$id in pinia2.state.value)) {
          const originalStore = pinia2._s.get(store.$id.replace("__hot:", ""));
          if (originalStore)
            Promise.resolve().then(() => originalStore.$persist());
          return;
        }
        const persistenceOptions = Array.isArray(persist) ? persist : persist === true ? [{}] : [persist];
        const persistences = persistenceOptions.map(optionsParser);
        store.$hydrate = ({ runHooks = true } = {}) => {
          persistences.forEach((p2) => {
            hydrateStore(store, p2, context, runHooks);
          });
        };
        store.$persist = () => {
          persistences.forEach((p2) => {
            persistState(store.$state, p2);
          });
        };
        persistences.forEach((p2) => {
          hydrateStore(store, p2, context);
          store.$subscribe(
            (_mutation, state) => persistState(state, p2),
            { detached: true }
          );
        });
      }
      function createPersistedState(options = {}) {
        return function(context) {
          createPersistence(
            context,
            (p2) => ({
              key: (options.key ? options.key : (x2) => x2)(p2.key ?? context.store.$id),
              debug: p2.debug ?? options.debug ?? false,
              serializer: p2.serializer ?? options.serializer ?? {
                serialize: (data) => JSON.stringify(data),
                deserialize: (data) => destr(data)
              },
              storage: p2.storage ?? options.storage ?? window.localStorage,
              beforeHydrate: p2.beforeHydrate,
              afterHydrate: p2.afterHydrate,
              pick: p2.pick,
              omit: p2.omit
            }),
            options.auto ?? false
          );
        };
      }
      var src_default = createPersistedState();
      const pinia = createPinia();
      pinia.use(src_default);
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace);
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace();
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$1 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      var isArray = Array.isArray;
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity$1(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity$1 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity$1), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$2;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer$1 = nativeIsBuffer || stubFalse;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$6.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (predicate(value)) {
            {
              arrayPush(result, value);
            }
          } else {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectTag$2 = "[object Object]";
      var funcProto = Function.prototype, objectProto$3 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        {
          return buffer.slice();
        }
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$2 = Object.prototype;
      var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      var DataView$1 = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
      var dataViewTag$1 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$1;
              case mapCtorString:
                return mapTag$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$1;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      var Uint8Array$1 = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = cloneArrayBuffer(typedArray.buffer);
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack2.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            var result;
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity$1;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = -1, iterable = Object(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee));
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isNull(value) {
        return value === null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isElement = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isPropAbsent = (prop) => isNil(prop);
      const isStringNumber = (val) => {
        if (!isString$1(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      var __defProp$9 = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$b.call(b2, prop))
            __defNormalProp$9(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b2)) {
            if (__propIsEnum$b.call(b2, prop))
              __defNormalProp$9(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
      function computedEager(fn2, options) {
        var _a2;
        const result = shallowRef();
        watchEffect(() => {
          result.value = fn2();
        }, __spreadProps$6(__spreadValues$9({}, options), {
          flush: (_a2 = void 0) != null ? _a2 : "sync"
        }));
        return readonly(result);
      }
      var _a;
      const isClient = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop = () => {
      };
      const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function identity(arg) {
        return arg;
      }
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity
      }, _TransitionPresets);
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message) {
      }
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0;
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !inject(ZINDEX_INJECTION_KEY)) ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color.",
            alphaLabel: "pick alpha value"
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          mention: {
            loading: "Loading"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const componentSizes = ["", "default", "small", "large"];
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      var _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$1(value)) {
          return value;
        }
      }
      const withInstall = (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$g = /* @__PURE__ */ defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size, color } = props;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "icon.vue"]]);
      const ElIcon = withInstall(Icon);
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = close_vue_vue_type_script_setup_true_lang_default;
      var comment_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Comment",
        __name: "comment",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M736 504a56 56 0 1 1 0-112 56 56 0 0 1 0 112m-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112m-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112M128 128v640h192v160l224-160h352V128z"
            })
          ]));
        }
      });
      var comment_default = comment_vue_vue_type_script_setup_true_lang_default;
      var full_screen_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      });
      var full_screen_default = full_screen_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var key_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Key",
        __name: "key",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M448 456.064V96a32 32 0 0 1 32-32.064L672 64a32 32 0 0 1 0 64H512v128h160a32 32 0 0 1 0 64H512v128a256 256 0 1 1-64 8.064M512 896a192 192 0 1 0 0-384 192 192 0 0 0 0 384"
            })
          ]));
        }
      });
      var key_default = key_vue_vue_type_script_setup_true_lang_default;
      var list_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "List",
        __name: "list",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M704 192h160v736H160V192h160v64h384zM288 512h448v-64H288zm0 256h448v-64H288zm96-576V96h256v96z"
            })
          ]));
        }
      });
      var list_default = list_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = minus_vue_vue_type_script_setup_true_lang_default;
      var notebook_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Notebook",
        __name: "notebook",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M192 128v768h640V128zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M672 128h64v768h-64zM96 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32"
            })
          ]));
        }
      });
      var notebook_default = notebook_vue_vue_type_script_setup_true_lang_default;
      var operation_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Operation",
        __name: "operation",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64z"
            })
          ]));
        }
      });
      var operation_default = operation_vue_vue_type_script_setup_true_lang_default;
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = plus_vue_vue_type_script_setup_true_lang_default;
      var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "QuestionFilled",
        __name: "question-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
            })
          ]));
        }
      });
      var question_filled_default = question_filled_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var tools_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Tools",
        __name: "tools",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0"
            })
          ]));
        }
      });
      var tools_default = tools_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      var warning_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Warning",
        __name: "warning",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0m-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            })
          ]));
        }
      });
      var warning_default = warning_vue_vue_type_script_setup_true_lang_default;
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const TypeComponents = {
        Close: close_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const alertEffects = ["light", "dark"];
      const alertProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        description: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: keysOf(TypeComponentsMap),
          default: "info"
        },
        closable: {
          type: Boolean,
          default: true
        },
        closeText: {
          type: String,
          default: ""
        },
        showIcon: Boolean,
        center: Boolean,
        effect: {
          type: String,
          values: alertEffects,
          default: "light"
        }
      });
      const alertEmits = {
        close: (evt) => evt instanceof MouseEvent
      };
      const __default__$f = /* @__PURE__ */ defineComponent({
        name: "ElAlert"
      });
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: alertProps,
        emits: alertEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const { Close } = TypeComponents;
          const slots = useSlots();
          const ns = useNamespace("alert");
          const visible = ref(true);
          const iconComponent = computed(() => TypeComponentsMap[props.type]);
          const hasDesc = computed(() => !!(props.description || slots.default));
          const close = (evt) => {
            visible.value = false;
            emit2("close", evt);
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.type), unref(ns).is("center", _ctx.center), unref(ns).is(_ctx.effect)]),
                  role: "alert"
                }, [
                  _ctx.showIcon && (_ctx.$slots.icon || unref(iconComponent)) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), { [unref(ns).is("big")]: unref(hasDesc) }])
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "icon", {}, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                      ])
                    ]),
                    _: 3
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass([unref(ns).e("title"), { "with-description": unref(hasDesc) }])
                    }, [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(hasDesc) ? (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(unref(ns).e("description"))
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        createTextVNode(toDisplayString(_ctx.description), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      _ctx.closeText ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass([unref(ns).e("close-btn"), unref(ns).is("customed")]),
                        onClick: close
                      }, toDisplayString(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass(unref(ns).e("close-btn")),
                        onClick: close
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Close))
                        ]),
                        _: 1
                      }, 8, ["class"]))
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name"]);
          };
        }
      });
      var Alert = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "alert.vue"]]);
      const ElAlert = withInstall(Alert);
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = {
        height: "0",
        visibility: "hidden",
        overflow: isFirefox() ? "" : "hidden",
        position: "absolute",
        "z-index": "-1000",
        top: "0",
        right: "0"
      };
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => [
          name,
          style.getPropertyValue(name)
        ]);
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        contextStyle.forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value));
        Object.entries(HIDDEN_STYLE).forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value, "important"));
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const mutable = (val) => val;
      const ariaProps = buildProps({
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical", "undefined"]
        },
        ariaControls: String
      });
      const useAriaProps = (arias) => {
        return pick(ariaProps, arias);
      };
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: Boolean,
        clearable: Boolean,
        showPassword: Boolean,
        showWordLimit: Boolean,
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: Boolean,
        rows: {
          type: Number,
          default: 2
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        input: (value) => isString$1(value),
        change: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computedEager(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!(props.label || props.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      function useFocusController(target, {
        beforeFocus,
        afterFocus,
        beforeBlur,
        afterBlur
      } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const disabled = useProp("disabled");
        const isFocused = ref(false);
        const handleFocus = (event) => {
          const cancelFocus = isFunction$1(beforeFocus) ? beforeFocus(event) : false;
          if (cancelFocus || isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2, _b;
          if (((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(document.activeElement)) && wrapperRef.value !== document.activeElement || disabled.value)
            return;
          (_b = target.value) == null ? void 0 : _b.focus();
        };
        watch([wrapperRef, disabled], ([el, disabled2]) => {
          if (!el)
            return;
          if (disabled2) {
            el.removeAttribute("tabindex");
          } else {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "focus", handleFocus, true);
        useEventListener(wrapperRef, "blur", handleBlur, true);
        useEventListener(wrapperRef, "click", handleClick, true);
        return {
          isFocused,
          wrapperRef,
          handleFocus,
          handleBlur
        };
      }
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      function useComposition({
        afterComposition,
        emit: emit2
      }) {
        const isComposing = ref(false);
        const handleCompositionStart = (event) => {
          emit2 == null ? void 0 : emit2("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit2 == null ? void 0 : emit2("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit2 == null ? void 0 : emit2("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            nextTick(() => afterComposition(event));
          }
        };
        const handleComposition = (event) => {
          event.type === "compositionend" ? handleCompositionEnd(event) : handleCompositionUpdate(event);
        };
        return {
          isComposing,
          handleComposition,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      function useCursor(input) {
        let selectionInfo;
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionInfo = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionInfo == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionInfo;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const COMPONENT_NAME$3 = "ElInput";
      const __default__$e = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$3,
        inheritAttrs: false
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const slots = useSlots();
          const containerKls = computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            beforeFocus() {
              return inputDisabled.value;
            },
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props;
            if (!isClient || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter && props.parser) {
              value = props.parser(value);
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2(INPUT_EVENT, value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            let { value } = event.target;
            if (props.formatter && props.parser) {
              value = props.parser(value);
            }
            emit2(CHANGE_EVENT, value);
          };
          const {
            isComposing,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd
          } = useComposition({ emit: emit2, afterComposition: handleInput });
          const handlePasswordVisible = () => {
            recordCursor();
            passwordVisible.value = !passwordVisible.value;
            setTimeout(setCursor);
          };
          const focus = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2(CHANGE_EVENT, "");
            emit2("clear");
            emit2(INPUT_EVENT, "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser) ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props, "autosize"),
            isComposing,
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(containerKls),
                {
                  [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                  [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
                }
              ]),
              style: normalizeStyle(unref(containerStyle)),
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }, [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.ariaLabel,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    role: _ctx.containerRole,
                    onCompositionstart: unref(handleCompositionStart),
                    onCompositionupdate: unref(handleCompositionUpdate),
                    onCompositionend: unref(handleCompositionEnd),
                    onInput: handleInput,
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: [unref(nsTextarea).e("inner"), unref(nsInput).is("focus", unref(isFocused))]
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.ariaLabel,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  rows: _ctx.rows,
                  role: _ctx.containerRole,
                  onCompositionstart: unref(handleCompositionStart),
                  onCompositionupdate: unref(handleCompositionUpdate),
                  onCompositionend: unref(handleCompositionEnd),
                  onInput: handleInput,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 38);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$2 = "Thumb";
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$2, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a2;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 42, ["onClick"]), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap)
              return;
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        tabindex: {
          type: [String, Number],
          default: void 0
        },
        id: String,
        role: String,
        ...useAriaProps(["ariaLabel", "ariaOrientation"])
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$1 = "ElScrollbar";
      const __default__$d = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          let wrapScrollTop = 0;
          let wrapScrollLeft = 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              wrapScrollTop = wrapRef.value.scrollTop;
              wrapScrollLeft = wrapRef.value.scrollLeft;
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a2;
            (_a2 = barRef.value) == null ? void 0 : _a2.update();
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onActivated(() => {
            if (wrapRef.value) {
              wrapRef.value.scrollTop = wrapScrollTop;
              wrapRef.value.scrollLeft = wrapScrollLeft;
            }
          });
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                tabindex: _ctx.tabindex,
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 46, ["tabindex"]),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$c = /* @__PURE__ */ defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$b = /* @__PURE__ */ defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "arrow.vue"]]);
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.tabIndex < 0 || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true") {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const NAME = "ElOnlyChild";
      const OnlyChild = /* @__PURE__ */ defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const __default__$a = /* @__PURE__ */ defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          const TRIGGER_ELE_EVENTS = [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ];
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                TRIGGER_ELE_EVENTS.forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                if (isFocusable(el)) {
                  virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                    [
                      "aria-controls",
                      "aria-describedby",
                      "aria-haspopup",
                      "aria-expanded"
                    ].forEach((key, idx) => {
                      isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                    });
                  }, { immediate: true });
                }
              }
              if (isElement(prevEl) && isFocusable(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (triggerRef.value && isElement(triggerRef.value)) {
              const el = triggerRef.value;
              TRIGGER_ELE_EVENTS.forEach((eventName) => {
                const handler = props[eventName];
                if (handler) {
                  el.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                }
              });
              triggerRef.value = void 0;
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          let cleanup = false;
          if (isElement(element) && !isFocusable(element) && !element.getAttribute("tabindex")) {
            element.setAttribute("tabindex", "-1");
            cleanup = true;
          }
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
          if (isElement(element) && cleanup) {
            element.removeAttribute("tabindex");
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack2 = [];
        const push = (layer) => {
          const currentLayer = stack2[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack2 = removeFromStack(stack2, layer);
          stack2.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack2 = removeFromStack(stack2, layer);
          (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        esc: "Escape",
        numpadEnter: "NumpadEnter"
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (event) => {
        if (event.code === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit2(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$1(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
            if (forwardRef.value) {
              forwardRef.value.removeEventListener("keydown", onKeydown);
              forwardRef.value.removeEventListener("focusin", onFocusIn);
              forwardRef.value.removeEventListener("focusout", onFocusOut);
              forwardRef.value = void 0;
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$2], ["__file", "focus-trap.vue"]]);
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U$1, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null) return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined") return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a2 = t.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e)) return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r)) return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I$1(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
      }
      function at(t) {
        return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N$1(t);
          if (r.position === "fixed") return null;
        }
        var o2 = ge(t);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; ) n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X$1(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $ = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I$1(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
      }
      function Ut(t) {
        var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t) {
        var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me) return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j) for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d2.find(function(de) {
              var ae = O2.get(de);
              if (ae) return ae.slice(0, z).every(function(Y2) {
                return Y2;
              });
            });
            if (V) return A2 = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break") break;
          }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E$1, W, R, P$1].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2)) return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
              if (typeof $ == "function") {
                var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: definePropType(String),
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        virtualTriggering: Boolean,
        zIndex: Number,
        ...useAriaProps(["ariaLabel"])
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const usePopperContentFocusTrap = (props, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance, {
          flush: "sync"
        });
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const __default__$9 = /* @__PURE__ */ defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: (e) => _ctx.$emit("mouseenter", e),
              onMouseleave: (e) => _ctx.$emit("mouseleave", e)
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const teleportProps = buildProps({
        to: {
          type: definePropType([String, Object]),
          required: true
        },
        disabled: Boolean
      });
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: teleportProps.to.type
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: Boolean,
        persistent: Boolean,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean,
        ...useAriaProps(["ariaLabel"])
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space]
        }
      });
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
          const isModelBindingAbsent = computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type) => {
        if (isArray$1(trigger2)) {
          return trigger2.includes(type);
        }
        return trigger2 === type;
      };
      const whenTrigger = (trigger2, type, handler) => {
        return (e) => {
          isTriggerType(unref(trigger2), type) && handler(e);
        };
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const __default__$8 = /* @__PURE__ */ defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger2 = toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "trigger.vue"]]);
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        __name: "teleport",
        props: teleportProps,
        setup(__props) {
          return (_ctx, _cache) => {
            return _ctx.disabled ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(Teleport$1, {
              key: 1,
              to: _ctx.to
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["to"]));
          };
        }
      });
      var Teleport = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "teleport.vue"]]);
      const ElTeleport = withInstall(Teleport);
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!document.body.querySelector(selector.value)) {
            createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const __default__$7 = /* @__PURE__ */ defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref();
          const popperContentRef = computedEager(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          });
          let stopHandle;
          const {
            controlled,
            id,
            open,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            stopHandle == null ? void 0 : stopHandle();
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed(() => {
            return props.disabled ? false : unref(open);
          });
          const appendTo = computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = ref(true);
          const onTransitionLeave = () => {
            onHide();
            isFocusInsideContent() && tryFocus(document.body);
            ariaHidden.value = true;
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(popperContentRef, () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          const isFocusInsideContent = (event) => {
            var _a2;
            const popperContent = (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent == null ? void 0 : popperContent.contains(activeElement);
          };
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            } else {
              ariaHidden.value = false;
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef,
            isFocusInsideContent
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport), {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, {
              default: withCtx(() => [
                createVNode(Transition, {
                  name: unref(transitionClass),
                  onAfterLeave: onTransitionLeave,
                  onBeforeEnter,
                  onAfterEnter: onAfterShow,
                  onBeforeLeave
                }, {
                  default: withCtx(() => [
                    unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                      key: 0,
                      id: unref(id),
                      ref_key: "contentRef",
                      ref: contentRef
                    }, _ctx.$attrs, {
                      "aria-label": _ctx.ariaLabel,
                      "aria-hidden": ariaHidden.value,
                      "boundaries-padding": _ctx.boundariesPadding,
                      "fallback-placements": _ctx.fallbackPlacements,
                      "gpu-acceleration": _ctx.gpuAcceleration,
                      offset: _ctx.offset,
                      placement: _ctx.placement,
                      "popper-options": _ctx.popperOptions,
                      strategy: _ctx.strategy,
                      effect: _ctx.effect,
                      enterable: _ctx.enterable,
                      pure: _ctx.pure,
                      "popper-class": _ctx.popperClass,
                      "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                      "reference-el": _ctx.referenceEl,
                      "trigger-target-el": _ctx.triggerTargetEl,
                      visible: unref(shouldShow),
                      "z-index": _ctx.zIndex,
                      onMouseenter: unref(onContentEnter),
                      onMouseleave: unref(onContentLeave),
                      onBlur,
                      onClose: unref(onClose)
                    }), {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                      [vShow, unref(shouldShow)]
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ]),
              _: 3
            }, 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "content.vue"]]);
      const __default__$6 = /* @__PURE__ */ defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          usePopperContainer();
          const ns = useNamespace("tooltip");
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props, "showAfter"),
            hideAfter: toRef(props, "hideAfter"),
            autoClose: toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          const kls = computed(() => {
            return [ns.b(), props.popperClass];
          });
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.isFocusInsideContent(event);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": unref(kls),
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, ["innerHTML"])) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaControls"])
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit: emit2 } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b, _c, _d;
          return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit2(CHANGE_EVENT, getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit2(CHANGE_EVENT, getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit: emit2 } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit2(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed(() => {
          if (!isPropAbsent(props.value)) {
            return props.value;
          }
          return props.label;
        });
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(toRaw).some((o2) => isEqual(o2, actualValue.value));
            } else {
              return value.map(toRaw).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueValue || value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a2, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true;
            }
          }
          props.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => isGroup.value && isPropAbsent(props.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const __default__$5 = /* @__PURE__ */ defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.ariaControls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a2, _b, _c, _d;
                return [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_b = (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel) != null ? _b : true,
                      "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createBaseVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "checkbox.vue"]]);
      const __default__$4 = /* @__PURE__ */ defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a2, _b, _c, _d;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_b = (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel) != null ? _b : true,
                "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      };
      const __default__$3 = /* @__PURE__ */ defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit2(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit2(CHANGE_EVENT, value);
          };
          const modelValue = computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const nodeList = /* @__PURE__ */ new Map();
      if (isClient) {
        let startClick;
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          if (startClick) {
            for (const handlers of nodeList.values()) {
              for (const { documentHandler } of handlers) {
                documentHandler(e, startClick);
              }
            }
            startClick = void 0;
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (isArray$1(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const __default__$2 = /* @__PURE__ */ defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision) ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$1(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
              if (newVal !== value) {
                update && emit2(UPDATE_MODEL_EVENT, newVal);
              }
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit2(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit2(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit2(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit2(CHANGE_EVENT, newVal, oldVal);
            }
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit2(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit2("focus", event);
          };
          const handleBlur = (event) => {
            var _a2, _b;
            data.userInput = null;
            if (isFirefox() && data.currentValue === null && ((_a2 = input.value) == null ? void 0 : _a2.input)) {
              input.value.input.value = "";
            }
            emit2("blur", event);
            if (props.validateEvent) {
              (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props.modelValue) {
              data.currentValue = props.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a2;
            const { min, max, modelValue } = props;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit2(UPDATE_MODEL_EVENT, val);
            }
            innerInput.addEventListener("wheel", handleWheel, { passive: false });
          });
          onUpdated(() => {
            var _a2, _b;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: withModifiers(() => {
              }, ["prevent"])
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                "aria-label": _ctx.ariaLabel,
                "validate-event": false,
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, createSlots({
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "prefix")
                  ])
                } : void 0,
                _ctx.$slots.suffix ? {
                  name: "suffix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "suffix")
                  ])
                } : void 0
              ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
            ], 42, ["onDragstart"]);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      const switchProps = buildProps({
        modelValue: {
          type: [Boolean, String, Number],
          default: false
        },
        disabled: Boolean,
        loading: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        width: {
          type: [String, Number],
          default: ""
        },
        inlinePrompt: Boolean,
        inactiveActionIcon: {
          type: iconPropType
        },
        activeActionIcon: {
          type: iconPropType
        },
        activeIcon: {
          type: iconPropType
        },
        inactiveIcon: {
          type: iconPropType
        },
        activeText: {
          type: String,
          default: ""
        },
        inactiveText: {
          type: String,
          default: ""
        },
        activeValue: {
          type: [Boolean, String, Number],
          default: true
        },
        inactiveValue: {
          type: [Boolean, String, Number],
          default: false
        },
        name: {
          type: String,
          default: ""
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        beforeChange: {
          type: definePropType(Function)
        },
        id: String,
        tabindex: {
          type: [String, Number]
        },
        ...useAriaProps(["ariaLabel"])
      });
      const switchEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
        [CHANGE_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
        [INPUT_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val)
      };
      const COMPONENT_NAME = "ElSwitch";
      const __default__$1 = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: switchProps,
        emits: switchEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const { formItem } = useFormItem();
          const switchSize = useFormSize();
          const ns = useNamespace("switch");
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const switchDisabled = useFormDisabled(computed(() => props.loading));
          const isControlled = ref(props.modelValue !== false);
          const input = ref();
          const core = ref();
          const switchKls = computed(() => [
            ns.b(),
            ns.m(switchSize.value),
            ns.is("disabled", switchDisabled.value),
            ns.is("checked", checked.value)
          ]);
          const labelLeftKls = computed(() => [
            ns.e("label"),
            ns.em("label", "left"),
            ns.is("active", !checked.value)
          ]);
          const labelRightKls = computed(() => [
            ns.e("label"),
            ns.em("label", "right"),
            ns.is("active", checked.value)
          ]);
          const coreStyle = computed(() => ({
            width: addUnit(props.width)
          }));
          watch(() => props.modelValue, () => {
            isControlled.value = true;
          });
          const actualValue = computed(() => {
            return isControlled.value ? props.modelValue : false;
          });
          const checked = computed(() => actualValue.value === props.activeValue);
          if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
            emit2(UPDATE_MODEL_EVENT, props.inactiveValue);
            emit2(CHANGE_EVENT, props.inactiveValue);
            emit2(INPUT_EVENT, props.inactiveValue);
          }
          watch(checked, (val) => {
            var _a2;
            input.value.checked = val;
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const handleChange = () => {
            const val = checked.value ? props.inactiveValue : props.activeValue;
            emit2(UPDATE_MODEL_EVENT, val);
            emit2(CHANGE_EVENT, val);
            emit2(INPUT_EVENT, val);
            nextTick(() => {
              input.value.checked = checked.value;
            });
          };
          const switchValue = () => {
            if (switchDisabled.value)
              return;
            const { beforeChange } = props;
            if (!beforeChange) {
              handleChange();
              return;
            }
            const shouldChange = beforeChange();
            const isPromiseOrBool = [
              isPromise(shouldChange),
              isBoolean(shouldChange)
            ].includes(true);
            if (!isPromiseOrBool) {
              throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
            }
            if (isPromise(shouldChange)) {
              shouldChange.then((result) => {
                if (result) {
                  handleChange();
                }
              }).catch((e) => {
              });
            } else if (shouldChange) {
              handleChange();
            }
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          onMounted(() => {
            input.value.checked = checked.value;
          });
          expose({
            focus,
            checked
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(switchKls)),
              onClick: withModifiers(switchValue, ["prevent"])
            }, [
              createBaseVNode("input", {
                id: unref(inputId),
                ref_key: "input",
                ref: input,
                class: normalizeClass(unref(ns).e("input")),
                type: "checkbox",
                role: "switch",
                "aria-checked": unref(checked),
                "aria-disabled": unref(switchDisabled),
                "aria-label": _ctx.ariaLabel,
                name: _ctx.name,
                "true-value": _ctx.activeValue,
                "false-value": _ctx.inactiveValue,
                disabled: unref(switchDisabled),
                tabindex: _ctx.tabindex,
                onChange: handleChange,
                onKeydown: withKeys(switchValue, ["enter"])
              }, null, 42, ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]),
              !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelLeftKls))
              }, [
                _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": unref(checked)
                }, toDisplayString(_ctx.inactiveText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("span", {
                ref_key: "core",
                ref: core,
                class: normalizeClass(unref(ns).e("core")),
                style: normalizeStyle(unref(coreStyle))
              }, [
                _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("inner"))
                }, [
                  _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(ns).is("text")),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, ["aria-hidden"])) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("action"))
                }, [
                  _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(loading_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                    _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                    _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true)
                ], 2)
              ], 6),
              !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(labelRightKls))
              }, [
                _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": !unref(checked)
                }, toDisplayString(_ctx.activeText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 10, ["onClick"]);
          };
        }
      });
      var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__file", "switch.vue"]]);
      const ElSwitch = withInstall(Switch);
      const getCell = function(event) {
        var _a2;
        return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
      };
      const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
        if (!sortKey && !sortMethod && (!sortBy || isArray$1(sortBy) && !sortBy.length)) {
          return array;
        }
        if (isString$1(reverse)) {
          reverse = reverse === "descending" ? -1 : 1;
        } else {
          reverse = reverse && reverse < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index) {
          if (sortBy) {
            if (!isArray$1(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map((by) => {
              if (isString$1(by)) {
                return get(value, by);
              } else {
                return by(value, index, array);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$1(value) && "$value" in value)
              value = value.$value;
          }
          return [isObject$1(value) ? get(value, sortKey) : value];
        };
        const compare = function(a2, b2) {
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = a2.key.length; i < len; i++) {
            if (a2.key[i] < b2.key[i]) {
              return -1;
            }
            if (a2.key[i] > b2.key[i]) {
              return 1;
            }
          }
          return 0;
        };
        return array.map((value, index) => {
          return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches) {
          return getColumnById(table, matches[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (isString$1(rowKey)) {
          if (!rowKey.includes(".")) {
            return `${row[rowKey]}`;
          }
          const key = rowKey.split(".");
          let current = row;
          for (const element of key) {
            current = current[element];
          }
          return `${current}`;
        } else if (isFunction$1(rowKey)) {
          return rowKey.call(null, row);
        }
      };
      const getKeysMap = function(array, rowKey, flatten2 = false, childrenKey = "children") {
        const data = array || [];
        const arrayMap2 = {};
        data.forEach((row, index) => {
          arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
          if (flatten2) {
            const children = row[childrenKey];
            if (isArray$1(children)) {
              Object.assign(arrayMap2, getKeysMap(children, rowKey, true, childrenKey));
            }
          }
        });
        return arrayMap2;
      };
      function mergeOptions(defaults, config) {
        const options = {};
        let key;
        for (key in defaults) {
          options[key] = defaults[key];
        }
        for (key in config) {
          if (hasOwn(config, key)) {
            const value = config[key];
            if (!isUndefined(value)) {
              options[key] = value;
            }
          }
        }
        return options;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (!isUndefined(width)) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (!isUndefined(minWidth)) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (isNumber(height)) {
          return height;
        }
        if (isString$1(height)) {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex) {
        let _rowIndex = rowIndex != null ? rowIndex : 0;
        let changed = false;
        const index = statusArr.indexOf(row);
        const included = index !== -1;
        const isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, _rowIndex);
        const toggleStatus = (type) => {
          if (type === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index, 1);
          }
          changed = true;
        };
        const getChildrenCount = (row2) => {
          let count = 0;
          const children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];
          if (children && isArray$1(children)) {
            count += children.length;
            children.forEach((item) => {
              count += getChildrenCount(item);
            });
          }
          return count;
        };
        if (!selectable || isRowSelectable) {
          if (isBoolean(newVal)) {
            if (newVal && !included) {
              toggleStatus("add");
            } else if (!newVal && included) {
              toggleStatus("remove");
            }
          } else {
            included ? toggleStatus("remove") : toggleStatus("add");
          }
        }
        if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray$1(row[tableTreeProps.children])) {
          row[tableTreeProps.children].forEach((item) => {
            const childChanged = toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1);
            _rowIndex += getChildrenCount(item) + 1;
            if (childChanged) {
              changed = childChanged;
            }
          });
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
        const isNil2 = (array) => !(isArray$1(array) && array.length);
        function _walker(parent, children, level) {
          cb(parent, children, level);
          children.forEach((item) => {
            if (item[lazyKey]) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      const getTableOverflowTooltipProps = (props, innerText, row, column) => {
        const popperOptions = {
          strategy: "fixed",
          ...props.popperOptions
        };
        const tooltipFormatterContent = isFunction$1(column.tooltipFormatter) ? column.tooltipFormatter({
          row,
          column,
          cellValue: getProp(row, column.property).value
        }) : void 0;
        if (isVNode(tooltipFormatterContent)) {
          return {
            slotContent: tooltipFormatterContent,
            content: null,
            ...props,
            popperOptions
          };
        }
        return {
          slotContent: null,
          content: tooltipFormatterContent != null ? tooltipFormatterContent : innerText,
          ...props,
          popperOptions
        };
      };
      let removePopper = null;
      function createTablePopper(props, popperContent, row, column, trigger2, table) {
        const tableOverflowTooltipProps = getTableOverflowTooltipProps(props, popperContent, row, column);
        const mergedProps = {
          ...tableOverflowTooltipProps,
          slotContent: void 0
        };
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger2) {
          const comp = removePopper.vm.component;
          merge(comp.props, mergedProps);
          if (tableOverflowTooltipProps.slotContent) {
            comp.slots.content = () => [tableOverflowTooltipProps.slotContent];
          }
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const vm = createVNode(ElTooltip, {
          virtualTriggering: true,
          virtualRef: trigger2,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...mergedProps
        }, tableOverflowTooltipProps.slotContent ? {
          content: () => tableOverflowTooltipProps.slotContent
        } : void 0);
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger2;
        removePopper.vm = vm;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index, fixed, store, realColumns) => {
        let start = 0;
        let after = index;
        const columns = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index]);
          const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after
        } : {};
      };
      const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
        const classes = [];
        const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
        if (direction) {
          const isLeft = direction === "left";
          classes.push(`${namespace}-fixed-column--${direction}`);
          if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset, column) {
        return offset + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index, fixed, store, realColumns) => {
        const {
          direction,
          start = 0,
          after = 0
        } = isFixedColumn(index, fixed, store, realColumns);
        if (!direction) {
          return;
        }
        const styles = {};
        const isLeft = direction === "left";
        const columns = store.states.columns.value;
        if (isLeft) {
          styles.left = columns.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style, key) => {
        if (!style)
          return;
        if (!Number.isNaN(style[key])) {
          style[key] = `${style[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data.slice();
          } else if (rowKey) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey);
            expandRows.value = data.reduce((prev, row) => {
              const rowId = getRowIdentity(row, rowKey);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev.push(row);
              }
              return prev;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          const keysMap = getKeysMap(data, rowKey);
          expandRows.value = rowKeys.reduce((prev, cur) => {
            const info = keysMap[cur];
            if (info) {
              prev.push(info.row);
            }
            return prev;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey = watcherData.rowKey.value;
          if (rowKey) {
            const expandMap = getKeysMap(expandRows.value, rowKey);
            return !!expandMap[getRowIdentity(row, rowKey)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          const { data, rowKey } = watcherData;
          let _currentRow = null;
          if (rowKey.value) {
            _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
          }
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey = watcherData.rowKey.value;
          const data = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (!data.includes(oldCurrentRow) && oldCurrentRow) {
            if (rowKey) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (isNull(currentRow.value)) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const checkStrictly = ref(false);
        const instance = getCurrentInstance();
        const normalizedData = computed(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data = watcherData.data.value || [];
          return normalize(data);
        });
        const normalizedLazyNode = computed(() => {
          const rowKey = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data) => {
          const rowKey = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data, (parent, children, level) => {
            const parentId = getRowIdentity(parent, rowKey);
            if (isArray$1(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
          var _a2;
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (newTreeData[key].children.length !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: ""
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const isUseLazy = (data) => {
          return lazy.value && data && "loaded" in data && !data.loaded;
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = id && treeData.value[id];
          if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = isUndefined(expanded) ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            isUseLazy(data) && loadData(row, id, data);
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = treeData.value[id];
          if (isUseLazy(data)) {
            loadData(row, id, data);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data) => {
              if (!isArray$1(data)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data.length) {
                lazyTreeNodeMap.value[key] = data;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        const updateKeyChildren = (key, data) => {
          const { lazy: lazy2, rowKey } = instance.props;
          if (!lazy2)
            return;
          if (!rowKey)
            throw new Error("[Table] rowKey is required in updateKeyChild");
          if (lazyTreeNodeMap.value[key]) {
            lazyTreeNodeMap.value[key] = data;
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          updateKeyChildren,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName,
            checkStrictly
          }
        };
      }
      const sortData = (data, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || isString$1(sortingColumn.sortable)) {
          return data;
        }
        return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result.push.apply(result, doFlattenColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      function useWatcher$1() {
        var _a2;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
        const rowKey = ref(null);
        const data = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        const selectedMap = computed(() => {
          return rowKey.value ? getKeysMap(selection.value, rowKey.value) : void 0;
        });
        watch(data, () => {
          var _a22;
          if (instance.state) {
            scheduleLayout(false);
            const needUpdateFixed = instance.props.tableLayout === "auto";
            if (needUpdateFixed) {
              (_a22 = instance.refs.tableHeaderRef) == null ? void 0 : _a22.updateFixedColumnStyle();
            }
          }
        }, {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a22;
          (_a22 = column.children) == null ? void 0 : _a22.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          var _a22, _b;
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => column.type !== "selection" && [true, "left"].includes(column.fixed));
          let selectColFixLeft;
          if (((_b = (_a22 = _columns.value) == null ? void 0 : _a22[0]) == null ? void 0 : _b.type) === "selection") {
            const selectColumn = _columns.value[0];
            selectColFixLeft = [true, "left"].includes(selectColumn.fixed) || fixedColumns.value.length && selectColumn.fixed !== "right";
            if (selectColFixLeft) {
              fixedColumns.value.unshift(selectColumn);
            }
          }
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          const notFixedColumns = _columns.value.filter((column) => (selectColFixLeft ? column.type !== "selection" : true) && !column.fixed);
          originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          if (selectedMap.value) {
            return !!selectedMap.value[getRowIdentity(row, rowKey.value)];
          } else {
            return selection.value.includes(row);
          }
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          selection.value = [];
          if (oldSelection.length) {
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          var _a22, _b;
          let deleted;
          if (rowKey.value) {
            deleted = [];
            const childrenKey = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.childrenColumnName.value;
            const dataMap = getKeysMap(data.value, rowKey.value, true, childrenKey);
            for (const key in selectedMap.value) {
              if (hasOwn(selectedMap.value, key) && !dataMap[key]) {
                deleted.push(selectedMap.value[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected, emitChange = true, ignoreSelectable = false) => {
          var _a22, _b, _c, _d;
          const treeProps = {
            children: (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.childrenColumnName.value,
            checkStrictly: (_d = (_c = instance == null ? void 0 : instance.store) == null ? void 0 : _c.states) == null ? void 0 : _d.checkStrictly.value
          };
          const changed = toggleRowStatus(selection.value, row, selected, treeProps, ignoreSelectable ? void 0 : selectable.value, data.value.indexOf(row));
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a22, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey2 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
          const { childrenColumnName } = instance.store.states;
          const treeProps = {
            children: childrenColumnName.value,
            checkStrictly: false
          };
          data.value.forEach((row, index) => {
            const rowIndex = index + childrenCount;
            if (toggleRowStatus(selection.value, row, value, treeProps, selectable.value, rowIndex)) {
              selectionChanged = true;
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", (selection.value || []).slice());
        };
        const updateSelectionByRowKey = () => {
          data.value.forEach((row) => {
            const rowId = getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap.value[rowId];
            if (rowInfo) {
              selection.value[rowInfo.index] = row;
            }
          });
        };
        const updateAllSelected = () => {
          var _a22;
          if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          const { childrenColumnName } = instance.store.states;
          let rowIndex = 0;
          let selectedCount = 0;
          const checkSelectedStatus = (data2) => {
            var _a3;
            for (const row of data2) {
              const isRowSelectable = selectable.value && selectable.value.call(null, row, rowIndex);
              if (!isSelected(row)) {
                if (!selectable.value || isRowSelectable) {
                  return false;
                }
              } else {
                selectedCount++;
              }
              rowIndex++;
              if (((_a3 = row[childrenColumnName.value]) == null ? void 0 : _a3.length) && !checkSelectedStatus(row[childrenColumnName.value])) {
                return false;
              }
            }
            return true;
          };
          const isAllSelected_ = checkSelectedStatus(data.value || []);
          isAllSelected.value = selectedCount === 0 ? false : isAllSelected_;
        };
        const getChildrenCount = (rowKey2) => {
          var _a22;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a22 = treeData.value[rowKey2]) == null ? void 0 : _a22.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (columns2, values) => {
          if (!isArray$1(columns2)) {
            columns2 = [columns2];
          }
          const filters_ = {};
          columns2.forEach((col) => {
            filters.value[col.id] = values;
            filters_[col.columnKey || col.id] = values;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values = filters.value[columnId];
            if (!values || values.length === 0)
              return;
            const column = getColumnById({
              columns: columns.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          data.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore && ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (isString$1(columnKeys)) {
            columnKeys = [columnKeys];
          }
          if (isArray$1(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data,
          rowKey
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          updateKeyChildren,
          loadOrToggle,
          states: treeStates
        } = useTree({
          data,
          rowKey
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data,
          rowKey
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns.value.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateSelectionByRowKey,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          updateKeyChildren,
          states: {
            tableSize,
            rowKey,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array, column) {
        return array.map((item) => {
          var _a2;
          if (item.id === column.id) {
            return column;
          } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array) {
        array.forEach((item) => {
          var _a2, _b;
          item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data) {
            const dataInstanceChanged = unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
              instance.store.updateSelectionByRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns);
            let newColumns = [];
            if (!parent) {
              array.push(column);
              newColumns = array;
            } else {
              if (parent && !parent.children) {
                parent.children = [];
              }
              parent.children.push(column);
              newColumns = replaceColumn(array, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a2;
            const newColumnIndex = (_a2 = column.getColumnIndex) == null ? void 0 : _a2.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns) || [];
            if (parent) {
              parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a2;
                if (((_a2 = parent.children) == null ? void 0 : _a2.length) === 0) {
                  delete parent.children;
                }
              });
              states._columns.value = replaceColumn(array, parent);
            } else {
              const index = array.indexOf(column);
              if (index > -1) {
                array.splice(index, 1);
                states._columns.value = array;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options) {
            const { prop, order, init } = options;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init });
              }
            }
          },
          changeSortCondition(states, options) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (isNull(orderValue)) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options || !(options.silent || options.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options) {
            const { column, values, silent } = options;
            const newFilters = instance.store.updateFilters(column, values);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            instance.store.toggleAllSelection();
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [instance.store.states].concat(args));
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        },
        ["treeProps.checkStrictly"]: {
          key: "checkStrictly",
          default: false
        }
      };
      function createStore(table, props) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props, key), key, store);
        });
        proxyTableProps(store, props);
        return store;
      }
      function proxyTableProps(store, props) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (isObject$1(InitialStateMap[propsKey])) {
          storeKey = storeKey.key;
          newVal = newVal || InitialStateMap[propsKey].default;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props, keys2) {
        if (keys2.includes(".")) {
          const keyList = keys2.split(".");
          let value = props;
          keyList.forEach((key) => {
            value = value[key];
          });
          return value;
        } else {
          return props[keys2];
        }
      }
      class TableLayout {
        constructor(options) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options) {
            if (hasOwn(options, name)) {
              if (isRef(this[name])) {
                this[name].value = options[name];
              } else {
                this[name] = options[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (isNull(height))
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0))
            return nextTick(() => this.setHeight(value, prop));
          if (isNumber(value)) {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (isString$1(value)) {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns = this.table.store.states.columns.value;
          columns.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          if (!isClient)
            return;
          const fit = this.fit;
          const bodyWidth = this.table.vnode.el.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => !isNumber(column.width));
          flattenColumns.forEach((column) => {
            if (isNumber(column.width) && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index) => {
                  if (index === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index = this.observers.indexOf(observer);
          if (index !== -1) {
            this.observers.splice(index, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a2, _b;
            switch (event) {
              case "columns":
                (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon,
          ArrowDown: arrow_down_default,
          ArrowUp: arrow_up_default
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          },
          appendTo: useTooltipContentProps.appendTo
        },
        setup(props) {
          const instance = getCurrentInstance();
          const { t } = useLocale();
          const ns = useNamespace("table-filter");
          const parent = instance == null ? void 0 : instance.parent;
          if (!parent.filterPanels.value[props.column.id]) {
            parent.filterPanels.value[props.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed(() => {
            return props.column && props.column.filters;
          });
          const filterClassName = computed(() => {
            if (props.column.filterClassName) {
              return `${ns.b()} ${props.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed({
            get: () => {
              var _a2;
              return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (!isPropAbsent(value)) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed({
            get() {
              if (props.column) {
                return props.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              if (props.column) {
                props.upDataColumn("filteredValue", value);
              }
            }
          });
          const multiple = computed(() => {
            if (props.column) {
              return props.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter) => {
            return filter.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (!isPropAbsent(_filterValue)) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            props.store.commit("filterChange", {
              column: props.column,
              values: filteredValue2
            });
            props.store.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            if (props.column) {
              props.upDataColumn("filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isPropAbsent,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: "",
          "append-to": _ctx.appendTo
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", { key: 0 }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": ($event) => _ctx.filteredValue = $event,
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter.value,
                            value: filter.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(filter.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "onUpdate:modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createBaseVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _ctx.handleConfirm
                }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, ["disabled", "onClick"]),
                createBaseVNode("button", {
                  type: "button",
                  onClick: _ctx.handleReset
                }, toDisplayString(_ctx.t("el.table.resetFilter")), 9, ["onClick"])
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createBaseVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.isPropAbsent(_ctx.filterValue)
                  }
                ]),
                onClick: ($event) => _ctx.handleSelect(null)
              }, toDisplayString(_ctx.t("el.table.clearFilter")), 11, ["onClick"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                return openBlock(), createElementBlock("li", {
                  key: filter.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
                  label: filter.value,
                  onClick: ($event) => _ctx.handleSelect(filter.value)
                }, toDisplayString(filter.text), 11, ["label", "onClick"]);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _ctx.showFilterPanel
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "filter-icon", {}, () => [
                    _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                  ])
                ]),
                _: 3
              })
            ], 10, ["onClick"])), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 3
        }, 8, ["visible", "placement", "popper-class", "append-to"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$1], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed(() => {
          const layout = root2.layout;
          if (!layout) {
            throw new Error("Can not find table layout.");
          }
          return layout;
        });
        const onColumnsChange = (layout) => {
          var _a2;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout) => {
          var _a2, _b;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props, emit2) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent == null ? void 0 : parent.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref({});
        const handleMouseDown = (event, column) => {
          if (!isClient)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props.border) {
            dragging.value = true;
            const table = parent;
            emit2("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = {};
                emit2("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          var _a2;
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement(el)) {
            return;
          }
          const target = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable || !target)
            return;
          if (!dragging.value && props.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            const isLastTh = ((_a2 = target.parentNode) == null ? void 0 : _a2.lastElementChild) === target;
            const allowDarg = props.allowDragLastColumn || !isLastTh;
            if (rect.width > 12 && rect.right - event.clientX < 8 && allowDarg) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index = sortOrders.indexOf(order || null);
          return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a2;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
          if (target) {
            if (hasClass(target, "noclick")) {
              removeClass(target, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const clickTarget = event.currentTarget;
          if (["ascending", "descending"].some((str) => hasClass(clickTarget, str) && !column.sortOrders.includes(str))) {
            return;
          }
          const states = props.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && isNull(sortingColumn.order)) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent == null ? void 0 : parent.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
          if (isFunction$1(headerRowStyle)) {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
          if (isString$1(headerRowClassName)) {
            classes.push(headerRowClassName);
          } else if (isFunction$1(headerRowClassName)) {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a2;
          let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
          if (isFunction$1(headerCellStyles)) {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
          if (isString$1(headerCellClassName)) {
            classes.push(headerCellClassName);
          } else if (isFunction$1(headerCellClassName)) {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse2 = (column, parent) => {
          if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse2(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse2(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const columnRows = computed(() => {
          return convertToRows(props.store.states.originColumns.value);
        });
        const isGroup = computed(() => {
          const result = columnRows.value.length > 1;
          if (result && parent) {
            parent.state.isGroup.value = true;
          }
          return result;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent == null ? void 0 : parent.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = /* @__PURE__ */ defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          },
          appendFilterPanelTo: {
            type: String
          },
          allowDragLastColumn: {
            type: Boolean
          }
        },
        setup(props, { emit: emit2 }) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const isTableLayoutAuto = (parent == null ? void 0 : parent.props.tableLayout) === "auto";
          const saveIndexSelection = reactive(/* @__PURE__ */ new Map());
          const theadRef = ref();
          const updateFixedColumnStyle = () => {
            setTimeout(() => {
              if (saveIndexSelection.size > 0) {
                saveIndexSelection.forEach((column, key) => {
                  const el = theadRef.value.querySelector(`.${key.replace(/\s/g, ".")}`);
                  if (el) {
                    const width = el.getBoundingClientRect().width;
                    column.width = width;
                  }
                });
                saveIndexSelection.clear();
              }
            });
          };
          watch(saveIndexSelection, updateFixedColumnStyle);
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props.defaultSort;
            parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
            updateFixedColumnStyle();
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props, emit2);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection,
            saveIndexSelection,
            isTableLayoutAuto,
            theadRef,
            updateFixedColumnStyle
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent,
            saveIndexSelection,
            isTableLayoutAuto
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            ref: "theadRef",
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            const _class = getHeaderCellClass(rowIndex, cellIndex, subColumns, column);
            if (isTableLayoutAuto && column.fixed) {
              saveIndexSelection.set(_class, column);
            }
            return h$1("th", {
              class: _class,
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => {
                if ($event.currentTarget.classList.contains("noclick")) {
                  return;
                }
                handleHeaderClick($event, column);
              },
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  appendTo: $parent.appendFilterPanelTo,
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                }, {
                  "filter-icon": () => column.renderFilterIcon ? column.renderFilterIcon({
                    filterOpened: column.filterOpened
                  }) : null
                })
              ])
            ]);
          }))));
        }
      });
      function isGreaterThan(a2, b2, epsilon = 0.03) {
        return a2 - b2 > epsilon;
      }
      function useEvents(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a2;
          const table = parent;
          const cell = getCell(event);
          let column;
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          props.store.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index) => {
          props.store.commit("setHoverRow", index);
        }, 30);
        const handleMouseLeave = debounce(() => {
          props.store.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          let node = event.target.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a2, _b, _c;
          const table = parent;
          const cell = getCell(event);
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          let column;
          if (cell) {
            column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = { cell, column, row };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range = document.createRange();
          range.setStart(cellChild, 0);
          range.setEnd(cellChild, cellChild.childNodes.length);
          const { width: rangeWidth, height: rangeHeight } = range.getBoundingClientRect();
          const { width: cellChildWidth, height: cellChildHeight } = cellChild.getBoundingClientRect();
          const { top, left, right, bottom } = getPadding(cellChild);
          const horizontalPadding = left + right;
          const verticalPadding = top + bottom;
          if (isGreaterThan(rangeWidth + horizontalPadding, cellChildWidth) || isGreaterThan(rangeHeight + verticalPadding, cellChildHeight) || isGreaterThan(cellChild.scrollWidth, cellChildWidth)) {
            createTablePopper(tooltipOptions, cell.innerText || cell.textContent, row, column, cell, table);
          } else if (((_b = removePopper) == null ? void 0 : _b.trigger) === cell) {
            (_c = removePopper) == null ? void 0 : _c();
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent == null ? void 0 : parent.hoverState;
          parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
          if (isFunction$1(rowStyle)) {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          const classes = [ns.e("row")];
          if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
            classes.push("current-row");
          }
          if (props.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
          if (isString$1(rowClassName)) {
            classes.push(rowClassName);
          } else if (isFunction$1(rowClassName)) {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (isFunction$1(cellStyle)) {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
          if (isString$1(cellClassName)) {
            classes.push(cellClassName);
          } else if (isFunction$1(cellClassName)) {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent == null ? void 0 : parent.props.spanMethod;
          if (isFunction$1(fn2)) {
            const result = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (isArray$1(result)) {
              rowspan = result[0];
              colspan = result[1];
            } else if (isObject$1(result)) {
              rowspan = result.rowspan;
              colspan = result.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns, colspan, index) => {
          if (colspan < 1) {
            return columns[index].realWidth;
          }
          const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      const __default__ = /* @__PURE__ */ defineComponent({
        name: "TableTdWrapper"
      });
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: {
          colspan: {
            type: Number,
            default: 1
          },
          rowspan: {
            type: Number,
            default: 1
          }
        },
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("td", {
              colspan: __props.colspan,
              rowspan: __props.rowspan
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["colspan", "rowspan"]);
          };
        }
      });
      var TdWrapper = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__file", "td-wrapper.vue"]]);
      function useRender$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles(props);
        const firstDefaultColumnIndex = computed(() => {
          return props.store.states.columns.value.findIndex(({ type }) => type === "default");
        });
        const getKeyOfRow = (row, index) => {
          const rowKey = parent.props.rowKey;
          if (rowKey) {
            return getRowIdentity(row, rowKey);
          }
          return index;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props;
          const { indent, columns } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = treeRowData.display;
          }
          const displayStyle = display ? null : { display: "none" };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
            const data = {
              store: props.store,
              _self: props.context || parent,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data.treeNode = {
                indent: treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (isBoolean(treeRowData.expanded)) {
                data.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${getKeyOfRow(row, $index)},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const mergedTooltipOptions = column.showOverflowTooltip && merge({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1(TdWrapper, {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, {
              default: () => cellChildren(cellIndex, column, data)
            });
          }));
        };
        const cellChildren = (cellIndex, column, data) => {
          return column.renderCell(data);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
          const columns = store.states.columns.value;
          const hasExpandColumn = columns.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent.renderExpanded;
            if (!renderExpanded) {
              console.error("[Element Error]renderExpanded is required.");
              return tr;
            }
            const rows = [[tr]];
            if (parent.props.preserveExpandedContent || expanded) {
              rows[0].push(h$1("tr", {
                key: `expanded-row__${tr.key}`,
                style: { display: expanded ? "" : "none" }
              }, [
                h$1("td", {
                  colspan: columns.length,
                  class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                }, [renderExpanded({ row, $index, store, expanded })])
              ]));
            }
            return rows;
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true
              };
              if (isBoolean(cur.lazy)) {
                if (isBoolean(cur.loaded) && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData)];
            if (cur) {
              let i = 0;
              const traverse2 = (children, parent2) => {
                if (!(children && children.length && parent2))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent2.display && parent2.expanded,
                    level: parent2.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey.value);
                  if (isPropAbsent(childKey)) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (isBoolean(cur.lazy)) {
                      if (isBoolean(cur.loaded) && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse2(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse2(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$2 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var TableBody = /* @__PURE__ */ defineComponent({
        name: "ElTableBody",
        props: defaultProps$2,
        setup(props) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const hoveredCellList = [];
          watch(props.store.states.hoverRow, (newVal, oldVal) => {
            var _a2;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a2 = rows[rowNum]) == null ? void 0 : _a2.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index) => {
                var _a22, _b;
                if (((_a22 = childNodes[index]) == null ? void 0 : _a22.colSpan) > 1) {
                  control = (_b = childNodes[index]) == null ? void 0 : _b.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a22;
                rowNum = newVal;
                while (rowNum > 0) {
                  const preChildNodes = (_a22 = rows[rowNum - 1]) == null ? void 0 : _a22.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!props.store.states.isComplex.value || !isClient)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a2;
            (_a2 = removePopper) == null ? void 0 : _a2();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data = store.states.data.value || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed(() => {
          return store.states.fixedLeafColumnsLength.value;
        });
        const rightFixedLeafCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        const columnsCount = computed(() => {
          return store.states.columns.value.length;
        });
        const leftFixedCount = computed(() => {
          return store.states.fixedColumns.value.length;
        });
        const rightFixedCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: store.states.columns
        };
      }
      function useStyle$1(props) {
        const { columns } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns2, cellIndex) => {
          const column = columns2[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns
        };
      }
      var TableFooter = /* @__PURE__ */ defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props) {
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { getCellClasses, getCellStyles, columns } = useStyle$1(props);
          const { onScrollableChange, onColumnsChange } = useLayoutObserver(parent);
          return {
            ns,
            onScrollableChange,
            onColumnsChange,
            getCellClasses,
            getCellStyles,
            columns
          };
        },
        render() {
          const { columns, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns,
              data
            });
          } else {
            columns.forEach((column, index) => {
              if (index === 0) {
                sums[index] = sumText;
                return;
              }
              const values = data.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index] = values.reduce((prev, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev;
                  }
                }, 0);
              } else {
                sums[index] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected, ignoreSelectable = true) => {
          store.toggleRowSelection(row, selected, false, ignoreSelectable);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        const updateKeyChildren = (key, data) => {
          store.updateKeyChildren(key, data);
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort,
          updateKeyChildren
        };
      }
      function useStyle(props, layout, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          layout.setHeight(props.height);
        });
        watchEffect(() => {
          layout.setMaxHeight(props.maxHeight);
        });
        watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
          if (!unref(rowKey) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          table.store.commit("setData", data);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props.expandRowKeys) {
            store.setExpandRowKeysAdapter(props.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (event, data) => {
          const { pixelX, pixelY } = data;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed(() => {
          return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed(() => {
          return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout.updateElsHeight();
          }
          layout.updateColumnsWidth();
          if (typeof window === "undefined")
            return;
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a2, _b;
            resizeListener();
            (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a2, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
          if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed(() => {
          if (props.maxHeight)
            return "fixed";
          return props.tableLayout;
        });
        const emptyBlockStyle = computed(() => {
          if (props.data && props.data.length)
            return null;
          let height = "100%";
          if (props.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const scrollbarStyle = computed(() => {
          if (props.height) {
            return {
              height: "100%"
            };
          }
          if (props.maxHeight) {
            if (!Number.isNaN(Number(props.maxHeight))) {
              return {
                maxHeight: `${props.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        const handleFixedMousewheel = (event, data) => {
          const bodyWrapper = table.refs.bodyWrapper;
          if (Math.abs(data.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data.pixelY < 0 && currentScrollTop !== 0) {
              event.preventDefault();
            }
            if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
              event.preventDefault();
            }
            bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
          } else {
            bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
          }
        };
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a2;
          (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
        });
      }
      var defaultProps$1 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children",
              checkStrictly: false
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object],
        tooltipFormatter: Function,
        appendFilterPanelTo: String,
        scrollbarTabindex: {
          type: [Number, String],
          default: void 0
        },
        allowDragLastColumn: {
          type: Boolean,
          default: true
        },
        preserveExpandedContent: {
          type: Boolean,
          default: false
        }
      };
      function hColgroup(props) {
        const isAuto = props.tableLayout === "auto";
        let columns = props.columns || [];
        if (isAuto) {
          if (columns.every(({ width }) => isUndefined(width))) {
            columns = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar = () => {
        const scrollBarRef = ref();
        const scrollTo = (options, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options, yCoord);
          }
        };
        const setScrollPosition = (position, offset) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber(offset) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left) => setScrollPosition("Left", left);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t ? parseFloat(t[1].replace("_", ".")) : true;
            } else l = false;
            p = !!i[2], m = !!i[3];
          } else l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document)) return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t = document.createElement("div");
          t.setAttribute(i, "return;"), r = typeof t[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      };
      let tableIdSeed = 1;
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$1,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change",
          "scroll"
        ],
        setup(props) {
          const { t } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props);
          table.store = store;
          const layout = new TableLayout({
            store: table.store,
            table,
            fit: props.fit,
            showHeader: props.showHeader
          });
          table.layout = layout;
          const isEmpty = computed(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort,
            updateKeyChildren
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            handleFixedMousewheel,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle
          } = useStyle(props, layout, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed(() => {
            var _a2;
            return (_a2 = props.sumText) != null ? _a2 : t("el.table.sumText");
          });
          const computedEmptyText = computed(() => {
            var _a2;
            return (_a2 = props.emptyText) != null ? _a2 : t("el.table.emptyText");
          });
          const columns = computed(() => {
            return convertToRows(store.states.originColumns.value)[0];
          });
          useKeyRender(table);
          onBeforeUnmount(() => {
            debouncedUpdateLayout.cancel();
          });
          return {
            ns,
            layout,
            store,
            columns,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            updateKeyChildren,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop,
            allowDragLastColumn: props.allowDragLastColumn
          };
        }
      });
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _ctx.handleMouseLeave
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper"))
          }, [
            createBaseVNode("div", {
              ref: "hiddenColumns",
              class: "hidden-columns"
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createBaseVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "append-filter-panel-to": _ctx.appendFilterPanelTo,
                  "allow-drag-last-column": _ctx.allowDragLastColumn,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn,
                tabindex: _ctx.scrollbarTabindex,
                onScroll: ($event) => _ctx.$emit("scroll", $event)
              }, {
                default: withCtx(() => [
                  createBaseVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "append-filter-panel-to": _ctx.appendFilterPanelTo,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always", "tabindex", "onScroll"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createBaseVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 2),
          withDirectives(createBaseVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, ["data-prefix", "onMouseleave"]);
      }
      var Table = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type) => {
        return defaultClassNames[type] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({ store, column }) {
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": store.toggleAllSelection,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({ column }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index = column.index;
            if (isNumber(index)) {
              i = $index + index;
            } else if (isFunction$1(index)) {
              i = index($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({ column }) {
            return column.label || "";
          },
          renderCell({
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                return [
                  h$1(ElIcon, null, {
                    default: () => {
                      return [h$1(arrow_right_default)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a2;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (isBoolean(treeNode.expanded) && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default;
          if (treeNode.loading) {
            icon = loading_default;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props, aliases) {
        return props.reduce((prev, cur) => {
          prev[cur] = cur;
          return prev;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip",
            "tooltipFormatter"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props.align ? `is-${props.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed(() => {
          let parent = instance.vnode.vParent || instance.parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.vnode.vParent || parent.parent;
          }
          return parent;
        });
        const hasTreeColumn = computed(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props.width));
        const realMinWidth = ref(parseMinWidth(props.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(isUndefined(column.width) ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type = column.type;
          const source = cellForced[type] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && !isUndefined(value)) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (isArray$1(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a2;
            if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props.renderHeader) ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          if (slots["filter-icon"]) {
            column.renderFilterIcon = (scope) => {
              return renderSlot(slots, "filter-icon", scope);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data)]);
            owner.value.renderExpanded = (data) => {
              return slots.default ? slots.default(data) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data);
                children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
              } else {
                children = originRenderCell(data);
              }
              const { columns } = owner.value.store.states;
              const firstUserColumnIndex = columns.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
              const props2 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props2.class = `${props2.class} ${unref(ns.namespace)}-tooltip`;
                props2.style = {
                  width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props2, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev, cur) => {
            if (isArray$1(cur)) {
              cur.forEach((key) => {
                prev[key] = props[key];
              });
            }
            return prev;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        tooltipFormatter: Function,
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = /* @__PURE__ */ defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed(() => {
            let parent2 = instance.parent;
            while (parent2 && !parent2.tableId) {
              parent2 = parent2.parent;
            }
            return parent2;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props, slots, owner);
          const parent = columnOrTableParent.value;
          columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent;
            const type = props.type || "default";
            const sortable = props.sortable === "" ? true : props.sortable;
            const showOverflowTooltip = type === "selection" ? false : isUndefined(props.showOverflowTooltip) ? parent.props.showOverflowTooltip : props.showOverflowTooltip;
            const tooltipFormatter = isUndefined(props.tooltipFormatter) ? parent.props.tooltipFormatter : props.tooltipFormatter;
            const defaults = {
              ...cellStarts[type],
              id: columnId.value,
              type,
              property: props.prop || props.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              tooltipFormatter,
              filterable: props.filters || props.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = mergeOptions(defaults, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a2;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            const getColumnIndex = columnConfig.value.getColumnIndex;
            const columnIndex = getColumnIndex ? getColumnIndex() : -1;
            columnIndex > -1 && owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a2, _b, _c;
          try {
            const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (isArray$1(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment && isArray$1(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$1(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = withInstall(Table, {
        TableColumn: ElTableColumn$1
      });
      const ElTableColumn = withNoopInstall(ElTableColumn$1);
      const useUserInfoStore = /* @__PURE__ */ defineStore("userInfo", {
        persist: true,
        // 持久化
        state: () => ({
          key: null,
          questionList: []
        })
      });
      const tips = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20t='1748439493458'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='1849'%20width='32'%20height='32'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cpath%20d='M512%20128c212.064%200%20384%20171.936%20384%20384s-171.936%20384-384%20384S128%20724.064%20128%20512%20299.936%20128%20512%20128z%20m0%2064C335.296%20192%20192%20335.296%20192%20512s143.296%20320%20320%20320%20320-143.296%20320-320S688.704%20192%20512%20192z%20m6.848%20429.728a48%2048%200%201%201%200%2096%2048%2048%200%200%201%200-96zM516.576%20320a32%2032%200%200%201%2032%2032v182.848a32%2032%200%201%201-64%200V352a32%2032%200%200%201%2032-32z'%20fill='%23ffffff'%20p-id='1850'%3e%3c/path%3e%3c/svg%3e";
      const avatar = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAABACAYAAABGHBTIAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAAALmSURBVGiB7ZpdTttAFIXPuaahoFZydkBXQHirEiToDroD2AGwgJIhLKBhBQ07gBWQSqXijXYFzQ6IRAQN1HP74AYRSOg4sR1I5pPyMr65Psc/d8bXBjwej8fj8XhygnnubN1chLcyXwV0EwCUUi9Evw+aptjOS8NcXjsCgNgstnvHmarmVuZDADt5aZC8dhQTn9n/j2VHzoYZuo1lR86GJ483PO14w9NO4oXHe3O9FAiqUC2BupR3lQW0rco2iaPI8uDMLLSS/DuR4fL+dZWqJrHGTLE7p7tv6q7RzoYrtc42IJ9H1pUhSprvnxb2XGKdDMeXsf4aW1mGRJbvXC5vp6IViG6loipDAkHVJc7JsCo+jq0oa1RLLmFOhkksjS0oa4j0DE8T3vC0M3OGU27xsGGtPSY0pMhy3M4ZN0+wlmZX5M5wudbZpMpWr9qd7i4mWnbSRh++mbfN+2Or5vJYJTgZM09j1VweJs1TqV0poG0oWyo86q3EZN1chJW9q3NCvriW9gEyGw/NAkA8xkaCRPWU8vR0hSBKVDWVvatzAJCb4PXW6EZjrLXHo2x7HKtfh22L7J/DUbTdQZQqtc62wI5/fyhsKn3lp/IQMv5jqMqGpLGKCmRuY9g2Ea6lkYeBLI+irT8JSilNS7pZNp1Ht8W/sQSVengeqh2x4veT2rRE4Ul5/7qukf2psO34bCW/XdLKM4wU52GGVDUUAggA6ITzDGbmVlre8LTjDU87M2hY8WPSIvJCFS1R4VEqyUhzurvI3u+V7RaVNFnEjIywwXVzEd7I/DnRv6a+/zwcP1s+zbDn5/v/TSvGRcPDeAVaBdtdkaYptgu2u6KkUUWiF1P9gjqP1roPx9KKSYICLSVNwXZXmqbYdupquBzd54BLl2YGq/SM4Wb4BUxdrvXHzTD57A2TcJpenQxHFk4vmycJbeTULHQyfGYWWqlN/hmgpBnU3h3Ei//GI8nnDh6Px+PxeCbLX2w1RmzseYc7AAAAAElFTkSuQmCC";
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const _hoisted_1$1 = { class: "header-flex" };
      const _hoisted_2$1 = { class: "avatar-name" };
      const _hoisted_3$1 = ["src"];
      const _hoisted_4$1 = { class: "title" };
      const _hoisted_5$1 = { class: "header-settings" };
      const _hoisted_6$1 = ["src"];
      const _hoisted_7$1 = {
        key: 0,
        class: "main-content"
      };
      const _sfc_main$2 = {
        __name: "draggable-dialog",
        props: {
          title: {
            type: String,
            default: "网课助手"
          },
          width: {
            type: String,
            default: "336px"
          },
          height: {
            type: String,
            default: "260px"
          },
          boundary: {
            type: Boolean,
            default: true
          },
          axis: {
            type: String,
            default: "both",
            // 限制拖拽方向：both | x | y | none
            validator: (value) => ["both", "x", "y", "none"].includes(value)
          }
        },
        setup(__props) {
          const props = __props;
          const position = ref({ x: 0, y: 0 });
          const isDragging = ref(false);
          const startPos = ref({ x: 0, y: 0 });
          const dragStartOffset = ref({ x: 0, y: 0 });
          const windowSize = ref({ width: 0, height: 0 });
          const isMinimize = ref(false);
          const updateWindowSize = () => {
            windowSize.value = {
              width: window.innerWidth,
              height: window.innerHeight
            };
            const dialogWidth = parseInt(props.width) || 400;
            const dialogHeight = parseInt(props.height) || 300;
            position.value.x = Math.max(0, (windowSize.value.width - dialogWidth) / 2);
            position.value.y = Math.max(0, (windowSize.value.height - dialogHeight) / 2);
          };
          const startDrag = (e) => {
            if (props.axis === "none") return;
            e.preventDefault();
            e.stopPropagation();
            isDragging.value = true;
            startPos.value = { x: e.clientX, y: e.clientY };
            dragStartOffset.value = { x: position.value.x, y: position.value.y };
            document.addEventListener("mousemove", onDrag, { passive: false });
            document.addEventListener("mouseup", stopDrag, { passive: false });
            document.body.style.userSelect = "none";
            document.body.style.cursor = "grabbing";
          };
          const onDrag = (e) => {
            if (!isDragging.value) return;
            e.preventDefault();
            let dx = e.clientX - startPos.value.x;
            let dy = e.clientY - startPos.value.y;
            if (props.axis === "x") dy = 0;
            if (props.axis === "y") dx = 0;
            let newX = dragStartOffset.value.x + dx;
            let newY = dragStartOffset.value.y + dy;
            if (props.boundary) {
              const dialogWidth = parseInt(props.width) || 400;
              const dialogHeight = parseInt(props.height) || 300;
              newX = Math.max(0, Math.min(newX, windowSize.value.width - dialogWidth));
              newY = Math.max(0, Math.min(newY, windowSize.value.height - dialogHeight));
            }
            position.value = { x: newX, y: newY };
          };
          const stopDrag = (e) => {
            if (!isDragging.value) return;
            isDragging.value = false;
            document.removeEventListener("mousemove", onDrag);
            document.removeEventListener("mouseup", stopDrag);
            document.body.style.userSelect = "";
            document.body.style.cursor = "";
            if (e) {
              e.preventDefault();
              e.stopPropagation();
            }
          };
          const minimize = () => {
            isMinimize.value = !isMinimize.value;
          };
          onMounted(() => {
            updateWindowSize();
            window.addEventListener("resize", updateWindowSize);
            const dialogWidth = parseInt(props.width) || 400;
            const dialogHeight = parseInt(props.height) || 300;
            position.value = {
              x: (windowSize.value.width - dialogWidth) / 2,
              y: (windowSize.value.height - dialogHeight) / 2
            };
            if (props.boundary) {
              position.value.x = Math.max(
                0,
                Math.min(position.value.x, windowSize.value.width - dialogWidth)
              );
              position.value.y = Math.max(
                0,
                Math.min(position.value.y, windowSize.value.height - dialogHeight)
              );
            }
          });
          onUnmounted(() => {
            window.removeEventListener("resize", updateWindowSize);
            document.removeEventListener("mousemove", onDrag);
            document.removeEventListener("mouseup", stopDrag);
            document.body.style.userSelect = "";
            document.body.style.cursor = "";
          });
          return (_ctx, _cache) => {
            const _component_el_tooltip = ElTooltip;
            const _component_el_icon = ElIcon;
            return openBlock(), createElementBlock("div", {
              class: "draggable-dialog",
              style: normalizeStyle({
                transform: `translate(${unref(position).x}px, ${unref(position).y}px)`
              })
            }, [
              createBaseVNode("div", {
                class: "draggable-title",
                onMousedown: startDrag
              }, [
                createBaseVNode("div", _hoisted_1$1, [
                  createBaseVNode("div", _hoisted_2$1, [
                    createBaseVNode("img", {
                      src: unref(avatar),
                      alt: "",
                      class: "avatar"
                    }, null, 8, _hoisted_3$1),
                    createBaseVNode("span", _hoisted_4$1, toDisplayString(__props.title), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_5$1, [
                  createVNode(_component_el_tooltip, {
                    placement: "bottom",
                    content: "请及时更新最新版、避免使用旧版本导致无法使用"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("img", {
                        src: unref(tips),
                        alt: "",
                        class: "tips",
                        srcset: ""
                      }, null, 8, _hoisted_6$1)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_tooltip, {
                    content: unref(isMinimize) ? "最大化" : "最小化",
                    placement: "bottom"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_icon, {
                        size: 18,
                        color: "#ffffff",
                        onClick: minimize
                      }, {
                        default: withCtx(() => [
                          !unref(isMinimize) ? (openBlock(), createBlock(unref(minus_default), { key: 0 })) : createCommentVNode("", true),
                          unref(isMinimize) ? (openBlock(), createBlock(unref(full_screen_default), { key: 1 })) : createCommentVNode("", true)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["content"])
                ])
              ], 32),
              !unref(isMinimize) ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ])) : createCommentVNode("", true)
            ], 4);
          };
        }
      };
      const DraggableDialog = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-330ab24e"]]);
      var _GM_getResourceText = /* @__PURE__ */ (() => typeof GM_getResourceText != "undefined" ? GM_getResourceText : void 0)();
      var _GM_info = /* @__PURE__ */ (() => typeof GM_info != "undefined" ? GM_info : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      var Typr$1 = {};
      var Typr = {};
      Typr.parse = function(buff) {
        var bin = Typr._bin;
        var data = new Uint8Array(buff);
        var tag = bin.readASCII(data, 0, 4);
        if (tag == "ttcf") {
          var offset = 4;
          bin.readUshort(data, offset);
          offset += 2;
          bin.readUshort(data, offset);
          offset += 2;
          var numF = bin.readUint(data, offset);
          offset += 4;
          var fnts = [];
          for (var i = 0; i < numF; i++) {
            var foff = bin.readUint(data, offset);
            offset += 4;
            fnts.push(Typr._readFont(data, foff));
          }
          return fnts;
        } else
          return [Typr._readFont(data, 0)];
      };
      Typr._readFont = function(data, offset) {
        var bin = Typr._bin;
        var ooff = offset;
        bin.readFixed(data, offset);
        offset += 4;
        var numTables = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var tags = [
          "cmap",
          "head",
          "hhea",
          "maxp",
          "hmtx",
          "name",
          "OS/2",
          "post",
          //"cvt",
          //"fpgm",
          "loca",
          "glyf",
          "kern",
          //"prep"
          //"gasp"
          "CFF ",
          "GPOS",
          "GSUB",
          "SVG "
          //"VORG",
        ];
        var obj = { _data: data, _offset: ooff };
        var tabs = {};
        for (var i = 0; i < numTables; i++) {
          var tag = bin.readASCII(data, offset, 4);
          offset += 4;
          bin.readUint(data, offset);
          offset += 4;
          var toffset = bin.readUint(data, offset);
          offset += 4;
          var length = bin.readUint(data, offset);
          offset += 4;
          tabs[tag] = { offset: toffset, length };
        }
        for (var i = 0; i < tags.length; i++) {
          var t = tags[i];
          if (tabs[t])
            obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);
        }
        return obj;
      };
      Typr._tabOffset = function(data, tab, foff) {
        var bin = Typr._bin;
        var numTables = bin.readUshort(data, foff + 4);
        var offset = foff + 12;
        for (var i = 0; i < numTables; i++) {
          var tag = bin.readASCII(data, offset, 4);
          offset += 4;
          bin.readUint(data, offset);
          offset += 4;
          var toffset = bin.readUint(data, offset);
          offset += 4;
          bin.readUint(data, offset);
          offset += 4;
          if (tag == tab)
            return toffset;
        }
        return 0;
      };
      Typr._bin = {
        readFixed: function(data, o2) {
          return (data[o2] << 8 | data[o2 + 1]) + (data[o2 + 2] << 8 | data[o2 + 3]) / (256 * 256 + 4);
        },
        readF2dot14: function(data, o2) {
          var num = Typr._bin.readShort(data, o2);
          return num / 16384;
        },
        readInt: function(buff, p2) {
          return Typr._bin._view(buff).getInt32(p2);
        },
        readInt8: function(buff, p2) {
          return Typr._bin._view(buff).getInt8(p2);
        },
        readShort: function(buff, p2) {
          return Typr._bin._view(buff).getInt16(p2);
        },
        readUshort: function(buff, p2) {
          return Typr._bin._view(buff).getUint16(p2);
        },
        readUshorts: function(buff, p2, len) {
          var arr = [];
          for (var i = 0; i < len; i++)
            arr.push(Typr._bin.readUshort(buff, p2 + i * 2));
          return arr;
        },
        readUint: function(buff, p2) {
          return Typr._bin._view(buff).getUint32(p2);
        },
        readUint64: function(buff, p2) {
          return Typr._bin.readUint(buff, p2) * (4294967295 + 1) + Typr._bin.readUint(buff, p2 + 4);
        },
        readASCII: function(buff, p2, l2) {
          var s2 = "";
          for (var i = 0; i < l2; i++)
            s2 += String.fromCharCode(buff[p2 + i]);
          return s2;
        },
        readUnicode: function(buff, p2, l2) {
          var s2 = "";
          for (var i = 0; i < l2; i++) {
            var c2 = buff[p2++] << 8 | buff[p2++];
            s2 += String.fromCharCode(c2);
          }
          return s2;
        },
        _tdec: typeof window !== "undefined" && window["TextDecoder"] ? new window["TextDecoder"]() : null,
        readUTF8: function(buff, p2, l2) {
          var tdec = Typr._bin._tdec;
          if (tdec && p2 == 0 && l2 == buff.length)
            return tdec["decode"](buff);
          return Typr._bin.readASCII(buff, p2, l2);
        },
        readBytes: function(buff, p2, l2) {
          var arr = [];
          for (var i = 0; i < l2; i++)
            arr.push(buff[p2 + i]);
          return arr;
        },
        readASCIIArray: function(buff, p2, l2) {
          var s2 = [];
          for (var i = 0; i < l2; i++)
            s2.push(String.fromCharCode(buff[p2 + i]));
          return s2;
        },
        _view: function(buff) {
          return buff._dataView || (buff._dataView = buff.buffer ? new DataView(buff.buffer, buff.byteOffset, buff.byteLength) : new DataView(new Uint8Array(buff).buffer));
        }
      };
      Typr._lctf = {};
      Typr._lctf.parse = function(data, offset, length, font, subt) {
        var bin = Typr._bin;
        var obj = {};
        var offset0 = offset;
        bin.readFixed(data, offset);
        offset += 4;
        var offScriptList = bin.readUshort(data, offset);
        offset += 2;
        var offFeatureList = bin.readUshort(data, offset);
        offset += 2;
        var offLookupList = bin.readUshort(data, offset);
        offset += 2;
        obj.scriptList = Typr._lctf.readScriptList(data, offset0 + offScriptList);
        obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);
        obj.lookupList = Typr._lctf.readLookupList(data, offset0 + offLookupList, subt);
        return obj;
      };
      Typr._lctf.readLookupList = function(data, offset, subt) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = [];
        var count = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < count; i++) {
          var noff = bin.readUshort(data, offset);
          offset += 2;
          var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);
          obj.push(lut);
        }
        return obj;
      };
      Typr._lctf.readLookupTable = function(data, offset, subt) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = { tabs: [] };
        obj.ltype = bin.readUshort(data, offset);
        offset += 2;
        obj.flag = bin.readUshort(data, offset);
        offset += 2;
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        var ltype = obj.ltype;
        for (var i = 0; i < cnt; i++) {
          var noff = bin.readUshort(data, offset);
          offset += 2;
          var tab = subt(data, ltype, offset0 + noff, obj);
          obj.tabs.push(tab);
        }
        return obj;
      };
      Typr._lctf.numOfOnes = function(n) {
        var num = 0;
        for (var i = 0; i < 32; i++)
          if ((n >>> i & 1) != 0)
            num++;
        return num;
      };
      Typr._lctf.readClassDef = function(data, offset) {
        var bin = Typr._bin;
        var obj = [];
        var format = bin.readUshort(data, offset);
        offset += 2;
        if (format == 1) {
          var startGlyph = bin.readUshort(data, offset);
          offset += 2;
          var glyphCount = bin.readUshort(data, offset);
          offset += 2;
          for (var i = 0; i < glyphCount; i++) {
            obj.push(startGlyph + i);
            obj.push(startGlyph + i);
            obj.push(bin.readUshort(data, offset));
            offset += 2;
          }
        }
        if (format == 2) {
          var count = bin.readUshort(data, offset);
          offset += 2;
          for (var i = 0; i < count; i++) {
            obj.push(bin.readUshort(data, offset));
            offset += 2;
            obj.push(bin.readUshort(data, offset));
            offset += 2;
            obj.push(bin.readUshort(data, offset));
            offset += 2;
          }
        }
        return obj;
      };
      Typr._lctf.getInterval = function(tab, val) {
        for (var i = 0; i < tab.length; i += 3) {
          var start = tab[i], end = tab[i + 1];
          tab[i + 2];
          if (start <= val && val <= end)
            return i;
        }
        return -1;
      };
      Typr._lctf.readCoverage = function(data, offset) {
        var bin = Typr._bin;
        var cvg = {};
        cvg.fmt = bin.readUshort(data, offset);
        offset += 2;
        var count = bin.readUshort(data, offset);
        offset += 2;
        if (cvg.fmt == 1)
          cvg.tab = bin.readUshorts(data, offset, count);
        if (cvg.fmt == 2)
          cvg.tab = bin.readUshorts(data, offset, count * 3);
        return cvg;
      };
      Typr._lctf.coverageIndex = function(cvg, val) {
        var tab = cvg.tab;
        if (cvg.fmt == 1)
          return tab.indexOf(val);
        if (cvg.fmt == 2) {
          var ind = Typr._lctf.getInterval(tab, val);
          if (ind != -1)
            return tab[ind + 2] + (val - tab[ind]);
        }
        return -1;
      };
      Typr._lctf.readFeatureList = function(data, offset) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = [];
        var count = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < count; i++) {
          var tag = bin.readASCII(data, offset, 4);
          offset += 4;
          var noff = bin.readUshort(data, offset);
          offset += 2;
          var feat = Typr._lctf.readFeatureTable(data, offset0 + noff);
          feat.tag = tag.trim();
          obj.push(feat);
        }
        return obj;
      };
      Typr._lctf.readFeatureTable = function(data, offset) {
        var bin = Typr._bin;
        var offset0 = offset;
        var feat = {};
        var featureParams = bin.readUshort(data, offset);
        offset += 2;
        if (featureParams > 0) {
          feat.featureParams = offset0 + featureParams;
        }
        var lookupCount = bin.readUshort(data, offset);
        offset += 2;
        feat.tab = [];
        for (var i = 0; i < lookupCount; i++)
          feat.tab.push(bin.readUshort(data, offset + 2 * i));
        return feat;
      };
      Typr._lctf.readScriptList = function(data, offset) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = {};
        var count = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < count; i++) {
          var tag = bin.readASCII(data, offset, 4);
          offset += 4;
          var noff = bin.readUshort(data, offset);
          offset += 2;
          obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);
        }
        return obj;
      };
      Typr._lctf.readScriptTable = function(data, offset) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = {};
        var defLangSysOff = bin.readUshort(data, offset);
        offset += 2;
        if (defLangSysOff > 0) {
          obj["default"] = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);
        }
        var langSysCount = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < langSysCount; i++) {
          var tag = bin.readASCII(data, offset, 4);
          offset += 4;
          var langSysOff = bin.readUshort(data, offset);
          offset += 2;
          obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);
        }
        return obj;
      };
      Typr._lctf.readLangSysTable = function(data, offset) {
        var bin = Typr._bin;
        var obj = {};
        bin.readUshort(data, offset);
        offset += 2;
        obj.reqFeature = bin.readUshort(data, offset);
        offset += 2;
        var featureCount = bin.readUshort(data, offset);
        offset += 2;
        obj.features = bin.readUshorts(data, offset, featureCount);
        return obj;
      };
      Typr.CFF = {};
      Typr.CFF.parse = function(data, offset, length) {
        var bin = Typr._bin;
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        var ninds = [];
        offset = Typr.CFF.readIndex(data, offset, ninds);
        var names = [];
        for (var i = 0; i < ninds.length - 1; i++)
          names.push(bin.readASCII(data, offset + ninds[i], ninds[i + 1] - ninds[i]));
        offset += ninds[ninds.length - 1];
        var tdinds = [];
        offset = Typr.CFF.readIndex(data, offset, tdinds);
        var topDicts = [];
        for (var i = 0; i < tdinds.length - 1; i++)
          topDicts.push(Typr.CFF.readDict(data, offset + tdinds[i], offset + tdinds[i + 1]));
        offset += tdinds[tdinds.length - 1];
        var topdict = topDicts[0];
        var sinds = [];
        offset = Typr.CFF.readIndex(data, offset, sinds);
        var strings = [];
        for (var i = 0; i < sinds.length - 1; i++)
          strings.push(bin.readASCII(data, offset + sinds[i], sinds[i + 1] - sinds[i]));
        offset += sinds[sinds.length - 1];
        Typr.CFF.readSubrs(data, offset, topdict);
        if (topdict.CharStrings) {
          offset = topdict.CharStrings;
          var sinds = [];
          offset = Typr.CFF.readIndex(data, offset, sinds);
          var cstr = [];
          for (var i = 0; i < sinds.length - 1; i++)
            cstr.push(bin.readBytes(data, offset + sinds[i], sinds[i + 1] - sinds[i]));
          topdict.CharStrings = cstr;
        }
        if (topdict.ROS) {
          offset = topdict.FDArray;
          var fdind = [];
          offset = Typr.CFF.readIndex(data, offset, fdind);
          topdict.FDArray = [];
          for (var i = 0; i < fdind.length - 1; i++) {
            var dict = Typr.CFF.readDict(data, offset + fdind[i], offset + fdind[i + 1]);
            Typr.CFF._readFDict(data, dict, strings);
            topdict.FDArray.push(dict);
          }
          offset += fdind[fdind.length - 1];
          offset = topdict.FDSelect;
          topdict.FDSelect = [];
          var fmt = data[offset];
          offset++;
          if (fmt == 3) {
            var rns = bin.readUshort(data, offset);
            offset += 2;
            for (var i = 0; i < rns + 1; i++) {
              topdict.FDSelect.push(bin.readUshort(data, offset), data[offset + 2]);
              offset += 3;
            }
          } else
            throw fmt;
        }
        if (topdict.Encoding)
          topdict.Encoding = Typr.CFF.readEncoding(data, topdict.Encoding, topdict.CharStrings.length);
        if (topdict.charset)
          topdict.charset = Typr.CFF.readCharset(data, topdict.charset, topdict.CharStrings.length);
        Typr.CFF._readFDict(data, topdict, strings);
        return topdict;
      };
      Typr.CFF._readFDict = function(data, dict, ss) {
        var offset;
        if (dict.Private) {
          offset = dict.Private[1];
          dict.Private = Typr.CFF.readDict(data, offset, offset + dict.Private[0]);
          if (dict.Private.Subrs)
            Typr.CFF.readSubrs(data, offset + dict.Private.Subrs, dict.Private);
        }
        for (var p2 in dict)
          if (["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(p2) != -1)
            dict[p2] = ss[dict[p2] - 426 + 35];
      };
      Typr.CFF.readSubrs = function(data, offset, obj) {
        var bin = Typr._bin;
        var gsubinds = [];
        offset = Typr.CFF.readIndex(data, offset, gsubinds);
        var bias, nSubrs = gsubinds.length;
        if (nSubrs < 1240)
          bias = 107;
        else if (nSubrs < 33900)
          bias = 1131;
        else
          bias = 32768;
        obj.Bias = bias;
        obj.Subrs = [];
        for (var i = 0; i < gsubinds.length - 1; i++)
          obj.Subrs.push(bin.readBytes(data, offset + gsubinds[i], gsubinds[i + 1] - gsubinds[i]));
      };
      Typr.CFF.tableSE = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        0,
        111,
        112,
        113,
        114,
        0,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        0,
        123,
        0,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        0,
        132,
        133,
        0,
        134,
        135,
        136,
        137,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        138,
        0,
        139,
        0,
        0,
        0,
        0,
        140,
        141,
        142,
        143,
        0,
        0,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        145,
        0,
        0,
        146,
        147,
        148,
        149,
        0,
        0,
        0,
        0
      ];
      Typr.CFF.glyphByUnicode = function(cff, code) {
        for (var i = 0; i < cff.charset.length; i++)
          if (cff.charset[i] == code)
            return i;
        return -1;
      };
      Typr.CFF.glyphBySE = function(cff, charcode) {
        if (charcode < 0 || charcode > 255)
          return -1;
        return Typr.CFF.glyphByUnicode(cff, Typr.CFF.tableSE[charcode]);
      };
      Typr.CFF.readEncoding = function(data, offset, num) {
        Typr._bin;
        var array = [".notdef"];
        var format = data[offset];
        offset++;
        if (format == 0) {
          var nCodes = data[offset];
          offset++;
          for (var i = 0; i < nCodes; i++)
            array.push(data[offset + i]);
        } else
          throw "error: unknown encoding format: " + format;
        return array;
      };
      Typr.CFF.readCharset = function(data, offset, num) {
        var bin = Typr._bin;
        var charset = [".notdef"];
        var format = data[offset];
        offset++;
        if (format == 0) {
          for (var i = 0; i < num; i++) {
            var first = bin.readUshort(data, offset);
            offset += 2;
            charset.push(first);
          }
        } else if (format == 1 || format == 2) {
          while (charset.length < num) {
            var first = bin.readUshort(data, offset);
            offset += 2;
            var nLeft = 0;
            if (format == 1) {
              nLeft = data[offset];
              offset++;
            } else {
              nLeft = bin.readUshort(data, offset);
              offset += 2;
            }
            for (var i = 0; i <= nLeft; i++) {
              charset.push(first);
              first++;
            }
          }
        } else
          throw "error: format: " + format;
        return charset;
      };
      Typr.CFF.readIndex = function(data, offset, inds) {
        var bin = Typr._bin;
        var count = bin.readUshort(data, offset) + 1;
        offset += 2;
        var offsize = data[offset];
        offset++;
        if (offsize == 1)
          for (var i = 0; i < count; i++)
            inds.push(data[offset + i]);
        else if (offsize == 2)
          for (var i = 0; i < count; i++)
            inds.push(bin.readUshort(data, offset + i * 2));
        else if (offsize == 3)
          for (var i = 0; i < count; i++)
            inds.push(bin.readUint(data, offset + i * 3 - 1) & 16777215);
        else if (count != 1)
          throw "unsupported offset size: " + offsize + ", count: " + count;
        offset += count * offsize;
        return offset - 1;
      };
      Typr.CFF.getCharString = function(data, offset, o2) {
        var bin = Typr._bin;
        var b0 = data[offset], b1 = data[offset + 1];
        data[offset + 2];
        data[offset + 3];
        data[offset + 4];
        var vs = 1;
        var op = null, val = null;
        if (b0 <= 20) {
          op = b0;
          vs = 1;
        }
        if (b0 == 12) {
          op = b0 * 100 + b1;
          vs = 2;
        }
        if (21 <= b0 && b0 <= 27) {
          op = b0;
          vs = 1;
        }
        if (b0 == 28) {
          val = bin.readShort(data, offset + 1);
          vs = 3;
        }
        if (29 <= b0 && b0 <= 31) {
          op = b0;
          vs = 1;
        }
        if (32 <= b0 && b0 <= 246) {
          val = b0 - 139;
          vs = 1;
        }
        if (247 <= b0 && b0 <= 250) {
          val = (b0 - 247) * 256 + b1 + 108;
          vs = 2;
        }
        if (251 <= b0 && b0 <= 254) {
          val = -(b0 - 251) * 256 - b1 - 108;
          vs = 2;
        }
        if (b0 == 255) {
          val = bin.readInt(data, offset + 1) / 65535;
          vs = 5;
        }
        o2.val = val != null ? val : "o" + op;
        o2.size = vs;
      };
      Typr.CFF.readCharString = function(data, offset, length) {
        var end = offset + length;
        var bin = Typr._bin;
        var arr = [];
        while (offset < end) {
          var b0 = data[offset], b1 = data[offset + 1];
          data[offset + 2];
          data[offset + 3];
          data[offset + 4];
          var vs = 1;
          var op = null, val = null;
          if (b0 <= 20) {
            op = b0;
            vs = 1;
          }
          if (b0 == 12) {
            op = b0 * 100 + b1;
            vs = 2;
          }
          if (b0 == 19 || b0 == 20) {
            op = b0;
            vs = 2;
          }
          if (21 <= b0 && b0 <= 27) {
            op = b0;
            vs = 1;
          }
          if (b0 == 28) {
            val = bin.readShort(data, offset + 1);
            vs = 3;
          }
          if (29 <= b0 && b0 <= 31) {
            op = b0;
            vs = 1;
          }
          if (32 <= b0 && b0 <= 246) {
            val = b0 - 139;
            vs = 1;
          }
          if (247 <= b0 && b0 <= 250) {
            val = (b0 - 247) * 256 + b1 + 108;
            vs = 2;
          }
          if (251 <= b0 && b0 <= 254) {
            val = -(b0 - 251) * 256 - b1 - 108;
            vs = 2;
          }
          if (b0 == 255) {
            val = bin.readInt(data, offset + 1) / 65535;
            vs = 5;
          }
          arr.push(val != null ? val : "o" + op);
          offset += vs;
        }
        return arr;
      };
      Typr.CFF.readDict = function(data, offset, end) {
        var bin = Typr._bin;
        var dict = {};
        var carr = [];
        while (offset < end) {
          var b0 = data[offset], b1 = data[offset + 1];
          data[offset + 2];
          data[offset + 3];
          data[offset + 4];
          var vs = 1;
          var key = null, val = null;
          if (b0 == 28) {
            val = bin.readShort(data, offset + 1);
            vs = 3;
          }
          if (b0 == 29) {
            val = bin.readInt(data, offset + 1);
            vs = 5;
          }
          if (32 <= b0 && b0 <= 246) {
            val = b0 - 139;
            vs = 1;
          }
          if (247 <= b0 && b0 <= 250) {
            val = (b0 - 247) * 256 + b1 + 108;
            vs = 2;
          }
          if (251 <= b0 && b0 <= 254) {
            val = -(b0 - 251) * 256 - b1 - 108;
            vs = 2;
          }
          if (b0 == 255) {
            val = bin.readInt(data, offset + 1) / 65535;
            vs = 5;
            throw "unknown number";
          }
          if (b0 == 30) {
            var nibs = [];
            vs = 1;
            while (true) {
              var b2 = data[offset + vs];
              vs++;
              var nib0 = b2 >> 4, nib1 = b2 & 15;
              if (nib0 != 15)
                nibs.push(nib0);
              if (nib1 != 15)
                nibs.push(nib1);
              if (nib1 == 15)
                break;
            }
            var s2 = "";
            var chars = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"];
            for (var i = 0; i < nibs.length; i++)
              s2 += chars[nibs[i]];
            val = parseFloat(s2);
          }
          if (b0 <= 21) {
            var keys2 = [
              "version",
              "Notice",
              "FullName",
              "FamilyName",
              "Weight",
              "FontBBox",
              "BlueValues",
              "OtherBlues",
              "FamilyBlues",
              "FamilyOtherBlues",
              "StdHW",
              "StdVW",
              "escape",
              "UniqueID",
              "XUID",
              "charset",
              "Encoding",
              "CharStrings",
              "Private",
              "Subrs",
              "defaultWidthX",
              "nominalWidthX"
            ];
            key = keys2[b0];
            vs = 1;
            if (b0 == 12) {
              var keys2 = [
                "Copyright",
                "isFixedPitch",
                "ItalicAngle",
                "UnderlinePosition",
                "UnderlineThickness",
                "PaintType",
                "CharstringType",
                "FontMatrix",
                "StrokeWidth",
                "BlueScale",
                "BlueShift",
                "BlueFuzz",
                "StemSnapH",
                "StemSnapV",
                "ForceBold",
                0,
                0,
                "LanguageGroup",
                "ExpansionFactor",
                "initialRandomSeed",
                "SyntheticBase",
                "PostScript",
                "BaseFontName",
                "BaseFontBlend",
                0,
                0,
                0,
                0,
                0,
                0,
                "ROS",
                "CIDFontVersion",
                "CIDFontRevision",
                "CIDFontType",
                "CIDCount",
                "UIDBase",
                "FDArray",
                "FDSelect",
                "FontName"
              ];
              key = keys2[b1];
              vs = 2;
            }
          }
          if (key != null) {
            dict[key] = carr.length == 1 ? carr[0] : carr;
            carr = [];
          } else
            carr.push(val);
          offset += vs;
        }
        return dict;
      };
      Typr.cmap = {};
      Typr.cmap.parse = function(data, offset, length) {
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        var bin = Typr._bin;
        var obj = {};
        bin.readUshort(data, offset);
        offset += 2;
        var numTables = bin.readUshort(data, offset);
        offset += 2;
        var offs = [];
        obj.tables = [];
        for (var i = 0; i < numTables; i++) {
          var platformID = bin.readUshort(data, offset);
          offset += 2;
          var encodingID = bin.readUshort(data, offset);
          offset += 2;
          var noffset = bin.readUint(data, offset);
          offset += 4;
          var id = "p" + platformID + "e" + encodingID;
          var tind = offs.indexOf(noffset);
          if (tind == -1) {
            tind = obj.tables.length;
            var subt;
            offs.push(noffset);
            var format = bin.readUshort(data, noffset);
            if (format == 0)
              subt = Typr.cmap.parse0(data, noffset);
            else if (format == 4)
              subt = Typr.cmap.parse4(data, noffset);
            else if (format == 6)
              subt = Typr.cmap.parse6(data, noffset);
            else if (format == 12)
              subt = Typr.cmap.parse12(data, noffset);
            else
              console.warn("unknown format: " + format, platformID, encodingID, noffset);
            obj.tables.push(subt);
          }
          if (obj[id] != null)
            throw "multiple tables for one platform+encoding";
          obj[id] = tind;
        }
        return obj;
      };
      Typr.cmap.parse0 = function(data, offset) {
        var bin = Typr._bin;
        var obj = {};
        obj.format = bin.readUshort(data, offset);
        offset += 2;
        var len = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.map = [];
        for (var i = 0; i < len - 6; i++)
          obj.map.push(data[offset + i]);
        return obj;
      };
      Typr.cmap.parse4 = function(data, offset) {
        var bin = Typr._bin;
        var offset0 = offset;
        var obj = {};
        obj.format = bin.readUshort(data, offset);
        offset += 2;
        var length = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var segCountX2 = bin.readUshort(data, offset);
        offset += 2;
        var segCount = segCountX2 / 2;
        obj.searchRange = bin.readUshort(data, offset);
        offset += 2;
        obj.entrySelector = bin.readUshort(data, offset);
        offset += 2;
        obj.rangeShift = bin.readUshort(data, offset);
        offset += 2;
        obj.endCount = bin.readUshorts(data, offset, segCount);
        offset += segCount * 2;
        offset += 2;
        obj.startCount = bin.readUshorts(data, offset, segCount);
        offset += segCount * 2;
        obj.idDelta = [];
        for (var i = 0; i < segCount; i++) {
          obj.idDelta.push(bin.readShort(data, offset));
          offset += 2;
        }
        obj.idRangeOffset = bin.readUshorts(data, offset, segCount);
        offset += segCount * 2;
        obj.glyphIdArray = [];
        while (offset < offset0 + length) {
          obj.glyphIdArray.push(bin.readUshort(data, offset));
          offset += 2;
        }
        return obj;
      };
      Typr.cmap.parse6 = function(data, offset) {
        var bin = Typr._bin;
        var obj = {};
        obj.format = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.firstCode = bin.readUshort(data, offset);
        offset += 2;
        var entryCount = bin.readUshort(data, offset);
        offset += 2;
        obj.glyphIdArray = [];
        for (var i = 0; i < entryCount; i++) {
          obj.glyphIdArray.push(bin.readUshort(data, offset));
          offset += 2;
        }
        return obj;
      };
      Typr.cmap.parse12 = function(data, offset) {
        var bin = Typr._bin;
        var obj = {};
        obj.format = bin.readUshort(data, offset);
        offset += 2;
        offset += 2;
        bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        var nGroups = bin.readUint(data, offset);
        offset += 4;
        obj.groups = [];
        for (var i = 0; i < nGroups; i++) {
          var off = offset + i * 12;
          var startCharCode = bin.readUint(data, off + 0);
          var endCharCode = bin.readUint(data, off + 4);
          var startGlyphID = bin.readUint(data, off + 8);
          obj.groups.push([startCharCode, endCharCode, startGlyphID]);
        }
        return obj;
      };
      Typr.glyf = {};
      Typr.glyf.parse = function(data, offset, length, font) {
        var obj = [];
        for (var g = 0; g < font.maxp.numGlyphs; g++)
          obj.push(null);
        return obj;
      };
      Typr.glyf._parseGlyf = function(font, g) {
        var bin = Typr._bin;
        var data = font._data;
        var offset = Typr._tabOffset(data, "glyf", font._offset) + font.loca[g];
        if (font.loca[g] == font.loca[g + 1])
          return null;
        var gl = {};
        gl.noc = bin.readShort(data, offset);
        offset += 2;
        gl.xMin = bin.readShort(data, offset);
        offset += 2;
        gl.yMin = bin.readShort(data, offset);
        offset += 2;
        gl.xMax = bin.readShort(data, offset);
        offset += 2;
        gl.yMax = bin.readShort(data, offset);
        offset += 2;
        if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax)
          return null;
        if (gl.noc > 0) {
          gl.endPts = [];
          for (var i = 0; i < gl.noc; i++) {
            gl.endPts.push(bin.readUshort(data, offset));
            offset += 2;
          }
          var instructionLength = bin.readUshort(data, offset);
          offset += 2;
          if (data.length - offset < instructionLength)
            return null;
          gl.instructions = bin.readBytes(data, offset, instructionLength);
          offset += instructionLength;
          var crdnum = gl.endPts[gl.noc - 1] + 1;
          gl.flags = [];
          for (var i = 0; i < crdnum; i++) {
            var flag = data[offset];
            offset++;
            gl.flags.push(flag);
            if ((flag & 8) != 0) {
              var rep = data[offset];
              offset++;
              for (var j = 0; j < rep; j++) {
                gl.flags.push(flag);
                i++;
              }
            }
          }
          gl.xs = [];
          for (var i = 0; i < crdnum; i++) {
            var i8 = (gl.flags[i] & 2) != 0, same = (gl.flags[i] & 16) != 0;
            if (i8) {
              gl.xs.push(same ? data[offset] : -data[offset]);
              offset++;
            } else {
              if (same)
                gl.xs.push(0);
              else {
                gl.xs.push(bin.readShort(data, offset));
                offset += 2;
              }
            }
          }
          gl.ys = [];
          for (var i = 0; i < crdnum; i++) {
            var i8 = (gl.flags[i] & 4) != 0, same = (gl.flags[i] & 32) != 0;
            if (i8) {
              gl.ys.push(same ? data[offset] : -data[offset]);
              offset++;
            } else {
              if (same)
                gl.ys.push(0);
              else {
                gl.ys.push(bin.readShort(data, offset));
                offset += 2;
              }
            }
          }
          var x2 = 0, y = 0;
          for (var i = 0; i < crdnum; i++) {
            x2 += gl.xs[i];
            y += gl.ys[i];
            gl.xs[i] = x2;
            gl.ys[i] = y;
          }
        } else {
          var ARG_1_AND_2_ARE_WORDS = 1 << 0;
          var ARGS_ARE_XY_VALUES = 1 << 1;
          var WE_HAVE_A_SCALE = 1 << 3;
          var MORE_COMPONENTS = 1 << 5;
          var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
          var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
          var WE_HAVE_INSTRUCTIONS = 1 << 8;
          gl.parts = [];
          var flags;
          do {
            flags = bin.readUshort(data, offset);
            offset += 2;
            var part = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
            gl.parts.push(part);
            part.glyphIndex = bin.readUshort(data, offset);
            offset += 2;
            if (flags & ARG_1_AND_2_ARE_WORDS) {
              var arg1 = bin.readShort(data, offset);
              offset += 2;
              var arg2 = bin.readShort(data, offset);
              offset += 2;
            } else {
              var arg1 = bin.readInt8(data, offset);
              offset++;
              var arg2 = bin.readInt8(data, offset);
              offset++;
            }
            if (flags & ARGS_ARE_XY_VALUES) {
              part.m.tx = arg1;
              part.m.ty = arg2;
            } else {
              part.p1 = arg1;
              part.p2 = arg2;
            }
            if (flags & WE_HAVE_A_SCALE) {
              part.m.a = part.m.d = bin.readF2dot14(data, offset);
              offset += 2;
            } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
              part.m.a = bin.readF2dot14(data, offset);
              offset += 2;
              part.m.d = bin.readF2dot14(data, offset);
              offset += 2;
            } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
              part.m.a = bin.readF2dot14(data, offset);
              offset += 2;
              part.m.b = bin.readF2dot14(data, offset);
              offset += 2;
              part.m.c = bin.readF2dot14(data, offset);
              offset += 2;
              part.m.d = bin.readF2dot14(data, offset);
              offset += 2;
            }
          } while (flags & MORE_COMPONENTS);
          if (flags & WE_HAVE_INSTRUCTIONS) {
            var numInstr = bin.readUshort(data, offset);
            offset += 2;
            gl.instr = [];
            for (var i = 0; i < numInstr; i++) {
              gl.instr.push(data[offset]);
              offset++;
            }
          }
        }
        return gl;
      };
      Typr.GPOS = {};
      Typr.GPOS.parse = function(data, offset, length, font) {
        return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);
      };
      Typr.GPOS.subt = function(data, ltype, offset, ltable) {
        var bin = Typr._bin, offset0 = offset, tab = {};
        tab.fmt = bin.readUshort(data, offset);
        offset += 2;
        if (ltype == 1 || ltype == 2 || ltype == 3 || ltype == 7 || ltype == 8 && tab.fmt <= 2) {
          var covOff = bin.readUshort(data, offset);
          offset += 2;
          tab.coverage = Typr._lctf.readCoverage(data, covOff + offset0);
        }
        if (ltype == 1 && tab.fmt == 1) {
          var valFmt1 = bin.readUshort(data, offset);
          offset += 2;
          var ones1 = Typr._lctf.numOfOnes(valFmt1);
          if (valFmt1 != 0)
            tab.pos = Typr.GPOS.readValueRecord(data, offset, valFmt1);
        } else if (ltype == 2 && tab.fmt >= 1 && tab.fmt <= 2) {
          var valFmt1 = bin.readUshort(data, offset);
          offset += 2;
          var valFmt2 = bin.readUshort(data, offset);
          offset += 2;
          var ones1 = Typr._lctf.numOfOnes(valFmt1);
          var ones2 = Typr._lctf.numOfOnes(valFmt2);
          if (tab.fmt == 1) {
            tab.pairsets = [];
            var psc = bin.readUshort(data, offset);
            offset += 2;
            for (var i = 0; i < psc; i++) {
              var psoff = offset0 + bin.readUshort(data, offset);
              offset += 2;
              var pvc = bin.readUshort(data, psoff);
              psoff += 2;
              var arr = [];
              for (var j = 0; j < pvc; j++) {
                var gid2 = bin.readUshort(data, psoff);
                psoff += 2;
                var value1, value2;
                if (valFmt1 != 0) {
                  value1 = Typr.GPOS.readValueRecord(data, psoff, valFmt1);
                  psoff += ones1 * 2;
                }
                if (valFmt2 != 0) {
                  value2 = Typr.GPOS.readValueRecord(data, psoff, valFmt2);
                  psoff += ones2 * 2;
                }
                arr.push({ gid2, val1: value1, val2: value2 });
              }
              tab.pairsets.push(arr);
            }
          }
          if (tab.fmt == 2) {
            var classDef1 = bin.readUshort(data, offset);
            offset += 2;
            var classDef2 = bin.readUshort(data, offset);
            offset += 2;
            var class1Count = bin.readUshort(data, offset);
            offset += 2;
            var class2Count = bin.readUshort(data, offset);
            offset += 2;
            tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);
            tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);
            tab.matrix = [];
            for (var i = 0; i < class1Count; i++) {
              var row = [];
              for (var j = 0; j < class2Count; j++) {
                var value1 = null, value2 = null;
                if (valFmt1 != 0) {
                  value1 = Typr.GPOS.readValueRecord(data, offset, valFmt1);
                  offset += ones1 * 2;
                }
                if (valFmt2 != 0) {
                  value2 = Typr.GPOS.readValueRecord(data, offset, valFmt2);
                  offset += ones2 * 2;
                }
                row.push({ val1: value1, val2: value2 });
              }
              tab.matrix.push(row);
            }
          }
        } else if (ltype == 9 && tab.fmt == 1) {
          var extType = bin.readUshort(data, offset);
          offset += 2;
          var extOffset = bin.readUint(data, offset);
          offset += 4;
          if (ltable.ltype == 9) {
            ltable.ltype = extType;
          } else if (ltable.ltype != extType) {
            throw "invalid extension substitution";
          }
          return Typr.GPOS.subt(data, ltable.ltype, offset0 + extOffset);
        } else
          console.warn("unsupported GPOS table LookupType", ltype, "format", tab.fmt);
        return tab;
      };
      Typr.GPOS.readValueRecord = function(data, offset, valFmt) {
        var bin = Typr._bin;
        var arr = [];
        arr.push(valFmt & 1 ? bin.readShort(data, offset) : 0);
        offset += valFmt & 1 ? 2 : 0;
        arr.push(valFmt & 2 ? bin.readShort(data, offset) : 0);
        offset += valFmt & 2 ? 2 : 0;
        arr.push(valFmt & 4 ? bin.readShort(data, offset) : 0);
        offset += valFmt & 4 ? 2 : 0;
        arr.push(valFmt & 8 ? bin.readShort(data, offset) : 0);
        offset += valFmt & 8 ? 2 : 0;
        return arr;
      };
      Typr.GSUB = {};
      Typr.GSUB.parse = function(data, offset, length, font) {
        return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);
      };
      Typr.GSUB.subt = function(data, ltype, offset, ltable) {
        var bin = Typr._bin, offset0 = offset, tab = {};
        tab.fmt = bin.readUshort(data, offset);
        offset += 2;
        if (ltype != 1 && ltype != 4 && ltype != 5 && ltype != 6)
          return null;
        if (ltype == 1 || ltype == 4 || ltype == 5 && tab.fmt <= 2 || ltype == 6 && tab.fmt <= 2) {
          var covOff = bin.readUshort(data, offset);
          offset += 2;
          tab.coverage = Typr._lctf.readCoverage(data, offset0 + covOff);
        }
        if (ltype == 1 && tab.fmt >= 1 && tab.fmt <= 2) {
          if (tab.fmt == 1) {
            tab.delta = bin.readShort(data, offset);
            offset += 2;
          } else if (tab.fmt == 2) {
            var cnt = bin.readUshort(data, offset);
            offset += 2;
            tab.newg = bin.readUshorts(data, offset, cnt);
            offset += tab.newg.length * 2;
          }
        } else if (ltype == 4) {
          tab.vals = [];
          var cnt = bin.readUshort(data, offset);
          offset += 2;
          for (var i = 0; i < cnt; i++) {
            var loff = bin.readUshort(data, offset);
            offset += 2;
            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0 + loff));
          }
        } else if (ltype == 5 && tab.fmt == 2) {
          if (tab.fmt == 2) {
            var cDefOffset = bin.readUshort(data, offset);
            offset += 2;
            tab.cDef = Typr._lctf.readClassDef(data, offset0 + cDefOffset);
            tab.scset = [];
            var subClassSetCount = bin.readUshort(data, offset);
            offset += 2;
            for (var i = 0; i < subClassSetCount; i++) {
              var scsOff = bin.readUshort(data, offset);
              offset += 2;
              tab.scset.push(scsOff == 0 ? null : Typr.GSUB.readSubClassSet(data, offset0 + scsOff));
            }
          }
        } else if (ltype == 6 && tab.fmt == 3) {
          if (tab.fmt == 3) {
            for (var i = 0; i < 3; i++) {
              var cnt = bin.readUshort(data, offset);
              offset += 2;
              var cvgs = [];
              for (var j = 0; j < cnt; j++)
                cvgs.push(Typr._lctf.readCoverage(data, offset0 + bin.readUshort(data, offset + j * 2)));
              offset += cnt * 2;
              if (i == 0)
                tab.backCvg = cvgs;
              if (i == 1)
                tab.inptCvg = cvgs;
              if (i == 2)
                tab.ahedCvg = cvgs;
            }
            var cnt = bin.readUshort(data, offset);
            offset += 2;
            tab.lookupRec = Typr.GSUB.readSubstLookupRecords(data, offset, cnt);
          }
        } else if (ltype == 7 && tab.fmt == 1) {
          var extType = bin.readUshort(data, offset);
          offset += 2;
          var extOffset = bin.readUint(data, offset);
          offset += 4;
          if (ltable.ltype == 9) {
            ltable.ltype = extType;
          } else if (ltable.ltype != extType) {
            throw "invalid extension substitution";
          }
          return Typr.GSUB.subt(data, ltable.ltype, offset0 + extOffset);
        } else
          console.warn("unsupported GSUB table LookupType", ltype, "format", tab.fmt);
        return tab;
      };
      Typr.GSUB.readSubClassSet = function(data, offset) {
        var rUs = Typr._bin.readUshort, offset0 = offset, lset = [];
        var cnt = rUs(data, offset);
        offset += 2;
        for (var i = 0; i < cnt; i++) {
          var loff = rUs(data, offset);
          offset += 2;
          lset.push(Typr.GSUB.readSubClassRule(data, offset0 + loff));
        }
        return lset;
      };
      Typr.GSUB.readSubClassRule = function(data, offset) {
        var rUs = Typr._bin.readUshort, rule = {};
        var gcount = rUs(data, offset);
        offset += 2;
        var scount = rUs(data, offset);
        offset += 2;
        rule.input = [];
        for (var i = 0; i < gcount - 1; i++) {
          rule.input.push(rUs(data, offset));
          offset += 2;
        }
        rule.substLookupRecords = Typr.GSUB.readSubstLookupRecords(data, offset, scount);
        return rule;
      };
      Typr.GSUB.readSubstLookupRecords = function(data, offset, cnt) {
        var rUs = Typr._bin.readUshort;
        var out = [];
        for (var i = 0; i < cnt; i++) {
          out.push(rUs(data, offset), rUs(data, offset + 2));
          offset += 4;
        }
        return out;
      };
      Typr.GSUB.readChainSubClassSet = function(data, offset) {
        var bin = Typr._bin, offset0 = offset, lset = [];
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < cnt; i++) {
          var loff = bin.readUshort(data, offset);
          offset += 2;
          lset.push(Typr.GSUB.readChainSubClassRule(data, offset0 + loff));
        }
        return lset;
      };
      Typr.GSUB.readChainSubClassRule = function(data, offset) {
        var bin = Typr._bin, rule = {};
        var pps = ["backtrack", "input", "lookahead"];
        for (var pi = 0; pi < pps.length; pi++) {
          var cnt = bin.readUshort(data, offset);
          offset += 2;
          if (pi == 1)
            cnt--;
          rule[pps[pi]] = bin.readUshorts(data, offset, cnt);
          offset += rule[pps[pi]].length * 2;
        }
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        rule.subst = bin.readUshorts(data, offset, cnt * 2);
        offset += rule.subst.length * 2;
        return rule;
      };
      Typr.GSUB.readLigatureSet = function(data, offset) {
        var bin = Typr._bin, offset0 = offset, lset = [];
        var lcnt = bin.readUshort(data, offset);
        offset += 2;
        for (var j = 0; j < lcnt; j++) {
          var loff = bin.readUshort(data, offset);
          offset += 2;
          lset.push(Typr.GSUB.readLigature(data, offset0 + loff));
        }
        return lset;
      };
      Typr.GSUB.readLigature = function(data, offset) {
        var bin = Typr._bin, lig = { chain: [] };
        lig.nglyph = bin.readUshort(data, offset);
        offset += 2;
        var ccnt = bin.readUshort(data, offset);
        offset += 2;
        for (var k = 0; k < ccnt - 1; k++) {
          lig.chain.push(bin.readUshort(data, offset));
          offset += 2;
        }
        return lig;
      };
      Typr.head = {};
      Typr.head.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        obj.fontRevision = bin.readFixed(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        obj.flags = bin.readUshort(data, offset);
        offset += 2;
        obj.unitsPerEm = bin.readUshort(data, offset);
        offset += 2;
        obj.created = bin.readUint64(data, offset);
        offset += 8;
        obj.modified = bin.readUint64(data, offset);
        offset += 8;
        obj.xMin = bin.readShort(data, offset);
        offset += 2;
        obj.yMin = bin.readShort(data, offset);
        offset += 2;
        obj.xMax = bin.readShort(data, offset);
        offset += 2;
        obj.yMax = bin.readShort(data, offset);
        offset += 2;
        obj.macStyle = bin.readUshort(data, offset);
        offset += 2;
        obj.lowestRecPPEM = bin.readUshort(data, offset);
        offset += 2;
        obj.fontDirectionHint = bin.readShort(data, offset);
        offset += 2;
        obj.indexToLocFormat = bin.readShort(data, offset);
        offset += 2;
        obj.glyphDataFormat = bin.readShort(data, offset);
        offset += 2;
        return obj;
      };
      Typr.hhea = {};
      Typr.hhea.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        obj.ascender = bin.readShort(data, offset);
        offset += 2;
        obj.descender = bin.readShort(data, offset);
        offset += 2;
        obj.lineGap = bin.readShort(data, offset);
        offset += 2;
        obj.advanceWidthMax = bin.readUshort(data, offset);
        offset += 2;
        obj.minLeftSideBearing = bin.readShort(data, offset);
        offset += 2;
        obj.minRightSideBearing = bin.readShort(data, offset);
        offset += 2;
        obj.xMaxExtent = bin.readShort(data, offset);
        offset += 2;
        obj.caretSlopeRise = bin.readShort(data, offset);
        offset += 2;
        obj.caretSlopeRun = bin.readShort(data, offset);
        offset += 2;
        obj.caretOffset = bin.readShort(data, offset);
        offset += 2;
        offset += 4 * 2;
        obj.metricDataFormat = bin.readShort(data, offset);
        offset += 2;
        obj.numberOfHMetrics = bin.readUshort(data, offset);
        offset += 2;
        return obj;
      };
      Typr.hmtx = {};
      Typr.hmtx.parse = function(data, offset, length, font) {
        var bin = Typr._bin;
        var obj = {};
        obj.aWidth = [];
        obj.lsBearing = [];
        var aw = 0, lsb = 0;
        for (var i = 0; i < font.maxp.numGlyphs; i++) {
          if (i < font.hhea.numberOfHMetrics) {
            aw = bin.readUshort(data, offset);
            offset += 2;
            lsb = bin.readShort(data, offset);
            offset += 2;
          }
          obj.aWidth.push(aw);
          obj.lsBearing.push(lsb);
        }
        return obj;
      };
      Typr.kern = {};
      Typr.kern.parse = function(data, offset, length, font) {
        var bin = Typr._bin;
        var version2 = bin.readUshort(data, offset);
        offset += 2;
        if (version2 == 1)
          return Typr.kern.parseV1(data, offset - 2, length, font);
        var nTables = bin.readUshort(data, offset);
        offset += 2;
        var map2 = { glyph1: [], rval: [] };
        for (var i = 0; i < nTables; i++) {
          offset += 2;
          var length = bin.readUshort(data, offset);
          offset += 2;
          var coverage = bin.readUshort(data, offset);
          offset += 2;
          var format = coverage >>> 8;
          format &= 15;
          if (format == 0)
            offset = Typr.kern.readFormat0(data, offset, map2);
          else
            throw "unknown kern table format: " + format;
        }
        return map2;
      };
      Typr.kern.parseV1 = function(data, offset, length, font) {
        var bin = Typr._bin;
        bin.readFixed(data, offset);
        offset += 4;
        var nTables = bin.readUint(data, offset);
        offset += 4;
        var map2 = { glyph1: [], rval: [] };
        for (var i = 0; i < nTables; i++) {
          bin.readUint(data, offset);
          offset += 4;
          var coverage = bin.readUshort(data, offset);
          offset += 2;
          bin.readUshort(data, offset);
          offset += 2;
          var format = coverage >>> 8;
          format &= 15;
          if (format == 0)
            offset = Typr.kern.readFormat0(data, offset, map2);
          else
            throw "unknown kern table format: " + format;
        }
        return map2;
      };
      Typr.kern.readFormat0 = function(data, offset, map2) {
        var bin = Typr._bin;
        var pleft = -1;
        var nPairs = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        for (var j = 0; j < nPairs; j++) {
          var left = bin.readUshort(data, offset);
          offset += 2;
          var right = bin.readUshort(data, offset);
          offset += 2;
          var value = bin.readShort(data, offset);
          offset += 2;
          if (left != pleft) {
            map2.glyph1.push(left);
            map2.rval.push({ glyph2: [], vals: [] });
          }
          var rval = map2.rval[map2.rval.length - 1];
          rval.glyph2.push(right);
          rval.vals.push(value);
          pleft = left;
        }
        return offset;
      };
      Typr.loca = {};
      Typr.loca.parse = function(data, offset, length, font) {
        var bin = Typr._bin;
        var obj = [];
        var ver = font.head.indexToLocFormat;
        var len = font.maxp.numGlyphs + 1;
        if (ver == 0)
          for (var i = 0; i < len; i++)
            obj.push(bin.readUshort(data, offset + (i << 1)) << 1);
        if (ver == 1)
          for (var i = 0; i < len; i++)
            obj.push(bin.readUint(data, offset + (i << 2)));
        return obj;
      };
      Typr.maxp = {};
      Typr.maxp.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = {};
        var ver = bin.readUint(data, offset);
        offset += 4;
        obj.numGlyphs = bin.readUshort(data, offset);
        offset += 2;
        if (ver == 65536) {
          obj.maxPoints = bin.readUshort(data, offset);
          offset += 2;
          obj.maxContours = bin.readUshort(data, offset);
          offset += 2;
          obj.maxCompositePoints = bin.readUshort(data, offset);
          offset += 2;
          obj.maxCompositeContours = bin.readUshort(data, offset);
          offset += 2;
          obj.maxZones = bin.readUshort(data, offset);
          offset += 2;
          obj.maxTwilightPoints = bin.readUshort(data, offset);
          offset += 2;
          obj.maxStorage = bin.readUshort(data, offset);
          offset += 2;
          obj.maxFunctionDefs = bin.readUshort(data, offset);
          offset += 2;
          obj.maxInstructionDefs = bin.readUshort(data, offset);
          offset += 2;
          obj.maxStackElements = bin.readUshort(data, offset);
          offset += 2;
          obj.maxSizeOfInstructions = bin.readUshort(data, offset);
          offset += 2;
          obj.maxComponentElements = bin.readUshort(data, offset);
          offset += 2;
          obj.maxComponentDepth = bin.readUshort(data, offset);
          offset += 2;
        }
        return obj;
      };
      Typr.name = {};
      Typr.name.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = {};
        bin.readUshort(data, offset);
        offset += 2;
        var count = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var names = [
          "copyright",
          "fontFamily",
          "fontSubfamily",
          "ID",
          "fullName",
          "version",
          "postScriptName",
          "trademark",
          "manufacturer",
          "designer",
          "description",
          "urlVendor",
          "urlDesigner",
          "licence",
          "licenceURL",
          "---",
          "typoFamilyName",
          "typoSubfamilyName",
          "compatibleFull",
          "sampleText",
          "postScriptCID",
          "wwsFamilyName",
          "wwsSubfamilyName",
          "lightPalette",
          "darkPalette"
        ];
        var offset0 = offset;
        for (var i = 0; i < count; i++) {
          var platformID = bin.readUshort(data, offset);
          offset += 2;
          var encodingID = bin.readUshort(data, offset);
          offset += 2;
          var languageID = bin.readUshort(data, offset);
          offset += 2;
          var nameID = bin.readUshort(data, offset);
          offset += 2;
          var slen = bin.readUshort(data, offset);
          offset += 2;
          var noffset = bin.readUshort(data, offset);
          offset += 2;
          var cname = names[nameID];
          var soff = offset0 + count * 12 + noffset;
          var str;
          if (platformID == 0)
            str = bin.readUnicode(data, soff, slen / 2);
          else if (platformID == 3 && encodingID == 0)
            str = bin.readUnicode(data, soff, slen / 2);
          else if (encodingID == 0)
            str = bin.readASCII(data, soff, slen);
          else if (encodingID == 1)
            str = bin.readUnicode(data, soff, slen / 2);
          else if (encodingID == 3)
            str = bin.readUnicode(data, soff, slen / 2);
          else if (platformID == 1) {
            str = bin.readASCII(data, soff, slen);
            console.warn("reading unknown MAC encoding " + encodingID + " as ASCII");
          } else
            throw "unknown encoding " + encodingID + ", platformID: " + platformID;
          var tid = "p" + platformID + "," + languageID.toString(16);
          if (obj[tid] == null)
            obj[tid] = {};
          obj[tid][cname !== void 0 ? cname : nameID] = str;
          obj[tid]._lang = languageID;
        }
        for (var p2 in obj)
          if (obj[p2].postScriptName != null && obj[p2]._lang == 1033)
            return obj[p2];
        for (var p2 in obj)
          if (obj[p2].postScriptName != null && obj[p2]._lang == 0)
            return obj[p2];
        for (var p2 in obj)
          if (obj[p2].postScriptName != null && obj[p2]._lang == 3084)
            return obj[p2];
        for (var p2 in obj)
          if (obj[p2].postScriptName != null)
            return obj[p2];
        var tname;
        for (var p2 in obj) {
          tname = p2;
          break;
        }
        console.warn("returning name table with languageID " + obj[tname]._lang);
        return obj[tname];
      };
      Typr["OS/2"] = {};
      Typr["OS/2"].parse = function(data, offset, length) {
        var bin = Typr._bin;
        var ver = bin.readUshort(data, offset);
        offset += 2;
        var obj = {};
        if (ver == 0)
          Typr["OS/2"].version0(data, offset, obj);
        else if (ver == 1)
          Typr["OS/2"].version1(data, offset, obj);
        else if (ver == 2 || ver == 3 || ver == 4)
          Typr["OS/2"].version2(data, offset, obj);
        else if (ver == 5)
          Typr["OS/2"].version5(data, offset, obj);
        else
          throw "unknown OS/2 table version: " + ver;
        return obj;
      };
      Typr["OS/2"].version0 = function(data, offset, obj) {
        var bin = Typr._bin;
        obj.xAvgCharWidth = bin.readShort(data, offset);
        offset += 2;
        obj.usWeightClass = bin.readUshort(data, offset);
        offset += 2;
        obj.usWidthClass = bin.readUshort(data, offset);
        offset += 2;
        obj.fsType = bin.readUshort(data, offset);
        offset += 2;
        obj.ySubscriptXSize = bin.readShort(data, offset);
        offset += 2;
        obj.ySubscriptYSize = bin.readShort(data, offset);
        offset += 2;
        obj.ySubscriptXOffset = bin.readShort(data, offset);
        offset += 2;
        obj.ySubscriptYOffset = bin.readShort(data, offset);
        offset += 2;
        obj.ySuperscriptXSize = bin.readShort(data, offset);
        offset += 2;
        obj.ySuperscriptYSize = bin.readShort(data, offset);
        offset += 2;
        obj.ySuperscriptXOffset = bin.readShort(data, offset);
        offset += 2;
        obj.ySuperscriptYOffset = bin.readShort(data, offset);
        offset += 2;
        obj.yStrikeoutSize = bin.readShort(data, offset);
        offset += 2;
        obj.yStrikeoutPosition = bin.readShort(data, offset);
        offset += 2;
        obj.sFamilyClass = bin.readShort(data, offset);
        offset += 2;
        obj.panose = bin.readBytes(data, offset, 10);
        offset += 10;
        obj.ulUnicodeRange1 = bin.readUint(data, offset);
        offset += 4;
        obj.ulUnicodeRange2 = bin.readUint(data, offset);
        offset += 4;
        obj.ulUnicodeRange3 = bin.readUint(data, offset);
        offset += 4;
        obj.ulUnicodeRange4 = bin.readUint(data, offset);
        offset += 4;
        obj.achVendID = [bin.readInt8(data, offset), bin.readInt8(data, offset + 1), bin.readInt8(data, offset + 2), bin.readInt8(data, offset + 3)];
        offset += 4;
        obj.fsSelection = bin.readUshort(data, offset);
        offset += 2;
        obj.usFirstCharIndex = bin.readUshort(data, offset);
        offset += 2;
        obj.usLastCharIndex = bin.readUshort(data, offset);
        offset += 2;
        obj.sTypoAscender = bin.readShort(data, offset);
        offset += 2;
        obj.sTypoDescender = bin.readShort(data, offset);
        offset += 2;
        obj.sTypoLineGap = bin.readShort(data, offset);
        offset += 2;
        obj.usWinAscent = bin.readUshort(data, offset);
        offset += 2;
        obj.usWinDescent = bin.readUshort(data, offset);
        offset += 2;
        return offset;
      };
      Typr["OS/2"].version1 = function(data, offset, obj) {
        var bin = Typr._bin;
        offset = Typr["OS/2"].version0(data, offset, obj);
        obj.ulCodePageRange1 = bin.readUint(data, offset);
        offset += 4;
        obj.ulCodePageRange2 = bin.readUint(data, offset);
        offset += 4;
        return offset;
      };
      Typr["OS/2"].version2 = function(data, offset, obj) {
        var bin = Typr._bin;
        offset = Typr["OS/2"].version1(data, offset, obj);
        obj.sxHeight = bin.readShort(data, offset);
        offset += 2;
        obj.sCapHeight = bin.readShort(data, offset);
        offset += 2;
        obj.usDefault = bin.readUshort(data, offset);
        offset += 2;
        obj.usBreak = bin.readUshort(data, offset);
        offset += 2;
        obj.usMaxContext = bin.readUshort(data, offset);
        offset += 2;
        return offset;
      };
      Typr["OS/2"].version5 = function(data, offset, obj) {
        var bin = Typr._bin;
        offset = Typr["OS/2"].version2(data, offset, obj);
        obj.usLowerOpticalPointSize = bin.readUshort(data, offset);
        offset += 2;
        obj.usUpperOpticalPointSize = bin.readUshort(data, offset);
        offset += 2;
        return offset;
      };
      Typr.post = {};
      Typr.post.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = {};
        obj.version = bin.readFixed(data, offset);
        offset += 4;
        obj.italicAngle = bin.readFixed(data, offset);
        offset += 4;
        obj.underlinePosition = bin.readShort(data, offset);
        offset += 2;
        obj.underlineThickness = bin.readShort(data, offset);
        offset += 2;
        return obj;
      };
      Typr.SVG = {};
      Typr.SVG.parse = function(data, offset, length) {
        var bin = Typr._bin;
        var obj = { entries: [] };
        var offset0 = offset;
        bin.readUshort(data, offset);
        offset += 2;
        var svgDocIndexOffset = bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        offset = svgDocIndexOffset + offset0;
        var numEntries = bin.readUshort(data, offset);
        offset += 2;
        for (var i = 0; i < numEntries; i++) {
          var startGlyphID = bin.readUshort(data, offset);
          offset += 2;
          var endGlyphID = bin.readUshort(data, offset);
          offset += 2;
          var svgDocOffset = bin.readUint(data, offset);
          offset += 4;
          var svgDocLength = bin.readUint(data, offset);
          offset += 4;
          var sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
          var svg = bin.readUTF8(sbuf, 0, sbuf.length);
          for (var f2 = startGlyphID; f2 <= endGlyphID; f2++) {
            obj.entries[f2] = svg;
          }
        }
        return obj;
      };
      Typr.SVG.toPath = function(str) {
        var pth = { cmds: [], crds: [] };
        if (str == null)
          return pth;
        var prsr = new DOMParser();
        var doc2 = prsr["parseFromString"](str, "image/svg+xml");
        var svg = doc2.firstChild;
        while (svg.tagName != "svg")
          svg = svg.nextSibling;
        var vb = svg.getAttribute("viewBox");
        if (vb)
          vb = vb.trim().split(" ").map(parseFloat);
        else
          vb = [0, 0, 1e3, 1e3];
        Typr.SVG._toPath(svg.children, pth);
        for (var i = 0; i < pth.crds.length; i += 2) {
          var x2 = pth.crds[i], y = pth.crds[i + 1];
          x2 -= vb[0];
          y -= vb[1];
          y = -y;
          pth.crds[i] = x2;
          pth.crds[i + 1] = y;
        }
        return pth;
      };
      Typr.SVG._toPath = function(nds, pth, fill) {
        for (var ni = 0; ni < nds.length; ni++) {
          var nd = nds[ni], tn2 = nd.tagName;
          var cfl = nd.getAttribute("fill");
          if (cfl == null)
            cfl = fill;
          if (tn2 == "g")
            Typr.SVG._toPath(nd.children, pth, cfl);
          else if (tn2 == "path") {
            pth.cmds.push(cfl ? cfl : "#000000");
            var d2 = nd.getAttribute("d");
            var toks = Typr.SVG._tokens(d2);
            Typr.SVG._toksToPath(toks, pth);
            pth.cmds.push("X");
          } else if (tn2 == "defs") ;
          else
            console.warn(tn2, nd);
        }
      };
      Typr.SVG._tokens = function(d2) {
        var ts = [], off = 0, rn2 = false, cn2 = "";
        while (off < d2.length) {
          var cc = d2.charCodeAt(off), ch = d2.charAt(off);
          off++;
          var isNum = 48 <= cc && cc <= 57 || ch == "." || ch == "-";
          if (rn2) {
            if (ch == "-") {
              ts.push(parseFloat(cn2));
              cn2 = ch;
            } else if (isNum)
              cn2 += ch;
            else {
              ts.push(parseFloat(cn2));
              if (ch != "," && ch != " ")
                ts.push(ch);
              rn2 = false;
            }
          } else {
            if (isNum) {
              cn2 = ch;
              rn2 = true;
            } else if (ch != "," && ch != " ")
              ts.push(ch);
          }
        }
        if (rn2)
          ts.push(parseFloat(cn2));
        return ts;
      };
      Typr.SVG._toksToPath = function(ts, pth) {
        var i = 0, x2 = 0, y = 0, ox = 0, oy = 0;
        var pc = { "M": 2, "L": 2, "H": 1, "V": 1, "S": 4, "C": 6 };
        var cmds = pth.cmds, crds = pth.crds;
        while (i < ts.length) {
          var cmd = ts[i];
          i++;
          if (cmd == "z") {
            cmds.push("Z");
            x2 = ox;
            y = oy;
          } else {
            var cmu = cmd.toUpperCase();
            var ps = pc[cmu], reps = Typr.SVG._reps(ts, i, ps);
            for (var j = 0; j < reps; j++) {
              var xi = 0, yi = 0;
              if (cmd != cmu) {
                xi = x2;
                yi = y;
              }
              if (cmu == "M") {
                x2 = xi + ts[i++];
                y = yi + ts[i++];
                cmds.push("M");
                crds.push(x2, y);
                ox = x2;
                oy = y;
              } else if (cmu == "L") {
                x2 = xi + ts[i++];
                y = yi + ts[i++];
                cmds.push("L");
                crds.push(x2, y);
              } else if (cmu == "H") {
                x2 = xi + ts[i++];
                cmds.push("L");
                crds.push(x2, y);
              } else if (cmu == "V") {
                y = yi + ts[i++];
                cmds.push("L");
                crds.push(x2, y);
              } else if (cmu == "C") {
                var x1 = xi + ts[i++], y1 = yi + ts[i++], x22 = xi + ts[i++], y2 = yi + ts[i++], x3 = xi + ts[i++], y3 = yi + ts[i++];
                cmds.push("C");
                crds.push(x1, y1, x22, y2, x3, y3);
                x2 = x3;
                y = y3;
              } else if (cmu == "S") {
                var co = Math.max(crds.length - 4, 0);
                var x1 = x2 + x2 - crds[co], y1 = y + y - crds[co + 1];
                var x22 = xi + ts[i++], y2 = yi + ts[i++], x3 = xi + ts[i++], y3 = yi + ts[i++];
                cmds.push("C");
                crds.push(x1, y1, x22, y2, x3, y3);
                x2 = x3;
                y = y3;
              } else
                console.warn("Unknown SVG command " + cmd);
            }
          }
        }
      };
      Typr.SVG._reps = function(ts, off, ps) {
        var i = off;
        while (i < ts.length) {
          if (typeof ts[i] == "string")
            break;
          i += ps;
        }
        return (i - off) / ps;
      };
      if (Typr == null)
        Typr = {};
      if (Typr.U == null)
        Typr.U = {};
      Typr.U.codeToGlyph = function(font, code) {
        var cmap = font.cmap;
        for (var _i = 0, _a2 = [cmap.p0e4, cmap.p3e1, cmap.p3e10, cmap.p0e3, cmap.p1e0]; _i < _a2.length; _i++) {
          var tind = _a2[_i];
          if (tind == null)
            continue;
          var tab = cmap.tables[tind];
          if (tab.format == 0) {
            if (code >= tab.map.length)
              continue;
            return tab.map[code];
          } else if (tab.format == 4) {
            var sind = -1;
            for (var i = 0; i < tab.endCount.length; i++) {
              if (code <= tab.endCount[i]) {
                sind = i;
                break;
              }
            }
            if (sind == -1)
              continue;
            if (tab.startCount[sind] > code)
              continue;
            var gli = 0;
            if (tab.idRangeOffset[sind] != 0) {
              gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
            } else {
              gli = code + tab.idDelta[sind];
            }
            return gli & 65535;
          } else if (tab.format == 12) {
            if (code > tab.groups[tab.groups.length - 1][1])
              continue;
            for (var i = 0; i < tab.groups.length; i++) {
              var grp = tab.groups[i];
              if (grp[0] <= code && code <= grp[1])
                return grp[2] + (code - grp[0]);
            }
            continue;
          } else {
            throw "unknown cmap table format " + tab.format;
          }
        }
        return 0;
      };
      Typr.U.glyphToPath = function(font, gid) {
        var path = { cmds: [], crds: [] };
        if (font.SVG && font.SVG.entries[gid]) {
          var p2 = font.SVG.entries[gid];
          if (p2 == null)
            return path;
          if (typeof p2 == "string") {
            p2 = Typr.SVG.toPath(p2);
            font.SVG.entries[gid] = p2;
          }
          return p2;
        } else if (font.CFF) {
          var state = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: font.CFF.Private ? font.CFF.Private.defaultWidthX : 0, open: false };
          var cff = font.CFF, pdct = font.CFF.Private;
          if (cff.ROS) {
            var gi = 0;
            while (cff.FDSelect[gi + 2] <= gid)
              gi += 2;
            pdct = cff.FDArray[cff.FDSelect[gi + 1]].Private;
          }
          Typr.U._drawCFF(font.CFF.CharStrings[gid], state, cff, pdct, path);
        } else if (font.glyf) {
          Typr.U._drawGlyf(gid, font, path);
        }
        return path;
      };
      Typr.U._drawGlyf = function(gid, font, path) {
        var gl = font.glyf[gid];
        if (gl == null)
          gl = font.glyf[gid] = Typr.glyf._parseGlyf(font, gid);
        if (gl != null) {
          if (gl.noc > -1) {
            Typr.U._simpleGlyph(gl, path);
          } else {
            Typr.U._compoGlyph(gl, font, path);
          }
        }
      };
      Typr.U._simpleGlyph = function(gl, p2) {
        for (var c2 = 0; c2 < gl.noc; c2++) {
          var i0 = c2 == 0 ? 0 : gl.endPts[c2 - 1] + 1;
          var il = gl.endPts[c2];
          for (var i = i0; i <= il; i++) {
            var pr = i == i0 ? il : i - 1;
            var nx = i == il ? i0 : i + 1;
            var onCurve = gl.flags[i] & 1;
            var prOnCurve = gl.flags[pr] & 1;
            var nxOnCurve = gl.flags[nx] & 1;
            var x2 = gl.xs[i], y = gl.ys[i];
            if (i == i0) {
              if (onCurve) {
                if (prOnCurve) {
                  Typr.U.P.moveTo(p2, gl.xs[pr], gl.ys[pr]);
                } else {
                  Typr.U.P.moveTo(p2, x2, y);
                  continue;
                }
              } else {
                if (prOnCurve) {
                  Typr.U.P.moveTo(p2, gl.xs[pr], gl.ys[pr]);
                } else {
                  Typr.U.P.moveTo(p2, (gl.xs[pr] + x2) / 2, (gl.ys[pr] + y) / 2);
                }
              }
            }
            if (onCurve) {
              if (prOnCurve)
                Typr.U.P.lineTo(p2, x2, y);
            } else {
              if (nxOnCurve) {
                Typr.U.P.qcurveTo(p2, x2, y, gl.xs[nx], gl.ys[nx]);
              } else {
                Typr.U.P.qcurveTo(p2, x2, y, (x2 + gl.xs[nx]) / 2, (y + gl.ys[nx]) / 2);
              }
            }
          }
          Typr.U.P.closePath(p2);
        }
      };
      Typr.U._compoGlyph = function(gl, font, p2) {
        for (var j = 0; j < gl.parts.length; j++) {
          var path = { cmds: [], crds: [] };
          var prt = gl.parts[j];
          Typr.U._drawGlyf(prt.glyphIndex, font, path);
          var m2 = prt.m;
          for (var i = 0; i < path.crds.length; i += 2) {
            var x2 = path.crds[i], y = path.crds[i + 1];
            p2.crds.push(x2 * m2.a + y * m2.b + m2.tx);
            p2.crds.push(x2 * m2.c + y * m2.d + m2.ty);
          }
          for (var i = 0; i < path.cmds.length; i++) {
            p2.cmds.push(path.cmds[i]);
          }
        }
      };
      Typr.U._getGlyphClass = function(g, cd) {
        var intr = Typr._lctf.getInterval(cd, g);
        return intr == -1 ? 0 : cd[intr + 2];
      };
      Typr.U.getPairAdjustment = function(font, g1, g2) {
        var hasGPOSkern = false;
        if (font.GPOS) {
          var gpos = font["GPOS"];
          var llist = gpos.lookupList, flist = gpos.featureList;
          var tused = [];
          for (var i = 0; i < flist.length; i++) {
            var fl = flist[i];
            if (fl.tag != "kern")
              continue;
            hasGPOSkern = true;
            for (var ti = 0; ti < fl.tab.length; ti++) {
              if (tused[fl.tab[ti]])
                continue;
              tused[fl.tab[ti]] = true;
              var tab = llist[fl.tab[ti]];
              for (var j = 0; j < tab.tabs.length; j++) {
                if (tab.tabs[j] == null)
                  continue;
                var ltab = tab.tabs[j], ind;
                if (ltab.coverage) {
                  ind = Typr._lctf.coverageIndex(ltab.coverage, g1);
                  if (ind == -1)
                    continue;
                }
                if (tab.ltype == 1) ;
                else if (tab.ltype == 2) {
                  var adj = null;
                  if (ltab.fmt == 1) {
                    var right = ltab.pairsets[ind];
                    for (var i = 0; i < right.length; i++) {
                      if (right[i].gid2 == g2)
                        adj = right[i];
                    }
                  } else if (ltab.fmt == 2) {
                    var c1 = Typr.U._getGlyphClass(g1, ltab.classDef1);
                    var c2 = Typr.U._getGlyphClass(g2, ltab.classDef2);
                    adj = ltab.matrix[c1][c2];
                  }
                  if (adj) {
                    var offset = 0;
                    if (adj.val1 && adj.val1[2])
                      offset += adj.val1[2];
                    if (adj.val2 && adj.val2[0])
                      offset += adj.val2[0];
                    return offset;
                  }
                }
              }
            }
          }
        }
        if (font.kern && !hasGPOSkern) {
          var ind1 = font.kern.glyph1.indexOf(g1);
          if (ind1 != -1) {
            var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);
            if (ind2 != -1)
              return font.kern.rval[ind1].vals[ind2];
          }
        }
        return 0;
      };
      Typr.U.stringToGlyphs = function(font, str) {
        var gls = [];
        for (var i = 0; i < str.length; i++) {
          var cc = str.codePointAt(i);
          if (cc > 65535)
            i++;
          gls.push(Typr.U.codeToGlyph(font, cc));
        }
        for (var i = 0; i < str.length; i++) {
          var cc = str.codePointAt(i);
          if (cc == 2367) {
            var t = gls[i - 1];
            gls[i - 1] = gls[i];
            gls[i] = t;
          }
          if (cc > 65535)
            i++;
        }
        var gsub = font["GSUB"];
        if (gsub == null)
          return gls;
        var llist = gsub.lookupList, flist = gsub.featureList;
        var cligs = [
          "rlig",
          "liga",
          "mset",
          "isol",
          "init",
          "fina",
          "medi",
          "half",
          "pres",
          "blws"
          /* Tibetan fonts like Himalaya.ttf */
        ];
        var tused = [];
        for (var fi = 0; fi < flist.length; fi++) {
          var fl = flist[fi];
          if (cligs.indexOf(fl.tag) == -1)
            continue;
          for (var ti = 0; ti < fl.tab.length; ti++) {
            if (tused[fl.tab[ti]])
              continue;
            tused[fl.tab[ti]] = true;
            var tab = llist[fl.tab[ti]];
            for (var ci = 0; ci < gls.length; ci++) {
              var feat = Typr.U._getWPfeature(str, ci);
              if ("isol,init,fina,medi".indexOf(fl.tag) != -1 && fl.tag != feat)
                continue;
              Typr.U._applySubs(gls, ci, tab, llist);
            }
          }
        }
        return gls;
      };
      Typr.U._getWPfeature = function(str, ci) {
        var wsep = '\n	" ,.:;!?()  ،';
        var R2 = "آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬";
        var L = "ꡲ્૗";
        var slft = ci == 0 || wsep.indexOf(str[ci - 1]) != -1;
        var srgt = ci == str.length - 1 || wsep.indexOf(str[ci + 1]) != -1;
        if (!slft && R2.indexOf(str[ci - 1]) != -1)
          slft = true;
        if (!srgt && R2.indexOf(str[ci]) != -1)
          srgt = true;
        if (!srgt && L.indexOf(str[ci + 1]) != -1)
          srgt = true;
        if (!slft && L.indexOf(str[ci]) != -1)
          slft = true;
        var feat = null;
        if (slft) {
          feat = srgt ? "isol" : "init";
        } else {
          feat = srgt ? "fina" : "medi";
        }
        return feat;
      };
      Typr.U._applySubs = function(gls, ci, tab, llist) {
        var rlim = gls.length - ci - 1;
        for (var j = 0; j < tab.tabs.length; j++) {
          if (tab.tabs[j] == null)
            continue;
          var ltab = tab.tabs[j], ind;
          if (ltab.coverage) {
            ind = Typr._lctf.coverageIndex(ltab.coverage, gls[ci]);
            if (ind == -1)
              continue;
          }
          if (tab.ltype == 1) {
            gls[ci];
            if (ltab.fmt == 1)
              gls[ci] = gls[ci] + ltab.delta;
            else
              gls[ci] = ltab.newg[ind];
          } else if (tab.ltype == 4) {
            var vals = ltab.vals[ind];
            for (var k = 0; k < vals.length; k++) {
              var lig = vals[k], rl = lig.chain.length;
              if (rl > rlim)
                continue;
              var good = true, em1 = 0;
              for (var l2 = 0; l2 < rl; l2++) {
                while (gls[ci + em1 + (1 + l2)] == -1)
                  em1++;
                if (lig.chain[l2] != gls[ci + em1 + (1 + l2)])
                  good = false;
              }
              if (!good)
                continue;
              gls[ci] = lig.nglyph;
              for (var l2 = 0; l2 < rl + em1; l2++)
                gls[ci + l2 + 1] = -1;
              break;
            }
          } else if (tab.ltype == 5 && ltab.fmt == 2) {
            var cind = Typr._lctf.getInterval(ltab.cDef, gls[ci]);
            var cls = ltab.cDef[cind + 2], scs = ltab.scset[cls];
            for (var i = 0; i < scs.length; i++) {
              var sc = scs[i], inp = sc.input;
              if (inp.length > rlim)
                continue;
              var good = true;
              for (var l2 = 0; l2 < inp.length; l2++) {
                var cind2 = Typr._lctf.getInterval(ltab.cDef, gls[ci + 1 + l2]);
                if (cind == -1 && ltab.cDef[cind2 + 2] != inp[l2]) {
                  good = false;
                  break;
                }
              }
              if (!good)
                continue;
              var lrs = sc.substLookupRecords;
              for (var k = 0; k < lrs.length; k += 2) {
                lrs[k];
                lrs[k + 1];
              }
            }
          } else if (tab.ltype == 6 && ltab.fmt == 3) {
            if (!Typr.U._glsCovered(gls, ltab.backCvg, ci - ltab.backCvg.length))
              continue;
            if (!Typr.U._glsCovered(gls, ltab.inptCvg, ci))
              continue;
            if (!Typr.U._glsCovered(gls, ltab.ahedCvg, ci + ltab.inptCvg.length))
              continue;
            var lr = ltab.lookupRec;
            for (var i = 0; i < lr.length; i += 2) {
              var cind = lr[i], tab2 = llist[lr[i + 1]];
              Typr.U._applySubs(gls, ci + cind, tab2, llist);
            }
          }
        }
      };
      Typr.U._glsCovered = function(gls, cvgs, ci) {
        for (var i = 0; i < cvgs.length; i++) {
          var ind = Typr._lctf.coverageIndex(cvgs[i], gls[ci + i]);
          if (ind == -1)
            return false;
        }
        return true;
      };
      Typr.U.glyphsToPath = function(font, gls, clr) {
        var tpath = { cmds: [], crds: [] };
        var x2 = 0;
        for (var i = 0; i < gls.length; i++) {
          var gid = gls[i];
          if (gid == -1)
            continue;
          var gid2 = i < gls.length - 1 && gls[i + 1] != -1 ? gls[i + 1] : 0;
          var path = Typr.U.glyphToPath(font, gid);
          for (var j = 0; j < path.crds.length; j += 2) {
            tpath.crds.push(path.crds[j] + x2);
            tpath.crds.push(path.crds[j + 1]);
          }
          if (clr)
            tpath.cmds.push(clr);
          for (var j = 0; j < path.cmds.length; j++)
            tpath.cmds.push(path.cmds[j]);
          if (clr)
            tpath.cmds.push("X");
          x2 += font.hmtx.aWidth[gid];
          if (i < gls.length - 1)
            x2 += Typr.U.getPairAdjustment(font, gid, gid2);
        }
        return tpath;
      };
      Typr.U.pathToSVG = function(path, prec) {
        if (prec == null)
          prec = 5;
        var out = [], co = 0, lmap = { "M": 2, "L": 2, "Q": 4, "C": 6 };
        for (var i = 0; i < path.cmds.length; i++) {
          var cmd = path.cmds[i], cn2 = co + (lmap[cmd] ? lmap[cmd] : 0);
          out.push(cmd);
          while (co < cn2) {
            var c2 = path.crds[co++];
            out.push(parseFloat(c2.toFixed(prec)) + (co == cn2 ? "" : " "));
          }
        }
        return out.join("");
      };
      Typr.U.pathToContext = function(path, ctx) {
        var c2 = 0, crds = path.crds;
        for (var j = 0; j < path.cmds.length; j++) {
          var cmd = path.cmds[j];
          if (cmd == "M") {
            ctx.moveTo(crds[c2], crds[c2 + 1]);
            c2 += 2;
          } else if (cmd == "L") {
            ctx.lineTo(crds[c2], crds[c2 + 1]);
            c2 += 2;
          } else if (cmd == "C") {
            ctx.bezierCurveTo(crds[c2], crds[c2 + 1], crds[c2 + 2], crds[c2 + 3], crds[c2 + 4], crds[c2 + 5]);
            c2 += 6;
          } else if (cmd == "Q") {
            ctx.quadraticCurveTo(crds[c2], crds[c2 + 1], crds[c2 + 2], crds[c2 + 3]);
            c2 += 4;
          } else if (cmd.charAt(0) == "#") {
            ctx.beginPath();
            ctx.fillStyle = cmd;
          } else if (cmd == "Z") {
            ctx.closePath();
          } else if (cmd == "X") {
            ctx.fill();
          }
        }
      };
      Typr.U.P = {};
      Typr.U.P.moveTo = function(p2, x2, y) {
        p2.cmds.push("M");
        p2.crds.push(x2, y);
      };
      Typr.U.P.lineTo = function(p2, x2, y) {
        p2.cmds.push("L");
        p2.crds.push(x2, y);
      };
      Typr.U.P.curveTo = function(p2, a2, b2, c2, d2, e, f2) {
        p2.cmds.push("C");
        p2.crds.push(a2, b2, c2, d2, e, f2);
      };
      Typr.U.P.qcurveTo = function(p2, a2, b2, c2, d2) {
        p2.cmds.push("Q");
        p2.crds.push(a2, b2, c2, d2);
      };
      Typr.U.P.closePath = function(p2) {
        p2.cmds.push("Z");
      };
      Typr.U._drawCFF = function(cmds, state, font, pdct, p2) {
        var stack2 = state.stack;
        var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
        var i = 0;
        var x2 = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
        var o2 = { val: 0, size: 0 };
        while (i < cmds.length) {
          Typr.CFF.getCharString(cmds, i, o2);
          var v2 = o2.val;
          i += o2.size;
          if (v2 == "o1" || v2 == "o18") {
            var hasWidthArg;
            hasWidthArg = stack2.length % 2 !== 0;
            if (hasWidthArg && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
            }
            nStems += stack2.length >> 1;
            stack2.length = 0;
            haveWidth = true;
          } else if (v2 == "o3" || v2 == "o23") {
            var hasWidthArg;
            hasWidthArg = stack2.length % 2 !== 0;
            if (hasWidthArg && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
            }
            nStems += stack2.length >> 1;
            stack2.length = 0;
            haveWidth = true;
          } else if (v2 == "o4") {
            if (stack2.length > 1 && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
              haveWidth = true;
            }
            if (open)
              Typr.U.P.closePath(p2);
            y += stack2.pop();
            Typr.U.P.moveTo(p2, x2, y);
            open = true;
          } else if (v2 == "o5") {
            while (stack2.length > 0) {
              x2 += stack2.shift();
              y += stack2.shift();
              Typr.U.P.lineTo(p2, x2, y);
            }
          } else if (v2 == "o6" || v2 == "o7") {
            var count = stack2.length;
            var isX = v2 == "o6";
            for (var j = 0; j < count; j++) {
              var sval = stack2.shift();
              if (isX) {
                x2 += sval;
              } else {
                y += sval;
              }
              isX = !isX;
              Typr.U.P.lineTo(p2, x2, y);
            }
          } else if (v2 == "o8" || v2 == "o24") {
            var count = stack2.length;
            var index = 0;
            while (index + 6 <= count) {
              c1x = x2 + stack2.shift();
              c1y = y + stack2.shift();
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              x2 = c2x + stack2.shift();
              y = c2y + stack2.shift();
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, x2, y);
              index += 6;
            }
            if (v2 == "o24") {
              x2 += stack2.shift();
              y += stack2.shift();
              Typr.U.P.lineTo(p2, x2, y);
            }
          } else if (v2 == "o11") {
            break;
          } else if (v2 == "o1234" || v2 == "o1235" || v2 == "o1236" || v2 == "o1237") {
            if (v2 == "o1234") {
              c1x = x2 + stack2.shift();
              c1y = y;
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              jpx = c2x + stack2.shift();
              jpy = c2y;
              c3x = jpx + stack2.shift();
              c3y = c2y;
              c4x = c3x + stack2.shift();
              c4y = y;
              x2 = c4x + stack2.shift();
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
              Typr.U.P.curveTo(p2, c3x, c3y, c4x, c4y, x2, y);
            }
            if (v2 == "o1235") {
              c1x = x2 + stack2.shift();
              c1y = y + stack2.shift();
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              jpx = c2x + stack2.shift();
              jpy = c2y + stack2.shift();
              c3x = jpx + stack2.shift();
              c3y = jpy + stack2.shift();
              c4x = c3x + stack2.shift();
              c4y = c3y + stack2.shift();
              x2 = c4x + stack2.shift();
              y = c4y + stack2.shift();
              stack2.shift();
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
              Typr.U.P.curveTo(p2, c3x, c3y, c4x, c4y, x2, y);
            }
            if (v2 == "o1236") {
              c1x = x2 + stack2.shift();
              c1y = y + stack2.shift();
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              jpx = c2x + stack2.shift();
              jpy = c2y;
              c3x = jpx + stack2.shift();
              c3y = c2y;
              c4x = c3x + stack2.shift();
              c4y = c3y + stack2.shift();
              x2 = c4x + stack2.shift();
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
              Typr.U.P.curveTo(p2, c3x, c3y, c4x, c4y, x2, y);
            }
            if (v2 == "o1237") {
              c1x = x2 + stack2.shift();
              c1y = y + stack2.shift();
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              jpx = c2x + stack2.shift();
              jpy = c2y + stack2.shift();
              c3x = jpx + stack2.shift();
              c3y = jpy + stack2.shift();
              c4x = c3x + stack2.shift();
              c4y = c3y + stack2.shift();
              if (Math.abs(c4x - x2) > Math.abs(c4y - y)) {
                x2 = c4x + stack2.shift();
              } else {
                y = c4y + stack2.shift();
              }
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
              Typr.U.P.curveTo(p2, c3x, c3y, c4x, c4y, x2, y);
            }
          } else if (v2 == "o14") {
            if (stack2.length > 0 && !haveWidth) {
              width = stack2.shift() + font.nominalWidthX;
              haveWidth = true;
            }
            if (stack2.length == 4) {
              var adx = stack2.shift();
              var ady = stack2.shift();
              var bchar = stack2.shift();
              var achar = stack2.shift();
              var bind = Typr.CFF.glyphBySE(font, bchar);
              var aind = Typr.CFF.glyphBySE(font, achar);
              Typr.U._drawCFF(font.CharStrings[bind], state, font, pdct, p2);
              state.x = adx;
              state.y = ady;
              Typr.U._drawCFF(font.CharStrings[aind], state, font, pdct, p2);
            }
            if (open) {
              Typr.U.P.closePath(p2);
              open = false;
            }
          } else if (v2 == "o19" || v2 == "o20") {
            var hasWidthArg;
            hasWidthArg = stack2.length % 2 !== 0;
            if (hasWidthArg && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
            }
            nStems += stack2.length >> 1;
            stack2.length = 0;
            haveWidth = true;
            i += nStems + 7 >> 3;
          } else if (v2 == "o21") {
            if (stack2.length > 2 && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
              haveWidth = true;
            }
            y += stack2.pop();
            x2 += stack2.pop();
            if (open)
              Typr.U.P.closePath(p2);
            Typr.U.P.moveTo(p2, x2, y);
            open = true;
          } else if (v2 == "o22") {
            if (stack2.length > 1 && !haveWidth) {
              width = stack2.shift() + pdct.nominalWidthX;
              haveWidth = true;
            }
            x2 += stack2.pop();
            if (open)
              Typr.U.P.closePath(p2);
            Typr.U.P.moveTo(p2, x2, y);
            open = true;
          } else if (v2 == "o25") {
            while (stack2.length > 6) {
              x2 += stack2.shift();
              y += stack2.shift();
              Typr.U.P.lineTo(p2, x2, y);
            }
            c1x = x2 + stack2.shift();
            c1y = y + stack2.shift();
            c2x = c1x + stack2.shift();
            c2y = c1y + stack2.shift();
            x2 = c2x + stack2.shift();
            y = c2y + stack2.shift();
            Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, x2, y);
          } else if (v2 == "o26") {
            if (stack2.length % 2) {
              x2 += stack2.shift();
            }
            while (stack2.length > 0) {
              c1x = x2;
              c1y = y + stack2.shift();
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              x2 = c2x;
              y = c2y + stack2.shift();
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, x2, y);
            }
          } else if (v2 == "o27") {
            if (stack2.length % 2) {
              y += stack2.shift();
            }
            while (stack2.length > 0) {
              c1x = x2 + stack2.shift();
              c1y = y;
              c2x = c1x + stack2.shift();
              c2y = c1y + stack2.shift();
              x2 = c2x + stack2.shift();
              y = c2y;
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, x2, y);
            }
          } else if (v2 == "o10" || v2 == "o29") {
            var obj = v2 == "o10" ? pdct : font;
            if (stack2.length == 0) {
              console.warn("error: empty stack");
            } else {
              var ind = stack2.pop();
              var subr = obj.Subrs[ind + obj.Bias];
              state.x = x2;
              state.y = y;
              state.nStems = nStems;
              state.haveWidth = haveWidth;
              state.width = width;
              state.open = open;
              Typr.U._drawCFF(subr, state, font, pdct, p2);
              x2 = state.x;
              y = state.y;
              nStems = state.nStems;
              haveWidth = state.haveWidth;
              width = state.width;
              open = state.open;
            }
          } else if (v2 == "o30" || v2 == "o31") {
            var count, count1 = stack2.length;
            var index = 0;
            var alternate = v2 == "o31";
            count = count1 & -3;
            index += count1 - count;
            while (index < count) {
              if (alternate) {
                c1x = x2 + stack2.shift();
                c1y = y;
                c2x = c1x + stack2.shift();
                c2y = c1y + stack2.shift();
                y = c2y + stack2.shift();
                if (count - index == 5) {
                  x2 = c2x + stack2.shift();
                  index++;
                } else {
                  x2 = c2x;
                }
                alternate = false;
              } else {
                c1x = x2;
                c1y = y + stack2.shift();
                c2x = c1x + stack2.shift();
                c2y = c1y + stack2.shift();
                x2 = c2x + stack2.shift();
                if (count - index == 5) {
                  y = c2y + stack2.shift();
                  index++;
                } else {
                  y = c2y;
                }
                alternate = true;
              }
              Typr.U.P.curveTo(p2, c1x, c1y, c2x, c2y, x2, y);
              index += 4;
            }
          } else if ((v2 + "").charAt(0) == "o") {
            console.warn("Unknown operation: " + v2, cmds);
            throw v2;
          } else
            stack2.push(v2);
        }
        state.x = x2;
        state.y = y;
        state.nStems = nStems;
        state.haveWidth = haveWidth;
        state.width = width;
        state.open = open;
      };
      Typr$1.Typr = Typr;
      var Typr_js_1 = Typr$1;
      var friendlyTags = { "aalt": "Access All Alternates", "abvf": "Above-base Forms", "abvm": "Above - base Mark Positioning", "abvs": "Above - base Substitutions", "afrc": "Alternative Fractions", "akhn": "Akhands", "blwf": "Below - base Forms", "blwm": "Below - base Mark Positioning", "blws": "Below - base Substitutions", "calt": "Contextual Alternates", "case": "Case - Sensitive Forms", "ccmp": "Glyph Composition / Decomposition", "cfar": "Conjunct Form After Ro", "cjct": "Conjunct Forms", "clig": "Contextual Ligatures", "cpct": "Centered CJK Punctuation", "cpsp": "Capital Spacing", "cswh": "Contextual Swash", "curs": "Cursive Positioning", "c2pc": "Petite Capitals From Capitals", "c2sc": "Small Capitals From Capitals", "dist": "Distances", "dlig": "Discretionary Ligatures", "dnom": "Denominators", "dtls": "Dotless Forms", "expt": "Expert Forms", "falt": "Final Glyph on Line Alternates", "fin2": "Terminal Forms #2", "fin3": "Terminal Forms #3", "fina": "Terminal Forms", "flac": "Flattened accent forms", "frac": "Fractions", "fwid": "Full Widths", "half": "Half Forms", "haln": "Halant Forms", "halt": "Alternate Half Widths", "hist": "Historical Forms", "hkna": "Horizontal Kana Alternates", "hlig": "Historical Ligatures", "hngl": "Hangul", "hojo": "Hojo Kanji Forms(JIS X 0212 - 1990 Kanji Forms)", "hwid": "Half Widths", "init": "Initial Forms", "isol": "Isolated Forms", "ital": "Italics", "jalt": "Justification Alternates", "jp78": "JIS78 Forms", "jp83": "JIS83 Forms", "jp90": "JIS90 Forms", "jp04": "JIS2004 Forms", "kern": "Kerning", "lfbd": "Left Bounds", "liga": "Standard Ligatures", "ljmo": "Leading Jamo Forms", "lnum": "Lining Figures", "locl": "Localized Forms", "ltra": "Left - to - right alternates", "ltrm": "Left - to - right mirrored forms", "mark": "Mark Positioning", "med2": "Medial Forms #2", "medi": "Medial Forms", "mgrk": "Mathematical Greek", "mkmk": "Mark to Mark Positioning", "mset": "Mark Positioning via Substitution", "nalt": "Alternate Annotation Forms", "nlck": "NLC Kanji Forms", "nukt": "Nukta Forms", "numr": "Numerators", "onum": "Oldstyle Figures", "opbd": "Optical Bounds", "ordn": "Ordinals", "ornm": "Ornaments", "palt": "Proportional Alternate Widths", "pcap": "Petite Capitals", "pkna": "Proportional Kana", "pnum": "Proportional Figures", "pref": "Pre - Base Forms", "pres": "Pre - base Substitutions", "pstf": "Post - base Forms", "psts": "Post - base Substitutions", "pwid": "Proportional Widths", "qwid": "Quarter Widths", "rand": "Randomize", "rclt": "Required Contextual Alternates", "rkrf": "Rakar Forms", "rlig": "Required Ligatures", "rphf": "Reph Forms", "rtbd": "Right Bounds", "rtla": "Right - to - left alternates", "rtlm": "Right - to - left mirrored forms", "ruby": "Ruby Notation Forms", "rvrn": "Required Variation Alternates", "salt": "Stylistic Alternates", "sinf": "Scientific Inferiors", "size": "Optical size", "smcp": "Small Capitals", "smpl": "Simplified Forms", "ssty": "Math script style alternates", "stch": "Stretching Glyph Decomposition", "subs": "Subscript", "sups": "Superscript", "swsh": "Swash", "titl": "Titling", "tjmo": "Trailing Jamo Forms", "tnam": "Traditional Name Forms", "tnum": "Tabular Figures", "trad": "Traditional Forms", "twid": "Third Widths", "unic": "Unicase", "valt": "Alternate Vertical Metrics", "vatu": "Vattu Variants", "vert": "Vertical Writing", "vhal": "Alternate Vertical Half Metrics", "vjmo": "Vowel Jamo Forms", "vkna": "Vertical Kana Alternates", "vkrn": "Vertical Kerning", "vpal": "Proportional Alternate Vertical Metrics", "vrt2": "Vertical Alternates and Rotation", "vrtr": "Vertical Alternates for Rotation", "zero": "Slashed Zero" };
      var Font = (
        /** @class */
        function() {
          function Font2(data) {
            var obj = Typr_js_1.Typr.parse(data);
            if (!obj.length || typeof obj[0] !== "object" || typeof obj[0].hasOwnProperty !== "function") {
              throw "unable to parse font";
            }
            for (var n in obj[0]) {
              this[n] = obj[0][n];
            }
            this.enabledGSUB = {};
          }
          Font2.prototype.getFamilyName = function() {
            return this.name && (this.name.typoFamilyName || this.name.fontFamily) || "";
          };
          Font2.prototype.getSubFamilyName = function() {
            return this.name && (this.name.typoSubfamilyName || this.name.fontSubfamily) || "";
          };
          Font2.prototype.glyphToPath = function(gid) {
            return Typr_js_1.Typr.U.glyphToPath(this, gid);
          };
          Font2.prototype.getPairAdjustment = function(gid1, gid2) {
            return Typr_js_1.Typr.U.getPairAdjustment(this, gid1, gid2);
          };
          Font2.prototype.stringToGlyphs = function(str) {
            return Typr_js_1.Typr.U.stringToGlyphs(this, str);
          };
          Font2.prototype.glyphsToPath = function(gls) {
            return Typr_js_1.Typr.U.glyphsToPath(this, gls);
          };
          Font2.prototype.pathToSVG = function(path, prec) {
            return Typr_js_1.Typr.U.pathToSVG(path, prec);
          };
          Font2.prototype.pathToContext = function(path, ctx) {
            return Typr_js_1.Typr.U.pathToContext(path, ctx);
          };
          Font2.prototype.lookupFriendlyName = function(table, feature) {
            if (this[table] !== void 0) {
              var tbl = this[table];
              var feat = tbl.featureList[feature];
              return this.featureFriendlyName(feat);
            }
            return "";
          };
          Font2.prototype.featureFriendlyName = function(feature) {
            if (friendlyTags[feature.tag]) {
              return friendlyTags[feature.tag];
            }
            if (feature.tag.match(/ss[0-2][0-9]/)) {
              var name_1 = "Stylistic Set " + Number(feature.tag.substr(2, 2)).toString();
              if (feature.featureParams) {
                var version2 = Typr_js_1.Typr._bin.readUshort(this._data, feature.featureParams);
                if (version2 === 0) {
                  var nameID = Typr_js_1.Typr._bin.readUshort(this._data, feature.featureParams + 2);
                  if (this.name && this.name[nameID] !== void 0) {
                    return name_1 + " - " + this.name[nameID];
                  }
                }
              }
              return name_1;
            }
            if (feature.tag.match(/cv[0-9][0-9]/)) {
              return "Character Variant " + Number(feature.tag.substr(2, 2)).toString();
            }
            return "";
          };
          Font2.prototype.enableGSUB = function(featureNumber) {
            if (this.GSUB) {
              var feature = this.GSUB.featureList[featureNumber];
              if (feature) {
                for (var i = 0; i < feature.tab.length; ++i) {
                  this.enabledGSUB[feature.tab[i]] = (this.enabledGSUB[feature.tab[i]] || 0) + 1;
                }
              }
            }
          };
          Font2.prototype.disableGSUB = function(featureNumber) {
            if (this.GSUB) {
              var feature = this.GSUB.featureList[featureNumber];
              if (feature) {
                for (var i = 0; i < feature.tab.length; ++i) {
                  if (this.enabledGSUB[feature.tab[i]] > 1) {
                    --this.enabledGSUB[feature.tab[i]];
                  } else {
                    delete this.enabledGSUB[feature.tab[i]];
                  }
                }
              }
            }
          };
          Font2.prototype.codeToGlyph = function(code) {
            var g = Typr_js_1.Typr.U.codeToGlyph(this, code);
            if (this.GSUB) {
              var gls = [g];
              for (var n in this.enabledGSUB) {
                var l2 = this.GSUB.lookupList[n];
                Typr_js_1.Typr.U._applySubs(gls, 0, l2, this.GSUB.lookupList);
              }
              if (gls.length === 1)
                return gls[0];
            }
            return g;
          };
          return Font2;
        }()
      );
      var Font_1 = Font;
      var md5$1 = { exports: {} };
      var crypt = { exports: {} };
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
          // Bit-wise rotation left
          rotl: function(n, b2) {
            return n << b2 | n >>> 32 - b2;
          },
          // Bit-wise rotation right
          rotr: function(n, b2) {
            return n << 32 - b2 | n >>> b2;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt$1.endian(n[i]);
            return n;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n) {
            for (var bytes = []; n > 0; n--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes) {
            for (var words = [], i = 0, b2 = 0; i < bytes.length; i++, b2 += 8)
              words[b2 >>> 5] |= bytes[i] << 24 - b2 % 32;
            return words;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words) {
            for (var bytes = [], b2 = 0; b2 < words.length * 32; b2 += 8)
              bytes.push(words[b2 >>> 5] >>> 24 - b2 % 32 & 255);
            return bytes;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes) {
            for (var hex = [], i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 15).toString(16));
            }
            return hex.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex) {
            for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2)
              bytes.push(parseInt(hex.substr(c2, 2), 16));
            return bytes;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes) {
            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
              var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                else
                  base64.push("=");
            }
            return base64.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0) continue;
              bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
          }
        };
        crypt.exports = crypt$1;
      })();
      var cryptExports = crypt.exports;
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes = [], i = 0; i < str.length; i++)
              bytes.push(str.charCodeAt(i) & 255);
            return bytes;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            for (var str = [], i = 0; i < bytes.length; i++)
              str.push(String.fromCharCode(bytes[i]));
            return str.join("");
          }
        }
      };
      var charenc_1 = charenc;
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1 = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
      (function() {
        var crypt2 = cryptExports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message, options) {
          if (message.constructor == String)
            if (options && options.encoding === "binary")
              message = bin.stringToBytes(message);
            else
              message = utf8.stringToBytes(message);
          else if (isBuffer2(message))
            message = Array.prototype.slice.call(message, 0);
          else if (!Array.isArray(message) && message.constructor !== Uint8Array)
            message = message.toString();
          var m2 = crypt2.bytesToWords(message), l2 = message.length * 8, a2 = 1732584193, b2 = -271733879, c2 = -1732584194, d2 = 271733878;
          for (var i = 0; i < m2.length; i++) {
            m2[i] = (m2[i] << 8 | m2[i] >>> 24) & 16711935 | (m2[i] << 24 | m2[i] >>> 8) & 4278255360;
          }
          m2[l2 >>> 5] |= 128 << l2 % 32;
          m2[(l2 + 64 >>> 9 << 4) + 14] = l2;
          var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
          for (var i = 0; i < m2.length; i += 16) {
            var aa = a2, bb = b2, cc = c2, dd = d2;
            a2 = FF(a2, b2, c2, d2, m2[i + 0], 7, -680876936);
            d2 = FF(d2, a2, b2, c2, m2[i + 1], 12, -389564586);
            c2 = FF(c2, d2, a2, b2, m2[i + 2], 17, 606105819);
            b2 = FF(b2, c2, d2, a2, m2[i + 3], 22, -1044525330);
            a2 = FF(a2, b2, c2, d2, m2[i + 4], 7, -176418897);
            d2 = FF(d2, a2, b2, c2, m2[i + 5], 12, 1200080426);
            c2 = FF(c2, d2, a2, b2, m2[i + 6], 17, -1473231341);
            b2 = FF(b2, c2, d2, a2, m2[i + 7], 22, -45705983);
            a2 = FF(a2, b2, c2, d2, m2[i + 8], 7, 1770035416);
            d2 = FF(d2, a2, b2, c2, m2[i + 9], 12, -1958414417);
            c2 = FF(c2, d2, a2, b2, m2[i + 10], 17, -42063);
            b2 = FF(b2, c2, d2, a2, m2[i + 11], 22, -1990404162);
            a2 = FF(a2, b2, c2, d2, m2[i + 12], 7, 1804603682);
            d2 = FF(d2, a2, b2, c2, m2[i + 13], 12, -40341101);
            c2 = FF(c2, d2, a2, b2, m2[i + 14], 17, -1502002290);
            b2 = FF(b2, c2, d2, a2, m2[i + 15], 22, 1236535329);
            a2 = GG(a2, b2, c2, d2, m2[i + 1], 5, -165796510);
            d2 = GG(d2, a2, b2, c2, m2[i + 6], 9, -1069501632);
            c2 = GG(c2, d2, a2, b2, m2[i + 11], 14, 643717713);
            b2 = GG(b2, c2, d2, a2, m2[i + 0], 20, -373897302);
            a2 = GG(a2, b2, c2, d2, m2[i + 5], 5, -701558691);
            d2 = GG(d2, a2, b2, c2, m2[i + 10], 9, 38016083);
            c2 = GG(c2, d2, a2, b2, m2[i + 15], 14, -660478335);
            b2 = GG(b2, c2, d2, a2, m2[i + 4], 20, -405537848);
            a2 = GG(a2, b2, c2, d2, m2[i + 9], 5, 568446438);
            d2 = GG(d2, a2, b2, c2, m2[i + 14], 9, -1019803690);
            c2 = GG(c2, d2, a2, b2, m2[i + 3], 14, -187363961);
            b2 = GG(b2, c2, d2, a2, m2[i + 8], 20, 1163531501);
            a2 = GG(a2, b2, c2, d2, m2[i + 13], 5, -1444681467);
            d2 = GG(d2, a2, b2, c2, m2[i + 2], 9, -51403784);
            c2 = GG(c2, d2, a2, b2, m2[i + 7], 14, 1735328473);
            b2 = GG(b2, c2, d2, a2, m2[i + 12], 20, -1926607734);
            a2 = HH(a2, b2, c2, d2, m2[i + 5], 4, -378558);
            d2 = HH(d2, a2, b2, c2, m2[i + 8], 11, -2022574463);
            c2 = HH(c2, d2, a2, b2, m2[i + 11], 16, 1839030562);
            b2 = HH(b2, c2, d2, a2, m2[i + 14], 23, -35309556);
            a2 = HH(a2, b2, c2, d2, m2[i + 1], 4, -1530992060);
            d2 = HH(d2, a2, b2, c2, m2[i + 4], 11, 1272893353);
            c2 = HH(c2, d2, a2, b2, m2[i + 7], 16, -155497632);
            b2 = HH(b2, c2, d2, a2, m2[i + 10], 23, -1094730640);
            a2 = HH(a2, b2, c2, d2, m2[i + 13], 4, 681279174);
            d2 = HH(d2, a2, b2, c2, m2[i + 0], 11, -358537222);
            c2 = HH(c2, d2, a2, b2, m2[i + 3], 16, -722521979);
            b2 = HH(b2, c2, d2, a2, m2[i + 6], 23, 76029189);
            a2 = HH(a2, b2, c2, d2, m2[i + 9], 4, -640364487);
            d2 = HH(d2, a2, b2, c2, m2[i + 12], 11, -421815835);
            c2 = HH(c2, d2, a2, b2, m2[i + 15], 16, 530742520);
            b2 = HH(b2, c2, d2, a2, m2[i + 2], 23, -995338651);
            a2 = II(a2, b2, c2, d2, m2[i + 0], 6, -198630844);
            d2 = II(d2, a2, b2, c2, m2[i + 7], 10, 1126891415);
            c2 = II(c2, d2, a2, b2, m2[i + 14], 15, -1416354905);
            b2 = II(b2, c2, d2, a2, m2[i + 5], 21, -57434055);
            a2 = II(a2, b2, c2, d2, m2[i + 12], 6, 1700485571);
            d2 = II(d2, a2, b2, c2, m2[i + 3], 10, -1894986606);
            c2 = II(c2, d2, a2, b2, m2[i + 10], 15, -1051523);
            b2 = II(b2, c2, d2, a2, m2[i + 1], 21, -2054922799);
            a2 = II(a2, b2, c2, d2, m2[i + 8], 6, 1873313359);
            d2 = II(d2, a2, b2, c2, m2[i + 15], 10, -30611744);
            c2 = II(c2, d2, a2, b2, m2[i + 6], 15, -1560198380);
            b2 = II(b2, c2, d2, a2, m2[i + 13], 21, 1309151649);
            a2 = II(a2, b2, c2, d2, m2[i + 4], 6, -145523070);
            d2 = II(d2, a2, b2, c2, m2[i + 11], 10, -1120210379);
            c2 = II(c2, d2, a2, b2, m2[i + 2], 15, 718787259);
            b2 = II(b2, c2, d2, a2, m2[i + 9], 21, -343485551);
            a2 = a2 + aa >>> 0;
            b2 = b2 + bb >>> 0;
            c2 = c2 + cc >>> 0;
            d2 = d2 + dd >>> 0;
          }
          return crypt2.endian([a2, b2, c2, d2]);
        };
        md52._ff = function(a2, b2, c2, d2, x2, s2, t) {
          var n = a2 + (b2 & c2 | ~b2 & d2) + (x2 >>> 0) + t;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._gg = function(a2, b2, c2, d2, x2, s2, t) {
          var n = a2 + (b2 & d2 | c2 & ~d2) + (x2 >>> 0) + t;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._hh = function(a2, b2, c2, d2, x2, s2, t) {
          var n = a2 + (b2 ^ c2 ^ d2) + (x2 >>> 0) + t;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._ii = function(a2, b2, c2, d2, x2, s2, t) {
          var n = a2 + (c2 ^ (b2 | ~d2)) + (x2 >>> 0) + t;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._blocksize = 16;
        md52._digestsize = 16;
        md5$1.exports = function(message, options) {
          if (message === void 0 || message === null)
            throw new Error("Illegal argument " + message);
          var digestbytes = crypt2.wordsToBytes(md52(message, options));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
        };
      })();
      var md5Exports = md5$1.exports;
      const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
      // @license      MIT
      const crackFont = async (iframeDocument) => {
        await decrypt(iframeDocument);
      };
      const decrypt = async (iframeDocument) => {
        let _tc, _b, _c;
        const styles = iframeDocument.querySelectorAll("style");
        let tip;
        for (let i = 0; i < styles.length; i++) {
          if ((_tc = styles[i].textContent) == null ? 0 : _tc.includes("font-cxsecret")) {
            tip = styles[i];
            break;
          }
        }
        if (!tip)
          return;
        const fontData = (_c = (_b = tip.textContent) == null ? 0 : _b.match(/base64,([\w\W]+?)'/)) == null ? 0 : _c[1];
        if (!fontData)
          return;
        const fontArray = base64ToUint8Array(fontData);
        const font = new Font_1(fontArray);
        const table = JSON.parse(_GM_getResourceText("Table"));
        const match = {};
        for (let i = 19968; i < 40870; i++) {
          const glyph = font.codeToGlyph(i);
          if (!glyph)
            continue;
          const path = font.glyphToPath(glyph);
          const hash = md5(JSON.stringify(path)).slice(24);
          match[i] = table[hash];
        }
        const elements = iframeDocument.querySelectorAll(".font-cxsecret");
        for (let i = 0; i < elements.length; i++) {
          const el = elements[i];
          let html = el.innerHTML;
          for (const key in match) {
            const value = String.fromCharCode(match[key]);
            const regExp = new RegExp(String.fromCharCode(Number(key)), "g");
            html = html.replace(regExp, value);
          }
          el.innerHTML = html;
          el.classList.remove("font-cxsecret");
        }
        function base64ToUint8Array(base64) {
          const data = window.atob(base64);
          const buffer = new Uint8Array(data.length);
          for (let i = 0; i < data.length; ++i) {
            buffer[i] = data.charCodeAt(i);
          }
          return buffer;
        }
      };
      const sleep = (ms) => {
        return new Promise((resolve2) => setTimeout(resolve2, ms * 1e3));
      };
      const request = (url, method = "GET", headers, data, onSuccess, onError) => {
        _GM_xmlhttpRequest({
          method,
          headers,
          url,
          // timeout: 20000, // 5秒超时
          data: method === "POST" ? data : null,
          onload: function(response) {
            if (response.status >= 200 && response.status < 300) {
              if (onSuccess) {
                const resp = JSON.parse(response.responseText);
                if (resp.code === 200) {
                  onSuccess(resp.data);
                } else {
                  onError(new Error(resp.msg));
                }
              }
            } else {
              if (onError) {
                onError(new Error(`Request failed with status ${response.status}`));
              }
            }
          },
          onerror: function(error) {
            if (onError) {
              onError(error);
            }
          }
        });
      };
      const inputNumberAttr = {
        step: 1,
        "step-strictly": true,
        size: "small"
      };
      const tabBars = [
        {
          value: "settings",
          label: "配置"
        }
      ];
      const settings = [
        
      ];
      const guide = [
        {
          index: 1,
          content: "本脚本完全免费，无任何付费项目"
        },
        {
          index: 2,
          content: "使用第三方题库资源，内容准确率非100%，仅供参考"
        },
        {
          index: 3,
          content: "请先打开需要处理的课程视频或作业页面"
        },
        {
          index: 4,
          content: "根据实际需求，配置相应的自动化选项"
        }
      ];
      const protocol = [
        {
          index: 1,
          content: "本脚本仅供学习和研究目的使用，并应在24小时内删除。脚本的使用不应违反任何法律法规及学术道德标准。"
        },
        {
          index: 2,
          content: "用户在使用脚本时，必须遵守所有适用的法律法规。任何由于使用脚本而引起的违法行为或不当行为，其产生的一切后果由用户自行承担。"
        },
        {
          index: 4,
          content: "开发者不对用户使用脚本所产生的任何直接或间接后果负责。用户应自行评估使用脚本的风险，并对任何可能的负面影响承担全责。"
        },
        {
          index: 5,
          content: "本声明的目的在于提醒用户注意相关法律法规与风险，确保用户在明智、合法的前提下使用脚本。"
        },
        {
          index: 6,
          content: "如用户在使用脚本的过程中有任何疑问，建议立即停止使用，并删除所有相关文件。"
        },
        {
          index: 7,
          content: "本免责声明的最终解释权归脚本开发者所有。"
        }
      ];
      const types = {
        0: "单选题",
        1: "多选题",
        3: "判断题"
      };
      const simulateRequest = async (url, params, _self, keys2) => {
        return new Promise((resolve2) => {
          const data = JSON.stringify({
            ...params,
            typeText: types[params.type],
            key: keys2
          });
          let { author, version: version2 } = _GM_info.script;
          request(
            `${url}?s=${author}&v=${version2}`,
            "POST",
            {
              "Content-Type": "application/json",
              referer: params.refer,
              u: _self.uid || _self.getCookie("UID") || _self.getCookie("_uid") || "",
              t: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3).toString()
            },
            data,
            (response) => {
              resolve2(response);
            },
            (error) => {
              resolve2(error);
            }
          );
        });
      };
      const _hoisted_1 = { class: "tab-bar" };
      const _hoisted_2 = ["size", "onClick"];
      const _hoisted_3 = { class: "content-body" };
      const _hoisted_4 = {
        key: 0,
        class: "validate-key body-box"
      };
      const _hoisted_5 = { class: "card-title" };
      const _hoisted_6 = { style: { "margin-top": "16px" } };
      const _hoisted_7 = { class: "card-title" };
      const _hoisted_8 = {
        key: 1,
        class: "body-box"
      };
      const _hoisted_9 = { class: "card-title" };
      const _hoisted_10 = { class: "settings-main" };
      const _hoisted_11 = { class: "title" };
      const _hoisted_12 = { class: "title-text" };
      const _hoisted_13 = { class: "sub-title" };
      const _hoisted_14 = {
        key: 2,
        class: "guide body-box"
      };
      const _hoisted_15 = { class: "card-title" };
      const _hoisted_16 = { class: "guide-content" };
      const _hoisted_17 = { class: "guide-content-index" };
      const _hoisted_18 = { class: "guide-content-content" };
      const _hoisted_19 = {
        key: 3,
        class: "guide body-box"
      };
      const _hoisted_20 = { class: "card-title" };
      const _hoisted_21 = { class: "guide-content" };
      const _hoisted_22 = { class: "guide-content-index" };
      const _hoisted_23 = { class: "guide-content-content" };
      const _hoisted_24 = {
        key: 4,
        class: "log-generation body-box"
      };
      const _hoisted_25 = { class: "card-title" };
      const _hoisted_26 = { class: "log-generation-content" };
      const _hoisted_27 = { class: "value" };
      const _sfc_main$1 = {
        __name: "index",
        setup(__props) {
          const userInfoStore = useUserInfoStore();
          const configStore = reactive({
            isShow: true,
            platformParams: {
              cx: {
                autoNext: true,
                // 自动切换
                answeringMode: false
                // 只答题
              }
            },
            // 入参
            otherParams: {
              timeInterval: 3,
              // 切换、答题间隔，单位秒
              rate: 85,
              // 正确率达到多少自动提交
              name: "其他参数"
            },
            rate: 80,
            // 完成率
            currentPageTabs: [],
            // 当前任务章节 tab
            nowIdx: 0,
            // 当前tab索引
            title: "AT助手",
            logData: [],
            // 日志
            isfalse: false,
            sizes: "small",
            activeTab: "settings",
            // avatarSrc:
            //   'https://public.readdy.ai/ai/img_res/2d58579252345596c10002ce85d4f6f8.jpg',
            workUrl: window.location.href,
            key: userInfoStore.key,
            // keys
            validatedKeys: false,
            // 是否验证
            url: "https://autohelper.top/prod-api/question/dpQuestion"
          });
          const column = [
            {
              prop: "title",
              label: "题目"
            },
            {
              prop: "answer",
              label: "答案",
              width: "140"
            }
          ];
          const __defProp2 = Object.defineProperty;
          const __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value
          }) : obj[key] = value;
          const __publicField = (obj, key, value) => {
            __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
            return value;
          };
          const _unsafeWindow$1 = /* @__PURE__ */ (() => typeof _unsafeWindow != "undefined" ? _unsafeWindow : void 0)();
          const addLog = (obj) => {
            configStore.logData.unshift({
              time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
              ...obj
            });
          };
          const waitIframeLoad = async (iframe) => {
            return new Promise((resolve2) => {
              const intervalId = setInterval(async () => {
                var _a2;
                if (((_a2 = iframe.contentDocument) == null ? void 0 : _a2.readyState) === "complete") {
                  resolve2();
                  clearInterval(intervalId);
                }
              }, 500);
            });
          };
          const processIframe = async (iframe) => {
            var _a2;
            const iframeSrc = iframe.src;
            const iframeDocument = iframe.contentDocument;
            const iframeWindow = iframe.contentWindow;
            if (!iframeDocument || !iframeWindow) {
              return Promise.resolve();
            }
            if (iframeSrc.includes("javascript:")) {
              return Promise.resolve();
            }
            await waitIframeLoad(iframe);
            const parentClass = ((_a2 = iframe.parentElement) == null ? void 0 : _a2.className) || "";
            if (parentClass.includes("ans-job-finished")) {
              addLog({
                value: `发现一个已完成任务点`,
                type: "success"
              });
              return Promise.resolve();
            }
            if (iframeSrc.includes("api/work")) {
              return await processWork(iframe, iframeDocument, iframeWindow);
            }
            if (configStore.platformParams.cx.answeringMode) {
              addLog({
                value: `只答题模式已开，可在设置里调整`,
                type: "warning"
              });
            } else {
              const ansJobIcon = iframe.parentElement ? iframe.parentElement.querySelector(".ans-job-icon") : "";
              if (ansJobIcon) {
                if (iframeSrc.includes("video")) {
                  return processMedia("video", iframeDocument);
                } else if (iframeSrc.includes("audio")) {
                  return processMedia("audio", iframeDocument);
                } else if (["ppt", "doc", "pptx", "docx", "pdf"].some(
                  (type) => iframeSrc.includes("modules/" + type)
                )) {
                  return processPpt();
                } else if (["innerbook"].some((type) => iframeSrc.includes("modules/" + type))) {
                  return processBook(iframeWindow);
                }
              }
            }
            return Promise.resolve();
          };
          const processMedia = async (mediaType, iframeDocument) => {
            return new Promise(async (resolve2) => {
              addLog({
                value: `发现一个${mediaType}，正在解析`,
                type: "warning"
              });
              addLog({
                value: `正在尝试播放${mediaType}，请稍等`,
                type: "warning"
              });
              await sleep(1);
              let isExecuted = false;
              addLog({
                value: `播放成功`,
                type: "success"
              });
              const intervalId = setInterval(async () => {
                const mediaElement = iframeDocument.documentElement.querySelector(mediaType);
                if (mediaElement && !isExecuted) {
                  await mediaElement.pause();
                  mediaElement.muted = true;
                  await mediaElement.play();
                  const listener = async () => {
                    await sleep(3);
                    await mediaElement.play();
                  };
                  mediaElement.addEventListener("pause", listener);
                  mediaElement.addEventListener("ended", () => {
                    addLog({
                      value: `${mediaType}已播放完成`,
                      type: "success"
                    });
                    mediaElement.removeEventListener("pause", listener);
                    resolve2();
                  });
                  isExecuted = true;
                  clearInterval(intervalId);
                }
              }, 2500);
            });
          };
          const processPpt = async (iframeWindow) => {
            return Promise.resolve();
          };
          const processBook = async (iframeWindow) => {
            var _a2;
            addLog({
              value: `发现一个电子书，正在解析`,
              type: "warning"
            });
            (_a2 = _unsafeWindow$1 == null ? void 0 : _unsafeWindow$1.top) == null ? void 0 : _a2.onchangepage(iframeWindow.getFrameAttr("end"));
            addLog({
              value: `阅读完成`,
              type: "success"
            });
            return Promise.resolve();
          };
          class BaseQuestionHandler {
            constructor() {
              __publicField(this, "_document", document);
              __publicField(this, "_window", _unsafeWindow$1);
              __publicField(this, "questions", []);
              __publicField(this, "correctNum", 0);
              __publicField(this, "parseHtml", () => {
                throw new Error("请使用继承类的重写方法");
              });
              __publicField(this, "fillQuestion", (question) => {
                throw new Error("请使用继承类的重写方法");
              });
              __publicField(this, "questionType", {
                单选题: "0",
                A1型题: "0",
                多选题: "1",
                X型题: "1",
                填空题: "2",
                判断题: "3",
                简答题: "4",
                名词解释: "5",
                论述题: "6",
                计算题: "7"
              });
              __publicField(this, "removeHtml", (html) => {
                if (html == null) {
                  return "";
                }
                return html.replace(/<((?!img|sub|sup|br)[^>]+)>/g, "").replace(/&nbsp;/g, " ").replace(/\s+/g, " ").replace(/<br\s*\/?>/g, "\n").replace(/<img.*?src="(.*?)".*?>/g, '<img src="$1"/>').trim();
              });
              __publicField(this, "clean", (str) => {
                return str.replace(/^【.*?】\s*/, "").replace(/\s*（\d+\.\d+分）$/, "");
              });
            }
          }
          class CxQuestionHandler extends BaseQuestionHandler {
            constructor(type, iframe) {
              super();
              __publicField(this, "type");
              __publicField(this, "init", async () => {
                this.questions = [];
                this.parseHtml();
                if (this.questions.length) {
                  addLog({
                    value: `成功解析到${this.questions.length}个题目`,
                    type: "success"
                  });
                  for (const [index, question] of this.questions.entries()) {
                    try {
                      const resp = await simulateRequest(
                        configStore.url,
                        question,
                        _unsafeWindow$1,
                        configStore.key
                      );
                      const { answer, count } = resp;
                      question.source = resp.source;
                      if (answer == null ? void 0 : answer.length) {
                        question.answer = answer;
                        this.fillQuestion(question);
                        addLog({
                          value: `第${index + 1}道题、搜索成功，剩余次数：${count}`,
                          type: "success"
                        });
                        this.correctNum += 1;
                      } else {
                        addLog({
                          value: `第${index + 1}道题、题库为空`,
                          type: "warning"
                        });
                      }
                      userInfoStore.questionList = [question];
                    } catch (error) {
                      addLog({
                        value: `第${index + 1}道题、搜索失败`,
                        type: "error"
                      });
                    } finally {
                      if (!this._document) {
                        let _a2 = this._document;
                        await _a2.querySelectorAll(".switch-btn-box > button")[1].click();
                      }
                      await sleep(2);
                    }
                  }
                }
                if (this.questions.length === 0) {
                  addLog({
                    value: `未解析到题目，请进入正确页面`,
                    type: "warning"
                  });
                }
                return Promise.resolve(this.correctNum / this.questions.length * 100);
              });
              __publicField(this, "parseHtml", () => {
                if (!this._document) return [];
                if (["zj"].includes(this.type)) {
                  const questionElements = this._document.querySelectorAll(".TiMu");
                  this.addQuestions(questionElements);
                } else if (["zy", "ks"].includes(this.type)) {
                  const questionElements = this._document.querySelectorAll(".questionLi");
                  this.addQuestions(questionElements);
                }
              });
              __publicField(this, "fillQuestion", (question) => {
                var _a2, _b;
                if (!this._window) return;
                if (question.type === "0" || question.type === "1") {
                  question.answer.forEach((answer) => {
                    for (const key in question.options) {
                      if (key === this.removeHtml(answer)) {
                        if (["zj", "zy"].includes(this.type)) {
                          const optionElement = question.options[key];
                          if (optionElement.getAttribute("aria-checked") === "true") {
                            return;
                          }
                          optionElement == null ? void 0 : optionElement.click();
                        } else if (["ks"].includes(this.type)) {
                          const optionElement = question.options[key];
                          if (optionElement.querySelector(".check_answer") || optionElement.querySelector(".check_answer_dx")) {
                            return;
                          }
                          optionElement == null ? void 0 : optionElement.click();
                        }
                      }
                    }
                  });
                } else if (question.type === "2") {
                  const textareaElements = question.element.querySelectorAll("textarea");
                  if (textareaElements.length === 0) return;
                  textareaElements.forEach((textareaElement, index) => {
                    try {
                      const ueditor = this._window.UE.getEditor(textareaElement.name);
                      ueditor.setContent(question.answer[index]);
                    } catch (e) {
                      textareaElement.value = "";
                    }
                  });
                } else if (question.type === "3") {
                  let answer = "true";
                  if (question.answer[0].match(/(^|,)(正确|是|对|√|T|ri|right|true)(,|$)/)) {
                    answer = "true";
                  } else if (question.answer[0].toString().match(/(^|,)(错误|否|错|×|F|wr|wrong|false)(,|$)/)) {
                    answer = "false";
                  }
                  const trueOrFalse = {
                    true: "对",
                    false: "错"
                  };
                  for (const key in question.options) {
                    if (["zj", "zy"].includes(this.type)) {
                      if ((_a2 = question.options[key].getAttribute("aria-label")) == null ? void 0 : _a2.includes(`${trueOrFalse[answer]}选择`)) {
                        if (question.options[key].getAttribute("aria-checked") === "true")
                          return;
                        (_b = question.options[key]) == null ? void 0 : _b.click();
                      }
                    } else if (["ks"].includes(this.type)) {
                      const optionElement = question.options[key].querySelector(
                        `span[data='${answer}']`
                      );
                      if (optionElement == null ? void 0 : optionElement.querySelector(".check_answer"))
                        return;
                      optionElement == null ? void 0 : optionElement.click();
                    }
                  }
                } else if (question.type === "4" || question.type === "6") {
                  const textareaElement = question.element.querySelector("textarea");
                  if (!textareaElement) return;
                  const ueditor = this._window.UE.getEditor(textareaElement.name);
                  ueditor.setContent(question.answer[0]);
                } else ;
              });
              this.type = type;
              if (iframe) {
                this._document = iframe.contentDocument;
                this._window = iframe.contentWindow;
              }
            }
            extractOptions(optionElements, optionSelector) {
              const optionsObject = {};
              const optionTexts = [];
              optionElements.forEach((optionElement) => {
                var _a2;
                const optionTextContent = this.removeHtml(
                  ((_a2 = optionElement.querySelector(optionSelector)) == null ? void 0 : _a2.innerHTML) || ""
                );
                optionsObject[optionTextContent] = optionElement;
                optionTexts.push(optionTextContent);
              });
              return [optionsObject, optionTexts];
            }
            addQuestions(questionElements) {
              questionElements.forEach((questionElement) => {
                var _a3, _b2;
                var _a2, _b, _c, _d;
                let questionTitle = "";
                let questionTypeText = "";
                let optionElements;
                let optionsObject = {};
                let optionTexts = [];
                if (["zy", "ks"].includes(this.type)) {
                  const titleElement = ((_a2 = questionElement == null ? void 0 : questionElement.querySelector("h3")) == null ? void 0 : _a2.innerHTML) || "";
                  const colorShallowElement = ((_b = questionElement.querySelector(".colorShallow")) == null ? void 0 : _b.outerHTML) || "";
                  if (["zy"].includes(this.type)) {
                    questionTypeText = (questionElement == null ? void 0 : questionElement.getAttribute("typename")) || "";
                  } else if (["ks"].includes(this.type)) {
                    questionTypeText = this.removeHtml(colorShallowElement).slice(1, 4) || "";
                  }
                  questionTitle = this.removeHtml(
                    titleElement.split(colorShallowElement || "")[1] || ""
                  );
                  optionElements = questionElement.querySelectorAll(".answerBg");
                  [optionsObject, optionTexts] = this.extractOptions(
                    optionElements,
                    ".answer_p"
                  );
                } else if (["zj"].includes(this.type)) {
                  questionTitle = this.removeHtml(
                    ((_c = questionElement.querySelector(".fontLabel")) == null ? void 0 : _c.innerHTML) || ""
                  );
                  questionTypeText = this.removeHtml(
                    ((_d = questionElement.querySelector(".newZy_TItle")) == null ? void 0 : _d.innerHTML) || ""
                  );
                  optionElements = questionElement.querySelectorAll(
                    '[class*="before-after"]'
                  );
                  [optionsObject, optionTexts] = this.extractOptions(
                    optionElements,
                    ".fl.after"
                  );
                }
                this.questions.push({
                  element: questionElement,
                  type: this.questionType[questionTypeText.replace("【", "").replace("】", "")] || "999",
                  title: this.clean(questionTitle),
                  optionsText: optionTexts,
                  options: optionsObject,
                  answer: [],
                  workType: this.type,
                  refer: (_b2 = (_a3 = this._window) == null ? void 0 : _a3.location) == null ? void 0 : _b2.href
                });
              });
            }
          }
          const processWork = async (iframe, iframeDocument, iframeWindow) => {
            addLog({
              value: `处理作业任务点`,
              type: "info"
            });
            addLog({
              value: `发现一个作业，正在解析`,
              type: "warning"
            });
            return new Promise(async (resolve2) => {
              var _a2;
              if (!iframeDocument) return resolve2();
              if (iframeDocument.documentElement.innerText.includes("已完成") || iframeDocument.documentElement.innerText.includes("待批阅")) {
                addLog({
                  value: `作业已经完成，跳过`,
                  type: "success"
                });
                return resolve2();
              }
              crackFont(iframeDocument);
              addLog({
                value: `题目列表获取成功`,
                type: "success"
              });
              await sleep(2);
              const correctRate = await ((_a2 = new CxQuestionHandler("zj", iframe)) == null ? void 0 : _a2.init());
              if (configStore.platformParams.cx.autoNext) {
                addLog({
                  value: `自动提交已开启，尝试提交`,
                  type: "warning"
                });
                if (correctRate < configStore.otherParams.rate) {
                  addLog({
                    value: `正确率小于${configStore.otherParams.rate}%，暂存`,
                    type: "error"
                  });
                  await iframeWindow.noSubmit();
                } else {
                  addLog({
                    value: `正确率大于${configStore.otherParams.rate}%，提交`,
                    type: "success"
                  });
                  await iframeWindow.btnBlueSubmit();
                  await sleep(configStore.otherParams.timeInterval / 2);
                  await iframeWindow.submitCheckTimes();
                  addLog({
                    value: `提交成功`,
                    type: "success"
                  });
                }
              } else {
                addLog({
                  value: `未开启自动提交，暂存`,
                  type: "warning"
                });
                await iframeWindow.noSubmit();
              }
              addLog({
                value: `作业已完成`,
                type: "success"
              });
              return resolve2();
            });
          };
          const getAllNestedIframes = (documentElement) => {
            const iframes = [];
            const scan = (doc2) => {
              const frames = doc2.querySelectorAll("iframe");
              frames.forEach((iframe) => {
                try {
                  iframes.push(iframe);
                  if (iframe.contentDocument) {
                    scan(iframe.contentDocument);
                  }
                } catch (e) {
                  console.warn("无法访问跨域 iframe:", iframe.src);
                }
              });
            };
            scan(documentElement);
            return iframes;
          };
          const watchIframe = (documentElement) => {
            const iframes = getAllNestedIframes(documentElement);
            iframes.reduce((promiseChain, iframe) => {
              return promiseChain.then(() => processIframe(iframe));
            }, Promise.resolve()).then(async () => {
              var _a2;
              addLog({
                value: `本页任务点已全部完成，正前往下一章节`,
                type: "success"
              });
              await sleep(2);
              if (configStore.platformParams.cx.autoNext) {
                const nextBtn = documentElement.querySelector("#prevNextFocusNext");
                if (!nextBtn || nextBtn.style.display === "none") {
                  addLog({
                    value: `已经到达最后一章节，无法跳转`,
                    type: "error"
                  });
                } else {
                  await sleep(2);
                  (_a2 = document == null ? void 0 : document.querySelector(".jb_btn.jb_btn_92.fr.fs14.nextChapter")) == null ? void 0 : _a2.click();
                }
              } else {
                addLog({
                  value: `已经关闭自动下一章节，在设置里可更改`,
                  type: "error"
                });
              }
            });
          };
          const processIframeTask = () => {
            const documentElement = document.documentElement;
            const iframe = documentElement.querySelector("iframe");
            if (!iframe) {
              console.warn("No iframe found.");
              return;
            }
            watchIframe(documentElement);
            iframe.addEventListener("load", function() {
              watchIframe(documentElement);
            });
          };
          const setupInterceptor = () => {
            let currentUrl2 = window.location.href;
            setInterval(() => {
              if (currentUrl2 !== window.location.href) {
                currentUrl2 = window.location.href;
                processIframeTask();
              }
            }, 5e3);
          };
          const useCxChapterFunc = () => {
            const init = () => {
              if (!window.location.href.includes("&mooc2=1")) {
                window.location.href = currentUrl + "&mooc2=1";
              }
              addLog({
                value: `检测到用户进入到章节学习页面`,
                type: "success"
              });
              addLog({
                value: `正在解析任务点，请稍等（如长时间没有反应，请刷新页面）`,
                type: "warning"
              });
            };
            init();
            processIframeTask();
            setupInterceptor();
          };
          const useCxWorkLogicFunc = async () => {
            addLog({
              value: `进入新版作业页面，开始准备答题`,
              type: "success"
            });
            addLog({
              value: `正在解析题目, 请等待`,
              type: "warning"
            });
            await new CxQuestionHandler("zy").init();
          };
          const useCxExamLogicFunc = async () => {
            addLog({
              value: `进入新版考试页面，开始准备答题`,
              type: "warning"
            });
            addLog({
              value: `正在解析题目, 请等待`,
              type: "warning"
            });
            await new CxQuestionHandler("ks").init();
            if (configStore.platformParams.cx.autoNext) {
              addLog({
                value: `自动切换已开启，正在前往下一题`,
                type: "warning"
              });
              await sleep(configStore.otherParams.timeInterval);
              _unsafeWindow$1.getTheNextQuestion(1);
            } else {
              addLog({
                value: `已经关闭自动切换，在设置里可更改`,
                type: "warning"
              });
            }
          };
          const getFunc = () => {
            const urlLogicPairs = [
              { keyword: "/mycourse/studentstudy", logic: useCxChapterFunc },
              { keyword: "/mooc2/work/dowork", logic: useCxWorkLogicFunc },
              { keyword: "/exam-ans/exam", logic: useCxExamLogicFunc },
              { keyword: "/exam-ans/mooc2/exam/preview", logic: useCxExamLogicFunc },
              {
                keyword: "mycourse/stu?courseid",
                logic: () => {
                  addLog({
                    value: `该页面无任务，请进入章节或答题页面使用`,
                    type: "error"
                  });
                }
              }
              // { keyword: '/stuExamWeb.html', logic: useZhsAnswerLogicFunc },
            ];
            const executeLogicByUrl = () => {
              for (const { keyword, logic } of urlLogicPairs) {
                if (window.location.href.includes(keyword)) {
                  logic();
                  configStore.isShow = true;
                  return;
                }
              }
              configStore.isShow = false;
            };
            executeLogicByUrl();
          };
          const validateKey = () => {
            if (!configStore.key) {
              addLog({
                value: `请先输入卡密`,
                type: "warning"
              });
              return;
            }
            userInfoStore.key = configStore.key;
            addLog({
              value: `验证成功`,
              type: "success"
            });
          };
          const clearKey = () => {
            userInfoStore.key = null;
          };
          onMounted(() => {
            userInfoStore.questionList = [];
            addLog({
              value: `请不要多个脚本同时使用，会有脚本冲突问题`,
              type: "warning"
            });
            addLog({
              value: `如果脚本出现异常，请用谷歌、火狐等浏览器`,
              type: "warning"
            });
            addLog({
              value: `脚本加载成功，正在解析网页`,
              type: "success"
            });
            getFunc();
          });
          return (_ctx, _cache) => {
            const _component_el_icon = ElIcon;
            const _component_el_input = ElInput;
            const _component_el_table_column = ElTableColumn;
            const _component_el_table = ElTable;
            const _component_el_switch = ElSwitch;
            const _component_el_input_number = ElInputNumber;
            const _component_el_alert = ElAlert;
            return unref(configStore).isShow ? (openBlock(), createBlock(DraggableDialog, {
              key: 0,
              boundary: true,
              axis: "both"
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(tabBars), (tab) => {
                    return openBlock(), createElementBlock("div", {
                      key: tab.value,
                      size: unref(configStore).sizes,
                      onClick: ($event) => unref(configStore).activeTab = tab.value,
                      class: normalizeClass(["tab-bar-item", [unref(configStore).activeTab === tab.value ? "active" : ""]])
                    }, [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          tab.value === "key" ? (openBlock(), createBlock(unref(key_default), { key: 0 })) : createCommentVNode("", true),
                          tab.value === "settings" ? (openBlock(), createBlock(unref(tools_default), { key: 1 })) : createCommentVNode("", true),
                          tab.value === "help" ? (openBlock(), createBlock(unref(question_filled_default), { key: 2 })) : createCommentVNode("", true),
                          tab.value === "protocol" ? (openBlock(), createBlock(unref(warning_default), { key: 3 })) : createCommentVNode("", true)
                        ]),
                        _: 2
                      }, 1024),
                      createTextVNode(" " + toDisplayString(tab.label), 1)
                    ], 10, _hoisted_2);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_3, [
                  unref(configStore).activeTab === "key" ? (openBlock(), createElementBlock("div", _hoisted_4, [
                    createBaseVNode("div", _hoisted_5, [
                      createVNode(_component_el_icon, {
                        size: 18,
                        color: "#4a90e2"
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(key_default))
                        ]),
                        _: 1
                      }),
                      _cache[4] || (_cache[4] = createTextVNode("授权管理 "))
                    ]),
                    createVNode(_component_el_input, {
                      modelValue: unref(configStore).key,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(configStore).key = $event),
                      modelModifiers: { trim: true },
                      style: { "width": "100%" },
                      placeholder: "输入卡密、获取方式在帮助中查看",
                      clearable: "",
                      onClear: clearKey
                    }, null, 8, ["modelValue"]),
                    createBaseVNode("div", {
                      class: "start-parse",
                      onClick: validateKey
                    }, "验证卡密"),
                    createBaseVNode("div", _hoisted_6, [
                      createBaseVNode("div", _hoisted_7, [
                        createVNode(_component_el_icon, {
                          size: 18,
                          color: "#4a90e2"
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(list_default))
                          ]),
                          _: 1
                        }),
                        _cache[5] || (_cache[5] = createTextVNode("题目列表 "))
                      ]),
                      createVNode(_component_el_table, {
                        data: unref(userInfoStore).questionList,
                        style: { "width": "100%" },
                        "empty-text": "暂无题目"
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createElementBlock(Fragment, null, renderList(column, (c2) => {
                            return createVNode(_component_el_table_column, mergeProps({
                              key: c2,
                              ref_for: true
                            }, c2), null, 16);
                          }), 64))
                        ]),
                        _: 1
                      }, 8, ["data"])
                    ])
                  ])) : createCommentVNode("", true),
                  unref(configStore).activeTab === "settings" ? (openBlock(), createElementBlock("div", _hoisted_8, [
                    createBaseVNode("div", _hoisted_9, [
                      createVNode(_component_el_icon, {
                        size: 18,
                        color: "#4a90e2"
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(operation_default))
                        ]),
                        _: 1
                      }),
                      _cache[6] || (_cache[6] = createTextVNode("功能配置 "))
                    ]),
                    createBaseVNode("div", _hoisted_10, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(settings), (setting) => {
                        return openBlock(), createElementBlock("div", {
                          class: "settings-section",
                          key: setting.value
                        }, [
                          createBaseVNode("div", _hoisted_11, [
                            createBaseVNode("span", _hoisted_12, toDisplayString(setting.name), 1),
                            createBaseVNode("span", _hoisted_13, toDisplayString(setting.desc), 1)
                          ]),
                          setting.value === "answeringMode" ? (openBlock(), createBlock(_component_el_switch, {
                            key: 0,
                            class: "settings-switch",
                            modelValue: unref(configStore).platformParams.cx.answeringMode,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(configStore).platformParams.cx.answeringMode = $event),
                            "inline-prompt": ""
                          }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                          setting.value === "autoNext" ? (openBlock(), createBlock(_component_el_switch, {
                            key: 1,
                            class: "settings-switch",
                            modelValue: unref(configStore).platformParams.cx.autoNext,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(configStore).platformParams.cx.autoNext = $event),
                            "inline-prompt": ""
                          }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                          setting.value === "rate" ? (openBlock(), createBlock(_component_el_input_number, mergeProps({
                            key: 2,
                            class: "settings-switch",
                            modelValue: unref(configStore).otherParams.rate,
                            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(configStore).otherParams.rate = $event),
                            ref_for: true
                          }, { inputNumberAttr: unref(inputNumberAttr) }, {
                            min: 60,
                            max: 90
                          }), null, 16, ["modelValue"])) : createCommentVNode("", true)
                        ]);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true),
                  unref(configStore).activeTab === "help" ? (openBlock(), createElementBlock("div", _hoisted_14, [
                    createBaseVNode("div", _hoisted_15, [
                      createVNode(_component_el_icon, {
                        size: 18,
                        color: "#4a90e2"
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(notebook_default))
                        ]),
                        _: 1
                      }),
                      _cache[7] || (_cache[7] = createTextVNode("使用指南 "))
                    ]),
                    createBaseVNode("div", _hoisted_16, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(guide), (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: item.index,
                          class: "guide-content-item"
                        }, [
                          createBaseVNode("div", _hoisted_17, toDisplayString(item.index), 1),
                          createBaseVNode("div", _hoisted_18, toDisplayString(item.content), 1)
                        ]);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true),
                  unref(configStore).activeTab === "protocol" ? (openBlock(), createElementBlock("div", _hoisted_19, [
                    createBaseVNode("div", _hoisted_20, [
                      createVNode(_component_el_icon, {
                        size: 18,
                        color: "#f56c6c"
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(warning_default))
                        ]),
                        _: 1
                      }),
                      _cache[8] || (_cache[8] = createTextVNode("协议 "))
                    ]),
                    createBaseVNode("div", _hoisted_21, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(protocol), (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: item.index,
                          class: "guide-content-item"
                        }, [
                          createBaseVNode("div", _hoisted_22, toDisplayString(item.index), 1),
                          createBaseVNode("div", _hoisted_23, toDisplayString(item.content), 1)
                        ]);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true),
                  unref(configStore).activeTab !== "protocol" ? (openBlock(), createElementBlock("div", _hoisted_24, [
                    createBaseVNode("div", _hoisted_25, [
                      createVNode(_component_el_icon, { size: 18 }, {
                        default: withCtx(() => [
                          createVNode(unref(comment_default))
                        ]),
                        _: 1
                      }),
                      _cache[9] || (_cache[9] = createTextVNode(" 操作反馈 "))
                    ]),
                    createBaseVNode("div", _hoisted_26, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(configStore).logData, (item) => {
                        return openBlock(), createBlock(_component_el_alert, {
                          key: item.time,
                          title: item.value,
                          type: item.type,
                          "show-icon": "",
                          closable: false,
                          style: { "margin-bottom": "8px", "border-radius": "4px" }
                        }, {
                          title: withCtx(() => [
                            createBaseVNode("span", _hoisted_27, toDisplayString(item.value), 1)
                          ]),
                          _: 2
                        }, 1032, ["title", "type"]);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true)
                ])
              ]),
              _: 1
            })) : createCommentVNode("", true);
          };
        }
      };
      const HomeIndex = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-7271a377"]]);
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createBlock(HomeIndex);
          };
        }
      });
      const initApp = () => {
        const app = createApp(_sfc_main);
        app.use(pinia);
        app.mount(
          (() => {
            const app2 = document.createElement("div");
            app2.className = "script-div";
            document.body.append(app2);
            return app2;
          })()
        );
      };
      window.addEventListener("load", initApp);
    }
  });
  require_main_001();

})();