// ==UserScript==
// @name         Symfony 翻译文档 templates.html
// @namespace    fireloong
// @version      0.1.5
// @description  翻译文档
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/templates.html
// @match        https://symfony.com/doc/6.4/templates.html
// @match        https://symfony.com/doc/7.1/templates.html
// @match        https://symfony.com/doc/7.2/templates.html
// @match        https://symfony.com/doc/current/templates.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/488393/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20templateshtml.user.js
// @updateURL https://update.greasyfork.org/scripts/488393/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20templateshtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        'Twig Templating Language': 'Twig 模板语言',
        'Twig Configuration': 'Twig 配置',
        'Creating Templates': '创建模板',
        'Template Naming':'模板命名',
        'Template Location': '模板位置',
        'Template Variables': '模板变量',
        'Linking to Pages': '链接到页面',
        'Linking to CSS, JavaScript and Image Assets': '链接到 CSS、JavaScript 和图像资源',
        'Build, Versioning & More Advanced CSS, JavaScript and Image Handling': '构建，版本控制和更先进的 CSS, JavaScript 和图像处理',
        'The App Global Variable': '应用全局变量',
        'Global Variables': '全局变量',
        'Twig Components': 'Twig 组件',
        'Rendering Templates': '渲染模板',
        'Rendering a Template in Controllers': '在控制器中渲染模板',
        'Rendering a Template in Services': '在服务中渲染模板',
        'Rendering a Template in Emails': '在电子邮件中呈现模板',
        'Rendering a Template Directly from a Route': '直接从路由渲染模板',
        'Checking if a Template Exists':'检查模板是否存在',
        'Debugging Templates': '调试模板',
        'Linting Twig Templates': '检查 Twig 模板',
        'Inspecting Twig Information': '检查 Twig 信息',
        'Reusing Template Contents': '重复使用模板内容',
        'Including Templates': '引入模板',
        'Embedding Controllers': '嵌入控制器',
        'How to Embed Asynchronous Content with hinclude.js': '如何使用 hinclude.js 嵌入异步内容',
        'Template Inheritance and Layouts': '模板继承和布局',
        'Output Escaping': '输出转义',
        'Template Namespaces': '模板命名空间',
        'Writing a Twig Extension': '编写 Twig 扩展',
        'Create the Extension Class': '创建扩展类',
        'Creating Lazy-Loaded Twig Extensions': '创建懒加载的 Twig 扩展',
        '\n        \n                    Creating and Using Templates\n        \n            ': '创建和使用模版',
        "A template is the best way to organize and render HTML from inside your application,\nwhether you need to render HTML from a controller or generate\nthe contents of an email. Templates in Symfony are created with\nTwig: a flexible, fast, and secure template engine.": '模板是从应用程序内部组织和呈现 HTML 的最佳方式， 无论您是需要从<a class="reference internal" href="controller.html">控制器</a>渲染 HTML 还是生成<a href="mailer.html" class="reference internal">电子邮件的内容</a>。Symfony中的模板是用 Twig：一个灵活、快速且安全的模板引擎。',
        "The Twig templating language allows you to write concise, readable templates\nthat are more friendly to web designers and, in several ways, more powerful than\nPHP templates. Take a look at the following Twig template example. Even if it's\nthe first time you see Twig, you probably understand most of it:":'<a href="https://twig.symfony.com" class="reference external">Twig</a> 模板语言允许您编写简洁、可读的模板，这些模板对网络设计师更友好，而且在某些方面比 PHP 模板更强大。看看下面的 Twig 模板示例。即使这是你第一次看到 Twig，你也可能了解其中的大部分内容：',
        'Twig syntax is based on these three constructs:': 'Twig 语法基于以下三个结构：',
        '{{ ... }}, used to display the content of a variable or the result of\nevaluating an expression;': '<code translate="no" class="notranslate">{{ ... }}</code>，用于显示变量的内容或表达式的求值结果；',
        '{% ... %}, used to run some logic, such as a conditional or a loop;': '<code translate="no" class="notranslate">{% ... %}</code>，用于运行一些逻辑，如条件或循环；',
        '{# ... #}, used to add comments to the template (unlike HTML comments,\nthese comments are not included in the rendered page).': '<code translate="no" class="notranslate">{# ... #}</code>，用于向模板添加注释（与HTML注释不同，这些注释不包括在呈现的页面中）。',
        "You can't run PHP code inside Twig templates, but Twig provides utilities to\nrun some logic in the templates. For example, filters modify content before\nbeing rendered, like the upper filter to uppercase contents:": '您不能在 Twig 模板中运行 PHP 代码，但 Twig 提供了在模板中运行一些逻辑的实用程序。例如，<strong>filters</strong> 在呈现内容之前会对内容进行修改，就像上面的 <code translate="no" class="notranslate">upper</code> 过滤器对大写内容所做的那样：',
        'Twig comes with a long list of tags, filters and functions that are\navailable by default. In Symfony applications you can also use these\nTwig filters and functions defined by Symfony\nand you can create your own Twig filters and functions.':'Twig 提供了一长串默认可用的<a href="https://twig.symfony.com/doc/3.x/tags/index.html" class="reference external">标签</a>、<a href="https://twig.symfony.com/doc/3.x/filters/index.html" class="reference external">过滤器</a>和<a href="https://twig.symfony.com/doc/3.x/functions/index.html" class="reference external">函数</a>。在 Symfony 应用程序中，还可以使用 <a href="reference/twig_reference.html" class="reference internal">Symfony 定义的 Twig 过滤器和函数</a>，还可以<a href="templates.html#templates-twig-extension" class="reference internal">创建自己的 Twig 筛选器和函数</a>。',
        'Twig is fast in the prod environment\n(because templates are compiled into PHP and cached automatically), but\nconvenient to use in the dev environment (because templates are recompiled\nautomatically when you change them).': 'Twig 在 <code translate="no" class="notranslate">prod</code> <a href="configuration.html#configuration-environments" class="reference internal">环境</a>中速度很快（因为模板被编译到 PHP 中并自动缓存），但在 <code translate="no" class="notranslate">dev</a> 环境中使用很方便（因为更改模板时会自动重新编译）。',
        'Twig has several configuration options to define things like the format used\nto display numbers and dates, the template caching, etc. Read the\nTwig configuration reference to learn about them.': 'Twig 有几个配置选项来定义诸如用于显示数字和日期的格式、模板缓存等内容。阅读 <a href="reference/configuration/twig.html" class="reference internal">Twig 配置参考</a>以了解它们。',
        'Before explaining in detail how to create and render templates, look at the\nfollowing example for a quick overview of the whole process. First, you need to\ncreate a new file in the templates/ directory to store the template contents:': '在详细解释如何创建和渲染模板之前，请先看下面的示例以快速了解整个过程。首先，您需要在 <code translate="no" class="notranslate">templates/</code> 目录中创建一个新文件来存储模板内容：',
        'Then, create a controller that renders this template and\npasses to it the needed variables:': '然后，创建一个<a href="controller.html" class="reference internal">控制器</a>来渲染此模板并将所需的变量传递给它：',
        'Symfony recommends the following for template names:': 'Symfony 建议使用以下模板名称：',
        'Use snake case for filenames and directories (e.g. blog_posts.html.twig,\nadmin/default_theme/blog/index.html.twig, etc.);': '文件名和目录使用蛇形命名法(snake case)（例如 <code translate="no" class="notranslate">blog_posts.html.twig</code>、<code translate="no" class="notranslate">admin/default_theme/blog/index.html.twig</code> 等）；',
        'Define two extensions for filenames (e.g. index.html.twig or\nblog_posts.xml.twig) being the first extension (html, xml, etc.)\nthe final format that the template will generate.': '为文件名定义两个扩展名（例如 <code translate="no" class="notranslate">index.html.twig</code> 或 <code translate="no" class="notranslate">blog_posts.xml.twig</code>），作为第一个扩展（<code translate="no" class="notranslate">html</code>、<code translate="no" class="notranslate">xml</code> 等），即模板将生成的最终格式。',
        "Although templates usually generate HTML contents, they can generate any\ntext-based format. That's why the two-extension convention simplifies the way\ntemplates are created and rendered for multiple formats.": '尽管模板通常生成HTML内容，但它们可以生成任何基于文本的格式。这就是为什么两个扩展约定简化了为多种格式创建和渲染模板的方式。',
         'Templates are stored by default in the templates/ directory. When a service\nor controller renders the product/index.html.twig template, they are actually\nreferring to the <your-project>/templates/product/index.html.twig file.': '默认情况下，模板存储在 <code translate="no" class="notranslate">templates/</code> 目录中。当服务或控制器渲染 <code translate="no" class="notranslate">product/index.html.twig</code> 模板时，它们实际上正在转换到 <code translate="no" class="notranslate">&lt;your-project&gt;/templates/product/index.html.twig</code> 文件。',
        'The default templates directory is configurable with the\ntwig.default_path option and you can add more\ntemplate directories as explained later in this article.':'默认模板目录可通过 <a href="reference/configuration/twig.html#config-twig-default-path" class="reference internal">twig.default_path</a> 选项进行配置，您可以添加更多模板目录，如本文<a href="templates.html#templates-namespaces" class="reference internal">稍后所述</a>。',
        "A common need for templates is to print the values stored in the templates\npassed from the controller or service. Variables usually store objects and\narrays instead of strings, numbers and boolean values. That's why Twig provides\nquick access to complex PHP variables. Consider the following template:": '对模板的一个常见需求是打印从控制器或服务传递的模板中存储的值。变量通常存储对象和数组，而不是字符串、数字和布尔值。这就是为什么 Twig 提供了对复杂 PHP 变量的快速访问。考虑以下模板：',
        "The user.name notation means that you want to display some information\n(name) stored in a variable (user). Is user an array or an object?\nIs name a property or a method? In Twig this doesn't matter.": '<code translate="no" class="notranslate">user.name</code> 表示希望显示存储在变量（<code translate="no" class="notranslate">user</code>）中的一些信息（<code translate="no" class="notranslate">name</code>）。<code translate="no" class="notranslate">user</code> 是数组还是对象？<code translate="no" class="notranslate">name</code> 是属性还是方法？在 Twig，这并不重要。',
        'When using the foo.bar notation, Twig tries to get the value of the variable\nin the following order:':'当使用 <code translate="no" class="notranslate">foo.bar</code> 表示法时，Twig 尝试按以下顺序获取变量的值：',
        "$foo['bar'] (array and element);": '<code translate="no" class="notranslate">$foo[\'bar\']</code> （数组元素）；',
        '$foo->bar (object and public property);': '<code translate="no" class="notranslate">$foo-&gt;bar</code> （对象公共属性）；',
        '$foo->bar() (object and public method);':'<code translate="no" class="notranslate">$foo-&gt;bar()</code>（对象公共方法）；',
        '$foo->getBar() (object and getter method);': '<code translate="no" class="notranslate">$foo-&gt;getBar()</code>（对象 <em>getter</em> 方法）；',
        '$foo->isBar() (object and isser method);':'<code translate="no" class="notranslate">$foo-&gt;isBar()</code>（对象 <em>isser</em> 方法）；',
        '$foo->hasBar() (object and hasser method);': '<code translate="no" class="notranslate">$foo-&gt;hasBar()</code>（对象 <em>hasser</em> 方法）；',
         'If none of the above exists, use null (or throw a Twig\\Error\\RuntimeError\nexception if the strict_variables\noption is enabled).': '如果以上都不存在，使用 <code translate="no" class="notranslate">null</code>（如果启用了 <a href="reference/configuration/twig.html#config-twig-strict-variables" class="reference internal">strict_variables</a> 选项，则抛出 <code translate="no" class="notranslate">Twig\\Error\\RuntimeError</code> 异常）。',
        'This allows to evolve your application code without having to change the\ntemplate code (you can start with array variables for the application proof of\nconcept, then move to objects with methods, etc.)': '这允许在不改变模板代码的情况下发展您的应用程序代码（您可以从应用程序概念验证的数组变量开始，然后转移到具有方法的对象等。)',
        'Instead of writing the link URLs by hand, use the path() function to\ngenerate URLs based on the routing configuration.':'使用 <code translate="no" class="notranslate">path()</code> 函数根据<a href="routing.html#routing-creating-routes" class="reference internal">路由配置</a>生成 URL，而不是手动编写链接URL。',
        "Later, if you want to modify the URL of a particular page, all you'll need to do\nis change the routing configuration: the templates will automatically generate\nthe new URL.": '稍后，如果想修改特定页面的 URL，所需要做的就是更改路由配置：模板将自动生成新的 URL。',
        'Consider the following routing configuration:': '请考虑以下路由配置：',
        'Use the path() Twig function to link to these pages and pass the route name\nas the first argument and the route parameters as the optional second argument:': '使用 <code translate="no" class="notranslate">path()</code> Twig 函数链接到这些页面，并将路由名称作为第一个参数，将路由参数作为可选的第二个参数：',
        'The path() function generates relative URLs. If you need to generate\nabsolute URLs (for example when rendering templates for emails or RSS feeds),\nuse the url() function, which takes the same arguments as path()\n(e.g. <a href="{{ url(\'blog_index\') }}"> ... </a>).': '<code translate="no" class="notranslate">path()</code> 函数生成相对 URL。如果需要生成绝对 URL（例如，在为电子邮件或 RSS 提要渲染模板时），请使用 <code translate="no" class="notranslate">url()</code> 函数，该函数采用与 <code translate="no" class="notranslate">path()</code> 相同的参数（例如<code translate="no" class="notranslate">&lt;a href="{{ url(\'blog_index\') }}"&gt; ... &lt;/a&gt;</code>）',
        'If a template needs to link to a static asset (e.g. an image), Symfony provides\nan asset() Twig function to help generate that URL. First, install the\nasset package:': '如果模板需要链接到静态资源（例如图像），Symfony 会提供 <code translate="no" class="notranslate">asset()</code> Twig 函数来帮助生成该 URL。首先，安装 <code translate="no" class="notranslate">asset</code> 包：',
        'You can now use the asset() function:': '现在可以使用 <code translate="no" class="notranslate">asset()</code> 函数：',
        "The asset() function's main purpose is to make your application more portable.\nIf your application lives at the root of your host (e.g. https://example.com),\nthen the rendered path should be /images/logo.png. But if your application\nlives in a subdirectory (e.g. https://example.com/my_app), each asset path\nshould render with the subdirectory (e.g. /my_app/images/logo.png). The\nasset() function takes care of this by determining how your application is\nbeing used and generating the correct paths accordingly.":'<code translate="no" class="notranslate">asset()</code> 函数的主要目的是使应用程序更易于移植。如果您的应用程序位于主机的根目录（例如 <code translate="no" class="notranslate">https://example.com</code>)，则渲染的路径应该是 <code translate="no" class="notranslate">/images/logo.png</code>。但是，如果您的应用程序位于子目录中（例如 <code translate="no" class="notranslate">https://example.com/my_app</code>)，每个资源路径都应该使用子目录（例如 <code translate="no" class="notranslate">/my_app/images/logo.png</code>）进行渲染。<code translate="no" class="notranslate">asset()</code> 函数通过确定应用程序的使用方式并相应地生成正确的路径来处理这一问题。',
        'The asset() function supports various cache busting techniques via the\nversion,\nversion_format, and\njson_manifest_path configuration options.':'<code translate="no" class="notranslate">asset()</code> 函数通过 <a href="reference/configuration/framework.html#reference-framework-assets-version" class="reference internal">version</a>、 <a href="reference/configuration/framework.html#reference-assets-version-format" class="reference internal">version_format</a> 和 <a href="reference/configuration/framework.html#reference-assets-json-manifest-path" class="reference internal">json_manifest_path</a> 配置选项支持各种缓存破坏技术。',
        'If you need absolute URLs for assets, use the absolute_url() Twig function\nas follows:': '如果需要资源的绝对 URL，请使用 <code translate="no" class="notranslate">absolute_url()</code> Twig 函数，如下所示：',
        "For help building, versioning and minifying your JavaScript and\nCSS assets in a modern way, read about Symfony's Webpack Encore.":'有关以现代方式构建、版本控制和缩小 JavaScript 和 CSS 资产的帮助，请阅读 <a href="frontend.html" class="reference internal">Symfony 的 Webpack Encore</a>。',
        'Symfony creates a context object that is injected into every Twig template\nautomatically as a variable called app. It provides access to some\napplication information:': 'Symfony 创建了一个上下文对象，该对象作为一个名为 <code translate="no" class="notranslate">app</code> 的变量自动注入到每个 Twig 模板中。它提供了对一些应用程序信息的访问：',
        'The app variable (which is an instance of AppVariable)\ngives you access to these variables:': '<code translate="no" class="notranslate">app</code> 变量（它是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bridge/Twig/AppVariable.php" class="reference external" title="Symfony\Bridge\Twig\AppVariable" rel="external noopener noreferrer" target="_blank">AppVariable</a> 的一个实例）允许您访问这些变量：',
         '\n                            The current user object or null if the user\nis not authenticated.\n                    ': '<a href="security.html#create-user-class" class="reference internal">当前用户对象</a>或 <code translate="no" class="notranslate">null</code>（如果用户未通过身份验证）。',
        '\n                            The Request object that stores\nthe current request data (depending on your\napplication, this can be a sub-request\nor a regular request).\n                    ':'存储当前<a href="components/http_foundation.html#accessing-request-data" class="reference internal">请求数据</a>的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Request.php" class="reference external" title="Symfony\Component\HttpFoundation\Request" rel="external noopener noreferrer" target="_blank">Request</a> 对象（根据您的应用程序，这可以是<a href="components/http_kernel.html#http-kernel-sub-requests" class="reference internal">子请求</a>或常规请求）。',
        "\n                            The Session object that\nrepresents the current user's session or null if there is none.\n                    ": '表示当前<a href="session.html" class="reference internal">用户会话</a>的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Session/Session.php" class="reference external" title="Symfony\Component\HttpFoundation\Session\Session" rel="external noopener noreferrer" target="_blank">Session</a> 对象，如果没有，则为 <code translate="no" class="notranslate">null</code>。',
        "\n                            An array of all the flash messages stored in the session.\nYou can also get only the messages of some type (e.g. app.flashes('notice')).\n                    ": '存储在会话中的所有<a href="session.html#flash-messages" class="reference internal">闪存消息</a>的数组。您也只能获得某些类型的消息（例如 <code translate="no" class="notranslate">app.flashes(\'notice\')</code>）。',
        '\n                            The name of the current configuration environment\n(dev, prod, etc).\n                    ': '当前配置环境的名称（<code translate="no" class="notranslate">dev</code>、<code translate="no" class="notranslate">prod</code>等）。',
        '\n                            True if in debug mode. False otherwise.\n                    ': '如果处于<a href="configuration/front_controllers_and_kernel.html#debug-mode" class="reference internal">调试模式</a>，则为 True。否则为 False。',
        '\n                            A TokenInterface\nobject representing the security token.\n                    ': '表示安全令牌的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Authentication/Token/TokenInterface.php" class="reference external" title="Symfony\Component\Security\Core\Authentication\Token\TokenInterface" rel="external noopener noreferrer" target="_blank">TokenInterface</a> 对象。',
        "\n                            The name of the route associated with the current request or null if no\nrequest is available (equivalent to app.request.attributes.get('_route'))\n                    ": '与当前请求关联的路由名称，如果没有可用的请求，则为 <code translate="no" class="notranslate">null</code>（相当于 <code translate="no" class="notranslate">app.request.attributes.get(\'_route\')</code>）',
        "\n                            An array with the parameters passed to the route of the current request or an\nempty array if no request is available (equivalent to app.request.attributes.get('_route_params'))\n                    ": '具有传递到当前请求路由参数的数组，如果没有可用的请求，则为空数组（相当于 <code translate="no" class="notranslate">app.request.attributes.get(\'_route_params\')</code>）',
        '\n                            The locale used in the current locale switcher context.\n                    ': '当前<a href="translation.html#locale-switcher" class="reference internal">区域设置切换器</a>上下文中使用的区域设置。',
        '\n                            The locales enabled in the application.\n                    ': '应用程序中启用的区域设置。',
        'The app.current_route and app.current_route_parameters variables\nwere introduced in Symfony 6.2.': '在 Symfony 6.2 中引入了 <code translate="no" class="notranslate">app.current_route</code> 和 <code translate="no" class="notranslate">app.current_route_parameters</code> 变量。',
         'The app.locale variable was introduced in Symfony 6.3.': '在 Symfony 6.3 中引入了 <code translate="no" class="notranslate">app.locale</code> 变量。',
        'The app.enabled_locales variable was introduced in Symfony 6.4.': '在Symfony 6.4中引入 <code translate="no" class="notranslate">app.enabled_locales</code> 变量。',
        'In addition to the global app variable injected by Symfony, you can also\ninject variables automatically to all Twig templates as explained in the next\nsection.': '除了 Symfony 注入的全局 <code translate="no" class="notranslate">app</code> 变量外，您还可以将变量自动注入所有 Twig 模板，如下一节所述。',
        'Twig allows you to automatically inject one or more variables into all\ntemplates. These global variables are defined in the twig.globals option\ninside the main Twig configuration file:': 'Twig 允许您自动将一个或多个变量注入到所有模板中。这些全局变量在主 Twig 配置文件内的 <code translate="no" class="notranslate">twig.globals</code> 选项中定义：',
        'Now, the variable ga_tracking is available in all Twig templates, so you\ncan use it without having to pass it explicitly from the controller or service\nthat renders the template:': '现在，变量 <code translate="no" class="notranslate">ga_tracking</code> 在所有 Twig 模板中都可用，因此您可以使用它，而不必从渲染模板的控制器或服务显式传递它：',
        'In addition to static values, Twig global variables can also reference services\nfrom the service container. The main drawback is\nthat these services are not loaded lazily. In other words, as soon as Twig is\nloaded, your service is instantiated, even if you never use that global\nvariable.': '除了静态值，Twig 全局变量还可以引用<a href="service_container.html" class="reference internal">服务容器</a>中的服务。主要的缺点是这些服务不会延迟加载。换句话说，一旦加载了 Twig，您的服务就会被实例化，即使您从未使用过该全局变量。',
        'To define a service as a global Twig variable, prefix the service ID string\nwith the @ character, which is the usual syntax to refer to services\nin container parameters:': '要将服务定义为全局 Twig 变量，请在服务 ID 字符串前面加上 <code translate="no" class="notranslate">@</code> 字符，这是<a href="service_container.html#service-container-parameters" class="reference internal">引用容器参数中服务</a>的常用语法：',
        'Now you can use the uuid variable in any Twig template to access to the\nUuidGenerator service:': '现在，您可以在任何 Twig 模板中使用 <code translate="no" class="notranslate">uuid</code> 变量来访问 <code translate="no" class="notranslate">UuidGenerator</code> 服务：',
        'Twig components are an alternative way to render templates, where each template\nis bound to a "component class". This makes it easier to render and re-use\nsmall template "units" - like an alert, markup for a modal, or a category sidebar.': 'Twig 组件是渲染模板的另一种方式，其中每个模板都绑定到一个“组件类”。这使得渲染和重用小模板“单元”变得更容易，比如警报、模态标记或类别侧边栏。',
        'For more information, see UX Twig Component.': '有关更多信息，请参见 <a href="https://symfony.com/bundles/ux-twig-component/current/index.html" class="reference external">UX Twig 组件</a>。',
        'Twig components also have one other superpower: they can become "live", where\nthey automatically update (via Ajax) as the user interacts with them. For example,\nwhen your user types into a box, your Twig component will re-render via Ajax to\nshow a list of results!': 'Twig 组件还有另一个超能力：它们可以成为“实时”组件，当用户与它们交互时，它们会自动更新（通过Ajax）。例如，当用户在框中键入内容时，Twig 组件将通过 Ajax 重新渲染，以显示结果列表！',
        'To learn more, see UX Live Component.': '要了解更多信息，请参阅 <a href="https://symfony.com/bundles/ux-live-component/current/index.html" class="reference external">UX Live Component</a>。',
        'If your controller extends from the AbstractController,\nuse the render() helper:': '如果控制器从 <a href="controller.html#the-base-controller-class-services" class="reference internal">AbstractController</a> 扩展，请使用 <code translate="no" class="notranslate">render()</code> 辅助对象：',
        "If your controller does not extend from AbstractController, you'll need to\nfetch services in your controller and\nuse the render() method of the twig service.": '如果您的控制器不是从 <code translate="no" class="notranslate">AbstractController</code> 扩展的，则需要<a href="controller.html#controller-accessing-services" class="reference internal">在控制器中获取服务</a>，并使用 <code translate="no" class="notranslate">twig</code> 服务的 <code translate="no" class="notranslate">render()</code> 方法。',
        'Another option is to use the #[Template()] attribute on the controller method\nto define the template to render:': '另一个选择是使用控制器方法上的 <code translate="no" class="notranslate">#[Template()]</code> 属性来定义要渲染的模板:',
        'The #[Template()] attribute was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">#[Template()]</code> 属性是在 Symfony 6.2 中引入的。',
        'The base AbstractController also provides the\nrenderBlock()\nand renderBlockView()\nmethods:': '<a href="controller.html#the-base-controller-classes-services" class="reference internal">基本的 AbstractController</a> 也提供了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php#:~:text=function%20renderBlock" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\AbstractController::renderBlock()" rel="external noopener noreferrer" target="_blank">renderBlock()</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php#:~:text=function%20renderBlockView" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\AbstractController::renderBlockView()" rel="external noopener noreferrer" target="_blank">renderBlockView()</a> 方法：',
        'This might come handy when dealing with blocks in\ntemplates inheritance or when using\nTurbo Streams.': '当处理<a href="templates.html#template_inheritance-layouts" class="reference internal">模板继承</a>中的块或使用 <a href="https://symfony.com/bundles/ux-turbo/current/index.html" class="reference external">Turbo Streams</a> 时，这可能会很方便。',
        'The\nrenderBlock() and\nrenderBlockView()\nmethods were introduced in Symfony 6.4.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php#:~:text=function%20renderBlock" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\AbstractController::renderBlock()" rel="external noopener noreferrer" target="_blank">renderBlock()</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/AbstractController.php#:~:text=function%20renderBlockView" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\AbstractController::renderBlockView()" rel="external noopener noreferrer" target="_blank">renderBlockView()</a> 方法是在Symfony 6.4中引入的。',
        'Inject the twig Symfony service into your own services and use its\nrender() method. When using service autowiring\nyou only need to add an argument in the service constructor and type-hint it with\nthe Twig Environment:': '将 <code translate="no" class="notranslate">twig</code> Symfony 服务注入到你自己的服务中，并使用它的 <code translate="no" class="notranslate">render()</code> 方法。当使用<a href="service_container/autowiring.html" class="reference internal">服务自动装配</a>时，你只需要在服务构造函数中添加一个参数，并使用 <a href="https://github.com/twigphp/Twig/blob/3.x/src/Loader/FilesystemLoader.php" class="reference external" rel="external noopener noreferrer" target="_blank">Twig Environment</a> 对其进行类型提示：',
        'Read the docs about the mailer and Twig integration.': '阅读有关 <a href="mailer.html#mailer-twig" class="reference internal">mailer 和 Twig 集成</a>的文档。',
        "Although templates are usually rendered in controllers and services, you can\nrender static pages that don't need any variables directly from the route\ndefinition. Use the special TemplateController\nprovided by Symfony:": '尽管模板通常在控制器和服务中渲染，但您可以直接从路由定义中渲染不需要任何变量的静态页面。使用 Symfony 提供的特殊 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/TemplateController.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\TemplateController" rel="external noopener noreferrer" target="_blank">TemplateController</a>：',
        'Templates are loaded in the application using a Twig template loader, which\nalso provides a method to check for template existence. First, get the loader:': '使用 <a href="https://twig.symfony.com/doc/3.x/api.html#loaders" class="reference external">Twig 模板加载器</a>将模板加载到应用程序中，该加载程序还提供了一种检查模板是否存在的方法。首先，获取加载程序：',
        'Then, pass the path of the Twig template to the exists() method of the loader:': '然后，将 Twig 模板的路径传递给加载程序的 <code translate="no" class="notranslate">exists()</code> 方法：',
        'Symfony provides several utilities to help you debug issues in your templates.': 'Symfony 提供了几个实用程序来帮助您调试模板中的问题。',
        "The lint:twig command checks that your Twig templates don't have any syntax\nerrors. It's useful to run it before deploying your application to production\n(e.g. in your continuous integration server):": '<code translate="no" class="notranslate">lint:twig</code> 命令检查 Twig 模板是否没有任何语法错误。在将应用程序部署到生产环境之前（例如，在持续集成服务器中）运行它非常有用：',
        'When running the linter inside GitHub Actions, the output is automatically\nadapted to the format required by GitHub, but you can force that format too:': '当在 <a href="https://docs.github.com/en/free-pro-team@latest/actions" class="reference external" rel="external noopener noreferrer" target="_blank">GitHub Actions</a> 中运行 linter 时，输出会自动适应 GitHub 所需的格式，但您也可以强制使用该格式：',
        "The debug:twig command lists all the information available about Twig\n(functions, filters, global variables, etc.). It's useful to check if your\ncustom Twig extensions are working properly\nand also to check the Twig features added when installing packages:": '<code translate="no" class="notranslate">debug:twig</code> 命令列出了关于 Twig 的所有可用信息(函数、过滤器、全局变量等)。检查您的<a href="templates.html#templates-twig-extension" class="reference internal">自定义 Twig 扩展</a>是否正常工作以及检查<a href="setup.html#symfony-flex" class="reference internal">安装包</a>时添加的 Twig 功能是有用的:',
        "Symfony provides a dump() function as an\nimproved alternative to PHP's var_dump() function. This function is useful\nto inspect the contents of any variable and you can use it in Twig templates too.": 'Symfony 提供了一个 <a href="components/var_dumper.html#components-var-dumper-dump" class="reference internal">dump() 函数</a>，作为 PHP 的 <code translate="no" class="notranslate">var_dump()</code> 函数的改进替代。这个函数对于检查任何变量的内容都很有用，你也可以在 Twig 模板中使用它。',
        'First, make sure that the VarDumper component is installed in the application:': '首先，确保应用中已经安装了 VarDumper 组件:',
        'Then, use either the {% dump %} tag or the {{ dump() }} function\ndepending on your needs:': '然后，根据需要使用 <code translate="no" class="notranslate">{% dump %}</code> 标签或 <code translate="no" class="notranslate">{{ dump() }}</code> 函数：',
        'The option to use named arguments in dump() was introduced in Symfony 6.3.': '在 <code translate="no" class="notranslate">dump()</code> 中使用命名参数的选项是在 Symfony 6.3 中引入的。',
        'To avoid leaking sensitive information, the dump() function/tag is only\navailable in the dev and test configuration environments.\nIf you try to use it in the prod environment, you will see a PHP error.': '为了避免泄露敏感信息，<code translate="no" class="notranslate">dump()</code> 函数/标记只在  <code translate="no" class="notranslate">dev</code> 和 <code translate="no" class="notranslate">test</code> <a href="configuration.html#configuration-environments" class="reference internal">配置环境</a>中可用。如果您尝试在 <code translate="no" class="notranslate">prod</code> 环境中使用它，您将看到一个 PHP 错误。',
        'If certain Twig code is repeated in several templates, you can extract it into a\nsingle "template fragment" and include it in other templates. Imagine that the\nfollowing code to display the user information is repeated in several places:': '如果某些 Twig 代码在多个模板中重复，您可以将其提取到单个“模板片段”中，并将其包含在其它模板中。想象一下，以下显示用户信息的代码在几个地方重复出现：',
        "First, create a new Twig template called blog/_user_profile.html.twig (the\n_ prefix is optional, but it's a convention used to better differentiate\nbetween full templates and template fragments).": '首先，创建一个名为 <code translate="no" class="notranslate">blog/_user_profile.html.twig</code> 的新 Twig 模板（<code translate="no" class="notranslate">_</code> 前缀是可选的，但这是一种用于更好地区分完整模板和模板片段的约定）。',
        'Then, remove that content from the original blog/index.html.twig template\nand add the following to include the template fragment:':'然后，从原始的 <code translate="no" class="notranslate">blog/index.html.twig</code> 模板中删除该内容，并添加以下内容以包含模板片段：',
        'The include() Twig function takes as argument the path of the template to\ninclude. The included template has access to all the variables of the template\nthat includes it (use the with_context option to control this).': '<code translate="no" class="notranslate">include()</code> Twig 函数的参数是要包含的模板的路径。被包含的模板可以访问包含它的模板的所有变量(使用 <a href="https://twig.symfony.com/doc/3.x/functions/include.html" class="reference external">with_context</a> 选项来控制)。',
        'You can also pass variables to the included template. This is useful for example\nto rename variables. Imagine that your template stores the user information in a\nvariable called blog_post.author instead of the user variable that the\ntemplate fragment expects. Use the following to rename the variable:': '还可以将变量传递给包含的模板。这对于重命名变量很有用。假设模板将用户信息存储在一个名为 <code translate="no" class="notranslate">blog_post.author</code> 的变量中，而不是模板片段所期望的 <code translate="no" class="notranslate">user</code> 变量中。使用以下命令重命名变量：',
        'Including template fragments is useful to reuse the\nsame content on several pages. However, this technique is not the best solution\nin some cases.': '<a href="templates.html#templates-include" class="reference internal">包含模板片段</a>对于在多个页面上重用相同的内容很有用。然而，在某些情况下，这种技术并不是最好的解决方案。',
        "Imagine that the template fragment displays the three most recent blog articles.\nTo do that, it needs to make a database query to get those articles. When using\nthe include() function, you'd need to do the same database query in every\npage that includes the fragment. This is not very convenient.": '假设模板片段显示最近的三篇博客文章。为此，它需要进行数据库查询以获取这些文章。当使用 <code translate="no" class="notranslate">include()</code> 函数时，您需要在包含片段的每个页面中执行相同的数据库查询。这不是很方便。',
        'A better alternative is to embed the result of executing some controller\nwith the render() and controller() Twig functions.': '更好的替代方法是<strong>将执行某些控制器的结果嵌入</strong>到 <code translate="no" class="notranslate">render()</code> 和 <code translate="no" class="notranslate">controller()</code> Twig 函数中。',
        'First, create the controller that renders a certain number of recent articles:': '首先，创建渲染最近一定数量文章的控制器：',
        "Then, create the blog/_recent_articles.html.twig template fragment (the\n_ prefix in the template name is optional, but it's a convention used to\nbetter differentiate between full templates and template fragments):": '然后，创建 <code translate="no" class="notranslate">blog/_user_profile.html.twig</code> 模板片段(模板名称中的 <code translate="no" class="notranslate">_</code> 前缀是可选的，但它是一种惯例，用于更好地区分完整模板和模板片段)：',
        'Now you can call to this controller from any template to embed its result:': '现在可以从任何模板中调用这个控制器来嵌入它的结果：',
        'When using the controller() function, controllers are not accessed using a\nregular Symfony route but through a special URL used exclusively to serve those\ntemplate fragments. Configure that special URL in the fragments option:': '当使用 <code translate="no" class="notranslate">controller()</code> 函数时，不会使用常规的 Symfony 路由访问控制器，而是通过一个专门用于服务这些模板片段的特殊 URL 访问控制器。在 <code translate="no" class="notranslate">fragments</code> 选项中配置这个特殊的 URL：',
        'Embedding controllers requires making requests to those controllers and\nrendering some templates as result. This can have a significant impact on\nthe application performance if you embed lots of controllers. If possible,\ncache the template fragment.': '嵌入控制器需要向这些控制器发出请求，并因此渲染一些模板。如果嵌入大量控制器，这可能会对应用程序性能产生重大影响。如果可能的话，<a href="http_cache/esi.html" class="reference internal">缓存模板片段</a>。',
        'Templates can also embed contents asynchronously with the hinclude.js\nJavaScript library.': '模板也可以用 <code translate="no" class="notranslate">hinclude.js</code> JavaScript 库异步嵌入内容。',
        'First, include the hinclude.js library in your page\nlinking to it from the template or adding it\nto your application JavaScript using Webpack Encore.': '首先，将 <a href="https://mnot.github.io/hinclude/" class="reference external" rel="external noopener noreferrer" target="_blank">hinclude.js</a> 库包含在页面中，从模板中<a href="templates.html#templates-link-to-assets" class="reference internal">链接到它</a>，或者<a href="frontend.html" class="reference internal">使用 Webpack Encore</a> 将其添加到应用程序 JavaScript 中。',
        'As the embedded content comes from another page (or controller for that matter),\nSymfony uses a version of the standard render() function to configure\nhinclude tags in templates:': '由于嵌入的内容来自另一个页面(或控制器)，Symfony 使用标准 <code translate="no" class="notranslate">render()</code> 函数的一个版本来配置模板中的 <code translate="no" class="notranslate">hinclude</code> 标签：',
        'When using the controller() function, you must also configure the\nfragments path option.': '当使用 <code translate="no" class="notranslate">controller()</code> 函数时，还必须配置 <a href="templates.html#fragments-path-config" class="reference internal"> fragments 路径选项</a>。',
        'When JavaScript is disabled or it takes a long time to load you can display a\ndefault content rendering some template:': '当 JavaScript 被禁用或需要很长时间加载时，你可以显示一个默认内容渲染一些模板：',
        'You can define default templates per render() function (which will override\nany global default template that is defined):': '你可以为 <code translate="no" class="notranslate">render()</code> 函数定义默认模板(它将覆盖任何已定义的全局默认模板)：',
        'Or you can also specify a string to display as the default content:': '或者，也可以指定一个字符串作为默认内容显示：',
        'Use the attributes option to define the value of hinclude.js options:': '使用 <code translate="no" class="notranslate">attributes</code> 选项来定义 hinclude.js 选项的值:',
        "As your application grows you'll find more and more repeated elements between\npages, such as headers, footers, sidebars, etc. Including templates\nand embedding controllers can help, but\nwhen pages share a common structure, it's better to use inheritance.": '随着应用程序的发展，您会发现页面之间越来越多的重复元素，如页眉、页脚、边栏等。<a href="templates.html#templates-include" class="reference internal">包含模板</a>和<a href="templates.html#templates-embed-controllers" class="reference internal">嵌入控制器</a>可能会有所帮助，但当页面共享一个公共结构时，最好使用<strong>继承</strong>。',
         'The concept of Twig template inheritance is similar to PHP class inheritance.\nYou define a parent template that other templates can extend from and child\ntemplates can override parts of the parent template.': '<a href="https://twig.symfony.com/doc/3.x/tags/extends.html" class="reference external">Twig 模板继承</a>的概念类似于 PHP 类继承。您定义了一个父模板，其他模板可以从它扩展，子模板可以覆盖父模板的某些部分。',
        'Symfony recommends the following three-level template inheritance for medium and\ncomplex applications:': 'Symfony 为中等和复杂的应用程序推荐以下三层模板继承：',
        'templates/base.html.twig, defines the common elements of all application\ntemplates, such as <head>, <header>, <footer>, etc.;': '<code translate="no" class="notranslate">templates/base.html.twig</code>，定义了所有应用模板的通用元素，如 <code translate="no" class="notranslate">&lt;head&gt;</code>、<code translate="no" class="notranslate">&lt;header&gt;</code>、<code translate="no" class="notranslate">&lt;footer&gt;</code> 等；',
        'templates/layout.html.twig, extends from base.html.twig and defines\nthe content structure used in all or most of the pages, such as a two-column\ncontent + sidebar layout. Some sections of the application can define their\nown layouts (e.g. templates/blog/layout.html.twig);': '<code translate="no" class="notranslate">templates/layout.html.twig</code>，从 <code translate="no" class="notranslate">base.html.twig</code> 扩展并定义了所有或大部分页面中使用的内容结构，例如两列内容+侧边栏布局。应用程序的某些部分可以定义自己的布局(例如 <code translate="no" class="notranslate">templates/blog/layout.html.twig</code>)；',
        'templates/*.html.twig, the application pages which extend from the main\nlayout.html.twig template or any other section layout.': '<code translate="no" class="notranslate">templates/*.html.twig</code>，从 <code translate="no" class="notranslate">layout.html.twig</code> 模板或任何其它部分布局扩展的应用程序页面。',
        'In practice, the base.html.twig template would look like this:': '实际上，<code translate="no" class="notranslate">base.html.twig</code> 模板看起来是这样的：',
        "The Twig block tag defines the page sections that can be overridden in the\nchild templates. They can be empty, like the content block or define a default\ncontent, like the title block, which is displayed when child templates don't\noverride them.": '<a href="https://twig.symfony.com/doc/3.x/tags/block.html" class="reference external">Twig 块标记</a>定义了可以在子模板中覆盖的页面部分。它们可以是空的，比如内容块，也可以定义一个默认的内容，比如标题块，当子模板没有覆盖它们时，就会显示它。',
        'The blog/layout.html.twig template could be like this:': '<code translate="no" class="notranslate">blog/layout.html.twig</code> 模板可以是这样的：',
        'The template extends from base.html.twig and only defines the contents of\nthe content block. The rest of the parent template blocks will display their\ndefault contents. However, they can be overridden by the third-level inheritance\ntemplate, such as blog/index.html.twig, which displays the blog index:': '模板从 <code translate="no" class="notranslate">base.html.twig</code> 扩展而来，只定义内容块的内容。其余的父模板块将显示它们的默认内容。但是，它们可以被第三级继承模板覆盖，比如 <code translate="no" class="notranslate">blog/index.html.twig</code>。显示博客索引的 Twig:',
        'This template extends from the second-level template (blog/layout.html.twig)\nbut overrides blocks of different parent templates: page_contents from\nblog/layout.html.twig and title from base.html.twig.': '这个模板从第二级模板（<code translate="no" class="notranslate">blog/layout.html.twig</code>）扩展，但覆盖了不同父模板的块:来自 <code translate="no" class="notranslate">blog/layout.html.twig</code> 的 <code translate="no" class="notranslate">page_contents</code>。和来自 <code translate="no" class="notranslate">base.html.twig</code> 的 <code translate="no" class="notranslate">title</code>。',
        'When you render the blog/index.html.twig template, Symfony uses three\ndifferent templates to create the final contents. This inheritance mechanism\nboosts your productivity because each template includes only its unique contents\nand leaves the repeated contents and HTML structure to some parent templates.': '当渲染 <code translate="no" class="notranslate">blog/index.html.twig</code> 模版时，Symfony 使用三种不同的模板来创建最终的内容。这种继承机制提高了您的工作效率，因为每个模板只包含其唯一的内容，而将重复的内容和 HTML 结构留给某些父模板。',
        'When using extends, a child template is forbidden to define template\nparts outside of a block. The following code throws a SyntaxError:': '当使用 <code translate="no" class="notranslate">extends</code> 时，禁止子模板在块之外定义模板部分。下面的代码抛出一个 <code translate="no" class="notranslate">SyntaxError</code> ：',
        'Read the Twig template inheritance docs to learn more about how to reuse\nparent block contents when overriding templates and other advanced features.': '阅读 <a href="https://twig.symfony.com/doc/3.x/tags/extends.html" class="reference external">Twig 模板继承</a>文档，了解更多关于重写模板和其它高级特性时如何重用父块内容的信息。',
        "Imagine that your template includes the Hello {{ name }} code to display the\nuser name. If a malicious user sets \x3Cscript>alert('hello!')\x3C/script> as\ntheir name and you output that value unchanged, the application will display a\nJavaScript popup window.": '假设您的模板包含 <code translate="no" class="notranslate">Hello {{ name }}</code> 代码来显示用户名。如果恶意用户设置 <code translate="no" class="notranslate">&lt;script&gt;alert(\'hello!\')&lt;/script&gt;</code> 作为其名称，而您输出该值不变，则应用程序将显示一个 JavaScript 弹出窗口。',
        'This is known as a Cross-Site Scripting (XSS) attack. And while the previous\nexample seems harmless, the attacker could write more advanced JavaScript code\nto perform malicious actions.': '这被称为跨站点脚本(XSS)攻击。虽然前面的示例看起来无害，但攻击者可以编写更高级的JavaScript代码来执行恶意操作。',
        'To prevent this attack, use "output escaping" to transform the characters\nwhich have special meaning (e.g. replace < by the &lt; HTML entity).\nSymfony applications are safe by default because they perform automatic output\nescaping:': '为了防止这种攻击，使用<em>“输出转义”</em>来转换具有特殊含义的字符(例如，将<code translate="no" class="notranslate">&lt;</code>替换为<code translate="no" class="notranslate">&amp;lt;</code> HTML 实体)。默认情况下，Symfony 应用程序是安全的，因为它们执行自动输出转义：',
        'If you are rendering a variable that is trusted and contains HTML contents,\nuse the Twig raw filter to disable the output escaping for that variable:': '如果正在渲染一个受信任且包含 HTML 内容的变量，使用 <a href="https://twig.symfony.com/doc/3.x/filters/raw.html" class="reference external">Twig raw 过滤器</a>来禁用该变量的输出转义：',
        'Read the Twig output escaping docs to learn more about how to disable output\nescaping for a block or even an entire template.': '阅读 <a href="https://twig.symfony.com/doc/3.x/api.html#escaper-extension" class="reference external">Twig 输出转义</a>文档，了解更多关于如何禁用块甚至整个模板的输出转义的信息。',
        'Although most applications store their templates in the default templates/\ndirectory, you may need to store some or all of them in different directories.\nUse the twig.paths option to configure those extra directories. Each path is\ndefined as a key: value pair where the key is the template directory and\nthe value is the Twig namespace, which is explained later:': '尽管大多数应用程序将它们的模板存储在默认的 <code translate="no" class="notranslate">templates/</code> 目录中，但您可能需要将它们中的一些或全部存储在不同的目录中。用 <code translate="no" class="notranslate">twig.paths</code> 选项来配置这些额外的目录。每个路径都被定义为一个 <code translate="no" class="notranslate">key: value</code> 对，其中 <code translate="no" class="notranslate">key</code> 是模板目录，<code translate="no" class="notranslate">value</code> 是 Twig 命名空间，后面会解释：',
        "When rendering a template, Symfony looks for it first in the twig.paths\ndirectories that don't define a namespace and then falls back to the default\ntemplate directory (usually, templates/).": '当渲染一个模板时，Symfony 首先在没有定义命名空间的 <code translate="no" class="notranslate">twig.paths</code> 目录中查找它，然后回落到默认的模板目录(通常是 <code translate="no" class="notranslate">templates/</code>)。',
        'Using the above configuration, if your application renders for example the\nlayout.html.twig template, Symfony will first look for\nemail/default/templates/layout.html.twig and backend/templates/layout.html.twig.\nIf any of those templates exists, Symfony will use it instead of using\ntemplates/layout.html.twig, which is probably the template you wanted to use.': '使用上面的配置，如果你的应用程序渲染 <code translate="no" class="notranslate">layout.html.twig</code> 模板，Symfony 将首先查找 <code translate="no" class="notranslate">email/default/templates/layout.html.twig</code> 和 <code translate="no" class="notranslate">backend/templates/layout.html.twig</code>。如果这些模板存在，Symfony 将使用它，而不是使用 <code translate="no" class="notranslate">templates/layout.html.twig</code>，这可能是你想要使用的模板。',
        'Twig solves this problem with namespaces, which group several templates\nunder a logic name unrelated to their actual location. Update the previous\nconfiguration to define a namespace for each template directory:': 'Twig 用 <strong>namespaces</strong> 解决了这个问题，它将几个模板分组在一个与实际位置无关的逻辑名称下。更新前面的配置，为每个模板目录定义一个命名空间：',
        'Now, if you render the layout.html.twig template, Symfony will render the\ntemplates/layout.html.twig file. Use the special syntax @ + namespace to\nrefer to the other namespaced templates (e.g. @email/layout.html.twig and\n@admin/layout.html.twig).': '现在，如果渲染 <code translate="no" class="notranslate">layout.html.twig</code> 模板，Symfony 将渲染 <code translate="no" class="notranslate">templates/layout.html.twig</code> 文件。使用特殊语法 <code translate="no" class="notranslate">@</code> + 命名空间来引用其它命名空间模板(例如 <code translate="no" class="notranslate">@email/layout.html.twig</code> 和 <code translate="no" class="notranslate">@admin/layout.html.twig</code>)。',
        'A single Twig namespace can be associated with more than one template\ndirectory. In that case, the order in which paths are added is important\nbecause Twig will start looking for templates from the first defined path.': '单个 Twig 命名空间可以与多个模板目录关联。在这种情况下，添加路径的顺序很重要，因为 Twig 将从第一个定义的路径开始查找模板。',
        'If you install packages/bundles in your application, they\nmay include their own Twig templates (in the Resources/views/ directory of\neach bundle). To avoid messing with your own templates, Symfony adds bundle\ntemplates under an automatic namespace created after the bundle name.': '如果在应用程序中<a href="setup.html#symfony-flex" class="reference internal">安装应用包/捆绑包</a>，它们可能包含自己的 Twig 模板(在每个捆绑包的 <code translate="no" class="notranslate">Resources/views/</code> 目录中)。为了避免混淆您自己的模板，Symfony 在 bundle 名称之后创建的自动命名空间下添加了 bundle 模板。',
        'For example, the templates of a bundle called AcmeBlogBundle are available\nunder the AcmeBlog namespace. If this bundle includes the template\n<your-project>/vendor/acme/blog-bundle/Resources/views/user/profile.html.twig,\nyou can refer to it as @AcmeBlog/user/profile.html.twig.': '例如，一个名为 <code translate="no" class="notranslate">AcmeBlogBundle</code> 的包的模板可以在 <code translate="no" class="notranslate">AcmeBlog</code> 命名空间下使用。如果这个包包含了模板 <code translate="no" class="notranslate">&lt;your-project&gt;/vendor/acme/blog-bundle/Resources/views/user/profile.html.twig</code>。您可以将其引用为 <code translate="no" class="notranslate">@AcmeBlog/user/profile.html.twig</code>。',
        'You can also override bundle templates in case\nyou want to change some parts of the original bundle templates.': '如果你想改变原bundle模板的某些部分，你也可以<a href="bundles/override.html#override-templates" class="reference internal">重写 bundle 模板</a>。',
        'Twig Extensions allow the creation of custom functions, filters, and more to use\nin your Twig templates. Before writing your own Twig extension, check if\nthe filter/function that you need is already implemented in:': '<a href="https://twig.symfony.com/doc/3.x/advanced.html#creating-an-extension" class="reference external">Twig Extensions</a> 允许在 Twig 模板中创建自定义函数、过滤器等。在编写自己的 Twig 扩展之前，检查您需要的过滤器/函数是否已经在：',
        'The default Twig filters and functions;': '<a href="https://twig.symfony.com/doc/3.x/#reference" class="reference external">默认的 Twig 过滤器和函数</a>；',
        'The Twig filters and functions added by Symfony;': '<a href="reference/twig_reference.html" class="reference internal">Symfony 添加的 Twig 过滤器和函数</a>；',
        'The official Twig extensions related to strings, HTML, Markdown, internationalization, etc.': '与字符串、HTML、Markdown、国际化等相关的<a href="https://github.com/twigphp?q=extra" class="reference external" rel="external noopener noreferrer" target="_blank">官方 Twig 扩展</a>。',
        'Suppose you want to create a new filter called price that formats a number\nas currency:': '假设要创建一个名为 <code translate="no" class="notranslate">price</code> 的新过滤器，该过滤器将数字格式化为货币：',
        'Create a class that extends AbstractExtension and fill in the logic:': '创建一个继承 <code translate="no" class="notranslate">AbstractExtension</code> 的类并填充逻辑：',
        'If you want to create a function instead of a filter, define the\ngetFunctions() method:': '如果要创建一个函数而不是过滤器，请定义 <code translate="no" class="notranslate">getFunctions()</code> 方法：',
        'Along with custom filters and functions, you can also register\nglobal variables.': '除了自定义过滤器和函数，还可以注册<a href="https://twig.symfony.com/doc/3.x/advanced.html#id1" class="reference external">全局变量</a>。',
        'Register an Extension as a Service': '将扩展注册为服务',
        "Next, register your class as a service and tag it with twig.extension. If you're\nusing the default services.yaml configuration,\nyou're done! Symfony will automatically know about your new service and add the tag.": '接下来，将类注册为服务，并使用 <code translate="no" class="notranslate">twig.extension</code> 对其进行标记。如果您使用的是<a href="service_container.html#service-container-services-load-example" class="reference internal">默认的 services.yaml 配置</a>，那么您就完成了！Symfony 将自动解析您的新服务并添加标签。',
        'You can now start using your filter in any Twig template. Optionally, execute\nthis command to confirm that your new filter was successfully registered:': '现在，可以开始在任何 Twig 模板中使用过滤器。（可选）执行此命令以确认您的新筛选器已成功注册：',
        "Including the code of the custom filters/functions in the Twig extension class\nis the simplest way to create extensions. However, Twig must initialize all\nextensions before rendering any template, even if the template doesn't use an\nextension.": '在 Twig 扩展类中包含自定义过滤器/函数的代码是创建扩展的最简单方法。但是，即使模板没有使用扩展，Twig 也必须在渲染任何模板之前初始化所有扩展。',
        "If extensions don't define dependencies (i.e. if you don't inject services in\nthem) performance is not affected. However, if extensions define lots of complex\ndependencies (e.g. those making database connections), the performance loss can\nbe significant.": '如果扩展没有定义依赖项（即，如果不在其中注入服务），则性能不会受到影响。然而，如果扩展定义了许多复杂的依赖项（例如，那些建立数据库连接的依赖项），那么性能损失可能会很大。',
        "That's why Twig allows decoupling the extension definition from its\nimplementation. Following the same example as before, the first change would be\nto remove the formatPrice() method from the extension and update the PHP\ncallable defined in getFilters():": '这就是为什么 Twig 允许将扩展定义与其实现解耦。遵循与之前相同的示例，第一个更改将从扩展中删除 <code translate="no" class="notranslate">formatPrice()</code> 方法，并更新 <code translate="no" class="notranslate">getFilters()</code> 中定义的PHP可调用对象：',
         "Then, create the new AppRuntime class (it's not required but these classes\nare suffixed with Runtime by convention) and include the logic of the\nprevious formatPrice() method:": '然后，创建新的 <code translate="no" class="notranslate">AppRuntime</code> 类（这不是必需的，但按照惯例，这些类的后缀是 <code translate="no" class="notranslate">Runtime</code>），并包括以前 <code translate="no" class="notranslate">formatPrice()</code> 方法的逻辑：',
        "If you're using the default services.yaml configuration, this will already\nwork! Otherwise, create a service\nfor this class and tag your service with twig.runtime.": '如果使用的是默认的 <code translate="no" class="notranslate">services.yaml</code> 配置，这已经可以工作了！否则，请为此类<a href="service_container.html#service-container-creating-service" class="reference internal">创建一个服务</a>，并使用 <code translate="no" class="notranslate">twig.runtime</code> <a href="service_container/tags.html" class="reference internal">标记您的服务</a>。',
        'For help building and versioning your JavaScript and\nCSS assets in a modern way, read about Symfony\'s AssetMapper.': '有关以现代方式构建和管理 JavaScript 和 CSS 资产的帮助，请阅读关于 <a href="frontend.html" class="reference internal">Symfony 的 AssetMapper</a> 的介绍。',
        'Another option is to use the #[Template] attribute on the controller method\nto define the template to render:': '另一个选项是在控制器方法上使用 <code translate="no" class="notranslate">#[Template]</code> 注解来定义要渲染的模板：',
        'The #[Template] attribute was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">#[Template]</code> 注解是在 Symfony 6.2 中引入的。',
        'First, include the hinclude.js library in your page\nlinking to it from the template or adding it\nto your application JavaScript using AssetMapper.': '首先，在页面中包含 <a href="https://mnot.github.io/hinclude/" class="reference external" rel="external noopener noreferrer" target="_blank">hinclude.js</a> 库，可以通过模板<a href="templates.html#templates-link-to-assets" class="reference internal">链接到它</a>，或者<a href="frontend.html" class="reference internal">使用 AssetMapper</a> 将其添加到你的应用程序 JavaScript 中。',
        'Output Escaping and XSS Attacks': '输出转义与 XSS 攻击',
        'Imagine that your template includes the Hello {{ name }} code to display the\nuser name and a malicious user sets the following as their name:': '假设你的模板包含了 <code translate="no" class="notranslate">Hello {{ name }}</code> 代码来显示用户名，而一个恶意用户将其用户名设置为如下内容：',
        'You\'ll see My Name on screen but the attacker just secretly stole your cookies\nso they can impersonate you on other websites. This is known as a Cross-Site Scripting\nor XSS attack.': '你在屏幕上看到的是 <code translate="no" class="notranslate">My Name</code>，但是攻击者却偷偷窃取了你的 Cookie，从而可以在其它网站上冒充你。这种攻击被称为跨站脚本攻击（Cross-Site Scripting，简称 XSS 攻击）。',
        'Bundle Templates': 'Bundle 模板',
        'Twig Extensions allow the creation of custom functions, filters, and more to use\nin your Twig templates. Before writing your own Twig extension, check if\nthe filter/function that you need is not already implemented in:': '<a href="https://twig.symfony.com/doc/3.x/advanced.html#creating-an-extension" class="reference external">Twig 扩展</a>允许创建自定义函数、过滤器等，以便在你的 Twig 模板中使用。在编写自己的 Twig 扩展之前，请检查所需的功能或过滤器是否已经实现在以下地方：',
    };

    fanyi(translates, 1);
})($);
