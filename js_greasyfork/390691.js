// ==UserScript==
// @name         AutoGrepo
// @namespace    es.csnv.grepo
// @version      0.1
// @description  Grepo Automator
// @author       Jorge L. Casanova
// @match        https://*.grepolis.com/game/*
// @grant        none
// @downloadURL https://update.greasyfork.org/scripts/390691/AutoGrepo.user.js
// @updateURL https://update.greasyfork.org/scripts/390691/AutoGrepo.meta.js
// ==/UserScript==

(function() {
// Options
const config = {
	farmy: true, // Run auto farm when game loads
};

// Classes
class JBottomBar {
	constructor(opt) {
		const element = document.createElement('div');
		element.style.background = "#00000099";
		element.style.position = "absolute";
		element.style.zIndex = 999;
		element.style.bottom = opt.bottom;
		element.style.left = opt.left;
		element.style.padding = "5px 5px";

		document.body.appendChild(element);
		this.element = element;
	}

	add(el) {
		this.element.appendChild(el);
	}
}

class JButton {
	constructor(obj, context) {
		const element = document.createElement('button');
		// Style
		element.style.padding = "10px 20px";
		element.style.zIndex = 9999;
		element.style.color = "white";
		element.style.padding = 0;
		element.style.background = "none";
		element.style.border = 0;
		element.style.cursor = "pointer";

		element.innerText = obj.label;

		document.body.appendChild(element);

		// Events
		element.addEventListener('click', this.onClick.bind(this));

		this.fnOnClick = obj.onClick;
		this.element = element;
	}

	onClick(...args) {
		setTimeout(() => this.fnOnClick.apply(null, args), 0);
	}
}

class JButtonToggle extends JButton {
	constructor(obj) {
		super(obj);
		obj.active && this.on();
		this.onToggle();
	}

	onClick(...args) {
		if (this.active) {
			this.off();
		} else {
			this.on();
		}
		this.onToggle(args);
	}

	onToggle(args) {
		super.onClick(args);
	}

	on() {
		this.element.style.color = "cyan";
		this.active = true;
	}

	off() {
		this.element.style.color = "white";
		this.active = false;
	}

	isActive() {
		return this.active;
	}
}

class JTradeDialog {
	constructor() {
		const element = document.createElement('div');

		element.style.position = "absolute";
		element.style.zIndex = 9999;


	}
}

// Constants
const J = {
	resource: {
		WOOD: "url(https://gpes.innogamescdn.com/images/game/autogenerated/layout/layout_0153fd0.png) no-repeat -327px -608px",
		STONE: "url(https://gpes.innogamescdn.com/images/game/autogenerated/layout/layout_0153fd0.png) no-repeat -302px -608px",
		SILVER: "url(https://gpes.innogamescdn.com/images/game/autogenerated/layout/layout_0153fd0.png) no-repeat -724px -396px;"
	}
}

const opt = {
	extra_limit_time: 30000
};

let towns = null;

let auto = {

	init() {
		this.createBar();
		this.createButtons();
	},

	createBar() {
		this.bottomBar = new JBottomBar({
			bottom: 0,
			left: 0
		});
	},

	createButtons() {
		this.farmyButton = new JButtonToggle({
			active: config.farmy,
			label: "AF",
			onClick: this.onFarmyClick.bind(this)
		});
		this.bottomBar.add(this.farmyButton.element);
	},

	onFarmyClick() {
		if (!this.farmyButton.isActive()) {
			if (this.farmyTimeout) {
				clearTimeout(this.farmyTimeout);
			}
			return;
		}

		this.onFarming();
	},

	async onFarming() {
		const data = await this.callTownsInfo();
		towns = data.towns;

		this.requestFarmsData();
	},

	async requestFarmsData() {
		const aListPr = towns.map((town) => this.callFarmsInfo(town));
		const data = await Promise.all(aListPr);

		this.checkFarms(data);
	},

	async checkFarms(data) {
		// Get the first one we can collect
		let currFarm = null;
		let index = -1;
		data.forEach((town, townIndex)  => {
			if (!town.farm_town_list) {
				return;
			}
			if (this.hasReachedLimits(town.townId)) {
				// One of the resources has reached its limit
				return;
			}
			town.farm_town_list.forEach(farm => {
				if (!farm.loot) {
					if (farm.rel === 0)
					return;
					farm.loot = 0;
				}
				if (!currFarm || farm.loot < currFarm.loot) {
					currFarm = farm;
					index = townIndex;
				}
			});
		});

		let msDiff;
		// Check if we can already loot it
		if (currFarm) {
			msDiff = (currFarm.loot * 1000 + 1000) - new Date().getTime();
		} else {
			// Check again after 30 seconds
			msDiff = opt.extra_limit_time;
		}

		if (msDiff < 0) {
			// Loot it already
			this.doLoot(currFarm, data[index]);
		} else {
			// Otherwise wait for it to be available
			console.log("Next take: " + this.getDateWithMSOffSet(msDiff));
			this.farmyTimeout = setTimeout(this.onFarming.bind(this), msDiff);
		}
	},

	getDateWithMSOffSet(msOffset) {
		return new Date(new Date().getTime() + msOffset);
	},

	hasReachedLimits(townId) {
		const town = this.getTown(townId);
		const limit = town.storage_volume;
		const resources = town.resources;

		return resources.wood === limit
			|| resources.stone === limit
			|| resources.iron === limit;
	},

	getTown(townId) {
		return towns.find(town => town.id === townId);
	},

	async doLoot(farm, parent) {
		const now = new Date().getTime() / 1000;
		// Make a list of submitible farms - only if we can submit them
		const submitList = parent.farm_town_list.map(curr => {
			if (now >= curr.loot)
				return curr.id;
		});

		await this.callLootFarm({
			farmList: submitList,
			time: Math.min(...Object.keys(parent.loads_data)),
			townId: parent.townId
		});

		this.onFarming();
	},

	callTrade(obj) {
		return gpAjax.ajaxPost("town_overviews",
			"trade_between_own_town",
			{
					...obj,
					nl_init: true
			},
			false,
			() => console.log("TRADE OK"),
			false);
	},

	callTownsInfo() {
		return new Promise(res => gpAjax.ajaxGet("farm_town_overviews",
			"index",
			{
				town_id: Game.townId
			},
			false,
			(data) => res(data),
			true));
	},

	callLootFarm(obj) {
		return new Promise(res => gpAjax.ajaxPost("farm_town_overviews", "claim_loads", {
				claim_factor: "normal",
				current_town_id: obj.townId,
				farm_town_ids: obj.farmList,
				time_option: obj.time,
				town_id: obj.townId
			},
			false,
			(data) => res(data),
			true));
	},

	callFarmsInfo(town) {
		return new Promise(res => gpAjax.ajaxGet("farm_town_overviews",
			"get_farm_towns_for_town",
			{
				current_town_id: town.id,
				island_x: town.island_x,
				island_y: town.island_y,
				booty_researched: town.booty_researched,
				diplomacy_researched: town.diplomacy_researched || "",
				trade_office: town.trade_office
			},
			false,
			(data) => res({...data, townId: town.id}),
			true));
	}
};

auto.init();

})();