// ==UserScript==
// @name MAL-Sync Adult [FateXXXBlood Edition]
// @namespace https://greasyfork.org/users/92233
// @description Integrates MyAnimeList/AniList/Kitsu/Simkl into various sites, with auto episode tracking.
// @version 0.2.10
// @author lolamtisch@gmail.com
// @license GPL-3.0
// @iconURL https://raw.githubusercontent.com/MALSync/MALSync/master/assets/icons/icon128.png
// @grant GM_xmlhttpRequest
// @grant GM_getValue
// @grant GM_setValue
// @grant GM_deleteValue
// @grant GM_listValues
// @grant GM_addStyle
// @grant GM_getResourceText
// @grant GM.xmlHttpRequest
// @grant GM.getValue
// @grant GM.setValue
// @match *://anilist.co/404
// @match *://kitsu.io/404?mal-sync=authentication*
// @match *://simkl.com/apps/chrome/mal-sync/connected*
// @match *://malsync.moe/mal/oauth*
// @match *://*.hanime.tv/*
// @match *://hentaihaven.org/*
// @match *://hentaigasm.com/*
// @match *://kisshentai.net/Hentai/*
// @match *://www.underhentai.net/*
// @match *://nhentai.net/g/*
// @match *://*.openload.co/*
// @match *://*.openload.pw/*
// @match *://*.streamango.com/*
// @match *://*.mp4upload.com/*
// @match *://*.mcloud.to/*
// @match *://*.prettyfast.to/*
// @match *://*.rapidvideo.com/*
// @match *://*.rapidvid.to/*
// @match *://*.static.vrv.co/*
// @match *://*.vidstreaming.io/*
// @match *://*.xstreamcdn.com/*
// @match *://*.gcloud.live/*
// @match *://*.oload.tv/*
// @match *://*.mail.ru/*
// @match *://*.myvi.ru/*
// @match *://*.sibnet.ru/*
// @match *://*.tune.pk/*
// @match *://*.vimple.ru/*
// @match *://*.href.li/*
// @match *://*.vk.com/*
// @match *://*.cloudvideo.tv/*
// @match *://*.fembed.net/*
// @match *://*.fembed.com/*
// @match *://*.animeproxy.info/*
// @match *://*.youpload.co/*
// @match *://*.yourupload.com/*
// @match *://*.vidlox.me/*
// @match *://*.kwik.cx/*
// @match *://*.mega.nz/*
// @match *://*.hqq.tv/*
// @match *://*.ok.ru/*
// @match *://verystream.com/*
// @match *://*.vidoza.net/*
// @match *://crazyload.co/*
// @match *://gounlimited.to/*
// @match *://www.ani-stream.com/*
// @match *://flex.aniflex.org/public/dist/*
// @match *://superitu.com/embed/*
// @match *://www.dailymotion.com/embed/*
// @match *://vev.io/embed/*
// @match *://vev.red/embed/*
// @match *://jwpstream.com/jwps/yplayer.php*
// @match *://www.vaplayer.xyz/v/*
// @match *://player.hanime.tv/*
// @match *://stream.lewd.host/embed/*
// @match *://tiwi.kiwi/*
// @match *://streamcherry.com/embed/*
// @require  http://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js
// @resource material.css https://code.getmdl.io/1.3.0/material.indigo-pink.min.css
// @resource materialFont.css https://fonts.googleapis.com/icon?family=Material+Icons
// @resource material.js https://raw.githubusercontent.com/MALSync/MALSync/master/package/materialDesignLite.js
// @run-at document_start
// @connect myanimelist.net
// @connect kissanimelist.firebaseio.com
// @connect graphql.anilist.co
// @connect media.kitsu.io
// @connect api.simkl.com
// @connect api.malsync.moe
// @connect *
// @downloadURL https://update.greasyfork.org/scripts/387981/MAL-Sync%20Adult%20%5BFateXXXBlood%20Edition%5D.user.js
// @updateURL https://update.greasyfork.org/scripts/387981/MAL-Sync%20Adult%20%5BFateXXXBlood%20Edition%5D.meta.js
// ==/UserScript==

var i18n = {"Search":"Site Search","Show":"Show","Help":"Help","Update":"Update","Add":"Add","Reset":"Reset","Remove":"Remove","Loading":"Loading","Select":"Select","Yes":"Yes","Ok":"Ok","No":"No","Cancel":"Cancel","updated":"Updated","removed":"Removed","NothingFound":"Nothing Found","Not_Found":"Not Found!","NoEntries":"No Entries","fullscreen":"fullscreen","close":"close","All":"All","Anime":"Anime","Manga":"Manga","Package_Description":"Integrates MyAnimeList/AniList/Kitsu/Simkl into various sites, with auto episode tracking.","UI_Status":"Status:","UI_Status_watching_anime":"Watching","UI_Status_watching_manga":"Reading","UI_Status_Completed":"Completed","UI_Status_OnHold":"On-Hold","UI_Status_Dropped":"Dropped","UI_Status_planTo_anime":"Plan to Watch","UI_Status_planTo_manga":"Plan to Read","UI_Status_Rewatching_anime":"Rewatching","UI_Status_Rewatching_manga":"Rereading","UI_Episode":"Episode:","UI_Volume":"Volume:","UI_Chapter":"Chapter:","UI_Score":"Your Score:","UI_Score_Not_Rated":"Not rated","UI_Score_Masterpiece":"(10) Masterpiece","UI_Score_Great":"(9) Great","UI_Score_VeryGood":"(8) Very Good","UI_Score_Good":"(7) Good","UI_Score_Fine":"(6) Fine","UI_Score_Average":"(5) Average","UI_Score_Bad":"(4) Bad","UI_Score_VeryBad":"(3) Very Bad","UI_Score_Horrible":"(2) Horrible","UI_Score_Appalling":"(1) Appalling","UI_Rules":"Rules","syncPage_flashm_resumeMsg":"Resume at $1","syncPage_flashm_sync_anime":"Update $1 to episode $2","syncPage_flashm_sync_manga":"Update $1 to chapter $2","syncPage_flashm_sync_undefined_undo":"Undo","syncPage_flashm_sync_undefined_wrong":"Wrong?","syncPage_flashm_failded":"Update failed","syncPage_flashConfirm_complete":"Set as completed?","syncPage_flashConfirm_start_anime":"Start watching?","syncPage_flashConfirm_rewatch_finish_anime":"Finish rewatching?","syncPage_flashConfirm_rewatch_finish_manga":"Finish rereading?","syncPage_flashConfirm_start_manga":"Start reading?","syncPage_flashConfirm_rewatch_start_anime":"Rewatch Anime?","syncPage_flashConfirm_rewatch_start_manga":"Reread Manga?","syncPage_flashConfirm_Anime_Correct":"Is \"$1\" correct?","syncPage_flash_player_error":"Player not detected. Please manually update it here.","syncPage_malObj_addAnime":"Add to $1","syncPage_malObj_nextEp_anime":"Episode $1","syncPage_malObj_nextEp_manga":"Chapter $1","syncPage_flashConfirm_offsetHandler_1":"A possible Episode offset of $1 was detected. Is that correct? ","anilistClass_authentication":"Token saved you can close this page now","kitsuClass_authentication_text":"To login with Kitsu, you need to enter your account's e-mail and password.<br>Your credentials are not stored on your computer or anywhere else.<br>They are directly sent to Kitsu. Only the returned access token is saved.<br>","kitsuClass_authentication_Password":"Password","kitsuClass_authentication_Login":"Login","kitsuClass_authentication_Success":"Token saved you can close this page now","kitsuClass_authentication_Wrong":"Credentials wrong","bookmarksItem_Years":"Years","bookmarksItem_Year":"Year","bookmarksItem_Days":"Days","bookmarksItem_Day":"Day","bookmarksItem_Hours":"Hours","bookmarksItem_Hour":"Hour","bookmarksItem_mins":"mins","bookmarksItem_min":"min","bookmarksItem_secs":"seconds","bookmarksItem_sec":"second","bookmarksItem_now":"Now","bookmarksItem_ago":"$1 ago","prediction_Episode_anime":"Next episode estimated in $1","prediction_Last_anime":"Last episode released $1 ago","prediction_Episode_manga":"Next chapter estimated in $1","prediction_Last_manga":"Last chapter released $1 ago","prediction_next":"Next in $1","prediction_incomplete":"Incomplete","prediction_ongoing":"Ongoing","prediction_complete":"Complete","prediction_Airing":"Airing in $1","correction_Offset":"Episode Offset","correction_Offset_text":"Input the episode offset, if an anime has 12 episodes, but uses the numbers 0-11 rather than 1-12, you simply type \" +1 \" in the episode offset.","correction_WrongUrl":"Only change this URL if it points to the wrong anime page on MAL.","correction_Search":"Correction Search","correction_Search_text":"This field is for finding an anime, when you need to correct the \"MyAnimeList URL\" shown above.<br>To make a search, simply begin typing the name of an anime, and a list with results will automatically appear as you type.","correction_NoMal":"If the Anime/Manga can't be found on MAL","correction_NoEntry":"No entry on MyAnimeList","correction_NewOffset":"New Offset ($1) set.","correction_OffsetReset":"Offset reset","correction_NewUrl":"New URL '$1' set.","correction_NewUrlReset":"MyAnimeList URL reset","correction_DBRequest":"Submit database correction request?","overview_Continue_anime":"Continue watching","overview_Continue_manga":"Continue reading","overview_Next_Episode_anime":"Next Episode","overview_Next_Episode_manga":"Next Chapter","overview_Resume_Episode_anime":"Resume Episode","overview_Resume_Episode_manga":"Resume Chapter","overview_EditDetails":"Edit Details","overview_Characters":"Characters","overview_OpeningTheme":"Opening Theme:","overview_EndingTheme":"Ending Theme:","search_Type":"Type:","search_Score":"Score:","search_Year":"Year:","settings_General":"General","settings_Mode":"Mode","settings_Authenticate":"Authenticate","settings_LocalSync":"Local storage fallback","settings_LocalSync_Import":"Import","settings_LocalSync_Export":"Export","settings_Animesync":"Anime sync","settings_Animesync_Video":"Video","settings_Animesync_Instant":"Instant","settings_Animesync_Manual":"Manual","settings_Mangasync":"Manga sync","settings_AutoTracking_Video":"Update on $1% of video progress","settings_AutoTracking_Instant":"Delay instant autotracking by $1 seconds","settings_StreamingSite":"Streaming Site Links","settings_StreamingSite_text":"If disabled, the streaming site will no longer appear in an animeâ€™s sidebar on MyAnimeList/AniList/Kitsu/Simkl.","settings_Thumbnails":"Thumbnails","settings_Thumbnails_text":"The option is for resizing the thumbnails on MyAnimeList eg. thumbnails for characters, people, recommendations, etc.","settings_Thumbnails_Large":"Large","settings_Thumbnails_Medium":"Medium","settings_Thumbnails_Small":"Small","settings_Thumbnails_Default":"MAL Default","settings_FriendScore":"Friend scores on detail page","settings_epPredictions":"Estimate episode number","settings_malTags":"Use Tags/Notes","settings_malTags_Text":"If enabled: The streaming page that you have used last is permanently (across browsers) saved in the tags/Notes section in your list. The saved string in the tag section is ugly, only really recommended if you dont use the tag/notes section.","settings_malContinue":"Continue watching links","settings_malResume":"Resume watching links","settings_usedPage":"Last used page links","settings_miniMAL_floatButtonStealth":"Stealth UI mode","settings_miniMAL_minimizeBigPopup":"Minimize big pop-ups","settings_miniMAL_floatButtonCorrection":"Remap floating button to the correction UI","settings_miniMAL_floatButtonHide":"Hide miniMAL floating menu button","settings_miniMAL_autoCloseMinimal":"Clicking outside closes miniMAL","settings_miniMAL_Display":"Display to the","settings_miniMAL_popup":"Extension Popup","settings_miniMAL_theme":"Theme","settings_miniMAL_window":"Open in separate window","settings_miniMAL_Display_Left":"Left","settings_miniMAL_Display_Right":"Right","settings_miniMAL_Height":"Height (px / %)","settings_miniMAL_Width":"Width (px / %)","settings_Shortcuts":"Shortcuts","settings_miniMAL_Open":"Open miniMAL","settings_miniMAL_NotSet":"Not Set","settings_loadPTWForProgress":"Load PTW/PTR for Progress evaluation","settings_Video_Player":"Video Player","settings_Video_Fullscreen":"Auto fullscreen","settings_Video_Resume":"Auto resume","settings_autoNextEp":"Autoplay next episode","settings_Shortcuts_Correction":"Open anime relation correction popup","settings_Shortcuts_Sync":"Set episode/chapter as read","settings_Shortcuts_Next_Episode":"Open next episode shortcut","settings_Shortcuts_Skip_Forward":"Skips the opening","settings_Shortcuts_Skip_Backward":"Jump back to opening's beginning","settings_Shortcuts_Click":"Click to enter shortcut","settings_introSkip":"Set opening skip length ($1 seconds)","settings_UpdateCheck":"Update Check","settings_UpdateCheck_Text":"Checks for new episodes in the background.","settings_Interval":"Interval","settings_Interval_Off":"Off","settings_Interval_Default_Anime":"Default Anime","settings_Interval_Default_Manga":"Default Manga","settings_ProgressCheck":"Progress Check","settings_Notifications":"Notifications","settings_Debugging":"Debugging","settings_ETC":"ETC","settings_Userscriptmode":"Userscript mode","settings_Userscriptmode_Text":"Disables the content script. This makes it possible to have the extension and userscript enabled at the same time.","settings_highlightAllEp":"Highlight all Episodes/Chapters","settings_highlightAllEp_Text":"This option will highlight all watched chapters/episodes in the list you can find on some Anime/Manga sites","settings_ClearCache":"Clear Cache","settings_presenceHidePage":"Show MAL-Sync icon instead of page icon","settings_enabled":"Enabled","settings_shortcut_tooltip":"It is not recommended to set the shortcut to a single key","settings_progress_dropdown":"Estimation Source:","settings_progress_disabled":"Disabled","settings_progress_default":"Default","settings_website_button":"Websites","settings_custom_domains_button":"Custom domains","settings_clean_tags_button":"Clean Tags","settings_more_info":"More Info","settings_presenceShowButtons":"Show button to view the anime/manga on MAL or another provider","updateCheck_Refresh":"Refresh","updateCheck_StartCheck":"Start Check","updateCheck_NotificationCheck":"Notification Check","updateCheck_Episode":"Episode","updateCheck_Message":"Message","updateCheck_NotificationHistory":"Notification History","minimalApp_Overview":"Overview","minimalApp_Reviews":"Reviews","minimalApp_Recommendations":"Recommendations","minimalApp_Settings":"Settings","minimalClass_Popup":"Please allow pop-ups for this website","minimalClass_versionMsg":"Updated to version $1 $2CHANGELOG</a>]","minimalClass_versionMsg_Text_1":"Thank you for installing MAL-Sync","minimalClass_versionMsg_Text_2":"Having Questions?","minimalClass_versionMsg_Text_3":"Open Source Code:","minimalClass_versionMsg_Text_4":"uBlock users please subscribe to this filter list! This fixes some problems like broken images","installPage_Mode":"Please select which Anime database you want use:","installPage_Howto":"How to use?","installPage_Howto_Description":"Just open an episode or chapter on any of the <a target=\"_blank\" href=\"https://github.com/MALSync/MALSync#supported-pages-\">supported pages</a>. The sync waits until 85% of the video is watched. For mangas it syncs on page load. This can be changed in the <a class=\"open-settings\" href=\"#\">settings</a>.","installPage_Wrong":"It syncs to the wrong MAL entry?","installPage_Wrong_Description":"You can easily change the relation like shown in the gif below. An episode offset can be set on that page too.","Anilist_Authenticate":"Please Authenticate <a target=\"_blank\" href=\"https://anilist.co/api/v2/oauth/authorize?client_id=1487&response_type=token\">Here</a>","Emby_Authenticate":"MAL-Sync needs an Emby API key to work. More infos <a href=\"https://github.com/MediaBrowser/Emby/wiki/Api-Key-Authentication#creating-an-api-key\" target=\"_blank\">Here</a>","Error_Authenticate":"Please Authenticate <a target=\"_blank\" href=\"$1\">Here</a>","Discord_rpc_browsing":"Browsing $1","discord_rpc_view_anime":"View Anime","discord_rpc_view_manga":"View Manga","nextEpShort_no_support":"This page doesn't support opening the next episode","nextEpShort_no_nextEp":"Couldn't find the next episode","settings_filler":"Check for filler/recap episodes","settings_filler_text":"This will check if the episode is marked as a filler/recap on MyAnimeList","filler_filler_confirm":"This episode has been marked as a filler on MyAnimeList, do you want to skip?","filler_recap_confirm":"This episode has been marked as a recap on MyAnimeList, do you want to skip?"}
/*! For license information please see malsync-adult.user.js.LICENSE.txt */
!function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.l = !0, module.exports;
    }
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.r = function(exports) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, __webpack_require__.t = function(value, mode) {
        if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
        if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
        var ns = Object.create(null);
        if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
            enumerable: !0,
            value: value
        }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
            return value[key];
        }.bind(null, key));
        return ns;
    }, __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default;
        } : function() {
            return module;
        };
        return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 290);
}([ function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "storage", (function() {
        return storage;
    })), __webpack_require__.d(__webpack_exports__, "request", (function() {
        return request;
    })), __webpack_require__.d(__webpack_exports__, "settings", (function() {
        return settings;
    })), __webpack_require__.d(__webpack_exports__, "type", (function() {
        return type;
    }));
    var _storage_userscriptLegacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96), _request_requestUserscriptLegacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97), _settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
    const storage = _storage_userscriptLegacy__WEBPACK_IMPORTED_MODULE_0__.a, request = _request_requestUserscriptLegacy__WEBPACK_IMPORTED_MODULE_1__.a, settings = _settings__WEBPACK_IMPORTED_MODULE_2__.a, type = "userscript";
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), function(j, api, con, utils) {
        __webpack_require__.d(__webpack_exports__, "urlPart", (function() {
            return urlPart;
        })), __webpack_require__.d(__webpack_exports__, "urlStrip", (function() {
            return urlStrip;
        })), __webpack_require__.d(__webpack_exports__, "urlParam", (function() {
            return urlParam;
        })), __webpack_require__.d(__webpack_exports__, "getBaseText", (function() {
            return getBaseText;
        })), __webpack_require__.d(__webpack_exports__, "generateUniqueID", (function() {
            return generateUniqueID;
        })), __webpack_require__.d(__webpack_exports__, "favicon", (function() {
            return favicon;
        })), __webpack_require__.d(__webpack_exports__, "watching", (function() {
            return watching;
        })), __webpack_require__.d(__webpack_exports__, "planTo", (function() {
            return planTo;
        })), __webpack_require__.d(__webpack_exports__, "episode", (function() {
            return episode;
        })), __webpack_require__.d(__webpack_exports__, "syncRegex", (function() {
            return syncRegex;
        })), __webpack_require__.d(__webpack_exports__, "status", (function() {
            return status;
        })), __webpack_require__.d(__webpack_exports__, "getselect", (function() {
            return getselect;
        })), __webpack_require__.d(__webpack_exports__, "absoluteLink", (function() {
            return absoluteLink;
        })), __webpack_require__.d(__webpack_exports__, "parseHtml", (function() {
            return parseHtml;
        })), __webpack_require__.d(__webpack_exports__, "urlChangeDetect", (function() {
            return urlChangeDetect;
        })), __webpack_require__.d(__webpack_exports__, "fullUrlChangeDetect", (function() {
            return fullUrlChangeDetect;
        })), __webpack_require__.d(__webpack_exports__, "changeDetect", (function() {
            return changeDetect;
        })), __webpack_require__.d(__webpack_exports__, "waitUntilTrue", (function() {
            return waitUntilTrue;
        })), __webpack_require__.d(__webpack_exports__, "getAsyncWaitUntilTrue", (function() {
            return getAsyncWaitUntilTrue;
        })), __webpack_require__.d(__webpack_exports__, "checkDoubleExecution", (function() {
            return checkDoubleExecution;
        })), __webpack_require__.d(__webpack_exports__, "getUrlFromTags", (function() {
            return getUrlFromTags;
        })), __webpack_require__.d(__webpack_exports__, "setUrlInTags", (function() {
            return setUrlInTags;
        })), __webpack_require__.d(__webpack_exports__, "setResumeWaching", (function() {
            return setResumeWaching;
        })), __webpack_require__.d(__webpack_exports__, "getResumeWaching", (function() {
            return getResumeWaching;
        })), __webpack_require__.d(__webpack_exports__, "setContinueWaching", (function() {
            return setContinueWaching;
        })), __webpack_require__.d(__webpack_exports__, "getContinueWaching", (function() {
            return getContinueWaching;
        })), __webpack_require__.d(__webpack_exports__, "setEntrySettings", (function() {
            return setEntrySettings;
        })), __webpack_require__.d(__webpack_exports__, "getEntrySettings", (function() {
            return getEntrySettings;
        })), __webpack_require__.d(__webpack_exports__, "handleMalImages", (function() {
            return handleMalImages;
        })), __webpack_require__.d(__webpack_exports__, "getTooltip", (function() {
            return getTooltip;
        })), __webpack_require__.d(__webpack_exports__, "timeDiffToText", (function() {
            return timeDiffToText;
        })), __webpack_require__.d(__webpack_exports__, "canHideTabs", (function() {
            return canHideTabs;
        })), __webpack_require__.d(__webpack_exports__, "statusTag", (function() {
            return statusTag;
        })), __webpack_require__.d(__webpack_exports__, "notifications", (function() {
            return notifications;
        })), __webpack_require__.d(__webpack_exports__, "timeCache", (function() {
            return timeCache;
        })), __webpack_require__.d(__webpack_exports__, "flashm", (function() {
            return flashm;
        })), __webpack_require__.d(__webpack_exports__, "flashConfirm", (function() {
            return flashConfirm;
        })), __webpack_require__.d(__webpack_exports__, "lazyload", (function() {
            return lazyload;
        })), __webpack_require__.d(__webpack_exports__, "elementInViewport", (function() {
            return elementInViewport;
        })), __webpack_require__.d(__webpack_exports__, "wait", (function() {
            return wait;
        })), __webpack_require__.d(__webpack_exports__, "pageUrl", (function() {
            return pageUrl;
        })), __webpack_require__.d(__webpack_exports__, "returnYYYYMMDD", (function() {
            return returnYYYYMMDD;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function urlPart(url, part) {
            if (!url) return "";
            const urlParts = url.split("/");
            return urlParts[part] ? urlParts[part].replace(/[#?].*/, "") : "";
        }
        function urlStrip(url) {
            return url.replace(/[#?].*/, "");
        }
        function urlParam(url, name) {
            const results = new RegExp(`[?&]${name}=([^&#]*)`).exec(url);
            return null === results ? null : decodeURI(results[1]) || 0;
        }
        function getBaseText(element) {
            let text = element.text();
            return element.children().each((function() {
                text = text.replace(j.$(this).text(), "");
            })), text;
        }
        function generateUniqueID(arraySize = 10) {
            const array = new Uint32Array(arraySize);
            return window.crypto.getRandomValues(array), Array.from(array, value => value.toString(16)).join("");
        }
        function favicon(domain) {
            const res = domain.match(/^(https?:\/\/)?[^/]+/);
            return res && (domain = res[0]), "https://favicon.malsync.moe/?domain=" + domain;
        }
        function watching(type) {
            return "manga" === type ? "Reading" : "Watching";
        }
        function planTo(type) {
            return "manga" === type ? "Plan to Read" : "Plan to Watch";
        }
        function episode(type) {
            return "manga" === type ? api.storage.lang("UI_Chapter") : api.storage.lang("UI_Episode");
        }
        const syncRegex = /(^settings\/.*|^updateCheckTime$|^tempVersion$|^local:\/\/|^list-tagSettings$)/;
        var status;
        function getselect(data, name) {
            let temp = data.split(`name="${name}"`)[1].split("</select>")[0];
            if (temp.indexOf('selected="selected"') > -1) {
                temp = temp.split("<option");
                for (let i = 0; i < temp.length; ++i) if (temp[i].indexOf('selected="selected"') > -1) return temp[i].split('value="')[1].split('"')[0];
            }
            return "";
        }
        function absoluteLink(url, domain) {
            return void 0 === url || url.startsWith("http") || ("/" !== url.charAt(0) && (url = "/" + url), 
            url = domain + url), url;
        }
        function parseHtml(text) {
            return (new DOMParser).parseFromString("<!doctype html><body>" + text, "text/html").body.textContent;
        }
        function urlChangeDetect(callback) {
            let currentPage = window.location.href;
            return setInterval((function() {
                currentPage !== window.location.href && (currentPage = window.location.href, callback());
            }), 100);
        }
        function fullUrlChangeDetect(callback, strip = !1) {
            let currentPage = "";
            const intervalId = setInterval((function() {
                const url = strip ? urlStrip(window.location.href) : window.location.href;
                currentPage !== url && (currentPage = url, callback());
            }), 100);
            return Number(intervalId);
        }
        function changeDetect(callback, func) {
            let currentPage = func();
            const intervalId = setInterval((function() {
                const temp = func();
                void 0 !== temp && currentPage !== temp && (currentPage = func(), callback());
            }), 500);
            return Number(intervalId);
        }
        function waitUntilTrue(condition, callback, interval = 100) {
            const intervalId = setInterval((function() {
                condition() && (clearInterval(intervalId), callback());
            }), interval);
            return intervalId;
        }
        function getAsyncWaitUntilTrue(condition, interval = 100) {
            let intervalId, rejectThis;
            const reset = () => {
                clearTimeout(intervalId), rejectThis && rejectThis("AsyncWait stopped");
            };
            return {
                asyncWaitUntilTrue: () => (reset(), new Promise((resolve, reject) => {
                    rejectThis = reject, intervalId = waitUntilTrue(condition, () => resolve(), interval);
                })),
                reset: reset
            };
        }
        !function(status) {
            status[status.watching = 1] = "watching", status[status.completed = 2] = "completed", 
            status[status.onhold = 3] = "onhold", status[status.dropped = 4] = "dropped", status[status.planToWatch = 6] = "planToWatch";
        }(status || (status = {}));
        const doubleId = Math.random();
        function checkDoubleExecution() {
            $(".mal-sync-double-detect").length && $(".mal-sync-double-detect").each((function(index) {
                $(this).text() !== doubleId.toString() && alert("Double execution detected! Please run MAL-Sync once only.");
            })), $("body").after(j.html(`<div class="mal-sync-double-detect" style="display: none;">${doubleId.toString()}</div>`));
        }
        function getUrlFromTags(tags) {
            return /malSync::[\d\D]+::/.test(tags) ? atobURL(tags.split("malSync::")[1].split("::")[0]) : /last::[\d\D]+::/.test(tags) ? atobURL(tags.split("last::")[1].split("::")[0]) : void 0;
            function atobURL(encoded) {
                try {
                    return atob(encoded);
                } catch (e) {
                    return encoded;
                }
            }
        }
        function setUrlInTags(url, tags) {
            if ("" === url) return tags = tags.replace(/,?(malSync|last)::[^ \n]+?::/, "");
            if (!api.settings.get("malTags")) return tags;
            const addition = `malSync::${btoa(url)}::`;
            return tags = /(last|malSync)::[\d\D]+::/.test(tags) ? tags.replace(/(last|malSync)::[^^]*?::/, addition) : `${tags},${addition}`;
        }
        function setResumeWaching(url, ep, type, id) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set(`resume/${type}/${id}`, {
                    url: url,
                    ep: ep
                });
            }));
        }
        function getResumeWaching(type, id) {
            return __awaiter(this, void 0, void 0, (function*() {
                if (api.settings.get("malResume")) return api.storage.get(`resume/${type}/${id}`);
            }));
        }
        function setContinueWaching(url, ep, type, id) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set(`continue/${type}/${id}`, {
                    url: url,
                    ep: ep
                });
            }));
        }
        function getContinueWaching(type, id) {
            return __awaiter(this, void 0, void 0, (function*() {
                if (api.settings.get("malContinue")) return api.storage.get(`continue/${type}/${id}`);
            }));
        }
        function setEntrySettings(type, id, options, tags = "") {
            return __awaiter(this, void 0, void 0, (function*() {
                const tempOptions = {};
                if (options) {
                    for (const key in options) switch (key) {
                      case "u":
                      case "p":
                        tempOptions[key] = options[key];
                    }
                    api.settings.get("malTags") ? tags = setUrlInTags(JSON.stringify(tempOptions), tags) : yield api.storage.set(`tagSettings/${type}/${id}`, JSON.stringify(tempOptions));
                }
                return Object.values(tempOptions).find(el => Boolean(el)) || (tags = setUrlInTags("", tags), 
                api.settings.get("malTags") || (yield api.storage.remove(`tagSettings/${type}/${id}`))), 
                tags;
            }));
        }
        function getEntrySettings(type, id, tags = "") {
            return __awaiter(this, void 0, void 0, (function*() {
                const tempOptions = {
                    u: null,
                    c: null,
                    r: null,
                    p: ""
                };
                if (api.settings.get("malTags")) {
                    const tagString = getUrlFromTags(tags);
                    if (tagString) if ("{" === tagString[0]) try {
                        const temp = JSON.parse(tagString);
                        for (const key in tempOptions) temp[key] && (tempOptions[key] = temp[key]);
                    } catch (e) {
                        con.error(e);
                    } else tempOptions.u = tagString;
                } else {
                    let temp = yield api.storage.get(`tagSettings/${type}/${id}`);
                    if (temp) {
                        temp = JSON.parse(temp);
                        for (const key in tempOptions) temp[key] && (tempOptions[key] = temp[key]);
                    }
                }
                const continueUrlObj = yield getContinueWaching(type, id);
                continueUrlObj && (tempOptions.c = continueUrlObj);
                const resumeUrlObj = yield getResumeWaching(type, id);
                return resumeUrlObj && (tempOptions.r = resumeUrlObj), api.settings.get("usedPage") || (tempOptions.u = null), 
                tempOptions;
            }));
        }
        function handleMalImages(url) {
            return -1 !== url.indexOf("questionmark") ? api.storage.assetUrl("questionmark.gif") : url;
        }
        function getTooltip(text, style = "", direction = "top") {
            const rNumber = Math.floor(1e3 * Math.random() + 1);
            return `<div id="tt${rNumber}" class="icon material-icons" style="font-size:16px; line-height: 0; color: #7f7f7f; padding-bottom: 20px; padding-left: 3px; ${style}">contact_support</div>  <div class="mdl-tooltip mdl-tooltip--${direction} mdl-tooltip--large" for="tt${rNumber}">${text}</div>`;
        }
        function timeDiffToText(delta) {
            let text = "";
            delta /= 1e3;
            const diffYears = Math.floor(delta / 31536e3);
            delta -= 31536e3 * diffYears, diffYears && (text += diffYears + "y ");
            const diffDays = Math.floor(delta / 86400);
            delta -= 86400 * diffDays, diffDays && (text += diffDays + "d ");
            const diffHours = Math.floor(delta / 3600) % 24;
            delta -= 3600 * diffHours, diffHours && diffDays < 2 && (text += diffHours + "h ");
            const diffMinutes = Math.floor(delta / 60) % 60;
            return delta -= 60 * diffMinutes, diffMinutes && !diffDays && diffHours < 3 && (text += diffMinutes + "min "), 
            text;
        }
        function canHideTabs() {
            return "undefined" != typeof browser && void 0 !== browser.tabs.hide;
        }
        function statusTag(status, type, id) {
            const info = {
                anime: {
                    1: {
                        class: "watching",
                        text: "CW",
                        title: "Watching"
                    },
                    2: {
                        class: "completed",
                        text: "CMPL",
                        title: "Completed"
                    },
                    3: {
                        class: "on-hold",
                        text: " HOLD",
                        title: "On-Hold"
                    },
                    4: {
                        class: "dropped",
                        text: "DROP",
                        title: "Dropped"
                    },
                    6: {
                        class: "plantowatch",
                        text: "PTW",
                        title: "Plan to Watch"
                    }
                },
                manga: {
                    1: {
                        class: "reading",
                        text: "CR",
                        title: "Reading"
                    },
                    2: {
                        class: "completed",
                        text: "CMPL",
                        title: "Completed"
                    },
                    3: {
                        class: "on-hold",
                        text: " HOLD",
                        title: "On-Hold"
                    },
                    4: {
                        class: "dropped",
                        text: "DROP",
                        title: "Dropped"
                    },
                    6: {
                        class: "plantoread",
                        text: "PTR",
                        title: "Plan to Read"
                    }
                }
            };
            if ($.each([ 1, 2, 3, 4, 6 ], (function(i, el) {
                info.anime[info.anime[el].title] = info.anime[el], info.manga[info.manga[el].title] = info.manga[el];
            })), status) {
                const tempInfo = info[type][status];
                return ` <a href="https://myanimelist.net/ownlist/${type}/${id}/edit?hideLayout=1" title="${tempInfo.title}" class="Lightbox_AddEdit button_edit ${tempInfo.class}">${tempInfo.text}</a>`;
            }
            return !1;
        }
        function notifications(url, title, message, iconUrl = "") {
            const messageObj = {
                type: "basic",
                title: title,
                message: message,
                iconUrl: iconUrl
            };
            con.log("Notification", url, messageObj), api.storage.get("notificationHistory").then(history => {
                void 0 === history && (history = []), "object" == typeof history && (history.length >= 10 && history.shift(), 
                history.push({
                    url: url,
                    title: messageObj.title,
                    message: messageObj.message,
                    iconUrl: messageObj.iconUrl,
                    timestamp: Date.now()
                }), api.storage.set("notificationHistory", history));
            });
            try {
                return chrome.notifications.create(url, messageObj);
            } catch (e) {
                con.error(e);
            }
        }
        function timeCache(key, dataFunction, ttl) {
            return __awaiter(this, void 0, void 0, (function*() {
                const value = yield api.storage.get(key);
                if ("object" == typeof value && (new Date).getTime() < value.timestamp) return value.data;
                const result = yield dataFunction();
                return api.storage.set(key, {
                    data: result,
                    timestamp: (new Date).getTime() + ttl
                }).then(() => result);
            }));
        }
        function flashm(text, options) {
            j.$("#flash-div-top").length || function() {
                api.storage.addStyle('.flashinfo{\n                    transition: max-height 2s, opacity 2s 2s;\n                 }\n                 .mini-stealth .flashinfo{\n                    opacity: 0;\n                 }\n                  #flashinfo-div.hover.mini-stealth .flashinfo.type-update{\n                    opacity: 0.7;\n                 }\n                 #flashinfo-div.hover .flashinfo{\n                    opacity: 1;\n                 }\n                 .flashinfo:hover{\n                    max-height:5000px !important;\n                    z-index: 2147483647;\n                    opacity: 1;\n                    transition: max-height 2s;\n                 }\n                 .flashinfo .synopsis{\n                    transition: max-height 2s, max-width 2s ease 2s;\n                 }\n                 .flashinfo:hover .synopsis{\n                    max-height:9999px !important;\n                    max-width: 500px !important;\n                    transition: max-height 2s;\n                 }\n                 #flashinfo-div{\n                  z-index: 2;\n                  transition: 2s;\n                 }\n                 #flashinfo-div:hover, #flashinfo-div.hover{\n                  z-index: 2147483647;\n                 }\n                 #flashinfo-div.player-error {\n                   z-index: 2147483647;\n                 }\n                 #flashinfo-div.player-error .type-update{\n                  overflow: visible !important;\n                  opacity: 1 !important;\n                 }\n                 #flashinfo-div.player-error .player-error{\n                  display: block !important\n                 }\n\n                 #flash-div-top, #flash-div-bottom, #flashinfo-div{\n                    font-family: "Helvetica","Arial",sans-serif;\n                    color: white;\n                    font-size: 14px;\n                    font-weight: 400;\n                    line-height: 17px;\n                 }\n                 #flash-div-top h2, #flash-div-bottom h2, #flashinfo-div h2{\n                    font-family: "Helvetica","Arial",sans-serif;\n                    color: white;\n                    font-size: 14px;\n                    font-weight: 700;\n                    line-height: 17px;\n                    padding: 0;\n                    margin: 0;\n                 }\n                 #flash-div-top a, #flash-div-bottom a, #flashinfo-div a{\n                    color: #DF6300;\n                 }');
                let extraClass = "";
                api.settings.get("floatButtonStealth") && (extraClass = "mini-stealth");
                j.$("body").after(j.html(`<div id="flash-div-top" style="text-align: center;pointer-events: none;position: fixed;top:-5px;width:100%;z-index: 2147483647;left: 0;"></div>        <div id="flash-div-bottom" style="text-align: center;pointer-events: none;position: fixed;bottom:0px;width:100%;z-index: 2147483647;left: 0;"><div id="flash" style="display:none;  background-color: red;padding: 20px; margin: 0 auto;max-width: 60%;          -webkit-border-radius: 20px;-moz-border-radius: 20px;border-radius: 20px;background:rgba(227,0,0,0.6);"></div></div>        <div id="flashinfo-div" class="${extraClass}" style="text-align: center;pointer-events: none;position: fixed;bottom:0px;width:100%;left: 0;">`));
            }(), con.log("[Flash] Message:", text);
            let colorF = "#323232";
            void 0 !== options && void 0 !== options.error && options.error && (colorF = "#3e0808");
            let flashdiv = "#flash-div-bottom";
            void 0 !== options && void 0 !== options.position && options.position && (flashdiv = "#flash-div-" + options.position);
            let messClass = "flash";
            if (void 0 !== options && void 0 !== options.type && options.type) {
                const tempClass = "type-" + options.type;
                j.$(`${flashdiv} .${tempClass}, #flashinfo-div .${tempClass}`).removeClass(tempClass).fadeOut({
                    duration: 1e3,
                    queue: !1,
                    complete() {
                        j.$(this).remove();
                    }
                }), messClass += " " + tempClass;
            }
            let flashmEl, mess = `<div class="${messClass}" style="display:none;">        <div style="display:table; pointer-events: all; padding: 14px 24px 14px 24px; margin: 0 auto; margin-top: 5px; max-width: 60%; -webkit-border-radius: 20px;-moz-border-radius: 20px;border-radius: 2px;color: white;background:${colorF}; ">          ${text}        </div>      </div>`;
            return void 0 !== options && void 0 !== options.hoverInfo && options.hoverInfo ? (messClass += " flashinfo", 
            mess = `<div class="${messClass}" style="display:none; max-height: 5000px; overflow: hidden;"><div style="display:table; pointer-events: all; margin: 0 auto; margin-top: -2px; max-width: 60%; -webkit-border-radius: 20px;-moz-border-radius: 20px;border-radius: 2px;color: white;background:${colorF}; position: relative;"><div style="max-height: 60vh; overflow-y: auto; padding: 14px 24px 14px 24px;">${text}</div></div></div>`, 
            j.$("#flashinfo-div").addClass("hover"), flashmEl = j.$(j.html(mess)).appendTo("#flashinfo-div"), 
            void 0 !== options && void 0 !== options.minimized && options.minimized && flashmEl.css("max-height", "8px")) : flashmEl = j.$(j.html(mess)).appendTo(flashdiv), 
            void 0 !== options && void 0 !== options.permanent && options.permanent ? flashmEl.slideDown(800) : void 0 !== options && void 0 !== options.hoverInfo && options.hoverInfo ? flashmEl.slideDown(800).delay(4e3).queue((function() {
                j.$("#flashinfo-div").removeClass("hover"), flashmEl.css("max-height", "8px");
            })) : flashmEl.slideDown(800).delay(4e3).slideUp(800, () => {
                j.$(this).remove();
            }), flashmEl;
        }
        function flashConfirm(message, type, yesCall = (() => {}), cancelCall = (() => {}), yesNo = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                return new Promise((function(resolve, reject) {
                    let yesText = api.storage.lang("Ok"), noText = api.storage.lang("Cancel");
                    yesNo && (yesText = api.storage.lang("Yes"), noText = api.storage.lang("No"));
                    const flasmessage = flashm(message = `<div style="text-align: center;">${message}</div><div style="display: flex; justify-content: space-around;"><button class="Yes" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px; cursor:pointer;">${yesText}</button><button class="Cancel" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px; cursor:pointer;">${noText}</button></div>`, {
                        permanent: !0,
                        position: "top",
                        type: type
                    });
                    flasmessage.find(".Yes").click((function(evt) {
                        resolve(!0), j.$(evt.target).parentsUntil(".flash").fadeOut(300, (function() {
                            j.$(this).remove();
                        })), yesCall();
                    })), flasmessage.find(".Cancel").click((function(evt) {
                        resolve(!1), j.$(evt.target).parentsUntil(".flash").fadeOut(300, (function() {
                            j.$(this).remove();
                        })), cancelCall();
                    }));
                }));
            }));
        }
        let lazyloaded = !1, lazyimages = [];
        function lazyload(doc, scrollElement = ".mdl-layout__content") {
            function loadImage(el, fn) {
                if (!j.$(el).is(":visible")) return !1;
                if (j.$(el).hasClass("lazyBack")) j.$(el).css("background-image", `url(${el.getAttribute("data-src")})`).removeClass("lazyBack"); else {
                    const img = new Image, src = el.getAttribute("data-src");
                    img.onload = function() {
                        el.parent ? el.parent.replaceChild(img, el) : el.src = src, fn && fn();
                    }, img.src = src;
                }
            }
            for (let i = 0; i < lazyimages.length; i++) $(lazyimages[i]).addClass("init");
            lazyimages = [];
            const query = doc.find("img.lazy.init, .lazyBack.init"), processScroll = function() {
                for (let i = 0; i < lazyimages.length; i++) utils.elementInViewport(lazyimages[i], 600) && loadImage(lazyimages[i], (function() {
                    lazyimages.splice(i, i);
                })), $(lazyimages[i]).length || lazyimages.splice(i, i);
            };
            for (let i = 0; i < query.length; i++) lazyimages.push(query[i]), $(query[i]).removeClass("init");
            processScroll(), lazyloaded || (lazyloaded = !0, doc.find(scrollElement).scroll((function() {
                processScroll();
            })));
        }
        function elementInViewport(el, horizontalOffset = 0) {
            const rect = el.getBoundingClientRect();
            return rect.top >= 0 && rect.left >= 0 && rect.top - horizontalOffset <= (window.innerHeight || document.documentElement.clientHeight);
        }
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        function pageUrl(page, type, id) {
            switch (page) {
              case "mal":
                return `https://myanimelist.net/${type}/${id}`;

              case "anilist":
                return `https://anilist.co/${type}/${id}`;

              case "kitsu":
                return `https://kitsu.io/${type}/${id}`;

              case "simkl":
                return `https://simkl.com/${type}/${id}`;

              default:
                throw page + " not a valid page";
            }
        }
        function returnYYYYMMDD(numFromToday = 0) {
            const d = new Date;
            d.setDate(d.getDate() + numFromToday);
            const month = d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : d.getMonth() + 1, day = d.getDate() < 10 ? "0" + d.getDate() : d.getDate();
            return `${d.getFullYear()}-${month}-${day}`;
        }
    }.call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "$", (function() {
        return $;
    })), __webpack_require__.d(__webpack_exports__, "html", (function() {
        return html;
    }));
    var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88);
    const $ = jQuery;
    function html(htmlContent) {
        return dompurify__WEBPACK_IMPORTED_MODULE_0__.sanitize(htmlContent, {
            SAFE_FOR_JQUERY: !0,
            ALLOW_UNKNOWN_PROTOCOLS: !0,
            ADD_ATTR: [ "target" ]
        });
    }
}, function(module, exports) {
    module.exports = function(useSourceMap) {
        var list = [];
        return list.toString = function() {
            return this.map((function(item) {
                var content = function(item, useSourceMap) {
                    var content = item[1] || "", cssMapping = item[3];
                    if (!cssMapping) return content;
                    if (useSourceMap && "function" == typeof btoa) {
                        var sourceMapping = (sourceMap = cssMapping, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */"), sourceURLs = cssMapping.sources.map((function(source) {
                            return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
                        }));
                        return [ content ].concat(sourceURLs).concat([ sourceMapping ]).join("\n");
                    }
                    var sourceMap;
                    return [ content ].join("\n");
                }(item, useSourceMap);
                return item[2] ? "@media " + item[2] + "{" + content + "}" : content;
            })).join("");
        }, list.i = function(modules, mediaQuery) {
            "string" == typeof modules && (modules = [ [ null, modules, "" ] ]);
            for (var alreadyImportedModules = {}, i = 0; i < this.length; i++) {
                var id = this[i][0];
                "number" == typeof id && (alreadyImportedModules[id] = !0);
            }
            for (i = 0; i < modules.length; i++) {
                var item = modules[i];
                "number" == typeof item[0] && alreadyImportedModules[item[0]] || (mediaQuery && !item[2] ? item[2] = mediaQuery : mediaQuery && (item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"), 
                list.push(item));
            }
        }, list;
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "log", (function() {
        return log;
    })), __webpack_require__.d(__webpack_exports__, "error", (function() {
        return error;
    })), __webpack_require__.d(__webpack_exports__, "info", (function() {
        return info;
    })), __webpack_require__.d(__webpack_exports__, "debug", (function() {
        return debug;
    })), __webpack_require__.d(__webpack_exports__, "m", (function() {
        return m;
    }));
    const log = Function.prototype.bind.call(console.log, console, "%cMAL-Sync", "background-color: #2e51a2; color: white; padding: 2px 10px; border-radius: 3px;"), error = Function.prototype.bind.call(console.error, console, "%cMAL-Sync", "background-color: #8f0000; color: white; padding: 2px 10px; border-radius: 3px;"), info = Function.prototype.bind.call(console.info, console, "%cMAL-Sync", "background-color: wheat; color: black; padding: 2px 10px; border-radius: 3px;"), debug = Function.prototype.bind.call(console.debug, console, "%cMAL-Sync", "background-color: steelblue; color: black; padding: 2px 10px; border-radius: 3px;"), m = (name, color = "", blocks = []) => {
        let fontColor = "white";
        color || (color = function(str) {
            if (!str) return "#ffffff";
            str = String(str);
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            let colour = "#";
            for (let i = 0; i < 3; i++) {
                colour += ("00" + (hash >> 8 * i & 255).toString(16)).substr(-2);
            }
            return colour;
        }(name)), "#" === color[0] && (fontColor = parseInt(color.replace("#", ""), 16) > 8388607.5 ? "#000" : "#fff");
        const style = `background-color: ${color}; color: ${fontColor}; padding: 2px 10px; border-radius: 3px; margin-left: -5px; border-left: 1px solid white;`;
        blocks.push({
            name: name,
            style: style
        });
        const temp = {
            m: (name2, color2 = "") => m(name2, color2, [ ...blocks ])
        }, moduleText = blocks.reduce((sum, el) => `${sum}%c${el.name}`, ""), moduleStyle = blocks.map(el => el.style);
        return temp.log = Function.prototype.bind.call(console.log, console, "%cM " + moduleText, "background-color: #2e51a2; color: white; padding: 2px 10px; border-radius: 3px;", ...moduleStyle), 
        temp.error = Function.prototype.bind.call(console.error, console, "%cM " + moduleText, "background-color: #8f0000; color: white; padding: 2px 10px; border-radius: 3px;", ...moduleStyle), 
        temp.info = Function.prototype.bind.call(console.info, console, "%cM " + moduleText, "background-color: wheat; color: black; padding: 2px 10px; border-radius: 3px;", ...moduleStyle), 
        temp.debug = Function.prototype.bind.call(console.debug, console, "%cM " + moduleText, "background-color: steelblue; color: black; padding: 2px 10px; border-radius: 3px;", ...moduleStyle), 
        temp;
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var status, score, errorCode;
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return status;
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return errorCode;
    })), function(status) {
        status[status.NoState = 0] = "NoState", status[status.Watching = 1] = "Watching", 
        status[status.Completed = 2] = "Completed", status[status.Onhold = 3] = "Onhold", 
        status[status.Dropped = 4] = "Dropped", status[status.PlanToWatch = 6] = "PlanToWatch", 
        status[status.All = 7] = "All", status[status.Rewatching = 23] = "Rewatching";
    }(status || (status = {})), function(score) {
        score[score.NoScore = 0] = "NoScore", score[score.R1 = 1] = "R1", score[score.R2 = 2] = "R2", 
        score[score.R3 = 3] = "R3", score[score.R4 = 4] = "R4", score[score.R5 = 5] = "R5", 
        score[score.R6 = 6] = "R6", score[score.R7 = 7] = "R7", score[score.R8 = 8] = "R8", 
        score[score.R9 = 9] = "R9", score[score.R10 = 10] = "R10";
    }(score || (score = {})), function(errorCode) {
        errorCode[errorCode.UrlNotSuported = 901] = "UrlNotSuported", errorCode[errorCode.NotAutenticated = 902] = "NotAutenticated", 
        errorCode[errorCode.ServerOffline = 903] = "ServerOffline", errorCode[errorCode.EntryNotFound = 904] = "EntryNotFound", 
        errorCode[errorCode.GenericError = 905] = "GenericError";
    }(errorCode || (errorCode = {}));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
        var hook, options = "function" == typeof scriptExports ? scriptExports.options : scriptExports;
        if (render && (options.render = render, options.staticRenderFns = staticRenderFns, 
        options._compiled = !0), functionalTemplate && (options.functional = !0), scopeId && (options._scopeId = "data-v-" + scopeId), 
        moduleIdentifier ? (hook = function(context) {
            (context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (context = __VUE_SSR_CONTEXT__), 
            injectStyles && injectStyles.call(this, context), context && context._registeredComponents && context._registeredComponents.add(moduleIdentifier);
        }, options._ssrRegister = hook) : injectStyles && (hook = shadowMode ? function() {
            injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
        } : injectStyles), hook) if (options.functional) {
            options._injectStyles = hook;
            var originalRender = options.render;
            options.render = function(h, context) {
                return hook.call(context), originalRender(h, context);
            };
        } else {
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [ hook ];
        }
        return {
            exports: scriptExports,
            options: options
        };
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return normalizeComponent;
    }));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "f", (function() {
            return translateList;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getTitle;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getCacheKey;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return malToKitsu;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return kitsuToMal;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return apiCall;
        }));
        var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
        function translateList(aniStatus, malStatus = null) {
            const list = {
                current: 1,
                planned: 6,
                completed: 2,
                dropped: 4,
                on_hold: 3
            };
            return null !== malStatus ? Object.keys(list).find(key => list[key] === malStatus) : list[aniStatus];
        }
        function getTitle(titles, canonicalTitle) {
            let title;
            switch (api.settings.get("kitsuOptions").titleLanguagePreference) {
              case "english":
                title = titles.en;
                break;

              case "romanized":
                title = titles.en_jp;
                break;

              case "canonical":
              default:
                title = canonicalTitle;
            }
            if (void 0 !== title && title || (title = titles.en), void 0 !== title && title || (title = titles.en_jp), 
            void 0 !== title && title || (title = titles.ja_jp), void 0 === title || !title) {
                const keys = Object.keys(titles);
                if (!keys.length) return "No Title";
                title = titles[keys[0]];
            }
            return title;
        }
        function getCacheKey(id, kitsuId) {
            return Number.isNaN(id) || !id ? "kitsu:" + kitsuId : id;
        }
        function malToKitsu(malid, type) {
            return this.apiCall("GET", `https://kitsu.io/api/edge/mappings?filter[externalSite]=myanimelist/${type}&filter[externalId]=${malid}&include=item&fields[item]=id`, {}, !1);
        }
        function kitsuToMal(kitsuId, type) {
            return api.request.xhr("GET", {
                url: `https://kitsu.io/api/edge/${type}/${kitsuId}/mappings?filter[externalSite]=myanimelist/${type}`,
                headers: {
                    "Content-Type": "application/vnd.api+json",
                    Accept: "application/vnd.api+json"
                }
            }).then(response => {
                const res = JSON.parse(response.responseText);
                return con.log("[KtoM]", res), void 0 !== res.data && res.data.length ? res.data[0].attributes.externalId : null;
            });
        }
        function apiCall(mode, url, variables = {}, authentication = !0) {
            const headers = {
                "Content-Type": "application/vnd.api+json",
                Accept: "application/vnd.api+json"
            };
            return authentication && (headers.Authorization = "Bearer " + api.settings.get("kitsuToken")), 
            api.request.xhr(mode, {
                url: url,
                headers: headers,
                data: JSON.stringify(variables)
            }).then(response => {
                if (response.status > 499 && response.status < 600 || 0 === response.status) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline, "Server Offline status: " + response.status);
                if (204 === response.status) return {};
                const res = JSON.parse(response.responseText);
                if (void 0 !== res.errors && res.errors.length) {
                    this.logger.error("[SINGLE]", "Error", res.errors);
                    const error = res.errors[0];
                    switch (parseInt(error.status)) {
                      case 401:
                      case 403:
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated, error.detail);

                      case 404:
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.EntryNotFound, error.detail);

                      default:
                        throw this.errorObj(error.status, error.detail);
                    }
                }
                return res;
            });
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return client_id;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return translateList;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return getCacheKey;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return getEpisode;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return syncList;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return getSingle;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return call;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return errorHandling;
        }));
        var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const client_id = "39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0";
        function translateList(simklStatus, malStatus = null) {
            const list = {
                watching: 1,
                plantowatch: 6,
                completed: 2,
                notinteresting: 4,
                hold: 3
            };
            return null !== malStatus ? Object.keys(list).find(key => list[key] === malStatus) : list[simklStatus];
        }
        function getCacheKey(id, simklId) {
            return Number.isNaN(id) || !id ? "simkl:" + simklId : id;
        }
        function getEpisode(episode) {
            if ("number" == typeof episode) return episode;
            if (episode) {
                const temp = episode.match(/e\d+/i);
                if (null !== temp) {
                    const episodePart = parseInt(temp[0].replace(/\D/, ""));
                    return Number.isNaN(episodePart) ? 0 : episodePart;
                }
            }
            return 0;
        }
        let cacheList;
        function syncList(lazy = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                const logger = con.m("Simkl", "#9b7400").m("list");
                if (void 0 === cacheList) cacheList = yield api.storage.get("simklList"); else if (lazy) return cacheList;
                const lastCheck = yield api.storage.get("simklLastCheck"), activity = yield this.call("https://api.simkl.com/sync/activities");
                if (logger.log("Activity", lastCheck, activity.anime), lastCheck && lastCheck.removed_from_list !== activity.anime.removed_from_list) {
                    const checkRemoveList = yield this.call("https://api.simkl.com/sync/all-items/anime"), newCacheList = {};
                    if (checkRemoveList) for (let i = 0; i < checkRemoveList.anime.length; i++) {
                        const el = checkRemoveList.anime[i];
                        void 0 !== cacheList[el.show.ids.simkl] && (newCacheList[el.show.ids.simkl] = cacheList[el.show.ids.simkl]);
                    }
                    cacheList = newCacheList, logger.log("remove", cacheList);
                }
                let dateFrom = "";
                if (lastCheck && cacheList && (dateFrom = "date_from=" + lastCheck.all, lastCheck.all === activity.anime.all)) return logger.log("Up to date"), 
                cacheList;
                if (cacheList || (cacheList = {}), lastCheck && lastCheck.rated_at !== activity.anime.rated_at) {
                    const rated = yield this.call("https://api.simkl.com/sync/ratings/anime?" + dateFrom);
                    if (logger.log("ratedUpdate", rated), rated) for (let i = 0; i < rated.anime.length; i++) {
                        const el = rated.anime[i];
                        cacheList[el.show.ids.simkl] = el;
                    }
                }
                const list = yield this.call("https://api.simkl.com/sync/all-items/anime?" + dateFrom);
                if (logger.log("listUpdate", list), list) for (let i = 0; i < list.anime.length; i++) {
                    const el = list.anime[i];
                    cacheList[el.show.ids.simkl] = el;
                }
                return logger.log("totalList", cacheList), yield api.storage.set("simklList", cacheList), 
                yield api.storage.set("simklLastCheck", activity.anime), cacheList;
            }));
        }
        function getSingle(ids, lazy = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                const list = yield this.syncList(lazy);
                if (ids.simkl) {
                    if (void 0 !== list[ids.simkl]) return list[ids.simkl];
                } else {
                    if (!ids.mal) throw "No id passed";
                    {
                        const listVal = Object.values(list);
                        for (let i = 0; i < listVal.length; i++) {
                            const el = listVal[i];
                            if (void 0 !== el.show.ids.mal && Number(el.show.ids.mal) === Number(ids.mal)) return el;
                        }
                    }
                }
                return null;
            }));
        }
        function call(url, sData = {}, asParameter = !1, method = "GET", login = !0) {
            return __awaiter(this, void 0, void 0, (function*() {
                const logger = con.m("Simkl", "#9b7400").m("call");
                asParameter && (url += "?" + new URLSearchParams(Object.entries(sData)), sData = void 0), 
                logger.log(method, url, sData);
                const headers = {
                    "simkl-api-key": client_id,
                    Accept: "application/vnd.api+json",
                    "Content-Type": "application/json"
                };
                return login ? headers.Authorization = "Bearer " + api.settings.get("simklToken") : logger.log("No login"), 
                api.request.xhr(method, {
                    url: url,
                    headers: headers,
                    data: sData
                }).then(response => __awaiter(this, void 0, void 0, (function*() {
                    const res = this.jsonParse(response);
                    return this.errorHandling(res, response.status), res;
                })));
            }));
        }
        function errorHandling(res, code) {
            if (code > 499 && code < 600 || 0 === code) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline, "Server Offline status: " + code);
            if (res && void 0 !== res.error) {
                this.logger.error("[SINGLE]", "Error", res.error);
                const {error: error} = res;
                if (error.code) throw error.code, this.errorObj(error.code, error.error);
                switch (error) {
                  case "user_token_failed":
                    throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated, "user_token_failed");

                  default:
                    throw error;
                }
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "f", (function() {
            return translateList;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return statusTranslate;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return aniListToMal;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return malToAnilist;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getCacheKey;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return apiCall;
        }));
        var statusTranslate, _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
        function translateList(aniStatus, malStatus = null) {
            const list = {
                CURRENT: 1,
                PLANNING: 6,
                COMPLETED: 2,
                DROPPED: 4,
                PAUSED: 3,
                REPEATING: 1
            };
            return null !== malStatus ? Object.keys(list).find(key => list[key] === malStatus) : list[aniStatus];
        }
        function aniListToMal(anilistId, type) {
            const variables = {
                id: anilistId,
                type: type.toUpperCase()
            };
            return api.request.xhr("POST", {
                url: "https://graphql.anilist.co",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json"
                },
                data: JSON.stringify({
                    query: "\n  query ($id: Int, $type: MediaType) {\n    Media (id: $id, type: $type) {\n      id\n      idMal\n    }\n  }\n  ",
                    variables: variables
                })
            }).then(response => {
                const res = JSON.parse(response.responseText);
                return con.log(res), res.data.Media.idMal;
            });
        }
        function malToAnilist(malId, type) {
            const variables = {
                id: malId,
                type: type.toUpperCase()
            };
            return api.request.xhr("POST", {
                url: "https://graphql.anilist.co",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json"
                },
                data: JSON.stringify({
                    query: "\n  query ($id: Int, $type: MediaType) {\n    Media (idMal: $id, type: $type) {\n      id\n      idMal\n    }\n  }\n  ",
                    variables: variables
                })
            }).then(response => {
                const res = JSON.parse(response.responseText);
                return con.log(res), res.data.Media.id;
            });
        }
        function getCacheKey(id, kitsuId) {
            return Number.isNaN(id) || !id ? "anilist:" + kitsuId : id;
        }
        function apiCall(query, variables, authentication = !0) {
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            return authentication && (headers.Authorization = "Bearer " + api.settings.get("anilistToken")), 
            api.request.xhr("POST", {
                url: "https://graphql.anilist.co",
                headers: headers,
                data: JSON.stringify({
                    query: query,
                    variables: variables
                })
            }).then(response => {
                if (response.status > 499 && response.status < 600 || 0 === response.status) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline, "Server Offline status: " + response.status);
                const res = JSON.parse(response.responseText);
                if (void 0 !== res.errors && res.errors.length) {
                    this.logger.error("[SINGLE]", "Error", res.errors);
                    const error = res.errors[0];
                    switch (error.status) {
                      case 400:
                        if ("validation" === error.message) throw this.errorObj(error.status, "Wrong request format");
                        if (error.message.includes("invalid")) throw this.errorObj(error.status, "Wrong request format");
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated, error.message);

                      case 404:
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.EntryNotFound, error.message);

                      default:
                        throw this.errorObj(error.status, error.message);
                    }
                }
                return res;
            });
        }
        !function(statusTranslate) {
            statusTranslate[statusTranslate.CURRENT = 1] = "CURRENT", statusTranslate[statusTranslate.PLANNING = 6] = "PLANNING", 
            statusTranslate[statusTranslate.COMPLETED = 2] = "COMPLETED", statusTranslate[statusTranslate.DROPPED = 4] = "DROPPED", 
            statusTranslate[statusTranslate.PAUSED = 3] = "PAUSED", statusTranslate[statusTranslate.REPEATING = 23] = "REPEATING";
        }(statusTranslate || (statusTranslate = {}));
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "c", (function() {
            return authenticationUrl;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return apiCall;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return animeStatus;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return mangaStatus;
        }));
        var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5), _utils_oauth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const authenticationUrl = "https://malsync.moe/mal/oauth";
        function apiCall(options) {
            return __awaiter(this, void 0, void 0, (function*() {
                let url = "https://api.myanimelist.net/v2/" + options.path;
                options.fields && options.fields.length && (url += url.includes("?") ? "&" : "?", 
                url += "fields=" + options.fields.join(","));
                const headers = {
                    Authorization: "Bearer " + api.settings.get("malToken"),
                    "Content-Type": "application/x-www-form-urlencoded"
                };
                let data = "";
                if (options.dataObj) {
                    const formBody = [];
                    for (const property in options.dataObj) {
                        const encodedKey = encodeURIComponent(property), encodedValue = encodeURIComponent(options.dataObj[property]);
                        formBody.push(`${encodedKey}=${encodedValue}`);
                    }
                    data = formBody.join("&");
                }
                return api.request.xhr(options.type, {
                    url: url,
                    headers: headers,
                    data: data
                }).then(response => __awaiter(this, void 0, void 0, (function*() {
                    var _a, _b, _c;
                    if (response.status > 499 && response.status < 600 || 0 === response.status) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline, "Server Offline status: " + response.status);
                    let res;
                    try {
                        res = JSON.parse(response.responseText);
                    } catch (e) {
                        if (response.responseText.includes("Request blocked")) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.GenericError, "Your IP has been banned on MAL, change your IP or wait for it to get unbanned");
                        throw e;
                    }
                    if (res && res.error) switch (res.error) {
                      case "forbidden":
                      case "invalid_token":
                        if (yield function(logger) {
                            return __awaiter(this, void 0, void 0, (function*() {
                                const l = logger.m("Refresh");
                                l.log("Refresh Access Token");
                                const rToken = api.settings.get("malRefresh");
                                return !!rToken && api.request.xhr("POST", {
                                    url: "https://myanimelist.net/v1/oauth2/token",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    },
                                    data: `client_id=${_utils_oauth__WEBPACK_IMPORTED_MODULE_1__.a}&grant_type=refresh_token&refresh_token=${rToken}`
                                }).then(res => JSON.parse(res.responseText)).then(json => json && json.refresh_token && json.access_token ? (api.settings.set("malToken", json.access_token), 
                                api.settings.set("malRefresh", json.refresh_token), !0) : json && json.error ? (l.error(json.error, "|", json.message), 
                                api.settings.set("malRefresh", ""), !1) : (l.error("Something went wrong"), !1));
                            }));
                        }(this.logger)) return this.apiCall(options);
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated, null !== (_a = res.message) && void 0 !== _a ? _a : res.error);

                      case "not_found":
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.EntryNotFound, null !== (_b = res.message) && void 0 !== _b ? _b : res.error);

                      case "invalid_content":
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.GenericError, `This ${this.type} is currently pending approval. It canÂ´t be saved to mal for now`);

                      default:
                        throw this.errorObj(res.error, null !== (_c = res.message) && void 0 !== _c ? _c : res.error);
                    }
                    switch (response.status) {
                      case 400:
                        throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_0__.a.GenericError, "Invalid Parameters");
                    }
                    return res;
                })));
            }));
        }
        var animeStatus, mangaStatus;
        !function(animeStatus) {
            animeStatus[animeStatus.watching = 1] = "watching", animeStatus[animeStatus.completed = 2] = "completed", 
            animeStatus[animeStatus.on_hold = 3] = "on_hold", animeStatus[animeStatus.dropped = 4] = "dropped", 
            animeStatus[animeStatus.plan_to_watch = 6] = "plan_to_watch";
        }(animeStatus || (animeStatus = {})), function(mangaStatus) {
            mangaStatus[mangaStatus.reading = 1] = "reading", mangaStatus[mangaStatus.completed = 2] = "completed", 
            mangaStatus[mangaStatus.on_hold = 3] = "on_hold", mangaStatus[mangaStatus.dropped = 4] = "dropped", 
            mangaStatus[mangaStatus.plan_to_read = 6] = "plan_to_read";
        }(mangaStatus || (mangaStatus = {}));
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ScriptProxy;
        }));
        var _general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class ScriptProxy {
            constructor(elementId = Object(_general__WEBPACK_IMPORTED_MODULE_0__.generateUniqueID)()) {
                return this.elementId = elementId, this.capturedVariables = new Map, this;
            }
            addCaptureVariable(name, scriptContents) {
                this.capturedVariables.set(name, [ Object(_general__WEBPACK_IMPORTED_MODULE_0__.generateUniqueID)(), scriptContents ]);
            }
            getCaptureVariable(name) {
                const element = j.$("#" + this.elementId);
                if (null === element) return;
                const attrName = this.capturedVariables.get(name);
                if (void 0 === attrName) return;
                const elementContents = element.attr("data-" + attrName[0]);
                return void 0 !== elementContents ? JSON.parse(elementContents) : void 0;
            }
            addProxy(callback) {
                const previousElement = j.$("#" + this.elementId);
                null !== previousElement && previousElement.remove();
                const uniqueId = Object(_general__WEBPACK_IMPORTED_MODULE_0__.generateUniqueID)(), callbackFunction = event => {
                    if (!(event instanceof MessageEvent)) return;
                    event.data.uniqueId === uniqueId && (window.removeEventListener("message", callbackFunction), 
                    void 0 !== callback && callback(this));
                };
                window.addEventListener("message", callbackFunction, !1);
                let scriptContents = `\n      {\n        const element = document.getElementById('${this.elementId}');\n    `;
                this.capturedVariables.forEach((value, key) => {
                    const funcId = Object(_general__WEBPACK_IMPORTED_MODULE_0__.generateUniqueID)();
                    scriptContents += `\n        const func_${funcId} = () => {${value[1]}};\n        element.setAttribute('data-${value[0]}', JSON.stringify(func_${funcId}()));\n      `;
                }), scriptContents += `\n        window.postMessage({"uniqueId": "${uniqueId}"}, "*");\n      }\n    `;
                const scriptElement = document.createElement("script"), scriptTextElement = document.createTextNode(scriptContents);
                scriptElement.id = this.elementId, scriptElement.appendChild(scriptTextElement), 
                j.$("body").append(scriptElement);
            }
            getProxyVariable(name) {
                return __awaiter(this, void 0, void 0, (function*() {
                    return new Promise((resolve, reject) => {
                        this.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                            resolve(this.getCaptureVariable(name));
                        })));
                    });
                }));
            }
        }
    }).call(this, __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ZeroScans;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getInter;
        }));
        const ZeroScans = getInter();
        function getInter() {
            let thisSelf;
            return thisSelf = {
                name: "ZeroScans",
                domain: "https://zeroscans.com",
                languages: [ "English" ],
                type: "manga",
                isSyncPage: url => "comics" === url.split("/")[3] && url.split("/")[5] >= "1",
                sync: {
                    getTitle: url => j.$(".d-flex .heading h6.text-highlight").text().trim(),
                    getIdentifier: url => url.split("/")[4],
                    getOverviewUrl: url => j.$("div.container.py-5 div#pages-container div.d-flex div.btn-group a.btn").attr("href") || "",
                    getEpisode: url => Number(utils.urlPart(url, 6)),
                    getVolume: url => Number(url.split("/")[5]),
                    nextEpUrl: url => j.$("div#content.flex div.container.py-5 div#pages-container div.d-flex a:contains('Next')").attr("href")
                },
                overview: {
                    getTitle: url => j.$(".d-flex .heading h5.text-highlight").text().trim(),
                    getIdentifier: url => utils.urlPart(url, 4),
                    uiSelector(selector) {
                        j.$("div.col-lg-9.col-md-8.col-xs-12.text-muted div.row.py-2").first().before(j.html(`<div id= "MALSyncheading" class="heading"> <h6 class="text-highlight">MAL-Sync</h6></div><div id="malthing">${selector}</div>`));
                    },
                    list: {
                        offsetHandler: !1,
                        elementsSelector: () => j.$("div.list-item.col-sm-3"),
                        elementUrl: selector => selector.find("a").first().attr("href") || "",
                        elementEp: selector => selector.find("a").first().attr("href").split("/")[6]
                    }
                },
                init(page) {
                    api.storage.addStyle(__webpack_require__(479).toString()), j.$(document).ready((function() {
                        "comics" !== page.url.split("/")[3] || 5 !== page.url.split("/").length && 7 !== page.url.split("/").length || page.handlePage();
                    }));
                }
            }, thisSelf;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return combinedLinks;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return activeLinks;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return removeOptionKey;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return removeFromOptions;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const quicklinks = __webpack_require__(89);
        function titleSearch(url, title, id) {
            return url.replace("{searchterm}", encodeURIComponent(title.trim().toLowerCase())).replace("{searchtermPlus}", encodeURIComponent(title.trim().toLowerCase()).replace(/%20/g, "+")).replace("{searchtermRaw}", title.replace(/\//g, " ")).replace("{cacheId}", id);
        }
        function fillFromApi(combined, type, id) {
            return __awaiter(this, void 0, void 0, (function*() {
                const mal = yield function(type, id) {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const url = `https://api.malsync.moe/mal/${type}/${id}`;
                        return api.request.xhr("GET", url).then(response => __awaiter(this, void 0, void 0, (function*() {
                            if (con.log("malSync response", response), 400 === response.status) return {};
                            if (200 === response.status) {
                                const data = JSON.parse(response.responseText);
                                return data && data.Sites ? data.Sites : {};
                            }
                            throw new Error("malsync offline");
                        })));
                    }));
                }(type, id);
                return combined.map(el => (el.database && mal[el.database] && (el.databaseLinks = mal[el.database]), 
                el));
            }));
        }
        function combinedLinks() {
            const links = api.settings.get("quicklinks"), comb = [ ...links.filter(el => "object" == typeof el && el), ...quicklinks.filter(el => links.includes(el.name)) ];
            return JSON.parse(JSON.stringify(comb));
        }
        function activeLinks(type, id, searchterm) {
            return __awaiter(this, void 0, void 0, (function*() {
                let combined = combinedLinks();
                return id && (combined = yield fillFromApi(combined, type, id)), function(combined, type, searchterm, id) {
                    return combined.filter(el => el.search && el.search[type]).map(el => {
                        const links = [];
                        return el.databaseLinks ? Object.values(el.databaseLinks).forEach(db => {
                            links.push({
                                name: db.title,
                                url: db.url
                            });
                        }) : "home" === el.search[type] ? links.push({
                            name: "Homepage",
                            url: el.domain
                        }) : links.push({
                            name: "Quicksearch",
                            url: titleSearch(el.search[type], searchterm, id)
                        }), {
                            name: el.name,
                            domain: el.domain,
                            links: links
                        };
                    });
                }(combined, type, searchterm, id);
            }));
        }
        function removeOptionKey(options, key) {
            return key ? options.filter(el => el !== key && ("object" != typeof el || el.name !== key)) : options;
        }
        function removeFromOptions(key) {
            const options = api.settings.get("quicklinks");
            api.settings.set("quicklinks", removeOptionKey(options, key));
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Cache;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Cache {
            constructor(key, ttl, localStorage = !0) {
                return this.key = key, this.ttl = ttl, this.localStorage = localStorage, this;
            }
            hasValue() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const value = yield this.getStorage();
                    return null != value && (new Date).getTime() < value.timestamp;
                }));
            }
            hasValueAndIsNotEmpty() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const value = yield this.getStorage();
                    return !!(null != value && void 0 !== value.data && null !== value.data && Object.keys(value.data).length && (new Date).getTime() < value.timestamp);
                }));
            }
            getValue() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return (yield this.getStorage()).data;
                }));
            }
            setValue(result) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const save = {
                        data: result,
                        timestamp: (new Date).getTime() + this.ttl
                    };
                    return this.localStorage ? localStorage.setItem(this.key, JSON.stringify(save)) : api.storage.set(this.key, save);
                }));
            }
            getStorage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.localStorage ? JSON.parse(localStorage.getItem(this.key)) : api.storage.get(this.key);
                }));
            }
        }
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        function getSyncMode(type = "") {
            const mode = api.settings.get("syncMode");
            return "SIMKL" !== mode || "manga" !== type && -1 === type.indexOf("/manga/") ? mode : api.settings.get("syncModeSimkl");
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return getSyncMode;
        }));
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return getList;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getOnlyList;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getListbyType;
        }));
        var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15), _MyAnimeList_hybrid_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77), _MyAnimeList_api_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78), _AniList_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31), _Kitsu_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32), _Simkl_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28), _Local_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(102), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function getList(...args) {
            return __awaiter(this, void 0, void 0, (function*() {
                let tempList = [];
                if (api.settings.get("localSync")) {
                    const [status, listType] = args, localListEl = new _Local_list__WEBPACK_IMPORTED_MODULE_6__.a(status, listType);
                    localListEl.modes.initProgress = !0, tempList = yield localListEl.getCompleteList();
                }
                const list = getListObj(args);
                return list.setTemplist(tempList), list;
            }));
        }
        function getOnlyList(...args) {
            return getListObj(args);
        }
        function getListbyType(syncMode, args = []) {
            return getListObj(args, syncMode);
        }
        function getListObj(args, syncMode = "") {
            syncMode || (syncMode = _helper__WEBPACK_IMPORTED_MODULE_0__.a(args[1] ? args[1] : "anime"));
            const [status, listType, sorting] = args;
            if ("MAL" === syncMode) return new _MyAnimeList_hybrid_list__WEBPACK_IMPORTED_MODULE_1__.a(status, listType, sorting);
            if ("MALAPI" === syncMode) return new _MyAnimeList_api_list__WEBPACK_IMPORTED_MODULE_2__.a(status, listType, sorting);
            if ("ANILIST" === syncMode) return new _AniList_list__WEBPACK_IMPORTED_MODULE_3__.a(status, listType, sorting);
            if ("KITSU" === syncMode) return new _Kitsu_list__WEBPACK_IMPORTED_MODULE_4__.a(status, listType, sorting);
            if ("SIMKL" === syncMode) return new _Simkl_list__WEBPACK_IMPORTED_MODULE_5__.a(status, listType, sorting);
            throw "Unknown sync mode";
        }
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverviewAbstract;
        }));
        var _utils_Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverviewAbstract {
            constructor(url) {
                return this.url = url, this.run = !1, this.meta = {
                    title: "",
                    alternativeTitle: [],
                    description: "",
                    image: "",
                    characters: [],
                    statistics: [],
                    info: [],
                    openingSongs: [],
                    endingSongs: [],
                    related: []
                }, this.cacheObj = void 0, this.logger = con.m("Meta [O]", "green"), this;
            }
            init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.run ? this : (yield this.getCache().hasValueAndIsNotEmpty()) ? (this.logger.log("Cached"), 
                    this.meta = yield this.getCache().getValue(), this.run = !0, this) : (yield this._init(), 
                    this.run = !0, this.getCache().setValue(this.getMeta()), this);
                }));
            }
            getMeta() {
                return this.meta;
            }
            getCache() {
                return this.cacheObj || (this.cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_0__.a(this.url, 432e6)), 
                this.cacheObj;
            }
            errorObj(code, message) {
                return {
                    code: code,
                    message: message
                };
            }
        }
    }).call(this, __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return getSingle;
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return getCacheKey;
    }));
    var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15), _utils_Cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14), _MyAnimeList_hybrid_single__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74), _MyAnimeList_api_single__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75), _AniList_single__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33), _Kitsu_single__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34), _Simkl_single__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35), _Local_single__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(80), __awaiter = function(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))((function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator.throw(value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : function(value) {
                    return value instanceof P ? value : new P((function(resolve) {
                        resolve(value);
                    }));
                }(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        }));
    };
    function getSingle(url) {
        if (/^local:\/\//i.test(url)) return new _Local_single__WEBPACK_IMPORTED_MODULE_7__.a(url);
        const syncMode = _helper__WEBPACK_IMPORTED_MODULE_0__.a(url);
        if ("MAL" === syncMode) return new _MyAnimeList_hybrid_single__WEBPACK_IMPORTED_MODULE_2__.a(url);
        if ("MALAPI" === syncMode) return new _MyAnimeList_api_single__WEBPACK_IMPORTED_MODULE_3__.a(url);
        if ("ANILIST" === syncMode) return new _AniList_single__WEBPACK_IMPORTED_MODULE_4__.a(url);
        if ("KITSU" === syncMode) return new _Kitsu_single__WEBPACK_IMPORTED_MODULE_5__.a(url);
        if ("SIMKL" === syncMode) return new _Simkl_single__WEBPACK_IMPORTED_MODULE_6__.a(url);
        throw "Unknown sync mode";
    }
    function getCacheKey(url) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (/^https:\/\/myanimelist.net\/(anime|manga)\/\d+(\/|$)/.test(url)) return {
                cacheKey: url.split("/")[4]
            };
            const cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_1__.a("cacheKey/" + url, 6048e5);
            if (yield cacheObj.hasValue()) return cacheObj.getValue().then(res => ({
                cacheKey: res
            }));
            const singleObj = getSingle(url);
            return yield singleObj.update(), cacheObj.setValue(singleObj.getCacheKey()), {
                cacheKey: singleObj.getCacheKey(),
                singleObj: singleObj
            };
        }));
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return generateSync;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return getType;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return syncList;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return retriveLists;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return getListProvider;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getList;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return background;
        }));
        var _provider_MyAnimeList_hybrid_single__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74), _provider_AniList_single__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33), _provider_Kitsu_single__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34), _provider_Simkl_single__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35), _provider_MyAnimeList_hybrid_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77), _provider_AniList_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(31), _provider_Kitsu_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32), _provider_Simkl_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(28), _provider_helper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function generateSync(masterList, slaveLists, mode, typeArray, list, missing) {
            mapToArray(masterList, list, !0);
            for (const i in slaveLists) mapToArray(slaveLists[i], list, !1);
            for (const i in list) changeCheck(list[i], mode), missingCheck(list[i], missing, typeArray, mode);
        }
        function getType(url) {
            if (-1 !== url.indexOf("anilist.co")) return "ANILIST";
            if (-1 !== url.indexOf("kitsu.io")) return "KITSU";
            if (-1 !== url.indexOf("myanimelist.net")) return "MAL";
            if (-1 !== url.indexOf("simkl.com")) return "SIMKL";
            throw "Type not found";
        }
        function mapToArray(provierList, resultList, masterM = !1) {
            for (let i = 0; i < provierList.length; i++) {
                const el = provierList[i];
                let temp = resultList[el.malId];
                void 0 === temp && (temp = {
                    diff: !1,
                    master: {},
                    slaves: []
                }), masterM ? temp.master = el : (el.diff = {}, temp.slaves.push(el)), !Number.isNaN(el.malId) && el.malId && (resultList[el.malId] = temp);
            }
        }
        function changeCheck(item, mode) {
            if (item.master && item.master.uid) for (let i = 0; i < item.slaves.length; i++) {
                const slave = item.slaves[i];
                slave.watchedEp !== item.master.watchedEp && (2 === item.master.status ? slave.watchedEp !== slave.totalEp && (item.diff = !0, 
                slave.diff.watchedEp = slave.totalEp) : (item.diff = !0, slave.diff.watchedEp = item.master.watchedEp)), 
                slave.status !== item.master.status && (item.diff = !0, slave.diff.status = item.master.status), 
                slave.score !== item.master.score && (item.diff = !0, slave.diff.score = item.master.score);
            }
        }
        function missingCheck(item, missing, types, mode) {
            if (item.master && item.master.uid) {
                const tempTypes = [];
                tempTypes.push(getType(item.master.url));
                for (let i = 0; i < item.slaves.length; i++) {
                    const slave = item.slaves[i];
                    tempTypes.push(getType(slave.url));
                }
                for (const t in types) {
                    const type = types[t];
                    tempTypes.includes(type) || missing.push({
                        title: item.master.title,
                        syncType: type,
                        malId: item.master.malId,
                        watchedEp: item.master.watchedEp,
                        score: item.master.score,
                        status: item.master.status,
                        url: `https://myanimelist.net/${item.master.type}/${item.master.malId}`,
                        error: null
                    });
                }
            }
        }
        function syncList(list, thisMissing) {
            return __awaiter(this, void 0, void 0, (function*() {
                for (const i in list) {
                    const el = list[i];
                    if (el.diff) try {
                        yield syncListItem(el), el.diff = !1;
                    } catch (e) {
                        con.error(e);
                    }
                }
                const missing = thisMissing.slice();
                for (const i in missing) {
                    const miss = missing[i];
                    con.log("Sync missing", miss), yield syncMissing(miss).then(() => {
                        thisMissing.splice(thisMissing.indexOf(miss), 1);
                    }).catch(e => {
                        con.error("Error", e), miss.error = e;
                    });
                }
            }));
        }
        function syncListItem(item) {
            return __awaiter(this, void 0, void 0, (function*() {
                for (let i = 0; i < item.slaves.length; i++) {
                    const slave = item.slaves[i];
                    con.log("sync list item", slave), yield syncItem(slave, getType(slave.url));
                }
            }));
        }
        function syncMissing(item) {
            return __awaiter(this, void 0, void 0, (function*() {
                return item.diff = {
                    watchedEp: item.watchedEp,
                    status: item.status,
                    score: item.score
                }, syncItem(item, item.syncType);
            }));
        }
        function syncItem(slave, pageType) {
            if (0 !== Object.keys(slave.diff).length) {
                let singleClass;
                if ("MAL" === pageType) singleClass = new _provider_MyAnimeList_hybrid_single__WEBPACK_IMPORTED_MODULE_0__.a(slave.url); else if ("ANILIST" === pageType) singleClass = new _provider_AniList_single__WEBPACK_IMPORTED_MODULE_1__.a(slave.url); else if ("KITSU" === pageType) singleClass = new _provider_Kitsu_single__WEBPACK_IMPORTED_MODULE_2__.a(slave.url); else {
                    if ("SIMKL" !== pageType) throw "No sync type";
                    singleClass = new _provider_Simkl_single__WEBPACK_IMPORTED_MODULE_3__.a(slave.url);
                }
                return singleClass.update().then(() => (void 0 !== slave.diff.watchedEp && singleClass.setEpisode(slave.diff.watchedEp), 
                void 0 !== slave.diff.status && singleClass.setStatus(slave.diff.status), void 0 !== slave.diff.score && singleClass.setScore(slave.diff.score), 
                singleClass.sync())).then(() => new Promise(resolve => setTimeout(resolve, 3e3))).catch(e => new Promise((resolve, reject) => setTimeout(() => reject(e), 3e3)));
            }
        }
        function retriveLists(providerList, type, getListF) {
            return __awaiter(this, void 0, void 0, (function*() {
                const typeArray = [], masterMode = Object(_provider_helper__WEBPACK_IMPORTED_MODULE_8__.a)(type);
                if ("MALAPI" === masterMode) throw "Sync with the mal api is not yet supported";
                const listP = [];
                providerList.forEach(pi => {
                    pi.providerSettings.text = "Loading", listP.push(getListF(pi.listProvider, type).then(list => {
                        pi.providerSettings.list = list, pi.providerSettings.text = "Done", masterMode === pi.providerType && (pi.providerSettings.master = !0), 
                        typeArray.push(pi.providerType);
                    }).catch(e => {
                        pi.providerSettings.text = e;
                    }));
                }), yield Promise.all(listP);
                let master = !1;
                const slaves = [];
                return providerList.forEach((function(pi) {
                    pi.providerSettings.master ? master = pi.providerSettings.list : null !== pi.providerSettings.list && slaves.push(pi.providerSettings.list);
                })), {
                    master: master,
                    slaves: slaves,
                    typeArray: typeArray
                };
            }));
        }
        function getListProvider(providerSettingList) {
            return [ {
                providerType: "MAL",
                providerSettings: providerSettingList.mal,
                listProvider: _provider_MyAnimeList_hybrid_list__WEBPACK_IMPORTED_MODULE_4__.a
            }, {
                providerType: "ANILIST",
                providerSettings: providerSettingList.anilist,
                listProvider: _provider_AniList_list__WEBPACK_IMPORTED_MODULE_5__.a
            }, {
                providerType: "KITSU",
                providerSettings: providerSettingList.kitsu,
                listProvider: _provider_Kitsu_list__WEBPACK_IMPORTED_MODULE_6__.a
            }, {
                providerType: "SIMKL",
                providerSettings: providerSettingList.simkl,
                listProvider: _provider_Simkl_list__WEBPACK_IMPORTED_MODULE_7__.a
            } ];
        }
        function getList(Prov, type) {
            const listProvider = new Prov(7, type);
            return listProvider.getCompleteList().then(list => list).catch(e => {
                throw con.m(listProvider.name).error(e), listProvider.errorMessage(e);
            });
        }
        const background = {
            isEnabled() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.storage.get("backgroundListSync").then((function(state) {
                        return __awaiter(this, void 0, void 0, (function*() {
                            return con.info("background list sync state", state), !(!state || state.mode !== (yield api.settings.getAsync("syncMode"))) || (background.disable(), 
                            !1);
                        }));
                    }));
                }));
            },
            enable() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.storage.set("backgroundListSync", {
                        mode: yield api.settings.getAsync("syncMode")
                    });
                }));
            },
            disable: () => api.storage.remove("backgroundListSync"),
            sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return (yield background.isEnabled()) ? (con.log("Start Background list Sync"), 
                    setBadgeText("â™»"), syncLists("anime").then(() => syncLists("manga")).then(() => {
                        setBadgeText("");
                    }).catch(e => {
                        con.error(e), setBadgeText("");
                    })) : (con.error("Background list Sync not allowed"), []);
                    function syncLists(type) {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const list = {}, missing = [], providerList = getListProvider({
                                mal: {
                                    text: "Init",
                                    list: null,
                                    master: !1
                                },
                                anilist: {
                                    text: "Init",
                                    list: null,
                                    master: !1
                                },
                                kitsu: {
                                    text: "Init",
                                    list: null,
                                    master: !1
                                },
                                simkl: {
                                    text: "Init",
                                    list: null,
                                    master: !1
                                }
                            }), listOptions = yield retriveLists(providerList, type, getList);
                            generateSync(listOptions.master, listOptions.slaves, "mirror", listOptions.typeArray, list, missing), 
                            con.log("Start syncing", list, missing), yield syncList(list, missing);
                        }));
                    }
                }));
            }
        };
        function setBadgeText(text) {
            if ("userscript" !== api.type) try {
                chrome.browserAction.setBadgeText({
                    text: text
                });
            } catch (e) {
                con.error(e);
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils, api, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SingleAbstract;
        }));
        var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5), _utils_progress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76), _background_releaseProgress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22), _utils_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class SingleAbstract {
            constructor(url) {
                return this.url = url, this.type = null, this.rewatchingSupport = !0, this.ids = {
                    mal: NaN,
                    ani: NaN,
                    kitsu: {
                        id: NaN,
                        slug: ""
                    },
                    simkl: NaN
                }, this.options = null, this.progress = !1, this.prList = [], this.updateProgress = !1, 
                this._onList = !1, this._authenticated = !1, this.handleUrl(url), this.logger = con.m("[S]", "#348fff"), 
                this;
            }
            getType() {
                return this.type;
            }
            getUrl() {
                return this.url;
            }
            supportsRewatching() {
                return this.rewatchingSupport;
            }
            getApiCacheKey() {
                return this.ids.mal ? this.ids.mal : this.ids.ani ? "anilist:" + this.ids.ani : "";
            }
            setStatus(status) {
                return status = Number(status), this._setStatus(status), this;
            }
            getStatus() {
                return this.isOnList() ? this._getStatus() : _definitions__WEBPACK_IMPORTED_MODULE_0__.b.NoState;
            }
            setScore(score) {
                return (score = parseInt("" + score)) || (score = 0), this._setScore(score), this;
            }
            getScore() {
                const score = this._getScore();
                return score || 0;
            }
            setEpisode(episode) {
                return episode = parseInt("" + episode), this.getTotalEpisodes() && episode > this.getTotalEpisodes() && (episode = this.getTotalEpisodes()), 
                this._setEpisode(episode), this;
            }
            getEpisode() {
                return this._getEpisode();
            }
            setVolume(volume) {
                return this._setVolume(volume), this;
            }
            getVolume() {
                return this._getVolume();
            }
            setStreamingUrl(streamingUrl) {
                return this.options && (this.options.u = streamingUrl), this;
            }
            getStreamingUrl() {
                if (this.options && this.options.u) return this.options.u;
            }
            cleanTags() {
                this.options = null;
            }
            initProgress() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const xhr = yield Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_2__.b)(this.getType(), this.getApiCacheKey());
                    return this.prList = yield Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_2__.a)(this.getType()), 
                    new _utils_progress__WEBPACK_IMPORTED_MODULE_1__.a(this.getCacheKey(), this.getType()).init({
                        uid: this.getCacheKey(),
                        apiCacheKey: this.getApiCacheKey(),
                        title: this.getTitle(),
                        cacheKey: this.getCacheKey(),
                        progressMode: this.getProgressMode(),
                        watchedEp: this.getEpisode(),
                        single: this,
                        xhr: xhr
                    }).then(progress => {
                        this.progress = progress, this.progressXhr = xhr;
                    });
                }));
            }
            getProgress() {
                return !!this.progress && this.progress;
            }
            getProgressOptions() {
                const op = [];
                return this.progressXhr && Object.keys(this.progressXhr).length && this.progressXhr.forEach(el => {
                    if ("complete" === el.state) return;
                    let val = `${el.lang.toUpperCase()} (${el.type.toUpperCase()})`;
                    if (this.prList && this.prList.length) {
                        const tTemp = this.prList.find(p => p.key === el.id);
                        tTemp && (val = tTemp.label);
                    }
                    el.title && (val = el.title), el.lastEp && el.lastEp.total && (val += " EP" + el.lastEp.total), 
                    "dropped" === el.state && (val += " Incomplete"), op.push({
                        key: el.id,
                        value: val
                    });
                }), op;
            }
            getProgressMode() {
                return this.options && this.options.p ? this.options.p : "";
            }
            setProgressMode(mode) {
                this.options && (this.options.p = mode, this.updateProgress = !0);
            }
            getPageRelations() {
                const name = this.shortName, res = [];
                return this.ids.mal && "MAL" !== name && res.push({
                    name: "MAL",
                    icon: "https://cdn.myanimelist.net/images/favicon.ico",
                    link: `https://myanimelist.net/${this.type}/${this.ids.mal}`
                }), this.ids.ani && "AniList" !== name && res.push({
                    name: "AniList",
                    icon: "https://anilist.co/img/icons/favicon-32x32.png",
                    link: `https://anilist.co/${this.type}/${this.ids.ani}`
                }), this.ids.kitsu.id && "Kitsu" !== name && res.push({
                    name: "Kitsu",
                    icon: "https://kitsu.io/favicon-32x32-3e0ecb6fc5a6ae681e65dcbc2bdf1f17.png",
                    link: `https://kitsu.io/${this.type}/${this.ids.kitsu.id}`
                }), this.ids.simkl && "Simkl" !== name && res.push({
                    name: "Simkl",
                    icon: "https://eu.simkl.in/img_favicon/v2/favicon-32x32.png",
                    link: `https://simkl.com/${this.type}/${this.ids.simkl}`
                }), res;
            }
            fillRelations() {
                return Promise.resolve();
            }
            update() {
                return this.logger.log("[SINGLE]", "Update info", this.ids), this.lastError = null, 
                this._update().catch(e => {
                    throw this.lastError = e, e;
                }).then(() => (this.persistanceState = this.getStateEl(), utils.getEntrySettings(this.type, this.getCacheKey(), this._getTags()))).then(options => {
                    this.options = options, this.registerEvent();
                });
            }
            sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.logger.log("[SINGLE]", "Sync", this.ids), this.lastError = null, this._setTags(yield utils.setEntrySettings(this.type, this.getCacheKey(), this.options, this._getTags())), 
                    this._sync().catch(e => {
                        throw this.lastError = e, e;
                    }).then(() => {
                        this.undoState = this.persistanceState, this.updateProgress && this.initProgress(), 
                        this._onList = !0, this.emitUpdate();
                    });
                }));
            }
            emitUpdate() {
                _utils_emitter__WEBPACK_IMPORTED_MODULE_3__.a.emit("global.update." + this.getCacheKey(), !1, {
                    cacheKey: this.getCacheKey(),
                    state: this.getStateEl()
                });
            }
            registerEvent() {
                this.globalUpdateEvent || (this.globalUpdateEvent = _utils_emitter__WEBPACK_IMPORTED_MODULE_3__.a.on("global.update." + this.getCacheKey(), (ignore, data) => this.updateEvent(ignore, data)));
            }
            updateEvent(ignore, data) {
                JSON.stringify(this.persistanceState) === JSON.stringify(this.getStateEl()) ? data && data.state && (this.setStateEl(data.state), 
                this.persistanceState = this.getStateEl(), _utils_emitter__WEBPACK_IMPORTED_MODULE_3__.a.emit("syncPage_fillUi")) : this.logger.log("Ignore event");
            }
            undo() {
                if (this.logger.log("[SINGLE]", "Undo", this.undoState), !this.undoState) throw new Error("No undo state found");
                if (!this.undoState.onList) {
                    if (void 0 === this.delete) throw new Error("Deleting an entry is not supported");
                    return this.delete().then(() => {
                        this.setStateEl(this.undoState), this.undoState = null;
                    });
                }
                return this.setStateEl(this.undoState), this.sync().then(() => {
                    this.undoState = null;
                });
            }
            getTitle(raw = !1) {
                return this._getTitle(raw);
            }
            getTotalEpisodes() {
                let eps = this._getTotalEpisodes();
                return eps || (eps = 0), eps;
            }
            getTotalVolumes() {
                return this._getTotalVolumes();
            }
            isOnList() {
                return this._onList;
            }
            isAuthenticated() {
                return this._authenticated;
            }
            getDisplayUrl() {
                return this._getDisplayUrl();
            }
            getMalUrl() {
                if (!Number.isNaN(this.ids.mal)) {
                    let title;
                    try {
                        title = this.getTitle().replace(/\//, "_");
                    } catch (e) {
                        con.error("no title found");
                    }
                    return `https://myanimelist.net/${this.getType()}/${this.ids.mal}/${encodeURIComponent(title)}`;
                }
                return null;
            }
            getMalId() {
                return Number.isNaN(this.ids.mal) ? null : this.ids.mal;
            }
            getIds() {
                return this.ids;
            }
            getImage() {
                return this._getImage();
            }
            getRating() {
                return this._getRating().then(rating => rating || "N/A");
            }
            setResumeWatching(url, ep) {
                return utils.setResumeWaching(url, ep, this.type, this.getCacheKey());
            }
            getResumeWatching() {
                return this.options && this.options.r ? this.options.r : null;
            }
            setContinueWatching(url, ep) {
                return utils.setContinueWaching(url, ep, this.type, this.getCacheKey());
            }
            getContinueWatching() {
                return this.options && this.options.c ? this.options.c : null;
            }
            getStateEl() {
                return {
                    onList: this.isOnList(),
                    episode: this.getEpisode(),
                    volume: this.getVolume(),
                    status: this.getStatus(),
                    score: this.getScore()
                };
            }
            setStateEl(state) {
                this._onList = state.onList, this.setEpisode(state.episode), this.setVolume(state.volume), 
                this.setStatus(state.status), this.setScore(state.score);
            }
            getStateDiff() {
                const persistance = this.getStateEl();
                if (persistance && this.undoState) {
                    const diff = {};
                    for (const key in persistance) persistance[key] !== this.undoState[key] && (diff[key] = persistance[key]);
                    return diff;
                }
            }
            checkSync(episode, volume) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const curEpisode = this.getEpisode(), curStatus = this.getStatus(), curVolume = this.getVolume();
                    return curStatus === _definitions__WEBPACK_IMPORTED_MODULE_0__.b.Completed ? 1 === episode && this.startRewatchingMessage() : !(curEpisode >= episode && !(void 0 !== volume && (curVolume || volume > 1 || !episode) && volume > curVolume)) && (episode && episode === this.getTotalEpisodes() ? (curStatus === _definitions__WEBPACK_IMPORTED_MODULE_0__.b.Rewatching ? yield this.finishRewatchingMessage() : yield this.finishWatchingMessage(), 
                    !0) : curStatus === _definitions__WEBPACK_IMPORTED_MODULE_0__.b.Watching || curStatus === _definitions__WEBPACK_IMPORTED_MODULE_0__.b.Rewatching || this.startWatchingMessage());
                }));
            }
            startWatchingMessage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return utils.flashConfirm(api.storage.lang("syncPage_flashConfirm_start_" + this.getType()), "add").then(res => (res && this.setStatus(_definitions__WEBPACK_IMPORTED_MODULE_0__.b.Watching), 
                    res));
                }));
            }
            finishWatchingMessage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const currentScore = this.getScoreCheckboxValue();
                    let checkHtml = '<div><select id="finish_score" style="margin-top:5px; color:white; background-color:#4e4e4e; border: none;">';
                    return this.getScoreCheckbox().forEach(el => {
                        checkHtml += `<option value="${el.value}" ${String(currentScore) === el.value ? "selected" : ""}>${el.label}</option>`;
                    }), checkHtml += "</select></div>", utils.flashConfirm(api.storage.lang("syncPage_flashConfirm_complete") + checkHtml, "complete").then(res => {
                        if (res) {
                            this.setStatus(_definitions__WEBPACK_IMPORTED_MODULE_0__.b.Completed);
                            Number(j.$("#finish_score").val()) > 0 && (this.logger.log("finish_score: " + j.$("#finish_score :selected").val()), 
                            this.handleScoreCheckbox(j.$("#finish_score :selected").val()));
                        }
                        return res;
                    });
                }));
            }
            startRewatchingMessage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return utils.flashConfirm(api.storage.lang("syncPage_flashConfirm_rewatch_start_" + this.getType()), "add").then(res => (res && this.setStatus(_definitions__WEBPACK_IMPORTED_MODULE_0__.b.Rewatching), 
                    res));
                }));
            }
            finishRewatchingMessage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return utils.flashConfirm(api.storage.lang("syncPage_flashConfirm_rewatch_finish_" + this.getType()), "complete").then(res => (res && this.setStatus(_definitions__WEBPACK_IMPORTED_MODULE_0__.b.Completed), 
                    res));
                }));
            }
            getScoreCheckbox() {
                return [ {
                    value: "0",
                    label: api.storage.lang("UI_Score_Not_Rated")
                }, {
                    value: "10",
                    label: api.storage.lang("UI_Score_Masterpiece")
                }, {
                    value: "9",
                    label: api.storage.lang("UI_Score_Great")
                }, {
                    value: "8",
                    label: api.storage.lang("UI_Score_VeryGood")
                }, {
                    value: "7",
                    label: api.storage.lang("UI_Score_Good")
                }, {
                    value: "6",
                    label: api.storage.lang("UI_Score_Fine")
                }, {
                    value: "5",
                    label: api.storage.lang("UI_Score_Average")
                }, {
                    value: "4",
                    label: api.storage.lang("UI_Score_Bad")
                }, {
                    value: "3",
                    label: api.storage.lang("UI_Score_VeryBad")
                }, {
                    value: "2",
                    label: api.storage.lang("UI_Score_Horrible")
                }, {
                    value: "1",
                    label: api.storage.lang("UI_Score_Appalling")
                } ];
            }
            getScoreCheckboxValue() {
                return this.getScore();
            }
            handleScoreCheckbox(value) {
                this.setScore(value);
            }
            getDisplayScoreCheckbox() {
                const curScore = this.getScoreCheckboxValue(), labelEl = this.getScoreCheckbox().filter(el => el.value === String(curScore));
                return labelEl.length ? labelEl[0].label : "";
            }
            getStatusCheckbox() {
                const statusEs = [ {
                    value: "1",
                    label: api.storage.lang("UI_Status_watching_" + this.getType())
                }, {
                    value: "2",
                    label: api.storage.lang("UI_Status_Completed")
                }, {
                    value: "3",
                    label: api.storage.lang("UI_Status_OnHold")
                }, {
                    value: "4",
                    label: api.storage.lang("UI_Status_Dropped")
                }, {
                    value: "6",
                    label: api.storage.lang("UI_Status_planTo_" + this.getType())
                } ];
                return this.rewatchingSupport && statusEs.push({
                    value: "23",
                    label: api.storage.lang("UI_Status_Rewatching_" + this.getType())
                }), statusEs;
            }
            handleStatusCheckbox(value) {
                this.setStatus(value);
            }
            getStatusCheckboxValue() {
                return this.getStatus();
            }
            getLastError() {
                return this.lastError;
            }
            getLastErrorMessage() {
                return this.errorMessage(this.getLastError());
            }
            errorObj(code, message) {
                return {
                    code: code,
                    message: message
                };
            }
            flashmError(error) {
                utils.flashm(this.errorMessage(error), {
                    error: !0,
                    type: "error"
                });
            }
            errorMessage(error) {
                if (void 0 === error.code) return error;
                switch (error.code) {
                  case _definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated:
                    return api.storage.lang("Error_Authenticate", [ this.authenticationUrl ]);

                  case _definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline:
                    return `[${this.shortName}] Server Offline`;

                  case _definitions__WEBPACK_IMPORTED_MODULE_0__.a.UrlNotSuported:
                    return "Incorrect url provided";

                  case _definitions__WEBPACK_IMPORTED_MODULE_0__.a.EntryNotFound:
                    return `Entry for this ${this.getType()} could not be found on ${this.shortName}`;

                  default:
                    return error.message;
                }
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1), __webpack_require__(0), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ListAbstract;
        }));
        var _utils_Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), _utils_progress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76), _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5), _utils_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        Object.seal(_utils_emitter__WEBPACK_IMPORTED_MODULE_3__.a);
        class ListAbstract {
            constructor(status = 1, listType = "anime", sort = "default") {
                return this.status = status, this.listType = listType, this.sort = sort, this.done = !1, 
                this.loading = !1, this.firstLoaded = !1, this.seperateRewatching = !1, this.modes = {
                    frontend: !1,
                    sortAiring: !1,
                    initProgress: !1,
                    cached: !1
                }, this.username = "", this.offset = 0, this.templist = [], this.api = api, this.cacheObj = void 0, 
                this.status = Number(this.status), this.logger = con.m("[S]", "#348fff"), this;
            }
            setTemplist(list) {
                return this.templist = list, this;
            }
            getTemplist() {
                return this.templist;
            }
            setSort(sort) {
                if (this.firstLoaded || this.loading) throw "To late to change sort";
                this.sort = sort;
            }
            isDone() {
                return this.done;
            }
            isLoading() {
                return this.loading;
            }
            isFirstLoaded() {
                return this.firstLoaded;
            }
            getCompleteList() {
                return __awaiter(this, void 0, void 0, (function*() {
                    do {
                        yield this.getNext();
                    } while (!this.done);
                    return this.modes.sortAiring && (yield this.sortAiringList()), this.modes.cached && this.getCache().setValue(this.templist.slice(0, 18)), 
                    this.firstLoaded = !0, this.templist;
                }));
            }
            getNextPage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.done ? this.templist : this.modes.frontend && 1 === this.status && "default" === this.sort ? (this.modes.sortAiring = !0, 
                    this.getCompleteList()) : (yield this.getNext(), this.modes.cached && this.getCache().setValue(this.templist.slice(0, 18)), 
                    this.firstLoaded = !0, this.templist);
                }));
            }
            getNext() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.loading = !0;
                    const retList = yield this.getPart();
                    this.templist = this.templist.concat(retList), this.loading = !1;
                }));
            }
            getCached() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.getCache().hasValue()) {
                        const cachelist = yield this.getCache().getValue();
                        return cachelist.forEach(item => {
                            (item = this.fn(item)).watchedEp = "", item.score = "";
                        }), cachelist;
                    }
                    return [];
                }));
            }
            initFrontendMode() {
                this.modes.frontend = !0, this.updateListener = _utils_emitter__WEBPACK_IMPORTED_MODULE_3__.a.on("global.update.*", (ignore, data) => {
                    if (con.log("update", data), data.cacheKey) {
                        const item = this.templist.find(el => el.cacheKey === data.cacheKey);
                        con.log(item), item && data.state && (item.watchedEp = data.state.episode, item.score = data.state.score, 
                        item.status = data.state.status);
                    }
                }, {
                    objectify: !0
                });
            }
            destroy() {
                this.updateListener && this.updateListener.off();
            }
            getSortingOptions(tree = !1) {
                const res = [ {
                    icon: "filter_list",
                    title: "Default",
                    value: "default"
                } ];
                return this._getSortingOptions().forEach(el => {
                    if (el.asc) {
                        const asc = Object.assign({}, el);
                        delete asc.asc, asc.value += "_asc", asc.title += " Ascending", tree ? el.child = asc : res.push(asc);
                    }
                    delete el.asc, res.push(el);
                }), res;
            }
            jsonParse(response) {
                if ("" === response.responseText) throw {
                    code: 444,
                    message: "No Response"
                };
                try {
                    return JSON.parse(response.responseText);
                } catch (e) {
                    throw {
                        code: 406,
                        message: "Not Acceptable",
                        error: e
                    };
                }
            }
            flashmError(error) {
                utils.flashm(this.errorMessage(error), {
                    error: !0,
                    type: "error"
                });
            }
            errorMessage(error) {
                if (void 0 === error.code) return error;
                switch (error.code) {
                  case _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated:
                  case 400:
                  case 401:
                    return api.storage.lang("Error_Authenticate", [ this.authenticationUrl ]);

                  default:
                    return error.message;
                }
            }
            errorObj(code, message) {
                return {
                    code: code,
                    message: message
                };
            }
            fn(item, streamurl = "") {
                return __awaiter(this, void 0, void 0, (function*() {
                    let continueUrlTemp = null;
                    return item.fn = {
                        continueUrl: () => null !== continueUrlTemp ? continueUrlTemp : utils.getContinueWaching(item.type, item.cacheKey).then(obj => {
                            const curEp = parseInt(item.watchedEp.toString());
                            return void 0 === obj || obj.ep !== curEp + 1 ? "" : (continueUrlTemp = obj.url, 
                            continueUrlTemp);
                        }),
                        initProgress: () => new _utils_progress__WEBPACK_IMPORTED_MODULE_1__.a(item.cacheKey, item.type).init().then(progress => {
                            item.fn.progress = progress;
                        }),
                        progress: !1
                    }, item.options = yield utils.getEntrySettings(item.type, item.cacheKey, item.tags), 
                    streamurl && (item.options.u = streamurl), (this.modes.sortAiring || this.modes.initProgress) && (yield item.fn.initProgress()), 
                    item;
                }));
            }
            initProgress() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const listP = [];
                    this.templist.forEach(item => {
                        listP.push(item.fn.initProgress());
                    }), yield Promise.all(listP);
                }));
            }
            sortAiringList() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const normalItems = [];
                    let preItems = [], watchedItems = [];
                    function sortItems(a, b) {
                        let valA = a.fn.progress.getPredictionTimestamp(), valB = b.fn.progress.getPredictionTimestamp();
                        return valA || (valA = 999999999999), valB || (valB = valA), valA - valB;
                    }
                    this.templist.forEach(item => {
                        const prediction = item.fn.progress;
                        prediction && prediction.isAiring() && prediction.getPredictionTimestamp() ? item.watchedEp < prediction.getCurrentEpisode() ? preItems.push(item) : watchedItems.push(item) : normalItems.push(item);
                    }), preItems = preItems.sort(sortItems).reverse(), watchedItems = watchedItems.sort(sortItems), 
                    this.templist = preItems.concat(watchedItems, normalItems);
                }));
            }
            getCache() {
                return this.cacheObj || (this.cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_0__.a(`list/${this.name}/${this.listType}/${this.status}/${this.sort}`, 1728e5)), 
                this.cacheObj;
            }
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return predictionXhrGET;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return single;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return progressIsOld;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return getProgressTypeList;
        }));
        var _utils_Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14), __awaiter = (__webpack_require__(16), 
        function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        });
        function predictionXhrGET(type, apiCacheKey) {
            return __awaiter(this, void 0, void 0, (function*() {
                if (!apiCacheKey) return {};
                const response = yield api.request.xhr("GET", `https://api.malsync.moe/nc/mal/${type}/${apiCacheKey}/pr`);
                return JSON.parse(response.responseText);
            }));
        }
        function single(el, type, mode = "default", logger = con.m("release")) {
            return __awaiter(this, void 0, void 0, (function*() {
                if (mode || (mode = "default"), (logger = logger.m(el.uid.toString())).log(el.title, el.cacheKey, el.apiCacheKey, "Mode: " + mode), 
                !el.apiCacheKey) return void logger.log("No Api Cache Id");
                if (!api.settings.get("epPredictions")) return void logger.log("epPredictions disabled");
                const releaseItem = yield api.storage.get(`release/${type}/${el.cacheKey}`);
                logger.m("Load").log(releaseItem);
                let xhr, force = !1;
                if (releaseItem && releaseItem.mode && releaseItem.mode !== mode && (force = !0), 
                releaseItem && releaseItem.timestamp && Date.now() - releaseItem.timestamp < 12e4 && !force) return void logger.log("Up to date");
                if (releaseItem && releaseItem.finished && releaseItem.timestamp && Date.now() - releaseItem.timestamp < 6048e5 && !force) return void logger.log("Fininshed");
                if (releaseItem && !releaseItem.value && releaseItem.timestamp && Date.now() - releaseItem.timestamp < 864e5 && !force) return void logger.log("Nulled");
                force && logger.log("Update forced"), "off" === mode && (logger.log("Disabled"), 
                el.xhr = []), void 0 !== el.xhr ? xhr = el.xhr : (xhr = yield predictionXhrGET(type, el.apiCacheKey), 
                yield new Promise(resolve => setTimeout(() => resolve(), 500))), logger.log(xhr);
                const progressValue = getProgress(xhr, mode, type);
                progressValue || logger.log("No value for the selected mode");
                let finished = !1;
                progressValue && progressValue.state && "complete" === progressValue.state && (finished = !0), 
                logger.m("Save").log(progressValue), releaseItem && releaseItem.value && notificationCheck(el, releaseItem.value, progressValue, type), 
                yield api.storage.set(`release/${type}/${el.cacheKey}`, {
                    timestamp: Date.now(),
                    value: progressValue,
                    mode: mode,
                    finished: finished
                });
            }));
        }
        function progressIsOld(releaseItem) {
            if (releaseItem && releaseItem.timestamp) {
                const diff = (new Date).getTime() - releaseItem.timestamp;
                if (releaseItem.finished && diff < 6048e5) return !1;
                if (!releaseItem.value && diff < 864e5) return !1;
                if (diff < 864e5) return !1;
            }
            return !0;
        }
        function getProgress(res, mode, type) {
            const config = {};
            if (!res.length) return null;
            let top;
            if ("default" === mode ? (config.mainId = "anime" === type ? api.settings.get("progressIntervalDefaultAnime") : api.settings.get("progressIntervalDefaultManga"), 
            config.fallback = "en/sub") : config.mainId = mode, config.fallbackPrediction = "jp/dub", 
            config.mainId) {
                const mainTemp = res.find(el => el.id === config.mainId);
                mainTemp && (top = mainTemp);
            }
            if (config.fallback && !top) {
                const mainTemp = res.find(el => el.id === config.fallback);
                mainTemp && (top = mainTemp);
            }
            if (config.fallbackPrediction && top && !top.predicition && top.lastEp.timestamp) {
                const predTemp = res.find(el => el.id === config.fallbackPrediction), predTime = top.lastEp.timestamp + 6048e5;
                predTime && predTemp && predTemp.predicition && (top.lastEp.total === predTemp.lastEp.total ? Math.abs(predTime - predTemp.predicition.timestamp) < 108e6 && (top.predicition = {
                    timestamp: predTime,
                    probability: "medium"
                }) : predTemp.lastEp.total && top.lastEp.total === predTemp.lastEp.total - 1 && Math.abs(predTime - (predTemp.predicition.timestamp - 6048e5)) < 108e6 && (top.predicition = {
                    timestamp: predTime,
                    probability: "medium"
                }));
            }
            if (config.fallbackPrediction && !top) {
                const predSoon = res.find(el => el.id === config.fallbackPrediction);
                predSoon && predSoon.lastEp && predSoon.predicition && 0 === predSoon.lastEp.total && (top = predSoon, 
                top.predicition.probability = "medium");
            }
            return top || null;
        }
        function getProgressTypeList(type) {
            return __awaiter(this, void 0, void 0, (function*() {
                const cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_0__.a("ProgressTypeList" + type, 864e5, !1);
                if (!(yield cacheObj.hasValueAndIsNotEmpty())) {
                    con.log("Getting new ProgressTypeList Cache");
                    const url = "https://api.malsync.moe/general/progress/" + type, request = yield api.request.xhr("GET", url).then(response => __awaiter(this, void 0, void 0, (function*() {
                        return 200 === response.status && response.responseText ? JSON.parse(response.responseText) : [];
                    })));
                    return yield cacheObj.setValue(request), request;
                }
                return con.log("PageSearch Cached"), cacheObj.getValue();
            }));
        }
        function notificationCheck(el, cProgress, nProgress, type) {
            return __awaiter(this, void 0, void 0, (function*() {
                try {
                    if (!api.settings.get("progressNotifications")) return;
                    if (el && nProgress && nProgress && cProgress.lastEp && void 0 !== cProgress.lastEp.total && nProgress.lastEp && nProgress.lastEp.total && cProgress.lang === nProgress.lang && cProgress.type === nProgress.type && cProgress.lastEp.total < nProgress.lastEp.total && el.watchedEp + 1 === nProgress.lastEp.total) {
                        let noti;
                        noti = el.single ? {
                            title: el.title,
                            text: api.storage.lang("syncPage_malObj_nextEp_" + type, [ nProgress.lastEp.total ]),
                            sticky: !0,
                            image: yield el.single.getImage(),
                            url: el.single.getStreamingUrl() ? el.single.getStreamingUrl() : el.single.getUrl()
                        } : {
                            title: el.title,
                            text: api.storage.lang("syncPage_malObj_nextEp_" + type, [ nProgress.lastEp.total ]),
                            sticky: !0,
                            image: el.image,
                            url: el.options && el.options.u ? el.options.u : el.url
                        }, api.request.notification(noti);
                    }
                } catch (e) {
                    con.error("Could not check notification Progress", e);
                }
            }));
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return emitter;
        }));
        var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
        const scriptId = Math.floor(1e9 * Math.random()), emitter = new eventemitter2__WEBPACK_IMPORTED_MODULE_0__.EventEmitter2({
            wildcard: !0
        });
        void 0 !== api && api && "webextension" === api.type && (emitter.on("global.**", (function(ignore, ...params) {
            ignore || (con.m("Global").m("Emit").log(this.event, ...params), chrome.runtime.sendMessage({
                name: "emitter",
                item: {
                    event: this.event,
                    params: params,
                    id: scriptId
                }
            }));
        })), chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            message.name && "emitter" === message.name && (con.m("Global").m("Event").log(message.item.id, message.item.event, message.item.params), 
            message.item.id !== scriptId && emitter.emit(message.item.event, !0, ...message.item.params));
        }));
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return getCacheKey;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getSyncList;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getRegex;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function getCacheKey(id, page) {
            return `local:${id}:${page}`;
        }
        function getSyncList() {
            return __awaiter(this, void 0, void 0, (function*() {
                let data;
                if ("userscript" === api.type) {
                    const list = yield api.storage.list("sync");
                    for (const key in list) list[key] = yield api.storage.get(key);
                    data = list;
                } else data = api.storage.list("sync");
                return data;
            }));
        }
        function getRegex(listType) {
            return new RegExp("^local://[^/]*/" + listType, "i");
        }
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "backbutton-settings bg-cell mdl-grid",
            on: {
                click: this.click
            }
        }, [ _c("span", {
            staticClass: "material-icons"
        }, [ this._v("arrow_back") ]), this._v("\n  " + this._s(this.lang("minimalApp_Settings")) + "\n") ]);
    };
    render._withStripped = !0;
    var components_backbuttonvue_type_script_lang_js_ = __webpack_require__(67).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_backbuttonvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/backbutton.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global, setImmediate) {
        var emptyObject = Object.freeze({});
        function isUndef(v) {
            return null == v;
        }
        function isDef(v) {
            return null != v;
        }
        function isTrue(v) {
            return !0 === v;
        }
        function isPrimitive(value) {
            return "string" == typeof value || "number" == typeof value || "symbol" == typeof value || "boolean" == typeof value;
        }
        function isObject(obj) {
            return null !== obj && "object" == typeof obj;
        }
        var _toString = Object.prototype.toString;
        function isPlainObject(obj) {
            return "[object Object]" === _toString.call(obj);
        }
        function isRegExp(v) {
            return "[object RegExp]" === _toString.call(v);
        }
        function isValidArrayIndex(val) {
            var n = parseFloat(String(val));
            return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        function isPromise(val) {
            return isDef(val) && "function" == typeof val.then && "function" == typeof val.catch;
        }
        function toString(val) {
            return null == val ? "" : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
        }
        function toNumber(val) {
            var n = parseFloat(val);
            return isNaN(n) ? val : n;
        }
        function makeMap(str, expectsLowerCase) {
            for (var map = Object.create(null), list = str.split(","), i = 0; i < list.length; i++) map[list[i]] = !0;
            return expectsLowerCase ? function(val) {
                return map[val.toLowerCase()];
            } : function(val) {
                return map[val];
            };
        }
        var isBuiltInTag = makeMap("slot,component", !0), isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
        function remove(arr, item) {
            if (arr.length) {
                var index = arr.indexOf(item);
                if (index > -1) return arr.splice(index, 1);
            }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }
        function cached(fn) {
            var cache = Object.create(null);
            return function(str) {
                return cache[str] || (cache[str] = fn(str));
            };
        }
        var camelizeRE = /-(\w)/g, camelize = cached((function(str) {
            return str.replace(camelizeRE, (function(_, c) {
                return c ? c.toUpperCase() : "";
            }));
        })), capitalize = cached((function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        })), hyphenateRE = /\B([A-Z])/g, hyphenate = cached((function(str) {
            return str.replace(hyphenateRE, "-$1").toLowerCase();
        }));
        var bind = Function.prototype.bind ? function(fn, ctx) {
            return fn.bind(ctx);
        } : function(fn, ctx) {
            function boundFn(a) {
                var l = arguments.length;
                return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
            }
            return boundFn._length = fn.length, boundFn;
        };
        function toArray(list, start) {
            start = start || 0;
            for (var i = list.length - start, ret = new Array(i); i--; ) ret[i] = list[i + start];
            return ret;
        }
        function extend(to, _from) {
            for (var key in _from) to[key] = _from[key];
            return to;
        }
        function toObject(arr) {
            for (var res = {}, i = 0; i < arr.length; i++) arr[i] && extend(res, arr[i]);
            return res;
        }
        function noop(a, b, c) {}
        var no = function(a, b, c) {
            return !1;
        }, identity = function(_) {
            return _;
        };
        function looseEqual(a, b) {
            if (a === b) return !0;
            var isObjectA = isObject(a), isObjectB = isObject(b);
            if (!isObjectA || !isObjectB) return !isObjectA && !isObjectB && String(a) === String(b);
            try {
                var isArrayA = Array.isArray(a), isArrayB = Array.isArray(b);
                if (isArrayA && isArrayB) return a.length === b.length && a.every((function(e, i) {
                    return looseEqual(e, b[i]);
                }));
                if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
                if (isArrayA || isArrayB) return !1;
                var keysA = Object.keys(a), keysB = Object.keys(b);
                return keysA.length === keysB.length && keysA.every((function(key) {
                    return looseEqual(a[key], b[key]);
                }));
            } catch (e) {
                return !1;
            }
        }
        function looseIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) if (looseEqual(arr[i], val)) return i;
            return -1;
        }
        function once(fn) {
            var called = !1;
            return function() {
                called || (called = !0, fn.apply(this, arguments));
            };
        }
        var ASSET_TYPES = [ "component", "directive", "filter" ], LIFECYCLE_HOOKS = [ "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch" ], config = {
            optionMergeStrategies: Object.create(null),
            silent: !1,
            productionTip: !1,
            devtools: !1,
            performance: !1,
            errorHandler: null,
            warnHandler: null,
            ignoredElements: [],
            keyCodes: Object.create(null),
            isReservedTag: no,
            isReservedAttr: no,
            isUnknownElement: no,
            getTagNamespace: noop,
            parsePlatformTagName: identity,
            mustUseProp: no,
            async: !0,
            _lifecycleHooks: LIFECYCLE_HOOKS
        }, unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        function isReserved(str) {
            var c = (str + "").charCodeAt(0);
            return 36 === c || 95 === c;
        }
        function def(obj, key, val, enumerable) {
            Object.defineProperty(obj, key, {
                value: val,
                enumerable: !!enumerable,
                writable: !0,
                configurable: !0
            });
        }
        var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
        var _isServer, hasProto = "__proto__" in {}, inBrowser = "undefined" != typeof window, inWeex = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform, weexPlatform = inWeex && WXEnvironment.platform.toLowerCase(), UA = inBrowser && window.navigator.userAgent.toLowerCase(), isIE = UA && /msie|trident/.test(UA), isIE9 = UA && UA.indexOf("msie 9.0") > 0, isEdge = UA && UA.indexOf("edge/") > 0, isIOS = (UA && UA.indexOf("android"), 
        UA && /iphone|ipad|ipod|ios/.test(UA) || "ios" === weexPlatform), isFF = (UA && /chrome\/\d+/.test(UA), 
        UA && /phantomjs/.test(UA), UA && UA.match(/firefox\/(\d+)/)), nativeWatch = {}.watch, supportsPassive = !1;
        if (inBrowser) try {
            var opts = {};
            Object.defineProperty(opts, "passive", {
                get: function() {
                    supportsPassive = !0;
                }
            }), window.addEventListener("test-passive", null, opts);
        } catch (e) {}
        var isServerRendering = function() {
            return void 0 === _isServer && (_isServer = !inBrowser && !inWeex && void 0 !== global && (global.process && "server" === global.process.env.VUE_ENV)), 
            _isServer;
        }, devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        function isNative(Ctor) {
            return "function" == typeof Ctor && /native code/.test(Ctor.toString());
        }
        var _Set, hasSymbol = "undefined" != typeof Symbol && isNative(Symbol) && "undefined" != typeof Reflect && isNative(Reflect.ownKeys);
        _Set = "undefined" != typeof Set && isNative(Set) ? Set : function() {
            function Set() {
                this.set = Object.create(null);
            }
            return Set.prototype.has = function(key) {
                return !0 === this.set[key];
            }, Set.prototype.add = function(key) {
                this.set[key] = !0;
            }, Set.prototype.clear = function() {
                this.set = Object.create(null);
            }, Set;
        }();
        var warn = noop, uid = 0, Dep = function() {
            this.id = uid++, this.subs = [];
        };
        Dep.prototype.addSub = function(sub) {
            this.subs.push(sub);
        }, Dep.prototype.removeSub = function(sub) {
            remove(this.subs, sub);
        }, Dep.prototype.depend = function() {
            Dep.target && Dep.target.addDep(this);
        }, Dep.prototype.notify = function() {
            var subs = this.subs.slice();
            for (var i = 0, l = subs.length; i < l; i++) subs[i].update();
        }, Dep.target = null;
        var targetStack = [];
        function pushTarget(target) {
            targetStack.push(target), Dep.target = target;
        }
        function popTarget() {
            targetStack.pop(), Dep.target = targetStack[targetStack.length - 1];
        }
        var VNode = function(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
            this.tag = tag, this.data = data, this.children = children, this.text = text, this.elm = elm, 
            this.ns = void 0, this.context = context, this.fnContext = void 0, this.fnOptions = void 0, 
            this.fnScopeId = void 0, this.key = data && data.key, this.componentOptions = componentOptions, 
            this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, 
            this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, 
            this.asyncFactory = asyncFactory, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
        }, prototypeAccessors = {
            child: {
                configurable: !0
            }
        };
        prototypeAccessors.child.get = function() {
            return this.componentInstance;
        }, Object.defineProperties(VNode.prototype, prototypeAccessors);
        var createEmptyVNode = function(text) {
            void 0 === text && (text = "");
            var node = new VNode;
            return node.text = text, node.isComment = !0, node;
        };
        function createTextVNode(val) {
            return new VNode(void 0, void 0, void 0, String(val));
        }
        function cloneVNode(vnode) {
            var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
            return cloned.ns = vnode.ns, cloned.isStatic = vnode.isStatic, cloned.key = vnode.key, 
            cloned.isComment = vnode.isComment, cloned.fnContext = vnode.fnContext, cloned.fnOptions = vnode.fnOptions, 
            cloned.fnScopeId = vnode.fnScopeId, cloned.asyncMeta = vnode.asyncMeta, cloned.isCloned = !0, 
            cloned;
        }
        var arrayProto = Array.prototype, arrayMethods = Object.create(arrayProto);
        [ "push", "pop", "shift", "unshift", "splice", "sort", "reverse" ].forEach((function(method) {
            var original = arrayProto[method];
            def(arrayMethods, method, (function() {
                for (var args = [], len = arguments.length; len--; ) args[len] = arguments[len];
                var inserted, result = original.apply(this, args), ob = this.__ob__;
                switch (method) {
                  case "push":
                  case "unshift":
                    inserted = args;
                    break;

                  case "splice":
                    inserted = args.slice(2);
                }
                return inserted && ob.observeArray(inserted), ob.dep.notify(), result;
            }));
        }));
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods), shouldObserve = !0;
        function toggleObserving(value) {
            shouldObserve = value;
        }
        var Observer = function(value) {
            this.value = value, this.dep = new Dep, this.vmCount = 0, def(value, "__ob__", this), 
            Array.isArray(value) ? (hasProto ? function(target, src) {
                target.__proto__ = src;
            }(value, arrayMethods) : function(target, src, keys) {
                for (var i = 0, l = keys.length; i < l; i++) {
                    var key = keys[i];
                    def(target, key, src[key]);
                }
            }(value, arrayMethods, arrayKeys), this.observeArray(value)) : this.walk(value);
        };
        function observe(value, asRootData) {
            var ob;
            if (isObject(value) && !(value instanceof VNode)) return hasOwn(value, "__ob__") && value.__ob__ instanceof Observer ? ob = value.__ob__ : shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue && (ob = new Observer(value)), 
            asRootData && ob && ob.vmCount++, ob;
        }
        function defineReactive$$1(obj, key, val, customSetter, shallow) {
            var dep = new Dep, property = Object.getOwnPropertyDescriptor(obj, key);
            if (!property || !1 !== property.configurable) {
                var getter = property && property.get, setter = property && property.set;
                getter && !setter || 2 !== arguments.length || (val = obj[key]);
                var childOb = !shallow && observe(val);
                Object.defineProperty(obj, key, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        var value = getter ? getter.call(obj) : val;
                        return Dep.target && (dep.depend(), childOb && (childOb.dep.depend(), Array.isArray(value) && dependArray(value))), 
                        value;
                    },
                    set: function(newVal) {
                        var value = getter ? getter.call(obj) : val;
                        newVal === value || newVal != newVal && value != value || getter && !setter || (setter ? setter.call(obj, newVal) : val = newVal, 
                        childOb = !shallow && observe(newVal), dep.notify());
                    }
                });
            }
        }
        function set(target, key, val) {
            if (Array.isArray(target) && isValidArrayIndex(key)) return target.length = Math.max(target.length, key), 
            target.splice(key, 1, val), val;
            if (key in target && !(key in Object.prototype)) return target[key] = val, val;
            var ob = target.__ob__;
            return target._isVue || ob && ob.vmCount ? val : ob ? (defineReactive$$1(ob.value, key, val), 
            ob.dep.notify(), val) : (target[key] = val, val);
        }
        function del(target, key) {
            if (Array.isArray(target) && isValidArrayIndex(key)) target.splice(key, 1); else {
                var ob = target.__ob__;
                target._isVue || ob && ob.vmCount || hasOwn(target, key) && (delete target[key], 
                ob && ob.dep.notify());
            }
        }
        function dependArray(value) {
            for (var e = void 0, i = 0, l = value.length; i < l; i++) (e = value[i]) && e.__ob__ && e.__ob__.dep.depend(), 
            Array.isArray(e) && dependArray(e);
        }
        Observer.prototype.walk = function(obj) {
            for (var keys = Object.keys(obj), i = 0; i < keys.length; i++) defineReactive$$1(obj, keys[i]);
        }, Observer.prototype.observeArray = function(items) {
            for (var i = 0, l = items.length; i < l; i++) observe(items[i]);
        };
        var strats = config.optionMergeStrategies;
        function mergeData(to, from) {
            if (!from) return to;
            for (var key, toVal, fromVal, keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from), i = 0; i < keys.length; i++) "__ob__" !== (key = keys[i]) && (toVal = to[key], 
            fromVal = from[key], hasOwn(to, key) ? toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal) && mergeData(toVal, fromVal) : set(to, key, fromVal));
            return to;
        }
        function mergeDataOrFn(parentVal, childVal, vm) {
            return vm ? function() {
                var instanceData = "function" == typeof childVal ? childVal.call(vm, vm) : childVal, defaultData = "function" == typeof parentVal ? parentVal.call(vm, vm) : parentVal;
                return instanceData ? mergeData(instanceData, defaultData) : defaultData;
            } : childVal ? parentVal ? function() {
                return mergeData("function" == typeof childVal ? childVal.call(this, this) : childVal, "function" == typeof parentVal ? parentVal.call(this, this) : parentVal);
            } : childVal : parentVal;
        }
        function mergeHook(parentVal, childVal) {
            var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [ childVal ] : parentVal;
            return res ? function(hooks) {
                for (var res = [], i = 0; i < hooks.length; i++) -1 === res.indexOf(hooks[i]) && res.push(hooks[i]);
                return res;
            }(res) : res;
        }
        function mergeAssets(parentVal, childVal, vm, key) {
            var res = Object.create(parentVal || null);
            return childVal ? extend(res, childVal) : res;
        }
        strats.data = function(parentVal, childVal, vm) {
            return vm ? mergeDataOrFn(parentVal, childVal, vm) : childVal && "function" != typeof childVal ? parentVal : mergeDataOrFn(parentVal, childVal);
        }, LIFECYCLE_HOOKS.forEach((function(hook) {
            strats[hook] = mergeHook;
        })), ASSET_TYPES.forEach((function(type) {
            strats[type + "s"] = mergeAssets;
        })), strats.watch = function(parentVal, childVal, vm, key) {
            if (parentVal === nativeWatch && (parentVal = void 0), childVal === nativeWatch && (childVal = void 0), 
            !childVal) return Object.create(parentVal || null);
            if (!parentVal) return childVal;
            var ret = {};
            for (var key$1 in extend(ret, parentVal), childVal) {
                var parent = ret[key$1], child = childVal[key$1];
                parent && !Array.isArray(parent) && (parent = [ parent ]), ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [ child ];
            }
            return ret;
        }, strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
            if (!parentVal) return childVal;
            var ret = Object.create(null);
            return extend(ret, parentVal), childVal && extend(ret, childVal), ret;
        }, strats.provide = mergeDataOrFn;
        var defaultStrat = function(parentVal, childVal) {
            return void 0 === childVal ? parentVal : childVal;
        };
        function mergeOptions(parent, child, vm) {
            if ("function" == typeof child && (child = child.options), function(options, vm) {
                var props = options.props;
                if (props) {
                    var i, val, res = {};
                    if (Array.isArray(props)) for (i = props.length; i--; ) "string" == typeof (val = props[i]) && (res[camelize(val)] = {
                        type: null
                    }); else if (isPlainObject(props)) for (var key in props) val = props[key], res[camelize(key)] = isPlainObject(val) ? val : {
                        type: val
                    }; else 0;
                    options.props = res;
                }
            }(child), function(options, vm) {
                var inject = options.inject;
                if (inject) {
                    var normalized = options.inject = {};
                    if (Array.isArray(inject)) for (var i = 0; i < inject.length; i++) normalized[inject[i]] = {
                        from: inject[i]
                    }; else if (isPlainObject(inject)) for (var key in inject) {
                        var val = inject[key];
                        normalized[key] = isPlainObject(val) ? extend({
                            from: key
                        }, val) : {
                            from: val
                        };
                    } else 0;
                }
            }(child), function(options) {
                var dirs = options.directives;
                if (dirs) for (var key in dirs) {
                    var def$$1 = dirs[key];
                    "function" == typeof def$$1 && (dirs[key] = {
                        bind: def$$1,
                        update: def$$1
                    });
                }
            }(child), !child._base && (child.extends && (parent = mergeOptions(parent, child.extends, vm)), 
            child.mixins)) for (var i = 0, l = child.mixins.length; i < l; i++) parent = mergeOptions(parent, child.mixins[i], vm);
            var key, options = {};
            for (key in parent) mergeField(key);
            for (key in child) hasOwn(parent, key) || mergeField(key);
            function mergeField(key) {
                var strat = strats[key] || defaultStrat;
                options[key] = strat(parent[key], child[key], vm, key);
            }
            return options;
        }
        function resolveAsset(options, type, id, warnMissing) {
            if ("string" == typeof id) {
                var assets = options[type];
                if (hasOwn(assets, id)) return assets[id];
                var camelizedId = camelize(id);
                if (hasOwn(assets, camelizedId)) return assets[camelizedId];
                var PascalCaseId = capitalize(camelizedId);
                return hasOwn(assets, PascalCaseId) ? assets[PascalCaseId] : assets[id] || assets[camelizedId] || assets[PascalCaseId];
            }
        }
        function validateProp(key, propOptions, propsData, vm) {
            var prop = propOptions[key], absent = !hasOwn(propsData, key), value = propsData[key], booleanIndex = getTypeIndex(Boolean, prop.type);
            if (booleanIndex > -1) if (absent && !hasOwn(prop, "default")) value = !1; else if ("" === value || value === hyphenate(key)) {
                var stringIndex = getTypeIndex(String, prop.type);
                (stringIndex < 0 || booleanIndex < stringIndex) && (value = !0);
            }
            if (void 0 === value) {
                value = function(vm, prop, key) {
                    if (!hasOwn(prop, "default")) return;
                    var def = prop.default;
                    0;
                    if (vm && vm.$options.propsData && void 0 === vm.$options.propsData[key] && void 0 !== vm._props[key]) return vm._props[key];
                    return "function" == typeof def && "Function" !== getType(prop.type) ? def.call(vm) : def;
                }(vm, prop, key);
                var prevShouldObserve = shouldObserve;
                toggleObserving(!0), observe(value), toggleObserving(prevShouldObserve);
            }
            return value;
        }
        function getType(fn) {
            var match = fn && fn.toString().match(/^\s*function (\w+)/);
            return match ? match[1] : "";
        }
        function isSameType(a, b) {
            return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
            if (!Array.isArray(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
            for (var i = 0, len = expectedTypes.length; i < len; i++) if (isSameType(expectedTypes[i], type)) return i;
            return -1;
        }
        function handleError(err, vm, info) {
            pushTarget();
            try {
                if (vm) for (var cur = vm; cur = cur.$parent; ) {
                    var hooks = cur.$options.errorCaptured;
                    if (hooks) for (var i = 0; i < hooks.length; i++) try {
                        if (!1 === hooks[i].call(cur, err, vm, info)) return;
                    } catch (e) {
                        globalHandleError(e, cur, "errorCaptured hook");
                    }
                }
                globalHandleError(err, vm, info);
            } finally {
                popTarget();
            }
        }
        function invokeWithErrorHandling(handler, context, args, vm, info) {
            var res;
            try {
                (res = args ? handler.apply(context, args) : handler.call(context)) && !res._isVue && isPromise(res) && !res._handled && (res.catch((function(e) {
                    return handleError(e, vm, info + " (Promise/async)");
                })), res._handled = !0);
            } catch (e) {
                handleError(e, vm, info);
            }
            return res;
        }
        function globalHandleError(err, vm, info) {
            if (config.errorHandler) try {
                return config.errorHandler.call(null, err, vm, info);
            } catch (e) {
                e !== err && logError(e, null, "config.errorHandler");
            }
            logError(err, vm, info);
        }
        function logError(err, vm, info) {
            if (!inBrowser && !inWeex || "undefined" == typeof console) throw err;
            console.error(err);
        }
        var timerFunc, isUsingMicroTask = !1, callbacks = [], pending = !1;
        function flushCallbacks() {
            pending = !1;
            var copies = callbacks.slice(0);
            callbacks.length = 0;
            for (var i = 0; i < copies.length; i++) copies[i]();
        }
        if ("undefined" != typeof Promise && isNative(Promise)) {
            var p = Promise.resolve();
            timerFunc = function() {
                p.then(flushCallbacks), isIOS && setTimeout(noop);
            }, isUsingMicroTask = !0;
        } else if (isIE || "undefined" == typeof MutationObserver || !isNative(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) timerFunc = void 0 !== setImmediate && isNative(setImmediate) ? function() {
            setImmediate(flushCallbacks);
        } : function() {
            setTimeout(flushCallbacks, 0);
        }; else {
            var counter = 1, observer = new MutationObserver(flushCallbacks), textNode = document.createTextNode(String(counter));
            observer.observe(textNode, {
                characterData: !0
            }), timerFunc = function() {
                counter = (counter + 1) % 2, textNode.data = String(counter);
            }, isUsingMicroTask = !0;
        }
        function nextTick(cb, ctx) {
            var _resolve;
            if (callbacks.push((function() {
                if (cb) try {
                    cb.call(ctx);
                } catch (e) {
                    handleError(e, ctx, "nextTick");
                } else _resolve && _resolve(ctx);
            })), pending || (pending = !0, timerFunc()), !cb && "undefined" != typeof Promise) return new Promise((function(resolve) {
                _resolve = resolve;
            }));
        }
        var seenObjects = new _Set;
        function traverse(val) {
            !function _traverse(val, seen) {
                var i, keys, isA = Array.isArray(val);
                if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) return;
                if (val.__ob__) {
                    var depId = val.__ob__.dep.id;
                    if (seen.has(depId)) return;
                    seen.add(depId);
                }
                if (isA) for (i = val.length; i--; ) _traverse(val[i], seen); else for (keys = Object.keys(val), 
                i = keys.length; i--; ) _traverse(val[keys[i]], seen);
            }(val, seenObjects), seenObjects.clear();
        }
        var normalizeEvent = cached((function(name) {
            var passive = "&" === name.charAt(0), once$$1 = "~" === (name = passive ? name.slice(1) : name).charAt(0), capture = "!" === (name = once$$1 ? name.slice(1) : name).charAt(0);
            return {
                name: name = capture ? name.slice(1) : name,
                once: once$$1,
                capture: capture,
                passive: passive
            };
        }));
        function createFnInvoker(fns, vm) {
            function invoker() {
                var arguments$1 = arguments, fns = invoker.fns;
                if (!Array.isArray(fns)) return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
                for (var cloned = fns.slice(), i = 0; i < cloned.length; i++) invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
            }
            return invoker.fns = fns, invoker;
        }
        function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
            var name, cur, old, event;
            for (name in on) cur = on[name], old = oldOn[name], event = normalizeEvent(name), 
            isUndef(cur) || (isUndef(old) ? (isUndef(cur.fns) && (cur = on[name] = createFnInvoker(cur, vm)), 
            isTrue(event.once) && (cur = on[name] = createOnceHandler(event.name, cur, event.capture)), 
            add(event.name, cur, event.capture, event.passive, event.params)) : cur !== old && (old.fns = cur, 
            on[name] = old));
            for (name in oldOn) isUndef(on[name]) && remove$$1((event = normalizeEvent(name)).name, oldOn[name], event.capture);
        }
        function mergeVNodeHook(def, hookKey, hook) {
            var invoker;
            def instanceof VNode && (def = def.data.hook || (def.data.hook = {}));
            var oldHook = def[hookKey];
            function wrappedHook() {
                hook.apply(this, arguments), remove(invoker.fns, wrappedHook);
            }
            isUndef(oldHook) ? invoker = createFnInvoker([ wrappedHook ]) : isDef(oldHook.fns) && isTrue(oldHook.merged) ? (invoker = oldHook).fns.push(wrappedHook) : invoker = createFnInvoker([ oldHook, wrappedHook ]), 
            invoker.merged = !0, def[hookKey] = invoker;
        }
        function checkProp(res, hash, key, altKey, preserve) {
            if (isDef(hash)) {
                if (hasOwn(hash, key)) return res[key] = hash[key], preserve || delete hash[key], 
                !0;
                if (hasOwn(hash, altKey)) return res[key] = hash[altKey], preserve || delete hash[altKey], 
                !0;
            }
            return !1;
        }
        function normalizeChildren(children) {
            return isPrimitive(children) ? [ createTextVNode(children) ] : Array.isArray(children) ? function normalizeArrayChildren(children, nestedIndex) {
                var i, c, lastIndex, last, res = [];
                for (i = 0; i < children.length; i++) isUndef(c = children[i]) || "boolean" == typeof c || (lastIndex = res.length - 1, 
                last = res[lastIndex], Array.isArray(c) ? c.length > 0 && (isTextNode((c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i))[0]) && isTextNode(last) && (res[lastIndex] = createTextVNode(last.text + c[0].text), 
                c.shift()), res.push.apply(res, c)) : isPrimitive(c) ? isTextNode(last) ? res[lastIndex] = createTextVNode(last.text + c) : "" !== c && res.push(createTextVNode(c)) : isTextNode(c) && isTextNode(last) ? res[lastIndex] = createTextVNode(last.text + c.text) : (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex) && (c.key = "__vlist" + nestedIndex + "_" + i + "__"), 
                res.push(c)));
                return res;
            }(children) : void 0;
        }
        function isTextNode(node) {
            return isDef(node) && isDef(node.text) && !1 === node.isComment;
        }
        function resolveInject(inject, vm) {
            if (inject) {
                for (var result = Object.create(null), keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject), i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if ("__ob__" !== key) {
                        for (var provideKey = inject[key].from, source = vm; source; ) {
                            if (source._provided && hasOwn(source._provided, provideKey)) {
                                result[key] = source._provided[provideKey];
                                break;
                            }
                            source = source.$parent;
                        }
                        if (!source) if ("default" in inject[key]) {
                            var provideDefault = inject[key].default;
                            result[key] = "function" == typeof provideDefault ? provideDefault.call(vm) : provideDefault;
                        } else 0;
                    }
                }
                return result;
            }
        }
        function resolveSlots(children, context) {
            if (!children || !children.length) return {};
            for (var slots = {}, i = 0, l = children.length; i < l; i++) {
                var child = children[i], data = child.data;
                if (data && data.attrs && data.attrs.slot && delete data.attrs.slot, child.context !== context && child.fnContext !== context || !data || null == data.slot) (slots.default || (slots.default = [])).push(child); else {
                    var name = data.slot, slot = slots[name] || (slots[name] = []);
                    "template" === child.tag ? slot.push.apply(slot, child.children || []) : slot.push(child);
                }
            }
            for (var name$1 in slots) slots[name$1].every(isWhitespace) && delete slots[name$1];
            return slots;
        }
        function isWhitespace(node) {
            return node.isComment && !node.asyncFactory || " " === node.text;
        }
        function normalizeScopedSlots(slots, normalSlots, prevSlots) {
            var res, hasNormalSlots = Object.keys(normalSlots).length > 0, isStable = slots ? !!slots.$stable : !hasNormalSlots, key = slots && slots.$key;
            if (slots) {
                if (slots._normalized) return slots._normalized;
                if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) return prevSlots;
                for (var key$1 in res = {}, slots) slots[key$1] && "$" !== key$1[0] && (res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]));
            } else res = {};
            for (var key$2 in normalSlots) key$2 in res || (res[key$2] = proxyNormalSlot(normalSlots, key$2));
            return slots && Object.isExtensible(slots) && (slots._normalized = res), def(res, "$stable", isStable), 
            def(res, "$key", key), def(res, "$hasNormal", hasNormalSlots), res;
        }
        function normalizeScopedSlot(normalSlots, key, fn) {
            var normalized = function() {
                var res = arguments.length ? fn.apply(null, arguments) : fn({});
                return (res = res && "object" == typeof res && !Array.isArray(res) ? [ res ] : normalizeChildren(res)) && (0 === res.length || 1 === res.length && res[0].isComment) ? void 0 : res;
            };
            return fn.proxy && Object.defineProperty(normalSlots, key, {
                get: normalized,
                enumerable: !0,
                configurable: !0
            }), normalized;
        }
        function proxyNormalSlot(slots, key) {
            return function() {
                return slots[key];
            };
        }
        function renderList(val, render) {
            var ret, i, l, keys, key;
            if (Array.isArray(val) || "string" == typeof val) for (ret = new Array(val.length), 
            i = 0, l = val.length; i < l; i++) ret[i] = render(val[i], i); else if ("number" == typeof val) for (ret = new Array(val), 
            i = 0; i < val; i++) ret[i] = render(i + 1, i); else if (isObject(val)) if (hasSymbol && val[Symbol.iterator]) {
                ret = [];
                for (var iterator = val[Symbol.iterator](), result = iterator.next(); !result.done; ) ret.push(render(result.value, ret.length)), 
                result = iterator.next();
            } else for (keys = Object.keys(val), ret = new Array(keys.length), i = 0, l = keys.length; i < l; i++) key = keys[i], 
            ret[i] = render(val[key], key, i);
            return isDef(ret) || (ret = []), ret._isVList = !0, ret;
        }
        function renderSlot(name, fallback, props, bindObject) {
            var nodes, scopedSlotFn = this.$scopedSlots[name];
            scopedSlotFn ? (props = props || {}, bindObject && (props = extend(extend({}, bindObject), props)), 
            nodes = scopedSlotFn(props) || fallback) : nodes = this.$slots[name] || fallback;
            var target = props && props.slot;
            return target ? this.$createElement("template", {
                slot: target
            }, nodes) : nodes;
        }
        function resolveFilter(id) {
            return resolveAsset(this.$options, "filters", id) || identity;
        }
        function isKeyNotMatch(expect, actual) {
            return Array.isArray(expect) ? -1 === expect.indexOf(actual) : expect !== actual;
        }
        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
            var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
            return builtInKeyName && eventKeyName && !config.keyCodes[key] ? isKeyNotMatch(builtInKeyName, eventKeyName) : mappedKeyCode ? isKeyNotMatch(mappedKeyCode, eventKeyCode) : eventKeyName ? hyphenate(eventKeyName) !== key : void 0;
        }
        function bindObjectProps(data, tag, value, asProp, isSync) {
            if (value) if (isObject(value)) {
                var hash;
                Array.isArray(value) && (value = toObject(value));
                var loop = function(key) {
                    if ("class" === key || "style" === key || isReservedAttribute(key)) hash = data; else {
                        var type = data.attrs && data.attrs.type;
                        hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
                    }
                    var camelizedKey = camelize(key), hyphenatedKey = hyphenate(key);
                    camelizedKey in hash || hyphenatedKey in hash || (hash[key] = value[key], isSync && ((data.on || (data.on = {}))["update:" + key] = function($event) {
                        value[key] = $event;
                    }));
                };
                for (var key in value) loop(key);
            } else ;
            return data;
        }
        function renderStatic(index, isInFor) {
            var cached = this._staticTrees || (this._staticTrees = []), tree = cached[index];
            return tree && !isInFor || markStatic(tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this), "__static__" + index, !1), 
            tree;
        }
        function markOnce(tree, index, key) {
            return markStatic(tree, "__once__" + index + (key ? "_" + key : ""), !0), tree;
        }
        function markStatic(tree, key, isOnce) {
            if (Array.isArray(tree)) for (var i = 0; i < tree.length; i++) tree[i] && "string" != typeof tree[i] && markStaticNode(tree[i], key + "_" + i, isOnce); else markStaticNode(tree, key, isOnce);
        }
        function markStaticNode(node, key, isOnce) {
            node.isStatic = !0, node.key = key, node.isOnce = isOnce;
        }
        function bindObjectListeners(data, value) {
            if (value) if (isPlainObject(value)) {
                var on = data.on = data.on ? extend({}, data.on) : {};
                for (var key in value) {
                    var existing = on[key], ours = value[key];
                    on[key] = existing ? [].concat(existing, ours) : ours;
                }
            } else ;
            return data;
        }
        function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
            res = res || {
                $stable: !hasDynamicKeys
            };
            for (var i = 0; i < fns.length; i++) {
                var slot = fns[i];
                Array.isArray(slot) ? resolveScopedSlots(slot, res, hasDynamicKeys) : slot && (slot.proxy && (slot.fn.proxy = !0), 
                res[slot.key] = slot.fn);
            }
            return contentHashKey && (res.$key = contentHashKey), res;
        }
        function bindDynamicKeys(baseObj, values) {
            for (var i = 0; i < values.length; i += 2) {
                var key = values[i];
                "string" == typeof key && key && (baseObj[values[i]] = values[i + 1]);
            }
            return baseObj;
        }
        function prependModifier(value, symbol) {
            return "string" == typeof value ? symbol + value : value;
        }
        function installRenderHelpers(target) {
            target._o = markOnce, target._n = toNumber, target._s = toString, target._l = renderList, 
            target._t = renderSlot, target._q = looseEqual, target._i = looseIndexOf, target._m = renderStatic, 
            target._f = resolveFilter, target._k = checkKeyCodes, target._b = bindObjectProps, 
            target._v = createTextVNode, target._e = createEmptyVNode, target._u = resolveScopedSlots, 
            target._g = bindObjectListeners, target._d = bindDynamicKeys, target._p = prependModifier;
        }
        function FunctionalRenderContext(data, props, children, parent, Ctor) {
            var contextVm, this$1 = this, options = Ctor.options;
            hasOwn(parent, "_uid") ? (contextVm = Object.create(parent))._original = parent : (contextVm = parent, 
            parent = parent._original);
            var isCompiled = isTrue(options._compiled), needNormalization = !isCompiled;
            this.data = data, this.props = props, this.children = children, this.parent = parent, 
            this.listeners = data.on || emptyObject, this.injections = resolveInject(options.inject, parent), 
            this.slots = function() {
                return this$1.$slots || normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent)), 
                this$1.$slots;
            }, Object.defineProperty(this, "scopedSlots", {
                enumerable: !0,
                get: function() {
                    return normalizeScopedSlots(data.scopedSlots, this.slots());
                }
            }), isCompiled && (this.$options = options, this.$slots = this.slots(), this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots)), 
            options._scopeId ? this._c = function(a, b, c, d) {
                var vnode = createElement(contextVm, a, b, c, d, needNormalization);
                return vnode && !Array.isArray(vnode) && (vnode.fnScopeId = options._scopeId, vnode.fnContext = parent), 
                vnode;
            } : this._c = function(a, b, c, d) {
                return createElement(contextVm, a, b, c, d, needNormalization);
            };
        }
        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
            var clone = cloneVNode(vnode);
            return clone.fnContext = contextVm, clone.fnOptions = options, data.slot && ((clone.data || (clone.data = {})).slot = data.slot), 
            clone;
        }
        function mergeProps(to, from) {
            for (var key in from) to[camelize(key)] = from[key];
        }
        installRenderHelpers(FunctionalRenderContext.prototype);
        var componentVNodeHooks = {
            init: function(vnode, hydrating) {
                if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
                    var mountedNode = vnode;
                    componentVNodeHooks.prepatch(mountedNode, mountedNode);
                } else {
                    (vnode.componentInstance = function(vnode, parent) {
                        var options = {
                            _isComponent: !0,
                            _parentVnode: vnode,
                            parent: parent
                        }, inlineTemplate = vnode.data.inlineTemplate;
                        isDef(inlineTemplate) && (options.render = inlineTemplate.render, options.staticRenderFns = inlineTemplate.staticRenderFns);
                        return new vnode.componentOptions.Ctor(options);
                    }(vnode, activeInstance)).$mount(hydrating ? vnode.elm : void 0, hydrating);
                }
            },
            prepatch: function(oldVnode, vnode) {
                var options = vnode.componentOptions;
                !function(vm, propsData, listeners, parentVnode, renderChildren) {
                    0;
                    var newScopedSlots = parentVnode.data.scopedSlots, oldScopedSlots = vm.$scopedSlots, hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key), needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
                    vm.$options._parentVnode = parentVnode, vm.$vnode = parentVnode, vm._vnode && (vm._vnode.parent = parentVnode);
                    if (vm.$options._renderChildren = renderChildren, vm.$attrs = parentVnode.data.attrs || emptyObject, 
                    vm.$listeners = listeners || emptyObject, propsData && vm.$options.props) {
                        toggleObserving(!1);
                        for (var props = vm._props, propKeys = vm.$options._propKeys || [], i = 0; i < propKeys.length; i++) {
                            var key = propKeys[i], propOptions = vm.$options.props;
                            props[key] = validateProp(key, propOptions, propsData, vm);
                        }
                        toggleObserving(!0), vm.$options.propsData = propsData;
                    }
                    listeners = listeners || emptyObject;
                    var oldListeners = vm.$options._parentListeners;
                    vm.$options._parentListeners = listeners, updateComponentListeners(vm, listeners, oldListeners), 
                    needsForceUpdate && (vm.$slots = resolveSlots(renderChildren, parentVnode.context), 
                    vm.$forceUpdate());
                    0;
                }(vnode.componentInstance = oldVnode.componentInstance, options.propsData, options.listeners, vnode, options.children);
            },
            insert: function(vnode) {
                var vm, context = vnode.context, componentInstance = vnode.componentInstance;
                componentInstance._isMounted || (componentInstance._isMounted = !0, callHook(componentInstance, "mounted")), 
                vnode.data.keepAlive && (context._isMounted ? ((vm = componentInstance)._inactive = !1, 
                activatedChildren.push(vm)) : activateChildComponent(componentInstance, !0));
            },
            destroy: function(vnode) {
                var componentInstance = vnode.componentInstance;
                componentInstance._isDestroyed || (vnode.data.keepAlive ? function deactivateChildComponent(vm, direct) {
                    if (direct && (vm._directInactive = !0, isInInactiveTree(vm))) return;
                    if (!vm._inactive) {
                        vm._inactive = !0;
                        for (var i = 0; i < vm.$children.length; i++) deactivateChildComponent(vm.$children[i]);
                        callHook(vm, "deactivated");
                    }
                }(componentInstance, !0) : componentInstance.$destroy());
            }
        }, hooksToMerge = Object.keys(componentVNodeHooks);
        function createComponent(Ctor, data, context, children, tag) {
            if (!isUndef(Ctor)) {
                var baseCtor = context.$options._base;
                if (isObject(Ctor) && (Ctor = baseCtor.extend(Ctor)), "function" == typeof Ctor) {
                    var asyncFactory;
                    if (isUndef(Ctor.cid) && void 0 === (Ctor = function(factory, baseCtor) {
                        if (isTrue(factory.error) && isDef(factory.errorComp)) return factory.errorComp;
                        if (isDef(factory.resolved)) return factory.resolved;
                        var owner = currentRenderingInstance;
                        owner && isDef(factory.owners) && -1 === factory.owners.indexOf(owner) && factory.owners.push(owner);
                        if (isTrue(factory.loading) && isDef(factory.loadingComp)) return factory.loadingComp;
                        if (owner && !isDef(factory.owners)) {
                            var owners = factory.owners = [ owner ], sync = !0, timerLoading = null, timerTimeout = null;
                            owner.$on("hook:destroyed", (function() {
                                return remove(owners, owner);
                            }));
                            var forceRender = function(renderCompleted) {
                                for (var i = 0, l = owners.length; i < l; i++) owners[i].$forceUpdate();
                                renderCompleted && (owners.length = 0, null !== timerLoading && (clearTimeout(timerLoading), 
                                timerLoading = null), null !== timerTimeout && (clearTimeout(timerTimeout), timerTimeout = null));
                            }, resolve = once((function(res) {
                                factory.resolved = ensureCtor(res, baseCtor), sync ? owners.length = 0 : forceRender(!0);
                            })), reject = once((function(reason) {
                                isDef(factory.errorComp) && (factory.error = !0, forceRender(!0));
                            })), res = factory(resolve, reject);
                            return isObject(res) && (isPromise(res) ? isUndef(factory.resolved) && res.then(resolve, reject) : isPromise(res.component) && (res.component.then(resolve, reject), 
                            isDef(res.error) && (factory.errorComp = ensureCtor(res.error, baseCtor)), isDef(res.loading) && (factory.loadingComp = ensureCtor(res.loading, baseCtor), 
                            0 === res.delay ? factory.loading = !0 : timerLoading = setTimeout((function() {
                                timerLoading = null, isUndef(factory.resolved) && isUndef(factory.error) && (factory.loading = !0, 
                                forceRender(!1));
                            }), res.delay || 200)), isDef(res.timeout) && (timerTimeout = setTimeout((function() {
                                timerTimeout = null, isUndef(factory.resolved) && reject(null);
                            }), res.timeout)))), sync = !1, factory.loading ? factory.loadingComp : factory.resolved;
                        }
                    }(asyncFactory = Ctor, baseCtor))) return function(factory, data, context, children, tag) {
                        var node = createEmptyVNode();
                        return node.asyncFactory = factory, node.asyncMeta = {
                            data: data,
                            context: context,
                            children: children,
                            tag: tag
                        }, node;
                    }(asyncFactory, data, context, children, tag);
                    data = data || {}, resolveConstructorOptions(Ctor), isDef(data.model) && function(options, data) {
                        var prop = options.model && options.model.prop || "value", event = options.model && options.model.event || "input";
                        (data.attrs || (data.attrs = {}))[prop] = data.model.value;
                        var on = data.on || (data.on = {}), existing = on[event], callback = data.model.callback;
                        isDef(existing) ? (Array.isArray(existing) ? -1 === existing.indexOf(callback) : existing !== callback) && (on[event] = [ callback ].concat(existing)) : on[event] = callback;
                    }(Ctor.options, data);
                    var propsData = function(data, Ctor, tag) {
                        var propOptions = Ctor.options.props;
                        if (!isUndef(propOptions)) {
                            var res = {}, attrs = data.attrs, props = data.props;
                            if (isDef(attrs) || isDef(props)) for (var key in propOptions) {
                                var altKey = hyphenate(key);
                                checkProp(res, props, key, altKey, !0) || checkProp(res, attrs, key, altKey, !1);
                            }
                            return res;
                        }
                    }(data, Ctor);
                    if (isTrue(Ctor.options.functional)) return function(Ctor, propsData, data, contextVm, children) {
                        var options = Ctor.options, props = {}, propOptions = options.props;
                        if (isDef(propOptions)) for (var key in propOptions) props[key] = validateProp(key, propOptions, propsData || emptyObject); else isDef(data.attrs) && mergeProps(props, data.attrs), 
                        isDef(data.props) && mergeProps(props, data.props);
                        var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor), vnode = options.render.call(null, renderContext._c, renderContext);
                        if (vnode instanceof VNode) return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
                        if (Array.isArray(vnode)) {
                            for (var vnodes = normalizeChildren(vnode) || [], res = new Array(vnodes.length), i = 0; i < vnodes.length; i++) res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
                            return res;
                        }
                    }(Ctor, propsData, data, context, children);
                    var listeners = data.on;
                    if (data.on = data.nativeOn, isTrue(Ctor.options.abstract)) {
                        var slot = data.slot;
                        data = {}, slot && (data.slot = slot);
                    }
                    !function(data) {
                        for (var hooks = data.hook || (data.hook = {}), i = 0; i < hooksToMerge.length; i++) {
                            var key = hooksToMerge[i], existing = hooks[key], toMerge = componentVNodeHooks[key];
                            existing === toMerge || existing && existing._merged || (hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge);
                        }
                    }(data);
                    var name = Ctor.options.name || tag;
                    return new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data, void 0, void 0, void 0, context, {
                        Ctor: Ctor,
                        propsData: propsData,
                        listeners: listeners,
                        tag: tag,
                        children: children
                    }, asyncFactory);
                }
            }
        }
        function mergeHook$1(f1, f2) {
            var merged = function(a, b) {
                f1(a, b), f2(a, b);
            };
            return merged._merged = !0, merged;
        }
        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
            return (Array.isArray(data) || isPrimitive(data)) && (normalizationType = children, 
            children = data, data = void 0), isTrue(alwaysNormalize) && (normalizationType = 2), 
            function(context, tag, data, children, normalizationType) {
                if (isDef(data) && isDef(data.__ob__)) return createEmptyVNode();
                isDef(data) && isDef(data.is) && (tag = data.is);
                if (!tag) return createEmptyVNode();
                0;
                Array.isArray(children) && "function" == typeof children[0] && ((data = data || {}).scopedSlots = {
                    default: children[0]
                }, children.length = 0);
                2 === normalizationType ? children = normalizeChildren(children) : 1 === normalizationType && (children = function(children) {
                    for (var i = 0; i < children.length; i++) if (Array.isArray(children[i])) return Array.prototype.concat.apply([], children);
                    return children;
                }(children));
                var vnode, ns;
                if ("string" == typeof tag) {
                    var Ctor;
                    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag), vnode = config.isReservedTag(tag) ? new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context) : data && data.pre || !isDef(Ctor = resolveAsset(context.$options, "components", tag)) ? new VNode(tag, data, children, void 0, void 0, context) : createComponent(Ctor, data, context, children, tag);
                } else vnode = createComponent(tag, data, context, children);
                return Array.isArray(vnode) ? vnode : isDef(vnode) ? (isDef(ns) && function applyNS(vnode, ns, force) {
                    vnode.ns = ns, "foreignObject" === vnode.tag && (ns = void 0, force = !0);
                    if (isDef(vnode.children)) for (var i = 0, l = vnode.children.length; i < l; i++) {
                        var child = vnode.children[i];
                        isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && "svg" !== child.tag) && applyNS(child, ns, force);
                    }
                }(vnode, ns), isDef(data) && function(data) {
                    isObject(data.style) && traverse(data.style);
                    isObject(data.class) && traverse(data.class);
                }(data), vnode) : createEmptyVNode();
            }(context, tag, data, children, normalizationType);
        }
        var target, currentRenderingInstance = null;
        function ensureCtor(comp, base) {
            return (comp.__esModule || hasSymbol && "Module" === comp[Symbol.toStringTag]) && (comp = comp.default), 
            isObject(comp) ? base.extend(comp) : comp;
        }
        function isAsyncPlaceholder(node) {
            return node.isComment && node.asyncFactory;
        }
        function getFirstComponentChild(children) {
            if (Array.isArray(children)) for (var i = 0; i < children.length; i++) {
                var c = children[i];
                if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) return c;
            }
        }
        function add(event, fn) {
            target.$on(event, fn);
        }
        function remove$1(event, fn) {
            target.$off(event, fn);
        }
        function createOnceHandler(event, fn) {
            var _target = target;
            return function onceHandler() {
                var res = fn.apply(null, arguments);
                null !== res && _target.$off(event, onceHandler);
            };
        }
        function updateComponentListeners(vm, listeners, oldListeners) {
            target = vm, updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm), 
            target = void 0;
        }
        var activeInstance = null;
        function setActiveInstance(vm) {
            var prevActiveInstance = activeInstance;
            return activeInstance = vm, function() {
                activeInstance = prevActiveInstance;
            };
        }
        function isInInactiveTree(vm) {
            for (;vm && (vm = vm.$parent); ) if (vm._inactive) return !0;
            return !1;
        }
        function activateChildComponent(vm, direct) {
            if (direct) {
                if (vm._directInactive = !1, isInInactiveTree(vm)) return;
            } else if (vm._directInactive) return;
            if (vm._inactive || null === vm._inactive) {
                vm._inactive = !1;
                for (var i = 0; i < vm.$children.length; i++) activateChildComponent(vm.$children[i]);
                callHook(vm, "activated");
            }
        }
        function callHook(vm, hook) {
            pushTarget();
            var handlers = vm.$options[hook], info = hook + " hook";
            if (handlers) for (var i = 0, j = handlers.length; i < j; i++) invokeWithErrorHandling(handlers[i], vm, null, vm, info);
            vm._hasHookEvent && vm.$emit("hook:" + hook), popTarget();
        }
        var queue = [], activatedChildren = [], has = {}, waiting = !1, flushing = !1, index = 0;
        var currentFlushTimestamp = 0, getNow = Date.now;
        if (inBrowser && !isIE) {
            var performance = window.performance;
            performance && "function" == typeof performance.now && getNow() > document.createEvent("Event").timeStamp && (getNow = function() {
                return performance.now();
            });
        }
        function flushSchedulerQueue() {
            var watcher, id;
            for (currentFlushTimestamp = getNow(), flushing = !0, queue.sort((function(a, b) {
                return a.id - b.id;
            })), index = 0; index < queue.length; index++) (watcher = queue[index]).before && watcher.before(), 
            id = watcher.id, has[id] = null, watcher.run();
            var activatedQueue = activatedChildren.slice(), updatedQueue = queue.slice();
            index = queue.length = activatedChildren.length = 0, has = {}, waiting = flushing = !1, 
            function(queue) {
                for (var i = 0; i < queue.length; i++) queue[i]._inactive = !0, activateChildComponent(queue[i], !0);
            }(activatedQueue), function(queue) {
                var i = queue.length;
                for (;i--; ) {
                    var watcher = queue[i], vm = watcher.vm;
                    vm._watcher === watcher && vm._isMounted && !vm._isDestroyed && callHook(vm, "updated");
                }
            }(updatedQueue), devtools && config.devtools && devtools.emit("flush");
        }
        var uid$2 = 0, Watcher = function(vm, expOrFn, cb, options, isRenderWatcher) {
            this.vm = vm, isRenderWatcher && (vm._watcher = this), vm._watchers.push(this), 
            options ? (this.deep = !!options.deep, this.user = !!options.user, this.lazy = !!options.lazy, 
            this.sync = !!options.sync, this.before = options.before) : this.deep = this.user = this.lazy = this.sync = !1, 
            this.cb = cb, this.id = ++uid$2, this.active = !0, this.dirty = this.lazy, this.deps = [], 
            this.newDeps = [], this.depIds = new _Set, this.newDepIds = new _Set, this.expression = "", 
            "function" == typeof expOrFn ? this.getter = expOrFn : (this.getter = function(path) {
                if (!bailRE.test(path)) {
                    var segments = path.split(".");
                    return function(obj) {
                        for (var i = 0; i < segments.length; i++) {
                            if (!obj) return;
                            obj = obj[segments[i]];
                        }
                        return obj;
                    };
                }
            }(expOrFn), this.getter || (this.getter = noop)), this.value = this.lazy ? void 0 : this.get();
        };
        Watcher.prototype.get = function() {
            var value;
            pushTarget(this);
            var vm = this.vm;
            try {
                value = this.getter.call(vm, vm);
            } catch (e) {
                if (!this.user) throw e;
                handleError(e, vm, 'getter for watcher "' + this.expression + '"');
            } finally {
                this.deep && traverse(value), popTarget(), this.cleanupDeps();
            }
            return value;
        }, Watcher.prototype.addDep = function(dep) {
            var id = dep.id;
            this.newDepIds.has(id) || (this.newDepIds.add(id), this.newDeps.push(dep), this.depIds.has(id) || dep.addSub(this));
        }, Watcher.prototype.cleanupDeps = function() {
            for (var i = this.deps.length; i--; ) {
                var dep = this.deps[i];
                this.newDepIds.has(dep.id) || dep.removeSub(this);
            }
            var tmp = this.depIds;
            this.depIds = this.newDepIds, this.newDepIds = tmp, this.newDepIds.clear(), tmp = this.deps, 
            this.deps = this.newDeps, this.newDeps = tmp, this.newDeps.length = 0;
        }, Watcher.prototype.update = function() {
            this.lazy ? this.dirty = !0 : this.sync ? this.run() : function(watcher) {
                var id = watcher.id;
                if (null == has[id]) {
                    if (has[id] = !0, flushing) {
                        for (var i = queue.length - 1; i > index && queue[i].id > watcher.id; ) i--;
                        queue.splice(i + 1, 0, watcher);
                    } else queue.push(watcher);
                    waiting || (waiting = !0, nextTick(flushSchedulerQueue));
                }
            }(this);
        }, Watcher.prototype.run = function() {
            if (this.active) {
                var value = this.get();
                if (value !== this.value || isObject(value) || this.deep) {
                    var oldValue = this.value;
                    if (this.value = value, this.user) try {
                        this.cb.call(this.vm, value, oldValue);
                    } catch (e) {
                        handleError(e, this.vm, 'callback for watcher "' + this.expression + '"');
                    } else this.cb.call(this.vm, value, oldValue);
                }
            }
        }, Watcher.prototype.evaluate = function() {
            this.value = this.get(), this.dirty = !1;
        }, Watcher.prototype.depend = function() {
            for (var i = this.deps.length; i--; ) this.deps[i].depend();
        }, Watcher.prototype.teardown = function() {
            if (this.active) {
                this.vm._isBeingDestroyed || remove(this.vm._watchers, this);
                for (var i = this.deps.length; i--; ) this.deps[i].removeSub(this);
                this.active = !1;
            }
        };
        var sharedPropertyDefinition = {
            enumerable: !0,
            configurable: !0,
            get: noop,
            set: noop
        };
        function proxy(target, sourceKey, key) {
            sharedPropertyDefinition.get = function() {
                return this[sourceKey][key];
            }, sharedPropertyDefinition.set = function(val) {
                this[sourceKey][key] = val;
            }, Object.defineProperty(target, key, sharedPropertyDefinition);
        }
        function initState(vm) {
            vm._watchers = [];
            var opts = vm.$options;
            opts.props && function(vm, propsOptions) {
                var propsData = vm.$options.propsData || {}, props = vm._props = {}, keys = vm.$options._propKeys = [];
                vm.$parent && toggleObserving(!1);
                var loop = function(key) {
                    keys.push(key);
                    var value = validateProp(key, propsOptions, propsData, vm);
                    defineReactive$$1(props, key, value), key in vm || proxy(vm, "_props", key);
                };
                for (var key in propsOptions) loop(key);
                toggleObserving(!0);
            }(vm, opts.props), opts.methods && function(vm, methods) {
                vm.$options.props;
                for (var key in methods) vm[key] = "function" != typeof methods[key] ? noop : bind(methods[key], vm);
            }(vm, opts.methods), opts.data ? function(vm) {
                var data = vm.$options.data;
                isPlainObject(data = vm._data = "function" == typeof data ? function(data, vm) {
                    pushTarget();
                    try {
                        return data.call(vm, vm);
                    } catch (e) {
                        return handleError(e, vm, "data()"), {};
                    } finally {
                        popTarget();
                    }
                }(data, vm) : data || {}) || (data = {});
                var keys = Object.keys(data), props = vm.$options.props, i = (vm.$options.methods, 
                keys.length);
                for (;i--; ) {
                    var key = keys[i];
                    0, props && hasOwn(props, key) || isReserved(key) || proxy(vm, "_data", key);
                }
                observe(data, !0);
            }(vm) : observe(vm._data = {}, !0), opts.computed && function(vm, computed) {
                var watchers = vm._computedWatchers = Object.create(null), isSSR = isServerRendering();
                for (var key in computed) {
                    var userDef = computed[key], getter = "function" == typeof userDef ? userDef : userDef.get;
                    0, isSSR || (watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions)), 
                    key in vm || defineComputed(vm, key, userDef);
                }
            }(vm, opts.computed), opts.watch && opts.watch !== nativeWatch && function(vm, watch) {
                for (var key in watch) {
                    var handler = watch[key];
                    if (Array.isArray(handler)) for (var i = 0; i < handler.length; i++) createWatcher(vm, key, handler[i]); else createWatcher(vm, key, handler);
                }
            }(vm, opts.watch);
        }
        var computedWatcherOptions = {
            lazy: !0
        };
        function defineComputed(target, key, userDef) {
            var shouldCache = !isServerRendering();
            "function" == typeof userDef ? (sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef), 
            sharedPropertyDefinition.set = noop) : (sharedPropertyDefinition.get = userDef.get ? shouldCache && !1 !== userDef.cache ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop, 
            sharedPropertyDefinition.set = userDef.set || noop), Object.defineProperty(target, key, sharedPropertyDefinition);
        }
        function createComputedGetter(key) {
            return function() {
                var watcher = this._computedWatchers && this._computedWatchers[key];
                if (watcher) return watcher.dirty && watcher.evaluate(), Dep.target && watcher.depend(), 
                watcher.value;
            };
        }
        function createGetterInvoker(fn) {
            return function() {
                return fn.call(this, this);
            };
        }
        function createWatcher(vm, expOrFn, handler, options) {
            return isPlainObject(handler) && (options = handler, handler = handler.handler), 
            "string" == typeof handler && (handler = vm[handler]), vm.$watch(expOrFn, handler, options);
        }
        var uid$3 = 0;
        function resolveConstructorOptions(Ctor) {
            var options = Ctor.options;
            if (Ctor.super) {
                var superOptions = resolveConstructorOptions(Ctor.super);
                if (superOptions !== Ctor.superOptions) {
                    Ctor.superOptions = superOptions;
                    var modifiedOptions = function(Ctor) {
                        var modified, latest = Ctor.options, sealed = Ctor.sealedOptions;
                        for (var key in latest) latest[key] !== sealed[key] && (modified || (modified = {}), 
                        modified[key] = latest[key]);
                        return modified;
                    }(Ctor);
                    modifiedOptions && extend(Ctor.extendOptions, modifiedOptions), (options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)).name && (options.components[options.name] = Ctor);
                }
            }
            return options;
        }
        function Vue(options) {
            this._init(options);
        }
        function initExtend(Vue) {
            Vue.cid = 0;
            var cid = 1;
            Vue.extend = function(extendOptions) {
                extendOptions = extendOptions || {};
                var Super = this, SuperId = Super.cid, cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
                if (cachedCtors[SuperId]) return cachedCtors[SuperId];
                var name = extendOptions.name || Super.options.name;
                var Sub = function(options) {
                    this._init(options);
                };
                return (Sub.prototype = Object.create(Super.prototype)).constructor = Sub, Sub.cid = cid++, 
                Sub.options = mergeOptions(Super.options, extendOptions), Sub.super = Super, Sub.options.props && function(Comp) {
                    var props = Comp.options.props;
                    for (var key in props) proxy(Comp.prototype, "_props", key);
                }(Sub), Sub.options.computed && function(Comp) {
                    var computed = Comp.options.computed;
                    for (var key in computed) defineComputed(Comp.prototype, key, computed[key]);
                }(Sub), Sub.extend = Super.extend, Sub.mixin = Super.mixin, Sub.use = Super.use, 
                ASSET_TYPES.forEach((function(type) {
                    Sub[type] = Super[type];
                })), name && (Sub.options.components[name] = Sub), Sub.superOptions = Super.options, 
                Sub.extendOptions = extendOptions, Sub.sealedOptions = extend({}, Sub.options), 
                cachedCtors[SuperId] = Sub, Sub;
            };
        }
        function getComponentName(opts) {
            return opts && (opts.Ctor.options.name || opts.tag);
        }
        function matches(pattern, name) {
            return Array.isArray(pattern) ? pattern.indexOf(name) > -1 : "string" == typeof pattern ? pattern.split(",").indexOf(name) > -1 : !!isRegExp(pattern) && pattern.test(name);
        }
        function pruneCache(keepAliveInstance, filter) {
            var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
            for (var key in cache) {
                var cachedNode = cache[key];
                if (cachedNode) {
                    var name = getComponentName(cachedNode.componentOptions);
                    name && !filter(name) && pruneCacheEntry(cache, key, keys, _vnode);
                }
            }
        }
        function pruneCacheEntry(cache, key, keys, current) {
            var cached$$1 = cache[key];
            !cached$$1 || current && cached$$1.tag === current.tag || cached$$1.componentInstance.$destroy(), 
            cache[key] = null, remove(keys, key);
        }
        !function(Vue) {
            Vue.prototype._init = function(options) {
                var vm = this;
                vm._uid = uid$3++, vm._isVue = !0, options && options._isComponent ? function(vm, options) {
                    var opts = vm.$options = Object.create(vm.constructor.options), parentVnode = options._parentVnode;
                    opts.parent = options.parent, opts._parentVnode = parentVnode;
                    var vnodeComponentOptions = parentVnode.componentOptions;
                    opts.propsData = vnodeComponentOptions.propsData, opts._parentListeners = vnodeComponentOptions.listeners, 
                    opts._renderChildren = vnodeComponentOptions.children, opts._componentTag = vnodeComponentOptions.tag, 
                    options.render && (opts.render = options.render, opts.staticRenderFns = options.staticRenderFns);
                }(vm, options) : vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm), 
                vm._renderProxy = vm, vm._self = vm, function(vm) {
                    var options = vm.$options, parent = options.parent;
                    if (parent && !options.abstract) {
                        for (;parent.$options.abstract && parent.$parent; ) parent = parent.$parent;
                        parent.$children.push(vm);
                    }
                    vm.$parent = parent, vm.$root = parent ? parent.$root : vm, vm.$children = [], vm.$refs = {}, 
                    vm._watcher = null, vm._inactive = null, vm._directInactive = !1, vm._isMounted = !1, 
                    vm._isDestroyed = !1, vm._isBeingDestroyed = !1;
                }(vm), function(vm) {
                    vm._events = Object.create(null), vm._hasHookEvent = !1;
                    var listeners = vm.$options._parentListeners;
                    listeners && updateComponentListeners(vm, listeners);
                }(vm), function(vm) {
                    vm._vnode = null, vm._staticTrees = null;
                    var options = vm.$options, parentVnode = vm.$vnode = options._parentVnode, renderContext = parentVnode && parentVnode.context;
                    vm.$slots = resolveSlots(options._renderChildren, renderContext), vm.$scopedSlots = emptyObject, 
                    vm._c = function(a, b, c, d) {
                        return createElement(vm, a, b, c, d, !1);
                    }, vm.$createElement = function(a, b, c, d) {
                        return createElement(vm, a, b, c, d, !0);
                    };
                    var parentData = parentVnode && parentVnode.data;
                    defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, null, !0), 
                    defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, null, !0);
                }(vm), callHook(vm, "beforeCreate"), function(vm) {
                    var result = resolveInject(vm.$options.inject, vm);
                    result && (toggleObserving(!1), Object.keys(result).forEach((function(key) {
                        defineReactive$$1(vm, key, result[key]);
                    })), toggleObserving(!0));
                }(vm), initState(vm), function(vm) {
                    var provide = vm.$options.provide;
                    provide && (vm._provided = "function" == typeof provide ? provide.call(vm) : provide);
                }(vm), callHook(vm, "created"), vm.$options.el && vm.$mount(vm.$options.el);
            };
        }(Vue), function(Vue) {
            var dataDef = {
                get: function() {
                    return this._data;
                }
            }, propsDef = {
                get: function() {
                    return this._props;
                }
            };
            Object.defineProperty(Vue.prototype, "$data", dataDef), Object.defineProperty(Vue.prototype, "$props", propsDef), 
            Vue.prototype.$set = set, Vue.prototype.$delete = del, Vue.prototype.$watch = function(expOrFn, cb, options) {
                if (isPlainObject(cb)) return createWatcher(this, expOrFn, cb, options);
                (options = options || {}).user = !0;
                var watcher = new Watcher(this, expOrFn, cb, options);
                if (options.immediate) try {
                    cb.call(this, watcher.value);
                } catch (error) {
                    handleError(error, this, 'callback for immediate watcher "' + watcher.expression + '"');
                }
                return function() {
                    watcher.teardown();
                };
            };
        }(Vue), function(Vue) {
            var hookRE = /^hook:/;
            Vue.prototype.$on = function(event, fn) {
                var vm = this;
                if (Array.isArray(event)) for (var i = 0, l = event.length; i < l; i++) vm.$on(event[i], fn); else (vm._events[event] || (vm._events[event] = [])).push(fn), 
                hookRE.test(event) && (vm._hasHookEvent = !0);
                return vm;
            }, Vue.prototype.$once = function(event, fn) {
                var vm = this;
                function on() {
                    vm.$off(event, on), fn.apply(vm, arguments);
                }
                return on.fn = fn, vm.$on(event, on), vm;
            }, Vue.prototype.$off = function(event, fn) {
                var vm = this;
                if (!arguments.length) return vm._events = Object.create(null), vm;
                if (Array.isArray(event)) {
                    for (var i$1 = 0, l = event.length; i$1 < l; i$1++) vm.$off(event[i$1], fn);
                    return vm;
                }
                var cb, cbs = vm._events[event];
                if (!cbs) return vm;
                if (!fn) return vm._events[event] = null, vm;
                for (var i = cbs.length; i--; ) if ((cb = cbs[i]) === fn || cb.fn === fn) {
                    cbs.splice(i, 1);
                    break;
                }
                return vm;
            }, Vue.prototype.$emit = function(event) {
                var vm = this, cbs = vm._events[event];
                if (cbs) {
                    cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                    for (var args = toArray(arguments, 1), info = 'event handler for "' + event + '"', i = 0, l = cbs.length; i < l; i++) invokeWithErrorHandling(cbs[i], vm, args, vm, info);
                }
                return vm;
            };
        }(Vue), function(Vue) {
            Vue.prototype._update = function(vnode, hydrating) {
                var vm = this, prevEl = vm.$el, prevVnode = vm._vnode, restoreActiveInstance = setActiveInstance(vm);
                vm._vnode = vnode, vm.$el = prevVnode ? vm.__patch__(prevVnode, vnode) : vm.__patch__(vm.$el, vnode, hydrating, !1), 
                restoreActiveInstance(), prevEl && (prevEl.__vue__ = null), vm.$el && (vm.$el.__vue__ = vm), 
                vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode && (vm.$parent.$el = vm.$el);
            }, Vue.prototype.$forceUpdate = function() {
                this._watcher && this._watcher.update();
            }, Vue.prototype.$destroy = function() {
                var vm = this;
                if (!vm._isBeingDestroyed) {
                    callHook(vm, "beforeDestroy"), vm._isBeingDestroyed = !0;
                    var parent = vm.$parent;
                    !parent || parent._isBeingDestroyed || vm.$options.abstract || remove(parent.$children, vm), 
                    vm._watcher && vm._watcher.teardown();
                    for (var i = vm._watchers.length; i--; ) vm._watchers[i].teardown();
                    vm._data.__ob__ && vm._data.__ob__.vmCount--, vm._isDestroyed = !0, vm.__patch__(vm._vnode, null), 
                    callHook(vm, "destroyed"), vm.$off(), vm.$el && (vm.$el.__vue__ = null), vm.$vnode && (vm.$vnode.parent = null);
                }
            };
        }(Vue), function(Vue) {
            installRenderHelpers(Vue.prototype), Vue.prototype.$nextTick = function(fn) {
                return nextTick(fn, this);
            }, Vue.prototype._render = function() {
                var vnode, vm = this, ref = vm.$options, render = ref.render, _parentVnode = ref._parentVnode;
                _parentVnode && (vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots)), 
                vm.$vnode = _parentVnode;
                try {
                    currentRenderingInstance = vm, vnode = render.call(vm._renderProxy, vm.$createElement);
                } catch (e) {
                    handleError(e, vm, "render"), vnode = vm._vnode;
                } finally {
                    currentRenderingInstance = null;
                }
                return Array.isArray(vnode) && 1 === vnode.length && (vnode = vnode[0]), vnode instanceof VNode || (vnode = createEmptyVNode()), 
                vnode.parent = _parentVnode, vnode;
            };
        }(Vue);
        var patternTypes = [ String, RegExp, Array ], builtInComponents = {
            KeepAlive: {
                name: "keep-alive",
                abstract: !0,
                props: {
                    include: patternTypes,
                    exclude: patternTypes,
                    max: [ String, Number ]
                },
                created: function() {
                    this.cache = Object.create(null), this.keys = [];
                },
                destroyed: function() {
                    for (var key in this.cache) pruneCacheEntry(this.cache, key, this.keys);
                },
                mounted: function() {
                    var this$1 = this;
                    this.$watch("include", (function(val) {
                        pruneCache(this$1, (function(name) {
                            return matches(val, name);
                        }));
                    })), this.$watch("exclude", (function(val) {
                        pruneCache(this$1, (function(name) {
                            return !matches(val, name);
                        }));
                    }));
                },
                render: function() {
                    var slot = this.$slots.default, vnode = getFirstComponentChild(slot), componentOptions = vnode && vnode.componentOptions;
                    if (componentOptions) {
                        var name = getComponentName(componentOptions), include = this.include, exclude = this.exclude;
                        if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) return vnode;
                        var cache = this.cache, keys = this.keys, key = null == vnode.key ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
                        cache[key] ? (vnode.componentInstance = cache[key].componentInstance, remove(keys, key), 
                        keys.push(key)) : (cache[key] = vnode, keys.push(key), this.max && keys.length > parseInt(this.max) && pruneCacheEntry(cache, keys[0], keys, this._vnode)), 
                        vnode.data.keepAlive = !0;
                    }
                    return vnode || slot && slot[0];
                }
            }
        };
        !function(Vue) {
            var configDef = {
                get: function() {
                    return config;
                }
            };
            Object.defineProperty(Vue, "config", configDef), Vue.util = {
                warn: warn,
                extend: extend,
                mergeOptions: mergeOptions,
                defineReactive: defineReactive$$1
            }, Vue.set = set, Vue.delete = del, Vue.nextTick = nextTick, Vue.observable = function(obj) {
                return observe(obj), obj;
            }, Vue.options = Object.create(null), ASSET_TYPES.forEach((function(type) {
                Vue.options[type + "s"] = Object.create(null);
            })), Vue.options._base = Vue, extend(Vue.options.components, builtInComponents), 
            function(Vue) {
                Vue.use = function(plugin) {
                    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
                    if (installedPlugins.indexOf(plugin) > -1) return this;
                    var args = toArray(arguments, 1);
                    return args.unshift(this), "function" == typeof plugin.install ? plugin.install.apply(plugin, args) : "function" == typeof plugin && plugin.apply(null, args), 
                    installedPlugins.push(plugin), this;
                };
            }(Vue), function(Vue) {
                Vue.mixin = function(mixin) {
                    return this.options = mergeOptions(this.options, mixin), this;
                };
            }(Vue), initExtend(Vue), function(Vue) {
                ASSET_TYPES.forEach((function(type) {
                    Vue[type] = function(id, definition) {
                        return definition ? ("component" === type && isPlainObject(definition) && (definition.name = definition.name || id, 
                        definition = this.options._base.extend(definition)), "directive" === type && "function" == typeof definition && (definition = {
                            bind: definition,
                            update: definition
                        }), this.options[type + "s"][id] = definition, definition) : this.options[type + "s"][id];
                    };
                }));
            }(Vue);
        }(Vue), Object.defineProperty(Vue.prototype, "$isServer", {
            get: isServerRendering
        }), Object.defineProperty(Vue.prototype, "$ssrContext", {
            get: function() {
                return this.$vnode && this.$vnode.ssrContext;
            }
        }), Object.defineProperty(Vue, "FunctionalRenderContext", {
            value: FunctionalRenderContext
        }), Vue.version = "2.6.12";
        var isReservedAttr = makeMap("style,class"), acceptValue = makeMap("input,textarea,option,select,progress"), mustUseProp = function(tag, type, attr) {
            return "value" === attr && acceptValue(tag) && "button" !== type || "selected" === attr && "option" === tag || "checked" === attr && "input" === tag || "muted" === attr && "video" === tag;
        }, isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck"), isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only"), isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"), xlinkNS = "http://www.w3.org/1999/xlink", isXlink = function(name) {
            return ":" === name.charAt(5) && "xlink" === name.slice(0, 5);
        }, getXlinkProp = function(name) {
            return isXlink(name) ? name.slice(6, name.length) : "";
        }, isFalsyAttrValue = function(val) {
            return null == val || !1 === val;
        };
        function genClassForVnode(vnode) {
            for (var data = vnode.data, parentNode = vnode, childNode = vnode; isDef(childNode.componentInstance); ) (childNode = childNode.componentInstance._vnode) && childNode.data && (data = mergeClassData(childNode.data, data));
            for (;isDef(parentNode = parentNode.parent); ) parentNode && parentNode.data && (data = mergeClassData(data, parentNode.data));
            return function(staticClass, dynamicClass) {
                if (isDef(staticClass) || isDef(dynamicClass)) return concat(staticClass, stringifyClass(dynamicClass));
                return "";
            }(data.staticClass, data.class);
        }
        function mergeClassData(child, parent) {
            return {
                staticClass: concat(child.staticClass, parent.staticClass),
                class: isDef(child.class) ? [ child.class, parent.class ] : parent.class
            };
        }
        function concat(a, b) {
            return a ? b ? a + " " + b : a : b || "";
        }
        function stringifyClass(value) {
            return Array.isArray(value) ? function(value) {
                for (var stringified, res = "", i = 0, l = value.length; i < l; i++) isDef(stringified = stringifyClass(value[i])) && "" !== stringified && (res && (res += " "), 
                res += stringified);
                return res;
            }(value) : isObject(value) ? function(value) {
                var res = "";
                for (var key in value) value[key] && (res && (res += " "), res += key);
                return res;
            }(value) : "string" == typeof value ? value : "";
        }
        var namespaceMap = {
            svg: "http://www.w3.org/2000/svg",
            math: "http://www.w3.org/1998/Math/MathML"
        }, isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), isReservedTag = function(tag) {
            return isHTMLTag(tag) || isSVG(tag);
        };
        function getTagNamespace(tag) {
            return isSVG(tag) ? "svg" : "math" === tag ? "math" : void 0;
        }
        var unknownElementCache = Object.create(null);
        var isTextInputType = makeMap("text,number,password,search,email,tel,url");
        function query(el) {
            if ("string" == typeof el) {
                var selected = document.querySelector(el);
                return selected || document.createElement("div");
            }
            return el;
        }
        var nodeOps = Object.freeze({
            createElement: function(tagName, vnode) {
                var elm = document.createElement(tagName);
                return "select" !== tagName || vnode.data && vnode.data.attrs && void 0 !== vnode.data.attrs.multiple && elm.setAttribute("multiple", "multiple"), 
                elm;
            },
            createElementNS: function(namespace, tagName) {
                return document.createElementNS(namespaceMap[namespace], tagName);
            },
            createTextNode: function(text) {
                return document.createTextNode(text);
            },
            createComment: function(text) {
                return document.createComment(text);
            },
            insertBefore: function(parentNode, newNode, referenceNode) {
                parentNode.insertBefore(newNode, referenceNode);
            },
            removeChild: function(node, child) {
                node.removeChild(child);
            },
            appendChild: function(node, child) {
                node.appendChild(child);
            },
            parentNode: function(node) {
                return node.parentNode;
            },
            nextSibling: function(node) {
                return node.nextSibling;
            },
            tagName: function(node) {
                return node.tagName;
            },
            setTextContent: function(node, text) {
                node.textContent = text;
            },
            setStyleScope: function(node, scopeId) {
                node.setAttribute(scopeId, "");
            }
        }), ref = {
            create: function(_, vnode) {
                registerRef(vnode);
            },
            update: function(oldVnode, vnode) {
                oldVnode.data.ref !== vnode.data.ref && (registerRef(oldVnode, !0), registerRef(vnode));
            },
            destroy: function(vnode) {
                registerRef(vnode, !0);
            }
        };
        function registerRef(vnode, isRemoval) {
            var key = vnode.data.ref;
            if (isDef(key)) {
                var vm = vnode.context, ref = vnode.componentInstance || vnode.elm, refs = vm.$refs;
                isRemoval ? Array.isArray(refs[key]) ? remove(refs[key], ref) : refs[key] === ref && (refs[key] = void 0) : vnode.data.refInFor ? Array.isArray(refs[key]) ? refs[key].indexOf(ref) < 0 && refs[key].push(ref) : refs[key] = [ ref ] : refs[key] = ref;
            }
        }
        var emptyNode = new VNode("", {}, []), hooks = [ "create", "activate", "update", "remove", "destroy" ];
        function sameVnode(a, b) {
            return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && function(a, b) {
                if ("input" !== a.tag) return !0;
                var i, typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type, typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
                return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
            }(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
        }
        function createKeyToOldIdx(children, beginIdx, endIdx) {
            var i, key, map = {};
            for (i = beginIdx; i <= endIdx; ++i) isDef(key = children[i].key) && (map[key] = i);
            return map;
        }
        var directives = {
            create: updateDirectives,
            update: updateDirectives,
            destroy: function(vnode) {
                updateDirectives(vnode, emptyNode);
            }
        };
        function updateDirectives(oldVnode, vnode) {
            (oldVnode.data.directives || vnode.data.directives) && function(oldVnode, vnode) {
                var key, oldDir, dir, isCreate = oldVnode === emptyNode, isDestroy = vnode === emptyNode, oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context), newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context), dirsWithInsert = [], dirsWithPostpatch = [];
                for (key in newDirs) oldDir = oldDirs[key], dir = newDirs[key], oldDir ? (dir.oldValue = oldDir.value, 
                dir.oldArg = oldDir.arg, callHook$1(dir, "update", vnode, oldVnode), dir.def && dir.def.componentUpdated && dirsWithPostpatch.push(dir)) : (callHook$1(dir, "bind", vnode, oldVnode), 
                dir.def && dir.def.inserted && dirsWithInsert.push(dir));
                if (dirsWithInsert.length) {
                    var callInsert = function() {
                        for (var i = 0; i < dirsWithInsert.length; i++) callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
                    };
                    isCreate ? mergeVNodeHook(vnode, "insert", callInsert) : callInsert();
                }
                dirsWithPostpatch.length && mergeVNodeHook(vnode, "postpatch", (function() {
                    for (var i = 0; i < dirsWithPostpatch.length; i++) callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
                }));
                if (!isCreate) for (key in oldDirs) newDirs[key] || callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
            }(oldVnode, vnode);
        }
        var emptyModifiers = Object.create(null);
        function normalizeDirectives$1(dirs, vm) {
            var i, dir, res = Object.create(null);
            if (!dirs) return res;
            for (i = 0; i < dirs.length; i++) (dir = dirs[i]).modifiers || (dir.modifiers = emptyModifiers), 
            res[getRawDirName(dir)] = dir, dir.def = resolveAsset(vm.$options, "directives", dir.name);
            return res;
        }
        function getRawDirName(dir) {
            return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
        }
        function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
            var fn = dir.def && dir.def[hook];
            if (fn) try {
                fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
            } catch (e) {
                handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
            }
        }
        var baseModules = [ ref, directives ];
        function updateAttrs(oldVnode, vnode) {
            var opts = vnode.componentOptions;
            if (!(isDef(opts) && !1 === opts.Ctor.options.inheritAttrs || isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs))) {
                var key, cur, elm = vnode.elm, oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
                for (key in isDef(attrs.__ob__) && (attrs = vnode.data.attrs = extend({}, attrs)), 
                attrs) cur = attrs[key], oldAttrs[key] !== cur && setAttr(elm, key, cur);
                for (key in (isIE || isEdge) && attrs.value !== oldAttrs.value && setAttr(elm, "value", attrs.value), 
                oldAttrs) isUndef(attrs[key]) && (isXlink(key) ? elm.removeAttributeNS(xlinkNS, getXlinkProp(key)) : isEnumeratedAttr(key) || elm.removeAttribute(key));
            }
        }
        function setAttr(el, key, value) {
            el.tagName.indexOf("-") > -1 ? baseSetAttr(el, key, value) : isBooleanAttr(key) ? isFalsyAttrValue(value) ? el.removeAttribute(key) : (value = "allowfullscreen" === key && "EMBED" === el.tagName ? "true" : key, 
            el.setAttribute(key, value)) : isEnumeratedAttr(key) ? el.setAttribute(key, function(key, value) {
                return isFalsyAttrValue(value) || "false" === value ? "false" : "contenteditable" === key && isValidContentEditableValue(value) ? value : "true";
            }(key, value)) : isXlink(key) ? isFalsyAttrValue(value) ? el.removeAttributeNS(xlinkNS, getXlinkProp(key)) : el.setAttributeNS(xlinkNS, key, value) : baseSetAttr(el, key, value);
        }
        function baseSetAttr(el, key, value) {
            if (isFalsyAttrValue(value)) el.removeAttribute(key); else {
                if (isIE && !isIE9 && "TEXTAREA" === el.tagName && "placeholder" === key && "" !== value && !el.__ieph) {
                    var blocker = function(e) {
                        e.stopImmediatePropagation(), el.removeEventListener("input", blocker);
                    };
                    el.addEventListener("input", blocker), el.__ieph = !0;
                }
                el.setAttribute(key, value);
            }
        }
        var attrs = {
            create: updateAttrs,
            update: updateAttrs
        };
        function updateClass(oldVnode, vnode) {
            var el = vnode.elm, data = vnode.data, oldData = oldVnode.data;
            if (!(isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
                var cls = genClassForVnode(vnode), transitionClass = el._transitionClasses;
                isDef(transitionClass) && (cls = concat(cls, stringifyClass(transitionClass))), 
                cls !== el._prevClass && (el.setAttribute("class", cls), el._prevClass = cls);
            }
        }
        var len, str, chr, index$1, expressionPos, expressionEndPos, klass = {
            create: updateClass,
            update: updateClass
        }, validDivisionCharRE = /[\w).+\-_$\]]/;
        function parseFilters(exp) {
            var c, prev, i, expression, filters, inSingle = !1, inDouble = !1, inTemplateString = !1, inRegex = !1, curly = 0, square = 0, paren = 0, lastFilterIndex = 0;
            for (i = 0; i < exp.length; i++) if (prev = c, c = exp.charCodeAt(i), inSingle) 39 === c && 92 !== prev && (inSingle = !1); else if (inDouble) 34 === c && 92 !== prev && (inDouble = !1); else if (inTemplateString) 96 === c && 92 !== prev && (inTemplateString = !1); else if (inRegex) 47 === c && 92 !== prev && (inRegex = !1); else if (124 !== c || 124 === exp.charCodeAt(i + 1) || 124 === exp.charCodeAt(i - 1) || curly || square || paren) {
                switch (c) {
                  case 34:
                    inDouble = !0;
                    break;

                  case 39:
                    inSingle = !0;
                    break;

                  case 96:
                    inTemplateString = !0;
                    break;

                  case 40:
                    paren++;
                    break;

                  case 41:
                    paren--;
                    break;

                  case 91:
                    square++;
                    break;

                  case 93:
                    square--;
                    break;

                  case 123:
                    curly++;
                    break;

                  case 125:
                    curly--;
                }
                if (47 === c) {
                    for (var j = i - 1, p = void 0; j >= 0 && " " === (p = exp.charAt(j)); j--) ;
                    p && validDivisionCharRE.test(p) || (inRegex = !0);
                }
            } else void 0 === expression ? (lastFilterIndex = i + 1, expression = exp.slice(0, i).trim()) : pushFilter();
            function pushFilter() {
                (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim()), lastFilterIndex = i + 1;
            }
            if (void 0 === expression ? expression = exp.slice(0, i).trim() : 0 !== lastFilterIndex && pushFilter(), 
            filters) for (i = 0; i < filters.length; i++) expression = wrapFilter(expression, filters[i]);
            return expression;
        }
        function wrapFilter(exp, filter) {
            var i = filter.indexOf("(");
            if (i < 0) return '_f("' + filter + '")(' + exp + ")";
            var name = filter.slice(0, i), args = filter.slice(i + 1);
            return '_f("' + name + '")(' + exp + (")" !== args ? "," + args : args);
        }
        function baseWarn(msg, range) {
            console.error("[Vue compiler]: " + msg);
        }
        function pluckModuleFunction(modules, key) {
            return modules ? modules.map((function(m) {
                return m[key];
            })).filter((function(_) {
                return _;
            })) : [];
        }
        function addProp(el, name, value, range, dynamic) {
            (el.props || (el.props = [])).push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic
            }, range)), el.plain = !1;
        }
        function addAttr(el, name, value, range, dynamic) {
            (dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = [])).push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic
            }, range)), el.plain = !1;
        }
        function addRawAttr(el, name, value, range) {
            el.attrsMap[name] = value, el.attrsList.push(rangeSetItem({
                name: name,
                value: value
            }, range));
        }
        function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
            (el.directives || (el.directives = [])).push(rangeSetItem({
                name: name,
                rawName: rawName,
                value: value,
                arg: arg,
                isDynamicArg: isDynamicArg,
                modifiers: modifiers
            }, range)), el.plain = !1;
        }
        function prependModifierMarker(symbol, name, dynamic) {
            return dynamic ? "_p(" + name + ',"' + symbol + '")' : symbol + name;
        }
        function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
            var events;
            (modifiers = modifiers || emptyObject).right ? dynamic ? name = "(" + name + ")==='click'?'contextmenu':(" + name + ")" : "click" === name && (name = "contextmenu", 
            delete modifiers.right) : modifiers.middle && (dynamic ? name = "(" + name + ")==='click'?'mouseup':(" + name + ")" : "click" === name && (name = "mouseup")), 
            modifiers.capture && (delete modifiers.capture, name = prependModifierMarker("!", name, dynamic)), 
            modifiers.once && (delete modifiers.once, name = prependModifierMarker("~", name, dynamic)), 
            modifiers.passive && (delete modifiers.passive, name = prependModifierMarker("&", name, dynamic)), 
            modifiers.native ? (delete modifiers.native, events = el.nativeEvents || (el.nativeEvents = {})) : events = el.events || (el.events = {});
            var newHandler = rangeSetItem({
                value: value.trim(),
                dynamic: dynamic
            }, range);
            modifiers !== emptyObject && (newHandler.modifiers = modifiers);
            var handlers = events[name];
            Array.isArray(handlers) ? important ? handlers.unshift(newHandler) : handlers.push(newHandler) : events[name] = handlers ? important ? [ newHandler, handlers ] : [ handlers, newHandler ] : newHandler, 
            el.plain = !1;
        }
        function getBindingAttr(el, name, getStatic) {
            var dynamicValue = getAndRemoveAttr(el, ":" + name) || getAndRemoveAttr(el, "v-bind:" + name);
            if (null != dynamicValue) return parseFilters(dynamicValue);
            if (!1 !== getStatic) {
                var staticValue = getAndRemoveAttr(el, name);
                if (null != staticValue) return JSON.stringify(staticValue);
            }
        }
        function getAndRemoveAttr(el, name, removeFromMap) {
            var val;
            if (null != (val = el.attrsMap[name])) for (var list = el.attrsList, i = 0, l = list.length; i < l; i++) if (list[i].name === name) {
                list.splice(i, 1);
                break;
            }
            return removeFromMap && delete el.attrsMap[name], val;
        }
        function getAndRemoveAttrByRegex(el, name) {
            for (var list = el.attrsList, i = 0, l = list.length; i < l; i++) {
                var attr = list[i];
                if (name.test(attr.name)) return list.splice(i, 1), attr;
            }
        }
        function rangeSetItem(item, range) {
            return range && (null != range.start && (item.start = range.start), null != range.end && (item.end = range.end)), 
            item;
        }
        function genComponentModel(el, value, modifiers) {
            var ref = modifiers || {}, number = ref.number, valueExpression = "$$v";
            ref.trim && (valueExpression = "(typeof $$v === 'string'? $$v.trim(): $$v)"), number && (valueExpression = "_n(" + valueExpression + ")");
            var assignment = genAssignmentCode(value, valueExpression);
            el.model = {
                value: "(" + value + ")",
                expression: JSON.stringify(value),
                callback: "function ($$v) {" + assignment + "}"
            };
        }
        function genAssignmentCode(value, assignment) {
            var res = function(val) {
                if (val = val.trim(), len = val.length, val.indexOf("[") < 0 || val.lastIndexOf("]") < len - 1) return (index$1 = val.lastIndexOf(".")) > -1 ? {
                    exp: val.slice(0, index$1),
                    key: '"' + val.slice(index$1 + 1) + '"'
                } : {
                    exp: val,
                    key: null
                };
                str = val, index$1 = expressionPos = expressionEndPos = 0;
                for (;!eof(); ) isStringStart(chr = next()) ? parseString(chr) : 91 === chr && parseBracket(chr);
                return {
                    exp: val.slice(0, expressionPos),
                    key: val.slice(expressionPos + 1, expressionEndPos)
                };
            }(value);
            return null === res.key ? value + "=" + assignment : "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
        }
        function next() {
            return str.charCodeAt(++index$1);
        }
        function eof() {
            return index$1 >= len;
        }
        function isStringStart(chr) {
            return 34 === chr || 39 === chr;
        }
        function parseBracket(chr) {
            var inBracket = 1;
            for (expressionPos = index$1; !eof(); ) if (isStringStart(chr = next())) parseString(chr); else if (91 === chr && inBracket++, 
            93 === chr && inBracket--, 0 === inBracket) {
                expressionEndPos = index$1;
                break;
            }
        }
        function parseString(chr) {
            for (var stringQuote = chr; !eof() && (chr = next()) !== stringQuote; ) ;
        }
        var target$1;
        function createOnceHandler$1(event, handler, capture) {
            var _target = target$1;
            return function onceHandler() {
                var res = handler.apply(null, arguments);
                null !== res && remove$2(event, onceHandler, capture, _target);
            };
        }
        var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
        function add$1(name, handler, capture, passive) {
            if (useMicrotaskFix) {
                var attachedTimestamp = currentFlushTimestamp, original = handler;
                handler = original._wrapper = function(e) {
                    if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) return original.apply(this, arguments);
                };
            }
            target$1.addEventListener(name, handler, supportsPassive ? {
                capture: capture,
                passive: passive
            } : capture);
        }
        function remove$2(name, handler, capture, _target) {
            (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
        }
        function updateDOMListeners(oldVnode, vnode) {
            if (!isUndef(oldVnode.data.on) || !isUndef(vnode.data.on)) {
                var on = vnode.data.on || {}, oldOn = oldVnode.data.on || {};
                target$1 = vnode.elm, function(on) {
                    if (isDef(on.__r)) {
                        var event = isIE ? "change" : "input";
                        on[event] = [].concat(on.__r, on[event] || []), delete on.__r;
                    }
                    isDef(on.__c) && (on.change = [].concat(on.__c, on.change || []), delete on.__c);
                }(on), updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context), 
                target$1 = void 0;
            }
        }
        var svgContainer, events = {
            create: updateDOMListeners,
            update: updateDOMListeners
        };
        function updateDOMProps(oldVnode, vnode) {
            if (!isUndef(oldVnode.data.domProps) || !isUndef(vnode.data.domProps)) {
                var key, cur, elm = vnode.elm, oldProps = oldVnode.data.domProps || {}, props = vnode.data.domProps || {};
                for (key in isDef(props.__ob__) && (props = vnode.data.domProps = extend({}, props)), 
                oldProps) key in props || (elm[key] = "");
                for (key in props) {
                    if (cur = props[key], "textContent" === key || "innerHTML" === key) {
                        if (vnode.children && (vnode.children.length = 0), cur === oldProps[key]) continue;
                        1 === elm.childNodes.length && elm.removeChild(elm.childNodes[0]);
                    }
                    if ("value" === key && "PROGRESS" !== elm.tagName) {
                        elm._value = cur;
                        var strCur = isUndef(cur) ? "" : String(cur);
                        shouldUpdateValue(elm, strCur) && (elm.value = strCur);
                    } else if ("innerHTML" === key && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
                        (svgContainer = svgContainer || document.createElement("div")).innerHTML = "<svg>" + cur + "</svg>";
                        for (var svg = svgContainer.firstChild; elm.firstChild; ) elm.removeChild(elm.firstChild);
                        for (;svg.firstChild; ) elm.appendChild(svg.firstChild);
                    } else if (cur !== oldProps[key]) try {
                        elm[key] = cur;
                    } catch (e) {}
                }
            }
        }
        function shouldUpdateValue(elm, checkVal) {
            return !elm.composing && ("OPTION" === elm.tagName || function(elm, checkVal) {
                var notInFocus = !0;
                try {
                    notInFocus = document.activeElement !== elm;
                } catch (e) {}
                return notInFocus && elm.value !== checkVal;
            }(elm, checkVal) || function(elm, newVal) {
                var value = elm.value, modifiers = elm._vModifiers;
                if (isDef(modifiers)) {
                    if (modifiers.number) return toNumber(value) !== toNumber(newVal);
                    if (modifiers.trim) return value.trim() !== newVal.trim();
                }
                return value !== newVal;
            }(elm, checkVal));
        }
        var domProps = {
            create: updateDOMProps,
            update: updateDOMProps
        }, parseStyleText = cached((function(cssText) {
            var res = {}, propertyDelimiter = /:(.+)/;
            return cssText.split(/;(?![^(]*\))/g).forEach((function(item) {
                if (item) {
                    var tmp = item.split(propertyDelimiter);
                    tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                }
            })), res;
        }));
        function normalizeStyleData(data) {
            var style = normalizeStyleBinding(data.style);
            return data.staticStyle ? extend(data.staticStyle, style) : style;
        }
        function normalizeStyleBinding(bindingStyle) {
            return Array.isArray(bindingStyle) ? toObject(bindingStyle) : "string" == typeof bindingStyle ? parseStyleText(bindingStyle) : bindingStyle;
        }
        var emptyStyle, cssVarRE = /^--/, importantRE = /\s*!important$/, setProp = function(el, name, val) {
            if (cssVarRE.test(name)) el.style.setProperty(name, val); else if (importantRE.test(val)) el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important"); else {
                var normalizedName = normalize(name);
                if (Array.isArray(val)) for (var i = 0, len = val.length; i < len; i++) el.style[normalizedName] = val[i]; else el.style[normalizedName] = val;
            }
        }, vendorNames = [ "Webkit", "Moz", "ms" ], normalize = cached((function(prop) {
            if (emptyStyle = emptyStyle || document.createElement("div").style, "filter" !== (prop = camelize(prop)) && prop in emptyStyle) return prop;
            for (var capName = prop.charAt(0).toUpperCase() + prop.slice(1), i = 0; i < vendorNames.length; i++) {
                var name = vendorNames[i] + capName;
                if (name in emptyStyle) return name;
            }
        }));
        function updateStyle(oldVnode, vnode) {
            var data = vnode.data, oldData = oldVnode.data;
            if (!(isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style))) {
                var cur, name, el = vnode.elm, oldStaticStyle = oldData.staticStyle, oldStyleBinding = oldData.normalizedStyle || oldData.style || {}, oldStyle = oldStaticStyle || oldStyleBinding, style = normalizeStyleBinding(vnode.data.style) || {};
                vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
                var newStyle = function(vnode, checkChild) {
                    var styleData, res = {};
                    if (checkChild) for (var childNode = vnode; childNode.componentInstance; ) (childNode = childNode.componentInstance._vnode) && childNode.data && (styleData = normalizeStyleData(childNode.data)) && extend(res, styleData);
                    (styleData = normalizeStyleData(vnode.data)) && extend(res, styleData);
                    for (var parentNode = vnode; parentNode = parentNode.parent; ) parentNode.data && (styleData = normalizeStyleData(parentNode.data)) && extend(res, styleData);
                    return res;
                }(vnode, !0);
                for (name in oldStyle) isUndef(newStyle[name]) && setProp(el, name, "");
                for (name in newStyle) (cur = newStyle[name]) !== oldStyle[name] && setProp(el, name, null == cur ? "" : cur);
            }
        }
        var style = {
            create: updateStyle,
            update: updateStyle
        }, whitespaceRE = /\s+/;
        function addClass(el, cls) {
            if (cls && (cls = cls.trim())) if (el.classList) cls.indexOf(" ") > -1 ? cls.split(whitespaceRE).forEach((function(c) {
                return el.classList.add(c);
            })) : el.classList.add(cls); else {
                var cur = " " + (el.getAttribute("class") || "") + " ";
                cur.indexOf(" " + cls + " ") < 0 && el.setAttribute("class", (cur + cls).trim());
            }
        }
        function removeClass(el, cls) {
            if (cls && (cls = cls.trim())) if (el.classList) cls.indexOf(" ") > -1 ? cls.split(whitespaceRE).forEach((function(c) {
                return el.classList.remove(c);
            })) : el.classList.remove(cls), el.classList.length || el.removeAttribute("class"); else {
                for (var cur = " " + (el.getAttribute("class") || "") + " ", tar = " " + cls + " "; cur.indexOf(tar) >= 0; ) cur = cur.replace(tar, " ");
                (cur = cur.trim()) ? el.setAttribute("class", cur) : el.removeAttribute("class");
            }
        }
        function resolveTransition(def$$1) {
            if (def$$1) {
                if ("object" == typeof def$$1) {
                    var res = {};
                    return !1 !== def$$1.css && extend(res, autoCssTransition(def$$1.name || "v")), 
                    extend(res, def$$1), res;
                }
                return "string" == typeof def$$1 ? autoCssTransition(def$$1) : void 0;
            }
        }
        var autoCssTransition = cached((function(name) {
            return {
                enterClass: name + "-enter",
                enterToClass: name + "-enter-to",
                enterActiveClass: name + "-enter-active",
                leaveClass: name + "-leave",
                leaveToClass: name + "-leave-to",
                leaveActiveClass: name + "-leave-active"
            };
        })), hasTransition = inBrowser && !isIE9, transitionProp = "transition", transitionEndEvent = "transitionend", animationProp = "animation", animationEndEvent = "animationend";
        hasTransition && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (transitionProp = "WebkitTransition", 
        transitionEndEvent = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (animationProp = "WebkitAnimation", 
        animationEndEvent = "webkitAnimationEnd"));
        var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
            return fn();
        };
        function nextFrame(fn) {
            raf((function() {
                raf(fn);
            }));
        }
        function addTransitionClass(el, cls) {
            var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
            transitionClasses.indexOf(cls) < 0 && (transitionClasses.push(cls), addClass(el, cls));
        }
        function removeTransitionClass(el, cls) {
            el._transitionClasses && remove(el._transitionClasses, cls), removeClass(el, cls);
        }
        function whenTransitionEnds(el, expectedType, cb) {
            var ref = getTransitionInfo(el, expectedType), type = ref.type, timeout = ref.timeout, propCount = ref.propCount;
            if (!type) return cb();
            var event = "transition" === type ? transitionEndEvent : animationEndEvent, ended = 0, end = function() {
                el.removeEventListener(event, onEnd), cb();
            }, onEnd = function(e) {
                e.target === el && ++ended >= propCount && end();
            };
            setTimeout((function() {
                ended < propCount && end();
            }), timeout + 1), el.addEventListener(event, onEnd);
        }
        var transformRE = /\b(transform|all)(,|$)/;
        function getTransitionInfo(el, expectedType) {
            var type, styles = window.getComputedStyle(el), transitionDelays = (styles[transitionProp + "Delay"] || "").split(", "), transitionDurations = (styles[transitionProp + "Duration"] || "").split(", "), transitionTimeout = getTimeout(transitionDelays, transitionDurations), animationDelays = (styles[animationProp + "Delay"] || "").split(", "), animationDurations = (styles[animationProp + "Duration"] || "").split(", "), animationTimeout = getTimeout(animationDelays, animationDurations), timeout = 0, propCount = 0;
            return "transition" === expectedType ? transitionTimeout > 0 && (type = "transition", 
            timeout = transitionTimeout, propCount = transitionDurations.length) : "animation" === expectedType ? animationTimeout > 0 && (type = "animation", 
            timeout = animationTimeout, propCount = animationDurations.length) : propCount = (type = (timeout = Math.max(transitionTimeout, animationTimeout)) > 0 ? transitionTimeout > animationTimeout ? "transition" : "animation" : null) ? "transition" === type ? transitionDurations.length : animationDurations.length : 0, 
            {
                type: type,
                timeout: timeout,
                propCount: propCount,
                hasTransform: "transition" === type && transformRE.test(styles[transitionProp + "Property"])
            };
        }
        function getTimeout(delays, durations) {
            for (;delays.length < durations.length; ) delays = delays.concat(delays);
            return Math.max.apply(null, durations.map((function(d, i) {
                return toMs(d) + toMs(delays[i]);
            })));
        }
        function toMs(s) {
            return 1e3 * Number(s.slice(0, -1).replace(",", "."));
        }
        function enter(vnode, toggleDisplay) {
            var el = vnode.elm;
            isDef(el._leaveCb) && (el._leaveCb.cancelled = !0, el._leaveCb());
            var data = resolveTransition(vnode.data.transition);
            if (!isUndef(data) && !isDef(el._enterCb) && 1 === el.nodeType) {
                for (var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration, context = activeInstance, transitionNode = activeInstance.$vnode; transitionNode && transitionNode.parent; ) context = transitionNode.context, 
                transitionNode = transitionNode.parent;
                var isAppear = !context._isMounted || !vnode.isRootInsert;
                if (!isAppear || appear || "" === appear) {
                    var startClass = isAppear && appearClass ? appearClass : enterClass, activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass, toClass = isAppear && appearToClass ? appearToClass : enterToClass, beforeEnterHook = isAppear && beforeAppear || beforeEnter, enterHook = isAppear && "function" == typeof appear ? appear : enter, afterEnterHook = isAppear && afterAppear || afterEnter, enterCancelledHook = isAppear && appearCancelled || enterCancelled, explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
                    0;
                    var expectsCSS = !1 !== css && !isIE9, userWantsControl = getHookArgumentsLength(enterHook), cb = el._enterCb = once((function() {
                        expectsCSS && (removeTransitionClass(el, toClass), removeTransitionClass(el, activeClass)), 
                        cb.cancelled ? (expectsCSS && removeTransitionClass(el, startClass), enterCancelledHook && enterCancelledHook(el)) : afterEnterHook && afterEnterHook(el), 
                        el._enterCb = null;
                    }));
                    vnode.data.show || mergeVNodeHook(vnode, "insert", (function() {
                        var parent = el.parentNode, pendingNode = parent && parent._pending && parent._pending[vnode.key];
                        pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb && pendingNode.elm._leaveCb(), 
                        enterHook && enterHook(el, cb);
                    })), beforeEnterHook && beforeEnterHook(el), expectsCSS && (addTransitionClass(el, startClass), 
                    addTransitionClass(el, activeClass), nextFrame((function() {
                        removeTransitionClass(el, startClass), cb.cancelled || (addTransitionClass(el, toClass), 
                        userWantsControl || (isValidDuration(explicitEnterDuration) ? setTimeout(cb, explicitEnterDuration) : whenTransitionEnds(el, type, cb)));
                    }))), vnode.data.show && (toggleDisplay && toggleDisplay(), enterHook && enterHook(el, cb)), 
                    expectsCSS || userWantsControl || cb();
                }
            }
        }
        function leave(vnode, rm) {
            var el = vnode.elm;
            isDef(el._enterCb) && (el._enterCb.cancelled = !0, el._enterCb());
            var data = resolveTransition(vnode.data.transition);
            if (isUndef(data) || 1 !== el.nodeType) return rm();
            if (!isDef(el._leaveCb)) {
                var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration, expectsCSS = !1 !== css && !isIE9, userWantsControl = getHookArgumentsLength(leave), explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
                0;
                var cb = el._leaveCb = once((function() {
                    el.parentNode && el.parentNode._pending && (el.parentNode._pending[vnode.key] = null), 
                    expectsCSS && (removeTransitionClass(el, leaveToClass), removeTransitionClass(el, leaveActiveClass)), 
                    cb.cancelled ? (expectsCSS && removeTransitionClass(el, leaveClass), leaveCancelled && leaveCancelled(el)) : (rm(), 
                    afterLeave && afterLeave(el)), el._leaveCb = null;
                }));
                delayLeave ? delayLeave(performLeave) : performLeave();
            }
            function performLeave() {
                cb.cancelled || (!vnode.data.show && el.parentNode && ((el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode), 
                beforeLeave && beforeLeave(el), expectsCSS && (addTransitionClass(el, leaveClass), 
                addTransitionClass(el, leaveActiveClass), nextFrame((function() {
                    removeTransitionClass(el, leaveClass), cb.cancelled || (addTransitionClass(el, leaveToClass), 
                    userWantsControl || (isValidDuration(explicitLeaveDuration) ? setTimeout(cb, explicitLeaveDuration) : whenTransitionEnds(el, type, cb)));
                }))), leave && leave(el, cb), expectsCSS || userWantsControl || cb());
            }
        }
        function isValidDuration(val) {
            return "number" == typeof val && !isNaN(val);
        }
        function getHookArgumentsLength(fn) {
            if (isUndef(fn)) return !1;
            var invokerFns = fn.fns;
            return isDef(invokerFns) ? getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns) : (fn._length || fn.length) > 1;
        }
        function _enter(_, vnode) {
            !0 !== vnode.data.show && enter(vnode);
        }
        var patch = function(backend) {
            var i, j, cbs = {}, modules = backend.modules, nodeOps = backend.nodeOps;
            for (i = 0; i < hooks.length; ++i) for (cbs[hooks[i]] = [], j = 0; j < modules.length; ++j) isDef(modules[j][hooks[i]]) && cbs[hooks[i]].push(modules[j][hooks[i]]);
            function removeNode(el) {
                var parent = nodeOps.parentNode(el);
                isDef(parent) && nodeOps.removeChild(parent, el);
            }
            function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
                if (isDef(vnode.elm) && isDef(ownerArray) && (vnode = ownerArray[index] = cloneVNode(vnode)), 
                vnode.isRootInsert = !nested, !function(vnode, insertedVnodeQueue, parentElm, refElm) {
                    var i = vnode.data;
                    if (isDef(i)) {
                        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
                        if (isDef(i = i.hook) && isDef(i = i.init) && i(vnode, !1), isDef(vnode.componentInstance)) return initComponent(vnode, insertedVnodeQueue), 
                        insert(parentElm, vnode.elm, refElm), isTrue(isReactivated) && function(vnode, insertedVnodeQueue, parentElm, refElm) {
                            var i, innerNode = vnode;
                            for (;innerNode.componentInstance; ) if (innerNode = innerNode.componentInstance._vnode, 
                            isDef(i = innerNode.data) && isDef(i = i.transition)) {
                                for (i = 0; i < cbs.activate.length; ++i) cbs.activate[i](emptyNode, innerNode);
                                insertedVnodeQueue.push(innerNode);
                                break;
                            }
                            insert(parentElm, vnode.elm, refElm);
                        }(vnode, insertedVnodeQueue, parentElm, refElm), !0;
                    }
                }(vnode, insertedVnodeQueue, parentElm, refElm)) {
                    var data = vnode.data, children = vnode.children, tag = vnode.tag;
                    isDef(tag) ? (vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode), 
                    setScope(vnode), createChildren(vnode, children, insertedVnodeQueue), isDef(data) && invokeCreateHooks(vnode, insertedVnodeQueue), 
                    insert(parentElm, vnode.elm, refElm)) : isTrue(vnode.isComment) ? (vnode.elm = nodeOps.createComment(vnode.text), 
                    insert(parentElm, vnode.elm, refElm)) : (vnode.elm = nodeOps.createTextNode(vnode.text), 
                    insert(parentElm, vnode.elm, refElm));
                }
            }
            function initComponent(vnode, insertedVnodeQueue) {
                isDef(vnode.data.pendingInsert) && (insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert), 
                vnode.data.pendingInsert = null), vnode.elm = vnode.componentInstance.$el, isPatchable(vnode) ? (invokeCreateHooks(vnode, insertedVnodeQueue), 
                setScope(vnode)) : (registerRef(vnode), insertedVnodeQueue.push(vnode));
            }
            function insert(parent, elm, ref$$1) {
                isDef(parent) && (isDef(ref$$1) ? nodeOps.parentNode(ref$$1) === parent && nodeOps.insertBefore(parent, elm, ref$$1) : nodeOps.appendChild(parent, elm));
            }
            function createChildren(vnode, children, insertedVnodeQueue) {
                if (Array.isArray(children)) {
                    0;
                    for (var i = 0; i < children.length; ++i) createElm(children[i], insertedVnodeQueue, vnode.elm, null, !0, children, i);
                } else isPrimitive(vnode.text) && nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
            }
            function isPatchable(vnode) {
                for (;vnode.componentInstance; ) vnode = vnode.componentInstance._vnode;
                return isDef(vnode.tag);
            }
            function invokeCreateHooks(vnode, insertedVnodeQueue) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) cbs.create[i$1](emptyNode, vnode);
                isDef(i = vnode.data.hook) && (isDef(i.create) && i.create(emptyNode, vnode), isDef(i.insert) && insertedVnodeQueue.push(vnode));
            }
            function setScope(vnode) {
                var i;
                if (isDef(i = vnode.fnScopeId)) nodeOps.setStyleScope(vnode.elm, i); else for (var ancestor = vnode; ancestor; ) isDef(i = ancestor.context) && isDef(i = i.$options._scopeId) && nodeOps.setStyleScope(vnode.elm, i), 
                ancestor = ancestor.parent;
                isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId) && nodeOps.setStyleScope(vnode.elm, i);
            }
            function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
                for (;startIdx <= endIdx; ++startIdx) createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, !1, vnodes, startIdx);
            }
            function invokeDestroyHook(vnode) {
                var i, j, data = vnode.data;
                if (isDef(data)) for (isDef(i = data.hook) && isDef(i = i.destroy) && i(vnode), 
                i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
                if (isDef(i = vnode.children)) for (j = 0; j < vnode.children.length; ++j) invokeDestroyHook(vnode.children[j]);
            }
            function removeVnodes(vnodes, startIdx, endIdx) {
                for (;startIdx <= endIdx; ++startIdx) {
                    var ch = vnodes[startIdx];
                    isDef(ch) && (isDef(ch.tag) ? (removeAndInvokeRemoveHook(ch), invokeDestroyHook(ch)) : removeNode(ch.elm));
                }
            }
            function removeAndInvokeRemoveHook(vnode, rm) {
                if (isDef(rm) || isDef(vnode.data)) {
                    var i, listeners = cbs.remove.length + 1;
                    for (isDef(rm) ? rm.listeners += listeners : rm = function(childElm, listeners) {
                        function remove$$1() {
                            0 == --remove$$1.listeners && removeNode(childElm);
                        }
                        return remove$$1.listeners = listeners, remove$$1;
                    }(vnode.elm, listeners), isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data) && removeAndInvokeRemoveHook(i, rm), 
                    i = 0; i < cbs.remove.length; ++i) cbs.remove[i](vnode, rm);
                    isDef(i = vnode.data.hook) && isDef(i = i.remove) ? i(vnode, rm) : rm();
                } else removeNode(vnode.elm);
            }
            function findIdxInOld(node, oldCh, start, end) {
                for (var i = start; i < end; i++) {
                    var c = oldCh[i];
                    if (isDef(c) && sameVnode(node, c)) return i;
                }
            }
            function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
                if (oldVnode !== vnode) {
                    isDef(vnode.elm) && isDef(ownerArray) && (vnode = ownerArray[index] = cloneVNode(vnode));
                    var elm = vnode.elm = oldVnode.elm;
                    if (isTrue(oldVnode.isAsyncPlaceholder)) isDef(vnode.asyncFactory.resolved) ? hydrate(oldVnode.elm, vnode, insertedVnodeQueue) : vnode.isAsyncPlaceholder = !0; else if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) vnode.componentInstance = oldVnode.componentInstance; else {
                        var i, data = vnode.data;
                        isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch) && i(oldVnode, vnode);
                        var oldCh = oldVnode.children, ch = vnode.children;
                        if (isDef(data) && isPatchable(vnode)) {
                            for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
                            isDef(i = data.hook) && isDef(i = i.update) && i(oldVnode, vnode);
                        }
                        isUndef(vnode.text) ? isDef(oldCh) && isDef(ch) ? oldCh !== ch && function(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                            var oldKeyToIdx, idxInOld, vnodeToMove, oldStartIdx = 0, newStartIdx = 0, oldEndIdx = oldCh.length - 1, oldStartVnode = oldCh[0], oldEndVnode = oldCh[oldEndIdx], newEndIdx = newCh.length - 1, newStartVnode = newCh[0], newEndVnode = newCh[newEndIdx], canMove = !removeOnly;
                            for (0; oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx; ) isUndef(oldStartVnode) ? oldStartVnode = oldCh[++oldStartIdx] : isUndef(oldEndVnode) ? oldEndVnode = oldCh[--oldEndIdx] : sameVnode(oldStartVnode, newStartVnode) ? (patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx), 
                            oldStartVnode = oldCh[++oldStartIdx], newStartVnode = newCh[++newStartIdx]) : sameVnode(oldEndVnode, newEndVnode) ? (patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx), 
                            oldEndVnode = oldCh[--oldEndIdx], newEndVnode = newCh[--newEndIdx]) : sameVnode(oldStartVnode, newEndVnode) ? (patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx), 
                            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)), 
                            oldStartVnode = oldCh[++oldStartIdx], newEndVnode = newCh[--newEndIdx]) : sameVnode(oldEndVnode, newStartVnode) ? (patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx), 
                            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm), 
                            oldEndVnode = oldCh[--oldEndIdx], newStartVnode = newCh[++newStartIdx]) : (isUndef(oldKeyToIdx) && (oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)), 
                            isUndef(idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)) ? createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, !1, newCh, newStartIdx) : sameVnode(vnodeToMove = oldCh[idxInOld], newStartVnode) ? (patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx), 
                            oldCh[idxInOld] = void 0, canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)) : createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, !1, newCh, newStartIdx), 
                            newStartVnode = newCh[++newStartIdx]);
                            oldStartIdx > oldEndIdx ? addVnodes(parentElm, isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) : newStartIdx > newEndIdx && removeVnodes(oldCh, oldStartIdx, oldEndIdx);
                        }(elm, oldCh, ch, insertedVnodeQueue, removeOnly) : isDef(ch) ? (isDef(oldVnode.text) && nodeOps.setTextContent(elm, ""), 
                        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)) : isDef(oldCh) ? removeVnodes(oldCh, 0, oldCh.length - 1) : isDef(oldVnode.text) && nodeOps.setTextContent(elm, "") : oldVnode.text !== vnode.text && nodeOps.setTextContent(elm, vnode.text), 
                        isDef(data) && isDef(i = data.hook) && isDef(i = i.postpatch) && i(oldVnode, vnode);
                    }
                }
            }
            function invokeInsertHook(vnode, queue, initial) {
                if (isTrue(initial) && isDef(vnode.parent)) vnode.parent.data.pendingInsert = queue; else for (var i = 0; i < queue.length; ++i) queue[i].data.hook.insert(queue[i]);
            }
            var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
            function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
                var i, tag = vnode.tag, data = vnode.data, children = vnode.children;
                if (inVPre = inVPre || data && data.pre, vnode.elm = elm, isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) return vnode.isAsyncPlaceholder = !0, 
                !0;
                if (isDef(data) && (isDef(i = data.hook) && isDef(i = i.init) && i(vnode, !0), isDef(i = vnode.componentInstance))) return initComponent(vnode, insertedVnodeQueue), 
                !0;
                if (isDef(tag)) {
                    if (isDef(children)) if (elm.hasChildNodes()) if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                        if (i !== elm.innerHTML) return !1;
                    } else {
                        for (var childrenMatch = !0, childNode = elm.firstChild, i$1 = 0; i$1 < children.length; i$1++) {
                            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                                childrenMatch = !1;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        if (!childrenMatch || childNode) return !1;
                    } else createChildren(vnode, children, insertedVnodeQueue);
                    if (isDef(data)) {
                        var fullInvoke = !1;
                        for (var key in data) if (!isRenderedModule(key)) {
                            fullInvoke = !0, invokeCreateHooks(vnode, insertedVnodeQueue);
                            break;
                        }
                        !fullInvoke && data.class && traverse(data.class);
                    }
                } else elm.data !== vnode.text && (elm.data = vnode.text);
                return !0;
            }
            return function(oldVnode, vnode, hydrating, removeOnly) {
                if (!isUndef(vnode)) {
                    var elm, isInitialPatch = !1, insertedVnodeQueue = [];
                    if (isUndef(oldVnode)) isInitialPatch = !0, createElm(vnode, insertedVnodeQueue); else {
                        var isRealElement = isDef(oldVnode.nodeType);
                        if (!isRealElement && sameVnode(oldVnode, vnode)) patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); else {
                            if (isRealElement) {
                                if (1 === oldVnode.nodeType && oldVnode.hasAttribute("data-server-rendered") && (oldVnode.removeAttribute("data-server-rendered"), 
                                hydrating = !0), isTrue(hydrating) && hydrate(oldVnode, vnode, insertedVnodeQueue)) return invokeInsertHook(vnode, insertedVnodeQueue, !0), 
                                oldVnode;
                                elm = oldVnode, oldVnode = new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], void 0, elm);
                            }
                            var oldElm = oldVnode.elm, parentElm = nodeOps.parentNode(oldElm);
                            if (createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)), 
                            isDef(vnode.parent)) for (var ancestor = vnode.parent, patchable = isPatchable(vnode); ancestor; ) {
                                for (var i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](ancestor);
                                if (ancestor.elm = vnode.elm, patchable) {
                                    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) cbs.create[i$1](emptyNode, ancestor);
                                    var insert = ancestor.data.hook.insert;
                                    if (insert.merged) for (var i$2 = 1; i$2 < insert.fns.length; i$2++) insert.fns[i$2]();
                                } else registerRef(ancestor);
                                ancestor = ancestor.parent;
                            }
                            isDef(parentElm) ? removeVnodes([ oldVnode ], 0, 0) : isDef(oldVnode.tag) && invokeDestroyHook(oldVnode);
                        }
                    }
                    return invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch), vnode.elm;
                }
                isDef(oldVnode) && invokeDestroyHook(oldVnode);
            };
        }({
            nodeOps: nodeOps,
            modules: [ attrs, klass, events, domProps, style, inBrowser ? {
                create: _enter,
                activate: _enter,
                remove: function(vnode, rm) {
                    !0 !== vnode.data.show ? leave(vnode, rm) : rm();
                }
            } : {} ].concat(baseModules)
        });
        isIE9 && document.addEventListener("selectionchange", (function() {
            var el = document.activeElement;
            el && el.vmodel && trigger(el, "input");
        }));
        var directive = {
            inserted: function(el, binding, vnode, oldVnode) {
                "select" === vnode.tag ? (oldVnode.elm && !oldVnode.elm._vOptions ? mergeVNodeHook(vnode, "postpatch", (function() {
                    directive.componentUpdated(el, binding, vnode);
                })) : setSelected(el, binding, vnode.context), el._vOptions = [].map.call(el.options, getValue)) : ("textarea" === vnode.tag || isTextInputType(el.type)) && (el._vModifiers = binding.modifiers, 
                binding.modifiers.lazy || (el.addEventListener("compositionstart", onCompositionStart), 
                el.addEventListener("compositionend", onCompositionEnd), el.addEventListener("change", onCompositionEnd), 
                isIE9 && (el.vmodel = !0)));
            },
            componentUpdated: function(el, binding, vnode) {
                if ("select" === vnode.tag) {
                    setSelected(el, binding, vnode.context);
                    var prevOptions = el._vOptions, curOptions = el._vOptions = [].map.call(el.options, getValue);
                    if (curOptions.some((function(o, i) {
                        return !looseEqual(o, prevOptions[i]);
                    }))) (el.multiple ? binding.value.some((function(v) {
                        return hasNoMatchingOption(v, curOptions);
                    })) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions)) && trigger(el, "change");
                }
            }
        };
        function setSelected(el, binding, vm) {
            actuallySetSelected(el, binding, vm), (isIE || isEdge) && setTimeout((function() {
                actuallySetSelected(el, binding, vm);
            }), 0);
        }
        function actuallySetSelected(el, binding, vm) {
            var value = binding.value, isMultiple = el.multiple;
            if (!isMultiple || Array.isArray(value)) {
                for (var selected, option, i = 0, l = el.options.length; i < l; i++) if (option = el.options[i], 
                isMultiple) selected = looseIndexOf(value, getValue(option)) > -1, option.selected !== selected && (option.selected = selected); else if (looseEqual(getValue(option), value)) return void (el.selectedIndex !== i && (el.selectedIndex = i));
                isMultiple || (el.selectedIndex = -1);
            }
        }
        function hasNoMatchingOption(value, options) {
            return options.every((function(o) {
                return !looseEqual(o, value);
            }));
        }
        function getValue(option) {
            return "_value" in option ? option._value : option.value;
        }
        function onCompositionStart(e) {
            e.target.composing = !0;
        }
        function onCompositionEnd(e) {
            e.target.composing && (e.target.composing = !1, trigger(e.target, "input"));
        }
        function trigger(el, type) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(type, !0, !0), el.dispatchEvent(e);
        }
        function locateNode(vnode) {
            return !vnode.componentInstance || vnode.data && vnode.data.transition ? vnode : locateNode(vnode.componentInstance._vnode);
        }
        var platformDirectives = {
            model: directive,
            show: {
                bind: function(el, ref, vnode) {
                    var value = ref.value, transition$$1 = (vnode = locateNode(vnode)).data && vnode.data.transition, originalDisplay = el.__vOriginalDisplay = "none" === el.style.display ? "" : el.style.display;
                    value && transition$$1 ? (vnode.data.show = !0, enter(vnode, (function() {
                        el.style.display = originalDisplay;
                    }))) : el.style.display = value ? originalDisplay : "none";
                },
                update: function(el, ref, vnode) {
                    var value = ref.value;
                    !value != !ref.oldValue && ((vnode = locateNode(vnode)).data && vnode.data.transition ? (vnode.data.show = !0, 
                    value ? enter(vnode, (function() {
                        el.style.display = el.__vOriginalDisplay;
                    })) : leave(vnode, (function() {
                        el.style.display = "none";
                    }))) : el.style.display = value ? el.__vOriginalDisplay : "none");
                },
                unbind: function(el, binding, vnode, oldVnode, isDestroy) {
                    isDestroy || (el.style.display = el.__vOriginalDisplay);
                }
            }
        }, transitionProps = {
            name: String,
            appear: Boolean,
            css: Boolean,
            mode: String,
            type: String,
            enterClass: String,
            leaveClass: String,
            enterToClass: String,
            leaveToClass: String,
            enterActiveClass: String,
            leaveActiveClass: String,
            appearClass: String,
            appearActiveClass: String,
            appearToClass: String,
            duration: [ Number, String, Object ]
        };
        function getRealChild(vnode) {
            var compOptions = vnode && vnode.componentOptions;
            return compOptions && compOptions.Ctor.options.abstract ? getRealChild(getFirstComponentChild(compOptions.children)) : vnode;
        }
        function extractTransitionData(comp) {
            var data = {}, options = comp.$options;
            for (var key in options.propsData) data[key] = comp[key];
            var listeners = options._parentListeners;
            for (var key$1 in listeners) data[camelize(key$1)] = listeners[key$1];
            return data;
        }
        function placeholder(h, rawChild) {
            if (/\d-keep-alive$/.test(rawChild.tag)) return h("keep-alive", {
                props: rawChild.componentOptions.propsData
            });
        }
        var isNotTextNode = function(c) {
            return c.tag || isAsyncPlaceholder(c);
        }, isVShowDirective = function(d) {
            return "show" === d.name;
        }, Transition = {
            name: "transition",
            props: transitionProps,
            abstract: !0,
            render: function(h) {
                var this$1 = this, children = this.$slots.default;
                if (children && (children = children.filter(isNotTextNode)).length) {
                    0;
                    var mode = this.mode;
                    0;
                    var rawChild = children[0];
                    if (function(vnode) {
                        for (;vnode = vnode.parent; ) if (vnode.data.transition) return !0;
                    }(this.$vnode)) return rawChild;
                    var child = getRealChild(rawChild);
                    if (!child) return rawChild;
                    if (this._leaving) return placeholder(h, rawChild);
                    var id = "__transition-" + this._uid + "-";
                    child.key = null == child.key ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? 0 === String(child.key).indexOf(id) ? child.key : id + child.key : child.key;
                    var data = (child.data || (child.data = {})).transition = extractTransitionData(this), oldRawChild = this._vnode, oldChild = getRealChild(oldRawChild);
                    if (child.data.directives && child.data.directives.some(isVShowDirective) && (child.data.show = !0), 
                    oldChild && oldChild.data && !function(child, oldChild) {
                        return oldChild.key === child.key && oldChild.tag === child.tag;
                    }(child, oldChild) && !isAsyncPlaceholder(oldChild) && (!oldChild.componentInstance || !oldChild.componentInstance._vnode.isComment)) {
                        var oldData = oldChild.data.transition = extend({}, data);
                        if ("out-in" === mode) return this._leaving = !0, mergeVNodeHook(oldData, "afterLeave", (function() {
                            this$1._leaving = !1, this$1.$forceUpdate();
                        })), placeholder(h, rawChild);
                        if ("in-out" === mode) {
                            if (isAsyncPlaceholder(child)) return oldRawChild;
                            var delayedLeave, performLeave = function() {
                                delayedLeave();
                            };
                            mergeVNodeHook(data, "afterEnter", performLeave), mergeVNodeHook(data, "enterCancelled", performLeave), 
                            mergeVNodeHook(oldData, "delayLeave", (function(leave) {
                                delayedLeave = leave;
                            }));
                        }
                    }
                    return rawChild;
                }
            }
        }, props = extend({
            tag: String,
            moveClass: String
        }, transitionProps);
        function callPendingCbs(c) {
            c.elm._moveCb && c.elm._moveCb(), c.elm._enterCb && c.elm._enterCb();
        }
        function recordPosition(c) {
            c.data.newPos = c.elm.getBoundingClientRect();
        }
        function applyTranslation(c) {
            var oldPos = c.data.pos, newPos = c.data.newPos, dx = oldPos.left - newPos.left, dy = oldPos.top - newPos.top;
            if (dx || dy) {
                c.data.moved = !0;
                var s = c.elm.style;
                s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)", s.transitionDuration = "0s";
            }
        }
        delete props.mode;
        var platformComponents = {
            Transition: Transition,
            TransitionGroup: {
                props: props,
                beforeMount: function() {
                    var this$1 = this, update = this._update;
                    this._update = function(vnode, hydrating) {
                        var restoreActiveInstance = setActiveInstance(this$1);
                        this$1.__patch__(this$1._vnode, this$1.kept, !1, !0), this$1._vnode = this$1.kept, 
                        restoreActiveInstance(), update.call(this$1, vnode, hydrating);
                    };
                },
                render: function(h) {
                    for (var tag = this.tag || this.$vnode.data.tag || "span", map = Object.create(null), prevChildren = this.prevChildren = this.children, rawChildren = this.$slots.default || [], children = this.children = [], transitionData = extractTransitionData(this), i = 0; i < rawChildren.length; i++) {
                        var c = rawChildren[i];
                        if (c.tag) if (null != c.key && 0 !== String(c.key).indexOf("__vlist")) children.push(c), 
                        map[c.key] = c, (c.data || (c.data = {})).transition = transitionData; else ;
                    }
                    if (prevChildren) {
                        for (var kept = [], removed = [], i$1 = 0; i$1 < prevChildren.length; i$1++) {
                            var c$1 = prevChildren[i$1];
                            c$1.data.transition = transitionData, c$1.data.pos = c$1.elm.getBoundingClientRect(), 
                            map[c$1.key] ? kept.push(c$1) : removed.push(c$1);
                        }
                        this.kept = h(tag, null, kept), this.removed = removed;
                    }
                    return h(tag, null, children);
                },
                updated: function() {
                    var children = this.prevChildren, moveClass = this.moveClass || (this.name || "v") + "-move";
                    children.length && this.hasMove(children[0].elm, moveClass) && (children.forEach(callPendingCbs), 
                    children.forEach(recordPosition), children.forEach(applyTranslation), this._reflow = document.body.offsetHeight, 
                    children.forEach((function(c) {
                        if (c.data.moved) {
                            var el = c.elm, s = el.style;
                            addTransitionClass(el, moveClass), s.transform = s.WebkitTransform = s.transitionDuration = "", 
                            el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                                e && e.target !== el || e && !/transform$/.test(e.propertyName) || (el.removeEventListener(transitionEndEvent, cb), 
                                el._moveCb = null, removeTransitionClass(el, moveClass));
                            });
                        }
                    })));
                },
                methods: {
                    hasMove: function(el, moveClass) {
                        if (!hasTransition) return !1;
                        if (this._hasMove) return this._hasMove;
                        var clone = el.cloneNode();
                        el._transitionClasses && el._transitionClasses.forEach((function(cls) {
                            removeClass(clone, cls);
                        })), addClass(clone, moveClass), clone.style.display = "none", this.$el.appendChild(clone);
                        var info = getTransitionInfo(clone);
                        return this.$el.removeChild(clone), this._hasMove = info.hasTransform;
                    }
                }
            }
        };
        Vue.config.mustUseProp = mustUseProp, Vue.config.isReservedTag = isReservedTag, 
        Vue.config.isReservedAttr = isReservedAttr, Vue.config.getTagNamespace = getTagNamespace, 
        Vue.config.isUnknownElement = function(tag) {
            if (!inBrowser) return !0;
            if (isReservedTag(tag)) return !1;
            if (tag = tag.toLowerCase(), null != unknownElementCache[tag]) return unknownElementCache[tag];
            var el = document.createElement(tag);
            return tag.indexOf("-") > -1 ? unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement : unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
        }, extend(Vue.options.directives, platformDirectives), extend(Vue.options.components, platformComponents), 
        Vue.prototype.__patch__ = inBrowser ? patch : noop, Vue.prototype.$mount = function(el, hydrating) {
            return function(vm, el, hydrating) {
                var updateComponent;
                return vm.$el = el, vm.$options.render || (vm.$options.render = createEmptyVNode), 
                callHook(vm, "beforeMount"), updateComponent = function() {
                    vm._update(vm._render(), hydrating);
                }, new Watcher(vm, updateComponent, noop, {
                    before: function() {
                        vm._isMounted && !vm._isDestroyed && callHook(vm, "beforeUpdate");
                    }
                }, !0), hydrating = !1, null == vm.$vnode && (vm._isMounted = !0, callHook(vm, "mounted")), 
                vm;
            }(this, el = el && inBrowser ? query(el) : void 0, hydrating);
        }, inBrowser && setTimeout((function() {
            config.devtools && devtools && devtools.emit("init", Vue);
        }), 0);
        var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g, regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g, buildRegex = cached((function(delimiters) {
            var open = delimiters[0].replace(regexEscapeRE, "\\$&"), close = delimiters[1].replace(regexEscapeRE, "\\$&");
            return new RegExp(open + "((?:.|\\n)+?)" + close, "g");
        }));
        var klass$1 = {
            staticKeys: [ "staticClass" ],
            transformNode: function(el, options) {
                options.warn;
                var staticClass = getAndRemoveAttr(el, "class");
                staticClass && (el.staticClass = JSON.stringify(staticClass));
                var classBinding = getBindingAttr(el, "class", !1);
                classBinding && (el.classBinding = classBinding);
            },
            genData: function(el) {
                var data = "";
                return el.staticClass && (data += "staticClass:" + el.staticClass + ","), el.classBinding && (data += "class:" + el.classBinding + ","), 
                data;
            }
        };
        var decoder, style$1 = {
            staticKeys: [ "staticStyle" ],
            transformNode: function(el, options) {
                options.warn;
                var staticStyle = getAndRemoveAttr(el, "style");
                staticStyle && (el.staticStyle = JSON.stringify(parseStyleText(staticStyle)));
                var styleBinding = getBindingAttr(el, "style", !1);
                styleBinding && (el.styleBinding = styleBinding);
            },
            genData: function(el) {
                var data = "";
                return el.staticStyle && (data += "staticStyle:" + el.staticStyle + ","), el.styleBinding && (data += "style:(" + el.styleBinding + "),"), 
                data;
            }
        }, he_decode = function(html) {
            return (decoder = decoder || document.createElement("div")).innerHTML = html, decoder.textContent;
        }, isUnaryTag = makeMap("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"), canBeLeftOpenTag = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"), isNonPhrasingTag = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"), attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*", qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")", startTagOpen = new RegExp("^<" + qnameCapture), startTagClose = /^\s*(\/?)>/, endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>"), doctype = /^<!DOCTYPE [^>]+>/i, comment = /^<!\--/, conditionalComment = /^<!\[/, isPlainTextElement = makeMap("script,style,textarea", !0), reCache = {}, decodingMap = {
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&amp;": "&",
            "&#10;": "\n",
            "&#9;": "\t",
            "&#39;": "'"
        }, encodedAttr = /&(?:lt|gt|quot|amp|#39);/g, encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g, isIgnoreNewlineTag = makeMap("pre,textarea", !0), shouldIgnoreFirstNewline = function(tag, html) {
            return tag && isIgnoreNewlineTag(tag) && "\n" === html[0];
        };
        function decodeAttr(value, shouldDecodeNewlines) {
            var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
            return value.replace(re, (function(match) {
                return decodingMap[match];
            }));
        }
        var warn$2, delimiters, transforms, preTransforms, postTransforms, platformIsPreTag, platformMustUseProp, platformGetTagNamespace, onRE = /^@|^v-on:/, dirRE = /^v-|^@|^:|^#/, forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, stripParensRE = /^\(|\)$/g, dynamicArgRE = /^\[.*\]$/, argRE = /:(.*)$/, bindRE = /^:|^\.|^v-bind:/, modifierRE = /\.[^.\]]+(?=[^\]]*$)/g, slotRE = /^v-slot(:|$)|^#/, lineBreakRE = /[\r\n]/, whitespaceRE$1 = /\s+/g, decodeHTMLCached = cached(he_decode);
        function createASTElement(tag, attrs, parent) {
            return {
                type: 1,
                tag: tag,
                attrsList: attrs,
                attrsMap: makeAttrsMap(attrs),
                rawAttrsMap: {},
                parent: parent,
                children: []
            };
        }
        function parse(template, options) {
            warn$2 = options.warn || baseWarn, platformIsPreTag = options.isPreTag || no, platformMustUseProp = options.mustUseProp || no, 
            platformGetTagNamespace = options.getTagNamespace || no;
            var isReservedTag = options.isReservedTag || no;
            (function(el) {
                return !!el.component || !isReservedTag(el.tag);
            }), transforms = pluckModuleFunction(options.modules, "transformNode"), preTransforms = pluckModuleFunction(options.modules, "preTransformNode"), 
            postTransforms = pluckModuleFunction(options.modules, "postTransformNode"), delimiters = options.delimiters;
            var root, currentParent, stack = [], preserveWhitespace = !1 !== options.preserveWhitespace, whitespaceOption = options.whitespace, inVPre = !1, inPre = !1;
            function closeElement(element) {
                if (trimEndingWhitespace(element), inVPre || element.processed || (element = processElement(element, options)), 
                stack.length || element === root || root.if && (element.elseif || element.else) && addIfCondition(root, {
                    exp: element.elseif,
                    block: element
                }), currentParent && !element.forbidden) if (element.elseif || element.else) el = element, 
                (prev = function(children) {
                    for (var i = children.length; i--; ) {
                        if (1 === children[i].type) return children[i];
                        children.pop();
                    }
                }(currentParent.children)) && prev.if && addIfCondition(prev, {
                    exp: el.elseif,
                    block: el
                }); else {
                    if (element.slotScope) {
                        var name = element.slotTarget || '"default"';
                        (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                    }
                    currentParent.children.push(element), element.parent = currentParent;
                }
                var el, prev;
                element.children = element.children.filter((function(c) {
                    return !c.slotScope;
                })), trimEndingWhitespace(element), element.pre && (inVPre = !1), platformIsPreTag(element.tag) && (inPre = !1);
                for (var i = 0; i < postTransforms.length; i++) postTransforms[i](element, options);
            }
            function trimEndingWhitespace(el) {
                if (!inPre) for (var lastNode; (lastNode = el.children[el.children.length - 1]) && 3 === lastNode.type && " " === lastNode.text; ) el.children.pop();
            }
            return function(html, options) {
                for (var last, lastTag, stack = [], expectHTML = options.expectHTML, isUnaryTag$$1 = options.isUnaryTag || no, canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no, index = 0; html; ) {
                    if (last = html, lastTag && isPlainTextElement(lastTag)) {
                        var endTagLength = 0, stackedTag = lastTag.toLowerCase(), reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\s\\S]*?)(</" + stackedTag + "[^>]*>)", "i")), rest$1 = html.replace(reStackedTag, (function(all, text, endTag) {
                            return endTagLength = endTag.length, isPlainTextElement(stackedTag) || "noscript" === stackedTag || (text = text.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), 
                            shouldIgnoreFirstNewline(stackedTag, text) && (text = text.slice(1)), options.chars && options.chars(text), 
                            "";
                        }));
                        index += html.length - rest$1.length, html = rest$1, parseEndTag(stackedTag, index - endTagLength, index);
                    } else {
                        var textEnd = html.indexOf("<");
                        if (0 === textEnd) {
                            if (comment.test(html)) {
                                var commentEnd = html.indexOf("--\x3e");
                                if (commentEnd >= 0) {
                                    options.shouldKeepComment && options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3), 
                                    advance(commentEnd + 3);
                                    continue;
                                }
                            }
                            if (conditionalComment.test(html)) {
                                var conditionalEnd = html.indexOf("]>");
                                if (conditionalEnd >= 0) {
                                    advance(conditionalEnd + 2);
                                    continue;
                                }
                            }
                            var doctypeMatch = html.match(doctype);
                            if (doctypeMatch) {
                                advance(doctypeMatch[0].length);
                                continue;
                            }
                            var endTagMatch = html.match(endTag);
                            if (endTagMatch) {
                                var curIndex = index;
                                advance(endTagMatch[0].length), parseEndTag(endTagMatch[1], curIndex, index);
                                continue;
                            }
                            var startTagMatch = parseStartTag();
                            if (startTagMatch) {
                                handleStartTag(startTagMatch), shouldIgnoreFirstNewline(startTagMatch.tagName, html) && advance(1);
                                continue;
                            }
                        }
                        var text = void 0, rest = void 0, next = void 0;
                        if (textEnd >= 0) {
                            for (rest = html.slice(textEnd); !(endTag.test(rest) || startTagOpen.test(rest) || comment.test(rest) || conditionalComment.test(rest) || (next = rest.indexOf("<", 1)) < 0); ) textEnd += next, 
                            rest = html.slice(textEnd);
                            text = html.substring(0, textEnd);
                        }
                        textEnd < 0 && (text = html), text && advance(text.length), options.chars && text && options.chars(text, index - text.length, index);
                    }
                    if (html === last) {
                        options.chars && options.chars(html);
                        break;
                    }
                }
                function advance(n) {
                    index += n, html = html.substring(n);
                }
                function parseStartTag() {
                    var start = html.match(startTagOpen);
                    if (start) {
                        var end, attr, match = {
                            tagName: start[1],
                            attrs: [],
                            start: index
                        };
                        for (advance(start[0].length); !(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute)); ) attr.start = index, 
                        advance(attr[0].length), attr.end = index, match.attrs.push(attr);
                        if (end) return match.unarySlash = end[1], advance(end[0].length), match.end = index, 
                        match;
                    }
                }
                function handleStartTag(match) {
                    var tagName = match.tagName, unarySlash = match.unarySlash;
                    expectHTML && ("p" === lastTag && isNonPhrasingTag(tagName) && parseEndTag(lastTag), 
                    canBeLeftOpenTag$$1(tagName) && lastTag === tagName && parseEndTag(tagName));
                    for (var unary = isUnaryTag$$1(tagName) || !!unarySlash, l = match.attrs.length, attrs = new Array(l), i = 0; i < l; i++) {
                        var args = match.attrs[i], value = args[3] || args[4] || args[5] || "", shouldDecodeNewlines = "a" === tagName && "href" === args[1] ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
                        attrs[i] = {
                            name: args[1],
                            value: decodeAttr(value, shouldDecodeNewlines)
                        };
                    }
                    unary || (stack.push({
                        tag: tagName,
                        lowerCasedTag: tagName.toLowerCase(),
                        attrs: attrs,
                        start: match.start,
                        end: match.end
                    }), lastTag = tagName), options.start && options.start(tagName, attrs, unary, match.start, match.end);
                }
                function parseEndTag(tagName, start, end) {
                    var pos, lowerCasedTagName;
                    if (null == start && (start = index), null == end && (end = index), tagName) for (lowerCasedTagName = tagName.toLowerCase(), 
                    pos = stack.length - 1; pos >= 0 && stack[pos].lowerCasedTag !== lowerCasedTagName; pos--) ; else pos = 0;
                    if (pos >= 0) {
                        for (var i = stack.length - 1; i >= pos; i--) options.end && options.end(stack[i].tag, start, end);
                        stack.length = pos, lastTag = pos && stack[pos - 1].tag;
                    } else "br" === lowerCasedTagName ? options.start && options.start(tagName, [], !0, start, end) : "p" === lowerCasedTagName && (options.start && options.start(tagName, [], !1, start, end), 
                    options.end && options.end(tagName, start, end));
                }
                parseEndTag();
            }(template, {
                warn: warn$2,
                expectHTML: options.expectHTML,
                isUnaryTag: options.isUnaryTag,
                canBeLeftOpenTag: options.canBeLeftOpenTag,
                shouldDecodeNewlines: options.shouldDecodeNewlines,
                shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
                shouldKeepComment: options.comments,
                outputSourceRange: options.outputSourceRange,
                start: function(tag, attrs, unary, start$1, end) {
                    var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
                    isIE && "svg" === ns && (attrs = function(attrs) {
                        for (var res = [], i = 0; i < attrs.length; i++) {
                            var attr = attrs[i];
                            ieNSBug.test(attr.name) || (attr.name = attr.name.replace(ieNSPrefix, ""), res.push(attr));
                        }
                        return res;
                    }(attrs));
                    var el, element = createASTElement(tag, attrs, currentParent);
                    ns && (element.ns = ns), "style" !== (el = element).tag && ("script" !== el.tag || el.attrsMap.type && "text/javascript" !== el.attrsMap.type) || isServerRendering() || (element.forbidden = !0);
                    for (var i = 0; i < preTransforms.length; i++) element = preTransforms[i](element, options) || element;
                    inVPre || (!function(el) {
                        null != getAndRemoveAttr(el, "v-pre") && (el.pre = !0);
                    }(element), element.pre && (inVPre = !0)), platformIsPreTag(element.tag) && (inPre = !0), 
                    inVPre ? function(el) {
                        var list = el.attrsList, len = list.length;
                        if (len) for (var attrs = el.attrs = new Array(len), i = 0; i < len; i++) attrs[i] = {
                            name: list[i].name,
                            value: JSON.stringify(list[i].value)
                        }, null != list[i].start && (attrs[i].start = list[i].start, attrs[i].end = list[i].end); else el.pre || (el.plain = !0);
                    }(element) : element.processed || (processFor(element), function(el) {
                        var exp = getAndRemoveAttr(el, "v-if");
                        if (exp) el.if = exp, addIfCondition(el, {
                            exp: exp,
                            block: el
                        }); else {
                            null != getAndRemoveAttr(el, "v-else") && (el.else = !0);
                            var elseif = getAndRemoveAttr(el, "v-else-if");
                            elseif && (el.elseif = elseif);
                        }
                    }(element), function(el) {
                        null != getAndRemoveAttr(el, "v-once") && (el.once = !0);
                    }(element)), root || (root = element), unary ? closeElement(element) : (currentParent = element, 
                    stack.push(element));
                },
                end: function(tag, start, end$1) {
                    var element = stack[stack.length - 1];
                    stack.length -= 1, currentParent = stack[stack.length - 1], closeElement(element);
                },
                chars: function(text, start, end) {
                    if (currentParent && (!isIE || "textarea" !== currentParent.tag || currentParent.attrsMap.placeholder !== text)) {
                        var el, res, child, children = currentParent.children;
                        if (text = inPre || text.trim() ? "script" === (el = currentParent).tag || "style" === el.tag ? text : decodeHTMLCached(text) : children.length ? whitespaceOption ? "condense" === whitespaceOption && lineBreakRE.test(text) ? "" : " " : preserveWhitespace ? " " : "" : "") inPre || "condense" !== whitespaceOption || (text = text.replace(whitespaceRE$1, " ")), 
                        !inVPre && " " !== text && (res = function(text, delimiters) {
                            var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
                            if (tagRE.test(text)) {
                                for (var match, index, tokenValue, tokens = [], rawTokens = [], lastIndex = tagRE.lastIndex = 0; match = tagRE.exec(text); ) {
                                    (index = match.index) > lastIndex && (rawTokens.push(tokenValue = text.slice(lastIndex, index)), 
                                    tokens.push(JSON.stringify(tokenValue)));
                                    var exp = parseFilters(match[1].trim());
                                    tokens.push("_s(" + exp + ")"), rawTokens.push({
                                        "@binding": exp
                                    }), lastIndex = index + match[0].length;
                                }
                                return lastIndex < text.length && (rawTokens.push(tokenValue = text.slice(lastIndex)), 
                                tokens.push(JSON.stringify(tokenValue))), {
                                    expression: tokens.join("+"),
                                    tokens: rawTokens
                                };
                            }
                        }(text, delimiters)) ? child = {
                            type: 2,
                            expression: res.expression,
                            tokens: res.tokens,
                            text: text
                        } : " " === text && children.length && " " === children[children.length - 1].text || (child = {
                            type: 3,
                            text: text
                        }), child && children.push(child);
                    }
                },
                comment: function(text, start, end) {
                    if (currentParent) {
                        var child = {
                            type: 3,
                            text: text,
                            isComment: !0
                        };
                        0, currentParent.children.push(child);
                    }
                }
            }), root;
        }
        function processElement(element, options) {
            var el;
            !function(el) {
                var exp = getBindingAttr(el, "key");
                if (exp) {
                    el.key = exp;
                }
            }(element), element.plain = !element.key && !element.scopedSlots && !element.attrsList.length, 
            function(el) {
                var ref = getBindingAttr(el, "ref");
                ref && (el.ref = ref, el.refInFor = function(el) {
                    var parent = el;
                    for (;parent; ) {
                        if (void 0 !== parent.for) return !0;
                        parent = parent.parent;
                    }
                    return !1;
                }(el));
            }(element), function(el) {
                var slotScope;
                "template" === el.tag ? (slotScope = getAndRemoveAttr(el, "scope"), el.slotScope = slotScope || getAndRemoveAttr(el, "slot-scope")) : (slotScope = getAndRemoveAttr(el, "slot-scope")) && (el.slotScope = slotScope);
                var slotTarget = getBindingAttr(el, "slot");
                slotTarget && (el.slotTarget = '""' === slotTarget ? '"default"' : slotTarget, el.slotTargetDynamic = !(!el.attrsMap[":slot"] && !el.attrsMap["v-bind:slot"]), 
                "template" === el.tag || el.slotScope || addAttr(el, "slot", slotTarget, function(el, name) {
                    return el.rawAttrsMap[":" + name] || el.rawAttrsMap["v-bind:" + name] || el.rawAttrsMap[name];
                }(el, "slot")));
                if ("template" === el.tag) {
                    var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding) {
                        0;
                        var ref = getSlotName(slotBinding), name = ref.name, dynamic = ref.dynamic;
                        el.slotTarget = name, el.slotTargetDynamic = dynamic, el.slotScope = slotBinding.value || "_empty_";
                    }
                } else {
                    var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding$1) {
                        0;
                        var slots = el.scopedSlots || (el.scopedSlots = {}), ref$1 = getSlotName(slotBinding$1), name$1 = ref$1.name, dynamic$1 = ref$1.dynamic, slotContainer = slots[name$1] = createASTElement("template", [], el);
                        slotContainer.slotTarget = name$1, slotContainer.slotTargetDynamic = dynamic$1, 
                        slotContainer.children = el.children.filter((function(c) {
                            if (!c.slotScope) return c.parent = slotContainer, !0;
                        })), slotContainer.slotScope = slotBinding$1.value || "_empty_", el.children = [], 
                        el.plain = !1;
                    }
                }
            }(element), "slot" === (el = element).tag && (el.slotName = getBindingAttr(el, "name")), 
            function(el) {
                var binding;
                (binding = getBindingAttr(el, "is")) && (el.component = binding);
                null != getAndRemoveAttr(el, "inline-template") && (el.inlineTemplate = !0);
            }(element);
            for (var i = 0; i < transforms.length; i++) element = transforms[i](element, options) || element;
            return function(el) {
                var i, l, name, rawName, value, modifiers, syncGen, isDynamic, list = el.attrsList;
                for (i = 0, l = list.length; i < l; i++) {
                    if (name = rawName = list[i].name, value = list[i].value, dirRE.test(name)) if (el.hasBindings = !0, 
                    (modifiers = parseModifiers(name.replace(dirRE, ""))) && (name = name.replace(modifierRE, "")), 
                    bindRE.test(name)) name = name.replace(bindRE, ""), value = parseFilters(value), 
                    (isDynamic = dynamicArgRE.test(name)) && (name = name.slice(1, -1)), modifiers && (modifiers.prop && !isDynamic && "innerHtml" === (name = camelize(name)) && (name = "innerHTML"), 
                    modifiers.camel && !isDynamic && (name = camelize(name)), modifiers.sync && (syncGen = genAssignmentCode(value, "$event"), 
                    isDynamic ? addHandler(el, '"update:"+(' + name + ")", syncGen, null, !1, 0, list[i], !0) : (addHandler(el, "update:" + camelize(name), syncGen, null, !1, 0, list[i]), 
                    hyphenate(name) !== camelize(name) && addHandler(el, "update:" + hyphenate(name), syncGen, null, !1, 0, list[i])))), 
                    modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name) ? addProp(el, name, value, list[i], isDynamic) : addAttr(el, name, value, list[i], isDynamic); else if (onRE.test(name)) name = name.replace(onRE, ""), 
                    (isDynamic = dynamicArgRE.test(name)) && (name = name.slice(1, -1)), addHandler(el, name, value, modifiers, !1, 0, list[i], isDynamic); else {
                        var argMatch = (name = name.replace(dirRE, "")).match(argRE), arg = argMatch && argMatch[1];
                        isDynamic = !1, arg && (name = name.slice(0, -(arg.length + 1)), dynamicArgRE.test(arg) && (arg = arg.slice(1, -1), 
                        isDynamic = !0)), addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                    } else addAttr(el, name, JSON.stringify(value), list[i]), !el.component && "muted" === name && platformMustUseProp(el.tag, el.attrsMap.type, name) && addProp(el, name, "true", list[i]);
                }
            }(element), element;
        }
        function processFor(el) {
            var exp;
            if (exp = getAndRemoveAttr(el, "v-for")) {
                var res = function(exp) {
                    var inMatch = exp.match(forAliasRE);
                    if (!inMatch) return;
                    var res = {};
                    res.for = inMatch[2].trim();
                    var alias = inMatch[1].trim().replace(stripParensRE, ""), iteratorMatch = alias.match(forIteratorRE);
                    iteratorMatch ? (res.alias = alias.replace(forIteratorRE, "").trim(), res.iterator1 = iteratorMatch[1].trim(), 
                    iteratorMatch[2] && (res.iterator2 = iteratorMatch[2].trim())) : res.alias = alias;
                    return res;
                }(exp);
                res && extend(el, res);
            }
        }
        function addIfCondition(el, condition) {
            el.ifConditions || (el.ifConditions = []), el.ifConditions.push(condition);
        }
        function getSlotName(binding) {
            var name = binding.name.replace(slotRE, "");
            return name || "#" !== binding.name[0] && (name = "default"), dynamicArgRE.test(name) ? {
                name: name.slice(1, -1),
                dynamic: !0
            } : {
                name: '"' + name + '"',
                dynamic: !1
            };
        }
        function parseModifiers(name) {
            var match = name.match(modifierRE);
            if (match) {
                var ret = {};
                return match.forEach((function(m) {
                    ret[m.slice(1)] = !0;
                })), ret;
            }
        }
        function makeAttrsMap(attrs) {
            for (var map = {}, i = 0, l = attrs.length; i < l; i++) map[attrs[i].name] = attrs[i].value;
            return map;
        }
        var ieNSBug = /^xmlns:NS\d+/, ieNSPrefix = /^NS\d+:/;
        function cloneASTElement(el) {
            return createASTElement(el.tag, el.attrsList.slice(), el.parent);
        }
        var modules$1 = [ klass$1, style$1, {
            preTransformNode: function(el, options) {
                if ("input" === el.tag) {
                    var typeBinding, map = el.attrsMap;
                    if (!map["v-model"]) return;
                    if ((map[":type"] || map["v-bind:type"]) && (typeBinding = getBindingAttr(el, "type")), 
                    map.type || typeBinding || !map["v-bind"] || (typeBinding = "(" + map["v-bind"] + ").type"), 
                    typeBinding) {
                        var ifCondition = getAndRemoveAttr(el, "v-if", !0), ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "", hasElse = null != getAndRemoveAttr(el, "v-else", !0), elseIfCondition = getAndRemoveAttr(el, "v-else-if", !0), branch0 = cloneASTElement(el);
                        processFor(branch0), addRawAttr(branch0, "type", "checkbox"), processElement(branch0, options), 
                        branch0.processed = !0, branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra, 
                        addIfCondition(branch0, {
                            exp: branch0.if,
                            block: branch0
                        });
                        var branch1 = cloneASTElement(el);
                        getAndRemoveAttr(branch1, "v-for", !0), addRawAttr(branch1, "type", "radio"), processElement(branch1, options), 
                        addIfCondition(branch0, {
                            exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
                            block: branch1
                        });
                        var branch2 = cloneASTElement(el);
                        return getAndRemoveAttr(branch2, "v-for", !0), addRawAttr(branch2, ":type", typeBinding), 
                        processElement(branch2, options), addIfCondition(branch0, {
                            exp: ifCondition,
                            block: branch2
                        }), hasElse ? branch0.else = !0 : elseIfCondition && (branch0.elseif = elseIfCondition), 
                        branch0;
                    }
                }
            }
        } ];
        var isStaticKey, isPlatformReservedTag, baseOptions = {
            expectHTML: !0,
            modules: modules$1,
            directives: {
                model: function(el, dir, _warn) {
                    _warn;
                    var value = dir.value, modifiers = dir.modifiers, tag = el.tag, type = el.attrsMap.type;
                    if (el.component) return genComponentModel(el, value, modifiers), !1;
                    if ("select" === tag) !function(el, value, modifiers) {
                        var code = 'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' + (modifiers && modifiers.number ? "_n(val)" : "val") + "});";
                        code = code + " " + genAssignmentCode(value, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"), 
                        addHandler(el, "change", code, null, !0);
                    }(el, value, modifiers); else if ("input" === tag && "checkbox" === type) !function(el, value, modifiers) {
                        var number = modifiers && modifiers.number, valueBinding = getBindingAttr(el, "value") || "null", trueValueBinding = getBindingAttr(el, "true-value") || "true", falseValueBinding = getBindingAttr(el, "false-value") || "false";
                        addProp(el, "checked", "Array.isArray(" + value + ")?_i(" + value + "," + valueBinding + ")>-1" + ("true" === trueValueBinding ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")")), 
                        addHandler(el, "change", "var $$a=" + value + ",$$el=$event.target,$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");if(Array.isArray($$a)){var $$v=" + (number ? "_n(" + valueBinding + ")" : valueBinding) + ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + genAssignmentCode(value, "$$a.concat([$$v])") + ")}else{$$i>-1&&(" + genAssignmentCode(value, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") + ")}}else{" + genAssignmentCode(value, "$$c") + "}", null, !0);
                    }(el, value, modifiers); else if ("input" === tag && "radio" === type) !function(el, value, modifiers) {
                        var number = modifiers && modifiers.number, valueBinding = getBindingAttr(el, "value") || "null";
                        addProp(el, "checked", "_q(" + value + "," + (valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding) + ")"), 
                        addHandler(el, "change", genAssignmentCode(value, valueBinding), null, !0);
                    }(el, value, modifiers); else if ("input" === tag || "textarea" === tag) !function(el, value, modifiers) {
                        var type = el.attrsMap.type;
                        0;
                        var ref = modifiers || {}, lazy = ref.lazy, number = ref.number, trim = ref.trim, needCompositionGuard = !lazy && "range" !== type, event = lazy ? "change" : "range" === type ? "__r" : "input", valueExpression = "$event.target.value";
                        trim && (valueExpression = "$event.target.value.trim()");
                        number && (valueExpression = "_n(" + valueExpression + ")");
                        var code = genAssignmentCode(value, valueExpression);
                        needCompositionGuard && (code = "if($event.target.composing)return;" + code);
                        addProp(el, "value", "(" + value + ")"), addHandler(el, event, code, null, !0), 
                        (trim || number) && addHandler(el, "blur", "$forceUpdate()");
                    }(el, value, modifiers); else {
                        if (!config.isReservedTag(tag)) return genComponentModel(el, value, modifiers), 
                        !1;
                    }
                    return !0;
                },
                text: function(el, dir) {
                    dir.value && addProp(el, "textContent", "_s(" + dir.value + ")", dir);
                },
                html: function(el, dir) {
                    dir.value && addProp(el, "innerHTML", "_s(" + dir.value + ")", dir);
                }
            },
            isPreTag: function(tag) {
                return "pre" === tag;
            },
            isUnaryTag: isUnaryTag,
            mustUseProp: mustUseProp,
            canBeLeftOpenTag: canBeLeftOpenTag,
            isReservedTag: isReservedTag,
            getTagNamespace: getTagNamespace,
            staticKeys: function(modules) {
                return modules.reduce((function(keys, m) {
                    return keys.concat(m.staticKeys || []);
                }), []).join(",");
            }(modules$1)
        }, genStaticKeysCached = cached((function(keys) {
            return makeMap("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (keys ? "," + keys : ""));
        }));
        function optimize(root, options) {
            root && (isStaticKey = genStaticKeysCached(options.staticKeys || ""), isPlatformReservedTag = options.isReservedTag || no, 
            function markStatic$1(node) {
                if (node.static = function(node) {
                    if (2 === node.type) return !1;
                    if (3 === node.type) return !0;
                    return !(!node.pre && (node.hasBindings || node.if || node.for || isBuiltInTag(node.tag) || !isPlatformReservedTag(node.tag) || function(node) {
                        for (;node.parent; ) {
                            if ("template" !== (node = node.parent).tag) return !1;
                            if (node.for) return !0;
                        }
                        return !1;
                    }(node) || !Object.keys(node).every(isStaticKey)));
                }(node), 1 === node.type) {
                    if (!isPlatformReservedTag(node.tag) && "slot" !== node.tag && null == node.attrsMap["inline-template"]) return;
                    for (var i = 0, l = node.children.length; i < l; i++) {
                        var child = node.children[i];
                        markStatic$1(child), child.static || (node.static = !1);
                    }
                    if (node.ifConditions) for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                        var block = node.ifConditions[i$1].block;
                        markStatic$1(block), block.static || (node.static = !1);
                    }
                }
            }(root), function markStaticRoots(node, isInFor) {
                if (1 === node.type) {
                    if ((node.static || node.once) && (node.staticInFor = isInFor), node.static && node.children.length && (1 !== node.children.length || 3 !== node.children[0].type)) return void (node.staticRoot = !0);
                    if (node.staticRoot = !1, node.children) for (var i = 0, l = node.children.length; i < l; i++) markStaticRoots(node.children[i], isInFor || !!node.for);
                    if (node.ifConditions) for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) markStaticRoots(node.ifConditions[i$1].block, isInFor);
                }
            }(root, !1));
        }
        var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/, fnInvokeRE = /\([^)]*?\);*$/, simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/, keyCodes = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            up: 38,
            left: 37,
            right: 39,
            down: 40,
            delete: [ 8, 46 ]
        }, keyNames = {
            esc: [ "Esc", "Escape" ],
            tab: "Tab",
            enter: "Enter",
            space: [ " ", "Spacebar" ],
            up: [ "Up", "ArrowUp" ],
            left: [ "Left", "ArrowLeft" ],
            right: [ "Right", "ArrowRight" ],
            down: [ "Down", "ArrowDown" ],
            delete: [ "Backspace", "Delete", "Del" ]
        }, genGuard = function(condition) {
            return "if(" + condition + ")return null;";
        }, modifierCode = {
            stop: "$event.stopPropagation();",
            prevent: "$event.preventDefault();",
            self: genGuard("$event.target !== $event.currentTarget"),
            ctrl: genGuard("!$event.ctrlKey"),
            shift: genGuard("!$event.shiftKey"),
            alt: genGuard("!$event.altKey"),
            meta: genGuard("!$event.metaKey"),
            left: genGuard("'button' in $event && $event.button !== 0"),
            middle: genGuard("'button' in $event && $event.button !== 1"),
            right: genGuard("'button' in $event && $event.button !== 2")
        };
        function genHandlers(events, isNative) {
            var prefix = isNative ? "nativeOn:" : "on:", staticHandlers = "", dynamicHandlers = "";
            for (var name in events) {
                var handlerCode = genHandler(events[name]);
                events[name] && events[name].dynamic ? dynamicHandlers += name + "," + handlerCode + "," : staticHandlers += '"' + name + '":' + handlerCode + ",";
            }
            return staticHandlers = "{" + staticHandlers.slice(0, -1) + "}", dynamicHandlers ? prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])" : prefix + staticHandlers;
        }
        function genHandler(handler) {
            if (!handler) return "function(){}";
            if (Array.isArray(handler)) return "[" + handler.map((function(handler) {
                return genHandler(handler);
            })).join(",") + "]";
            var isMethodPath = simplePathRE.test(handler.value), isFunctionExpression = fnExpRE.test(handler.value), isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ""));
            if (handler.modifiers) {
                var code = "", genModifierCode = "", keys = [];
                for (var key in handler.modifiers) if (modifierCode[key]) genModifierCode += modifierCode[key], 
                keyCodes[key] && keys.push(key); else if ("exact" === key) {
                    var modifiers = handler.modifiers;
                    genModifierCode += genGuard([ "ctrl", "shift", "alt", "meta" ].filter((function(keyModifier) {
                        return !modifiers[keyModifier];
                    })).map((function(keyModifier) {
                        return "$event." + keyModifier + "Key";
                    })).join("||"));
                } else keys.push(key);
                return keys.length && (code += function(keys) {
                    return "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join("&&") + ")return null;";
                }(keys)), genModifierCode && (code += genModifierCode), "function($event){" + code + (isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value) + "}";
            }
            return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}";
        }
        function genFilterCode(key) {
            var keyVal = parseInt(key, 10);
            if (keyVal) return "$event.keyCode!==" + keyVal;
            var keyCode = keyCodes[key], keyName = keyNames[key];
            return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + ",$event.key," + JSON.stringify(keyName) + ")";
        }
        var baseDirectives = {
            on: function(el, dir) {
                el.wrapListeners = function(code) {
                    return "_g(" + code + "," + dir.value + ")";
                };
            },
            bind: function(el, dir) {
                el.wrapData = function(code) {
                    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? "true" : "false") + (dir.modifiers && dir.modifiers.sync ? ",true" : "") + ")";
                };
            },
            cloak: noop
        }, CodegenState = function(options) {
            this.options = options, this.warn = options.warn || baseWarn, this.transforms = pluckModuleFunction(options.modules, "transformCode"), 
            this.dataGenFns = pluckModuleFunction(options.modules, "genData"), this.directives = extend(extend({}, baseDirectives), options.directives);
            var isReservedTag = options.isReservedTag || no;
            this.maybeComponent = function(el) {
                return !!el.component || !isReservedTag(el.tag);
            }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1;
        };
        function generate(ast, options) {
            var state = new CodegenState(options);
            return {
                render: "with(this){return " + (ast ? genElement(ast, state) : '_c("div")') + "}",
                staticRenderFns: state.staticRenderFns
            };
        }
        function genElement(el, state) {
            if (el.parent && (el.pre = el.pre || el.parent.pre), el.staticRoot && !el.staticProcessed) return genStatic(el, state);
            if (el.once && !el.onceProcessed) return genOnce(el, state);
            if (el.for && !el.forProcessed) return genFor(el, state);
            if (el.if && !el.ifProcessed) return genIf(el, state);
            if ("template" !== el.tag || el.slotTarget || state.pre) {
                if ("slot" === el.tag) return function(el, state) {
                    var slotName = el.slotName || '"default"', children = genChildren(el, state), res = "_t(" + slotName + (children ? "," + children : ""), attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map((function(attr) {
                        return {
                            name: camelize(attr.name),
                            value: attr.value,
                            dynamic: attr.dynamic
                        };
                    }))) : null, bind$$1 = el.attrsMap["v-bind"];
                    !attrs && !bind$$1 || children || (res += ",null");
                    attrs && (res += "," + attrs);
                    bind$$1 && (res += (attrs ? "" : ",null") + "," + bind$$1);
                    return res + ")";
                }(el, state);
                var code;
                if (el.component) code = function(componentName, el, state) {
                    var children = el.inlineTemplate ? null : genChildren(el, state, !0);
                    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : "") + ")";
                }(el.component, el, state); else {
                    var data;
                    (!el.plain || el.pre && state.maybeComponent(el)) && (data = genData$2(el, state));
                    var children = el.inlineTemplate ? null : genChildren(el, state, !0);
                    code = "_c('" + el.tag + "'" + (data ? "," + data : "") + (children ? "," + children : "") + ")";
                }
                for (var i = 0; i < state.transforms.length; i++) code = state.transforms[i](el, code);
                return code;
            }
            return genChildren(el, state) || "void 0";
        }
        function genStatic(el, state) {
            el.staticProcessed = !0;
            var originalPreState = state.pre;
            return el.pre && (state.pre = el.pre), state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}"), 
            state.pre = originalPreState, "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ",true" : "") + ")";
        }
        function genOnce(el, state) {
            if (el.onceProcessed = !0, el.if && !el.ifProcessed) return genIf(el, state);
            if (el.staticInFor) {
                for (var key = "", parent = el.parent; parent; ) {
                    if (parent.for) {
                        key = parent.key;
                        break;
                    }
                    parent = parent.parent;
                }
                return key ? "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")" : genElement(el, state);
            }
            return genStatic(el, state);
        }
        function genIf(el, state, altGen, altEmpty) {
            return el.ifProcessed = !0, function genIfConditions(conditions, state, altGen, altEmpty) {
                if (!conditions.length) return altEmpty || "_e()";
                var condition = conditions.shift();
                return condition.exp ? "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty) : "" + genTernaryExp(condition.block);
                function genTernaryExp(el) {
                    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
                }
            }(el.ifConditions.slice(), state, altGen, altEmpty);
        }
        function genFor(el, state, altGen, altHelper) {
            var exp = el.for, alias = el.alias, iterator1 = el.iterator1 ? "," + el.iterator1 : "", iterator2 = el.iterator2 ? "," + el.iterator2 : "";
            return el.forProcessed = !0, (altHelper || "_l") + "((" + exp + "),function(" + alias + iterator1 + iterator2 + "){return " + (altGen || genElement)(el, state) + "})";
        }
        function genData$2(el, state) {
            var data = "{", dirs = function(el, state) {
                var dirs = el.directives;
                if (!dirs) return;
                var i, l, dir, needRuntime, res = "directives:[", hasRuntime = !1;
                for (i = 0, l = dirs.length; i < l; i++) {
                    dir = dirs[i], needRuntime = !0;
                    var gen = state.directives[dir.name];
                    gen && (needRuntime = !!gen(el, dir, state.warn)), needRuntime && (hasRuntime = !0, 
                    res += '{name:"' + dir.name + '",rawName:"' + dir.rawName + '"' + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : "") + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : '"' + dir.arg + '"') : "") + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : "") + "},");
                }
                if (hasRuntime) return res.slice(0, -1) + "]";
            }(el, state);
            dirs && (data += dirs + ","), el.key && (data += "key:" + el.key + ","), el.ref && (data += "ref:" + el.ref + ","), 
            el.refInFor && (data += "refInFor:true,"), el.pre && (data += "pre:true,"), el.component && (data += 'tag:"' + el.tag + '",');
            for (var i = 0; i < state.dataGenFns.length; i++) data += state.dataGenFns[i](el);
            if (el.attrs && (data += "attrs:" + genProps(el.attrs) + ","), el.props && (data += "domProps:" + genProps(el.props) + ","), 
            el.events && (data += genHandlers(el.events, !1) + ","), el.nativeEvents && (data += genHandlers(el.nativeEvents, !0) + ","), 
            el.slotTarget && !el.slotScope && (data += "slot:" + el.slotTarget + ","), el.scopedSlots && (data += function(el, slots, state) {
                var needsForceUpdate = el.for || Object.keys(slots).some((function(key) {
                    var slot = slots[key];
                    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot);
                })), needsKey = !!el.if;
                if (!needsForceUpdate) for (var parent = el.parent; parent; ) {
                    if (parent.slotScope && "_empty_" !== parent.slotScope || parent.for) {
                        needsForceUpdate = !0;
                        break;
                    }
                    parent.if && (needsKey = !0), parent = parent.parent;
                }
                var generatedSlots = Object.keys(slots).map((function(key) {
                    return genScopedSlot(slots[key], state);
                })).join(",");
                return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + function(str) {
                    var hash = 5381, i = str.length;
                    for (;i; ) hash = 33 * hash ^ str.charCodeAt(--i);
                    return hash >>> 0;
                }(generatedSlots) : "") + ")";
            }(el, el.scopedSlots, state) + ","), el.model && (data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},"), 
            el.inlineTemplate) {
                var inlineTemplate = function(el, state) {
                    var ast = el.children[0];
                    0;
                    if (ast && 1 === ast.type) {
                        var inlineRenderFns = generate(ast, state.options);
                        return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map((function(code) {
                            return "function(){" + code + "}";
                        })).join(",") + "]}";
                    }
                }(el, state);
                inlineTemplate && (data += inlineTemplate + ",");
            }
            return data = data.replace(/,$/, "") + "}", el.dynamicAttrs && (data = "_b(" + data + ',"' + el.tag + '",' + genProps(el.dynamicAttrs) + ")"), 
            el.wrapData && (data = el.wrapData(data)), el.wrapListeners && (data = el.wrapListeners(data)), 
            data;
        }
        function containsSlotChild(el) {
            return 1 === el.type && ("slot" === el.tag || el.children.some(containsSlotChild));
        }
        function genScopedSlot(el, state) {
            var isLegacySyntax = el.attrsMap["slot-scope"];
            if (el.if && !el.ifProcessed && !isLegacySyntax) return genIf(el, state, genScopedSlot, "null");
            if (el.for && !el.forProcessed) return genFor(el, state, genScopedSlot);
            var slotScope = "_empty_" === el.slotScope ? "" : String(el.slotScope), fn = "function(" + slotScope + "){return " + ("template" === el.tag ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || "undefined") + ":undefined" : genChildren(el, state) || "undefined" : genElement(el, state)) + "}", reverseProxy = slotScope ? "" : ",proxy:true";
            return "{key:" + (el.slotTarget || '"default"') + ",fn:" + fn + reverseProxy + "}";
        }
        function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
            var children = el.children;
            if (children.length) {
                var el$1 = children[0];
                if (1 === children.length && el$1.for && "template" !== el$1.tag && "slot" !== el$1.tag) {
                    var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
                    return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
                }
                var normalizationType$1 = checkSkip ? function(children, maybeComponent) {
                    for (var res = 0, i = 0; i < children.length; i++) {
                        var el = children[i];
                        if (1 === el.type) {
                            if (needsNormalization(el) || el.ifConditions && el.ifConditions.some((function(c) {
                                return needsNormalization(c.block);
                            }))) {
                                res = 2;
                                break;
                            }
                            (maybeComponent(el) || el.ifConditions && el.ifConditions.some((function(c) {
                                return maybeComponent(c.block);
                            }))) && (res = 1);
                        }
                    }
                    return res;
                }(children, state.maybeComponent) : 0, gen = altGenNode || genNode;
                return "[" + children.map((function(c) {
                    return gen(c, state);
                })).join(",") + "]" + (normalizationType$1 ? "," + normalizationType$1 : "");
            }
        }
        function needsNormalization(el) {
            return void 0 !== el.for || "template" === el.tag || "slot" === el.tag;
        }
        function genNode(node, state) {
            return 1 === node.type ? genElement(node, state) : 3 === node.type && node.isComment ? function(comment) {
                return "_e(" + JSON.stringify(comment.text) + ")";
            }(node) : function(text) {
                return "_v(" + (2 === text.type ? text.expression : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
            }(node);
        }
        function genProps(props) {
            for (var staticProps = "", dynamicProps = "", i = 0; i < props.length; i++) {
                var prop = props[i], value = transformSpecialNewlines(prop.value);
                prop.dynamic ? dynamicProps += prop.name + "," + value + "," : staticProps += '"' + prop.name + '":' + value + ",";
            }
            return staticProps = "{" + staticProps.slice(0, -1) + "}", dynamicProps ? "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])" : staticProps;
        }
        function transformSpecialNewlines(text) {
            return text.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b"), 
        new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)");
        function createFunction(code, errors) {
            try {
                return new Function(code);
            } catch (err) {
                return errors.push({
                    err: err,
                    code: code
                }), noop;
            }
        }
        function createCompileToFunctionFn(compile) {
            var cache = Object.create(null);
            return function(template, options, vm) {
                (options = extend({}, options)).warn;
                delete options.warn;
                var key = options.delimiters ? String(options.delimiters) + template : template;
                if (cache[key]) return cache[key];
                var compiled = compile(template, options);
                var res = {}, fnGenErrors = [];
                return res.render = createFunction(compiled.render, fnGenErrors), res.staticRenderFns = compiled.staticRenderFns.map((function(code) {
                    return createFunction(code, fnGenErrors);
                })), cache[key] = res;
            };
        }
        var baseCompile, div, ref$1 = (baseCompile = function(template, options) {
            var ast = parse(template.trim(), options);
            !1 !== options.optimize && optimize(ast, options);
            var code = generate(ast, options);
            return {
                ast: ast,
                render: code.render,
                staticRenderFns: code.staticRenderFns
            };
        }, function(baseOptions) {
            function compile(template, options) {
                var finalOptions = Object.create(baseOptions), errors = [], tips = [];
                if (options) for (var key in options.modules && (finalOptions.modules = (baseOptions.modules || []).concat(options.modules)), 
                options.directives && (finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives)), 
                options) "modules" !== key && "directives" !== key && (finalOptions[key] = options[key]);
                finalOptions.warn = function(msg, range, tip) {
                    (tip ? tips : errors).push(msg);
                };
                var compiled = baseCompile(template.trim(), finalOptions);
                return compiled.errors = errors, compiled.tips = tips, compiled;
            }
            return {
                compile: compile,
                compileToFunctions: createCompileToFunctionFn(compile)
            };
        })(baseOptions), compileToFunctions = (ref$1.compile, ref$1.compileToFunctions);
        function getShouldDecode(href) {
            return (div = div || document.createElement("div")).innerHTML = href ? '<a href="\n"/>' : '<div a="\n"/>', 
            div.innerHTML.indexOf("&#10;") > 0;
        }
        var shouldDecodeNewlines = !!inBrowser && getShouldDecode(!1), shouldDecodeNewlinesForHref = !!inBrowser && getShouldDecode(!0), idToTemplate = cached((function(id) {
            var el = query(id);
            return el && el.innerHTML;
        })), mount = Vue.prototype.$mount;
        Vue.prototype.$mount = function(el, hydrating) {
            if ((el = el && query(el)) === document.body || el === document.documentElement) return this;
            var options = this.$options;
            if (!options.render) {
                var template = options.template;
                if (template) if ("string" == typeof template) "#" === template.charAt(0) && (template = idToTemplate(template)); else {
                    if (!template.nodeType) return this;
                    template = template.innerHTML;
                } else el && (template = function(el) {
                    if (el.outerHTML) return el.outerHTML;
                    var container = document.createElement("div");
                    return container.appendChild(el.cloneNode(!0)), container.innerHTML;
                }(el));
                if (template) {
                    0;
                    var ref = compileToFunctions(template, {
                        outputSourceRange: !1,
                        shouldDecodeNewlines: shouldDecodeNewlines,
                        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
                        delimiters: options.delimiters,
                        comments: options.comments
                    }, this), render = ref.render, staticRenderFns = ref.staticRenderFns;
                    options.render = render, options.staticRenderFns = staticRenderFns;
                }
            }
            return mount.call(this, el, hydrating);
        }, Vue.compile = compileToFunctions, __webpack_exports__.a = Vue;
    }).call(this, __webpack_require__(87), __webpack_require__(95).setImmediate);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return beta;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        proxy.addCaptureVariable("auth", '\n    if (window.hasOwnProperty("__APP_CONFIG__")) {\n      return __APP_CONFIG__.cxApiParams\n    } else {\n      return undefined;\n    }\n  ');
        const status = {
            episode: null
        };
        let authenticated = !1;
        const beta = {
            name: "BetaCrunchyroll",
            domain: "https://beta.crunchyroll.com",
            languages: [ "English", "Spanish", "Portuguese", "French", "German", "Arabic", "Italian", "Russian" ],
            type: "anime",
            isSyncPage: url => Boolean(j.$(".erc-watch-episode-layout").length),
            isOverviewPage: url => Boolean(j.$(".erc-series-hero").length),
            sync: {
                getTitle: url => beta.overview.getTitle(url),
                getIdentifier: url => beta.overview.getIdentifier(url),
                getOverviewUrl(url) {
                    const meta = status.episode.episode_metadata;
                    return utils.absoluteLink(`/series/${meta.series_id}/#season=${meta.season_id}`, beta.domain);
                },
                getEpisode: url => Number(status.episode.episode_metadata.episode_number) || 1,
                nextEpUrl: url => $(".up-next-title").length && $(".up-next-title").first().attr("href") ? utils.absoluteLink($(".up-next-title").first().attr("href"), beta.domain) : ""
            },
            overview: {
                getTitle: url => status.episode.episode_metadata.season_title.replace(/\(.+[ds]ub\)/i, "").replace(/\(\d+-\d+\)/, "").trim(),
                getIdentifier: url => status.episode.episode_metadata.season_id,
                uiSelector(selector) {
                    j.$(".top-controls").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !0,
                    elementsSelector: () => j.$(".episode-list .c-playable-card"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), beta.domain),
                    elementEp(selector) {
                        const matches = selector.find(".c-playable-card__title").first().text().match(/E(\d+)/);
                        return matches ? Number(matches[1]) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(323).toString());
                let placeholderInterval, firstCall = !0;
                function check() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        page.reset(), status.episode = null, yield function() {
                            return __awaiter(this, void 0, void 0, (function*() {
                                authenticated || (yield function() {
                                    return __awaiter(this, void 0, void 0, (function*() {
                                        const logger = authLogger.m("Data");
                                        logger.log("start");
                                        const data = yield proxy.getProxyVariable("auth");
                                        if (!data) throw "No auth Data found";
                                        authObj.domain = data.apiDomain, authObj.clientId = data.accountAuthClientId, logger.log(authObj);
                                    }));
                                }(), yield function() {
                                    return __awaiter(this, void 0, void 0, (function*() {
                                        const logger = authLogger.m("Token");
                                        logger.log("start");
                                        const response = yield apiCall("/auth/v1/token", "POST", {
                                            basic: !0
                                        });
                                        if (200 !== response.status) throw "Could not get Token";
                                        const data = JSON.parse(response.responseText);
                                        authObj.token = data.access_token, logger.log(authObj);
                                    }));
                                }(), yield function() {
                                    return __awaiter(this, void 0, void 0, (function*() {
                                        const logger = authLogger.m("Policy");
                                        logger.log("start");
                                        const response = yield apiCall("/index/v2", "GET", {
                                            bearer: !0
                                        });
                                        if (200 !== response.status) throw "Could not get Policy";
                                        const data = JSON.parse(response.responseText);
                                        authObj.bucket.path = data.cms.bucket, authObj.bucket.keyPairId = data.cms.key_pair_id, 
                                        authObj.bucket.policy = data.cms.policy, authObj.bucket.signature = data.cms.signature, 
                                        logger.log(authObj);
                                    }));
                                }(), authenticated = !0);
                            }));
                        }(), clearInterval(placeholderInterval), placeholderInterval = utils.waitUntilTrue(() => beta.isSyncPage(page.url) || beta.isOverviewPage(page.url), () => __awaiter(this, void 0, void 0, (function*() {
                            if (beta.isOverviewPage(page.url)) return console.log("Waiting for page to load"), 
                            clearInterval(placeholderInterval), void (placeholderInterval = utils.waitUntilTrue(() => Boolean($(".episode-list .c-playable-card a").length), () => __awaiter(this, void 0, void 0, (function*() {
                                const epUrl = $(".episode-list .c-playable-card a").first().attr("href");
                                if (!epUrl) throw "No Episode found on the page";
                                status.episode = yield episode(getIdFromUrl(epUrl)), page.handlePage(), firstCall && function(id) {
                                    __awaiter(this, void 0, void 0, (function*() {
                                        const logger = con.m("Season Selecter");
                                        if (!window.location.href.includes("season")) return void logger.log("Nothing to do");
                                        const tempUrl = window.location.href.replace("#", "?"), selectId = utils.urlParam(tempUrl, "season");
                                        if (logger.log(selectId, id), selectId === id) return void logger.log("Correct Season");
                                        const index = (yield function(id) {
                                            return __awaiter(this, void 0, void 0, (function*() {
                                                const logger = con.m("Seasons").m(String(id));
                                                logger.log("start");
                                                const response = yield apiCall("/seasons?series_id=" + id, "GET", {
                                                    cms: !0
                                                });
                                                logger.log(response.finalUrl);
                                                const data = JSON.parse(response.responseText);
                                                if (!data || !data.items.length) throw "No Season Data found";
                                                if ("season" !== data.items[0].__class__) throw "Are not seasons";
                                                return logger.log(data.items), data.items;
                                            }));
                                        }(getIdFromUrl(tempUrl))).findIndex(se => se.id === selectId);
                                        -1 !== index ? ($(".seasons-select .c-dropdown-content").length || $('.seasons-select [role="button"].trigger').click(), 
                                        $('.seasons-select .c-dropdown-content [role="button"]').eq(index).click()) : logger.log("Not available here");
                                    }));
                                }(beta.overview.getIdentifier(page.url)), firstCall = !1;
                            }))));
                            status.episode = yield episode(getIdFromUrl(page.url)), page.handlePage(), firstCall = !1;
                        })));
                    }));
                }
                utils.changeDetect(() => {
                    beta.overview.list.elementsSelector().length && page.handleList();
                }, () => beta.overview.list.elementsSelector().length), j.$(document).ready((function() {
                    check();
                })), utils.changeDetect(() => check(), () => {
                    const sesInfo = $(".season-info .c-text").first().text();
                    return sesInfo || window.location.href;
                });
            }
        }, authLogger = con.m("auth"), authObj = {
            domain: "",
            clientId: "",
            token: "",
            bucket: {
                path: "",
                keyPairId: "",
                policy: "",
                signature: ""
            }
        };
        function episode(id) {
            return __awaiter(this, void 0, void 0, (function*() {
                const logger = con.m("Episode").m(String(id));
                logger.log("start");
                const response = yield apiCall("/objects/" + id, "GET", {
                    cms: !0
                });
                logger.log(response.finalUrl);
                const data = JSON.parse(response.responseText);
                if (!data || !data.items.length) throw "No Episode data found";
                const ep = data.items[0];
                if ("episode" !== ep.type) throw "Not an Episode";
                return logger.log(ep), ep;
            }));
        }
        function apiCall(path, type = "GET", mode = {}) {
            return __awaiter(this, void 0, void 0, (function*() {
                const options = {
                    url: authObj.domain + path,
                    headers: {
                        Accept: "application/json"
                    }
                };
                if (mode.basic && (options.headers.authorization = "Basic " + btoa(authObj.clientId + ":"), 
                options.headers["Content-Type"] = "application/x-www-form-urlencoded", options.data = "grant_type=etp_rt_cookie"), 
                mode.bearer && (options.headers.authorization = "Bearer " + authObj.token), mode.cms) {
                    const b = authObj.bucket;
                    let pre = "?";
                    -1 !== path.indexOf("?") && (pre = "&"), options.url = `${authObj.domain}/cms/v2${b.path}${path}${pre}Signature=${b.signature}&Policy=${b.policy}&Key-Pair-Id=${b.keyPairId}`;
                }
                return api.request.xhr(type, options);
            }));
        }
        function getIdFromUrl(url) {
            const res = url.match(/(series|watch)\/([^/]+)/i);
            if (!res[2]) throw "Could not find id in " + url;
            return res[2];
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UserList;
        }));
        var _listAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class UserList extends _listAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.name = "Simkl", this.authenticationUrl = "https://simkl.com/oauth/authorize?response_type=code&client_id=39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0&redirect_uri=https://simkl.com/apps/chrome/mal-sync/connected/", 
                this.syncList = _helper__WEBPACK_IMPORTED_MODULE_1__.g, this.translateList = _helper__WEBPACK_IMPORTED_MODULE_1__.h, 
                this.getCacheKey = _helper__WEBPACK_IMPORTED_MODULE_1__.d, this.getEpisode = _helper__WEBPACK_IMPORTED_MODULE_1__.e, 
                this.call = _helper__WEBPACK_IMPORTED_MODULE_1__.a;
            }
            getUsername() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.call("https://api.simkl.com/users/settings").then(res => {
                        if (con.log(res), res && res.user && void 0 !== res.user.name) return res.user.name;
                        throw {
                            code: 400,
                            message: "Not Authenticated"
                        };
                    });
                }));
            }
            deauth() {
                return api.settings.set("simklToken", "");
            }
            errorHandling(res, code) {
                if (void 0 !== res.error) throw con.error(res.error), {
                    code: code,
                    message: res.error
                };
                switch (code) {
                  case 200:
                  case 201:
                  case 204:
                  case 302:
                    break;

                  default:
                    throw {
                        code: code,
                        message: "Code: " + code
                    };
                }
            }
            _getSortingOptions() {
                return [];
            }
            getPart() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (con.log("[UserList][Simkl]", "status: " + this.status), "manga" === this.listType) throw {
                        code: 415,
                        message: "Does not support manga"
                    };
                    return this.syncList().then(list => __awaiter(this, void 0, void 0, (function*() {
                        this.done = !0;
                        const data = yield this.prepareData(Object.values(list), this.listType, this.status);
                        return con.log(data), data;
                    })));
                }));
            }
            prepareData(data, listType, status) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const newData = [];
                    for (let i = 0; i < data.length; i++) {
                        const el = data[i], st = this.translateList(el.status);
                        if (7 !== status && parseInt(st) !== status) continue;
                        let curep = this.getEpisode(el.last_watched);
                        if (2 === st && (curep = el.total_episodes_count), "anime" === listType) {
                            const tempData = yield this.fn({
                                malId: el.show.ids.mal,
                                apiCacheKey: el.show.ids.mal,
                                uid: el.show.ids.simkl,
                                cacheKey: this.getCacheKey(el.show.ids.mal, el.show.ids.simkl),
                                type: listType,
                                title: el.show.title,
                                url: `https://simkl.com/${listType}/${el.show.ids.simkl}`,
                                watchedEp: curep,
                                totalEp: el.total_episodes_count,
                                status: st,
                                score: el.user_rating ? el.user_rating : 0,
                                image: `https://simkl.in/posters/${el.show.poster}_ca.jpg`,
                                tags: el.private_memo,
                                airingState: el.anime_airing_status
                            });
                            newData.push(tempData);
                        }
                    }
                    return newData;
                }));
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        function msDiffToShortTimeString(ms) {
            return function(el) {
                let output = "";
                return 1 === el.y ? output += ` ${el.y} ${api.storage.lang("bookmarksItem_Year")}` : el.y > 1 && (output += ` ${el.y} ${api.storage.lang("bookmarksItem_Years")}`), 
                1 === el.d ? output += ` ${el.d} ${api.storage.lang("bookmarksItem_Day")}` : el.d > 1 && (output += ` ${el.d} ${api.storage.lang("bookmarksItem_Days")}`), 
                1 === el.h ? output += ` ${el.h} ${api.storage.lang("bookmarksItem_Hour")}` : el.h > 1 && (output += ` ${el.h} ${api.storage.lang("bookmarksItem_Hours")}`), 
                1 === el.m ? output += ` ${el.m} ${api.storage.lang("bookmarksItem_min")}` : el.m > 1 && (output += ` ${el.m} ${api.storage.lang("bookmarksItem_mins")}`), 
                1 === el.s ? output += ` ${el.s} ${api.storage.lang("bookmarksItem_sec")}` : el.s > 1 && (output += ` ${el.s} ${api.storage.lang("bookmarksItem_secs")}`), 
                output.trim();
            }((el = function(milliseconds) {
                let day, hour, minute, seconds;
                seconds = Math.floor(milliseconds / 1e3), minute = Math.floor(seconds / 60), seconds %= 60, 
                hour = Math.floor(minute / 60), minute %= 60, day = Math.floor(hour / 24), hour %= 24;
                const year = Math.floor(day / 365);
                return day %= 365, {
                    y: year,
                    d: day,
                    h: hour,
                    m: minute,
                    s: seconds
                };
            }(ms)).y > 1 ? el.d > 182 ? {
                y: el.y + 1,
                d: 0,
                h: 0,
                m: 0,
                s: 0
            } : {
                y: el.y,
                d: 0,
                h: 0,
                m: 0,
                s: 0
            } : el.y ? {
                y: el.y,
                d: el.d,
                h: 0,
                m: 0,
                s: 0
            } : el.d > 3 ? el.h > 11 ? {
                y: 0,
                d: el.d + 1,
                h: 0,
                m: 0,
                s: 0
            } : {
                y: 0,
                d: el.d,
                h: 0,
                m: 0,
                s: 0
            } : el.d ? {
                y: 0,
                d: el.d,
                h: el.h,
                m: 0,
                s: 0
            } : el.h > 5 ? el.m > 29 ? {
                y: 0,
                d: 0,
                h: el.h + 1,
                m: 0,
                s: 0
            } : {
                y: 0,
                d: 0,
                h: el.h,
                m: 0,
                s: 0
            } : el.h ? {
                y: 0,
                d: 0,
                h: el.h,
                m: el.m,
                s: 0
            } : el.m > 14 ? {
                y: 0,
                d: 0,
                h: 0,
                m: el.m,
                s: 0
            } : {
                y: 0,
                d: 0,
                h: 0,
                m: el.m,
                s: el.s
            });
            var el;
        }
        function timestampToShortTime(tm, ago = !0) {
            if (!tm) return "";
            const curTime = Date.now();
            let diff, future;
            if (curTime > tm ? (future = !1, diff = curTime - tm) : (future = !0, diff = tm - curTime), 
            diff < 3e4) return api.storage.lang("bookmarksItem_now");
            let short = msDiffToShortTimeString(diff);
            return !future && ago && (short = api.storage.lang("bookmarksItem_ago", [ short ])), 
            short;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return msDiffToShortTimeString;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return timestampToShortTime;
        }));
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return keyboardMap;
    }));
    const keyboardMap = [ "", "", "", "CANCEL", "", "", "HELP", "", "BACK_SPACE", "TAB", "", "", "CLEAR", "ENTER", "ENTER_SPECIAL", "", "SHIFT", "CONTROL", "ALT", "PAUSE", "CAPS_LOCK", "KANA", "EISU", "JUNJA", "FINAL", "HANJA", "", "ESCAPE", "CONVERT", "NONCONVERT", "ACCEPT", "MODECHANGE", "SPACE", "PAGE_UP", "PAGE_DOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "SELECT", "PRINT", "EXECUTE", "PRINTSCREEN", "INSERT", "DELETE", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "COLON", "SEMICOLON", "LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "AT", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "OS_KEY", "", "CONTEXT_MENU", "", "SLEEP", "NUMPAD0", "NUMPAD1", "NUMPAD2", "NUMPAD3", "NUMPAD4", "NUMPAD5", "NUMPAD6", "NUMPAD7", "NUMPAD8", "NUMPAD9", "MULTIPLY", "ADD", "SEPARATOR", "SUBTRACT", "DECIMAL", "DIVIDE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "NUM_LOCK", "SCROLL_LOCK", "WIN_OEM_FJ_JISHO", "WIN_OEM_FJ_MASSHOU", "WIN_OEM_FJ_TOUROKU", "WIN_OEM_FJ_LOYA", "WIN_OEM_FJ_ROYA", "", "", "", "", "", "", "", "", "", "CIRCUMFLEX", "EXCLAMATION", "DOUBLE_QUOTE", "HASH", "DOLLAR", "PERCENT", "AMPERSAND", "UNDERSCORE", "OPEN_PAREN", "CLOSE_PAREN", "ASTERISK", "PLUS", "PIPE", "HYPHEN_MINUS", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "TILDE", "", "", "", "", "VOLUME_MUTE", "VOLUME_DOWN", "VOLUME_UP", "", "", "SEMICOLON", "EQUALS", "COMMA", "MINUS", "PERIOD", "SLASH", "BACK_QUOTE", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OPEN_BRACKET", "BACK_SLASH", "CLOSE_BRACKET", "QUOTE", "", "META", "ALTGR", "", "WIN_ICO_HELP", "WIN_ICO_00", "", "WIN_ICO_CLEAR", "", "", "WIN_OEM_RESET", "WIN_OEM_JUMP", "WIN_OEM_PA1", "WIN_OEM_PA2", "WIN_OEM_PA3", "WIN_OEM_WSCTRL", "WIN_OEM_CUSEL", "WIN_OEM_ATTN", "WIN_OEM_FINISH", "WIN_OEM_COPY", "WIN_OEM_AUTO", "WIN_OEM_ENLW", "WIN_OEM_BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN_OEM_CLEAR", "" ];
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UserList;
        }));
        var _listAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class UserList extends _listAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.name = "AniList", this.compact = !1, this.seperateRewatching = !0, 
                this.authenticationUrl = "https://anilist.co/api/v2/oauth/authorize?client_id=1487&response_type=token";
            }
            getUsername() {
                return this.api.request.xhr("POST", {
                    url: "https://graphql.anilist.co",
                    headers: {
                        Authorization: "Bearer " + this.accessToken(),
                        "Content-Type": "application/json",
                        Accept: "application/json"
                    },
                    data: JSON.stringify({
                        query: "\n    query {\n      Viewer {\n        name\n        id\n        options {\n          displayAdultContent\n        }\n        mediaListOptions {\n          scoreFormat\n        }\n      }\n    }\n    ",
                        variables: []
                    })
                }).then(response => {
                    const res = this.jsonParse(response);
                    if (con.log(res), this.errorHandling(res), res.data.Viewer.options && res.data.Viewer.mediaListOptions) {
                        const opt = api.settings.get("anilistOptions");
                        opt.displayAdultContent = res.data.Viewer.options.displayAdultContent, opt.scoreFormat = res.data.Viewer.mediaListOptions.scoreFormat, 
                        api.settings.set("anilistOptions", opt);
                    }
                    return res.data.Viewer.name;
                });
            }
            deauth() {
                return api.settings.set("anilistToken", "");
            }
            errorHandling(res) {
                if (void 0 !== res.errors) throw con.error(res.errors), {
                    code: res.errors[0].status,
                    message: res.errors[0].message
                };
            }
            accessToken() {
                return this.api.settings.get("anilistToken");
            }
            _getSortingOptions() {
                return [ {
                    icon: "sort_by_alpha",
                    title: "Alphabetic",
                    value: "alpha"
                }, {
                    icon: "history",
                    title: "Last Updated",
                    value: "updated",
                    asc: !0
                }, {
                    icon: "score",
                    title: "Score",
                    value: "score",
                    asc: !0
                } ];
            }
            getOrder(sort) {
                switch (sort) {
                  case "alpha":
                    return "MEDIA_TITLE_ENGLISH";

                  case "updated":
                    return "UPDATED_TIME_DESC";

                  case "updated_asc":
                    return "UPDATED_TIME";

                  case "score":
                    return "SCORE_DESC";

                  case "score_asc":
                    return "SCORE";

                  default:
                    return 1 === this.status || this.status, this.getOrder("updated");
                }
            }
            getPart() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.offset < 1 && (this.offset = 1), con.log("[UserList][AniList]", "username: " + this.username, "status: " + this.status, "offset: " + this.offset), 
                    this.username || (this.username = yield this.getUsername());
                    let query = "\n    query ($page: Int, $userName: String, $type: MediaType, $status: MediaListStatus, $sort: [MediaListSort] ) {\n      Page (page: $page, perPage: 100) {\n        pageInfo {\n          hasNextPage\n        }\n        mediaList (status: $status, type: $type, userName: $userName, sort: $sort) {\n          status\n          score(format: POINT_100)\n          progress\n          progressVolumes\n          notes\n          media {\n            siteUrl\n            id\n            idMal\n            episodes\n            chapters\n            volumes\n            status\n            averageScore\n            coverImage{\n              large\n            }\n            title {\n              userPreferred\n            }\n          }\n        }\n      }\n    }\n    ";
                    this.compact && (query = "\n      query ($page: Int, $userName: String, $type: MediaType, $status: MediaListStatus, $sort: [MediaListSort]) {\n        Page (page: $page, perPage: 100) {\n          pageInfo {\n            hasNextPage\n          }\n          mediaList (status: $status, type: $type, userName: $userName, sort: $sort) {\n            progress\n            media {\n              id\n              idMal\n            }\n          }\n        }\n      }\n      ");
                    const variables = {
                        page: this.offset,
                        userName: this.username,
                        type: this.listType.toUpperCase(),
                        status: _helper__WEBPACK_IMPORTED_MODULE_1__.e[parseInt(this.status.toString())],
                        sort: null
                    }, order = this.getOrder(this.sort);
                    return order && (variables.sort = order), this.api.request.xhr("POST", {
                        url: "https://graphql.anilist.co",
                        headers: {
                            Authorization: "Bearer " + this.accessToken(),
                            "Content-Type": "application/json",
                            Accept: "application/json"
                        },
                        data: JSON.stringify({
                            query: query,
                            variables: variables
                        })
                    }).then(response => {
                        const res = this.jsonParse(response);
                        con.log("res", res), this.errorHandling(res);
                        const data = res.data.Page.mediaList;
                        return this.offset += 1, res.data.Page.pageInfo.hasNextPage || (this.done = !0), 
                        this.prepareData(data, this.listType);
                    });
                }));
            }
            prepareData(data, listType) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, (function*() {
                    const newData = [];
                    for (let i = 0; i < data.length; i++) {
                        const el = data[i];
                        let tempData;
                        tempData = "anime" === listType ? yield this.fn({
                            uid: el.media.id,
                            malId: el.media.idMal,
                            apiCacheKey: null !== (_a = el.media.idMal) && void 0 !== _a ? _a : "anilist:" + el.media.id,
                            cacheKey: _helper__WEBPACK_IMPORTED_MODULE_1__.c(el.media.idMal, el.media.id),
                            type: listType,
                            title: el.media.title.userPreferred,
                            url: el.media.siteUrl,
                            watchedEp: el.progress,
                            totalEp: el.media.episodes,
                            status: _helper__WEBPACK_IMPORTED_MODULE_1__.f(el.status),
                            score: Math.round(el.score / 10),
                            image: el.media.coverImage.large,
                            tags: el.notes,
                            airingState: el.anime_airing_status
                        }) : yield this.fn({
                            uid: el.media.id,
                            malId: el.media.idMal,
                            apiCacheKey: null !== (_b = el.media.idMal) && void 0 !== _b ? _b : "anilist:" + el.media.id,
                            cacheKey: _helper__WEBPACK_IMPORTED_MODULE_1__.c(el.media.idMal, el.media.id),
                            type: listType,
                            title: el.media.title.userPreferred,
                            url: el.media.siteUrl,
                            watchedEp: el.progress,
                            totalEp: el.media.chapters,
                            status: _helper__WEBPACK_IMPORTED_MODULE_1__.f(el.status),
                            score: Math.round(el.score / 10),
                            image: el.media.coverImage.large,
                            tags: el.notes,
                            airingState: el.anime_airing_status
                        }), null === tempData.totalEp && (tempData.totalEp = 0), newData.push(tempData);
                    }
                    return newData;
                }));
            }
            prepareCompact(data, listType) {
                const newData = [];
                for (let i = 0; i < data.length; i++) {
                    const el = data[i];
                    newData.push({
                        malid: el.media.idMal,
                        id: el.media.id,
                        watchedEp: el.progress,
                        cacheKey: _helper__WEBPACK_IMPORTED_MODULE_1__.c(el.media.idMal, el.media.id)
                    });
                }
                return newData;
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UserList;
        }));
        var _listAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class UserList extends _listAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.name = "Kitsu", this.authenticationUrl = "https://kitsu.io/404?mal-sync=authentication";
            }
            getUsername() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const user = yield this.userRequest(), opt = api.settings.get("kitsuOptions");
                    return opt.titleLanguagePreference = user.attributes.titleLanguagePreference, opt.sfwFilter = user.attributes.sfwFilter, 
                    opt.ratingSystem = user.attributes.ratingSystem, api.settings.set("kitsuOptions", opt), 
                    user.attributes.name;
                }));
            }
            getUserId() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const userId = yield api.storage.get("kitsuUserId");
                    if (void 0 !== userId) return userId;
                    const user = yield this.userRequest();
                    return api.storage.set("kitsuUserId", user.id), user.id;
                }));
            }
            userRequest() {
                return api.request.xhr("GET", {
                    url: "https://kitsu.io/api/edge/users?filter[self]=true",
                    headers: {
                        Authorization: "Bearer " + this.accessToken(),
                        "Content-Type": "application/vnd.api+json",
                        Accept: "application/vnd.api+json"
                    }
                }).then(response => {
                    const res = this.jsonParse(response);
                    if (con.log(res), this.errorHandling(res), void 0 === res.data[0]) throw {
                        code: 400,
                        message: "Not Authenticated"
                    };
                    return res.data[0];
                });
            }
            deauth() {
                return api.settings.set("kitsuToken", "").then(() => api.storage.set("kitsuUserId", ""));
            }
            errorHandling(res) {
                if (void 0 !== res.errors) throw con.error(res.errors), {
                    code: parseInt(res.errors[0].status),
                    message: res.errors[0].title
                };
            }
            accessToken() {
                return api.settings.get("kitsuToken");
            }
            _getSortingOptions() {
                return [ {
                    icon: "sort_by_alpha",
                    title: "Alphabetic",
                    value: "alpha",
                    asc: !0
                }, {
                    icon: "history",
                    title: "Last Updated",
                    value: "updated",
                    asc: !0
                }, {
                    icon: "score",
                    title: "Score",
                    value: "score",
                    asc: !0
                } ];
            }
            getOrder(sort) {
                let pre = "";
                sort.endsWith("_asc") || (pre = "-");
                switch (sort.replace("_asc", "")) {
                  case "alpha":
                    return pre = pre ? "" : "-", `${pre}${this.listType}.titles.en`;

                  case "updated":
                    return pre + "progressed_at";

                  case "score":
                    return pre + "rating";

                  default:
                    return 1 === this.status || 6 === this.status ? this.getOrder("updated") : this.getOrder("alpha");
                }
            }
            getPart() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const userid = yield this.getUserId();
                    let statusPart = "", sorting = "";
                    const order = this.getOrder(this.sort);
                    if (order && (sorting = "&sort=" + order), 7 !== this.status) {
                        statusPart = "&filter[status]=" + _helper__WEBPACK_IMPORTED_MODULE_1__.f(this.status, this.status);
                    }
                    return con.log("[UserList][Kitsu]", "user: " + userid, "status: " + this.status, "offset: " + this.offset), 
                    api.request.xhr("GET", {
                        url: `https://kitsu.io/api/edge/library-entries?filter[user_id]=${userid}${statusPart}&filter[kind]=${this.listType}&page[offset]=${this.offset}&page[limit]=50${sorting}&include=${this.listType},${this.listType}.mappings,${this.listType}.mappings.item&fields[${this.listType}]=slug,titles,canonicalTitle,averageRating,posterImage,${"anime" === this.listType ? "episodeCount" : "chapterCount,volumeCount"}`,
                        headers: {
                            Authorization: "Bearer " + this.accessToken(),
                            "Content-Type": "application/vnd.api+json",
                            Accept: "application/vnd.api+json"
                        },
                        data: {}
                    }).then(response => {
                        const res = this.jsonParse(response);
                        return con.log(res), this.errorHandling(res), this.offset += 50, res.meta.count > this.offset || (this.done = !0), 
                        this.prepareData(res, this.listType);
                    });
                }));
            }
            prepareData(data, listType) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const newData = [];
                    for (let i = 0; i < data.data.length; i++) {
                        const list = data.data[i], el = data.included[i], name = _helper__WEBPACK_IMPORTED_MODULE_1__.c(el.attributes.titles, el.attributes.canonicalTitle);
                        let tempData, malId = NaN;
                        for (let k = 0; k < data.included.length; k++) {
                            const mapping = data.included[k];
                            if ("mappings" === mapping.type && mapping.attributes.externalSite === "myanimelist/" + listType && mapping.relationships.item.data.id === el.id) {
                                malId = mapping.attributes.externalId, data.included.splice(k, 1);
                                break;
                            }
                        }
                        tempData = "anime" === listType ? yield this.fn({
                            malId: malId,
                            apiCacheKey: malId,
                            uid: el.id,
                            cacheKey: _helper__WEBPACK_IMPORTED_MODULE_1__.b(malId, el.id),
                            kitsuSlug: el.attributes.slug,
                            type: listType,
                            title: name,
                            url: `https://kitsu.io/${listType}/${el.attributes.slug}`,
                            watchedEp: list.attributes.progress,
                            totalEp: el.attributes.episodeCount,
                            status: _helper__WEBPACK_IMPORTED_MODULE_1__.f(list.attributes.status),
                            score: Math.round(list.attributes.ratingTwenty / 2),
                            image: el.attributes.posterImage && el.attributes.posterImage.large ? el.attributes.posterImage.large : "",
                            tags: list.attributes.notes,
                            airingState: el.anime_airing_status
                        }) : yield this.fn({
                            malId: malId,
                            apiCacheKey: malId,
                            uid: el.id,
                            cacheKey: _helper__WEBPACK_IMPORTED_MODULE_1__.b(malId, el.id),
                            kitsuSlug: el.attributes.slug,
                            type: listType,
                            title: name,
                            url: `https://kitsu.io/${listType}/${el.attributes.slug}`,
                            watchedEp: list.attributes.progress,
                            totalEp: el.attributes.chapterCount,
                            status: _helper__WEBPACK_IMPORTED_MODULE_1__.f(list.attributes.status),
                            score: Math.round(list.attributes.ratingTwenty / 2),
                            image: el.attributes.posterImage && el.attributes.posterImage.large ? el.attributes.posterImage.large : "",
                            tags: list.attributes.notes,
                            airingState: el.anime_airing_status
                        }), null === tempData.totalEp && (tempData.totalEp = 0), newData.push(tempData);
                    }
                    return newData;
                }));
            }
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Single;
        }));
        var _singleAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9), _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Single extends _singleAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.url = url, this.displayUrl = "", this.shortName = "AniList", 
                this.authenticationUrl = "https://anilist.co/api/v2/oauth/authorize?client_id=1487&response_type=token", 
                this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_1__.b, this.logger = con.m(this.shortName, "#3db4f2"), 
                this;
            }
            handleUrl(url) {
                if (url.match(/anilist\.co\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.ids.ani = Number(utils.urlPart(url, 4)));
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.ids.mal = Number(utils.urlPart(url, 4)));
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.UrlNotSuported, "Url not supported");
            }
            getCacheKey() {
                return _helper__WEBPACK_IMPORTED_MODULE_1__.c(this.ids.mal, this.ids.ani);
            }
            _getStatus() {
                return parseInt(_helper__WEBPACK_IMPORTED_MODULE_1__.e[this.animeInfo.mediaListEntry.status]);
            }
            _setStatus(status) {
                this.animeInfo.mediaListEntry.status = _helper__WEBPACK_IMPORTED_MODULE_1__.e[status];
            }
            _getScore() {
                if (0 === this.animeInfo.mediaListEntry.score) return 0;
                const score = Math.round(this.animeInfo.mediaListEntry.score / 10);
                return 0 === score ? 1 : score;
            }
            _setScore(score) {
                this.animeInfo.mediaListEntry.score = 10 * score;
            }
            _getEpisode() {
                return this.animeInfo.mediaListEntry.progress;
            }
            _setEpisode(episode) {
                this.animeInfo.mediaListEntry.progress = parseInt("" + episode);
            }
            _getVolume() {
                return this.animeInfo.mediaListEntry.progressVolumes;
            }
            _setVolume(volume) {
                this.animeInfo.mediaListEntry.progressVolumes = volume;
            }
            _getTags() {
                let tags = this.animeInfo.mediaListEntry.notes;
                return null !== tags && "null" !== tags || (tags = ""), tags;
            }
            _setTags(tags) {
                this.animeInfo.mediaListEntry.notes = tags;
            }
            _getTitle() {
                return this.animeInfo.title.userPreferred;
            }
            _getTotalEpisodes() {
                const eps = this.animeInfo.episodes ? this.animeInfo.episodes : this.animeInfo.chapters;
                return null === eps ? 0 : eps;
            }
            _getTotalVolumes() {
                const vol = this.animeInfo.volumes;
                return vol || 0;
            }
            _getDisplayUrl() {
                return "" !== this.displayUrl && null !== this.displayUrl ? this.displayUrl : this.url;
            }
            _getImage() {
                return Promise.resolve(this.animeInfo.coverImage.large);
            }
            _getRating() {
                return Promise.resolve(this.animeInfo.averageScore);
            }
            _update() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let selectId = this.ids.mal, selectQuery = "idMal";
                    Number.isNaN(this.ids.mal) && (selectId = this.ids.ani, selectQuery = "id");
                    const query = `\n    query ($id: Int, $type: MediaType) {\n      Media (${selectQuery}: $id, type: $type) {\n        id\n        idMal\n        siteUrl\n        episodes\n        chapters\n        volumes\n        averageScore\n        coverImage{\n          large\n        }\n        title {\n          userPreferred\n        }\n        mediaListEntry {\n          id\n          status\n          progress\n          progressVolumes\n          score(format: POINT_100)\n          repeat\n          notes\n        }\n      }\n    }\n    `, variables = {
                        id: selectId,
                        type: this.type.toUpperCase()
                    };
                    return this._authenticated = !0, this.apiCall(query, variables).catch(e => {
                        if (e.code === _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated) return this._authenticated = !1, 
                        this.apiCall(query, variables, !1);
                        throw e;
                    }).then(json => {
                        if (this.logger.log("[SINGLE]", "Data", json), this.animeInfo = json.data.Media, 
                        this.ids.ani = this.animeInfo.id, Number.isNaN(this.ids.mal) && this.animeInfo.idMal && (this.ids.mal = this.animeInfo.idMal), 
                        this.displayUrl = this.animeInfo.siteUrl, this._onList = !0, null === this.animeInfo.mediaListEntry && (this._onList = !1, 
                        this.animeInfo.mediaListEntry = {
                            notes: "",
                            progress: 0,
                            progressVolumes: 0,
                            repeat: 0,
                            score: 0,
                            status: "PLANNING"
                        }), !this._authenticated) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated, "Not Authenticated");
                    });
                }));
            }
            _sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let query = "\n      mutation ($mediaId: Int, $status: MediaListStatus, $progress: Int, $scoreRaw: Int, $notes: String) {\n        SaveMediaListEntry (mediaId: $mediaId, status: $status, progress: $progress, scoreRaw: $scoreRaw, notes: $notes) {\n          id\n          status\n          progress\n        }\n      }\n    ";
                    const variables = {
                        mediaId: this.ids.ani,
                        status: this.animeInfo.mediaListEntry.status,
                        progress: this.animeInfo.mediaListEntry.progress,
                        scoreRaw: this.animeInfo.mediaListEntry.score,
                        notes: this.animeInfo.mediaListEntry.notes,
                        volumes: null
                    };
                    return "manga" === this.type && (query = "\n        mutation ($mediaId: Int, $status: MediaListStatus, $progress: Int, $scoreRaw: Int, $notes: String, $volumes: Int) {\n          SaveMediaListEntry (mediaId: $mediaId, status: $status, progress: $progress, scoreRaw: $scoreRaw, notes: $notes, progressVolumes: $volumes) {\n            id\n            status\n            progress\n            progressVolumes\n          }\n        }\n      ", 
                    variables.volumes = this.animeInfo.mediaListEntry.progressVolumes), this.apiCall(query, variables).then(json => (json && json.data && json.data.SaveMediaListEntry && json.data.SaveMediaListEntry.id && (this.animeInfo.mediaListEntry.id = json.data.SaveMediaListEntry.id), 
                    json));
                }));
            }
            getScoreMode() {
                return api.settings.get("anilistOptions").scoreFormat;
            }
            getScoreCheckbox() {
                switch (this.getScoreMode()) {
                  case "POINT_3":
                    return [ {
                        value: "0",
                        label: api.storage.lang("UI_Score_Not_Rated")
                    }, {
                        value: "85",
                        label: "ðŸ™‚"
                    }, {
                        value: "60",
                        label: "ðŸ˜"
                    }, {
                        value: "35",
                        label: "ðŸ™"
                    } ];

                  case "POINT_5":
                    return [ {
                        value: "0",
                        label: api.storage.lang("UI_Score_Not_Rated")
                    }, {
                        value: "90",
                        label: "â˜…â˜…â˜…â˜…â˜…"
                    }, {
                        value: "70",
                        label: "â˜…â˜…â˜…â˜…"
                    }, {
                        value: "50",
                        label: "â˜…â˜…â˜…"
                    }, {
                        value: "30",
                        label: "â˜…â˜…"
                    }, {
                        value: "10",
                        label: "â˜…"
                    } ];

                  case "POINT_10_DECIMAL":
                    {
                        const decArr = [ {
                            value: "0",
                            label: api.storage.lang("UI_Score_Not_Rated")
                        } ];
                        for (let i = 1; i < 101; i++) decArr.push({
                            value: i.toString(),
                            label: (i / 10).toFixed(1)
                        });
                        return decArr;
                    }

                  case "POINT_100":
                    {
                        const resArr = [ {
                            value: "0",
                            label: api.storage.lang("UI_Score_Not_Rated")
                        } ];
                        for (let i = 1; i < 101; i++) resArr.push({
                            value: i.toString(),
                            label: String(i)
                        });
                        return resArr;
                    }

                  default:
                    return super.getScoreCheckbox();
                }
            }
            getScoreCheckboxValue() {
                const curScore = this.animeInfo.mediaListEntry.score;
                switch (this.getScoreMode()) {
                  case "POINT_3":
                    return curScore ? curScore >= 73 ? 85 : curScore <= 47 ? 35 : 60 : 0;

                  case "POINT_5":
                    return curScore ? curScore < 20 ? 10 : curScore < 40 ? 30 : curScore < 60 ? 50 : curScore < 80 ? 70 : 90 : 0;

                  case "POINT_10_DECIMAL":
                  case "POINT_100":
                    return curScore;

                  default:
                    return super.getScoreCheckboxValue();
                }
            }
            handleScoreCheckbox(value) {
                switch (this.getScoreMode()) {
                  case "POINT_3":
                  case "POINT_5":
                  case "POINT_10_DECIMAL":
                  case "POINT_100":
                    this.animeInfo.mediaListEntry.score = value;
                    break;

                  default:
                    super.handleScoreCheckbox(value);
                }
            }
            delete() {
                const variables = {
                    mediaId: this.animeInfo.mediaListEntry.id
                };
                return this.apiCall("\n      mutation ($mediaId: Int) {\n        DeleteMediaListEntry(id: $mediaId) {\n          deleted\n        }\n      }\n    ", variables);
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Single;
        }));
        var _singleAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Single extends _singleAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.url = url, this.shortName = "Kitsu", this.authenticationUrl = "https://kitsu.io/404?mal-sync=authentication", 
                this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_1__.a, this.logger = con.m(this.shortName, "#d65e43"), 
                this;
            }
            listI() {
                return this.animeInfo.data[0];
            }
            animeI() {
                return this.animeInfo.included[0];
            }
            handleUrl(url) {
                if (url.match(/kitsu\.io\/(anime|manga)\/.*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.ids.kitsu.slug = utils.urlPart(url, 4));
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.ids.mal = Number(utils.urlPart(url, 4)));
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.UrlNotSuported, "Url not supported");
            }
            getCacheKey() {
                return _helper__WEBPACK_IMPORTED_MODULE_1__.b(this.ids.mal, this.ids.kitsu.id);
            }
            _getStatus() {
                return this.listI().attributes.reconsuming && "current" === this.listI().attributes.status ? 23 : parseInt(_helper__WEBPACK_IMPORTED_MODULE_1__.f(this.listI().attributes.status));
            }
            _setStatus(status) {
                23 === status ? (status = 1, this.listI().attributes.reconsuming = !0) : this.listI().attributes.reconsuming = !1, 
                this.listI().attributes.status = _helper__WEBPACK_IMPORTED_MODULE_1__.f(status, parseInt(status.toString()));
            }
            _getScore() {
                if (!this.listI().attributes.ratingTwenty) return 0;
                return Math.round(this.listI().attributes.ratingTwenty / 2);
            }
            _setScore(score) {
                this.listI().attributes.ratingTwenty = 0 !== score ? 2 * score : null;
            }
            _getEpisode() {
                return this.listI().attributes.progress;
            }
            _setEpisode(episode) {
                this.listI().attributes.progress = parseInt("" + episode);
            }
            _getVolume() {
                return this.listI().attributes.volumesOwned;
            }
            _setVolume(volume) {
                this.listI().attributes.volumesOwned = volume;
            }
            _getTags() {
                let tags = this.listI().attributes.notes;
                return null !== tags && "null" !== tags || (tags = ""), tags;
            }
            _setTags(tags) {
                this.listI().attributes.notes = tags;
            }
            _getTitle() {
                try {
                    return _helper__WEBPACK_IMPORTED_MODULE_1__.c(this.animeI().attributes.titles, this.animeI().attributes.canonicalTitle);
                } catch (e) {
                    return console.error("title", e), "Failed";
                }
            }
            _getTotalEpisodes() {
                const eps = this.animeI().attributes.episodeCount ? this.animeI().attributes.episodeCount : this.animeI().attributes.chapterCount;
                return null === eps ? 0 : eps;
            }
            _getTotalVolumes() {
                const vol = this.animeI().attributes.volumeCount;
                return vol || 0;
            }
            _getDisplayUrl() {
                return `https://kitsu.io/${this.getType()}/${this.animeI().attributes.slug}`;
            }
            _getImage() {
                return Promise.resolve(this.animeI().attributes.posterImage.large);
            }
            _getRating() {
                return null === this.animeI().attributes.averageRating ? Promise.resolve("") : Promise.resolve(this.animeI().attributes.averageRating + "%");
            }
            _update() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (Number.isNaN(this.ids.mal)) {
                        var kitsuSlugRes = yield this.kitsuSlugtoKitsu(this.ids.kitsu.slug, this.getType());
                        try {
                            this.ids.kitsu.id = kitsuSlugRes.res.data[0].id, this.ids.mal = kitsuSlugRes.malId;
                        } catch (e) {
                            throw this._authenticated = !0, this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.EntryNotFound, "Not found");
                        }
                    }
                    if (Number.isNaN(this.ids.kitsu.id)) {
                        var kitsuRes = yield this.malToKitsu(this.ids.mal, this.getType());
                        try {
                            this.ids.kitsu.id = kitsuRes.data[0].relationships.item.data.id;
                        } catch (e) {
                            throw this._authenticated = !0, this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.EntryNotFound, "Not found");
                        }
                    }
                    return this._authenticated = !0, this.userId().then(userId => this.apiCall("GET", `https://kitsu.io/api/edge/library-entries?filter[user_id]=${userId}&filter[kind]=${this.getType()}&filter[${this.getType()}_id]=${this.ids.kitsu.id}&page[limit]=1&page[limit]=1&include=${this.getType()}&fields[${this.getType()}]=slug,titles,canonicalTitle,averageRating,posterImage,${"anime" === this.getType() ? "episodeCount" : "chapterCount,volumeCount"}`)).catch(e => {
                        if (e.code === _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated) return this._authenticated = !1, 
                        {
                            data: [],
                            included: []
                        };
                        throw e;
                    }).then(res => __awaiter(this, void 0, void 0, (function*() {
                        const tempAnimeInfo = res;
                        this._onList = !0, res.data.length || (this._onList = !1, tempAnimeInfo.data[0] = {
                            attributes: {
                                notes: "",
                                progress: 0,
                                volumesOwned: 0,
                                reconsuming: !1,
                                reconsumeCount: !1,
                                ratingTwenty: null,
                                status: "planned"
                            }
                        }, void 0 !== kitsuRes ? tempAnimeInfo.included = kitsuRes.included : kitsuSlugRes ? tempAnimeInfo.included = kitsuSlugRes.res.data : (kitsuRes = yield this.malToKitsu(this.ids.mal, this.getType()), 
                        tempAnimeInfo.included = kitsuRes.included)), this.animeInfo = tempAnimeInfo;
                        try {
                            this.animeI();
                        } catch (e) {
                            throw this.logger.error(e), this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.EntryNotFound, "Not found");
                        }
                        if (!this._authenticated) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated, "Not Authenticated");
                    })));
                }));
            }
            _sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.listI().attributes.ratingTwenty < 2 && (this.listI().attributes.ratingTwenty = null);
                    const variables = {
                        data: {
                            attributes: {
                                notes: this.listI().attributes.notes,
                                progress: this.listI().attributes.progress,
                                volumesOwned: this.listI().attributes.volumesOwned,
                                reconsuming: this.listI().attributes.reconsuming,
                                reconsumeCount: this.listI().attributes.reconsumeCount,
                                ratingTwenty: this.listI().attributes.ratingTwenty ? this.listI().attributes.ratingTwenty : null,
                                status: this.listI().attributes.status
                            },
                            type: "library-entries"
                        }
                    }, tType = this.getType();
                    if (!tType) return Promise.resolve();
                    let updateUrl, post;
                    return this.isOnList() ? (updateUrl = "https://kitsu.io/api/edge/library-entries/" + this.listI().id, 
                    variables.data.id = this.listI().id, post = "PATCH") : (updateUrl = "https://kitsu.io/api/edge/library-entries/", 
                    variables.data.relationships = {
                        [tType]: {
                            data: {
                                type: tType,
                                id: this.ids.kitsu.id
                            }
                        },
                        user: {
                            data: {
                                type: "users",
                                id: yield this.userId()
                            }
                        }
                    }, post = "POST"), this.logger.log(post, variables), this.apiCall(post, updateUrl, variables).then(res => (res && res.data && res.data.id && (this.listI().id = res.data.id), 
                    res));
                }));
            }
            kitsuSlugtoKitsu(kitsuSlug, type) {
                return this.apiCall("Get", `https://kitsu.io/api/edge/${type}?filter[slug]=${kitsuSlug}&page[limit]=1&include=mappings`, {}).catch(e => {
                    if (e.code === _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated) return this._authenticated = !1, 
                    this.apiCall("Get", `https://kitsu.io/api/edge/${type}?filter[slug]=${kitsuSlug}&page[limit]=1&include=mappings`, {}, !1);
                    throw e;
                }).then(res => {
                    let malId = NaN;
                    if (void 0 !== res && void 0 !== res.included) for (let k = 0; k < res.included.length; k++) {
                        const mapping = res.included[k];
                        if ("mappings" === mapping.type) {
                            if (mapping.attributes.externalSite === "myanimelist/" + type) {
                                malId = mapping.attributes.externalId, res.included.splice(k, 1);
                                break;
                            }
                            mapping.attributes.externalSite === "anilist/" + type && (this.ids.ani = mapping.attributes.externalId);
                        }
                    }
                    return {
                        res: res,
                        malId: malId
                    };
                });
            }
            malToKitsu(malid, type) {
                return this.apiCall("Get", `https://kitsu.io/api/edge/mappings?filter[externalSite]=myanimelist/${type}&filter[externalId]=${malid}&include=item&fields[item]=id`, {}).catch(e => {
                    if (e.code === _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated) return this._authenticated = !1, 
                    this.apiCall("Get", `https://kitsu.io/api/edge/mappings?filter[externalSite]=myanimelist/${type}&filter[externalId]=${malid}&include=item&fields[item]=id`, {}, !1);
                    throw e;
                }).then(res => res);
            }
            userId() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const userId = yield api.storage.get("kitsuUserId");
                    return void 0 !== userId ? userId : this.apiCall("Get", "https://kitsu.io/api/edge/users?filter[self]=true").then(res => {
                        if (void 0 === res.data || !res.data.length || void 0 === res.data[0]) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated, "Not Authenticated");
                        return api.storage.set("kitsuUserId", res.data[0].id), res.data[0].id;
                    });
                }));
            }
            getScoreMode() {
                return api.settings.get("kitsuOptions").ratingSystem;
            }
            getScoreCheckbox() {
                switch (this.getScoreMode()) {
                  case "simple":
                    return [ {
                        value: "0",
                        label: api.storage.lang("UI_Score_Not_Rated")
                    }, {
                        value: "20",
                        label: "ðŸ˜€"
                    }, {
                        value: "14",
                        label: "ðŸ™‚"
                    }, {
                        value: "8",
                        label: "ðŸ˜"
                    }, {
                        value: "2",
                        label: "ðŸ™"
                    } ];

                  case "regular":
                    {
                        const regArr = [ {
                            value: "0",
                            label: api.storage.lang("UI_Score_Not_Rated")
                        } ];
                        for (let i = 1; i < 11; i++) regArr.push({
                            value: (2 * i).toString(),
                            label: (i / 2).toFixed(1).toString()
                        });
                        return regArr;
                    }

                  case "advanced":
                    {
                        const resArr = [ {
                            value: "0",
                            label: api.storage.lang("UI_Score_Not_Rated")
                        } ];
                        for (let i = 1; i < 21; i++) resArr.push({
                            value: i.toString(),
                            label: (i / 2).toFixed(1).toString()
                        });
                        return resArr;
                    }

                  default:
                    return super.getScoreCheckbox();
                }
            }
            getScoreCheckboxValue() {
                let curScore = this.listI().attributes.ratingTwenty;
                switch (curScore || (curScore = 0), this.getScoreMode()) {
                  case "simple":
                    return curScore ? curScore < 6 ? 2 : curScore < 12 ? 8 : curScore < 18 ? 14 : 20 : 0;

                  case "regular":
                    return 2 * Math.round(curScore / 2);

                  case "advanced":
                    return curScore;

                  default:
                    return super.getScoreCheckboxValue();
                }
            }
            handleScoreCheckbox(value) {
                switch (this.getScoreMode()) {
                  case "simple":
                  case "regular":
                  case "advanced":
                    if (0 === value) return void (this.listI().attributes.ratingTwenty = null);
                    this.listI().attributes.ratingTwenty = value;
                    break;

                  default:
                    super.handleScoreCheckbox(value);
                }
            }
            delete() {
                return this.apiCall("DELETE", "https://kitsu.io/api/edge/library-entries/" + this.listI().id);
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Single;
        }));
        var _singleAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Single extends _singleAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.url = url, this.episodeUpdate = !1, this.statusUpdate = !1, 
                this.ratingUpdate = !1, this.minWatchedEp = 1, this.curWatchedEp = 0, this.shortName = "Simkl", 
                this.authenticationUrl = "https://simkl.com/oauth/authorize?response_type=code&client_id=39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0&redirect_uri=https://simkl.com/apps/chrome/mal-sync/connected/", 
                this.rewatchingSupport = !1, this.syncList = _helper__WEBPACK_IMPORTED_MODULE_1__.g, 
                this.getSingle = _helper__WEBPACK_IMPORTED_MODULE_1__.f, this.call = _helper__WEBPACK_IMPORTED_MODULE_1__.a, 
                this.errorHandling = _helper__WEBPACK_IMPORTED_MODULE_1__.c, this.logger = con.m(this.shortName, "#9b7400"), 
                this;
            }
            handleUrl(url) {
                if (url.match(/simkl\.com\/(anime|manga)\/\d*/i)) {
                    if (this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", this.ids.simkl = parseInt(utils.urlPart(url, 4)), 
                    "manga" === this.type) throw "Simkl has no manga support";
                } else {
                    if (!url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.UrlNotSuported, "Url not supported");
                    if (this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", this.ids.mal = Number(utils.urlPart(url, 4)), 
                    "manga" === this.type) throw "Simkl has no manga support";
                }
            }
            getCacheKey() {
                return _helper__WEBPACK_IMPORTED_MODULE_1__.d(this.ids.mal, this.ids.simkl);
            }
            _getStatus() {
                return parseInt(_helper__WEBPACK_IMPORTED_MODULE_1__.h(this.animeInfo.status));
            }
            _setStatus(status) {
                23 === status && (status = 1), (status = _helper__WEBPACK_IMPORTED_MODULE_1__.h(status, parseInt(status.toString()))) !== this.animeInfo.status && (this.statusUpdate = !0), 
                this.animeInfo.status = status;
            }
            _getScore() {
                const score = this.animeInfo.user_rating;
                return null === score ? 0 : score;
            }
            _setScore(score) {
                0 === score && (score = null), score !== this.animeInfo.user_rating && (this.ratingUpdate = !0), 
                this.animeInfo.user_rating = score;
            }
            _getEpisode() {
                return 2 === this._getStatus() ? this._getTotalEpisodes() : this.curWatchedEp;
            }
            _setEpisode(episode) {
                episode !== this.curWatchedEp && (this.episodeUpdate = !0), this.curWatchedEp = episode;
            }
            _getVolume() {
                return 0;
            }
            _setVolume(volume) {
                this.logger.error("You cant set Volumes for animes");
            }
            _getTags() {
                let tags = this.animeInfo.private_memo;
                return null !== tags && "null" !== tags || (tags = ""), tags;
            }
            _setTags(tags) {
                this.animeInfo.private_memo = tags;
            }
            _getTitle() {
                return this.animeInfo.show.title;
            }
            _getTotalEpisodes() {
                const eps = this.animeInfo.total_episodes_count;
                return null === eps ? 0 : eps;
            }
            _getTotalVolumes() {
                return 0;
            }
            _getDisplayUrl() {
                return `https://simkl.com/${this.getType()}/${this.ids.simkl}`;
            }
            _getImage() {
                return Promise.resolve(`https://simkl.in/posters/${this.animeInfo.show.poster}_ca.jpg`);
            }
            _getRating() {
                return __awaiter(this, void 0, void 0, (function*() {
                    try {
                        return (yield this.call("https://api.simkl.com/ratings", {
                            simkl: this.ids.simkl
                        }, !0)).simkl.rating;
                    } catch (e) {
                        return this.logger.error(e), "N/A";
                    }
                }));
            }
            _update() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let de;
                    return de = Number.isNaN(this.ids.mal) ? {
                        simkl: this.ids.simkl
                    } : {
                        mal: this.ids.mal
                    }, this._authenticated = !0, this.getSingle(de).catch(e => {
                        if (e.code === _definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated) return this._authenticated = !1, 
                        "";
                        throw e;
                    }).then(res => __awaiter(this, void 0, void 0, (function*() {
                        if (this.logger.log(res), this.episodeUpdate = !1, this.statusUpdate = !1, this.ratingUpdate = !1, 
                        this.animeInfo = res, this._onList = !0, !this.animeInfo) {
                            let el;
                            if (this._onList = !1, de.simkl) {
                                if (el = yield this.call("https://api.simkl.com/anime/" + de.simkl, {
                                    extended: "full"
                                }, !0), !el) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.EntryNotFound, "Anime not found");
                            } else {
                                if (el = yield this.call("https://api.simkl.com/search/id", de, !0), !el) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.EntryNotFound, "Anime not found");
                                if (el[0].mal && el[0].mal.type && "Special" === el[0].mal.type) throw {
                                    code: 415,
                                    message: "Is a special"
                                };
                                el = el[0];
                            }
                            this.animeInfo = {
                                last_watched: "",
                                last_watched_at: "",
                                next_to_watch: "",
                                not_aired_episodes_count: 0,
                                private_memo: "",
                                status: "plantowatch",
                                total_episodes_count: 0,
                                user_rating: null,
                                watched_episodes_count: 0,
                                show: el
                            }, this.logger.log("Add anime", this.animeInfo);
                        }
                        if (Number.isNaN(this.ids.simkl) && (this.ids.simkl = parseInt(this.animeInfo.show.ids.simkl)), 
                        Number.isNaN(this.ids.mal) && void 0 !== this.animeInfo.show.ids.mal && (this.ids.mal = this.animeInfo.show.ids.mal), 
                        this.curWatchedEp = _helper__WEBPACK_IMPORTED_MODULE_1__.e(this.animeInfo.last_watched), 
                        !this.curWatchedEp && this.animeInfo.next_to_watch) {
                            const next = _helper__WEBPACK_IMPORTED_MODULE_1__.e(this.animeInfo.next_to_watch);
                            next && (this.curWatchedEp = next - 1);
                        }
                        if (this.minWatchedEp = this.curWatchedEp + 1, !this._authenticated) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_2__.a.NotAutenticated, "Not Authenticated");
                    })));
                }));
            }
            _sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.logger.log("[SET] Object:", this.animeInfo, "status", this.statusUpdate, "episode", this.episodeUpdate, "rating", this.ratingUpdate, "minWatchedEp", this.minWatchedEp, "curWatchedEp", this.curWatchedEp), 
                    this.statusUpdate || !this.isOnList()) {
                        const response = yield this.call("https://api.simkl.com/sync/add-to-list", JSON.stringify({
                            shows: [ {
                                to: this.animeInfo.status,
                                ids: {
                                    simkl: this.ids.simkl
                                }
                            } ]
                        }), !1, "POST");
                        this.logger.log("Status response", response);
                    }
                    if (this.episodeUpdate || !this.isOnList()) {
                        const curEp = this.curWatchedEp, episodes = [];
                        if (this.minWatchedEp <= curEp) {
                            if (curEp) {
                                for (let i = this.minWatchedEp; i <= curEp; i++) episodes.push({
                                    number: i
                                });
                                const response = yield this.call("https://api.simkl.com/sync/history", JSON.stringify({
                                    shows: [ {
                                        ids: {
                                            simkl: this.ids.simkl
                                        },
                                        private_memo: this.animeInfo.private_memo,
                                        seasons: [ {
                                            number: 1,
                                            episodes: episodes
                                        } ]
                                    } ]
                                }), !1, "POST");
                                this.logger.log("Episode response", response);
                            }
                        } else {
                            for (let i = this.minWatchedEp - 1; i > curEp; i -= 1) episodes.push({
                                number: i
                            });
                            const response = yield this.call("https://api.simkl.com/sync/history/remove", JSON.stringify({
                                shows: [ {
                                    ids: {
                                        simkl: this.ids.simkl
                                    },
                                    seasons: [ {
                                        number: 1,
                                        episodes: episodes
                                    } ]
                                } ]
                            }), !1, "POST");
                            this.logger.log("Episode remove response", response);
                        }
                        this.minWatchedEp = curEp + 1;
                    }
                    if (this.ratingUpdate) if (this.animeInfo.user_rating) {
                        const response = yield this.call("https://api.simkl.com/sync/ratings", JSON.stringify({
                            shows: [ {
                                rating: this.animeInfo.user_rating,
                                ids: {
                                    simkl: this.ids.simkl
                                }
                            } ]
                        }), !1, "POST");
                        this.logger.log("Rating response", response);
                    } else {
                        const response = yield this.call("https://api.simkl.com/sync/ratings/remove", JSON.stringify({
                            shows: [ {
                                ids: {
                                    simkl: this.ids.simkl
                                }
                            } ]
                        }), !1, "POST");
                        this.logger.log("Rating remove response", response);
                    }
                    this.episodeUpdate = !1, this.statusUpdate = !1, this.ratingUpdate = !1;
                }));
            }
            jsonParse(response) {
                if ("" === response.responseText) throw {
                    code: 444,
                    message: "No Response"
                };
                try {
                    return JSON.parse(response.responseText);
                } catch (e) {
                    throw {
                        code: 406,
                        message: "Not Acceptable",
                        error: e
                    };
                }
            }
            delete() {
                return this.call("https://api.simkl.com/sync/history/remove", JSON.stringify({
                    shows: [ {
                        ids: {
                            simkl: this.ids.simkl
                        }
                    } ]
                }), !1, "POST");
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return searchFactory_search;
    }));
    var helper = __webpack_require__(15), search = __webpack_require__(82);
    const search_search = search.a;
    var AniList_search = __webpack_require__(110), Kitsu_search = __webpack_require__(111), Simkl_search = __webpack_require__(112);
    function searchFactory_search(keyword, type, options = {}, sync = !1, syncMode = "") {
        return syncMode || (syncMode = helper.a(type)), "KITSU" === syncMode ? Object(Kitsu_search.a)(keyword, type, options, sync) : "ANILIST" === syncMode ? Object(AniList_search.a)(keyword, type, options, sync) : "SIMKL" === syncMode ? Object(Simkl_search.a)(keyword, type, options, sync) : "MALAPI" === syncMode ? Object(search.a)(keyword, type, options, sync) : search_search(keyword, type, options, sync);
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, j) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getPlayerTime;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return fullscreenNotification;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let inter;
        const logger = con.m("Player");
        function getPlayerTime(callback) {
            clearInterval(inter), inter = setInterval((function() {
                const players = document.getElementsByTagName("video");
                for (let i = 0; i < players.length; i++) {
                    const player = players[i], {duration: duration} = player, current = player.currentTime, {paused: paused} = player;
                    if (duration && duration > 60) {
                        const item = {
                            current: current,
                            duration: duration,
                            paused: paused
                        };
                        logger.debug(window.location.href, item), callback(item, player), playerExtras(item, player);
                        break;
                    }
                }
            }), 1e3);
        }
        let videoIdentifier = "";
        function playerExtras(item, player) {
            const tempVideoIdentifier = player.currentSrc;
            item.current > 1 && videoIdentifier !== tempVideoIdentifier && (videoIdentifier = tempVideoIdentifier, 
            logger.log("New player detected", player.currentSrc), function(player) {
                __awaiter(this, void 0, void 0, (function*() {
                    if (yield api.settings.getAsync("autofull")) if (window.fullScreen || window.innerWidth === window.screen.width && window.innerHeight === window.screen.height) con.info("Browser already in fullscreen"); else {
                        let playerEl = player;
                        const ids = [ "player", "vstr", "vplayer", "mgvideo", "myVideo", "b-video-wrapper", "vilos" ], classes = [ "AT-player", "plyr", "AkiraPlayer", "video-js" ];
                        let found = !1;
                        for (const i in ids) {
                            const playerTemp = document.getElementById(ids[i]);
                            if (null !== playerTemp) {
                                found = !0, playerEl = playerTemp;
                                break;
                            }
                        }
                        for (const i in classes) {
                            const classTemp = document.getElementsByClassName(classes[i]).item(0);
                            if (null !== classTemp) {
                                found = !0, playerEl = classTemp;
                                break;
                            }
                        }
                        if (!found) {
                            const vHeight = playerEl.offsetHeight, vWidth = playerEl.offsetWidth;
                            for (;playerEl.parentElement && vHeight === playerEl.parentElement.offsetHeight && vWidth === playerEl.parentElement.offsetWidth; ) playerEl = playerEl.parentElement, 
                            found = !0;
                        }
                        if (!found && !player.getAttribute("controls")) {
                            function exitHandler() {
                                (document.webkitIsFullScreen || document.mozFullScreen || null !== document.msFullscreenElement) && player.removeAttribute("controls", "controls");
                            }
                            document.addEventListener && (document.addEventListener("fullscreenchange", exitHandler, !1), 
                            document.addEventListener("mozfullscreenchange", exitHandler, !1), document.addEventListener("MSFullscreenChange", exitHandler, !1), 
                            document.addEventListener("webkitfullscreenchange", exitHandler, !1)), player.setAttribute("controls", "controls");
                        }
                        playerEl.requestFullscreen ? playerEl.requestFullscreen() : playerEl.msRequestFullscreen ? playerEl.msRequestFullscreen() : playerEl.mozRequestFullScreen ? playerEl.mozRequestFullScreen() : playerEl.webkitRequestFullscreen && playerEl.webkitRequestFullscreen();
                    }
                }));
            }(player));
        }
        function fullscreenNotification(text) {
            if (api.settings.get("floatButtonStealth")) return;
            const fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            if (fullscreenElement) {
                const flashmEl = j.$(j.html(`\n        <div style="\n          all: initial;\n          position: absolute;\n          bottom: 0;\n          left: 0;\n          right: 0;\n          color: white;\n          display: none;\n          z-index: 20000;\n        ">\n          <div style="\n            background: rgba(50, 50, 50, 0.6);\n            color: white;\n            padding: 10px 15px 10px;\n            margin-left: auto;\n            margin-right: auto;\n            max-width: 60%;\n            display: table;\n            font-family: Helvetica,Arial,sans-serif;\n            text-align: center;\n          ">${text}</div>\n        </div>\n        `)).appendTo(j.$(fullscreenElement));
                flashmEl.slideDown(400).delay(2e3).slideUp(400, () => {
                    flashmEl.remove();
                });
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils) {
        var _components_search_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(262), _components_inputButton_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(263), _components_entry_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(264), _components_rules_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(265);
        __webpack_exports__.a = {
            components: {
                entry: _components_entry_vue__WEBPACK_IMPORTED_MODULE_2__.a,
                inputButton: _components_inputButton_vue__WEBPACK_IMPORTED_MODULE_1__.a,
                search: _components_search_vue__WEBPACK_IMPORTED_MODULE_0__.a,
                rules: _components_rules_vue__WEBPACK_IMPORTED_MODULE_3__.a
            },
            data: () => ({
                inputOffset: 0,
                minimized: !1
            }),
            computed: {
                searchClass() {
                    return this.$parent.searchClass;
                },
                syncPage() {
                    return this.$parent.searchClass.getSyncPage();
                },
                rulesClass() {
                    return this.searchClass.rules;
                },
                currentStateEp() {
                    if (this.syncPage && this.syncPage.curState && this.syncPage.curState.episode) return this.syncPage.curState.episode;
                },
                syncMode() {
                    return this.$parent.syncMode;
                },
                offset() {
                    return this.searchClass.getOffset();
                }
            },
            created() {
                this.minimized = api.settings.get("minimizeBigPopup");
            },
            methods: {
                lang: api.storage.lang,
                setPage(url, id = 0) {
                    this.searchClass.setUrl(url, id), utils.flashm(api.storage.lang("correction_NewUrl", [ url ]), !1), 
                    this.close();
                },
                setOffset(offset) {
                    this.searchClass.setOffset(offset);
                },
                close() {
                    this.$root.$destroy();
                },
                calcEpOffset(ep) {
                    return parseInt(ep) - parseInt(this.inputOffset);
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        var _searchFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
        let searchTimeout;
        __webpack_exports__.a = {
            components: {},
            props: {
                type: {
                    type: String,
                    default: "anime"
                },
                keyword: {
                    type: String,
                    default: ""
                },
                syncMode: {
                    type: Boolean,
                    default: !1
                },
                currentId: {
                    type: Number,
                    default: 0
                }
            },
            data: () => ({
                items: [],
                loading: !1,
                searchKeyword: ""
            }),
            watch: {
                keyword() {
                    this.searchKeyword = this.keyword, this.load();
                },
                searchKeyword() {
                    clearTimeout(searchTimeout), searchTimeout = setTimeout(() => {
                        this.load();
                    }, 200);
                },
                type() {
                    this.load();
                }
            },
            mounted() {
                this.syncMode && (this.searchKeyword = this.keyword, this.load());
            },
            methods: {
                lang: api.storage.lang,
                load() {
                    this.searchKeyword && (this.loading = !0, Object(_searchFactory__WEBPACK_IMPORTED_MODULE_0__.a)(this.searchKeyword, this.type).then(items => {
                        this.loading = !1, this.items = items, this.$nextTick(() => {
                            this.$el.scrollIntoView({
                                behavior: "smooth"
                            });
                        });
                    }));
                },
                inputFocus() {
                    this.searchKeyword || (this.searchKeyword = this.keyword);
                },
                async clickItem(e, item) {
                    if (e.preventDefault(), !item) return void this.$emit("clicked", {
                        url: "",
                        id: 0
                    });
                    const url = await item.malUrl();
                    url ? this.$emit("clicked", {
                        url: url,
                        id: item.id
                    }) : this.$emit("clicked", {
                        url: item.url,
                        id: item.id
                    });
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            props: {
                state: {
                    type: [ String, Number ],
                    default: ""
                },
                type: {
                    type: String,
                    default: ""
                },
                label: {
                    type: String,
                    default: ""
                }
            },
            data: () => ({
                inputString: ""
            }),
            watch: {
                state() {
                    this.inputString = this.state;
                },
                inputString() {
                    this.$emit("change", this.inputString);
                }
            },
            mounted() {
                this.inputString = this.state;
            },
            methods: {
                lang: api.storage.lang,
                click() {
                    this.$emit("clicked", this.inputString);
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils) {
        __webpack_exports__.a = {
            props: {
                obj: {
                    type: Object,
                    default: void 0
                }
            },
            data: () => ({
                image: ""
            }),
            computed: {
                status: {
                    get() {
                        return this.obj && this.obj.isAuthenticated() ? this.obj.getStatus() : null;
                    },
                    set(value) {
                        this.obj && this.obj.isAuthenticated() && this.obj.setStatus(value);
                    }
                },
                episode: {
                    get() {
                        return this.obj && this.obj.isAuthenticated() && this.obj.isOnList() ? this.obj.getEpisode() : null;
                    },
                    set(value) {
                        this.obj && this.obj.isAuthenticated() && this.obj.setEpisode(value);
                    }
                },
                volume: {
                    get() {
                        return this.obj && this.obj.isAuthenticated() && this.obj.isOnList() ? this.obj.getVolume() : null;
                    },
                    set(value) {
                        this.obj && this.obj.isAuthenticated() && this.obj.setVolume(value);
                    }
                },
                score: {
                    get() {
                        return this.obj && this.obj.isAuthenticated() ? this.obj.getDisplayScoreCheckbox() : null;
                    },
                    set(value) {
                        this.obj && this.obj.isAuthenticated() && this.obj.setScore(value);
                    }
                }
            },
            watch: {
                obj: {
                    deep: !0,
                    immediate: !0,
                    handler(val, oldVal) {
                        if (val && (!oldVal || oldVal.getUrl() !== val.getUrl())) {
                            const tempUrl = val.getUrl();
                            val.getImage().then(img => {
                                this.obj && this.obj.getUrl() === tempUrl && (this.image = img);
                            });
                        }
                    }
                }
            },
            methods: {
                lang: api.storage.lang,
                utilsepisode: utils.episode,
                statusText(state) {
                    switch (state) {
                      case 1:
                        return api.storage.lang("UI_Status_watching_" + this.obj.getType());

                      case 2:
                        return api.storage.lang("UI_Status_Completed");

                      case 3:
                        return api.storage.lang("UI_Status_OnHold");

                      case 4:
                        return api.storage.lang("UI_Status_Dropped");

                      case 6:
                        return api.storage.lang("UI_Status_planTo_" + this.obj.getType());

                      case 23:
                        return api.storage.lang("UI_Status_Rewatching_" + this.obj.getType());

                      default:
                        return "";
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            props: {
                obj: {
                    type: Object,
                    default: void 0
                }
            },
            data: () => ({}),
            computed: {
                rules() {
                    return this.obj && this.obj.getRules() ? this.obj.getRules().sort((a, b) => a.from.start - b.from.start) : [];
                }
            },
            methods: {
                lang: api.storage.lang,
                activeRule(rule) {
                    return {
                        active: !!this.obj && rule === this.obj.activeRule
                    };
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils, con) {
        var _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
        __webpack_exports__.a = {
            data: () => ({
                streamUrl: void 0,
                continueUrl: null,
                resumeUrl: null,
                links: null,
                pageSearch: null,
                pageRelation: null,
                classes: {
                    minimized: !0,
                    search: !1
                }
            }),
            watch: {
                streamUrl(url) {
                    url && (this.classes.minimized = !0, this.classes.search = !1);
                }
            },
            created() {
                const classes = JSON.parse(localStorage.getItem("SIMKL-MAL-SYNC"));
                classes && (this.classes = classes);
            },
            methods: {
                lang: api.storage.lang,
                favicon: utils.favicon,
                assetUrl: api.storage.assetUrl,
                getMal2KissFavicon(url) {
                    try {
                        return utils.favicon(url);
                    } catch (e) {
                        return con.error(e), "";
                    }
                },
                toggleSearch() {
                    this.classes.search = !this.classes.search, this.saveClasses();
                },
                pressMinimized() {
                    null === this.links || Object.keys(this.links).length ? this.toggleMinimized() : this.toggleSearch(), 
                    this.saveClasses();
                },
                toggleMinimized() {
                    this.classes.minimized = !this.classes.minimized, this.classes.search && this.classes.minimized && this.toggleSearch(), 
                    this.saveClasses();
                },
                removeSource(key) {
                    Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_0__.c)(String(key.name)), 
                    window.location.reload();
                },
                saveClasses() {
                    localStorage.setItem("SIMKL-MAL-SYNC", JSON.stringify(this.classes));
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1), __webpack_require__(4));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(299);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils, j, con) {
        var _minimalApp_settings_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(266), _minimalApp_overview_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267), _minimalApp_recommendations_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(268), _minimalApp_bookmarks_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _minimalApp_search_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(270), _minimalApp_updateCheck_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(271), _minimalApp_listSync_listSync_vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(272), _minimalApp_cleanTags_cleanTags_vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(273), _minimalApp_allSites_vue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(274), _minimalApp_reviews_vue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(275), _minimalApp_customDomains_vue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(276), _minimalApp_components_quicklinksEdit_vue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(277), _provider_singleFactory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(18), _provider_listFactory__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(16);
        let timer, ignoreCurrentTab = !0, ignoreNullBase = !1;
        const scrollHandler = {};
        let scrollHandlerArray = [];
        const randomListCache = {
            anime: [],
            manga: []
        }, popupStorage = {
            fetch: () => JSON.parse(localStorage.getItem("VUE-MAL-SYNC") || "[]"),
            save(state) {
                localStorage.setItem("VUE-MAL-SYNC", JSON.stringify(state));
            }
        };
        __webpack_exports__.a = {
            components: {
                overviewVue: _minimalApp_overview_vue__WEBPACK_IMPORTED_MODULE_1__.a,
                recommendationsVue: _minimalApp_recommendations_vue__WEBPACK_IMPORTED_MODULE_2__.a,
                reviewsVue: _minimalApp_reviews_vue__WEBPACK_IMPORTED_MODULE_9__.a,
                bookmarksVue: _minimalApp_bookmarks_vue__WEBPACK_IMPORTED_MODULE_3__.a,
                searchVue: _minimalApp_search_vue__WEBPACK_IMPORTED_MODULE_4__.a,
                updateCheckVue: _minimalApp_updateCheck_vue__WEBPACK_IMPORTED_MODULE_5__.a,
                listSyncVue: _minimalApp_listSync_listSync_vue__WEBPACK_IMPORTED_MODULE_6__.a,
                cleanTagsVue: _minimalApp_cleanTags_cleanTags_vue__WEBPACK_IMPORTED_MODULE_7__.a,
                allSitesVue: _minimalApp_allSites_vue__WEBPACK_IMPORTED_MODULE_8__.a,
                customDomainsVue: _minimalApp_customDomains_vue__WEBPACK_IMPORTED_MODULE_10__.a,
                quicklinksEdit: _minimalApp_components_quicklinksEdit_vue__WEBPACK_IMPORTED_MODULE_11__.a,
                settingsVue: _minimalApp_settings_vue__WEBPACK_IMPORTED_MODULE_0__.a
            },
            data: () => ({
                tabs: {
                    overview: {
                        title: "overview",
                        scroll: 0
                    },
                    reviews: {
                        title: "reviews",
                        scroll: 0
                    },
                    recommendations: {
                        title: "recommendations",
                        scroll: 0
                    },
                    settings: {
                        title: "settings",
                        scroll: 0
                    },
                    bookmarks: {
                        title: "bookmarks",
                        scroll: 0,
                        state: 1,
                        type: "anime",
                        sort: null,
                        supportsRewatch: !1
                    },
                    search: {
                        title: "search",
                        scroll: 0,
                        type: "anime",
                        keyword: ""
                    },
                    updateCheck: {
                        title: "updateCheck",
                        scroll: 0
                    },
                    listSync: {
                        title: "listSync",
                        scroll: 0,
                        type: "anime"
                    },
                    cleanTags: {
                        title: "cleanTags",
                        scroll: 0
                    },
                    allSites: {
                        title: "allSites",
                        scroll: 0
                    },
                    customDomains: {
                        title: "customDomains",
                        scroll: 0
                    },
                    quicklinks: {
                        title: "quicklinks",
                        scroll: 0
                    }
                },
                keyword: "",
                currentTab: "settings",
                renderUrl: "",
                renderObj: null,
                history: [],
                baseFallback: "",
                page: null,
                options: api.settings.options
            }),
            computed: {
                base() {
                    return this.page ? this.page.singleObj ? this.page.singleObj.getUrl() : (this.renderUrl = "", 
                    "") : this.baseFallback;
                },
                renderMalUrl() {
                    return null !== this.renderObj ? this.renderObj.getMalUrl() : null;
                },
                showReviewAndRecom() {
                    return null !== this.renderMalUrl || null === this.renderObj;
                },
                utils: () => utils,
                backbutton() {
                    return this.history.length > 0;
                },
                backbuttonSearchStyle() {
                    return this.backbutton ? {
                        "margin-left": "-17px"
                    } : {
                        "margin-left": "-57px"
                    };
                },
                backbuttonBookStyle() {
                    return this.backbutton ? {
                        left: "40px"
                    } : {
                        left: "0px"
                    };
                },
                popOver() {
                    return this.currentTab === this.tabs.bookmarks.title || (this.currentTab === this.tabs.search.title || (this.currentTab === this.tabs.updateCheck.title || (this.currentTab === this.tabs.listSync.title || (this.currentTab === this.tabs.cleanTags.title || (this.currentTab === this.tabs.allSites.title || (this.currentTab === this.tabs.customDomains.title || this.currentTab === this.tabs.quicklinks.title))))));
                },
                navigation() {
                    return !this.popOver && !this.onlySettings;
                },
                onlySettings() {
                    return "" === this.renderUrl;
                },
                listView: {
                    get: () => api.settings.get("bookMarksList"),
                    set(value) {
                        api.settings.set("bookMarksList", value);
                    }
                },
                bookIcon() {
                    j.$(this.$el);
                    return "bookmarks" === this.currentTab ? this.onlySettings ? "settings" : "collections_bookmark" : "book";
                }
            },
            watch: {
                renderUrl(url) {
                    this.renderObj = null;
                    const tempRenderObj = Object(_provider_singleFactory__WEBPACK_IMPORTED_MODULE_12__.b)(url);
                    tempRenderObj.update().then(() => {
                        this.renderObj = tempRenderObj, this.tabs.search.type = this.renderObj.getType(), 
                        this.renderObj.initProgress();
                    }).catch(e => {
                        throw this.renderObj = tempRenderObj, this.renderObj.flashmError(e), e;
                    });
                },
                currentTab(tab, oldtab) {
                    this.tabs[oldtab].scroll = this.getScroll(), this.$nextTick(() => {
                        this.setScroll(this.tabs[tab].scroll);
                    }), ignoreCurrentTab ? ignoreCurrentTab = !1 : (this.currentTab === this.tabs.bookmarks.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.search.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.updateCheck.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.listSync.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.cleanTags.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.allSites.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.customDomains.title && this.history.push(this.getCurrent(oldtab)), 
                    this.currentTab === this.tabs.quicklinks.title && this.history.push(this.getCurrent(oldtab)));
                },
                keyword(keyword) {
                    "" !== keyword ? this.selectTab("search") : this.selectTab("overview");
                },
                base(base, oldBase) {
                    if (base !== oldBase) {
                        for (;this.history.length > 0; ) this.history.pop();
                        this.fill(base, !0);
                    }
                }
            },
            mounted() {
                if (this.isPopup()) {
                    const state = popupStorage.fetch();
                    void 0 !== state && void 0 !== state.currentTab && (ignoreNullBase = !0, this.setCurrent(state));
                }
                j.$(this.$el).find(".mdl-layout__content").first().scroll(() => {
                    if (scrollHandlerArray.length) {
                        const pos = {
                            pos: this.getScroll(),
                            elHeight: j.$(this.$el).find(".mdl-layout__content").first().height(),
                            height: j.$(this.$el).find(".mdl-layout__content > .is-active").first().height()
                        };
                        for (const i in scrollHandlerArray) scrollHandlerArray[i](pos);
                    }
                });
            },
            updated() {
                this.isPopup() && popupStorage.save(this.getCurrent(this.currentTab));
            },
            methods: {
                lang: api.storage.lang,
                getTheme: options => "auto" === options.theme ? !window.matchMedia || window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : options.theme,
                selectTab(_selectedTab) {
                    let selectedTab = _selectedTab;
                    !this.onlySettings || "overview" !== selectedTab && "reviews" !== selectedTab && "recommendations" !== selectedTab || (selectedTab = "settings"), 
                    con.log("Tab Changed", selectedTab), this.currentTab = selectedTab;
                },
                registerScroll(key, fn) {
                    scrollHandler[key] = fn, scrollHandlerArray = Object.values(scrollHandler);
                },
                unregisterScroll(key) {
                    delete scrollHandler[key], scrollHandlerArray = Object.values(scrollHandler);
                },
                getScroll() {
                    return j.$(this.$el).find(".mdl-layout__content").first().scrollTop();
                },
                setScroll(scroll) {
                    return j.$(this.$el).find(".mdl-layout__content").first().scrollTop(scroll);
                },
                isPopup: () => !!j.$("#Mal-Sync-Popup").length,
                fill(url, isBase = !1) {
                    con.log("fill", url);
                    j.$(this.$el);
                    return null === url ? (this.isPopup() && this.selectTab("bookmarks"), !1) : /^https:\/\/myanimelist.net\/(anime|manga)\/\d+/i.test(url) || /^https:\/\/kitsu.io\/(anime|manga)\/.+/i.test(url) || /^https:\/\/anilist.co\/(anime|manga)\/\d+/i.test(url) || /^https:\/\/simkl.com\/(anime|manga)\/\d+/i.test(url) || /^local:\/\//i.test(url) ? (isBase || (this.tabs[this.currentTab].scroll = this.getScroll(), 
                    this.history.push(this.getCurrent(this.currentTab))), this.renderUrl = url, this.currentTab = "overview", 
                    !0) : (this.isPopup() && this.selectTab("bookmarks"), !1);
                },
                urlClick(_url) {
                    let url = _url;
                    if (/^local:\/\//i.test(url) || (url = utils.absoluteLink(url, "https://myanimelist.net")), 
                    !this.fill(url)) {
                        const win = window.open(url, "_blank");
                        win ? win.focus() : alert(api.storage.lang("minimalClass_Popup"));
                    }
                },
                fillBase(url) {
                    con.log("Fill Base", url, this.history), ignoreNullBase && null === url || (this.baseFallback = url), 
                    "" === url && (this.renderUrl = url);
                },
                setPage(page) {
                    this.page = page, void 0 === this.page.singleObj && this.$set(this.page, "singleObj", void 0);
                },
                backbuttonClick() {
                    con.log("History", this.history), this.history.length > 0 && this.setCurrent(this.history.pop());
                },
                bookClick() {
                    j.$(this.$el);
                    "book" !== this.bookIcon ? this.selectTab("overview") : (this.renderObj && (this.tabs.bookmarks.type = this.renderObj.getType()), 
                    this.selectTab("bookmarks"));
                },
                keywordSet() {
                    clearTimeout(timer), timer = setTimeout(() => {
                        this.tabs.search.keyword = this.keyword;
                    }, 300);
                },
                getCurrent(tab, url = this.renderUrl) {
                    return {
                        renderUrl: url,
                        currentTab: tab,
                        tabData: j.$.extend(!0, {}, this.tabs[tab])
                    };
                },
                setCurrent(historyElement) {
                    con.log("Set Current", historyElement), void 0 !== historyElement.tabData.keyword && (this.keyword = historyElement.tabData.keyword), 
                    this.tabs[historyElement.currentTab] = historyElement.tabData, this.renderUrl = historyElement.renderUrl, 
                    this.currentTab !== historyElement.currentTab && (ignoreCurrentTab = !0), this.currentTab = historyElement.currentTab;
                },
                rebuildListSync() {
                    this.currentTab = "", this.$nextTick(() => {
                        this.currentTab = "listSync";
                    });
                },
                searchClick(item) {
                    this.urlClick(item.url);
                },
                openLink(url) {
                    const link = document.createElement("a");
                    link.href = url, document.getElementById("malList").appendChild(link), link.click();
                },
                async openRandom(status, type) {
                    if (!randomListCache[type].length) {
                        utils.flashm("Loading");
                        const listProvider = await Object(_provider_listFactory__WEBPACK_IMPORTED_MODULE_13__.a)(status, type);
                        await listProvider.getCompleteList().then(async list => {
                            randomListCache[type] = list;
                        }).catch(e => {
                            con.error(e);
                        });
                    }
                    randomListCache[type].length > 1 ? this.openLink(randomListCache[type][Math.floor(Math.random() * randomListCache[type].length)].url) : utils.flashm("List is too small!");
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, j, utils) {
        var _components_settingsCheckbox_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(278), _components_settingsNumberInput_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(279), _components_settingsDropdown_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(280), _components_settingsFileUpload_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(281), _components_settingsShortcut_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(282), _components_settingsLogin_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(283), _components_tooltip_vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85), _correction_vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(284), _components_quicklinksOverview_vue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(285), _provider_Local_import__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(93), _background_releaseProgress__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);
        __webpack_exports__.a = {
            components: {
                correction: _correction_vue__WEBPACK_IMPORTED_MODULE_7__.a,
                tooltip: _components_tooltip_vue__WEBPACK_IMPORTED_MODULE_6__.a,
                checkbox: _components_settingsCheckbox_vue__WEBPACK_IMPORTED_MODULE_0__.a,
                numberInput: _components_settingsNumberInput_vue__WEBPACK_IMPORTED_MODULE_1__.a,
                dropdown: _components_settingsDropdown_vue__WEBPACK_IMPORTED_MODULE_2__.a,
                fileUpload: _components_settingsFileUpload_vue__WEBPACK_IMPORTED_MODULE_3__.a,
                shortcut: _components_settingsShortcut_vue__WEBPACK_IMPORTED_MODULE_4__.a,
                login: _components_settingsLogin_vue__WEBPACK_IMPORTED_MODULE_5__.a,
                quicklinksOverview: _components_quicklinksOverview_vue__WEBPACK_IMPORTED_MODULE_8__.a
            },
            props: {
                page: {
                    type: Object,
                    default: null
                }
            },
            data: () => ({
                contributer: [],
                isOpen: !1,
                options: api.settings.options,
                commands: null,
                progressAnimeDropdown: [],
                progressMangaDropdown: [],
                version: {
                    link: "https://malsync.moe/changelog#" + api.storage.version(),
                    img: `https://img.shields.io/badge/Changelog-${api.storage.version()}-green.svg?style=flat-square&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAtxQTFRFAAAARj1Hw158LyQzRDRBVF54Ew0ZXqvnIx4labLsQEFTdsD7ZpPC////VE1SNCg3Nik7PS1CSzBKWjRXczBXjjBUsTZd0WuILSUyMiU2MiI2Nyc9dypNoClRbC5INTQ+YXKMMCQ7PyQ/WitFKx4vFxchT16CRStIPSY6TSQ6jjhScb33TViCpCROni9VYKzqTlN+qDBZXK3sYi5JXbHyQzNGXLLzTTZOW6/wQC5EX67sNSw7Y67qWa3vLCUzMCo1uc3fXq3rWa/yLCgxSEdKZa7nV6rrWrDyKCEsMzA1aLDpYbLyYbj6SUJgPj5VLy87e8D6csP+c8r/d9L/fNT+esnydLbgcKfOa5vDdJ/MQi5GSjFLTTFOYi9PWS1NUS9OTTFPRzFLSDJMTTBMXjBPaS5NZzBVgTdjczVfbjVhXjVaTjRTQzJMSzRNTzVOTzNLai1ShzJcjjNdiDNeejRhbDVhWzZbSzRRQzFKQjJKUDNMiyxPYy9UlzBfyDBlpjJgcjJbajNfXDVaTDNRPzBHPTBHVDJNrDBZxSpaV1aBajBZkDNipzNjnTNjdDJdYzJcXDRZTzRQPzFHRzJHZTJNcS9MZ2WUcS9VcDNdezRgcjJeezNgZTNaTjNRRDFLQzJJQjNHQjJGWDJLUjJKYoK4cS5NWTFTWzRaWDJVbjRbWDNVSzNQRjJMUTRLSTVHSzRJjjZbfDdZYqXlhEZwVS5MSzRUVTNUczVbTjJRSTNOUDRMSTNLQTJISTNGczZUXjVRWrH0W3+1Ri9OSDJSSzNSTDNTRzJRRzNRSTNNQzJLPzFKPjJGPjFCOSw/W67vTWOORi5NSjJRSzNVTDRURTJRQTBNQTFKQzJKPjFINSw9XKrpSVyIQCxLRS9QRjJSQjJPRzRQUTROQjBFLyc1W6rrS22ePTRVQSxLSjNVSzZYTzZWUTJPOSw+Z778YqPWWnGcV1F/UkZxT0Nm////ch6M6QAAAFp0Uk5TAAAAAAAAAAAAAAAAAAABKH2/3+bIjTgFCm7a/f7nhRILifn9nRJx+v6JBC3b6UV//aPB3OTz5/bL3Y6oNuLuTAGA/ZsIEp79shwRhervmxwFQqDd+frjqksImWc25wAAAAFiS0dEDfa0YfUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEbSURBVBjTARAB7/4AAAABDg8QERITFBUWFwIAAAAAAxgZGhtaW1xdHB0eHwQAAAUgISJeX2BhYmNkZSMkJQYAACYnZmdoaWprbG1ubygpKgArLHBxcnN0dXZ3eHl6ey0uAC8wfH1+f4CBgoOEhYaHiDEAMomKi4yNjo+QkZKSk5SVMwA0lpeYmZqbnJ2en6ChoqM1ADakpaanqKmqq6ytrq+wsTcAOLKztLW2t7i5uru8vb6/OQA6wMHCw8TFxsfIycrLzM07ADw9zs/Q0dLT1NXW19jZPj8AQEFC2tvc3d7U3+Dh4uNDRAAHRUZH5OXm5+jp6uvsSEkIAAAJSktM7e7v8PHyTU5PCgAAAAALUFFSU1RVVldYWQwNAEGXdELuOiRkAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE4LTA1LTE2VDEzOjM2OjI0KzAwOjAwK9TuQgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOC0wNS0xNlQxMzozNjoyNCswMDowMFqJVv4AAABGdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuNy44LTkgMjAxNC0wNS0xMiBRMTYgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmfchu0AAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OmhlaWdodAAxOTIPAHKFAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADE5MtOsIQgAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTUyNjQ3Nzc4NGTqj8oAAAAPdEVYdFRodW1iOjpTaXplADBCQpSiPuwAAABWdEVYdFRodW1iOjpVUkkAZmlsZTovLy9tbnRsb2cvZmF2aWNvbnMvMjAxOC0wNS0xNi82ODRlZmQxYzBmMTdmMzAxMjIzMWFmNzQ4YzhmYjJjYy5pY28ucG5nP6GaiQAAAABJRU5ErkJggg==`
                },
                legacy: !1
            }),
            mounted() {
                Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_10__.a)("anime").then(re => this.progressAnimeDropdown = re), 
                Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_10__.a)("manga").then(re => this.progressMangaDropdown = re), 
                api.request.xhr("GET", "https://api.malsync.moe/static/contributor").then(response => {
                    try {
                        this.contributer = JSON.parse(response.responseText);
                    } catch (e) {
                        return void con.error("Contributer Could not be retieved", e);
                    }
                    con.log("Contributer", this.contributer);
                }), "webextension" === api.type && j.$("#Mal-Sync-Popup").length && chrome.commands.getAll(commands => {
                    con.info("Commands", commands);
                    const tempCommands = commands.reduce((function(total, current) {
                        return total[current.name] = current, total;
                    }), {});
                    this.commands = tempCommands;
                });
            },
            methods: {
                lang: api.storage.lang,
                myOpen() {
                    this.isOpen = !this.isOpen;
                },
                isExtension: () => "webextension" === api.type,
                importFallbackSync(filecontent) {
                    con.log("Import FallbackSync", filecontent);
                    try {
                        const iData = JSON.parse(filecontent);
                        con.log("data", iData);
                        const firstData = iData[Object.keys(iData)[0]];
                        if (!firstData.hasOwnProperty("name")) throw "No name";
                        if (!firstData.hasOwnProperty("progress")) throw "No progress";
                        if (!firstData.hasOwnProperty("score")) throw "No score";
                        if (!firstData.hasOwnProperty("status")) throw "No status";
                        if (!firstData.hasOwnProperty("tags")) throw "No tags";
                        Object(_provider_Local_import__WEBPACK_IMPORTED_MODULE_9__.b)(iData).then(() => {
                            utils.flashm("File imported"), alert("File imported");
                        }).catch(e => {
                            throw e.message && alert(e.message), e;
                        });
                    } catch (e) {
                        alert("File has wrong formating"), con.error("File has wrong formating:", e);
                    }
                },
                async exportFallbackSync() {
                    const exportObj = await Object(_provider_Local_import__WEBPACK_IMPORTED_MODULE_9__.a)();
                    con.log("Export", exportObj);
                    const encodedUri = "data:text/csv;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj));
                    try {
                        const link = document.createElement("a");
                        link.setAttribute("href", encodedUri), link.setAttribute("download", `malsync_${(new Date).toJSON().slice(0, 10).replace(/-/g, "/")}.txt`), 
                        document.body.appendChild(link), link.click();
                    } catch (e) {
                        window.open(encodedUri);
                    }
                    utils.flashm("File exported");
                },
                startProgressSync() {
                    if (this.isExtension()) {
                        const inter = parseInt(api.settings.get("progressInterval"));
                        if (!inter) return;
                        con.log("Trigger Progress update"), chrome.alarms.create("progressSync", {
                            periodInMinutes: inter,
                            when: Date.now() + 1e3
                        });
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(2), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            props: {
                option: {
                    type: String
                }
            },
            computed: {
                value: {
                    get() {
                        return api.settings.get(this.option);
                    },
                    set(value) {
                        api.settings.set(this.option, value);
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            props: {
                option: {
                    type: String
                },
                min: {
                    type: Number,
                    default: 0
                },
                max: {
                    type: Number,
                    default: 999
                },
                step: {
                    type: Number,
                    default: 1
                }
            },
            computed: {
                value: {
                    get() {
                        return api.settings.get(this.option);
                    },
                    set(value) {
                        "" !== value && null !== value && value >= this.min && value <= this.max && (api.settings.set(this.option, value), 
                        this.$emit("changed", value));
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            props: {
                option: {
                    type: String
                },
                text: {
                    type: String
                }
            },
            computed: {
                value: {
                    get() {
                        return api.settings.get(this.option);
                    },
                    set(value) {
                        api.settings.set(this.option, value), this.$emit("changed", value);
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        __webpack_exports__.a = {
            data: () => ({
                button: !0
            }),
            methods: {
                type: () => api.type,
                buttonClick() {
                    this.button = !1;
                },
                handleFileUpload(event) {
                    if (con.log("File Found", event), !window.FileReader) return void alert("Browser is not compatible");
                    const reader = new FileReader;
                    reader.onload = evt => {
                        if (2 !== evt.target.readyState) return;
                        if (evt.target.error) return void alert("Error while reading file");
                        const filecontent = evt.target.result;
                        this.$emit("upload", filecontent);
                    }, reader.readAsText(event.target.files[0]);
                },
                openWindow(e) {
                    e.preventDefault(), e.stopPropagation();
                    const win = window.open(chrome.extension.getURL("window.html"), "_blank");
                    win ? win.focus() : alert(api.storage.lang("minimalClass_Popup"));
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(316);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con) {
        var _tooltip_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85), _keyboardMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
        let tempKeysTimeout;
        __webpack_exports__.a = {
            components: {
                tooltip: _tooltip_vue__WEBPACK_IMPORTED_MODULE_0__.a
            },
            props: {
                option: {
                    type: String
                }
            },
            data: () => ({
                keys: {},
                tempKeys: {}
            }),
            computed: {
                display() {
                    return this.tempRec ? Object.keys(this.tempKeys).map(val => _keyboardMap__WEBPACK_IMPORTED_MODULE_1__.a[val]).join(" + ") : this.rec ? Object.keys(this.keys).map(val => _keyboardMap__WEBPACK_IMPORTED_MODULE_1__.a[val]).join(" + ") : this.value && Object.keys(this.value).length ? Object.keys(this.value).map(val => _keyboardMap__WEBPACK_IMPORTED_MODULE_1__.a[val]).join(" + ") : this.lang("settings_Shortcuts_Click");
                },
                rec() {
                    return Object.keys(this.keys).length;
                },
                tempRec() {
                    return Object.keys(this.tempKeys).length;
                },
                value: {
                    get() {
                        const temp = api.settings.get(this.option);
                        if (!temp || !temp.length) return {};
                        const rv = {};
                        for (let i = 0; i < temp.length; ++i) rv[temp[i]] = temp[i];
                        return rv;
                    },
                    set(value) {
                        api.settings.set(this.option, Object.keys(value));
                    }
                }
            },
            methods: {
                lang: api.storage.lang,
                keyDown(event) {
                    this.keys[event.keyCode] || con.log("down" + event.keyCode), this.$set(this.keys, event.keyCode, _keyboardMap__WEBPACK_IMPORTED_MODULE_1__.a[event.keyCode]), 
                    this.tempKeys = {};
                },
                keyUp(event) {
                    con.log("up" + event.keyCode), this.setTempState(this.keys), this.$delete(this.keys, event.keyCode);
                },
                focusLost() {
                    this.keys = {};
                },
                setTempState(state) {
                    if (!Object.keys(this.tempKeys).length) {
                        const tempState = {
                            ...state
                        };
                        this.tempKeys = tempState, clearTimeout(tempKeysTimeout), tempKeysTimeout = setTimeout(() => {
                            Object.keys(this.keys).length || (this.value = tempState), this.tempKeys = {};
                        }, 500);
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(318);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        var _provider_listFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
        __webpack_exports__.a = {
            props: {
                option: {
                    type: String
                }
            },
            data: () => ({
                username: "",
                listObj: null
            }),
            computed: {
                mode: {
                    get() {
                        return api.settings.get(this.option);
                    },
                    set() {}
                },
                pageName() {
                    return this.listObj ? this.listObj.name : "Loading";
                },
                pageAuth() {
                    return this.listObj ? this.listObj.authenticationUrl : "";
                }
            },
            watch: {
                mode() {
                    this.init();
                }
            },
            mounted() {
                this.init();
            },
            methods: {
                lang: api.storage.lang,
                init() {
                    return this.username = "", this.listObj = Object(_provider_listFactory__WEBPACK_IMPORTED_MODULE_0__.b)(this.mode), 
                    this.listObj.getUsername().then(username => {
                        this.username = username;
                    });
                },
                deauth() {
                    this.listObj.deauth().then(() => {
                        this.init();
                    }).catch(() => {
                        alert("Failed");
                    });
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(320);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        var _components_keyboardMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
        __webpack_exports__.a = {
            props: {
                page: {
                    type: Object,
                    default: null
                }
            },
            data: () => ({}),
            computed: {
                keys: () => api.settings.get("correctionShort").map(val => _components_keyboardMap__WEBPACK_IMPORTED_MODULE_0__.a[val]).join(" + ")
            },
            watch: {},
            methods: {
                lang: api.storage.lang,
                openPopup() {
                    return this.page.openCorrectionUi(), !1;
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils, con) {
        var _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
        __webpack_exports__.a = {
            computed: {
                links: () => Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_0__.b)()
            },
            methods: {
                lang: api.storage.lang,
                favicon(url) {
                    try {
                        return utils.favicon(url);
                    } catch (e) {
                        return con.error(e), "";
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con) {
        var _provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18), _provider_metaDataFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(289), _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13), _components_overviewProgress_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(286);
        let nextEpBounce;
        __webpack_exports__.a = {
            components: {
                progressP: _components_overviewProgress_vue__WEBPACK_IMPORTED_MODULE_3__.a
            },
            props: {
                renderObj: {
                    type: Object,
                    default: null
                }
            },
            data: () => ({
                metaObj: null,
                error: null,
                imageTemp: null,
                mal: {
                    resumeUrl: null,
                    continueUrl: null
                },
                kiss2mal: [],
                related: [],
                utils: utils
            }),
            computed: {
                objError() {
                    return this.renderObj && this.renderObj.getLastError() ? this.renderObj.getLastErrorMessage() : null;
                },
                editUrl() {
                    return void 0 !== this.renderObj.getDetailUrl ? this.renderObj.getDetailUrl() : null;
                },
                malStatus: {
                    get() {
                        return this.renderObj && this.renderObj.isAuthenticated() ? this.renderObj.getStatusCheckboxValue() : null;
                    },
                    set(value) {
                        this.renderObj && this.renderObj.isAuthenticated() && this.renderObj.handleStatusCheckbox(value);
                    }
                },
                malEpisode: {
                    get() {
                        return this.renderObj && this.renderObj.isAuthenticated() ? this.renderObj.addAnime ? null : this.renderObj.getEpisode() : null;
                    },
                    set(value) {
                        this.renderObj && this.renderObj.isAuthenticated() && this.renderObj.setEpisode(value);
                    }
                },
                malVolume: {
                    get() {
                        return this.renderObj && this.renderObj.isAuthenticated() ? this.renderObj.addAnime ? null : this.renderObj.getVolume() : null;
                    },
                    set(value) {
                        this.renderObj && this.renderObj.isAuthenticated() && this.renderObj.setVolume(value);
                    }
                },
                malScore: {
                    get() {
                        return this.renderObj && this.renderObj.isAuthenticated() ? this.renderObj.getScoreCheckboxValue() : null;
                    },
                    set(value) {
                        this.renderObj && this.renderObj.isAuthenticated() && this.renderObj.handleScoreCheckbox(value);
                    }
                },
                malProgressMode: {
                    get() {
                        return this.renderObj && this.renderObj.isAuthenticated() ? this.renderObj.getProgressMode() : null;
                    },
                    set(value) {
                        this.renderObj && this.renderObj.isAuthenticated() && this.renderObj.setProgressMode(value);
                    }
                },
                statistics() {
                    let stats = {};
                    try {
                        stats = this.metaObj.statistics;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return stats;
                },
                displayUrl() {
                    return null !== this.renderObj ? this.renderObj.getDisplayUrl() : this.renderObj.url;
                },
                image() {
                    let image = "";
                    try {
                        image = this.metaObj.image;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    try {
                        null !== this.imageTemp && "" !== this.imageTemp && (image = this.imageTemp);
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return image;
                },
                title() {
                    let title = "";
                    try {
                        title = this.metaObj.title;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    try {
                        title = this.renderObj.getTitle();
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return title;
                },
                description() {
                    let description = "";
                    try {
                        description = this.metaObj.description;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return description;
                },
                altTitle() {
                    let altTitle = {};
                    try {
                        altTitle = this.metaObj.alternativeTitle;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return altTitle;
                },
                characters() {
                    let char = {};
                    try {
                        char = this.metaObj.characters;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return char;
                },
                info() {
                    let info = {};
                    try {
                        info = this.metaObj.info;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return info;
                },
                openingSongs() {
                    let opening = {};
                    try {
                        opening = this.metaObj.openingSongs;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return opening;
                },
                endingSongs() {
                    let ending = {};
                    try {
                        ending = this.metaObj.endingSongs;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return ending;
                }
            },
            watch: {
                async renderObj(renderObj) {
                    this.render(renderObj);
                }
            },
            methods: {
                lang: api.storage.lang,
                assetUrl: api.storage.assetUrl,
                async render(renderObj) {
                    if (this.metaObj = null, this.error = null, this.mal.resumeUrl = null, this.mal.continueUrl = null, 
                    this.kiss2mal = [], this.related = [], this.imageTemp = null, null === renderObj) return;
                    const stateTest = renderObj.url;
                    let syncMode = api.settings.get("syncMode");
                    "SIMKL" === syncMode && "manga" === renderObj.type && (syncMode = api.settings.get("syncModeSimkl"));
                    try {
                        const ov = await Object(_provider_metaDataFactory__WEBPACK_IMPORTED_MODULE_1__.a)(renderObj.url, renderObj.getType()).init();
                        if (!this.renderObj || stateTest !== this.renderObj.url) return;
                        this.metaObj = ov.getMeta();
                    } catch (e) {
                        return con.error("Could not retrive metadata", e), void (this.error = e);
                    }
                    if (null !== this.metaObj && (this.related = this.getRelated()), null !== renderObj.getMalUrl() && renderObj.isAuthenticated() && this.updateStatusTags(), 
                    Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__.a)(renderObj.getType(), renderObj.getApiCacheKey(), renderObj.getTitle()).then(links => {
                        this.renderObj && stateTest === this.renderObj.url && (this.kiss2mal = links);
                    }), "MAL" !== this.renderObj.shortName) {
                        const tempi = await this.renderObj.getImage();
                        if (!this.renderObj || stateTest !== this.renderObj.url) return;
                        this.imageTemp = tempi;
                    }
                    this.mal.resumeUrl = renderObj.getResumeWatching(), this.mal.continueUrl = renderObj.getContinueWatching();
                },
                clickRender() {
                    this.render(this.renderObj);
                },
                malSync() {
                    this.renderObj.sync().then(() => {
                        utils.flashm(api.storage.lang("updated")), this.renderObj.isOnList() || this.renderObj.update();
                    }, e => {
                        throw this.renderObj.flashmError(e), e;
                    });
                },
                remove() {
                    this.renderObj.delete().then(() => {
                        utils.flashm(api.storage.lang("removed")), this.renderObj.update();
                    }, e => {
                        throw this.renderObj.flashmError(e), this.renderObj.update(), e;
                    });
                },
                reload() {
                    utils.flashm(api.storage.lang("Loading")), this.renderObj.update();
                },
                increaseEP(type) {
                    let nextEp = 1;
                    "episode" === type ? (this.renderObj.getEpisode() && (nextEp = this.renderObj.getEpisode() + 1), 
                    this.renderObj.getTotalEpisodes() && nextEp > this.renderObj.getTotalEpisodes() && (nextEp = this.renderObj.getTotalEpisodes()), 
                    this.renderObj.setEpisode(nextEp)) : (this.renderObj.getVolume() && (nextEp = this.renderObj.getVolume() + 1), 
                    this.renderObj.getTotalVolumes() && nextEp > this.renderObj.getTotalVolumes() && (nextEp = this.renderObj.getTotalVolumes()), 
                    this.renderObj.setVolume(nextEp)), clearTimeout(nextEpBounce), nextEpBounce = setTimeout(() => {
                        this.malSync();
                    }, 1e3);
                },
                getMal2KissFavicon(url) {
                    try {
                        return utils.favicon(url);
                    } catch (e) {
                        return con.error(e), "";
                    }
                },
                getRelated() {
                    let related = {};
                    try {
                        related = this.metaObj.related;
                    } catch (e) {
                        console.log("[iframeOverview] Error:", e);
                    }
                    return related;
                },
                async updateStatusTags() {
                    for (const relatedKey in this.related) {
                        const relate = this.related[relatedKey];
                        for (const linkKey in relate.links) {
                            const link = relate.links[linkKey], url = utils.absoluteLink(link.url, "https://myanimelist.net");
                            if (void 0 !== url) {
                                const tag = await utils.timeCache("MALTAG/" + url, (async function() {
                                    const malObj = Object(_provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__.b)(url);
                                    return await malObj.update(), await utils.wait(2e3), utils.statusTag(malObj.getStatus(), malObj.type, malObj.id);
                                }), 1728e5);
                                tag && (this.related[relatedKey].links[linkKey].statusTag = tag);
                            }
                        }
                    }
                },
                setQuestionmark(e) {
                    e.target.src = api.storage.assetUrl("questionmark.gif");
                }
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con) {
        var _overviewProgressCountryFlag_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288), _utils_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
        __webpack_exports__.a = {
            components: {
                CountryFlag: _overviewProgressCountryFlag_vue__WEBPACK_IMPORTED_MODULE_0__.a
            },
            props: {
                apiCacheKey: {
                    type: Number
                },
                type: {
                    type: String
                },
                totalEps: {
                    type: Number
                }
            },
            data: () => ({
                xhr: "",
                utils: utils
            }),
            computed: {
                elements() {
                    const elements = [];
                    if (this.xhr) for (const language in this.xhr) for (const i in this.xhr[language]) elements.push({
                        language: language,
                        index: i,
                        item: this.xhr[language][i]
                    });
                    return elements;
                },
                completed() {
                    return this.elements.filter(el => el.item && el.item.top && el.item.top.state && "complete" === el.item.top.state);
                },
                ongoing() {
                    return this.elements.filter(el => el.item && el.item.top && el.item.top.state && "complete" !== el.item.top.state);
                }
            },
            watch: {
                apiCacheKey: {
                    immediate: !0,
                    handler(newVal) {
                        this.xhr = "";
                        const cur = newVal + "s";
                        return api.request.xhr("GET", `https://api.malsync.moe/nc/mal/${this.type}/${newVal}/progress`).then(response => {
                            if (cur === this.apiCacheKey + "s") try {
                                this.xhr = JSON.parse(response.responseText);
                            } catch (e) {
                                con.error("No progress informations found");
                            }
                        });
                    }
                }
            },
            methods: {
                lang: api.storage.lang,
                releaseTime: ms => Object(_utils_time__WEBPACK_IMPORTED_MODULE_1__.b)(ms),
                correctFlag(flag) {
                    switch (flag.toLowerCase()) {
                      case "pt-br":
                        return "br";

                      case "aa":
                        return "dj";

                      case "af":
                        return "za";

                      case "ak":
                        return "gh";

                      case "sq":
                        return "al";

                      case "am":
                        return "et";

                      case "hy":
                        return "am";

                      case "az":
                        return "az";

                      case "bm":
                        return "ml";

                      case "be":
                        return "by";

                      case "bn":
                        return "bd";

                      case "bi":
                        return "vu";

                      case "bs":
                        return "ba";

                      case "bg":
                        return "bg";

                      case "my":
                        return "mm";

                      case "ca":
                        return "ad";

                      case "zh":
                      case "zh-hans":
                      case "zh-hant":
                      case "zh-x-yue":
                        return "cn";

                      case "hr":
                        return "hr";

                      case "cs":
                        return "cz";

                      case "da":
                        return "dk";

                      case "dv":
                        return "mv";

                      case "nl":
                        return "nl";

                      case "dz":
                        return "bt";

                      case "en":
                        return "gb";

                      case "et":
                        return "ee";

                      case "fj":
                        return "fj";

                      case "fil":
                        return "ph";

                      case "fi":
                        return "fi";

                      case "fr":
                        return "fr";

                      case "gaa":
                        return "gh";

                      case "ka":
                        return "ge";

                      case "de":
                        return "de";

                      case "el":
                        return "gr";

                      case "gu":
                        return "in";

                      case "ht":
                        return "ht";

                      case "he":
                        return "il";

                      case "hi":
                        return "in";

                      case "ho":
                        return "pg";

                      case "hu":
                        return "hu";

                      case "is":
                        return "is";

                      case "ig":
                        return "ng";

                      case "id":
                        return "id";

                      case "ga":
                        return "ie";

                      case "it":
                        return "it";

                      case "ja":
                        return "jp";

                      case "kr":
                        return "ne";

                      case "kk":
                        return "kz";

                      case "km":
                        return "kh";

                      case "kmb":
                        return "ao";

                      case "rw":
                        return "rw";

                      case "kg":
                        return "cg";

                      case "ko":
                        return "kr";

                      case "kj":
                        return "ao";

                      case "ku":
                        return "iq";

                      case "ky":
                        return "kg";

                      case "lo":
                        return "la";

                      case "la":
                        return "va";

                      case "lv":
                        return "lv";

                      case "ln":
                        return "cg";

                      case "lt":
                        return "lt";

                      case "lu":
                        return "cd";

                      case "lb":
                        return "lu";

                      case "mk":
                        return "mk";

                      case "mg":
                        return "mg";

                      case "ms":
                        return "my";

                      case "mt":
                        return "mt";

                      case "mi":
                        return "nz";

                      case "mh":
                        return "mh";

                      case "mn":
                        return "mn";

                      case "mos":
                        return "bf";

                      case "ne":
                        return "np";

                      case "nd":
                        return "zw";

                      case "nso":
                        return "za";

                      case "no":
                      case "nb":
                      case "nn":
                        return "no";

                      case "ny":
                        return "mw";

                      case "pap":
                        return "aw";

                      case "ps":
                        return "af";

                      case "fa":
                        return "ir";

                      case "pl":
                        return "pl";

                      case "pt":
                        return "pt";

                      case "pa":
                        return "in";

                      case "qu":
                        return "wh";

                      case "ro":
                        return "ro";

                      case "rm":
                        return "ch";

                      case "rn":
                        return "bi";

                      case "ru":
                        return "ru";

                      case "sg":
                        return "cf";

                      case "sr":
                        return "rs";

                      case "srr":
                        return "sn";

                      case "sn":
                        return "zw";

                      case "si":
                        return "lk";

                      case "sk":
                        return "sk";

                      case "sl":
                        return "si";

                      case "so":
                        return "so";

                      case "snk":
                        return "sn";

                      case "nr":
                        return "za";

                      case "st":
                        return "ls";

                      case "es":
                      case "es-la":
                        return "es";

                      case "ss":
                        return "sz";

                      case "sv":
                        return "se";

                      case "tl":
                        return "ph";

                      case "tg":
                        return "tj";

                      case "ta":
                        return "lk";

                      case "te":
                        return "in";

                      case "tet":
                        return "tl";

                      case "th":
                        return "th";

                      case "ti":
                        return "er";

                      case "tpi":
                        return "pg";

                      case "ts":
                        return "za";

                      case "tn":
                        return "bw";

                      case "tr":
                        return "tr";

                      case "tk":
                        return "tm";

                      case "uk":
                        return "ua";

                      case "umb":
                        return "ao";

                      case "ur":
                        return "pk";

                      case "uz":
                        return "uz";

                      case "ve":
                        return "za";

                      case "vi":
                        return "vn";

                      case "cy":
                        return "gb";

                      case "wo":
                        return "sn";

                      case "xh":
                      case "zu":
                        return "za";

                      default:
                        return flag;
                    }
                }
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        var _utils_Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
        __webpack_exports__.a = {
            props: {
                country: {
                    type: String,
                    required: !0
                },
                text: {
                    type: String,
                    default: ""
                }
            },
            data: () => ({
                flagHtml: ""
            }),
            watch: {
                country: {
                    immediate: !0,
                    async handler(newVal) {
                        const cache = new _utils_Cache__WEBPACK_IMPORTED_MODULE_0__.a("flag/" + newVal, 1728e5);
                        await cache.hasValue() ? cache.getValue().then(val => this.flagHtml = val) : api.request.xhr("GET", `https://raw.githubusercontent.com/lipis/flag-icon-css/master/flags/4x3/${newVal}.svg`).then(response => {
                            response.responseText && 200 === response.status ? (this.flagHtml = response.responseText, 
                            cache.setValue(response.responseText)) : cache.setValue(null);
                        });
                    }
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        function getUserRec(value) {
            const text = function(element) {
                let text = element.text();
                return element.children().each((function() {
                    text = text.replace(j.$(this).text(), "");
                })), text;
            }(j.$(value).find(".detail-user-recs-text").first()).trim(), username = j.$(value).find(".detail-user-recs-text").next().find("a").last().text(), userHref = "https://myanimelist.net" + j.$(value).find(".detail-user-recs-text").next().find("a").last().attr("href");
            let readmore = "";
            return j.$(value).find(".detail-user-recs-text > span[id^=recommend]").length && (readmore = j.$(value).find(".detail-user-recs-text > span[id^=recommend]").text().trim()), 
            {
                text: text,
                username: username,
                userHref: userHref,
                readmore: readmore
            };
        }
        __webpack_exports__.a = {
            props: {
                url: {
                    type: String,
                    default: ""
                },
                state: {
                    type: Boolean,
                    default: !1
                }
            },
            data: () => ({
                xhr: "",
                activeItems: [],
                activeReadMores: []
            }),
            computed: {
                recommendations() {
                    const array = [];
                    try {
                        const recommendationsBlock = this.xhr.split("Make a recommendation</a>")[1].split("</h2>")[1].split('<div class="mauto')[0], htmlT = j.$.parseHTML(recommendationsBlock);
                        j.$.each(j.$(htmlT).filter(".borderClass"), (index, value) => {
                            const imageBlock = j.$(value).find(".picSurround"), titleHref = imageBlock.find("a").attr("href"), titleName = imageBlock.find("a > img").first().attr("alt"), imageUrl = imageBlock.find("a > img").first().attr("data-src"), user = getUserRec(value), children = [];
                            j.$(value).find("td:eq(1) > div").last().find("div.borderClass").each((index2, value2) => {
                                children.push(getUserRec(value2));
                            }), array.push({
                                titleHref: titleHref,
                                titleName: titleName,
                                imageUrl: imageUrl,
                                user: user,
                                children: children
                            });
                        }), console.log(array);
                    } catch (e) {
                        console.log("[iframeRecommendations] Error:", e);
                    }
                    return array;
                }
            },
            watch: {
                async url() {
                    this.xhr = "", this.state && api.request.xhr("GET", this.url + "/userrecs").then(response => {
                        this.xhr = response.responseText;
                    });
                },
                async state(state) {
                    state && "" === this.xhr && api.request.xhr("GET", this.url + "/userrecs").then(response => {
                        this.xhr = response.responseText;
                    });
                }
            },
            methods: {
                lang: api.storage.lang
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, j, con) {
        var _provider_listFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16), _bookmarksItem_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(287);
        __webpack_exports__.a = {
            components: {
                bookmarksItem: _bookmarksItem_vue__WEBPACK_IMPORTED_MODULE_1__.a
            },
            props: {
                listType: {
                    type: String,
                    default: "anime"
                },
                state: {
                    type: Number,
                    default: 1
                },
                sort: {
                    type: Object,
                    default: null
                }
            },
            data: () => ({
                listProvider: void 0,
                errorText: null,
                cache: [],
                destroyTimer: void 0,
                reload: !1
            }),
            computed: {
                listView: {
                    get: () => api.settings.get("bookMarksList"),
                    set(value) {
                        api.settings.set("bookMarksList", value);
                    }
                },
                loading() {
                    return !this.listProvider || this.listProvider.isLoading();
                },
                items() {
                    return this.listProvider && this.listProvider.isFirstLoaded() ? this.listProvider.getTemplist() : this.cache;
                }
            },
            watch: {
                listType() {
                    this.load();
                },
                state() {
                    this.load();
                },
                sort(value, old) {
                    old && value.value === old.value || (localStorage.setItem(`sort/${this.listType}/${this.state}`, value.value), 
                    this.load());
                }
            },
            mounted() {
                this.load(), this.$parent.registerScroll("books", this.handleScroll), clearTimeout(this.destroyTimer);
            },
            activated() {
                this.$nextTick(() => {
                    j.$(this.$el).closest("html").find("head").click();
                }), clearTimeout(this.destroyTimer), this.$parent.registerScroll("books", this.handleScroll), 
                this.reload && (this.reload = !1, this.load());
            },
            deactivated() {
                this.$parent.unregisterScroll("books"), clearTimeout(this.destroyTimer), this.destroyTimer = setTimeout(() => {
                    this.listProvider.destroy(), this.reload = !0;
                }, 6e5);
            },
            methods: {
                lang: api.storage.lang,
                async load() {
                    this.cache = [], this.errorText = null, this.listProvider && this.listProvider.destroy(), 
                    this.listProvider = await Object(_provider_listFactory__WEBPACK_IMPORTED_MODULE_0__.a)(this.state, this.listType), 
                    this.$emit("rewatch", this.listProvider.seperateRewatching);
                    const sortOptions = this.listProvider.getSortingOptions();
                    this.initSort(sortOptions) || (this.listProvider.setSort(this.sort.value), this.listProvider.modes.cached = !0, 
                    this.listProvider.getCached().then(list => {
                        this.cache = list;
                    }), this.listProvider.modes.initProgress = !0, this.listProvider.initFrontendMode(), 
                    this.loadNext());
                },
                initSort(sortOptions) {
                    const curSort = localStorage.getItem(`sort/${this.listType}/${this.state}`);
                    let s = sortOptions.find(el => el.value === curSort);
                    return s ? (!this.sort || s.value !== this.sort.value) && (this.$emit("sort", s), 
                    !0) : (s = sortOptions.find(el => "default" === el.value), this.$emit("sort", s), 
                    !1);
                },
                listError(e) {
                    con.error(e), this.errorText = this.listProvider.errorMessage(e);
                },
                loadNext() {
                    return this.listProvider && !this.listProvider.isLoading() ? this.listProvider.getNextPage().catch(this.listError) : Promise.resolve();
                },
                handleScroll(pos) {
                    pos.pos + pos.elHeight + 1e3 > pos.height && this.loadNext();
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(2), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils) {
        __webpack_exports__.a = {
            props: {
                item: {
                    type: Object
                },
                listView: {
                    type: Boolean,
                    default: !1
                }
            },
            data: () => ({
                resumeUrl: null,
                continueUrl: null
            }),
            computed: {
                curEP() {
                    return parseInt(this.item.watchedEp.toString());
                },
                imageHi() {
                    let imageHi = this.item.image;
                    const regexDimensions = /\/r\/\d*x\d*/g;
                    return regexDimensions.test(imageHi) && (imageHi = imageHi.replace(/v.jpg$/g, ".jpg").replace(regexDimensions, "")), 
                    imageHi;
                },
                hasTotalEp() {
                    return this.barData.totalWidth;
                },
                barData() {
                    return this.item.fn.progress ? this.item.fn.progress.getBars(this.item.watchedEp, this.item.totalEp) : {};
                },
                progress() {
                    return `width: ${this.barData.epWidth}%; max-width: 100%;`;
                },
                predictionBar() {
                    const color = this.item.fn.progress.getColor();
                    return `width: ${this.barData.predWidth}%; background-color: ${color}; color: ${color};`;
                },
                streamUrl() {
                    return this.item.options.u;
                }
            },
            watch: {
                curEP: {
                    immediate: !0,
                    async handler(ep) {
                        if (void 0 === this.item.resume) {
                            this.resumeUrl = "", this.continueUrl = "";
                            let resumeUrl = null, continueUrl = null;
                            const resumeUrlObj = this.item.options.r, continueUrlObj = this.item.options.c;
                            continueUrlObj && continueUrlObj.ep === ep + 1 ? continueUrl = continueUrlObj.url : resumeUrlObj && resumeUrlObj.ep === ep && (resumeUrl = resumeUrlObj.url), 
                            this.resumeUrl = resumeUrl, this.continueUrl = continueUrl;
                        }
                    }
                }
            },
            methods: {
                lang: api.storage.lang,
                favicon: domain => utils.favicon(domain),
                assetUrl: asset => api.storage.assetUrl(asset),
                openLink(url) {
                    const link = document.createElement("a");
                    link.href = url, document.getElementById("malList").appendChild(link), link.click();
                },
                setQuestionmark(e) {
                    e.target.src = api.storage.assetUrl("questionmark.gif");
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        var _provider_searchFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
        __webpack_exports__.a = {
            components: {},
            props: {
                type: {
                    type: String,
                    default: "anime"
                },
                keyword: {
                    type: String,
                    default: ""
                }
            },
            data: () => ({
                items: [],
                loading: !0
            }),
            watch: {
                keyword() {
                    this.load();
                },
                type() {
                    this.load();
                }
            },
            mounted() {
                this.load();
            },
            activated() {
                this.$nextTick(() => {
                    j.$(this.$el).closest("html").find("head").click();
                });
            },
            methods: {
                lang: api.storage.lang,
                load() {
                    this.loading = !0, Object(_provider_searchFactory__WEBPACK_IMPORTED_MODULE_0__.a)(this.keyword, this.type).then(items => {
                        this.loading = !1, this.items = items;
                    });
                },
                clickItem(e, item) {
                    e.preventDefault(), this.$emit("clicked", item);
                }
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils) {
        var _provider_listFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
        let interva;
        __webpack_exports__.a = {
            data: () => ({
                listType: "anime",
                items: [],
                history: []
            }),
            watch: {
                listType() {
                    this.load();
                }
            },
            mounted() {
                this.load(), interva = setInterval(() => {
                    this.load();
                }, 5e3);
            },
            destroyed() {
                clearInterval(interva);
            },
            methods: {
                lang: api.storage.lang,
                async load() {
                    const listProvider = await Object(_provider_listFactory__WEBPACK_IMPORTED_MODULE_0__.a)(1, this.listType);
                    listProvider.getCompleteList().then(async list => {
                        for (let i = 0; i < list.length; i++) {
                            const el = list[i];
                            let episode = "", error = "", trColor = "";
                            con.log("el", el);
                            const elCache = await api.storage.get(`updateCheck/${this.listType}/${el.cacheKey}`);
                            con.log("elCache", elCache), void 0 !== elCache && (episode = `${elCache.newestEp}/${el.totalEp}`, 
                            trColor = "orange", elCache.finished && (error = "finished", trColor = "green"), 
                            void 0 !== elCache.error && (error = elCache.error, trColor = "red")), el.episode = episode, 
                            el.trColor = trColor, el.error = error;
                        }
                        this.items = list;
                    }).catch(e => {
                        con.error(e), listProvider.flashmError(e);
                    }), api.storage.get("notificationHistory").then(history => {
                        history.forEach(entry => {
                            let timeDiff = Date.now() - entry.timestamp;
                            timeDiff = utils.timeDiffToText(timeDiff), timeDiff += "ago", entry.timeDiff = timeDiff;
                        }), this.history = history.reverse();
                    });
                },
                deleteItem(item) {
                    const delPath = `updateCheck/${this.listType}/${item.cacheKey}`;
                    con.log("delete", delPath, item), api.storage.remove(delPath), item.trColor = "black";
                },
                notificationTest() {
                    utils.notifications("https://malsync.lolamtisch.de/", "MyAnimeList-Sync", "by lolamtisch", "https://cdn.myanimelist.net/images/anime/5/65187.jpg");
                },
                startCheck() {
                    chrome.alarms.create("updateCheckNow", {
                        when: Date.now() + 1e3
                    }), utils.flashm("Check started");
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        var _syncHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19), _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
        __webpack_exports__.a = {
            components: {
                backbutton: _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__.a
            },
            props: {
                listType: {
                    type: String,
                    default: "anime"
                }
            },
            data: () => ({
                listProvider: {
                    mal: {
                        text: "Init",
                        list: null,
                        master: !1
                    },
                    anilist: {
                        text: "Init",
                        list: null,
                        master: !1
                    },
                    kitsu: {
                        text: "Init",
                        list: null,
                        master: !1
                    },
                    simkl: {
                        text: "Init",
                        list: null,
                        master: !1
                    }
                },
                listReady: !1,
                listLength: 0,
                list: {},
                missing: [],
                isBackgroundEnabled: !1
            }),
            computed: {
                listSyncLength() {
                    return Object.values(this.list).filter(el => el.diff).length;
                },
                listDiff() {
                    const res = {};
                    for (const key in this.list) Object.prototype.hasOwnProperty.call(this.list, key) && this.list[key].diff && (res[key] = this.list[key]);
                    return res;
                }
            },
            watch: {},
            async mounted() {
                _syncHandler__WEBPACK_IMPORTED_MODULE_0__.a.isEnabled().then(state => {
                    this.isBackgroundEnabled = state;
                });
                const type = this.listType, providerList = _syncHandler__WEBPACK_IMPORTED_MODULE_0__.d({
                    mal: this.listProvider.mal,
                    anilist: this.listProvider.anilist,
                    kitsu: this.listProvider.kitsu,
                    simkl: this.listProvider.simkl
                }), listOptions = await _syncHandler__WEBPACK_IMPORTED_MODULE_0__.f(providerList, type, _syncHandler__WEBPACK_IMPORTED_MODULE_0__.c);
                _syncHandler__WEBPACK_IMPORTED_MODULE_0__.b(listOptions.master, listOptions.slaves, "mirror", listOptions.typeArray, this.list, this.missing), 
                this.list = {
                    ...this.list
                }, this.listReady = !0;
            },
            methods: {
                lang: api.storage.lang,
                getType: _syncHandler__WEBPACK_IMPORTED_MODULE_0__.e,
                apiType: () => api.type,
                getTypeColor: type => "ANILIST" === type ? "border-left: 5px solid #02a9ff" : "KITSU" === type ? "border-left: 5px solid #f75239" : "SIMKL" === type ? "border-left: 5px solid #ffbf00" : "border-left: 5px solid #2e51a2",
                async syncList() {
                    this.listReady = !1, this.listLength = this.listSyncLength, _syncHandler__WEBPACK_IMPORTED_MODULE_0__.g(this.list, this.missing);
                },
                async backgroundClick() {
                    await _syncHandler__WEBPACK_IMPORTED_MODULE_0__.a.isEnabled() ? (_syncHandler__WEBPACK_IMPORTED_MODULE_0__.a.disable(), 
                    this.isBackgroundEnabled = !1) : (_syncHandler__WEBPACK_IMPORTED_MODULE_0__.a.enable(), 
                    this.isBackgroundEnabled = !0);
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_exports__.a = {
            methods: {
                lang: api.storage.lang,
                click() {
                    this.$root.$children[0].selectTab("settings");
                }
            }
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils) {
        var _provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18), _provider_listFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
        async function cleanTags(url) {
            const entryClass = Object(_provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__.b)(url);
            return entryClass.update().then(() => (entryClass.cleanTags(), entryClass.sync())).catch(e => {
                con.error(e);
            });
        }
        function getList(type) {
            const listProvider = Object(_provider_listFactory__WEBPACK_IMPORTED_MODULE_1__.c)(7, type);
            return listProvider.getCompleteList().then(list => list).catch(e => {
                throw con.error(e), listProvider.errorMessage(e);
            });
        }
        __webpack_exports__.a = {
            props: {},
            data: () => ({
                animeLoading: !1,
                animelist: null,
                animelistLength: null,
                mangaLoading: !1,
                mangalist: null,
                mangalistLength: null
            }),
            computed: {},
            watch: {},
            methods: {
                lang: api.storage.lang,
                cleanTags() {
                    this.animeLoading = !0, getList("anime").then(async list => {
                        for (this.animelist = list, this.animelistLength = this.animelist.length; this.animelist.length; ) {
                            const anime = this.animelist.pop(), streamUrl = utils.getUrlFromTags(anime.tags);
                            void 0 !== streamUrl && (console.log(streamUrl), await cleanTags(anime.url));
                        }
                    }).then(() => getList("manga")).then(async list => {
                        for (this.mangalist = list, this.mangalistLength = this.mangalist.length; this.mangalist.length; ) {
                            const manga = this.mangalist.pop();
                            void 0 !== utils.getUrlFromTags(manga.tags) && await cleanTags(manga.url);
                        }
                    });
                }
            }
        };
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils) {
        var _pages_pages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84), _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
        __webpack_exports__.a = {
            components: {
                backbutton: _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__.a
            },
            props: {},
            data: () => ({
                pages: _pages_pages__WEBPACK_IMPORTED_MODULE_0__.a
            }),
            computed: {
                enablePages: () => api.settings.get("enablePages")
            },
            watch: {},
            async mounted() {
                this.$root.updateDom();
            },
            methods: {
                favicon: utils.favicon,
                lang: api.storage.lang,
                getDomain(page) {
                    let domain;
                    return domain = "object" == typeof page.domain ? page.domain[0] : page.domain, domain;
                },
                getPageState(page) {
                    return !(void 0 !== this.enablePages[page.name] && !this.enablePages[page.name]);
                },
                setPageState(page, state) {
                    const curState = JSON.parse(JSON.stringify(this.enablePages));
                    curState[page.name] = state, api.settings.set("enablePages", curState);
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_exports__.a = {
            props: {
                url: {
                    type: String,
                    default: ""
                },
                state: {
                    type: Boolean,
                    default: !1
                }
            },
            data: () => ({
                xhr: "",
                activeReadMores: []
            }),
            computed: {
                reviews() {
                    const array = [];
                    try {
                        const reviews = this.xhr.split("Reviews</h2>")[1].split("<h2>")[0], reviewsData2 = j.$.parseHTML(reviews);
                        j.$.each(j.$(reviewsData2).filter(".borderDark"), (index, value) => {
                            const imageBlock = j.$(value).find(".picSurround"), userHref = imageBlock.find("a").attr("href"), userImage = imageBlock.find("a > img").first().attr("data-src"), username = j.$(value).find(".spaceit > .mb8").next().find("td > a").text().trim(), rPeople = Number(j.$(value).find(".spaceit > .mb8").next().find("td > div > strong > span").text()), rDate = j.$(value).find(".spaceit > .mb8 > div").first().text().trim(), rEpisodes = j.$(value).find(".spaceit > .mb8 > div.lightLink").text().trim(), rRating = Number(j.$(value).find(".spaceit > .mb8 > div").last().text().replace(/\D+/, "")), rText = j.$(value).find(".textReadability").contents().filter((function() {
                                return 3 === this.nodeType && j.$.trim(this.nodeValue).length;
                            })).text().trim().split("\n"), rReadmore = j.$(value).find(".textReadability > span").contents().filter((function() {
                                return 3 === this.nodeType && j.$.trim(this.nodeValue).length;
                            })).text().trim().split("\n");
                            array.push({
                                userHref: userHref,
                                userImage: userImage,
                                username: username,
                                rPeople: rPeople,
                                rDate: rDate,
                                rEpisodes: rEpisodes,
                                rRating: rRating,
                                rText: rText,
                                rReadmore: rReadmore
                            });
                        }), console.log(array);
                    } catch (e) {
                        console.log("[iframeReview] Error:", e);
                    }
                    return array;
                }
            },
            watch: {
                async url() {
                    this.xhr = "", this.state && api.request.xhr("GET", this.url + "/reviews").then(response => {
                        this.xhr = response.responseText;
                    });
                },
                async state(state) {
                    state && "" === this.xhr && api.request.xhr("GET", this.url + "/reviews").then(response => {
                        this.xhr = response.responseText;
                    });
                }
            },
            methods: {
                lang: api.storage.lang
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils) {
        var _pages_pages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84), _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
        __webpack_exports__.a = {
            components: {
                backbutton: _components_backbutton_vue__WEBPACK_IMPORTED_MODULE_1__.a
            },
            data: () => ({
                pages: _pages_pages__WEBPACK_IMPORTED_MODULE_0__.a,
                permissions: [],
                hasPermissions: null
            }),
            computed: {
                option: {
                    get: () => api.settings.get("customDomains"),
                    set(value) {
                        api.settings.set("customDomains", value);
                    }
                },
                browserPermissions() {
                    return {
                        permissions: [ "webNavigation" ],
                        origins: this.permissions.map(perm => new URL(perm.domain).origin + "/")
                    };
                }
            },
            watch: {
                option(value) {
                    this.permissions = JSON.parse(JSON.stringify(value));
                },
                browserPermissions() {
                    this.checkPermissions();
                }
            },
            activated() {
                this.permissions = JSON.parse(JSON.stringify(this.option));
            },
            mounted() {
                this.permissions = JSON.parse(JSON.stringify(this.option)), this.$root.updateDom();
            },
            methods: {
                lang: api.storage.lang,
                addPermission() {
                    this.permissions.push({
                        domain: "",
                        page: ""
                    }), this.$root.updateDom();
                },
                removePermission(index) {
                    this.permissions.splice(index, 1);
                },
                savePermissions() {
                    this.permissions.every(el => this.domainCheck(el.domain) && this.pageCheck(el.page)) ? (this.option = JSON.parse(JSON.stringify(this.permissions)), 
                    this.requestPermissions()) : alert("Configuration could not be saved. Check if everything is configured correctly.");
                },
                pageCheck: page => !!page,
                domainCheck: domain => /^https?:\/\/(localhost|(?:www?\d?\.)?((?:(?!www\.|\.).)+\.[a-zA-Z0-9.]+))/.test(domain) && new URL(domain).origin,
                checkPermissions() {
                    chrome.permissions.contains(this.browserPermissions, result => {
                        this.hasPermissions = result;
                    });
                },
                requestPermissions() {
                    con.m("Request Permissions").log(this.browserPermissions), chrome.permissions.request(this.browserPermissions, granted => {
                        granted || utils.flashm("Requesting the permissions failed", {
                            error: !0
                        }), this.checkPermissions();
                    });
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(576);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils, con) {
        var _utils_quicklinks_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89), _backbutton_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
        __webpack_exports__.a = {
            components: {
                backbutton: _backbutton_vue__WEBPACK_IMPORTED_MODULE_1__.a
            },
            data: () => ({
                quicklinks: _utils_quicklinks_json__WEBPACK_IMPORTED_MODULE_0__,
                search: "",
                custom_name: "",
                custom_anime: "",
                custom_manga: ""
            }),
            computed: {
                linksWithState() {
                    return [ ...this.quicklinks, ...this.value.filter(el => "object" == typeof el && el) ].filter(el => !this.search || el.name.toLowerCase().includes(this.search.toLowerCase())).map(el => (el.active = this.value.includes(el.name) || el.custom, 
                    el)).sort((a, b) => a.name.localeCompare(b.name)).sort((a, b) => this.stateNumber(a) - this.stateNumber(b));
                },
                value: {
                    get: () => api.settings.get("quicklinks"),
                    set(value) {
                        api.settings.set("quicklinks", value), this.$emit("changed", value);
                    }
                }
            },
            methods: {
                lang: api.storage.lang,
                favicon(url) {
                    try {
                        return utils.favicon(url);
                    } catch (e) {
                        return con.error(e), "";
                    }
                },
                toggleLink(link) {
                    link.active ? (link.custom && (this.custom_name = link.name, this.custom_anime = link.search.anime, 
                    this.custom_manga = link.search.manga), this.value = Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__.d)(this.value, link.name)) : this.value.push(link.name), 
                    this.value = [ ...this.value ];
                },
                stateNumber: link => link.custom ? 0 : link.database ? 1 : link.search && "home" !== link.search.anime && "home" !== link.search.manga ? 2 : 10,
                addCustom() {
                    let domain = "";
                    if (this.custom_anime || this.custom_manga) {
                        let domainParts;
                        domainParts = this.custom_anime ? this.custom_anime.split("/") : this.custom_manga.split("/"), 
                        domainParts.length > 2 && (domain = `${domainParts[0]}//${domainParts[2]}/`);
                    }
                    if (!domain) return void utils.flashm("Something is wrong", {
                        error: !0
                    });
                    const res = {
                        name: this.custom_name,
                        custom: !0,
                        domain: domain,
                        search: {
                            anime: this.custom_anime ? this.custom_anime : null,
                            manga: this.custom_manga ? this.custom_manga : null
                        }
                    };
                    this.value = [ ...this.value, res ], this.custom_name = "", this.custom_anime = "", 
                    this.custom_manga = "";
                }
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Single;
    }));
    const Single = __webpack_require__(75).a;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Single;
        }));
        var _singleAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10), _AniList_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9), _utils_Cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14), _utils_general__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Single extends _singleAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.url = url, this.displayUrl = "", this.pending = !1, this.shortName = "MAL", 
                this.authenticationUrl = _helper__WEBPACK_IMPORTED_MODULE_2__.c, this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_2__.b, 
                this.logger = con.m(this.shortName, "#2e51a2"), this;
            }
            handleUrl(url) {
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.ids.mal = Number(utils.urlPart(url, 4)));
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            getCacheKey() {
                return this.ids.mal;
            }
            _getStatus() {
                let curSt;
                return curSt = "manga" === this.type ? parseInt(_helper__WEBPACK_IMPORTED_MODULE_2__.d[this.animeInfo.my_list_status.status]) : parseInt(_helper__WEBPACK_IMPORTED_MODULE_2__.a[this.animeInfo.my_list_status.status]), 
                this.getRewatching() && 2 === curSt ? 23 : curSt;
            }
            _setStatus(status) {
                23 === status ? (status = 2, this.setRewatching(!0)) : this.setRewatching(!1), "manga" !== this.type ? this.animeInfo.my_list_status.status = _helper__WEBPACK_IMPORTED_MODULE_2__.a[status] : this.animeInfo.my_list_status.status = _helper__WEBPACK_IMPORTED_MODULE_2__.d[status];
            }
            _getScore() {
                return this.animeInfo.my_list_status.score;
            }
            _setScore(score) {
                this.animeInfo.my_list_status.score = score;
            }
            _getEpisode() {
                return "manga" === this.type ? this.animeInfo.my_list_status.num_chapters_read : this.animeInfo.my_list_status.num_watched_episodes;
            }
            _setEpisode(episode) {
                episode || (episode = 0), "manga" !== this.type ? this.animeInfo.my_list_status.num_watched_episodes = episode : this.animeInfo.my_list_status.num_chapters_read = episode;
            }
            _getVolume() {
                return "manga" === this.type ? this.animeInfo.my_list_status.num_volumes_read : 0;
            }
            _setVolume(volume) {
                "manga" === this.type && (this.animeInfo.my_list_status.num_volumes_read = volume);
            }
            _getTags() {
                return this.animeInfo.my_list_status.tags.length ? this.animeInfo.my_list_status.tags.join(",") : "";
            }
            _setTags(tags) {
                tags && "," !== tags.trim() ? this.animeInfo.my_list_status.tags = tags.split(",") : this.animeInfo.my_list_status.tags = [];
            }
            getRewatching() {
                return "manga" === this.type ? this.animeInfo.my_list_status.is_rereading : this.animeInfo.my_list_status.is_rewatching;
            }
            setRewatching(state) {
                "manga" !== this.type ? this.animeInfo.my_list_status.is_rewatching = state : this.animeInfo.my_list_status.is_rereading = state;
            }
            _getTitle() {
                return this.animeInfo.title;
            }
            _getTotalEpisodes() {
                return "manga" === this.type ? this.animeInfo.num_chapters : this.animeInfo.num_episodes;
            }
            _getTotalVolumes() {
                return "manga" === this.type ? this.animeInfo.num_volumes : 0;
            }
            _getDisplayUrl() {
                return this.url;
            }
            _getImage() {
                var _a, _b;
                return Promise.resolve(null !== (_b = null === (_a = this.animeInfo.main_picture) || void 0 === _a ? void 0 : _a.medium) && void 0 !== _b ? _b : "");
            }
            _getRating() {
                return Promise.resolve(this.animeInfo.mean);
            }
            _update() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.apiCall({
                        type: "GET",
                        path: `${this.type}/${this.ids.mal}`,
                        fields: [ "my_list_status{tags,is_rewatching,is_rereading,start_date,finish_date}", "num_episodes", "mean", "num_chapters", "num_volumes" ]
                    }).catch(e => {
                        throw e.code === _definitions__WEBPACK_IMPORTED_MODULE_1__.a.NotAutenticated && (this._authenticated = !1), 
                        e;
                    }).then(res => {
                        this.logger.m("Api").log(res), this._authenticated = !0, this.animeInfo = res, this._onList = !0, 
                        this.animeInfo.my_list_status || (this._onList = !1, "manga" === this.type ? this.animeInfo.my_list_status = {
                            is_rereading: !1,
                            num_chapters_read: 0,
                            num_volumes_read: 0,
                            score: 0,
                            status: "plan_to_read",
                            tags: []
                        } : this.animeInfo.my_list_status = {
                            is_rewatching: !1,
                            num_watched_episodes: 0,
                            score: 0,
                            status: "plan_to_watch",
                            tags: []
                        }), this.animeInfo.my_list_status && void 0 !== this.animeInfo.my_list_status.num_episodes_watched && (this.animeInfo.my_list_status.num_watched_episodes = this.animeInfo.my_list_status.num_episodes_watched, 
                        delete this.animeInfo.my_list_status.num_episodes_watched);
                    });
                }));
            }
            _sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    void 0 === this.animeInfo.my_list_status.start_date && 1 === this._getStatus() && this._getEpisode() > 0 && (this.animeInfo.my_list_status.start_date = Object(_utils_general__WEBPACK_IMPORTED_MODULE_5__.returnYYYYMMDD)()), 
                    void 0 === this.animeInfo.my_list_status.finish_date && 2 === this._getStatus() && (this.animeInfo.my_list_status.finish_date = Object(_utils_general__WEBPACK_IMPORTED_MODULE_5__.returnYYYYMMDD)(), 
                    void 0 === this.animeInfo.my_list_status.start_date && (this.animeInfo.my_list_status.start_date = Object(_utils_general__WEBPACK_IMPORTED_MODULE_5__.returnYYYYMMDD)()));
                    const sentData = {};
                    for (const property in this.animeInfo.my_list_status) switch (property) {
                      case "priority":
                      case "num_watched_episodes":
                      case "num_volumes_read":
                      case "num_chapters_read":
                      case "score":
                      case "is_rewatching":
                      case "is_rereading":
                      case "num_times_rewatched":
                      case "num_times_reread":
                      case "rewatch_value":
                      case "reread_value":
                      case "tags":
                      case "comments":
                      case "status":
                      case "start_date":
                      case "finish_date":
                        sentData[property] = this.animeInfo.my_list_status[property];
                    }
                    return this.logger.m("Sync").log(this.ids.mal, sentData), this.apiCall({
                        type: "PUT",
                        path: `${this.type}/${this.ids.mal}/my_list_status`,
                        dataObj: sentData
                    }).then(res => {
                        this.logger.m("Sync").log("res", res);
                    });
                }));
            }
            delete() {
                return this.apiCall({
                    type: "DELETE",
                    path: `${this.type}/${this.ids.mal}/my_list_status`
                });
            }
            fillRelations() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_4__.a(`fillRelations/${this.ids.mal}/${this.getType()}`, 6048e5);
                    return cacheObj.hasValueAndIsNotEmpty().then(exists => exists ? cacheObj.getValue().then(res => {
                        res && res.da && parseInt(res.da) && (this.ids.ani = parseInt(res.da));
                    }) : Object(_AniList_helper__WEBPACK_IMPORTED_MODULE_3__.d)(this.ids.mal, this.getType()).then(el => (el && parseInt(el) && (this.ids.ani = parseInt(el)), 
                    cacheObj.setValue({
                        da: el
                    }))));
                }));
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Progress;
        }));
        var _background_releaseProgress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22), _time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Progress {
            constructor(cacheKey, type) {
                return this.cacheKey = cacheKey, this.type = type, this.releaseItem = void 0, this.updateItem = void 0, 
                this.logger = con.m("progress").m(cacheKey.toString()), this;
            }
            initReleaseProgress(liveData) {
                return __awaiter(this, void 0, void 0, (function*() {
                    liveData && (yield Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_0__.d)(liveData, this.type, liveData.progressMode));
                    const releaseItem = yield api.storage.get(`release/${this.type}/${this.cacheKey}`);
                    this.logger.m("Init Release").log(releaseItem), releaseItem && (Object(_background_releaseProgress__WEBPACK_IMPORTED_MODULE_0__.c)(releaseItem) ? this.logger.log("Too old") : this.releaseItem = releaseItem);
                }));
            }
            getProgressCurrentEpisode() {
                const re = this.releaseItem;
                return re && re.value && re.value.lastEp && re.value.lastEp.total ? re.value.lastEp.total : null;
            }
            isProgressFinished() {
                const re = this.releaseItem;
                return !(!re || !re.finished);
            }
            getProgressPrediction() {
                const re = this.releaseItem;
                return re && re.value && re.value.predicition && re.value.predicition.timestamp ? re.value.predicition.timestamp : null;
            }
            getProgressLastTimestamp() {
                const re = this.releaseItem;
                return re && re.value && re.value.lastEp && re.value.lastEp.timestamp ? re.value.lastEp.timestamp : null;
            }
            initUpdateCheck() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if ("webextension" !== api.type) return;
                    const update = yield api.storage.get(`updateCheck/${this.type}/${this.cacheKey}`);
                    update && (update.error || update.timestamp && ((new Date).getTime() - update.timestamp > 864e5 ? con.log("too old") : (con.m("update check").log(update), 
                    this.updateItem = update)));
                }));
            }
            getUpdateCurrentEpisode() {
                const re = this.updateItem;
                return re && re.newestEp ? re.newestEp : null;
            }
            init(live = !1) {
                return __awaiter(this, void 0, void 0, (function*() {
                    return yield Promise.all([ this.initReleaseProgress(live), this.initUpdateCheck() ]), 
                    this;
                }));
            }
            getCurrentEpisode() {
                return api.settings.get("epPredictions") ? this.updateItem && this.getUpdateCurrentEpisode() ? this.getUpdateCurrentEpisode() : this.getProgressCurrentEpisode() : null;
            }
            isFinished() {
                return this.isProgressFinished();
            }
            isAiring() {
                return !this.isFinished();
            }
            getPredictionTimestamp() {
                return this.updateItem && this.getUpdateCurrentEpisode() && this.getUpdateCurrentEpisode() !== this.getProgressCurrentEpisode() || !this.getProgressPrediction() || (new Date).getTime() > this.getProgressPrediction() ? NaN : this.getProgressPrediction();
            }
            getPrediction() {
                return Object(_time__WEBPACK_IMPORTED_MODULE_1__.b)(this.getPredictionTimestamp());
            }
            getPredictionText() {
                const pre = this.getPrediction();
                return pre ? api.storage.lang("prediction_Episode_" + this.type, [ pre ]) : "";
            }
            getLastTimestamp() {
                return this.updateItem && this.getUpdateCurrentEpisode() && this.getUpdateCurrentEpisode() !== this.getProgressCurrentEpisode() ? NaN : this.getProgressLastTimestamp();
            }
            getLast(ago = !0) {
                return Object(_time__WEBPACK_IMPORTED_MODULE_1__.b)(this.getLastTimestamp(), ago);
            }
            getLastText() {
                const last = this.getLast(!1);
                return last ? api.storage.lang("prediction_Last_" + this.type, [ last ]) : "";
            }
            getAuto() {
                const preT = this.getPrediction();
                if (preT) return preT;
                const lastT = this.getLast();
                return lastT || "";
            }
            getAutoText() {
                const preT = this.getPredictionText();
                if (preT) return preT;
                const lastT = this.getLastText();
                return lastT || "";
            }
            getColor() {
                return this.updateItem && this.getUpdateCurrentEpisode() ? "#e91e63" : "#f57c00";
            }
            getBars(curEp, totalEp) {
                const predEp = this.getCurrentEpisode(), res = {
                    totalWidth: 100,
                    epWidth: 0,
                    predWidth: 0
                };
                if (!totalEp) if (res.totalWidth = 0, curEp && (!predEp || curEp >= predEp)) totalEp = Math.ceil(1.2 * curEp); else {
                    if (!predEp || curEp && !(curEp < predEp)) return res;
                    totalEp = Math.ceil(1.2 * predEp);
                }
                return curEp && (res.epWidth = curEp / totalEp * 100, res.epWidth > 100 && (res.epWidth = 100)), 
                predEp && (res.predWidth = predEp / totalEp * 100, res.predWidth > 100 && (res.predWidth = 100)), 
                res;
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UserList;
    }));
    const UserList = __webpack_require__(78).a;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UserList;
        }));
        var _listAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class UserList extends _listAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.name = "MyAnimeList", this.authenticationUrl = _helper__WEBPACK_IMPORTED_MODULE_1__.c, 
                this.limit = 100, this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_1__.b;
            }
            getUsername() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.apiCall({
                        type: "GET",
                        path: "users/@me"
                    }).then(json => json.name);
                }));
            }
            errorHandling(res) {
                if (void 0 !== res.errors) throw con.error(res.errors), {
                    code: parseInt(res.errors[0].status),
                    message: res.errors[0].title
                };
            }
            deauth() {
                return api.settings.set("malToken", "").then(() => api.settings.set("malRefresh", ""));
            }
            _getSortingOptions() {
                return [ {
                    icon: "sort_by_alpha",
                    title: "Alphabetic",
                    value: "alpha"
                }, {
                    icon: "history",
                    title: "Last Updated",
                    value: "updated"
                }, {
                    icon: "score",
                    title: "Score",
                    value: "score"
                } ];
            }
            getOrder(sort) {
                switch (sort) {
                  case "alpha":
                    return this.listType + "_title";

                  case "updated":
                    return "list_updated_at";

                  case "score":
                    return "list_score";

                  default:
                    return 1 === this.status || 6 === this.status ? this.getOrder("updated") : this.getOrder("alpha");
                }
            }
            getPart() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.limit = 100, this.modes.frontend && (this.limit = 24);
                    const order = this.getOrder(this.sort);
                    let sorting = "";
                    order && (sorting = "&sort=" + order), con.log("[UserList][MAL]", "username: " + this.username, "status: " + this.status, "offset: " + this.offset, "sorting: " + sorting);
                    let curSt = "";
                    return 7 !== this.status && (curSt = "manga" === this.listType ? "&status=" + _helper__WEBPACK_IMPORTED_MODULE_1__.d[this.status] : "&status=" + _helper__WEBPACK_IMPORTED_MODULE_1__.a[this.status]), 
                    this.apiCall({
                        type: "GET",
                        path: `users/@me/${this.listType}list?nsfw=true&limit=${this.limit}&offset=${this.offset}${curSt}${sorting}`,
                        fields: [ "list_status{tags,is_rewatching,is_rereading,start_date,finish_date}", "num_episodes", "num_chapters", "num_volumes" ]
                    }).then(json => (json.paging && json.paging.next ? this.offset += this.limit : this.done = !0, 
                    this.prepareData(json.data)));
                }));
            }
            prepareData(data) {
                var _a, _b, _c, _d;
                return __awaiter(this, void 0, void 0, (function*() {
                    const newData = [];
                    for (let i = 0; i < data.length; i++) {
                        const el = data[i];
                        "anime" === this.listType ? newData.push(yield this.fn({
                            uid: el.node.id,
                            malId: el.node.id,
                            apiCacheKey: el.node.id,
                            cacheKey: el.node.id,
                            type: this.listType,
                            title: el.node.title,
                            url: `https://myanimelist.net/${this.listType}/${el.node.id}`,
                            watchedEp: el.list_status.num_episodes_watched,
                            totalEp: el.node.num_episodes,
                            status: parseInt(_helper__WEBPACK_IMPORTED_MODULE_1__.a[el.list_status.status]),
                            score: el.list_status.score,
                            image: null !== (_b = null === (_a = el.node.main_picture) || void 0 === _a ? void 0 : _a.medium) && void 0 !== _b ? _b : "",
                            tags: el.list_status.tags.length ? el.list_status.tags.join(",") : "",
                            airingState: el.anime_airing_status
                        })) : newData.push(yield this.fn({
                            uid: el.node.id,
                            malId: el.node.id,
                            apiCacheKey: el.node.id,
                            cacheKey: el.node.id,
                            type: this.listType,
                            title: el.node.title,
                            url: `https://myanimelist.net/${this.listType}/${el.node.id}`,
                            watchedEp: el.list_status.num_chapters_read,
                            totalEp: el.node.num_chapters,
                            status: parseInt(_helper__WEBPACK_IMPORTED_MODULE_1__.d[el.list_status.status]),
                            score: el.list_status.score,
                            image: null !== (_d = null === (_c = el.node.main_picture) || void 0 === _c ? void 0 : _c.medium) && void 0 !== _d ? _d : "",
                            tags: el.list_status.tags.length ? el.list_status.tags.join(",") : "",
                            airingState: el.anime_airing_status
                        }));
                    }
                    return console.log(newData), newData;
                }));
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return clientId;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return oauth;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const clientId = "10093a3f9f0174b6b5577c40e9accdae";
        function oauth() {
            $(document).ready((function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (window.location.href.includes("code=")) try {
                        yield function() {
                            return __awaiter(this, void 0, void 0, (function*() {
                                const code = utils.urlParam(window.location.href, "code"), state = utils.urlParam(window.location.href, "state");
                                if (window.history.replaceState("", "", "/mal/oauth"), !state || !code) throw "Url wrong";
                                const challenge = sessionStorage.getItem(state);
                                if (!challenge) throw "No challenge found";
                                return api.request.xhr("POST", {
                                    url: "https://myanimelist.net/v1/oauth2/token",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    },
                                    data: `&client_id=${clientId}&grant_type=authorization_code&code=${code}&code_verifier=${challenge}`
                                }).then(res => JSON.parse(res.responseText)).then(json => {
                                    if (json && json.refresh_token && json.access_token) return api.settings.set("malToken", json.access_token), 
                                    api.settings.set("malRefresh", json.refresh_token), $(".card-text.succ").prepend(j.html(api.storage.lang("anilistClass_authentication"))), 
                                    $("body").removeClass(), void $("body").addClass("success");
                                    if (json && json.error) throw json.error;
                                    throw "Something went wrong";
                                });
                            }));
                        }();
                    } catch (e) {
                        console.error(e), $(".card-text").first().text("Error: " + e), $("body").removeClass(), 
                        $("body").addClass("noExtension");
                    } else !function() {
                        const challenge = generateRandomString(50), state = generateRandomString(10);
                        sessionStorage.setItem(state, challenge);
                        const url = `https://myanimelist.net/v1/oauth2/authorize?response_type=code&client_id=${clientId}&state=${state}&code_challenge=${challenge}&code_challenge_method=plain`;
                        $(".card-text.succ").prepend(j.html(`<a class="btn btn-outline-light" href="${url}">Start Authentication</a>`)), 
                        $("body").removeClass(), $("body").addClass("success");
                    }();
                }));
            }));
        }
        function generateRandomString(length) {
            let text = "";
            const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
            for (let i = 0; i < length; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
            return text;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Single;
        }));
        var _singleAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class Single extends _singleAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.url = url, this.shortName = "Local", this.authenticationUrl = "", 
                this.logger = con.m(this.shortName, "black"), this;
            }
            handleUrl(url) {
                if (url.match(/local:\/\/.*/i)) return this.id = utils.urlPart(url, 4), this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.page = utils.urlPart(url, 2), this.key = `local://${this.page}/${this.type}/${this.id}`, 
                void (utils.urlPart(url, 5) ? this.title = decodeURIComponent(utils.urlPart(url, 5)) : this.title = "Unknown");
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            getCacheKey() {
                return `local:${this.id}:${this.page}`;
            }
            _getStatus() {
                return this.animeInfo.status;
            }
            _setStatus(status) {
                this.animeInfo.status = status;
            }
            _getScore() {
                return this.animeInfo.score;
            }
            _setScore(score) {
                this.animeInfo.score = score;
            }
            _getEpisode() {
                return this.animeInfo.progress;
            }
            _setEpisode(episode) {
                this.animeInfo.progress = parseInt("" + episode);
            }
            _getVolume() {
                return this.animeInfo.volumeprogress;
            }
            _setVolume(volume) {
                this.animeInfo.volumeprogress = volume;
            }
            _getTags() {
                let {tags: tags} = this.animeInfo;
                return tags || (tags = ""), tags;
            }
            _setTags(tags) {
                this.animeInfo.tags = tags;
            }
            _getTitle(raw = !1) {
                return raw ? this.animeInfo.name : "[L] " + this.animeInfo.name;
            }
            _getTotalEpisodes() {
                return 0;
            }
            _getTotalVolumes() {
                return 0;
            }
            _getDisplayUrl() {
                return "https://github.com/MALSync/MALSync/wiki/Local-Sync";
            }
            _getImage() {
                return this.animeInfo && this.animeInfo.image ? Promise.resolve(this.animeInfo.image) : Promise.resolve(api.storage.assetUrl("questionmark.gif"));
            }
            setImage(url) {
                this.animeInfo.image = url, this._onList && this.sync();
            }
            _getRating() {
                return Promise.resolve("Local");
            }
            _update() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this._authenticated = !0, this.animeInfo = yield api.storage.get(this.key), this._onList = !0, 
                    this.animeInfo || (this._onList = !1, this.animeInfo = {
                        name: this.title,
                        tags: "",
                        sUrl: "",
                        image: "",
                        progress: 0,
                        volumeprogress: 0,
                        score: 0,
                        status: 6
                    });
                }));
            }
            _sync() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.storage.set(this.key, this.animeInfo);
                }));
            }
            delete() {
                return api.storage.remove(this.key);
            }
            setStreamingUrl(streamingUrl) {
                return this.animeInfo && streamingUrl && (this.animeInfo.sUrl = streamingUrl), super.setStreamingUrl(streamingUrl);
            }
            getStreamingUrl() {
                return this.animeInfo && this.animeInfo.sUrl ? this.animeInfo.sUrl : super.getStreamingUrl();
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return simkl;
    }));
    const simkl = {
        shortName: "Simkl",
        score: "Simkl Score:",
        noLogin: 'Please Authenticate <a target="_blank" href="https://simkl.com/oauth/authorize?response_type=code&client_id=39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0&redirect_uri=https://simkl.com/apps/chrome/mal-sync/connected/">Here</a>'
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return search;
        }));
        var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const tempObj = {
            apiCall: _helper__WEBPACK_IMPORTED_MODULE_0__.b,
            logger: con.m("MAL Search"),
            errorObj: (code, message) => ({
                code: code,
                message: message
            }),
            type: "anime"
        };
        function search(keyword, type, options = {}, sync = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                return tempObj.type = type, (keyword = keyword.trim()).length > 64 && (keyword = keyword.substr(0, 64)), 
                tempObj.apiCall({
                    type: "GET",
                    path: `${type}?q=${keyword}&limit=15&nsfw=true`,
                    fields: [ "start_date", "mean", "alternative_titles", "media_type" ]
                }).then(json => {
                    const resItems = [];
                    return json.data.forEach((function(item) {
                        var _a, _b;
                        let alt = [ item.node.title ];
                        item.node.alternative_titles && (item.node.alternative_titles.en && alt.push(item.node.alternative_titles.en), 
                        item.node.alternative_titles.ja && alt.push(item.node.alternative_titles.ja), item.node.alternative_titles.synonyms && (alt = alt.concat(item.node.alternative_titles.synonyms))), 
                        resItems.push({
                            id: item.node.id,
                            name: item.node.title,
                            altNames: alt,
                            url: `https://myanimelist.net/${type}/${item.node.id}`,
                            malUrl: () => `https://myanimelist.net/${type}/${item.node.id}`,
                            image: null !== (_b = null === (_a = item.node.main_picture) || void 0 === _a ? void 0 : _a.medium) && void 0 !== _b ? _b : "",
                            media_type: item.node.media_type ? (item.node.media_type.charAt(0) + item.node.media_type.slice(1).toLowerCase()).replace("_", " ") : "",
                            isNovel: item.node.media_type.toLowerCase().includes("novel"),
                            score: item.node.mean,
                            year: item.node.start_date
                        });
                    })), tempObj.logger.log(resItems), resItems;
                });
            }));
        }
    }).call(this, __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaHere;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getInter;
        }));
        const MangaHere = getInter();
        function getInter() {
            let thisSelf;
            return thisSelf = {
                name: "MangaHere",
                domain: "http://www.mangahere.cc",
                languages: [ "English" ],
                database: "MangaFox",
                type: "manga",
                isSyncPage: url => !(void 0 === url.split("/")[5] || !url.split("/")[5].length),
                isOverviewPage: url => !(void 0 === url.split("/")[4] || !url.split("/")[4].length || thisSelf.isSyncPage(url)),
                sync: {
                    getTitle: url => j.$("p.reader-header-title-1 > a:nth-child(1)").text(),
                    getIdentifier: url => url.split("/")[4],
                    getOverviewUrl: url => utils.absoluteLink(j.$("p.reader-header-title-1 > a:nth-child(1)").attr("href"), thisSelf.domain),
                    getEpisode: url => getChapterNumber(j.$("p.reader-header-title-2").text()),
                    getVolume(url) {
                        let temp = j.$("p.reader-header-title-2").text().match(/(vol\.|volume)\D?\d+/i);
                        return null !== temp && (temp = temp[0].match(/\d+/), null !== temp) ? parseInt(temp[0]) : NaN;
                    },
                    nextEpUrl(url) {
                        const href = j.$('div.pager-list-left > a:contains("Next Chapter")').attr("href");
                        return href ? utils.absoluteLink(href, thisSelf.domain) : "";
                    }
                },
                overview: {
                    getTitle: url => j.$("span.detail-info-right-title-font").first().text(),
                    getIdentifier: url => utils.urlPart(url, 4),
                    uiSelector(selector) {
                        j.$("div.detail-main").first().before(j.html(selector));
                    },
                    list: {
                        offsetHandler: !1,
                        elementsSelector: () => j.$("ul.detail-main-list > li"),
                        elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href") || "", thisSelf.domain),
                        elementEp: selector => getChapterNumber(selector.find("a > div > p.title3").text())
                    }
                },
                init(page) {
                    api.storage.addStyle(__webpack_require__(463).toString()), j.$(document).ready((function() {
                        page.handlePage();
                    }));
                }
            }, thisSelf;
        }
        function getChapterNumber(text) {
            let temp = text.match(/(ch\.|chapter)\D?\d+/i);
            return null !== temp && (temp = temp[0].match(/\d+/), null !== temp) ? parseInt(temp[0]) : 1;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return pages;
    }));
    var main = __webpack_require__(134), Crunchyroll_main = __webpack_require__(135), Mangadex_main = __webpack_require__(136), Gogoanime_main = __webpack_require__(137), Branitube_main = __webpack_require__(138), TurkAnime_main = __webpack_require__(139), Twistmoe_main = __webpack_require__(140), Emby_main = __webpack_require__(141), Plex_main = __webpack_require__(142), Netflix_main = __webpack_require__(143), animepahe_main = __webpack_require__(144), Animeflv_main = __webpack_require__(145), Jkanime_main = __webpack_require__(146), Vrv_main = __webpack_require__(147), Proxer_main = __webpack_require__(148), fourAnime_main = __webpack_require__(149), animeultima_main = __webpack_require__(150), Aniflix_main = __webpack_require__(151), Animefreak_main = __webpack_require__(152), AnimeLab_main = __webpack_require__(153), KickAssAnime_main = __webpack_require__(154), AnimeKisa_main = __webpack_require__(155), Wakanim_main = __webpack_require__(156), AnimeIndo_main = __webpack_require__(157), Shinden_main = __webpack_require__(158), Voiranime_main = __webpack_require__(159), DubbedAnime_main = __webpack_require__(160), VIZ_main = __webpack_require__(161), MangaNato_main = __webpack_require__(162), NekoSama_main = __webpack_require__(163), AnimeZone_main = __webpack_require__(164), AnimeOdcinki_main = __webpack_require__(165), Animeflix_main = __webpack_require__(166), serimanga_main = __webpack_require__(167), mangadenizi_main = __webpack_require__(168), moeclip_main = __webpack_require__(169), mangalivre_main = __webpack_require__(170), tmofans_main = __webpack_require__(171), unionmangas_main = __webpack_require__(172), MangaPlus_main = __webpack_require__(173), JapScan_main = __webpack_require__(174), Goyabu_main = __webpack_require__(175), AnimesVision_main = __webpack_require__(176), Hulu_main = __webpack_require__(177), Hidive_main = __webpack_require__(178), FallenAngels_main = __webpack_require__(179), PrimeVideo_main = __webpack_require__(180), MangaKatana_main = __webpack_require__(181), manga4life_main = __webpack_require__(182), bato_main = __webpack_require__(183), DreamSub_main = __webpack_require__(184), MangaPark_main = __webpack_require__(185), AnimesHouse_main = __webpack_require__(186), AnimeXin_main = __webpack_require__(187), MonosChinos_main = __webpack_require__(188), AnimeFire_main = __webpack_require__(189), OtakuFR_main = __webpack_require__(190), Samehadaku_main = __webpack_require__(191), TsukiMangas_main = __webpack_require__(192), mangatx_main = __webpack_require__(193), TRanimeizle_main = __webpack_require__(194), Anihub_main = __webpack_require__(195), AnimeStreamingFR_main = __webpack_require__(196), Scantrad_main = __webpack_require__(197), Furyosquad_main = __webpack_require__(198), AnimeId_main = __webpack_require__(199), AniMixPlay_main = __webpack_require__(200), MyAnimeListVideo_main = __webpack_require__(201), AnimeSimple_main = __webpack_require__(202), AnimeUnity_main = __webpack_require__(203), MangaHere_main = __webpack_require__(83);
    const clone = Object(MangaHere_main.b)();
    clone.name = "MangaFox", clone.domain = [ "http://fanfox.net", "http://mangafox.la" ];
    const MangaFox = clone;
    var JustAnime_main = __webpack_require__(204), YayAnimes_main = __webpack_require__(205), DesuOnline_main = __webpack_require__(206), Simplyaweeb_main = __webpack_require__(207), Animevibe_main = __webpack_require__(208), WuxiaWorld_main = __webpack_require__(209), AnimeOnDemand_main = __webpack_require__(210), ZeroScans_main = __webpack_require__(12);
    const main_clone = Object(ZeroScans_main.b)();
    main_clone.name = "EdelgardeScans", main_clone.domain = "https://edelgardescans.com";
    const EdelgardeScans = main_clone, HatigarmScanz_main_clone = Object(ZeroScans_main.b)();
    HatigarmScanz_main_clone.name = "HatigarmScanz", HatigarmScanz_main_clone.domain = "https://hatigarmscanz.net";
    const HatigarmScanz = HatigarmScanz_main_clone;
    var LeviatanScans_main = __webpack_require__(211);
    const MethodScans_main_clone = Object(ZeroScans_main.b)();
    MethodScans_main_clone.name = "MethodScans", MethodScans_main_clone.domain = "https://methodscans.com";
    const MethodScans = MethodScans_main_clone, NonamesScans_main_clone = Object(ZeroScans_main.b)();
    NonamesScans_main_clone.name = "NonamesScans", NonamesScans_main_clone.domain = "https://the-nonames.com";
    const NonamesScans = NonamesScans_main_clone, ReaperScans_main_clone = Object(ZeroScans_main.b)();
    ReaperScans_main_clone.name = "ReaperScans", ReaperScans_main_clone.domain = "https://reaperscans.com";
    const ReaperScans = ReaperScans_main_clone, LynxScans_main_clone = Object(ZeroScans_main.b)();
    LynxScans_main_clone.name = "LynxScans", LynxScans_main_clone.domain = "https://lynxscans.com";
    const LynxScans = LynxScans_main_clone;
    var SKScans_main = __webpack_require__(212), DeathTollScans_main = __webpack_require__(213), KireiCake_main = __webpack_require__(214), SenseScans_main = __webpack_require__(215), ManhuaPlus_main = __webpack_require__(216), Readm_main = __webpack_require__(217), tioanime_main = __webpack_require__(218), YugenAnime_main = __webpack_require__(219), MangaSee_main = __webpack_require__(220), AnimeTribes_main = __webpack_require__(221), Okanime_main = __webpack_require__(222), BSTO_main = __webpack_require__(223), Pantsubase_main = __webpack_require__(224), AnimeOwl_main = __webpack_require__(225), AsuraScans_main = __webpack_require__(226), NaniScans_main = __webpack_require__(227), MerakiScans_main = __webpack_require__(228), Jellyfin_main = __webpack_require__(229), An1me_main = __webpack_require__(230), MangaJar_main = __webpack_require__(231), AnimeDao_main = __webpack_require__(232), Otakustv_main = __webpack_require__(233), Komga_main = __webpack_require__(234), AnimeWho_main = __webpack_require__(235), AnimeSuge_main = __webpack_require__(236), Toonily_main = __webpack_require__(237), Fumetsu_main = __webpack_require__(238), NonstopScans_main = __webpack_require__(239), FrixySubs_main = __webpack_require__(240), Guya_main = __webpack_require__(241), MangaHub_main = __webpack_require__(242), ComicK_main = __webpack_require__(243), AnimeShitai_main = __webpack_require__(244), KangaryuTeam_main = __webpack_require__(245), Japanread_main = __webpack_require__(246), CatManga_main = __webpack_require__(247), MangaSushi_main = __webpack_require__(248), ArangScans_main = __webpack_require__(249);
    const HunlightScans_main_clone = Object(ZeroScans_main.b)();
    HunlightScans_main_clone.name = "HunlightScans", HunlightScans_main_clone.domain = "https://hunlight-scans.info/";
    const HunlightScans = HunlightScans_main_clone;
    var TritiniaScans_main = __webpack_require__(250), ReadManhua_main = __webpack_require__(251), FlameScans_main = __webpack_require__(252), ImmortalUpdates_main = __webpack_require__(253), Zoro_main = __webpack_require__(254), Funimation_main = __webpack_require__(255), Kitsune_main = __webpack_require__(256), AnimesOnline_main = __webpack_require__(257), LHTranslation_main = __webpack_require__(258);
    const pages = {
        nineAnime: main.a,
        Crunchyroll: Crunchyroll_main.a,
        Vrv: Vrv_main.a,
        Mangadex: Mangadex_main.a,
        Gogoanime: Gogoanime_main.a,
        Twistmoe: Twistmoe_main.a,
        Branitube: Branitube_main.a,
        TurkAnime: TurkAnime_main.a,
        animepahe: animepahe_main.a,
        Netflix: Netflix_main.a,
        Animeflv: Animeflv_main.a,
        Jkanime: Jkanime_main.a,
        Proxer: Proxer_main.a,
        Wakanim: Wakanim_main.a,
        Emby: Emby_main.a,
        Plex: Plex_main.a,
        fourAnime: fourAnime_main.a,
        animeultima: animeultima_main.a,
        Aniflix: Aniflix_main.a,
        Animefreak: Animefreak_main.a,
        AnimeLab: AnimeLab_main.a,
        KickAssAnime: KickAssAnime_main.a,
        AnimeKisa: AnimeKisa_main.a,
        AnimeIndo: AnimeIndo_main.a,
        Shinden: Shinden_main.a,
        Voiranime: Voiranime_main.a,
        DubbedAnime: DubbedAnime_main.a,
        MangaNato: MangaNato_main.a,
        VIZ: VIZ_main.a,
        NekoSama: NekoSama_main.a,
        AnimeOdcinki: AnimeOdcinki_main.a,
        AnimeZone: AnimeZone_main.a,
        Animeflix: Animeflix_main.a,
        serimanga: serimanga_main.a,
        mangadenizi: mangadenizi_main.a,
        moeclip: moeclip_main.a,
        mangalivre: mangalivre_main.a,
        tmofans: tmofans_main.a,
        unionmangas: unionmangas_main.a,
        MangaPlus: MangaPlus_main.a,
        JapScan: JapScan_main.a,
        Goyabu: Goyabu_main.a,
        AnimesVision: AnimesVision_main.a,
        Hulu: Hulu_main.a,
        Hidive: Hidive_main.a,
        FallenAngels: FallenAngels_main.a,
        PrimeVideo: PrimeVideo_main.a,
        MangaKatana: MangaKatana_main.a,
        manga4life: manga4life_main.a,
        bato: bato_main.a,
        DreamSub: DreamSub_main.a,
        MangaPark: MangaPark_main.a,
        AnimesHouse: AnimesHouse_main.a,
        AnimeXin: AnimeXin_main.a,
        MonosChinos: MonosChinos_main.a,
        AnimeFire: AnimeFire_main.a,
        OtakuFR: OtakuFR_main.a,
        Samehadaku: Samehadaku_main.a,
        TsukiMangas: TsukiMangas_main.a,
        mangatx: mangatx_main.a,
        TRanimeizle: TRanimeizle_main.a,
        Anihub: Anihub_main.a,
        AnimeStreamingFR: AnimeStreamingFR_main.a,
        Scantrad: Scantrad_main.a,
        Furyosquad: Furyosquad_main.a,
        AnimeId: AnimeId_main.a,
        AniMixPlay: AniMixPlay_main.a,
        MyAnimeListVideo: MyAnimeListVideo_main.a,
        AnimeSimple: AnimeSimple_main.a,
        AnimeUnity: AnimeUnity_main.a,
        MangaHere: MangaHere_main.a,
        MangaFox: MangaFox,
        JustAnime: JustAnime_main.a,
        YayAnimes: YayAnimes_main.a,
        DesuOnline: DesuOnline_main.a,
        Simplyaweeb: Simplyaweeb_main.a,
        Animevibe: Animevibe_main.a,
        WuxiaWorld: WuxiaWorld_main.a,
        AnimeOnDemand: AnimeOnDemand_main.a,
        EdelgardeScans: EdelgardeScans,
        HatigarmScanz: HatigarmScanz,
        LeviatanScans: LeviatanScans_main.a,
        MethodScans: MethodScans,
        NonamesScans: NonamesScans,
        ReaperScans: ReaperScans,
        LynxScans: LynxScans,
        SKScans: SKScans_main.a,
        ZeroScans: ZeroScans_main.a,
        DeathTollScans: DeathTollScans_main.a,
        KireiCake: KireiCake_main.a,
        SenseScans: SenseScans_main.a,
        ManhuaPlus: ManhuaPlus_main.a,
        Readm: Readm_main.a,
        tioanime: tioanime_main.a,
        YugenAnime: YugenAnime_main.a,
        MangaSee: MangaSee_main.a,
        AnimeTribes: AnimeTribes_main.a,
        Okanime: Okanime_main.a,
        BSTO: BSTO_main.a,
        Pantsubase: Pantsubase_main.a,
        AnimeOwl: AnimeOwl_main.a,
        AsuraScans: AsuraScans_main.a,
        NaniScans: NaniScans_main.a,
        MerakiScans: MerakiScans_main.a,
        Jellyfin: Jellyfin_main.a,
        An1me: An1me_main.a,
        MangaJar: MangaJar_main.a,
        AnimeDao: AnimeDao_main.a,
        Otakustv: Otakustv_main.a,
        Komga: Komga_main.a,
        AnimeWho: AnimeWho_main.a,
        AnimeSuge: AnimeSuge_main.a,
        Toonily: Toonily_main.a,
        Fumetsu: Fumetsu_main.a,
        NonstopScans: NonstopScans_main.a,
        FrixySubs: FrixySubs_main.a,
        Guya: Guya_main.a,
        MangaHub: MangaHub_main.a,
        ComicK: ComicK_main.a,
        AnimeShitai: AnimeShitai_main.a,
        KangaryuTeam: KangaryuTeam_main.a,
        Japanread: Japanread_main.a,
        CatManga: CatManga_main.a,
        MangaSushi: MangaSushi_main.a,
        ArangScans: ArangScans_main.a,
        HunlightScans: HunlightScans,
        TritiniaScans: TritiniaScans_main.a,
        ReadManhua: ReadManhua_main.a,
        FlameScans: FlameScans_main.a,
        ImmortalUpdates: ImmortalUpdates_main.a,
        Zoro: Zoro_main.a,
        Funimation: Funimation_main.a,
        Kitsune: Kitsune_main.a,
        AnimesOnline: AnimesOnline_main.a,
        LHTranslation: LHTranslation_main.a
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("div", {
            staticClass: "icon material-icons",
            staticStyle: {
                "font-size": "16px",
                "line-height": "0",
                color: "#7f7f7f",
                "padding-bottom": "20px",
                "padding-left": "3px"
            },
            style: _vm.tagStyle,
            attrs: {
                id: _vm.id
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.iconText) + "\n  ") ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-tooltip mdl-tooltip--large",
            class: _vm.directionClass,
            attrs: {
                for: _vm.id
            }
        }, [ _vm._t("default") ], 2) ]);
    };
    render._withStripped = !0;
    var components_tooltipvue_type_script_lang_js_ = {
        props: {
            direction: {
                type: String,
                default: "top"
            },
            tagStyle: {
                type: String,
                default: ""
            },
            iconText: {
                type: String,
                default: "contact_support"
            }
        },
        data: () => ({
            number: Math.floor(1e3 * Math.random() + 1)
        }),
        computed: {
            id() {
                return "tt-" + this.number;
            },
            directionClass() {
                return "mdl-tooltip--" + this.direction;
            }
        }
    }, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_tooltipvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/tooltip.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return client_id;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return simklIdToMal;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return call;
        }));
        var _templates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const client_id = "39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0";
        function simklIdToMal(simklId) {
            return call("https://api.simkl.com/anime/" + simklId, {
                extended: "full"
            }, !0).then(res => void 0 === res.ids.mal ? null : res.ids.mal);
        }
        function call(url, sData = {}, asParameter = !1, methode = "GET", login = !0) {
            return __awaiter(this, void 0, void 0, (function*() {
                asParameter && (url += "?" + j.$.param(sData)), con.log("call", methode, url, sData);
                const headers = {
                    Authorization: login ? "Bearer " + api.settings.get("simklToken") : void 0,
                    "simkl-api-key": client_id,
                    Accept: "application/vnd.api+json",
                    "Content-Type": "application/json"
                };
                return login || con.log("No login"), api.request.xhr(methode, {
                    url: url,
                    headers: headers,
                    data: sData
                }).then(response => __awaiter(this, void 0, void 0, (function*() {
                    switch (response.status) {
                      case 200:
                      case 201:
                      case 204:
                      case 302:
                        break;

                      case 401:
                        if (login) return call(url, sData, asParameter, methode, !1);
                        throw utils.flashm(_templates__WEBPACK_IMPORTED_MODULE_0__.a.noLogin, {
                            error: !0,
                            type: "error"
                        }), getThrowError();

                      default:
                        throw utils.flashm("Simkl: " + getErrorText(), {
                            error: !0,
                            type: "error"
                        }), getThrowError();
                    }
                    try {
                        return JSON.parse(response.responseText);
                    } catch (e) {
                        throw con.error(response), e;
                    }
                    function getErrorText() {
                        return JSON.parse(response.responseText).error;
                    }
                    function getThrowError() {
                        return {
                            status: response.status,
                            message: getErrorText()
                        };
                    }
                })));
            }));
        }
    }).call(this, __webpack_require__(2), __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, exports) {
    var g;
    g = function() {
        return this;
    }();
    try {
        g = g || new Function("return this")();
    } catch (e) {
        "object" == typeof window && (g = window);
    }
    module.exports = g;
}, function(module, exports, __webpack_require__) {
    module.exports = function() {
        "use strict";
        var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, freeze = Object.freeze, seal = Object.seal, create = Object.create, _ref = "undefined" != typeof Reflect && Reflect, apply = _ref.apply, construct = _ref.construct;
        apply || (apply = function(fun, thisValue, args) {
            return fun.apply(thisValue, args);
        }), freeze || (freeze = function(x) {
            return x;
        }), seal || (seal = function(x) {
            return x;
        }), construct || (construct = function(Func, args) {
            return new (Function.prototype.bind.apply(Func, [ null ].concat(function(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2;
                }
                return Array.from(arr);
            }(args))));
        });
        var func, arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = (func = TypeError, 
        function() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
            return construct(func, args);
        });
        function unapply(func) {
            return function(thisArg) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                return apply(func, thisArg, args);
            };
        }
        function addToSet(set, array) {
            setPrototypeOf && setPrototypeOf(set, null);
            for (var l = array.length; l--; ) {
                var element = array[l];
                if ("string" == typeof element) {
                    var lcElement = stringToLowerCase(element);
                    lcElement !== element && (isFrozen(array) || (array[l] = lcElement), element = lcElement);
                }
                set[element] = !0;
            }
            return set;
        }
        function clone(object) {
            var newObject = create(null), property = void 0;
            for (property in object) apply(hasOwnProperty, object, [ property ]) && (newObject[property] = object[property]);
            return newObject;
        }
        var html = freeze([ "a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr" ]), svg = freeze([ "svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "audio", "canvas", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "video", "view", "vkern" ]), svgFilters = freeze([ "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence" ]), mathMl = freeze([ "math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover" ]), text = freeze([ "#text" ]), html$1 = freeze([ "accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns" ]), svg$1 = freeze([ "accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan" ]), mathMl$1 = freeze([ "accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns" ]), xml = freeze([ "xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink" ]), MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _toConsumableArray$1(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        var getGlobal = function() {
            return "undefined" == typeof window ? null : window;
        }, _createTrustedTypesPolicy = function(trustedTypes, document) {
            if ("object" !== (void 0 === trustedTypes ? "undefined" : _typeof(trustedTypes)) || "function" != typeof trustedTypes.createPolicy) return null;
            var suffix = null;
            document.currentScript && document.currentScript.hasAttribute("data-tt-policy-suffix") && (suffix = document.currentScript.getAttribute("data-tt-policy-suffix"));
            var policyName = "dompurify" + (suffix ? "#" + suffix : "");
            try {
                return trustedTypes.createPolicy(policyName, {
                    createHTML: function(html$$1) {
                        return html$$1;
                    }
                });
            } catch (_) {
                return console.warn("TrustedTypes policy " + policyName + " could not be created."), 
                null;
            }
        };
        return function createDOMPurify() {
            var window = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : getGlobal(), DOMPurify = function(root) {
                return createDOMPurify(root);
            };
            if (DOMPurify.version = "2.1.1", DOMPurify.removed = [], !window || !window.document || 9 !== window.document.nodeType) return DOMPurify.isSupported = !1, 
            DOMPurify;
            var originalDocument = window.document, document = window.document, DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = void 0 === _window$NamedNodeMap ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, Text = window.Text, Comment = window.Comment, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;
            if ("function" == typeof HTMLTemplateElement) {
                var template = document.createElement("template");
                template.content && template.content.ownerDocument && (document = template.content.ownerDocument);
            }
            var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument), emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "", _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, getElementsByTagName = _document.getElementsByTagName, createDocumentFragment = _document.createDocumentFragment, importNode = originalDocument.importNode, documentMode = {};
            try {
                documentMode = clone(document).documentMode ? document.documentMode : {};
            } catch (_) {}
            var hooks = {};
            DOMPurify.isSupported = implementation && void 0 !== implementation.createHTMLDocument && 9 !== documentMode;
            var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE, IS_ALLOWED_URI$$1 = IS_ALLOWED_URI, ALLOWED_TAGS = null, DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text))), ALLOWED_ATTR = null, DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml))), FORBID_TAGS = null, FORBID_ATTR = null, ALLOW_ARIA_ATTR = !0, ALLOW_DATA_ATTR = !0, ALLOW_UNKNOWN_PROTOCOLS = !1, SAFE_FOR_TEMPLATES = !1, WHOLE_DOCUMENT = !1, SET_CONFIG = !1, FORCE_BODY = !1, RETURN_DOM = !1, RETURN_DOM_FRAGMENT = !1, RETURN_DOM_IMPORT = !1, RETURN_TRUSTED_TYPE = !1, SANITIZE_DOM = !0, KEEP_CONTENT = !0, IN_PLACE = !1, USE_PROFILES = {}, FORBID_CONTENTS = addToSet({}, [ "annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp" ]), DATA_URI_TAGS = null, DEFAULT_DATA_URI_TAGS = addToSet({}, [ "audio", "video", "img", "source", "image", "track" ]), URI_SAFE_ATTRIBUTES = null, DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [ "alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "summary", "title", "value", "style", "xmlns" ]), CONFIG = null, formElement = document.createElement("form"), _parseConfig = function(cfg) {
                CONFIG && CONFIG === cfg || (cfg && "object" === (void 0 === cfg ? "undefined" : _typeof(cfg)) || (cfg = {}), 
                cfg = clone(cfg), ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS, 
                ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR, 
                URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES, 
                DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS, 
                FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {}, FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {}, 
                USE_PROFILES = "USE_PROFILES" in cfg && cfg.USE_PROFILES, ALLOW_ARIA_ATTR = !1 !== cfg.ALLOW_ARIA_ATTR, 
                ALLOW_DATA_ATTR = !1 !== cfg.ALLOW_DATA_ATTR, ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || !1, 
                SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || !1, WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || !1, 
                RETURN_DOM = cfg.RETURN_DOM || !1, RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || !1, 
                RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || !1, RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || !1, 
                FORCE_BODY = cfg.FORCE_BODY || !1, SANITIZE_DOM = !1 !== cfg.SANITIZE_DOM, KEEP_CONTENT = !1 !== cfg.KEEP_CONTENT, 
                IN_PLACE = cfg.IN_PLACE || !1, IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1, 
                SAFE_FOR_TEMPLATES && (ALLOW_DATA_ATTR = !1), RETURN_DOM_FRAGMENT && (RETURN_DOM = !0), 
                USE_PROFILES && (ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text))), 
                ALLOWED_ATTR = [], !0 === USE_PROFILES.html && (addToSet(ALLOWED_TAGS, html), addToSet(ALLOWED_ATTR, html$1)), 
                !0 === USE_PROFILES.svg && (addToSet(ALLOWED_TAGS, svg), addToSet(ALLOWED_ATTR, svg$1), 
                addToSet(ALLOWED_ATTR, xml)), !0 === USE_PROFILES.svgFilters && (addToSet(ALLOWED_TAGS, svgFilters), 
                addToSet(ALLOWED_ATTR, svg$1), addToSet(ALLOWED_ATTR, xml)), !0 === USE_PROFILES.mathMl && (addToSet(ALLOWED_TAGS, mathMl), 
                addToSet(ALLOWED_ATTR, mathMl$1), addToSet(ALLOWED_ATTR, xml))), cfg.ADD_TAGS && (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS && (ALLOWED_TAGS = clone(ALLOWED_TAGS)), 
                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS)), cfg.ADD_ATTR && (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR && (ALLOWED_ATTR = clone(ALLOWED_ATTR)), 
                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR)), cfg.ADD_URI_SAFE_ATTR && addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR), 
                KEEP_CONTENT && (ALLOWED_TAGS["#text"] = !0), WHOLE_DOCUMENT && addToSet(ALLOWED_TAGS, [ "html", "head", "body" ]), 
                ALLOWED_TAGS.table && (addToSet(ALLOWED_TAGS, [ "tbody" ]), delete FORBID_TAGS.tbody), 
                freeze && freeze(cfg), CONFIG = cfg);
            }, _forceRemove = function(node) {
                arrayPush(DOMPurify.removed, {
                    element: node
                });
                try {
                    node.parentNode.removeChild(node);
                } catch (_) {
                    node.outerHTML = emptyHTML;
                }
            }, _removeAttribute = function(name, node) {
                try {
                    arrayPush(DOMPurify.removed, {
                        attribute: node.getAttributeNode(name),
                        from: node
                    });
                } catch (_) {
                    arrayPush(DOMPurify.removed, {
                        attribute: null,
                        from: node
                    });
                }
                node.removeAttribute(name);
            }, _initDocument = function(dirty) {
                var doc = void 0, leadingWhitespace = void 0;
                if (FORCE_BODY) dirty = "<remove></remove>" + dirty; else {
                    var matches = stringMatch(dirty, /^[\r\n\t ]+/);
                    leadingWhitespace = matches && matches[0];
                }
                var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
                try {
                    doc = (new DOMParser).parseFromString(dirtyPayload, "text/html");
                } catch (_) {}
                if (!doc || !doc.documentElement) {
                    var body = (doc = implementation.createHTMLDocument("")).body;
                    body.parentNode.removeChild(body.parentNode.firstElementChild), body.outerHTML = dirtyPayload;
                }
                return dirty && leadingWhitespace && doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null), 
                getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
            }, _createIterator = function(root) {
                return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, (function() {
                    return NodeFilter.FILTER_ACCEPT;
                }), !1);
            }, _isClobbered = function(elm) {
                return !(elm instanceof Text || elm instanceof Comment || "string" == typeof elm.nodeName && "string" == typeof elm.textContent && "function" == typeof elm.removeChild && elm.attributes instanceof NamedNodeMap && "function" == typeof elm.removeAttribute && "function" == typeof elm.setAttribute && "string" == typeof elm.namespaceURI);
            }, _isNode = function(object) {
                return "object" === (void 0 === Node ? "undefined" : _typeof(Node)) ? object instanceof Node : object && "object" === (void 0 === object ? "undefined" : _typeof(object)) && "number" == typeof object.nodeType && "string" == typeof object.nodeName;
            }, _executeHook = function(entryPoint, currentNode, data) {
                hooks[entryPoint] && arrayForEach(hooks[entryPoint], (function(hook) {
                    hook.call(DOMPurify, currentNode, data, CONFIG);
                }));
            }, _sanitizeElements = function(currentNode) {
                var content = void 0;
                if (_executeHook("beforeSanitizeElements", currentNode, null), _isClobbered(currentNode)) return _forceRemove(currentNode), 
                !0;
                if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) return _forceRemove(currentNode), 
                !0;
                var tagName = stringToLowerCase(currentNode.nodeName);
                if (_executeHook("uponSanitizeElement", currentNode, {
                    tagName: tagName,
                    allowedTags: ALLOWED_TAGS
                }), ("svg" === tagName || "math" === tagName) && 0 !== currentNode.querySelectorAll("p, br").length) return _forceRemove(currentNode), 
                !0;
                if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[!/\w]/g, currentNode.innerHTML) && regExpTest(/<[!/\w]/g, currentNode.textContent)) return _forceRemove(currentNode), 
                !0;
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                    if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && "function" == typeof currentNode.insertAdjacentHTML) try {
                        var htmlToInsert = currentNode.innerHTML;
                        currentNode.insertAdjacentHTML("AfterEnd", trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
                    } catch (_) {}
                    return _forceRemove(currentNode), !0;
                }
                return "noscript" !== tagName && "noembed" !== tagName || !regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML) ? (SAFE_FOR_TEMPLATES && 3 === currentNode.nodeType && (content = currentNode.textContent, 
                content = stringReplace(content, MUSTACHE_EXPR$$1, " "), content = stringReplace(content, ERB_EXPR$$1, " "), 
                currentNode.textContent !== content && (arrayPush(DOMPurify.removed, {
                    element: currentNode.cloneNode()
                }), currentNode.textContent = content)), _executeHook("afterSanitizeElements", currentNode, null), 
                !1) : (_forceRemove(currentNode), !0);
            }, _isValidAttribute = function(lcTag, lcName, value) {
                if (SANITIZE_DOM && ("id" === lcName || "name" === lcName) && (value in document || value in formElement)) return !1;
                if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else {
                    if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) return !1;
                    if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ; else if ("src" !== lcName && "xlink:href" !== lcName && "href" !== lcName || "script" === lcTag || 0 !== stringIndexOf(value, "data:") || !DATA_URI_TAGS[lcTag]) if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ; else if (value) return !1;
                }
                return !0;
            }, _sanitizeAttributes = function(currentNode) {
                var attr = void 0, value = void 0, lcName = void 0, l = void 0;
                _executeHook("beforeSanitizeAttributes", currentNode, null);
                var attributes = currentNode.attributes;
                if (attributes) {
                    var hookEvent = {
                        attrName: "",
                        attrValue: "",
                        keepAttr: !0,
                        allowedAttributes: ALLOWED_ATTR
                    };
                    for (l = attributes.length; l--; ) {
                        var _attr = attr = attributes[l], name = _attr.name, namespaceURI = _attr.namespaceURI;
                        if (value = stringTrim(attr.value), lcName = stringToLowerCase(name), hookEvent.attrName = lcName, 
                        hookEvent.attrValue = value, hookEvent.keepAttr = !0, hookEvent.forceKeepAttr = void 0, 
                        _executeHook("uponSanitizeAttribute", currentNode, hookEvent), value = hookEvent.attrValue, 
                        !hookEvent.forceKeepAttr && (_removeAttribute(name, currentNode), hookEvent.keepAttr)) if (regExpTest(/\/>/i, value)) _removeAttribute(name, currentNode); else {
                            SAFE_FOR_TEMPLATES && (value = stringReplace(value, MUSTACHE_EXPR$$1, " "), value = stringReplace(value, ERB_EXPR$$1, " "));
                            var lcTag = currentNode.nodeName.toLowerCase();
                            if (_isValidAttribute(lcTag, lcName, value)) try {
                                namespaceURI ? currentNode.setAttributeNS(namespaceURI, name, value) : currentNode.setAttribute(name, value), 
                                arrayPop(DOMPurify.removed);
                            } catch (_) {}
                        }
                    }
                    _executeHook("afterSanitizeAttributes", currentNode, null);
                }
            }, _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
                var shadowNode = void 0, shadowIterator = _createIterator(fragment);
                for (_executeHook("beforeSanitizeShadowDOM", fragment, null); shadowNode = shadowIterator.nextNode(); ) _executeHook("uponSanitizeShadowNode", shadowNode, null), 
                _sanitizeElements(shadowNode) || (shadowNode.content instanceof DocumentFragment && _sanitizeShadowDOM(shadowNode.content), 
                _sanitizeAttributes(shadowNode));
                _executeHook("afterSanitizeShadowDOM", fragment, null);
            };
            return DOMPurify.sanitize = function(dirty, cfg) {
                var body = void 0, importedNode = void 0, currentNode = void 0, oldNode = void 0, returnNode = void 0;
                if (dirty || (dirty = "\x3c!--\x3e"), "string" != typeof dirty && !_isNode(dirty)) {
                    if ("function" != typeof dirty.toString) throw typeErrorCreate("toString is not a function");
                    if ("string" != typeof (dirty = dirty.toString())) throw typeErrorCreate("dirty is not a string, aborting");
                }
                if (!DOMPurify.isSupported) {
                    if ("object" === _typeof(window.toStaticHTML) || "function" == typeof window.toStaticHTML) {
                        if ("string" == typeof dirty) return window.toStaticHTML(dirty);
                        if (_isNode(dirty)) return window.toStaticHTML(dirty.outerHTML);
                    }
                    return dirty;
                }
                if (SET_CONFIG || _parseConfig(cfg), DOMPurify.removed = [], "string" == typeof dirty && (IN_PLACE = !1), 
                IN_PLACE) ; else if (dirty instanceof Node) 1 === (importedNode = (body = _initDocument("\x3c!----\x3e")).ownerDocument.importNode(dirty, !0)).nodeType && "BODY" === importedNode.nodeName || "HTML" === importedNode.nodeName ? body = importedNode : body.appendChild(importedNode); else {
                    if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && -1 === dirty.indexOf("<")) return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
                    if (!(body = _initDocument(dirty))) return RETURN_DOM ? null : emptyHTML;
                }
                body && FORCE_BODY && _forceRemove(body.firstChild);
                for (var nodeIterator = _createIterator(IN_PLACE ? dirty : body); currentNode = nodeIterator.nextNode(); ) 3 === currentNode.nodeType && currentNode === oldNode || _sanitizeElements(currentNode) || (currentNode.content instanceof DocumentFragment && _sanitizeShadowDOM(currentNode.content), 
                _sanitizeAttributes(currentNode), oldNode = currentNode);
                if (oldNode = null, IN_PLACE) return dirty;
                if (RETURN_DOM) {
                    if (RETURN_DOM_FRAGMENT) for (returnNode = createDocumentFragment.call(body.ownerDocument); body.firstChild; ) returnNode.appendChild(body.firstChild); else returnNode = body;
                    return RETURN_DOM_IMPORT && (returnNode = importNode.call(originalDocument, returnNode, !0)), 
                    returnNode;
                }
                var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
                return SAFE_FOR_TEMPLATES && (serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " "), 
                serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ")), trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
            }, DOMPurify.setConfig = function(cfg) {
                _parseConfig(cfg), SET_CONFIG = !0;
            }, DOMPurify.clearConfig = function() {
                CONFIG = null, SET_CONFIG = !1;
            }, DOMPurify.isValidAttribute = function(tag, attr, value) {
                CONFIG || _parseConfig({});
                var lcTag = stringToLowerCase(tag), lcName = stringToLowerCase(attr);
                return _isValidAttribute(lcTag, lcName, value);
            }, DOMPurify.addHook = function(entryPoint, hookFunction) {
                "function" == typeof hookFunction && (hooks[entryPoint] = hooks[entryPoint] || [], 
                arrayPush(hooks[entryPoint], hookFunction));
            }, DOMPurify.removeHook = function(entryPoint) {
                hooks[entryPoint] && arrayPop(hooks[entryPoint]);
            }, DOMPurify.removeHooks = function(entryPoint) {
                hooks[entryPoint] && (hooks[entryPoint] = []);
            }, DOMPurify.removeAllHooks = function() {
                hooks = {};
            }, DOMPurify;
        }();
    }();
}, function(module) {
    module.exports = JSON.parse('[{"name":"9anime","domain":"https://9anime.to","database":"9anime","search":{"anime":"https://9anime.to/search?keyword={searchtermPlus}","manga":null}},{"name":"Crunchyroll","domain":"https://www.crunchyroll.com","database":"Crunchyroll","search":{"anime":"https://www.crunchyroll.com/search?q={searchtermPlus}","manga":null}},{"name":"Vrv","domain":"https://vrv.co","database":"Vrv","search":{"anime":"https://vrv.co/?q={searchterm}","manga":null}},{"name":"Mangadex","domain":"https://www.mangadex.org","database":"Mangadex","search":{"anime":null,"manga":"https://mangadex.org/titles#{searchterm}"}},{"name":"Gogoanime","domain":"https://gogoanime.tv","database":"Gogoanime","search":{"anime":"https://www1.gogoanime.ai/search.html?keyword={searchterm}","manga":null}},{"name":"Twistmoe","domain":"https://twist.moe","database":"Twistmoe","search":{"anime":"home","manga":null}},{"name":"Branitube","domain":"https://www.branitube.net","database":null,"search":{"anime":"https://www.branitube.net/buscar/{searchterm}","manga":null}},{"name":"TurkAnime","domain":"https://www.turkanime.net","database":null,"search":{"anime":"home","manga":null}},{"name":"animepahe","domain":"https://animepahe.com","database":"animepahe","search":{"anime":"home","manga":null}},{"name":"Netflix","domain":"https://www.netflix.com","database":"Netflix","search":{"anime":"https://www.netflix.com/search?q={searchterm}","manga":null}},{"name":"Animeflv","domain":"https://animeflv.net","database":null,"search":{"anime":"https://www3.animeflv.net/browse?q={searchtermPlus}","manga":null}},{"name":"Jkanime","domain":"https://jkanime.net","database":null,"search":{"anime":"https://jkanime.net/buscar/{searchterm}","manga":null}},{"name":"Proxer","domain":"https://proxer.me","database":null,"search":{"anime":"https://proxer.me/search?s=search&name={searchterm}&typ=all-anime&tags=&notags=#top","manga":"https://proxer.me/search?s=search&name={searchterm}&typ=all-manga&tags=&notags=#top"}},{"name":"Wakanim","domain":"https://www.wakanim.tv","database":null,"search":{"anime":"https://www.wakanim.tv/de/v2/catalogue/search?search={searchterm}","manga":null}},{"name":"Emby","domain":"http://app.emby.media","database":null,"search":{"anime":"home","manga":null}},{"name":"Plex","domain":"http://app.plex.tv","database":null,"search":{"anime":"home","manga":null}},{"name":"4Anime","domain":"https://4anime.to","database":null,"search":{"anime":"https://4anime.to/?s={searchtermPlus}","manga":null}},{"name":"animeultima","domain":"https://animeultima.to","database":null,"search":{"anime":"home","manga":null}},{"name":"Aniflix","domain":"https://www1.aniflix.tv","database":null,"search":{"anime":"home","manga":null}},{"name":"Animefreak","domain":"https://www.animefreak.tv","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimeLab","domain":"https://www.animelab.com","database":"AnimeLab","search":{"anime":"https://www.animelab.com/shows/search?searchTerms={searchtermPlus}","manga":null}},{"name":"KickAssAnime","domain":"https://www.kickassanime.ro","database":null,"search":{"anime":"https://www2.kickassanime.ro/search?q={searchterm}","manga":null}},{"name":"AnimeKisa","domain":"https://animekisa.tv","database":null,"search":{"anime":"https://animekisa.tv/search?q={searchtermPlus}","manga":null}},{"name":"AnimeIndo","domain":"https://animeindo.net","database":null,"search":{"anime":"https://animeindo.net/?s={searchterm}&post_type=anime","manga":null}},{"name":"Shinden","domain":"https://shinden.pl","database":null,"search":{"anime":"home","manga":null}},{"name":"Voiranime","domain":"https://voiranime.com","database":null,"search":{"anime":"home","manga":null}},{"name":"DubbedAnime","domain":"https://ww5.dubbedanime.net","database":null,"search":{"anime":"home","manga":null}},{"name":"MangaNato","domain":"https://manganato.com","database":"MangaNato","search":{"anime":null,"manga":"https://manganato.com/search/story/{searchterm}"}},{"name":"VIZ","domain":"https://www.viz.com","database":"VIZ","search":{"anime":null,"manga":"https://www.viz.com/search?search={searchtermPlus}"}},{"name":"NekoSama","domain":"https://www.neko-sama.fr","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimeOdcinki","domain":"https://anime-odcinki.pl","database":null,"search":{"anime":"https://anime-odcinki.pl/szukaj/{searchtermPlus}","manga":null}},{"name":"AnimeZone","domain":"https://www.animezone.pl","database":null,"search":{"anime":"home","manga":null}},{"name":"Animeflix","domain":"https://animeflix.io","database":null,"search":{"anime":"home","manga":null}},{"name":"serimanga","domain":"https://serimanga.com","database":null,"search":{"anime":null,"manga":"https://serimanga.com/mangalar?search={searchtermPlus}"}},{"name":"mangadenizi","domain":"https://mangadenizi.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"moeclip","domain":"https://moeclip.com","database":null,"search":{"anime":"https://moeclip.com/search/{searchtermPlus}","manga":null}},{"name":"mangalivre","domain":"https://mangalivre.net","database":null,"search":{"anime":null,"manga":"home"}},{"name":"tmofans","domain":"https://lectortmo.com","database":null,"search":{"anime":null,"manga":"https://lectortmo.com/library?_pg=1&title={searchtermPlus}"}},{"name":"unionmangas","domain":"https://unionleitor.top","database":null,"search":{"anime":null,"manga":"home"}},{"name":"MangaPlus","domain":"https://mangaplus.shueisha.co.jp","database":"MangaPlus","search":{"anime":null,"manga":"https://mangaplus.shueisha.co.jp/search_result?keyword={searchterm}"}},{"name":"JapScan","domain":"https://www.japscan.ws","database":null,"search":{"anime":null,"manga":"home"}},{"name":"Goyabu","domain":"https://goyabu.com","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimesVision","domain":"https://animesvision.biz","database":null,"search":{"anime":"home","manga":null}},{"name":"Hulu","domain":"https://www.hulu.com","database":"Hulu","search":{"anime":"home","manga":null}},{"name":"Hidive","domain":"https://www.hidive.com","database":"Hidive","search":{"anime":"https://www.hidive.com/search?q={searchtermPlus}","manga":null}},{"name":"FallenAngels","domain":"https://manga.fascans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"Amazon Prime Video","domain":"https://www.primevideo.com","database":null,"search":{"anime":"home","manga":null}},{"name":"MangaKatana","domain":"http://mangakatana.com","database":null,"search":{"anime":null,"manga":"http://mangakatana.com/?search={searchtermPlus}&search_by=book_name"}},{"name":"manga4life","domain":"https://manga4life.com","database":null,"search":{"anime":null,"manga":"https://manga4life.com/search/?name={searchterm}"}},{"name":"bato","domain":"https://bato.to","database":null,"search":{"anime":null,"manga":"https://bato.to/search?word={searchtermPlus}"}},{"name":"DreamSub","domain":"https://dreamsub.cc","database":null,"search":{"anime":"https://dreamsub.cc/search/?q={searchtermPlus}","manga":null}},{"name":"MangaPark","domain":"https://mangapark.net","database":null,"search":{"anime":null,"manga":"https://mangapark.net/search?word={searchterm}"}},{"name":"AnimesHouse","domain":"https://animeshouse.net","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimeXin","domain":"https://animexin.xyz","database":null,"search":{"anime":"https://animexin.xyz/?s={searchtermPlus}","manga":null}},{"name":"MonosChinos","domain":"https://monoschinos2.com","database":null,"search":{"anime":"https://monoschinos2.com/search?q={searchtermPlus}","manga":null}},{"name":"AnimeFire","domain":"https://animefire.net","database":null,"search":{"anime":"home","manga":null}},{"name":"OtakuFR","domain":"https://otakufr.co","database":null,"search":{"anime":"https://otakufr.co/toute-la-liste-affiches/?q={searchtermPlus}","manga":null}},{"name":"Samehadaku","domain":"https://samehadaku.vip","database":null,"search":{"anime":"https://samehadaku.vip/?s={searchtermPlus}","manga":null}},{"name":"Tsuki MangÃ¡s","domain":"https://www.tsukimangas.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"mangatx","domain":"https://mangatx.com","database":null,"search":{"anime":null,"manga":"https://mangatx.com/?s={searchtermPlus}&post_type=wp-manga&post_type=wp-manga"}},{"name":"TRanimeizle","domain":"https://www.tranimeizle.net/","database":null,"search":{"anime":"home","manga":null}},{"name":"Anihub","domain":"https://anihub.tv","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimeStreamingFR","domain":"https://www.animestreamingfr.fr","database":null,"search":{"anime":"https://www.animestreamingfr.fr/anime?page=1&query={searchtermPlus}","manga":null}},{"name":"Scantrad","domain":"https://scantrad.net","database":null,"search":{"anime":null,"manga":"home"}},{"name":"Furyosquad","domain":"https://furyosquad.com/","database":null,"search":{"anime":null,"manga":"home"}},{"name":"AnimeId","domain":"https://www.animeid.tv","database":null,"search":{"anime":"home","manga":null}},{"name":"AniMixPlay","domain":"https://animixplay.to","database":"AniMixPlay","search":{"anime":"home","manga":null}},{"name":"MyAnimeList","domain":"https://myanimelist.net","database":null,"search":{"anime":"https://myanimelist.net/anime.php?q={searchterm}","manga":"https://myanimelist.net/manga.php?q={searchterm}"}},{"name":"AnimeSimple","domain":"https://ww1.animesimple.com","database":"AnimeSimple","search":{"anime":"home","manga":null}},{"name":"AnimeUnity","domain":"https://animeunity.it","database":null,"search":{"anime":"home","manga":null}},{"name":"MangaHere","domain":"http://www.mangahere.cc","database":null,"search":{"anime":null,"manga":"http://www.mangahere.cc/search?title={searchtermPlus}"}},{"name":"MangaFox","domain":"http://fanfox.net","database":"MangaFox","search":{"anime":null,"manga":"http://fanfox.net/search?title={searchtermPlus}"}},{"name":"JustAnime","domain":"https://justanime.app","database":null,"search":{"anime":"home","manga":null}},{"name":"YayAnimes","domain":"https://yayanimes.net","database":null,"search":{"anime":"https://yayanimes.net/?s={searchtermPlus}","manga":null}},{"name":"DesuOnline","domain":"https://desu-online.pl","database":null,"search":{"anime":"https://desu-online.pl/?s={searchtermPlus}","manga":null}},{"name":"Simplyaweeb","domain":"https://simplyaweeb.com","database":null,"search":{"anime":"home","manga":null}},{"name":"Animevibe","domain":"https://animevibe.wtf","database":null,"search":{"anime":"https://animevibe.wtf/search?q={searchtermPlus}","manga":null}},{"name":"WuxiaWorld","domain":"https://wuxiaworld.site","database":null,"search":{"anime":null,"manga":"https://wuxiaworld.site/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"AnimeOnDemand","domain":"https://www.anime-on-demand.de","database":null,"search":{"anime":"https://www.anime-on-demand.de/animes/?term={searchtermPlus}","manga":null}},{"name":"EdelgardeScans","domain":"https://edelgardescans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"HatigarmScanz","domain":"https://hatigarmscanz.net","database":null,"search":{"anime":null,"manga":"home"}},{"name":"LeviatanScans","domain":"https://leviatanscans.com","database":null,"search":{"anime":null,"manga":"https://leviatanscans.com/el/?s={searchtermPlus}"}},{"name":"MethodScans","domain":"https://methodscans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"NonamesScans","domain":"https://the-nonames.com","database":null,"search":{"anime":null,"manga":"https://the-nonames.com/comics?query={searchtermPlus}"}},{"name":"ReaperScans","domain":"https://reaperscans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"LynxScans","domain":"https://lynxscans.com","database":null,"search":{"anime":null,"manga":"https://lynxscans.com/comics?query={searchtermPlus}"}},{"name":"SKScans","domain":"https://skscans.com","database":null,"search":{"anime":null,"manga":"https://skscans.com/?s={searchtermPlus}"}},{"name":"ZeroScans","domain":"https://zeroscans.com","database":null,"search":{"anime":null,"manga":"https://zeroscans.com/comics?query={searchtermPlus}"}},{"name":"DeathTollScans","domain":"https://reader.deathtollscans.net","database":null,"search":{"anime":null,"manga":"home"}},{"name":"KireiCake","domain":"https://reader.kireicake.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"SenseScans","domain":"https://sensescans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"ManhuaPlus","domain":"https://manhuaplus.com","database":null,"search":{"anime":null,"manga":"https://manhuaplus.com/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"Readm","domain":"https://readm.org","database":null,"search":{"anime":null,"manga":"home"}},{"name":"tioanime","domain":"https://tioanime.com","database":null,"search":{"anime":"https://tioanime.com/directorio?q={searchtermPlus}","manga":null}},{"name":"YugenAnime","domain":"https://yugenani.me","database":"YugenAnime","search":{"anime":"https://yugenani.me/search/?q={searchtermPlus}","manga":null}},{"name":"MangaSee","domain":"https://mangasee123.com","database":"MangaSee","search":{"anime":null,"manga":"https://mangasee123.com/search/?name={searchterm}"}},{"name":"AnimeTribes","domain":"https://animetribes.ru","database":null,"search":{"anime":"home","manga":null}},{"name":"Okanime","domain":"https://okanime.tv","database":null,"search":{"anime":"https://okanime.tv/search?search={searchtermPlus}","manga":null}},{"name":"bs.to","domain":"https://bs.to","database":null,"search":{"anime":"home","manga":null}},{"name":"Pantsubase","domain":"https://pantsubase.tv","database":null,"search":{"anime":"https://pantsubase.tv/search?name={searchtermPlus}","manga":null}},{"name":"AnimeOwl","domain":"https://animeowl.net","database":null,"search":{"anime":"https://animeowl.net/?s={searchtermPlus}","manga":null}},{"name":"AsuraScans","domain":"https://asurascans.com","database":null,"search":{"anime":null,"manga":"https://www.asurascans.com/?s={searchtermPlus}"}},{"name":"NaniScans","domain":"https://naniscans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"MerakiScans","domain":"https://merakiscans.com","database":null,"search":{"anime":null,"manga":"home"}},{"name":"Jellyfin","domain":"https://jellyfin.org/","database":null,"search":{"anime":"home","manga":null}},{"name":"An1me","domain":"https://an1me.nl","database":null,"search":{"anime":"https://an1me.nl/?s={searchtermPlus}&post_type=wp-manga","manga":null}},{"name":"MangaJar","domain":"https://mangajar.com","database":null,"search":{"anime":null,"manga":"https://mangajar.com/search?q={searchtermPlus}"}},{"name":"AnimeDao","domain":"https://animedao.to","database":null,"search":{"anime":"https://animedao.to/search/?search={searchtermPlus}","manga":null}},{"name":"Otakustv","domain":"https://www.otakustv.com","database":null,"search":{"anime":"https://www.otakustv.com/buscador.php?buscador={searchterm}","manga":null}},{"name":"Komga","domain":"https://komga.org","database":null,"search":{"anime":null,"manga":"home"}},{"name":"AnimeWho","domain":"https://animewho.com","database":null,"search":{"anime":"home","manga":null}},{"name":"AnimeSuge","domain":"https://animesuge.io","database":null,"search":{"anime":"https://animesuge.io/search?keyword={searchtermPlus}","manga":null}},{"name":"Toonily","domain":"https://toonily.net","database":null,"search":{"anime":null,"manga":"https://toonily.net/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"Fumetsu","domain":"https://fumetsu.pl","database":null,"search":{"anime":"home","manga":null}},{"name":"NonstopScans","domain":"https://www.nonstopscans.com","database":null,"search":{"anime":null,"manga":"https://www.nonstopscans.com/?s={searchtermPlus}"}},{"name":"FrixySubs","domain":"https://frixysubs.pl","database":null,"search":{"anime":"home","manga":null}},{"name":"Guya & Cubari","domain":"https://guya.moe","database":null,"search":{"anime":null,"manga":"home"}},{"name":"MangaHub","domain":"https://mangahub.io","database":null,"search":{"anime":null,"manga":"https://mangahub.io/search?q={searchterm}"}},{"name":"ComicK","domain":"https://comick.fun","database":null,"search":{"anime":null,"manga":"https://comick.fun/search?q={searchterm}"}},{"name":"AnimeShitai","domain":"https://www.anime-shitai.com","database":null,"search":{"anime":"home","manga":null}},{"name":"KangaryuTeam","domain":"https://kangaryu-team.fr","database":null,"search":{"anime":null,"manga":"home"}},{"name":"Japanread","domain":"https://www.japanread.cc/","database":null,"search":{"anime":null,"manga":"https://www.japanread.cc/manga-list?q={searchterm}"}},{"name":"CatManga","domain":"https://catmanga.org","database":null,"search":{"anime":null,"manga":"home"}},{"name":"MangaSushi","domain":"https://mangasushi.net","database":null,"search":{"anime":null,"manga":"https://mangasushi.net/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"ArangScans","domain":"https://arangscans.com","database":null,"search":{"anime":null,"manga":"https://arangscans.com/?s={searchtermPlus}"}},{"name":"HunlightScans","domain":"https://hunlight-scans.info/","database":null,"search":{"anime":null,"manga":"https://hunlight-scans.info/comics?query={searchtermPlus}"}},{"name":"TritiniaScans","domain":"https://tritinia.com","database":null,"search":{"anime":null,"manga":"https://tritinia.com/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"ReadManhua","domain":"https://readmanhua.net","database":null,"search":{"anime":null,"manga":"https://readmanhua.net/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"FlameScans","domain":"https://flamescans.org","database":null,"search":{"anime":null,"manga":"https://flamescans.org/?s={searchtermPlus}"}},{"name":"ImmortalUpdates","domain":"https://immortalupdates.com","database":null,"search":{"anime":null,"manga":"https://immortalupdates.com/?s={searchtermPlus}&post_type=wp-manga"}},{"name":"Zoro","domain":"https://zoro.to","database":"Zoro","search":{"anime":"https://zoro.to/search?keyword={searchtermPlus}","manga":null}},{"name":"Funimation","domain":"https://www.funimation.com","database":"Funimation","search":{"anime":"https://www.funimation.com/search/?q={searchterm}","manga":null}},{"name":"Kitsune","domain":"https://beta.kitsune.tv","database":null,"search":{"anime":"https://kitsune.tv/shows?q={searchterm}","manga":null}},{"name":"AnimesOnline","domain":"https://animesonline.org","database":null,"search":{"anime":"https://animesonline.org/?s={searchtermPlus}","manga":null}},{"name":"LHTranslation","domain":"https://lhtranslation.net","database":null,"search":{"anime":null,"manga":"home"}}]');
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, utils, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SearchClass;
        }));
        var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26), _searchClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109), _correctionApp_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(260);
        class SearchClass extends _searchClass__WEBPACK_IMPORTED_MODULE_1__.a {
            constructor() {
                super(...arguments), this.reloadSync = !1;
            }
            openCorrectionCheck() {
                return this.state && this.state.similarity && this.state.similarity.same ? (con.log("similarity", this.state.similarity.value), 
                !1) : this.openCorrection(!0).then(() => this.changed);
            }
            openCorrection(syncMode = !1) {
                return new Promise((resolve, reject) => {
                    if (this.vueInstance && (this.vueInstance.$destroy(), !syncMode)) return void resolve(!1);
                    const flasmessage = utils.flashm('<div class="shadow"></div>', {
                        permanent: !0,
                        position: "top",
                        type: "correction"
                    });
                    flasmessage.find(".shadow").get(0).attachShadow({
                        mode: "open"
                    }).innerHTML = `\n        <style>\n          ${j.html(__webpack_require__(292).toString())}\n        </style>\n        <div id="correctionApp"></div>\n        `;
                    const element = flasmessage.find(".shadow").get(0).shadowRoot.querySelector("#correctionApp");
                    this.vueInstance = new vue__WEBPACK_IMPORTED_MODULE_0__.a({
                        el: element,
                        data: () => ({
                            searchClass: this,
                            syncMode: syncMode
                        }),
                        destroyed: () => {
                            resolve(this.changed), flasmessage.remove(), this.vueInstance = void 0;
                        },
                        render: h => h(_correctionApp_vue__WEBPACK_IMPORTED_MODULE_2__.a)
                    });
                });
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(1), __webpack_require__(2));
}, function(module, exports) {
    function compareTwoStrings(first, second) {
        if (first = first.replace(/\s+/g, ""), second = second.replace(/\s+/g, ""), !first.length && !second.length) return 1;
        if (!first.length || !second.length) return 0;
        if (first === second) return 1;
        if (1 === first.length && 1 === second.length) return 0;
        if (first.length < 2 || second.length < 2) return 0;
        let firstBigrams = new Map;
        for (let i = 0; i < first.length - 1; i++) {
            const bigram = first.substring(i, i + 2), count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;
            firstBigrams.set(bigram, count);
        }
        let intersectionSize = 0;
        for (let i = 0; i < second.length - 1; i++) {
            const bigram = second.substring(i, i + 2), count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;
            count > 0 && (firstBigrams.set(bigram, count - 1), intersectionSize++);
        }
        return 2 * intersectionSize / (first.length + second.length - 2);
    }
    module.exports = {
        compareTwoStrings: compareTwoStrings,
        findBestMatch: function(mainString, targetStrings) {
            if (!function(mainString, targetStrings) {
                return "string" == typeof mainString && (!!Array.isArray(targetStrings) && (!!targetStrings.length && !targetStrings.find(s => "string" != typeof s)));
            }(mainString, targetStrings)) throw new Error("Bad arguments: First argument should be a string, second should be an array of strings");
            const ratings = [];
            let bestMatchIndex = 0;
            for (let i = 0; i < targetStrings.length; i++) {
                const currentTargetString = targetStrings[i], currentRating = compareTwoStrings(mainString, currentTargetString);
                ratings.push({
                    target: currentTargetString,
                    rating: currentRating
                }), currentRating > ratings[bestMatchIndex].rating && (bestMatchIndex = i);
            }
            const bestMatch = ratings[bestMatchIndex];
            return {
                ratings: ratings,
                bestMatch: bestMatch,
                bestMatchIndex: bestMatchIndex
            };
        }
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con) {
        function aniListToMal(anilistId, type) {
            const variables = {
                id: anilistId,
                type: type.toUpperCase()
            };
            return api.request.xhr("POST", {
                url: "https://graphql.anilist.co",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json"
                },
                data: JSON.stringify({
                    query: "\n  query ($id: Int, $type: MediaType) {\n    Media (id: $id, type: $type) {\n      id\n      idMal\n    }\n  }\n  ",
                    variables: variables
                })
            }).then(response => {
                const res = JSON.parse(response.responseText);
                return con.log(res), function(res, silent = !1) {
                    if (void 0 !== res.errors) for (let i = 0, len = res.errors.length; i < len; i++) {
                        const error = res.errors[i];
                        switch (error.status) {
                          case 400:
                            if (!silent) return utils.flashm(api.storage.lang("Anilist_Authenticate"), {
                                error: !0,
                                type: "error"
                            }), "noLogin";

                          case 404:
                            if (!silent) {
                                utils.flashm("anilist: " + error.message, {
                                    error: !0,
                                    type: "error"
                                });
                                break;
                            }

                          default:
                            throw silent || utils.flashm("anilist: " + error.message, {
                                error: !0,
                                type: "error"
                            }), error.message;
                        }
                    }
                }(res), res.data.Media.idMal;
            });
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return aniListToMal;
        }));
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return exportData;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return importData;
        }));
        var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function exportData() {
            return __awaiter(this, void 0, void 0, (function*() {
                const data = yield _helper__WEBPACK_IMPORTED_MODULE_0__.c(), newData = {};
                for (const key in data) _helper__WEBPACK_IMPORTED_MODULE_0__.b("(anime|manga)").test(key) && (newData[key] = data[key]);
                return newData;
            }));
        }
        function importData(newData) {
            return __awaiter(this, void 0, void 0, (function*() {
                const data = yield _helper__WEBPACK_IMPORTED_MODULE_0__.c();
                for (const key in data) _helper__WEBPACK_IMPORTED_MODULE_0__.b("(anime|manga)").test(key) && (con.log("Remove", key), 
                yield api.storage.remove(key).catch(e => {
                    if (e.message && e.message.includes("MAX_WRITE_OPERATIONS_PER_MINUTE")) return utils.flashm("Max write operations per minute hit. Import stopped for 1 minute. Just keep this window open."), 
                    new Promise(resolve => {
                        setTimeout(() => {
                            resolve(api.storage.remove(key));
                        }, 6e4);
                    });
                    throw e;
                }));
                for (const k in newData) con.log("Set", k, newData[k]), yield api.storage.set(k, newData[k]).catch(e => {
                    if (e.message && e.message.includes("MAX_WRITE_OPERATIONS_PER_MINUTE")) return utils.flashm("Max write operations per minute hit. Import stopped for 1 minute. Just keep this window open."), 
                    new Promise(resolve => {
                        setTimeout(() => {
                            resolve(api.storage.set(k, newData[k]));
                        }, 6e4);
                    });
                    throw e;
                });
                return 1;
            }));
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, exports) {
    var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
    }
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
        setTimeout(fun, 0);
        try {
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    !function() {
        try {
            cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    }();
    var currentQueue, queue = [], draining = !1, queueIndex = -1;
    function cleanUpNextTick() {
        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
        queue.length && drainQueue());
    }
    function drainQueue() {
        if (!draining) {
            var timeout = runTimeout(cleanUpNextTick);
            draining = !0;
            for (var len = queue.length; len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, len = queue.length;
            }
            currentQueue = null, draining = !1, function(marker) {
                if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                clearTimeout(marker);
                try {
                    cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }(timeout);
        }
    }
    function Item(fun, array) {
        this.fun = fun, this.array = array;
    }
    function noop() {}
    process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
        queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
    }, Item.prototype.run = function() {
        this.fun.apply(null, this.array);
    }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
    process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
    process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
    process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
    process.listeners = function(name) {
        return [];
    }, process.binding = function(name) {
        throw new Error("process.binding is not supported");
    }, process.cwd = function() {
        return "/";
    }, process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
    }, process.umask = function() {
        return 0;
    };
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var scope = void 0 !== global && global || "undefined" != typeof self && self || window, apply = Function.prototype.apply;
        function Timeout(id, clearFn) {
            this._id = id, this._clearFn = clearFn;
        }
        exports.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
        }, exports.setInterval = function() {
            return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
        }, exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout && timeout.close();
        }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
            this._clearFn.call(scope, this._id);
        }, exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
        }, exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
        }, exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            msecs >= 0 && (item._idleTimeoutId = setTimeout((function() {
                item._onTimeout && item._onTimeout();
            }), msecs));
        }, __webpack_require__(291), exports.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== global && global.setImmediate || this && this.setImmediate, 
        exports.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== global && global.clearImmediate || this && this.clearImmediate;
    }).call(this, __webpack_require__(87));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return userscriptLegacy;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const userscriptLegacy = {
            set(key, value) {
                return __awaiter(this, void 0, void 0, (function*() {
                    GM_setValue(key, value);
                }));
            },
            get(key) {
                return __awaiter(this, void 0, void 0, (function*() {
                    return GM_getValue(key);
                }));
            },
            remove(key) {
                return __awaiter(this, void 0, void 0, (function*() {
                    GM_deleteValue(key);
                }));
            },
            list() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const reverseArray = {};
                    return j.$.each(GM_listValues(), (function(index, cache) {
                        reverseArray[cache] = index;
                    })), reverseArray;
                }));
            },
            addStyle(css) {
                return __awaiter(this, void 0, void 0, (function*() {
                    GM_addStyle(css);
                }));
            },
            version: () => GM_info.script.version,
            lang(selector, args) {
                let message = i18n[selector];
                if (void 0 !== args) for (let argIndex = 0; argIndex < args.length; argIndex++) message = message.replace("$" + (argIndex + 1), args[argIndex]);
                return message;
            },
            assetUrl: filename => "https://raw.githubusercontent.com/MALSync/MALSync/master/assets/assets/" + filename,
            injectCssResource(res, head) {
                head.append(j.$("<style>").attr("rel", "stylesheet").attr("type", "text/css").html(GM_getResourceText(res)));
            },
            injectjsResource(res, head) {
                const s = document.createElement("script");
                s.text = GM_getResourceText(res), s.onload = function() {
                    this.remove();
                }, head.get(0).appendChild(s);
            },
            updateDom(head) {
                const s = document.createElement("script");
                s.text = "\n        document.getElementsByTagName('head')[0].onclick = function(e){\n          try{\n            componentHandler.upgradeDom();\n          }catch(e){\n            console.log(e);\n            setTimeout(function(){\n              componentHandler.upgradeDom();\n            },500);\n          }\n        }", 
                s.onload = function() {
                    this.remove();
                }, head.get(0).appendChild(s);
            },
            storageOnChanged(cb) {}
        };
    }).call(this, __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return requestUserscriptLegacy;
        }));
        var _background_notifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const requestUserscriptLegacy = {
            xhr(method, url) {
                return __awaiter(this, void 0, void 0, (function*() {
                    return new Promise((resolve, reject) => {
                        const request = {
                            method: method,
                            url: url,
                            synchronous: !1,
                            headers: {},
                            data: null,
                            onload(response) {
                                if (console.log(response), 429 === response.status) return con.error("RATE LIMIT"), 
                                api.storage.set("rateLimit", !0), void setTimeout(() => {
                                    api.storage.set("rateLimit", !1), resolve(requestUserscriptLegacy.xhr(method, url));
                                }, 1e4);
                                const responseObj = {
                                    finalUrl: response.finalUrl,
                                    responseText: response.responseText,
                                    status: response.status
                                };
                                resolve(responseObj);
                            }
                        };
                        "object" == typeof url && (request.url = url.url, request.headers = url.headers, 
                        request.data = url.data), request.url.includes("malsync.moe") && (request.headers.version = api.storage.version(), 
                        request.headers.type = "userscript"), GM_xmlhttpRequest(request);
                    });
                }));
            },
            notification(options) {
                var _a;
                GM_notification({
                    title: options.title,
                    text: options.text,
                    image: null !== (_a = options.image) && void 0 !== _a ? _a : _background_notifications__WEBPACK_IMPORTED_MODULE_0__.a,
                    timeout: options.sticky ? 0 : 10,
                    onclick: () => {
                        window.open(options.url, "_blank");
                    }
                });
            }
        };
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return defaultImg;
        }));
        const defaultImg = "https://raw.githubusercontent.com/MALSync/MALSync/master/assets/icons/icon128.png";
    }).call(this, __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return settingsObj;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const settingsObj = {
            options: {
                autoTrackingModeanime: "video",
                autoTrackingModemanga: "instant",
                enablePages: {},
                forceEn: !1,
                rpc: !0,
                presenceHidePage: !1,
                presenceShowButtons: !0,
                userscriptModeButton: !1,
                syncMode: "MAL",
                syncModeSimkl: "MAL",
                localSync: !0,
                delay: 0,
                videoDuration: 85,
                malTags: !1,
                malContinue: !0,
                malResume: !0,
                usedPage: !0,
                epPredictions: !0,
                theme: "auto",
                minimalWindow: !1,
                posLeft: "left",
                miniMALonMal: !1,
                floatButtonStealth: !1,
                minimizeBigPopup: !1,
                floatButtonCorrection: !1,
                floatButtonHide: !1,
                autoCloseMinimal: !1,
                outWay: !0,
                miniMalWidth: "500px",
                miniMalHeight: "90%",
                malThumbnail: 100,
                friendScore: !0,
                loadPTWForProgress: !1,
                quicklinks: [ "9anime", "Crunchyroll", "Gogoanime", "Twistmoe", "Mangadex", "MangaNato", "AnimeSimple", "animepahe", "MangaFox", "MangaSee", "YugenAnime", "AniMixPlay", "Zoro", "Funimation", "Hulu", "Netflix", "AnimeLab", "Hidive", "Vrv", "VIZ", "MangaPlus" ],
                autofull: !1,
                autoresume: !1,
                autoNextEp: !1,
                highlightAllEp: !1,
                checkForFiller: !0,
                introSkip: 85,
                introSkipFwd: [ 17, 39 ],
                introSkipBwd: [ 17, 37 ],
                nextEpShort: [],
                correctionShort: [ 67 ],
                syncShort: [],
                progressInterval: 120,
                progressIntervalDefaultAnime: "en/sub",
                progressIntervalDefaultManga: "en/sub",
                progressNotifications: !0,
                updateCheckNotifications: !0,
                bookMarksList: !1,
                customDomains: [],
                anilistToken: "",
                anilistOptions: {
                    displayAdultContent: !0,
                    scoreFormat: "POINT_10"
                },
                kitsuToken: "",
                kitsuOptions: {
                    titleLanguagePreference: "canonical",
                    sfwFilter: !1,
                    ratingSystem: "regular"
                },
                simklToken: "",
                malToken: "",
                malRefresh: ""
            },
            init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    for (const key in this.options) {
                        const store = yield api.storage.get("settings/" + key);
                        void 0 !== store && (this.options[key] = store);
                    }
                    return con.log("Settings", this.options), api.storage.storageOnChanged((changes, namespace) => {
                        if ("sync" === namespace) for (const key in changes) {
                            const storageChange = changes[key];
                            /^settings\//i.test(key) && (this.options[key.replace("settings/", "")] = storageChange.newValue, 
                            con.info(`Update ${key} option to ${storageChange.newValue}`));
                        }
                        if ("local" === namespace && changes.rateLimit) try {
                            changes.rateLimit.newValue ? (con.log("Rate limited"), utils.flashm("Rate limited. Retrying in a moment", {
                                error: !0,
                                type: "rate",
                                permanent: !0
                            })) : (con.log("No Rate limited"), $(".type-rate").remove());
                        } catch (e) {
                            con.error(e);
                        }
                    }), this;
                }));
            },
            get(name) {
                return this.options[name];
            },
            set(name, value) {
                if (!Object.prototype.hasOwnProperty.call(this.options, name)) {
                    const err = Error(name + " is not a defined option");
                    throw con.error(err), err;
                }
                return this.options[name] = value, api.storage.set("settings/" + name, value);
            },
            getAsync(name) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const value = yield api.storage.get("settings/" + name);
                    return void 0 === value && void 0 !== this.options[name] ? this.options[name] : value;
                }));
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, j, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SyncPage;
        }));
        var _provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18), _floatbutton_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(103), _provider_templates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104), _utils_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37), _provider_Search_vueSearchClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(90), _utils_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23), _utils_Cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let extensionId = "agnaejlkbiiggajjmnpmeheigkflbnoo";
        "undefined" != typeof browser && "undefined" != typeof chrome && (extensionId = "{57081fef-67b4-482f-bcb0-69296e63ec4f}");
        const logger = con.m("Sync", "#348fff");
        let browsingTimeout, playerTimeout;
        class SyncPage {
            constructor(url, pages, floatClick = (() => {
                throw "No click handling found";
            })) {
                if (this.url = url, this.pages = pages, this.floatClick = floatClick, this.novel = !1, 
                this.strongVolumes = !1, this.autoNextEpRun = !1, this.curState = void 0, this.tempPlayer = void 0, 
                this.UILoaded = !1, this.browsingtime = Date.now(), this.page = this.getPage(url), 
                null === this.page) throw new Error("Page could not be recognized");
                if (this.domainSet(), logger.log("Page", this.page.name), void 0 !== api.settings.get("enablePages")[this.page.name] && !api.settings.get("enablePages")[this.page.name]) throw logger.info("Sync is disabled for this page", this.page.name), 
                "Stop Script";
                _utils_emitter__WEBPACK_IMPORTED_MODULE_5__.a.on("syncPage_fillUi", () => this.fillUI());
            }
            init() {
                const This = this;
                if (j.$(document).ready((function() {
                    Object(_floatbutton_init__WEBPACK_IMPORTED_MODULE_1__.a)(This, This.floatClick);
                })), this.testForCloudflare()) return logger.log("loading"), void this.cdn();
                if (this.page.init(this), "webextension" === api.type) try {
                    chrome.runtime.onMessage.addListener((info, sender, sendResponse) => {
                        this.presence(info, sender, sendResponse);
                    });
                } catch (e) {
                    logger.error(e);
                }
            }
            getPage(url) {
                if (this.pages.type) return this.pages;
                for (const key in this.pages) {
                    const page = this.pages[key];
                    if (j.$.isArray(page.domain)) {
                        let resPage;
                        if (page.domain.forEach(singleDomain => {
                            checkDomain(singleDomain) && (page.domain = singleDomain, resPage = page);
                        }), resPage) return resPage;
                    } else if (checkDomain(page.domain)) return page;
                    function checkDomain(domain) {
                        return url.indexOf(utils.urlPart(domain, 2).replace(".com.br", ".br").split(".").slice(-2, -1)[0] + ".") > -1;
                    }
                }
                return null;
            }
            domainSet() {
                this.page.domain = new URL(window.location.href).origin;
            }
            openNextEp() {
                if (void 0 === this.page.sync.nextEpUrl) utils.flashm(api.storage.lang("nextEpShort_no_support"), {
                    error: !0,
                    type: "EpError"
                }); else {
                    if (this.page.isSyncPage(this.url)) {
                        const nextEp = this.page.sync.nextEpUrl(this.url);
                        if (nextEp) return void (window.location.href = nextEp);
                    }
                    utils.flashm(api.storage.lang("nextEpShort_no_nextEp"), {
                        error: !0,
                        type: "EpError"
                    });
                }
            }
            setVideoTime(item, timeCb) {
                this.resetPlayerError();
                const syncDuration = api.settings.get("videoDuration"), progress = item.current / (item.duration * (syncDuration / 100)) * 100;
                j.$("#malSyncProgress").length && (progress < 100 ? (j.$(".ms-progress").css("width", progress + "%"), 
                j.$("#malSyncProgress").removeClass("ms-loading").removeClass("ms-done")) : (j.$("#malSyncProgress").addClass("ms-done"), 
                j.$(".flash.type-update .sync").click())), this.handleVideoResume(item, timeCb), 
                this.autoNextEp(item);
            }
            autoNextEp(item) {
                api.settings.get("autoNextEp") && !this.autoNextEpRun && item.current === item.duration && (this.autoNextEpRun = !0, 
                this.openNextEp());
            }
            handleVideoResume(item, timeCb) {
                if (void 0 === this.curState || void 0 === this.curState.identifier || void 0 === this.curState.episode) return;
                const This = this, localSelector = `${this.curState.identifier}/${this.curState.episode}`;
                if (this.curState.lastVideoTime = item, void 0 !== this.curState.videoChecked && this.curState.videoChecked) this.curState.videoChecked > 1 && item.current > 10 && (logger.debug("Set Resume", item.current), 
                localStorage.setItem(localSelector, item.current), this.curState.videoChecked = !0, 
                setTimeout(() => {
                    this.curState.videoChecked = 2;
                }, 1e4)); else {
                    const localItem = localStorage.getItem(localSelector);
                    if (logger.info("Resume", localItem), null !== localItem && parseInt(localItem) - 30 > item.current && parseInt(localItem) > 30) {
                        j.$("#MALSyncResume").length || j.$("#MALSyncResume").parent().parent().remove();
                        const resumeTime = Math.round(parseInt(localItem));
                        let resumeTimeString = "";
                        if (api.settings.get("autoresume") && item.duration - resumeTime > .1 * item.duration) return timeCb(resumeTime), 
                        void (This.curState.videoChecked = 2);
                        let delta = resumeTime;
                        const minutes = Math.floor(delta / 60);
                        delta -= 60 * minutes;
                        let sec = "" + delta;
                        for (;sec.length < 2; ) sec = "0" + sec;
                        resumeTimeString = `${minutes}:${sec}`;
                        const resumeMsg = utils.flashm(`<button id="MALSyncResume" class="sync" style="margin-bottom: 2px; background-color: transparent; border: none; color: rgb(255,64,129);cursor: pointer;">${api.storage.lang("syncPage_flashm_resumeMsg", [ resumeTimeString ])}</button><br><button class="resumeClose" style="background-color: transparent; border: none; color: white;margin-top: 10px;cursor: pointer;">Close</button>`, {
                            permanent: !0,
                            error: !1,
                            type: "resume",
                            minimized: !1,
                            position: "top"
                        });
                        resumeMsg.find(".sync").on("click", (function() {
                            timeCb(resumeTime), This.curState.videoChecked = 2, j.$(this).parent().parent().remove();
                        })), resumeMsg.find(".resumeClose").on("click", (function() {
                            This.curState.videoChecked = 2, j.$(this).parent().parent().remove();
                        }));
                    } else setTimeout(() => {
                        this.curState.videoChecked = 2;
                    }, 15e3);
                    this.curState.videoChecked = !0;
                }
            }
            reset() {
                this.url = window.location.href, this.UILoaded = !1, this.curState = void 0, $("#flashinfo-div, #flash-div-bottom, #flash-div-top, #malp").remove();
            }
            handlePage(curUrl = window.location.href) {
                return __awaiter(this, void 0, void 0, (function*() {
                    let state;
                    this.resetPlayerError(), this.curState = void 0, this.searchObj = void 0;
                    const This = this;
                    let tempSingle;
                    if (this.url = curUrl, this.browsingtime = Date.now(), this.page.isSyncPage(this.url)) this.loadUI(), 
                    state = {
                        on: "SYNC",
                        title: this.page.sync.getTitle(this.url),
                        identifier: this.page.sync.getIdentifier(this.url),
                        detectedEpisode: parseInt("" + this.page.sync.getEpisode(this.url))
                    }, this.searchObj = new _provider_Search_vueSearchClass__WEBPACK_IMPORTED_MODULE_4__.a(state.title, this.novel ? "novel" : this.page.type, state.identifier), 
                    this.searchObj.setPage(this.page), this.searchObj.setSyncPage(this), this.searchObj.setLocalUrl(this.generateLocalUrl(this.page, state)), 
                    this.curState = state, yield this.searchObj.search(), tempSingle = yield this.searchObj.initRules(), 
                    state.detectedEpisode || 0 === state.detectedEpisode ? state.episode = state.detectedEpisode + parseInt(this.searchObj.getRuledOffset(state.detectedEpisode)) : "anime" === this.page.type ? state.episode = 1 : state.episode = 0, 
                    void 0 !== this.page.sync.getVolume && (state.volume = this.page.sync.getVolume(this.url)), 
                    "anime" === this.page.type && Object(_utils_player__WEBPACK_IMPORTED_MODULE_3__.b)((item, player) => {
                        this.tempPlayer = player, this.setVideoTime(item, time => {
                            void 0 !== player ? void 0 !== time && (player.play(), player.currentTime = time) : logger.error("No player Found");
                        });
                    }), logger.m("Sync", "green").log(state); else {
                        if (void 0 === this.page.overview) return void logger.log("No overview definition");
                        if (void 0 !== this.page.isOverviewPage && !this.page.isOverviewPage(this.url)) return void logger.info("Not an overview/sync page");
                        this.loadUI(), state = {
                            on: "OVERVIEW",
                            title: this.page.overview.getTitle(this.url),
                            identifier: this.page.overview.getIdentifier(this.url)
                        }, this.searchObj = new _provider_Search_vueSearchClass__WEBPACK_IMPORTED_MODULE_4__.a(state.title, this.novel ? "novel" : this.page.type, state.identifier), 
                        this.searchObj.setPage(this.page), this.searchObj.setSyncPage(this), this.searchObj.setLocalUrl(this.generateLocalUrl(this.page, state)), 
                        this.curState = state, yield this.searchObj.search(), tempSingle = yield this.searchObj.initRules(), 
                        logger.m("Overview", "green").log(state);
                    }
                    this.curState = state;
                    let malUrl = this.searchObj.getRuledUrl(state.detectedEpisode);
                    const localUrl = this.generateLocalUrl(this.page, state);
                    if (null !== malUrl && malUrl || !api.settings.get("localSync") || (logger.log("Local Fallback"), 
                    malUrl = localUrl), null === malUrl) j.$("#MalInfo").text(api.storage.lang("Not_Found")), 
                    j.$("#MalData").css("display", "none"), logger.log("Not on mal"); else if (malUrl) {
                        logger.log("MyAnimeList", malUrl);
                        try {
                            tempSingle ? this.singleObj = tempSingle : (this.singleObj = Object(_provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__.b)(malUrl), 
                            yield this.singleObj.update());
                        } catch (e) {
                            if (901 === e.code) throw utils.flashm("Incorrect url provided", {
                                error: !0,
                                type: "error"
                            }), e;
                            if (904 !== e.code || !api.settings.get("localSync")) throw this.singleObj.flashmError(e), 
                            this.fillUI(), e;
                            logger.log("Local Fallback"), this.singleObj = Object(_provider_singleFactory__WEBPACK_IMPORTED_MODULE_0__.b)(localUrl), 
                            yield this.singleObj.update();
                        }
                        if ("webextension" === api.type && api.settings.get("rpc")) try {
                            chrome.runtime.sendMessage(extensionId, {
                                mode: "active"
                            }, (function(response) {
                                logger.log("Presence registred", response);
                            }));
                        } catch (e) {
                            logger.error(e);
                        }
                        if (this.fillUI(), this.page.isSyncPage(this.url)) {
                            if (yield this.searchObj.openCorrectionCheck()) return void this.handlePage(curUrl);
                            if (yield this.singleObj.checkSync(state.episode, state.volume)) {
                                if (this.strongVolumes && !state.episode || this.singleObj.setEpisode(state.episode), 
                                this.singleObj.setStreamingUrl(this.page.sync.getOverviewUrl(this.url)), void 0 !== state.volume && state.volume > this.singleObj.getVolume() && this.singleObj.setVolume(state.volume), 
                                logger.log(`Start Sync (${api.settings.get("delay")} Seconds)`), this.singleObj.getMalId() && "anime" === this.singleObj.getType() && api.settings.get("checkForFiller") && this.checkForFiller(this.singleObj.getMalId(), this.singleObj.getEpisode()), 
                                "instant" === api.settings.get("autoTrackingMode" + this.page.type)) setTimeout(() => {
                                    sync();
                                }, 1e3 * api.settings.get("delay")); else {
                                    let message = `<button class="sync" style="margin-bottom: 8px; background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px;cursor: pointer;">${api.storage.lang("syncPage_flashm_sync_" + This.page.type, [ Object(_provider_templates__WEBPACK_IMPORTED_MODULE_2__.a)(malUrl).shortName, String(state.episode) ])}</button>`, options = {
                                        hoverInfo: !0,
                                        error: !0,
                                        type: "update",
                                        minimized: !1
                                    };
                                    "video" === api.settings.get("autoTrackingMode" + this.page.type) && "anime" === this.page.type && (message = `\n                <div id="malSyncProgress" class="ms-loading" style="background-color: transparent; position: absolute; top: 0; left: 0; right: 0; height: 4px;">\n                  <div class="ms-progress" style="background-color: #2980b9; width: 0%; height: 100%; transition: width 1s;"></div>\n                </div>\n                <div class="player-error" style="display: none; position: absolute; left: 0; right: 0; padding: 5px; bottom: 100%; color: rgb(255,64,129); background-color: #323232;">\n                  ${api.storage.lang("syncPage_flash_player_error")}\n                  <a href="https://discord.com/invite/cTH4yaw" style="display: block; padding: 10px">Help</a>\n                </div>\n              ${message}`, 
                                    options = {
                                        hoverInfo: !0,
                                        error: !1,
                                        type: "update",
                                        minimized: !0
                                    }), utils.flashm(message, options).find(".sync").on("click", () => {
                                        j.$(".flashinfo").remove(), sync(), this.resetPlayerError();
                                    }), playerTimeout = setTimeout(() => {
                                        j.$("#flashinfo-div").addClass("player-error");
                                    }, 3e5), logger.log("overviewUrl", This.page.sync.getOverviewUrl(This.url)), void 0 !== This.page.sync.nextEpUrl && logger.log("nextEp", This.page.sync.nextEpUrl(This.url));
                                }
                                function sync() {
                                    if (This.singleObj.setResumeWatching(This.url, state.episode), void 0 !== This.page.sync.nextEpUrl) {
                                        const continueWatching = This.page.sync.nextEpUrl(This.url);
                                        continueWatching && -1 === continueWatching.indexOf("undefined") && This.singleObj.setContinueWatching(continueWatching, state.episode + 1);
                                    }
                                    This.syncHandling(!0);
                                }
                            } else logger.log("Nothing to Sync");
                        }
                        yield this.imageFallback();
                    } else j.$("#MalInfo").text(api.storage.lang("NothingFound")), j.$("#MalData").css("display", "none"), 
                    logger.log("Nothing found");
                }));
            }
            resetPlayerError() {
                playerTimeout && (clearTimeout(playerTimeout), playerTimeout = void 0, j.$("#flashinfo-div").removeClass("player-error"));
            }
            generateLocalUrl(page, state) {
                return `local://${page.name}/${page.type}/${state.identifier}/${encodeURIComponent(state.title)}`;
            }
            openCorrectionUi() {
                if (this.searchObj) return this.searchObj.openCorrection().then(rerun => {
                    rerun && this.handlePage();
                });
            }
            syncHandling(hoverInfo = !1, undo = !1) {
                let p;
                return p = undo ? this.singleObj.undo() : this.singleObj.sync(), p.then(() => {
                    let message = this.singleObj.getTitle(), split = "<br>", totalVol = this.singleObj.getTotalVolumes();
                    0 === totalVol && (totalVol = "?");
                    let totalEp = this.singleObj.getTotalEpisodes();
                    0 === totalEp && (totalEp = "?");
                    let diffState = this.singleObj.getStateDiff();
                    if (diffState || (diffState = {
                        onList: this.singleObj.isOnList(),
                        episode: this.singleObj.getEpisode(),
                        volume: this.singleObj.getVolume(),
                        status: this.singleObj.getStatus(),
                        score: this.singleObj.getScore()
                    }), void 0 === diffState.onList && (diffState.onList = !0), diffState.onList && diffState.status) {
                        let statusString = "";
                        switch (parseInt(diffState.status)) {
                          case 1:
                            statusString = api.storage.lang("UI_Status_watching_" + this.page.type);
                            break;

                          case 2:
                            statusString = api.storage.lang("UI_Status_Completed");
                            break;

                          case 3:
                            statusString = api.storage.lang("UI_Status_OnHold");
                            break;

                          case 4:
                            statusString = api.storage.lang("UI_Status_Dropped");
                            break;

                          case 6:
                            statusString = api.storage.lang("UI_Status_planTo_" + this.page.type);
                            break;

                          case 23:
                            statusString = api.storage.lang("UI_Status_Rewatching_" + this.page.type);
                        }
                        message += split + statusString, split = " | ";
                    }
                    if (diffState.onList || (message += split + api.storage.lang("removed"), split = " | "), 
                    diffState.onList && "manga" === this.page.type && diffState.volume && (message += `${split + api.storage.lang("UI_Volume")} ${diffState.volume}/${totalVol}`, 
                    split = " | "), diffState.onList && diffState.episode && (message += `${split + utils.episode(this.page.type)} ${diffState.episode}/${totalEp}`, 
                    split = " | "), diffState.onList && diffState.score && (message += `${split + api.storage.lang("UI_Score")} ${diffState.score}`, 
                    split = " | "), hoverInfo) {
                        this.fullNotification(message), message += `\n            <br>\n            <button class="undoButton" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px;cursor: pointer;">\n              ${api.storage.lang("syncPage_flashm_sync_undefined_undo")}\n            </button>\n            <button class="wrongButton" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px;cursor: pointer;">\n              ${api.storage.lang("syncPage_flashm_sync_undefined_wrong")}\n            </button>`;
                        const flashmItem = utils.flashm(message, {
                            hoverInfo: !0,
                            type: "update"
                        });
                        flashmItem.find(".undoButton").on("click", e => {
                            const fl = e.target.closest(".flash");
                            fl && fl.remove(), this.syncHandling(!1, !0);
                        }), flashmItem.find(".wrongButton").on("click", e => {
                            this.openCorrectionUi();
                            const fl = e.target.closest(".flash");
                            fl && fl.remove(), this.syncHandling(!1, !0);
                        });
                    } else utils.flashm(message);
                    this.fillUI();
                }).catch(e => {
                    throw this.singleObj.flashmError(e), e;
                });
            }
            fullNotification(text) {
                try {
                    Object(_utils_player__WEBPACK_IMPORTED_MODULE_3__.a)(text), "webextension" === api.type && chrome.runtime.sendMessage({
                        name: "content",
                        item: {
                            action: "fullscreenNotification",
                            text: text
                        }
                    });
                } catch (e) {
                    logger.error(e);
                }
            }
            fillUI() {
                if (j.$(".MalLogin").css("display", "initial"), j.$("#AddMalDiv, #LoginMalDiv").remove(), 
                j.$("#malRating").attr("href", this.singleObj.getDisplayUrl()), this.singleObj.getLastError()) return j.$(".MalLogin").css("display", "none"), 
                j.$("#MalData").css("display", "flex"), j.$("#MalInfo").text(""), void j.$("#malRating").after(j.html(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id='LoginMalDiv'>${this.singleObj.getLastErrorMessage()}</span>`));
                let scoreCheckbox = "";
                this.singleObj.getScoreCheckbox().forEach(el => {
                    scoreCheckbox += `<option value="${el.value}" >${el.label}</option>`;
                }), j.$("#malUserRating").html(j.html(scoreCheckbox));
                let statusCheckbox = "";
                if (this.singleObj.getStatusCheckbox().forEach(el => {
                    statusCheckbox += `<option value="${el.value}" >${el.label}</option>`;
                }), j.$("#malStatus").html(j.html(statusCheckbox)), this.singleObj.getRating().then(rating => {
                    j.$("#malRating").text(rating);
                }), this.singleObj.isOnList()) j.$("#malTotal, #malTotalCha").text(this.singleObj.getTotalEpisodes()), 
                0 === this.singleObj.getTotalEpisodes() && j.$("#malTotal, #malTotalCha").text("?"), 
                j.$("#malTotalVol").text(this.singleObj.getTotalVolumes()), 0 === this.singleObj.getTotalVolumes() && j.$("#malTotalVol").text("?"), 
                j.$("#malEpisodes").val(this.singleObj.getEpisode()), j.$("#malVolumes").val(this.singleObj.getVolume()), 
                j.$("#malStatus").val(this.singleObj.getStatusCheckboxValue()), j.$("#malUserRating").val(this.singleObj.getScoreCheckboxValue()); else {
                    j.$(".MalLogin").css("display", "none"), j.$("#malRating").after(j.html(`<span id='AddMalDiv'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#' id='AddMal' onclick='return false;'>${api.storage.lang("syncPage_malObj_addAnime", [ this.singleObj.shortName ])}</a></span>`));
                    const This = this;
                    j.$("#AddMal").click((function(event) {
                        return __awaiter(this, void 0, void 0, (function*() {
                            event.preventDefault(), This.page.isSyncPage(This.url) || This.singleObj.setStreamingUrl(This.url);
                            (yield This.searchObj.openCorrectionCheck()) ? This.handlePage() : This.syncHandling().then(() => This.singleObj.update()).then(() => {
                                This.fillUI();
                            });
                        }));
                    }));
                }
                j.$("#MalData").css("display", "flex"), j.$("#MalInfo").text(""), this.calcSelectWidth(j.$("#malEpisodes, #malVolumes, #malUserRating, #malStatus")), 
                j.$("#malEpisodes, #malVolumes").trigger("input");
                try {
                    this.handleList(!0);
                } catch (e) {
                    logger.error(e);
                }
            }
            handleList(searchCurrent = !1, reTry = 0) {
                if (j.$(".mal-sync-active").removeClass("mal-sync-active"), void 0 !== this.page.overview && void 0 !== this.page.overview.list) {
                    const epList = this.getEpList();
                    if (void 0 !== epList && epList.length > 0) {
                        this.offsetHandler(epList);
                        const {elementUrl: elementUrl} = this.page.overview.list;
                        logger.log("Episode List", j.$.map(epList, (function(val, i) {
                            return void 0 !== val ? elementUrl(val) : "-";
                        }))), void 0 !== this.page.overview.list.handleListHook && this.page.overview.list.handleListHook(this.singleObj.getEpisode(), epList);
                        const curEp = epList[parseInt(this.singleObj.getEpisode() || 1)];
                        if (void 0 === curEp && !curEp && searchCurrent && reTry < 10 && void 0 !== this.page.overview.list.paginationNext) {
                            logger.log("Pagination next");
                            const This = this;
                            this.page.overview.list.paginationNext(!1) && setTimeout((function() {
                                reTry++, This.handleList(!0, reTry);
                            }), 500);
                        }
                        const nextEp = epList[this.singleObj.getEpisode() + 1];
                        if (void 0 !== nextEp && nextEp && !this.page.isSyncPage(this.url)) {
                            const message = `<a href="${elementUrl(nextEp)}">${api.storage.lang("syncPage_malObj_nextEp_" + this.page.type, [ this.singleObj.getEpisode() + 1 ])}</a>`;
                            utils.flashm(message, {
                                hoverInfo: !0,
                                type: "nextEp",
                                minimized: !0
                            });
                        }
                    }
                }
            }
            getEpList() {
                const This = this, elementArray = [];
                if (void 0 !== this.page.overview && void 0 !== this.page.overview.list) {
                    const {elementEp: elementEp} = this.page.overview.list;
                    let currentEpisode = 0;
                    this.singleObj && (currentEpisode = parseInt(this.singleObj.getEpisode())), this.page.overview.list.elementsSelector().each((function(index, el) {
                        try {
                            const elEp = parseInt("" + elementEp(j.$(el))) + parseInt(This.getOffset());
                            elementArray[elEp] = j.$(el), (api.settings.get("highlightAllEp") && elEp <= currentEpisode || elEp === currentEpisode) && j.$(el).addClass("mal-sync-active");
                        } catch (e) {
                            logger.info(e);
                        }
                    }));
                }
                return elementArray;
            }
            offsetHandler(epList) {
                if (this.page.overview.list.offsetHandler && !this.getOffset() && this.searchObj && "user" !== this.searchObj.provider) for (let i = 0; i < epList.length; ++i) if (void 0 !== epList[i]) {
                    if (logger.log("Offset", i), i > 1) {
                        const calcOffset = 1 - i;
                        utils.flashConfirm(api.storage.lang("syncPage_flashConfirm_offsetHandler_1", [ String(calcOffset) ]), "offset", () => {
                            this.setOffset(calcOffset);
                        }, () => {
                            this.setOffset(0);
                        }, !0);
                    }
                    return;
                }
            }
            imageFallback() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.singleObj && void 0 !== this.singleObj.setImage && this.page.getImage) {
                        const image = yield this.page.getImage();
                        image && this.singleObj.setImage(image);
                    }
                }));
            }
            testForCloudflare() {
                return "Just a moment..." === document.title || -1 !== document.title.indexOf("Cloudflare");
            }
            cdn(type = "default") {
                api.storage.addStyle("\n      .bubbles {\n        display: none !important;\n      }\n      div#cf-content:before {\n        content: '';\n        background-image: url(https://raw.githubusercontent.com/MALSync/MALSync/master/assets/icons/icon128.png);\n        height: 64px;\n        width: 64px;\n        display: block;\n        background-size: cover;\n        animation: rotate 3s linear infinite;\n        background-color: #251e2b;\n        border-radius: 50%;\n      }\n      @keyframes rotate{ to{ transform: rotate(360deg); } }\n    ");
            }
            getOffset() {
                return this.searchObj && this.searchObj.getOffset() ? this.searchObj.getOffset() : 0;
            }
            setOffset(value) {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.searchObj && this.searchObj.setOffset(value), void 0 !== this.singleObj && api.storage.remove(`updateCheck/${this.singleObj.getType()}/${this.singleObj.getCacheKey()}`);
                }));
            }
            loadUI() {
                const This = this;
                if (this.UILoaded) return;
                this.UILoaded = !0;
                let wrapStart = '<span style="display: inline-block;">';
                let ui = '<p id="malp">';
                ui += `<span id="MalInfo">${api.storage.lang("Loading")}</span>`, ui += '<span id="MalData" style="display: none; justify-content: space-between; flex-wrap: wrap;">', 
                ui += wrapStart, ui += `<span class="info">${api.storage.lang("search_Score")} </span>`, 
                ui += '<a id="malRating" style="min-width: 30px;display: inline-block;" target="_blank" href="">____</a>', 
                ui += "</span>", wrapStart = '<span style="display: inline-block; display: none;" class="MalLogin">', 
                ui += wrapStart, ui += `<span class="info">${api.storage.lang("UI_Status")} </span>`, 
                ui += '<select id="malStatus">', ui += "</select>", ui += "</span>";
                let middle = "";
                "anime" === this.page.type ? (middle += wrapStart, middle += `<span class="info">${api.storage.lang("UI_Episode")} </span>`, 
                middle += '<span style=" text-decoration: none; outline: medium none;">', middle += '<input id="malEpisodes" value="0" type="text" size="1" maxlength="4">', 
                middle += '/<span id="malTotal">0</span>', middle += "</span>", middle += "</span>") : (middle += wrapStart, 
                middle += `<span class="info">${api.storage.lang("UI_Volume")} </span>`, middle += '<span style=" text-decoration: none; outline: medium none;">', 
                middle += '<input id="malVolumes" value="0" type="text" size="1" maxlength="4">', 
                middle += '/<span id="malTotalVol">0</span>', middle += "</span>", middle += "</span>", 
                middle += wrapStart, middle += `<span class="info">${api.storage.lang("UI_Chapter")} </span>`, 
                middle += '<span style=" text-decoration: none; outline: medium none;">', middle += '<input id="malEpisodes" value="0" type="text" size="1" maxlength="4">', 
                middle += '/<span id="malTotalCha">0</span>', middle += "</span>", middle += "</span>"), 
                ui += middle, ui += wrapStart, ui += `<span class="info">${api.storage.lang("UI_Score")}</span>`, 
                ui += '<select id="malUserRating">', ui += "</select>", ui += "</span>", ui += "</span>", 
                ui += "</p>", this.page.isSyncPage(this.url) ? void 0 !== this.page.sync.uiSelector && this.page.sync.uiSelector(ui) : void 0 !== this.page.overview && this.page.overview.uiSelector(ui), 
                j.$("#malEpisodes, #malVolumes, #malUserRating, #malStatus").change((function() {
                    This.buttonclick();
                    const el = j.$(this);
                    This.calcSelectWidth(el);
                })), j.$("#malEpisodes, #malVolumes").on("input", (function() {
                    const el = j.$(this);
                    let numberlength = el.val().toString().length;
                    numberlength < 1 && (numberlength = 1);
                    const numberWidth = 7.7 * numberlength + 3;
                    el.css("width", numberWidth + "px");
                })).trigger("input");
            }
            calcSelectWidth(selectors) {
                selectors.each((function(index, selector) {
                    const text = j.$(selector).find("option:selected").text(), aux = j.$('<select style="width: auto;"/>').append(j.html(`<option>${text}</option>`)), width = aux.width() || 0;
                    width && (j.$("#malp").append(j.html(aux)), j.$(selector).width(width + 5), aux.remove());
                }));
            }
            buttonclick() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.singleObj.setEpisode(j.$("#malEpisodes").val()), j.$("#malVolumes").length && this.singleObj.setVolume(j.$("#malVolumes").val()), 
                    this.singleObj.handleScoreCheckbox(j.$("#malUserRating").val()), this.singleObj.handleStatusCheckbox(j.$("#malStatus").val()), 
                    this.page.isSyncPage(this.url) || this.singleObj.setStreamingUrl(this.url);
                    (yield this.searchObj.openCorrectionCheck()) ? this.handlePage() : this.syncHandling().then(() => this.singleObj.update()).then(() => {
                        this.fillUI();
                    });
                }));
            }
            presence(info, sender, sendResponse) {
                try {
                    if ("presence" === info.action) {
                        console.log("Presence requested", info, this.curState), clearTimeout(browsingTimeout), 
                        browsingTimeout = setTimeout(() => {
                            this.browsingtime = void 0;
                        }, 3e5), this.browsingtime || (this.browsingtime = Date.now());
                        let largeImageKeyTemp, largeImageTextTemp, clientId = "823563096747802695";
                        if ("anime" !== this.page.type && (clientId = "823563138669608980"), api.settings.get("presenceHidePage") ? (largeImageKeyTemp = "malsync", 
                        largeImageTextTemp = "MAL-Sync") : (largeImageKeyTemp = this.page.name.toLowerCase(), 
                        largeImageTextTemp = this.page.name + " â€¢ MAL-Sync"), this.curState) {
                            const pres = {
                                clientId: clientId,
                                presence: {
                                    details: this.singleObj.getTitle(!0) || this.curState.title,
                                    largeImageKey: largeImageKeyTemp,
                                    largeImageText: largeImageTextTemp,
                                    instance: !0
                                }
                            };
                            if (api.settings.get("presenceShowButtons")) {
                                let url = this.singleObj.getMalUrl();
                                url || "Local" === this.singleObj.shortName || (url = this.singleObj.getDisplayUrl()), 
                                url || api.settings.get("presenceHidePage") || (url = this.singleObj.getStreamingUrl()), 
                                url && (pres.presence.buttons = [ {
                                    label: api.storage.lang("discord_rpc_view_" + this.singleObj.getType()),
                                    url: url
                                } ]);
                            }
                            if (void 0 !== this.curState.episode) {
                                const ep = this.curState.episode;
                                let totalEp = this.singleObj.getTotalEpisodes();
                                if (totalEp || (totalEp = "?"), pres.presence.state = `${utils.episode(this.page.type)} ${ep} of ${totalEp}`, 
                                void 0 !== this.curState.lastVideoTime) if (this.curState.lastVideoTime.paused) pres.presence.smallImageKey = "pause", 
                                pres.presence.smallImageText = "Paused"; else {
                                    const timeleft = this.curState.lastVideoTime.duration - this.curState.lastVideoTime.current;
                                    pres.presence.endTimestamp = Date.now() + 1e3 * timeleft, pres.presence.smallImageKey = "play", 
                                    pres.presence.smallImageText = "Playing";
                                } else pres.presence.startTimestamp = this.browsingtime, "anime" !== this.page.type && (pres.presence.smallImageKey = "reading", 
                                pres.presence.smallImageText = "Reading");
                            } else {
                                let browsingTemp;
                                browsingTemp = api.settings.get("presenceHidePage") ? this.page.type.toString() : this.page.name, 
                                pres.presence.startTimestamp = this.browsingtime, pres.presence.state = api.storage.lang("Discord_rpc_browsing", [ browsingTemp ]);
                            }
                            return void sendResponse(pres);
                        }
                    }
                } catch (e) {
                    logger.error(e);
                }
                sendResponse({});
            }
            checkForFiller(malid, episode) {
                return __awaiter(this, void 0, void 0, (function*() {
                    const page = Math.ceil(episode / 100), cacheObj = new _utils_Cache__WEBPACK_IMPORTED_MODULE_6__.a(`fillers/${malid}/${page}`, 6048e5);
                    if (!(yield cacheObj.hasValueAndIsNotEmpty())) {
                        const url = `https://api.jikan.moe/v3/anime/${malid}/episodes/${page}`, request = yield api.request.xhr("GET", url).then(response => __awaiter(this, void 0, void 0, (function*() {
                            if (200 === response.status && response.responseText) {
                                const data = JSON.parse(response.responseText);
                                if (data.episodes && data.episodes.length) try {
                                    return data.episodes.map(e => ({
                                        filler: e.filler,
                                        recap: e.recap,
                                        episode_id: e.episode_id
                                    }));
                                } catch (e) {}
                            }
                            return [];
                        })));
                        yield cacheObj.setValue(request);
                    }
                    const episodes = yield cacheObj.getValue();
                    if (episodes && episodes.length) {
                        const episodeData = episodes.find(e => e.episode_id === episode);
                        if (episodeData && (episodeData.filler || episodeData.recap)) {
                            const type = episodeData.filler ? "filler" : "recap";
                            utils.flashConfirm(api.storage.lang(`filler_${type}_confirm`), "filler", () => {
                                this.openNextEp();
                            }, () => {}, !0);
                        }
                    }
                }));
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(2), __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
    (function(process, setImmediate) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        !function(undefined) {
            var hasOwnProperty = Object.hasOwnProperty, isArray = Array.isArray ? Array.isArray : function(obj) {
                return "[object Array]" === Object.prototype.toString.call(obj);
            }, nextTickSupported = "object" == typeof process && "function" == typeof process.nextTick, symbolsSupported = "function" == typeof Symbol, reflectSupported = "object" == typeof Reflect, _setImmediate = "function" == typeof setImmediate ? setImmediate : setTimeout, ownKeys = symbolsSupported ? reflectSupported && "function" == typeof Reflect.ownKeys ? Reflect.ownKeys : function(obj) {
                var arr = Object.getOwnPropertyNames(obj);
                return arr.push.apply(arr, Object.getOwnPropertySymbols(obj)), arr;
            } : Object.keys;
            function init() {
                this._events = {}, this._conf && configure.call(this, this._conf);
            }
            function configure(conf) {
                conf && (this._conf = conf, conf.delimiter && (this.delimiter = conf.delimiter), 
                void 0 !== conf.maxListeners && (this._maxListeners = conf.maxListeners), conf.wildcard && (this.wildcard = conf.wildcard), 
                conf.newListener && (this._newListener = conf.newListener), conf.removeListener && (this._removeListener = conf.removeListener), 
                conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak), conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors), 
                this.wildcard && (this.listenerTree = {}));
            }
            function logPossibleMemoryLeak(count, eventName) {
                var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
                if (this.verboseMemoryLeak && (errorMsg += " Event name: " + eventName + "."), void 0 !== process && process.emitWarning) {
                    var e = new Error(errorMsg);
                    e.name = "MaxListenersExceededWarning", e.emitter = this, e.count = count, process.emitWarning(e);
                } else console.error(errorMsg), console.trace && console.trace();
            }
            var toArray = function(a, b, c) {
                var n = arguments.length;
                switch (n) {
                  case 0:
                    return [];

                  case 1:
                    return [ a ];

                  case 2:
                    return [ a, b ];

                  case 3:
                    return [ a, b, c ];

                  default:
                    for (var arr = new Array(n); n--; ) arr[n] = arguments[n];
                    return arr;
                }
            };
            function toObject(keys, values) {
                for (var obj = {}, len = keys.length, valuesCount = values ? value.length : 0, i = 0; i < len; i++) obj[keys[i]] = i < valuesCount ? values[i] : void 0;
                return obj;
            }
            function TargetObserver(emitter, target, options) {
                var on, off;
                if (this._emitter = emitter, this._target = target, this._listeners = {}, this._listenersCount = 0, 
                (options.on || options.off) && (on = options.on, off = options.off), target.addEventListener ? (on = target.addEventListener, 
                off = target.removeEventListener) : target.addListener ? (on = target.addListener, 
                off = target.removeListener) : target.on && (on = target.on, off = target.off), 
                !on && !off) throw Error("target does not implement any known event API");
                if ("function" != typeof on) throw TypeError("on method must be a function");
                if ("function" != typeof off) throw TypeError("off method must be a function");
                this._on = on, this._off = off;
                var _observers = emitter._observers;
                _observers ? _observers.push(this) : emitter._observers = [ this ];
            }
            function resolveOptions(options, schema, reducers, allowUnknown) {
                var computedOptions = Object.assign({}, schema);
                if (!options) return computedOptions;
                if ("object" != typeof options) throw TypeError("options must be an object");
                var option, value, reducer, keys = Object.keys(options), length = keys.length;
                function reject(reason) {
                    throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
                }
                for (var i = 0; i < length; i++) {
                    if (option = keys[i], !allowUnknown && !hasOwnProperty.call(schema, option)) throw Error('Unknown "' + option + '" option');
                    void 0 !== (value = options[option]) && (reducer = reducers[option], computedOptions[option] = reducer ? reducer(value, reject) : value);
                }
                return computedOptions;
            }
            function constructorReducer(value, reject) {
                return "function" == typeof value && value.hasOwnProperty("prototype") || reject("value must be a constructor"), 
                value;
            }
            function makeTypeReducer(types) {
                var message = "value must be type of " + types.join("|"), len = types.length, firstType = types[0], secondType = types[1];
                return 1 === len ? function(v, reject) {
                    if (typeof v === firstType) return v;
                    reject(message);
                } : 2 === len ? function(v, reject) {
                    var kind = typeof v;
                    if (kind === firstType || kind === secondType) return v;
                    reject(message);
                } : function(v, reject) {
                    for (var kind = typeof v, i = len; i-- > 0; ) if (kind === types[i]) return v;
                    reject(message);
                };
            }
            Object.assign(TargetObserver.prototype, {
                subscribe: function(event, localEvent, reducer) {
                    var observer = this, target = this._target, emitter = this._emitter, listeners = this._listeners, handler = function() {
                        var args = toArray.apply(null, arguments), eventObj = {
                            data: args,
                            name: localEvent,
                            original: event
                        };
                        if (reducer) {
                            var result = reducer.call(target, eventObj);
                            !1 !== result && emitter.emit.apply(emitter, [ eventObj.name ].concat(args));
                        } else emitter.emit.apply(emitter, [ localEvent ].concat(args));
                    };
                    if (listeners[event]) throw Error("Event '" + event + "' is already listening");
                    this._listenersCount++, emitter._newListener && emitter._removeListener && !observer._onNewListener ? (this._onNewListener = function(_event) {
                        _event === localEvent && null === listeners[event] && (listeners[event] = handler, 
                        observer._on.call(target, event, handler));
                    }, emitter.on("newListener", this._onNewListener), this._onRemoveListener = function(_event) {
                        _event === localEvent && !emitter.hasListeners(_event) && listeners[event] && (listeners[event] = null, 
                        observer._off.call(target, event, handler));
                    }, listeners[event] = null, emitter.on("removeListener", this._onRemoveListener)) : (listeners[event] = handler, 
                    observer._on.call(target, event, handler));
                },
                unsubscribe: function(event) {
                    var handler, events, i, observer = this, listeners = this._listeners, emitter = this._emitter, off = this._off, target = this._target;
                    if (event && "string" != typeof event) throw TypeError("event must be a string");
                    function clearRefs() {
                        observer._onNewListener && (emitter.off("newListener", observer._onNewListener), 
                        emitter.off("removeListener", observer._onRemoveListener), observer._onNewListener = null, 
                        observer._onRemoveListener = null);
                        var index = findTargetIndex.call(emitter, observer);
                        emitter._observers.splice(index, 1);
                    }
                    if (event) {
                        if (!(handler = listeners[event])) return;
                        off.call(target, event, handler), delete listeners[event], --this._listenersCount || clearRefs();
                    } else {
                        for (i = (events = ownKeys(listeners)).length; i-- > 0; ) event = events[i], off.call(target, event, listeners[event]);
                        this._listeners = {}, this._listenersCount = 0, clearRefs();
                    }
                }
            });
            var functionReducer = makeTypeReducer([ "function" ]), objectFunctionReducer = makeTypeReducer([ "object", "function" ]);
            function makeCancelablePromise(Promise, executor, options) {
                var isCancelable, callbacks, subscriptionClosed, timer = 0, promise = new Promise((function(resolve, reject, onCancel) {
                    function cleanup() {
                        callbacks && (callbacks = null), timer && (clearTimeout(timer), timer = 0);
                    }
                    options = resolveOptions(options, {
                        timeout: 0,
                        overload: !1
                    }, {
                        timeout: function(value, reject) {
                            return ("number" != typeof (value *= 1) || value < 0 || !Number.isFinite(value)) && reject("timeout must be a positive number"), 
                            value;
                        }
                    }), isCancelable = !options.overload && "function" == typeof Promise.prototype.cancel && "function" == typeof onCancel;
                    var _resolve = function(value) {
                        cleanup(), resolve(value);
                    }, _reject = function(err) {
                        cleanup(), reject(err);
                    };
                    isCancelable ? executor(_resolve, _reject, onCancel) : (callbacks = [ function(reason) {
                        _reject(reason || Error("canceled"));
                    } ], executor(_resolve, _reject, (function(cb) {
                        if (subscriptionClosed) throw Error("Unable to subscribe on cancel event asynchronously");
                        if ("function" != typeof cb) throw TypeError("onCancel callback must be a function");
                        callbacks.push(cb);
                    })), subscriptionClosed = !0), options.timeout > 0 && (timer = setTimeout((function() {
                        var reason = Error("timeout");
                        timer = 0, promise.cancel(reason), reject(reason);
                    }), options.timeout));
                }));
                return isCancelable || (promise.cancel = function(reason) {
                    if (callbacks) {
                        for (var length = callbacks.length, i = 1; i < length; i++) callbacks[i](reason);
                        callbacks[0](reason), callbacks = null;
                    }
                }), promise;
            }
            function findTargetIndex(observer) {
                var observers = this._observers;
                if (!observers) return -1;
                for (var len = observers.length, i = 0; i < len; i++) if (observers[i]._target === observer) return i;
                return -1;
            }
            function searchListenerTree(handlers, type, tree, i, typeLength) {
                if (!tree) return null;
                if (0 === i) {
                    var kind = typeof type;
                    if ("string" === kind) {
                        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
                        if (-1 !== (n = type.indexOf(delimiter))) {
                            ns = new Array(5);
                            do {
                                ns[l++] = type.slice(j, n), j = n + dl;
                            } while (-1 !== (n = type.indexOf(delimiter, j)));
                            ns[l++] = type.slice(j), type = ns, typeLength = l;
                        } else type = [ type ], typeLength = 1;
                    } else "object" === kind ? typeLength = type.length : (type = [ type ], typeLength = 1);
                }
                var branch, xTree, xxTree, isolatedBranch, endReached, branches, _listeners, listeners = null, currentType = type[i], nextType = type[i + 1];
                if (i === typeLength && tree._listeners) return "function" == typeof tree._listeners ? (handlers && handlers.push(tree._listeners), 
                [ tree ]) : (handlers && handlers.push.apply(handlers, tree._listeners), [ tree ]);
                if ("*" === currentType) {
                    for (n = (branches = ownKeys(tree)).length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && (_listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength)) && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners);
                    return listeners;
                }
                if ("**" === currentType) {
                    for ((endReached = i + 1 === typeLength || i + 2 === typeLength && "*" === nextType) && tree._listeners && (listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength)), 
                    n = (branches = ownKeys(tree)).length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && ("*" === branch || "**" === branch ? (tree[branch]._listeners && !endReached && (_listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength)) && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners), 
                    _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength)) : _listeners = searchListenerTree(handlers, type, tree[branch], branch === nextType ? i + 2 : i, typeLength), 
                    _listeners && (listeners ? listeners.push.apply(listeners, _listeners) : listeners = _listeners));
                    return listeners;
                }
                if (tree[currentType] && (listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength)), 
                (xTree = tree["*"]) && searchListenerTree(handlers, type, xTree, i + 1, typeLength), 
                xxTree = tree["**"]) if (i < typeLength) for (xxTree._listeners && searchListenerTree(handlers, type, xxTree, typeLength, typeLength), 
                n = (branches = ownKeys(xxTree)).length; n-- > 0; ) "_listeners" !== (branch = branches[n]) && (branch === nextType ? searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength) : branch === currentType ? searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength) : ((isolatedBranch = {})[branch] = xxTree[branch], 
                searchListenerTree(handlers, type, {
                    "**": isolatedBranch
                }, i + 1, typeLength))); else xxTree._listeners ? searchListenerTree(handlers, type, xxTree, typeLength, typeLength) : xxTree["*"] && xxTree["*"]._listeners && searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
                return listeners;
            }
            function growListenerTree(type, listener) {
                var i, ns, len = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
                if ("string" == typeof type) if (-1 !== (i = type.indexOf(delimiter))) {
                    ns = new Array(5);
                    do {
                        ns[len++] = type.slice(j, i), j = i + dl;
                    } while (-1 !== (i = type.indexOf(delimiter, j)));
                    ns[len++] = type.slice(j);
                } else ns = [ type ], len = 1; else ns = type, len = type.length;
                if (len > 1) for (i = 0; i + 1 < len; i++) if ("**" === ns[i] && "**" === ns[i + 1]) return;
                var name, tree = this.listenerTree;
                for (i = 0; i < len; i++) if (tree = tree[name = ns[i]] || (tree[name] = {}), i === len - 1) return tree._listeners ? ("function" == typeof tree._listeners && (tree._listeners = [ tree._listeners ]), 
                tree._listeners.push(listener), !tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners && (tree._listeners.warned = !0, 
                logPossibleMemoryLeak.call(this, tree._listeners.length, name))) : tree._listeners = listener, 
                !0;
                return !0;
            }
            function collectTreeEvents(tree, events, root, asArray) {
                for (var branch, branchName, path, isArrayPath, branches = ownKeys(tree), i = branches.length, hasListeners = tree._listeners; i-- > 0; ) branch = tree[branchName = branches[i]], 
                path = "_listeners" === branchName ? root : root ? root.concat(branchName) : [ branchName ], 
                isArrayPath = asArray || "symbol" == typeof branchName, hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter)), 
                "object" == typeof branch && collectTreeEvents.call(this, branch, events, path, isArrayPath);
                return events;
            }
            function recursivelyGarbageCollect(root) {
                for (var obj, key, flag, keys = ownKeys(root), i = keys.length; i-- > 0; ) (obj = root[key = keys[i]]) && (flag = !0, 
                "_listeners" === key || recursivelyGarbageCollect(obj) || delete root[key]);
                return flag;
            }
            function Listener(emitter, event, listener) {
                this.emitter = emitter, this.event = event, this.listener = listener;
            }
            function setupListener(event, listener, options) {
                if (!0 === options) promisify = !0; else if (!1 === options) async = !0; else {
                    if (!options || "object" != typeof options) throw TypeError("options should be an object or true");
                    var async = options.async, promisify = options.promisify, nextTick = options.nextTick, objectify = options.objectify;
                }
                if (async || nextTick || promisify) {
                    var _listener = listener, _origin = listener._origin || listener;
                    if (nextTick && !nextTickSupported) throw Error("process.nextTick is not supported");
                    void 0 === promisify && (promisify = "AsyncFunction" === listener.constructor.name), 
                    (listener = function() {
                        var args = arguments, context = this, event = this.event;
                        return promisify ? nextTick ? Promise.resolve() : new Promise((function(resolve) {
                            _setImmediate(resolve);
                        })).then((function() {
                            return context.event = event, _listener.apply(context, args);
                        })) : (nextTick ? process.nextTick : _setImmediate)((function() {
                            context.event = event, _listener.apply(context, args);
                        }));
                    })._async = !0, listener._origin = _origin;
                }
                return [ listener, objectify ? new Listener(this, event, listener) : this ];
            }
            function EventEmitter(conf) {
                this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, 
                configure.call(this, conf);
            }
            Listener.prototype.off = function() {
                return this.emitter.off(this.event, this.listener), this;
            }, EventEmitter.EventEmitter2 = EventEmitter, EventEmitter.prototype.listenTo = function(target, events, options) {
                if ("object" != typeof target) throw TypeError("target musts be an object");
                var emitter = this;
                function listen(events) {
                    if ("object" != typeof events) throw TypeError("events must be an object");
                    var observer, reducers = options.reducers, index = findTargetIndex.call(emitter, target);
                    observer = -1 === index ? new TargetObserver(emitter, target, options) : emitter._observers[index];
                    for (var event, keys = ownKeys(events), len = keys.length, isSingleReducer = "function" == typeof reducers, i = 0; i < len; i++) event = keys[i], 
                    observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
                }
                return options = resolveOptions(options, {
                    on: void 0,
                    off: void 0,
                    reducers: void 0
                }, {
                    on: functionReducer,
                    off: functionReducer,
                    reducers: objectFunctionReducer
                }), isArray(events) ? listen(toObject(events)) : listen("string" == typeof events ? toObject(events.split(/\s+/)) : events), 
                this;
            }, EventEmitter.prototype.stopListeningTo = function(target, event) {
                var observers = this._observers;
                if (!observers) return !1;
                var observer, i = observers.length, matched = !1;
                if (target && "object" != typeof target) throw TypeError("target should be an object");
                for (;i-- > 0; ) observer = observers[i], target && observer._target !== target || (observer.unsubscribe(event), 
                matched = !0);
                return matched;
            }, EventEmitter.prototype.delimiter = ".", EventEmitter.prototype.setMaxListeners = function(n) {
                void 0 !== n && (this._maxListeners = n, this._conf || (this._conf = {}), this._conf.maxListeners = n);
            }, EventEmitter.prototype.getMaxListeners = function() {
                return this._maxListeners;
            }, EventEmitter.prototype.event = "", EventEmitter.prototype.once = function(event, fn, options) {
                return this._once(event, fn, !1, options);
            }, EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
                return this._once(event, fn, !0, options);
            }, EventEmitter.prototype._once = function(event, fn, prepend, options) {
                return this._many(event, 1, fn, prepend, options);
            }, EventEmitter.prototype.many = function(event, ttl, fn, options) {
                return this._many(event, ttl, fn, !1, options);
            }, EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
                return this._many(event, ttl, fn, !0, options);
            }, EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
                var self = this;
                if ("function" != typeof fn) throw new Error("many only accepts instances of Function");
                function listener() {
                    return 0 == --ttl && self.off(event, listener), fn.apply(this, arguments);
                }
                return listener._origin = fn, this._on(event, listener, prepend, options);
            }, EventEmitter.prototype.emit = function() {
                if (!this._events && !this._all) return !1;
                this._events || init.call(this);
                var ns, args, l, i, j, containsSymbol, type = arguments[0], wildcard = this.wildcard;
                if ("newListener" === type && !this._newListener && !this._events.newListener) return !1;
                if (wildcard && (ns = type, "newListener" !== type && "removeListener" !== type && "object" == typeof type)) {
                    if (l = type.length, symbolsSupported) for (i = 0; i < l; i++) if ("symbol" == typeof type[i]) {
                        containsSymbol = !0;
                        break;
                    }
                    containsSymbol || (type = type.join(this.delimiter));
                }
                var handler, al = arguments.length;
                if (this._all && this._all.length) for (i = 0, l = (handler = this._all.slice()).length; i < l; i++) switch (this.event = type, 
                al) {
                  case 1:
                    handler[i].call(this, type);
                    break;

                  case 2:
                    handler[i].call(this, type, arguments[1]);
                    break;

                  case 3:
                    handler[i].call(this, type, arguments[1], arguments[2]);
                    break;

                  default:
                    handler[i].apply(this, arguments);
                }
                if (wildcard) handler = [], searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l); else {
                    if ("function" == typeof (handler = this._events[type])) {
                        switch (this.event = type, al) {
                          case 1:
                            handler.call(this);
                            break;

                          case 2:
                            handler.call(this, arguments[1]);
                            break;

                          case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;

                          default:
                            for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                            handler.apply(this, args);
                        }
                        return !0;
                    }
                    handler && (handler = handler.slice());
                }
                if (handler && handler.length) {
                    if (al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        handler[i].call(this);
                        break;

                      case 2:
                        handler[i].call(this, arguments[1]);
                        break;

                      case 3:
                        handler[i].call(this, arguments[1], arguments[2]);
                        break;

                      default:
                        handler[i].apply(this, args);
                    }
                    return !0;
                }
                if (!this.ignoreErrors && !this._all && "error" === type) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
                return !!this._all;
            }, EventEmitter.prototype.emitAsync = function() {
                if (!this._events && !this._all) return !1;
                this._events || init.call(this);
                var ns, containsSymbol, args, l, i, j, type = arguments[0], wildcard = this.wildcard;
                if ("newListener" === type && !this._newListener && !this._events.newListener) return Promise.resolve([ !1 ]);
                if (wildcard && (ns = type, "newListener" !== type && "removeListener" !== type && "object" == typeof type)) {
                    if (l = type.length, symbolsSupported) for (i = 0; i < l; i++) if ("symbol" == typeof type[i]) {
                        containsSymbol = !0;
                        break;
                    }
                    containsSymbol || (type = type.join(this.delimiter));
                }
                var handler, promises = [], al = arguments.length;
                if (this._all) for (i = 0, l = this._all.length; i < l; i++) switch (this.event = type, 
                al) {
                  case 1:
                    promises.push(this._all[i].call(this, type));
                    break;

                  case 2:
                    promises.push(this._all[i].call(this, type, arguments[1]));
                    break;

                  case 3:
                    promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                    break;

                  default:
                    promises.push(this._all[i].apply(this, arguments));
                }
                if (wildcard ? (handler = [], searchListenerTree.call(this, handler, ns, this.listenerTree, 0)) : handler = this._events[type], 
                "function" == typeof handler) switch (this.event = type, al) {
                  case 1:
                    promises.push(handler.call(this));
                    break;

                  case 2:
                    promises.push(handler.call(this, arguments[1]));
                    break;

                  case 3:
                    promises.push(handler.call(this, arguments[1], arguments[2]));
                    break;

                  default:
                    for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    promises.push(handler.apply(this, args));
                } else if (handler && handler.length) {
                    if (handler = handler.slice(), al > 3) for (args = new Array(al - 1), j = 1; j < al; j++) args[j - 1] = arguments[j];
                    for (i = 0, l = handler.length; i < l; i++) switch (this.event = type, al) {
                      case 1:
                        promises.push(handler[i].call(this));
                        break;

                      case 2:
                        promises.push(handler[i].call(this, arguments[1]));
                        break;

                      case 3:
                        promises.push(handler[i].call(this, arguments[1], arguments[2]));
                        break;

                      default:
                        promises.push(handler[i].apply(this, args));
                    }
                } else if (!this.ignoreErrors && !this._all && "error" === type) return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
                return Promise.all(promises);
            }, EventEmitter.prototype.on = function(type, listener, options) {
                return this._on(type, listener, !1, options);
            }, EventEmitter.prototype.prependListener = function(type, listener, options) {
                return this._on(type, listener, !0, options);
            }, EventEmitter.prototype.onAny = function(fn) {
                return this._onAny(fn, !1);
            }, EventEmitter.prototype.prependAny = function(fn) {
                return this._onAny(fn, !0);
            }, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prototype._onAny = function(fn, prepend) {
                if ("function" != typeof fn) throw new Error("onAny only accepts instances of Function");
                return this._all || (this._all = []), prepend ? this._all.unshift(fn) : this._all.push(fn), 
                this;
            }, EventEmitter.prototype._on = function(type, listener, prepend, options) {
                if ("function" == typeof type) return this._onAny(type, listener), this;
                if ("function" != typeof listener) throw new Error("on only accepts instances of Function");
                this._events || init.call(this);
                var temp, returnValue = this;
                return void 0 !== options && (listener = (temp = setupListener.call(this, type, listener, options))[0], 
                returnValue = temp[1]), this._newListener && this.emit("newListener", type, listener), 
                this.wildcard ? (growListenerTree.call(this, type, listener), returnValue) : (this._events[type] ? ("function" == typeof this._events[type] && (this._events[type] = [ this._events[type] ]), 
                prepend ? this._events[type].unshift(listener) : this._events[type].push(listener), 
                !this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners && (this._events[type].warned = !0, 
                logPossibleMemoryLeak.call(this, this._events[type].length, type))) : this._events[type] = listener, 
                returnValue);
            }, EventEmitter.prototype.off = function(type, listener) {
                if ("function" != typeof listener) throw new Error("removeListener only takes instances of Function");
                var handlers, leafs = [];
                if (this.wildcard) {
                    var ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    if (!(leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0))) return this;
                } else {
                    if (!this._events[type]) return this;
                    handlers = this._events[type], leafs.push({
                        _listeners: handlers
                    });
                }
                for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
                    var leaf = leafs[iLeaf];
                    if (handlers = leaf._listeners, isArray(handlers)) {
                        for (var position = -1, i = 0, length = handlers.length; i < length; i++) if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                            position = i;
                            break;
                        }
                        if (position < 0) continue;
                        return this.wildcard ? leaf._listeners.splice(position, 1) : this._events[type].splice(position, 1), 
                        0 === handlers.length && (this.wildcard ? delete leaf._listeners : delete this._events[type]), 
                        this._removeListener && this.emit("removeListener", type, listener), this;
                    }
                    (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) && (this.wildcard ? delete leaf._listeners : delete this._events[type], 
                    this._removeListener && this.emit("removeListener", type, listener));
                }
                return this.listenerTree && recursivelyGarbageCollect(this.listenerTree), this;
            }, EventEmitter.prototype.offAny = function(fn) {
                var fns, i = 0, l = 0;
                if (fn && this._all && this._all.length > 0) {
                    for (i = 0, l = (fns = this._all).length; i < l; i++) if (fn === fns[i]) return fns.splice(i, 1), 
                    this._removeListener && this.emit("removeListenerAny", fn), this;
                } else {
                    if (fns = this._all, this._removeListener) for (i = 0, l = fns.length; i < l; i++) this.emit("removeListenerAny", fns[i]);
                    this._all = [];
                }
                return this;
            }, EventEmitter.prototype.removeListener = EventEmitter.prototype.off, EventEmitter.prototype.removeAllListeners = function(type) {
                if (void 0 === type) return !this._events || init.call(this), this;
                if (this.wildcard) {
                    var i, leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0);
                    if (!leafs) return this;
                    for (i = 0; i < leafs.length; i++) leafs[i]._listeners = null;
                    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
                } else this._events && (this._events[type] = null);
                return this;
            }, EventEmitter.prototype.listeners = function(type) {
                var keys, listeners, allListeners, i, listenerTree, _events = this._events;
                if (void 0 === type) {
                    if (this.wildcard) throw Error("event name required for wildcard emitter");
                    if (!_events) return [];
                    for (i = (keys = ownKeys(_events)).length, allListeners = []; i-- > 0; ) "function" == typeof (listeners = _events[keys[i]]) ? allListeners.push(listeners) : allListeners.push.apply(allListeners, listeners);
                    return allListeners;
                }
                if (this.wildcard) {
                    if (!(listenerTree = this.listenerTree)) return [];
                    var handlers = [], ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    return searchListenerTree.call(this, handlers, ns, listenerTree, 0), handlers;
                }
                return _events && (listeners = _events[type]) ? "function" == typeof listeners ? [ listeners ] : listeners : [];
            }, EventEmitter.prototype.eventNames = function(nsAsArray) {
                var _events = this._events;
                return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
            }, EventEmitter.prototype.listenerCount = function(type) {
                return this.listeners(type).length;
            }, EventEmitter.prototype.hasListeners = function(type) {
                if (this.wildcard) {
                    var handlers = [], ns = "string" == typeof type ? type.split(this.delimiter) : type.slice();
                    return searchListenerTree.call(this, handlers, ns, this.listenerTree, 0), handlers.length > 0;
                }
                var _events = this._events, _all = this._all;
                return !!(_all && _all.length || _events && (void 0 === type ? ownKeys(_events).length : _events[type]));
            }, EventEmitter.prototype.listenersAny = function() {
                return this._all ? this._all : [];
            }, EventEmitter.prototype.waitFor = function(event, options) {
                var self = this, type = typeof options;
                return "number" === type ? options = {
                    timeout: options
                } : "function" === type && (options = {
                    filter: options
                }), makeCancelablePromise((options = resolveOptions(options, {
                    timeout: 0,
                    filter: void 0,
                    handleError: !1,
                    Promise: Promise,
                    overload: !1
                }, {
                    filter: functionReducer,
                    Promise: constructorReducer
                })).Promise, (function(resolve, reject, onCancel) {
                    function listener() {
                        var filter = options.filter;
                        if (!filter || filter.apply(self, arguments)) if (self.off(event, listener), options.handleError) {
                            var err = arguments[0];
                            err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
                        } else resolve(toArray.apply(null, arguments));
                    }
                    onCancel((function() {
                        self.off(event, listener);
                    })), self._on(event, listener, !1);
                }), {
                    timeout: options.timeout,
                    overload: options.overload
                });
            };
            var prototype = EventEmitter.prototype;
            Object.defineProperties(EventEmitter, {
                defaultMaxListeners: {
                    get: function() {
                        return prototype._maxListeners;
                    },
                    set: function(n) {
                        if ("number" != typeof n || n < 0 || Number.isNaN(n)) throw TypeError("n must be a non-negative number");
                        prototype._maxListeners = n;
                    },
                    enumerable: !0
                },
                once: {
                    value: function(emitter, name, options) {
                        return makeCancelablePromise((options = resolveOptions(options, {
                            Promise: Promise,
                            timeout: 0,
                            overload: !1
                        }, {
                            Promise: constructorReducer
                        })).Promise, (function(resolve, reject, onCancel) {
                            var handler;
                            if ("function" == typeof emitter.addEventListener) return handler = function() {
                                resolve(toArray.apply(null, arguments));
                            }, onCancel((function() {
                                emitter.removeEventListener(name, handler);
                            })), void emitter.addEventListener(name, handler, {
                                once: !0
                            });
                            var errorListener, eventListener = function() {
                                errorListener && emitter.removeListener("error", errorListener), resolve(toArray.apply(null, arguments));
                            };
                            "error" !== name && (errorListener = function(err) {
                                emitter.removeListener(name, eventListener), reject(err);
                            }, emitter.once("error", errorListener)), onCancel((function() {
                                errorListener && emitter.removeListener("error", errorListener), emitter.removeListener(name, eventListener);
                            })), emitter.once(name, eventListener);
                        }), {
                            timeout: options.timeout,
                            overload: options.overload
                        });
                    },
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperties(prototype, {
                _maxListeners: {
                    value: 10,
                    writable: !0,
                    configurable: !0
                },
                _observers: {
                    value: null,
                    writable: !0,
                    configurable: !0
                }
            }), void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return EventEmitter;
            }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        }();
    }).call(this, __webpack_require__(94), __webpack_require__(95).setImmediate);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UserList;
        }));
        var _listAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class UserList extends _listAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.name = "local", this.authenticationUrl = "", this.getRegex = _helper__WEBPACK_IMPORTED_MODULE_1__.b, 
                this.getSyncList = _helper__WEBPACK_IMPORTED_MODULE_1__.c, this.getCacheKey = _helper__WEBPACK_IMPORTED_MODULE_1__.a;
            }
            getUsername() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return "local";
                }));
            }
            _getSortingOptions() {
                return [];
            }
            getPart() {
                return __awaiter(this, void 0, void 0, (function*() {
                    con.log("[UserList][Local]", "status: " + this.status), this.done = !0;
                    return yield this.prepareData(yield this.getSyncList(), this.listType, this.status);
                }));
            }
            prepareData(data, listType, status) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, (function*() {
                    const newData = [];
                    for (const key in data) if (this.getRegex(listType).test(key)) {
                        const el = data[key];
                        if (con.log(key, el), 7 !== status && parseInt(el.status) !== status) continue;
                        "anime" === listType ? newData.push(yield this.fn({
                            airingState: 2,
                            image: null !== (_a = el.image) && void 0 !== _a ? _a : api.storage.assetUrl("questionmark.gif"),
                            malId: 0,
                            apiCacheKey: 0,
                            tags: el.tags,
                            title: "[L] " + el.name,
                            totalEp: 0,
                            status: el.status,
                            score: el.score,
                            type: "anime",
                            uid: key,
                            url: key,
                            cacheKey: this.getCacheKey(utils.urlPart(key, 4), utils.urlPart(key, 2)),
                            watchedEp: el.progress
                        }, el.sUrl)) : newData.push(yield this.fn({
                            airingState: 2,
                            image: null !== (_b = el.image) && void 0 !== _b ? _b : api.storage.assetUrl("questionmark.gif"),
                            malId: 0,
                            apiCacheKey: 0,
                            tags: el.tags,
                            title: "[L] " + el.name,
                            totalEp: 0,
                            status: el.status,
                            score: el.score,
                            type: "manga",
                            uid: key,
                            url: key,
                            cacheKey: this.getCacheKey(utils.urlPart(key, 4), utils.urlPart(key, 2)),
                            watchedEp: el.progress
                        }, el.sUrl));
                    }
                    return con.log("data", newData), newData;
                }));
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, j) {
        function initFloatButton(page, floatClick) {
            const posLeft = api.settings.get("posLeft"), miniMalWidth = api.settings.get("miniMalWidth"), miniMalHeight = api.settings.get("miniMalHeight");
            if (!j.$("#info-popup").length) {
                api.storage.addStyle(`.modal-content-kal.fullscreen{width: 100% !important;height: 100% !important; bottom: 0 !important;${posLeft}: 0 !important;}      .modal-content-kal{-webkit-transition: all 0.5s ease; -moz-transition: all 0.5s ease; -o-transition: all 0.5s ease; transition: all 0.5s ease;}      .floatbutton:hover {background-color:rgb(63,81,181) !important;}      .floatbutton:hover div {background-color:white;}      .floatbutton div {background-color:black;-webkit-transition: all 0.5s ease;-moz-transition: all 0.5s ease;-o-transition: all 0.5s ease;transition: all 0.5s ease;}      .floatbutton {       z-index: 9999;display: none; position:fixed; bottom:40px; right:40px; border-radius: 50%; font-size: 24px; height: 56px; margin: auto; min-width: 56px; width: 56px; padding: 0; overflow: hidden; background: rgba(158,158,158,.2); box-shadow: 0 1px 1.5px 0 rgba(0,0,0,.12), 0 1px 1px 0 rgba(0,0,0,.24); line-height: normal; border: none;       font-weight: 500; text-transform: uppercase; letter-spacing: 0; will-change: box-shadow; transition: box-shadow .2s cubic-bezier(.4,0,1,1),background-color .2s cubic-bezier(.4,0,.2,1),color .2s cubic-bezier(.4,0,.2,1); outline: none; cursor: pointer; text-decoration: none; text-align: center; vertical-align: middle; padding: 16px;      }      .floatbutton.stealth {        background: rgba(158,158,158,.03);      }      .floatbutton.stealth .open-info-popup{        visibility: hidden;      }      .floatbutton.floatHide{        visibility: hidden !important;      }`);
                let position = `max-width: 100%; max-height: 100%; min-width: 500px; min-height: 300px; width: ${miniMalWidth}; height: ${miniMalHeight}; position: absolute; bottom: 0%; ${posLeft}: 0%`;
                j.$(window).width() < 500 && (position = `width: 100vw; height: 100%; position: absolute; top: 0%; ${posLeft}: 0%`);
                let material = '<div class="modal-kal" id="info-popup" style="pointer-events: none;display: none; position: fixed;z-index: 9999;left: 0;top: 0;bottom: 0;width: 100%; height: 100%; background-color: transparent; padding: 0; margin: 0; border: 0;">';
                material += `<div id="modal-content" class="modal-content-kal" Style="pointer-events: all; background-color: #f9f9f9; margin: 0; ${position}">`, 
                material += "</div>", material += "</div>", j.$("body").after(j.html(material));
                let additionalClasses = "";
                api.settings.get("floatButtonStealth") && (additionalClasses += "stealth "), api.settings.get("floatButtonHide") && (additionalClasses += "floatHide ");
                let floatbutton = `<button class="open-info-popup floatbutton ${additionalClasses}" style="">`;
                floatbutton += '<i class="my-float open-info-popup" style="margin-top:22px;"><div class="open-info-popup" style="width: 100%; height: 4px; margin-bottom: 15%;"></div><div class="open-info-popup" style="width: 100%; height: 4px; margin-bottom: 15%;"></div><div class="open-info-popup" style="width: 100%; height: 4px"></div></i></button>', 
                j.$("#info-popup").after(j.html(floatbutton)), j.$(".open-info-popup").show(), api.settings.get("autoCloseMinimal") && j.$(".modal-kal").css("pointer-events", "initial"), 
                document.addEventListener("click", (function(e) {
                    e && e.target && (j.$(e.target).hasClass("open-info-popup") && floatClick(page), 
                    j.$(e.target).hasClass("modal-kal") && (document.getElementById("info-popup").style.display = "none", 
                    j.$(".floatbutton").fadeIn()));
                }));
            }
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return initFloatButton;
        }));
    }).call(this, __webpack_require__(0), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return providerTemplates;
        }));
        var _MyAnimeList_templates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105), _AniList_templates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106), _Kitsu_templates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107), _Simkl_templates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81), _Local_templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(108);
        function providerTemplates(malUrl) {
            if (/^local:\/\//i.test(malUrl)) return _Local_templates__WEBPACK_IMPORTED_MODULE_4__.a;
            const syncMode = api.settings.get("syncMode");
            return "MAL" === syncMode || "MALAPI" === syncMode ? _MyAnimeList_templates__WEBPACK_IMPORTED_MODULE_0__.a : "ANILIST" === syncMode ? _AniList_templates__WEBPACK_IMPORTED_MODULE_1__.a : "KITSU" === syncMode ? _Kitsu_templates__WEBPACK_IMPORTED_MODULE_2__.a : _Simkl_templates__WEBPACK_IMPORTED_MODULE_3__.a;
        }
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return mal;
    }));
    const mal = {
        shortName: "MAL",
        score: "MAL Score:",
        noLogin: "Please log in on <a target='_blank' href='https://myanimelist.net/login.php'>MyAnimeList!<a>"
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return anilist;
        }));
        const anilist = {
            shortName: "AniList",
            score: "AniList Score:",
            noLogin: api.storage.lang("Anilist_Authenticate")
        };
    }).call(this, __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return kitsu;
    }));
    const kitsu = {
        shortName: "Kitsu",
        score: "Kitsu Score:",
        noLogin: 'Please Authenticate <a target="_blank" href="https://kitsu.io/404?mal-sync=authentication">Here</a>'
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return local;
    }));
    const local = {
        shortName: "local storage",
        score: "Local storage Score:",
        noLogin: ""
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SearchClass;
        }));
        var string_similarity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91), _searchFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36), _Local_single__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80), _singleFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18), _rulesClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(113), _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class SearchClass {
            constructor(title, type, identifier) {
                this.title = title, this.type = type, this.identifier = identifier, this.localUrl = "", 
                this.state = !1, this.changed = !1, this.identifier += "", this.sanitizedTitel = this.sanitizeTitel(this.title), 
                this.logger = con.m("search", "red");
            }
            setPage(page) {
                this.page = page;
            }
            setLocalUrl(url) {
                this.localUrl = url;
            }
            setSyncPage(syncPage) {
                this.syncPage = syncPage;
            }
            getSyncPage() {
                return this.syncPage;
            }
            getUrl() {
                return this.state ? this.state.url : null;
            }
            setUrl(url, id = 0) {
                this.state ? (this.state.url !== url && (this.changed = !0), this.state.provider = "user", 
                this.state.url = url, this.state.id = id, this.state.cache = !1, this.state.similarity = {
                    same: !0,
                    value: 1
                }) : (this.changed = !0, this.state = {
                    id: id,
                    url: url,
                    offset: 0,
                    provider: "user",
                    similarity: {
                        same: !0,
                        value: 1
                    }
                }), this.setCache(this.state);
            }
            getOffset() {
                return this.state ? this.state.offset : 0;
            }
            setOffset(offset) {
                this.state && (this.state.offset !== offset && (this.changed = !0), this.state.offset = offset), 
                this.setCache(this.state);
            }
            getCachedOffset() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.state = yield this.getCache(), this.state ? this.state.offset : 0;
                }));
            }
            getId() {
                return this.state && this.state.id ? this.state.id : 0;
            }
            getSanitizedTitel() {
                return this.sanitizedTitel;
            }
            getNormalizedType() {
                return "anime" === this.type ? "anime" : "manga";
            }
            sanitizeTitel(title) {
                let resTitle = title.replace(/ *(\(dub\)|\(sub\)|\(uncensored\)|\(uncut\)|\(subbed\)|\(dubbed\))/i, "");
                return resTitle = resTitle.replace(/ *\([^)]+audio\)/i, ""), resTitle = resTitle.replace(/ BD( |$)/i, ""), 
                resTitle = resTitle.trim(), resTitle = resTitle.substring(0, 99), resTitle;
            }
            search() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.state = yield this.getCache(), this.state || (this.state = yield this.searchLocal()), 
                    this.state || (this.state = yield this.searchForIt()), !this.state || this.state && ![ "user", "firebase", "sync", "local" ].includes(this.state.provider)) {
                        const tempRes = yield this.onsiteSearch();
                        tempRes && (this.state = tempRes);
                    }
                    return this.state && (yield this.setCache(this.state)), this.logger.log("Result", this.state), 
                    this.state;
                }));
            }
            getCache() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.storage.get(`${this.page.name}/${this.identifier}/Search`).then(state => (state && (state.cache = !0), 
                    state));
                }));
            }
            setCache(cache) {
                return cache = JSON.parse(JSON.stringify(cache)), setTimeout(() => {
                    this.databaseRequest();
                }, 200), api.storage.set(`${this.page.name}/${this.identifier}/Search`, cache);
            }
            static similarity(externalTitle, title, titleArray = []) {
                let simi = Object(string_similarity__WEBPACK_IMPORTED_MODULE_0__.compareTwoStrings)(title.toLowerCase(), externalTitle.toLowerCase());
                titleArray.forEach(el => {
                    if (el) {
                        const tempSimi = Object(string_similarity__WEBPACK_IMPORTED_MODULE_0__.compareTwoStrings)(title.toLowerCase(), el.toLowerCase());
                        tempSimi > simi && (simi = tempSimi);
                    }
                });
                let found = !1;
                return simi > .6 && (found = !0), {
                    same: found,
                    value: simi
                };
            }
            searchLocal() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (!this.localUrl) return !1;
                    const local = new _Local_single__WEBPACK_IMPORTED_MODULE_2__.a(this.localUrl);
                    return yield local.update(), !!local.isOnList() && (this.logger.m("Local").log("On List"), 
                    {
                        url: "",
                        offset: 0,
                        provider: "local",
                        similarity: {
                            same: !0,
                            value: 1
                        }
                    });
                }));
            }
            searchForIt() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let result = !1;
                    try {
                        result = searchCompare(result, yield this.malSync());
                    } catch (e) {
                        this.page && this.page.database && this.logger.error("MALSync api error or not supported", e);
                    }
                    if (result && "firebase" !== result.provider || !result) try {
                        result = searchCompare(result, yield this.malSearch());
                    } catch (e) {
                        this.logger.m(e);
                    }
                    if (result && "firebase" !== result.provider || !result) try {
                        result = searchCompare(result, yield this.pageSearch(), .5);
                    } catch (e) {
                        this.logger.m(e);
                    }
                    if (result && "firebase" === result.provider && "MAL" !== api.settings.get("syncMode") && !result.url) try {
                        const temp = yield this.pageSearch();
                        temp && -1 === temp.url.indexOf("myanimelist.net") && temp.similarity.same && (this.logger.log("Ignore Firebase", result), 
                        result = temp);
                    } catch (e) {
                        this.logger.m(e);
                    }
                    return result;
                    function searchCompare(curVal, newVal, threshold = 0) {
                        return !1 !== curVal && !1 !== newVal && newVal.similarity.value > threshold ? curVal.similarity.value >= newVal.similarity.value ? curVal : newVal : !1 !== curVal ? curVal : newVal;
                    }
                }));
            }
            firebase() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (!this.page || !this.page.database) return !1;
                    const logger = this.logger.m("Firebase"), url = `https://kissanimelist.firebaseio.com/Data2/${this.page.database}/${encodeURIComponent(this.identifierToDbKey(this.identifier)).toLowerCase()}/Mal.json`;
                    logger.log(url);
                    const response = yield api.request.xhr("GET", url);
                    if (logger.log("response", response.responseText), !response.responseText || "null" === response.responseText || response.responseText.includes("error")) return !1;
                    let matches;
                    try {
                        matches = JSON.parse(response.responseText);
                    } catch (e) {
                        return logger.info("Parse failed"), !1;
                    }
                    if (!matches || 0 === Object.keys(matches).length) return !1;
                    const id = Object.keys(matches)[0], name = matches[id];
                    let returnUrl = "";
                    return "Not-Found" !== id && (returnUrl = `https://myanimelist.net/${this.page.type}/${id}/${name}`), 
                    {
                        url: returnUrl,
                        offset: 0,
                        provider: "firebase",
                        similarity: {
                            same: !0,
                            value: 1
                        }
                    };
                }));
            }
            malSync() {
                var _a;
                return __awaiter(this, void 0, void 0, (function*() {
                    const logger = this.logger.m("API");
                    if (!this.page) return !1;
                    const dbPl = this.page.database ? this.page.database : this.page.name;
                    if (!dbPl) return !1;
                    const url = `https://api.malsync.moe/page/${dbPl}/${encodeURIComponent(this.identifierToDbKey(this.identifier)).toLowerCase()}`;
                    logger.log(url);
                    const response = yield api.request.xhr("GET", url);
                    if (logger.log("Response", response), 400 !== response.status && 200 !== response.status) throw new Error("malsync offline");
                    if (400 === response.status && (null === (_a = response.responseText) || void 0 === _a ? void 0 : _a.includes("error"))) return !1;
                    const res = JSON.parse(response.responseText);
                    let pageUrl = res.malUrl;
                    return !pageUrl && res.aniUrl && "ANILIST" === Object(_helper__WEBPACK_IMPORTED_MODULE_5__.a)(this.getNormalizedType()) && (pageUrl = res.aniUrl), 
                    {
                        url: pageUrl,
                        offset: 0,
                        provider: "firebase",
                        similarity: {
                            same: !0,
                            value: 1
                        }
                    };
                }));
            }
            malSearch() {
                var _a, _b;
                return __awaiter(this, void 0, void 0, (function*() {
                    const logger = this.logger.m("MAL");
                    let url = `https://myanimelist.net/${this.getNormalizedType()}.php?q=${encodeURI(this.sanitizedTitel)}`;
                    "novel" === this.type && (url = `https://myanimelist.net/${this.getNormalizedType()}.php?type=2&q=${encodeURI(this.sanitizedTitel)}`), 
                    logger.log(url);
                    const response = yield api.request.xhr("GET", url);
                    return !(!response || (null === (_a = response.responseText) || void 0 === _a ? void 0 : _a.includes("  error "))) && (!(!response || (null === (_b = response.responseText) || void 0 === _b ? void 0 : _b.includes("No titles that matched"))) && function handleResult(response, i = 1, This) {
                        const link = function(response, i) {
                            try {
                                return response.responseText.split('<a class="hoverinfo_trigger" href="')[i].split('"')[0];
                            } catch (e) {
                                logger.error(e);
                                try {
                                    return response.responseText.split('class="picSurround')[i].split("<a")[1].split('href="')[1].split('"')[0];
                                } catch (e2) {
                                    return logger.error(e2), !1;
                                }
                            }
                        }(response, i);
                        let id = 0, sim = {
                            same: !1,
                            value: 0
                        };
                        if (!1 !== link) try {
                            if ("manga" === This.type) {
                                if (-1 !== response.responseText.split(`href="${link}" id="si`)[1].split("</tr>")[0].indexOf("Novel")) return logger.log("Novel Found check next entry"), 
                                handleResult(response, i + 1, This);
                            }
                            const malTitel = function(response, link) {
                                try {
                                    const id = link.split("/")[4];
                                    return response.responseText.split(`rel="#sinfo${id}"><strong>`)[1].split("<")[0];
                                } catch (e) {
                                    return logger.error(e), "";
                                }
                            }(response, link);
                            sim = SearchClass.similarity(malTitel, This.sanitizedTitel), id = parseInt(link.split("/")[4]);
                        } catch (e) {
                            logger.error(e);
                        }
                        return {
                            id: id,
                            url: link,
                            offset: 0,
                            provider: "mal",
                            similarity: sim
                        };
                    }(response, 1, this));
                }));
            }
            pageSearch() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const searchResult = yield Object(_searchFactory__WEBPACK_IMPORTED_MODULE_1__.a)(this.sanitizedTitel, this.getNormalizedType());
                    let best = null;
                    for (let i = 0; i < searchResult.length && i < 5; i++) {
                        const el = searchResult[i], sim = SearchClass.similarity(el.name, this.sanitizedTitel, el.altNames), tempBest = {
                            index: i,
                            similarity: sim
                        };
                        ("manga" === this.type && !el.isNovel || "novel" === this.type && el.isNovel || "anime" === this.type) && (!best || sim.value > best.similarity.value) && (best = tempBest);
                    }
                    if (best) {
                        const retEl = searchResult[best.index], url = yield retEl.malUrl();
                        return {
                            id: retEl.id,
                            url: url || retEl.url,
                            offset: 0,
                            provider: "page",
                            similarity: best.similarity
                        };
                    }
                    return !1;
                }));
            }
            databaseRequest() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const logger = this.logger.m("DB Request");
                    if (this.page && this.page.database && this.syncPage && this.state) {
                        if (this.state.cache) return;
                        if ("user" === this.state.provider && !this.changed) return;
                        if ("firebase" === this.state.provider) return;
                        if ("local" === this.state.provider) return;
                        let kissurl;
                        if (!kissurl) if (this.page.isSyncPage(this.syncPage.url)) kissurl = this.page.sync.getOverviewUrl(this.syncPage.url), 
                        "Crunchyroll" === this.page.database && (kissurl = "" + this.syncPage.url); else {
                            if ("Crunchyroll" === this.page.database) return void logger.log("CR block");
                            kissurl = this.syncPage.url;
                        }
                        const param = {
                            pageUrl: kissurl,
                            malUrl: this.state.url,
                            correction: !1,
                            page: this.page.database
                        };
                        if ("user" === this.state.provider) {
                            if (!(yield utils.flashConfirm(api.storage.lang("correction_DBRequest"), "dbrequest", () => {}, () => {}, !0))) return;
                            param.correction = !0;
                        }
                        const url = "https://api.malsync.moe/corrections";
                        api.request.xhr("POST", {
                            url: url,
                            data: JSON.stringify(param),
                            headers: {
                                "Content-Type": "application/json"
                            }
                        }).then(response => {
                            try {
                                const res = JSON.parse(response.responseText);
                                if (res.error) throw res;
                                logger.log("Send to database:", res);
                            } catch (e) {
                                logger.error("Send to database:", e);
                            }
                        });
                    }
                }));
            }
            onsiteSearch() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.page && this.syncPage && this.syncPage.curState && this.syncPage.curState.on) {
                        let result = !1;
                        if ("OVERVIEW" === this.syncPage.curState.on ? this.page.overview && this.page.overview.getMalUrl && (result = yield this.page.overview.getMalUrl(api.settings.get("syncMode"))) : this.page.sync && this.page.sync.getMalUrl && (result = yield this.page.sync.getMalUrl(api.settings.get("syncMode"))), 
                        result) return this.logger.m("Onsite").log("[SEARCH]", "Overwrite by onsite url", result), 
                        {
                            url: result,
                            offset: 0,
                            provider: "sync",
                            similarity: {
                                same: !0,
                                value: 1
                            }
                        };
                    }
                    return !1;
                }));
            }
            openCorrection() {}
            identifierToDbKey(title) {
                return "Crunchyroll" === this.page.database ? encodeURIComponent(title.toLowerCase().split("#")[0]).replace(/\./g, "%2E") : title.toLowerCase().split("#")[0].replace(/\./g, "%2E");
            }
            initRules() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const logger = con.m("Rules"), url = this.getUrl();
                    if (logger.log("Url", url), url) {
                        const cacheKeyObj = yield Object(_singleFactory__WEBPACK_IMPORTED_MODULE_3__.a)(url);
                        return logger.log("Cachekey", cacheKeyObj), this.rules = yield new _rulesClass__WEBPACK_IMPORTED_MODULE_4__.a(cacheKeyObj.cacheKey, this.getNormalizedType()).init(), 
                        cacheKeyObj.singleObj;
                    }
                }));
            }
            applyRules(episode) {
                if (this.rules) {
                    const userOffset = this.getOffset() || 0, res = this.rules.applyRules(Number(episode) + Number(userOffset));
                    return res && (res.offset = Number(res.offset) + Number(userOffset)), res;
                }
            }
            getRuledOffset(episode) {
                const res = this.applyRules(episode);
                return res ? res.offset : this.getOffset();
            }
            getRuledUrl(episode) {
                const res = this.applyRules(episode);
                return res ? res.url : this.getUrl();
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return search;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function search(keyword, type, options = {}, sync = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                const query = `\n    query ($search: String) {\n      ${type}: Page (perPage: 10) {\n        pageInfo {\n          total\n        }\n        results: media (type: ${type.toUpperCase()}, search: $search) {\n          id\n          siteUrl\n          idMal\n          title {\n            userPreferred\n            romaji\n            english\n            native\n          }\n          coverImage {\n            medium\n          }\n          type\n          format\n          averageScore\n          startDate {\n            year\n          }\n          synonyms\n        }\n      }\n    }\n  `, variables = {
                    search: keyword
                }, response = yield api.request.xhr("POST", {
                    url: "https://graphql.anilist.co",
                    headers: {
                        "Content-Type": "application/json",
                        Accept: "application/json"
                    },
                    data: JSON.stringify({
                        query: query,
                        variables: variables
                    })
                }), res = JSON.parse(response.responseText);
                con.log(res);
                const resItems = [];
                return j.$.each(res.data[type].results, (function(index, item) {
                    resItems.push({
                        id: item.id,
                        name: item.title.userPreferred,
                        altNames: Object.values(item.title).concat(item.synonyms),
                        url: item.siteUrl,
                        malUrl: () => item.idMal ? `https://myanimelist.net/${type}/${item.idMal}` : null,
                        image: item.coverImage.medium,
                        media_type: item.format ? (item.format.charAt(0) + item.format.slice(1).toLowerCase()).replace("_", " ") : "",
                        isNovel: "NOVEL" === item.format,
                        score: item.averageScore,
                        year: item.startDate.year
                    });
                })), resItems;
            }));
        }
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return search;
        }));
        var _definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const search = function(keyword, type, options = {}, sync = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                return function(mode, url, variables = {}, authentication = !0) {
                    const headers = {
                        "Content-Type": "application/vnd.api+json",
                        Accept: "application/vnd.api+json"
                    };
                    authentication && (headers.Authorization = "Bearer " + api.settings.get("kitsuToken"));
                    return api.request.xhr(mode, {
                        url: url,
                        headers: headers,
                        data: JSON.stringify(variables)
                    }).then(response => {
                        if (response.status > 499 && response.status < 600 || 0 === response.status) throw {
                            code: _definitions__WEBPACK_IMPORTED_MODULE_0__.a.ServerOffline,
                            message: "Server Offline status: " + response.status
                        };
                        const res = JSON.parse(response.responseText);
                        if (void 0 !== res.errors && res.errors.length) {
                            con.error("[META]", "Error", res.errors);
                            const error = res.errors[0];
                            switch (parseInt(error.status)) {
                              case 401:
                              case 403:
                                throw {
                                    code: _definitions__WEBPACK_IMPORTED_MODULE_0__.a.NotAutenticated,
                                    message: error.detail
                                };

                              case 404:
                                throw {
                                    code: _definitions__WEBPACK_IMPORTED_MODULE_0__.a.EntryNotFound,
                                    message: error.detail
                                };

                              default:
                                throw {
                                    code: error.status,
                                    message: error.detail
                                };
                            }
                        }
                        return res;
                    });
                }("GET", `https://kitsu.io/api/edge/${type}?filter[text]=${keyword}&page[limit]=10&page[offset]=0&fields[${type}]=id,slug,titles,averageRating,startDate,posterImage,subtype`, {}).then(res => {
                    con.log("search", res);
                    const resItems = [];
                    return res.data.forEach((function(item) {
                        resItems.push({
                            id: item.id,
                            name: _helper__WEBPACK_IMPORTED_MODULE_1__.c(item.attributes.titles, item.attributes.canonicalTitle),
                            altNames: Object.values(item.attributes.titles),
                            url: `https://kitsu.io/${type}/${item.attributes.slug}`,
                            malUrl: () => __awaiter(this, void 0, void 0, (function*() {
                                const malId = yield _helper__WEBPACK_IMPORTED_MODULE_1__.d(item.id, type);
                                return malId ? `https://myanimelist.net/${type}/${malId}` : null;
                            })),
                            image: item.attributes.posterImage && void 0 !== item.attributes.posterImage.tiny ? item.attributes.posterImage.tiny : "",
                            media_type: item.attributes.subtype,
                            isNovel: "novel" === item.attributes.subtype,
                            score: item.attributes.averageRating,
                            year: item.attributes.startDate
                        });
                    })), resItems;
                });
            }));
        };
    }).call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, j, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return search;
        }));
        var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function search(keyword, type, options = {}, sync = !1) {
            return call("https://api.simkl.com/search/" + type, {
                q: keyword
            }, !0).then(res => {
                const resItems = [];
                return con.log("search", res), j.$.each(res, (function(index, item) {
                    resItems.push({
                        id: item.ids.simkl_id,
                        name: item.title,
                        altNames: [],
                        url: `https://simkl.com/${type}/${item.ids.simkl_id}/${item.ids.slug}`,
                        malUrl: () => __awaiter(this, void 0, void 0, (function*() {
                            const malId = yield (simklId = item.ids.simkl_id, call("https://api.simkl.com/anime/" + simklId, {
                                extended: "full"
                            }, !0).then(res => void 0 === res.ids.mal ? null : res.ids.mal));
                            var simklId;
                            return malId ? `https://myanimelist.net/${type}/${malId}` : null;
                        })),
                        image: `https://simkl.in/posters/${item.poster}_cm.jpg`,
                        media_type: item.type,
                        isNovel: !1,
                        score: null,
                        year: item.year
                    });
                })), resItems;
            });
        }
        function call(url, sData = {}, asParameter = !1, methode = "GET", login = !0) {
            return __awaiter(this, void 0, void 0, (function*() {
                asParameter && (url += "?" + j.$.param(sData)), con.log("call", methode, url, sData);
                const headers = {
                    Authorization: login ? "Bearer " + api.settings.get("simklToken") : void 0,
                    "simkl-api-key": _helper__WEBPACK_IMPORTED_MODULE_0__.b,
                    Accept: "application/vnd.api+json",
                    "Content-Type": "application/json"
                };
                return login || con.log("No login"), api.request.xhr(methode, {
                    url: url,
                    headers: headers,
                    data: sData
                }).then(response => __awaiter(this, void 0, void 0, (function*() {
                    switch (response.status) {
                      case 200:
                      case 201:
                      case 204:
                      case 302:
                        break;

                      case 401:
                        if (login) return call(url, sData, asParameter, methode, !1);
                        throw utils.flashm('Please Authenticate <a target="_blank" href="https://simkl.com/oauth/authorize?response_type=code&client_id=39e8640b6f1a60aaf60f3f3313475e830517badab8048a4e52ff2d10deb2b9b0&redirect_uri=https://simkl.com/apps/chrome/mal-sync/connected/">Here</a>', {
                            error: !0,
                            type: "error"
                        }), getThrowError();

                      default:
                        throw utils.flashm("Simkl: " + getErrorText(), {
                            error: !0,
                            type: "error"
                        }), getThrowError();
                    }
                    try {
                        return JSON.parse(response.responseText);
                    } catch (e) {
                        throw con.error(response), e;
                    }
                    function getErrorText() {
                        return JSON.parse(response.responseText).error;
                    }
                    function getThrowError() {
                        return {
                            status: response.status,
                            message: getErrorText()
                        };
                    }
                })));
            }));
        }
    }).call(this, __webpack_require__(4), __webpack_require__(2), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return RulesClass;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class RulesClass {
            constructor(cacheKey, type) {
                return this.cacheKey = cacheKey, this.type = type, this.logger = con.m("Rules"), 
                this;
            }
            init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (this.state = yield this.getCache(), !this.state || "firebase" === this.state.provider && this.state.updated && this.state.updated + 6048e5 < (new Date).getTime()) {
                        const tempState = yield this.api();
                        tempState && (this.state = tempState);
                    }
                    return this.logger.m("Result").log(this.state), this.state && (yield this.setCache(this.state)), 
                    this;
                }));
            }
            getRules() {
                return this.state && this.state.rules && this.state.rules.length ? this.state.rules : [];
            }
            api() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const logger = this.logger.m("API");
                    try {
                        if ("anime" !== this.type) return void logger.info("Only supports anime");
                        if (String(this.cacheKey).startsWith("simkl:")) return void logger.info("Simkl is not supported");
                        const url = "https://api.malsync.moe/rules/" + this.cacheKey;
                        logger.log(url);
                        const response = yield api.request.xhr("GET", url);
                        logger.log("Response", response);
                        const res = JSON.parse(response.responseText);
                        return {
                            provider: "firebase",
                            updated: (new Date).getTime(),
                            last_modified: res.last_modified,
                            rules: res.rules.map(rule => ({
                                from: {
                                    title: rule.from.title,
                                    url: utils.pageUrl(res.page, this.type, rule.from.id),
                                    start: rule.from.start,
                                    end: rule.from.end
                                },
                                to: {
                                    title: rule.to.title,
                                    url: utils.pageUrl(res.page, this.type, rule.to.id),
                                    start: rule.to.start,
                                    end: rule.to.end
                                }
                            }))
                        };
                    } catch (e) {
                        return void logger.error(e);
                    }
                }));
            }
            getCache() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.storage.get(`${this.type}/${this.cacheKey}/Rules`).then(state => (state && (state.cache = !0), 
                    state));
                }));
            }
            setCache(cache) {
                return cache = JSON.parse(JSON.stringify(cache)), api.storage.set(`${this.type}/${this.cacheKey}/Rules`, cache);
            }
            applyRules(currentEpisode, rules) {
                const logger = this.logger.m("apply");
                this.activeRule = void 0, rules || (rules = this.getRules()), logger.log(currentEpisode, rules);
                const rule = rules.find(el => el.from.start <= currentEpisode && el.from.end >= currentEpisode);
                if (rule) return logger.log("Rule found", rule), this.activeRule = rule, {
                    url: rule.to.url,
                    offset: rule.to.start - rule.from.start
                };
                if (rules.length > 1) {
                    const selfRule = rules.find(el => el.from.url === el.to.url && currentEpisode > el.from.end);
                    if (selfRule) {
                        const offset = selfRule.to.start - selfRule.from.start, newEp = currentEpisode + offset;
                        logger.log("Self Rule", selfRule, newEp, offset);
                        const res = this.applyRules(newEp, rules.filter(el => el.from.url !== el.to.url));
                        if (res) return res.offset += offset, res;
                    }
                }
            }
        }
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnilistClass;
        }));
        var _provider_AniList_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92), _provider_AniList_single__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33), _provider_AniList_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31), _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class AnilistClass {
            constructor(url) {
                this.url = url, this.page = null, this.tempAnimelist = null, this.tempMangalist = null;
                let first = !0;
                utils.changeDetect(() => {
                    this.url = window.location.href, this.init();
                }, () => {
                    if (first) return void (first = !1);
                    if (null !== this.page && "bookmarks" === this.page.page && $(".lists").length) return $(".lists").first().height();
                    let ogUrl = $('meta[property="og:url"]').attr("content");
                    return void 0 !== ogUrl && ogUrl.split("/").length > 4 ? ogUrl.split("/").slice(0, 6).join("/") : (ogUrl = window.location.href, 
                    ogUrl);
                }), this.url.indexOf("access_token=") > -1 && this.init(), api.storage.addStyle(__webpack_require__(294).toString());
            }
            init() {
                this.url.indexOf("access_token=") > -1 && this.authentication();
                const urlpart = utils.urlPart(this.url, 3);
                "anime" !== urlpart && "manga" !== urlpart || (this.page = {
                    page: "detail",
                    id: utils.urlPart(this.url, 4),
                    apiCacheKey: NaN,
                    type: urlpart
                }, this.streamingUI(), _provider_AniList_helper__WEBPACK_IMPORTED_MODULE_0__.a(this.page.id, this.page.type).then(malid => {
                    this.page.apiCacheKey = malid || "anilist:" + this.page.id, con.log("page", this.page), 
                    this.malToKiss();
                }));
                const urlpart4 = utils.urlPart(this.url, 5);
                "animelist" !== urlpart4 && "mangalist" !== urlpart4 || (this.page = {
                    page: "bookmarks",
                    type: urlpart4.substring(0, 5)
                }, this.bookmarks());
            }
            authentication() {
                return __awaiter(this, void 0, void 0, (function*() {
                    try {
                        utils.checkDoubleExecution();
                    } catch (e) {
                        con.error(e);
                    }
                    const tokens = /access_token=[^&]+/gi.exec(this.url);
                    if (null !== tokens && void 0 !== tokens[0] && tokens[0]) {
                        const token = tokens[0].toString().replace(/access_token=/gi, "");
                        con.log("Token Found", token), yield api.settings.set("anilistToken", token), $(document).ready((function() {
                            $(".page-content .container").html(j.html(`\n          <div style="text-align: center; margin-top: 50px; background-color: white; border: 1px solid lightgrey; padding: 10px;">\n            <h1>MAL-Sync</h1>\n            <br>\n            ${api.storage.lang("anilistClass_authentication")}\n          </div>\n        `));
                        }));
                    }
                }));
            }
            getMalUrl() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const urlpart = utils.urlPart(this.url, 3);
                    if ("anime" === urlpart || "manga" === urlpart) {
                        const aniListId = utils.urlPart(this.url, 4);
                        return _provider_AniList_helper__WEBPACK_IMPORTED_MODULE_0__.a(Number(aniListId), urlpart).then(malId => malId ? `https://myanimelist.net/${urlpart}/${malId}/${utils.urlPart(this.url, 5)}` : "");
                    }
                    return "";
                }));
            }
            malToKiss() {
                $(document).ready(() => {
                    con.log("malToKiss"), $(".mal_links").remove();
                    const title = $("h1").first().clone().children().remove().end().text().trim();
                    Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_3__.a)(this.page.type, this.page.apiCacheKey, title).then(links => {
                        let html = "";
                        links.forEach(page => {
                            let tempHtml = "";
                            page.links.forEach(stream => {
                                tempHtml += `\n              <div class="mal_links" style="margin-top: 5px;">\n                <a target="_blank" href="${stream.url}">\n                  ${stream.name}\n                </a>\n              </div>`;
                            }), html += `\n            <div id="${page.name}Links" class="mal_links" style="\n              background: rgb(var(--color-foreground));\n              border-radius: 3px;\n              display: block;\n              padding: 8px 12px;\n              width: 100%;\n              margin-bottom: 16px;\n              font-size: 1.2rem;\n\n            ">\n              <img src="${utils.favicon(page.domain)}">\n              <span style="font-weight: 500; line-height: 16px; vertical-align: middle;">${page.name}</span>\n              <span title="${page.name}" class="remove-mal-sync" style="float: right; cursor: pointer;">x</span>\n              ${tempHtml}\n            </div>`;
                        }), $(".mal_links").remove(), $(".sidebar .data").before(j.html(html)), $(".remove-mal-sync").click((function() {
                            const key = $(this).attr("title");
                            Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_3__.c)(String(key)), window.location.reload();
                        }));
                    });
                });
            }
            streamingUI() {
                return __awaiter(this, void 0, void 0, (function*() {
                    con.log("Streaming UI"), $("#mal-sync-stream-div").remove(), $(".malsync-rel-link").remove();
                    const malObj = new _provider_AniList_single__WEBPACK_IMPORTED_MODULE_1__.a(this.url);
                    yield malObj.update(), this.pageRelation(malObj);
                    const streamUrl = malObj.getStreamingUrl();
                    streamUrl && $(document).ready((function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            $("#mal-sync-stream-div").remove(), $("h1").first().append(j.html(`\n        <div class="data title progress" id="mal-sync-stream-div" style="margin-top: -2px; display: inline-block; position: relative; top: 2px;">\n          <a class="mal-sync-stream" title="${streamUrl ? streamUrl.split("/")[2] : ""}" target="_blank" style="margin: 0 0;" href="${streamUrl}">\n            <img src="${utils.favicon(streamUrl ? streamUrl.split("/")[2] : "")}">\n          </a>\n        </div>`));
                            const resumeUrlObj = malObj.getResumeWatching(), continueUrlObj = malObj.getContinueWatching();
                            con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === malObj.getEpisode() + 1 ? $("#mal-sync-stream-div").append(j.html(`<a class="nextStream" title="${api.storage.lang("overview_Continue_" + malObj.getType())}" target="_blank" style="margin: 0 5px 0 0; color: #BABABA;" href="${continueUrlObj.url}">\n              <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n            </a>`)) : resumeUrlObj && resumeUrlObj.ep === malObj.getEpisode() && $("#mal-sync-stream-div").append(j.html(`<a class="resumeStream" title="${api.storage.lang("overview_Resume_Episode_" + malObj.getType())}" target="_blank" style="margin: 0 5px 0 0; color: #BABABA;" href="${resumeUrlObj.url}">\n              <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n            </a>`));
                        }));
                    }));
                }));
            }
            pageRelation(malObj) {
                return __awaiter(this, void 0, void 0, (function*() {
                    yield malObj.fillRelations(), $(".malsync-rel-link").remove(), $("h1").first().append(j.html('<div class="malsync-rel-link" style="float: right;"></div>')), 
                    malObj.getPageRelations().forEach(page => {
                        $(".malsync-rel-link").append(j.html(`\n          <a href="${page.link}" target="_blank" title="${page.name}" class="link">\n            <img src="${page.icon}" width="16" width="16">\n          </a>\n\n        `));
                    });
                }));
            }
            bookmarks() {
                const This = this;
                $(document).ready(() => {
                    if ($(".list-entries .entry, .list-entries .entry-card").not(".malSyncDone").each((index, el) => {
                        $(el).addClass("malSyncDone");
                        let label = $(el).find(".notes").first().attr("label");
                        void 0 !== label && (label = label.replace(/(malSync|last)::[\d\D]+::/, "").replace(/#,/, ""), 
                        "" === label.trim() || "," === label.trim() ? $(el).find(".notes").first().css("visibility", "hidden") : $(el).find(".notes").first().attr("label", label));
                    }), "anime" === this.page.type) {
                        if (null !== this.tempAnimelist) return void fullListCallback(this.tempAnimelist);
                    } else if (null !== this.tempMangalist) return void fullListCallback(this.tempMangalist);
                    const listProvider = new _provider_AniList_list__WEBPACK_IMPORTED_MODULE_2__.a(1, this.page.type);
                    function fullListCallback(list) {
                        con.log(list), $.each(list, (index, en) => __awaiter(this, void 0, void 0, (function*() {
                            const tempEl = $(`.entry:not(.malSyncDone2) a[href^="/${This.page.type}/${en.uid}/"], .entry-card:not(.malSyncDone2) a[href^="/${This.page.type}/${en.uid}/"]`);
                            if (tempEl.length) {
                                const element = tempEl.first().parent();
                                element.parent().addClass("malSyncDone2"), en.options && en.options.u && (con.log(en.options.u), 
                                element.find("a").first().after(j.html(`\n                <a class="mal-sync-stream mal-rem" title="${en.options.u.split("/")[2]}" target="_blank" style="margin: 0 0; max-height: 14px;" href="${en.options.u}">\n                  <img src="${utils.favicon(en.options.u.split("/")[2])}">\n                </a>`)));
                                const resumeUrlObj = en.options.r, continueUrlObj = en.options.c, curEp = en.watchedEp;
                                con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === curEp + 1 ? element.prepend(j.html(`<a class="nextStream mal-rem" title="Continue watching" target="_blank" style="margin: -2px 5px 0 0; color: #BABABA;" href="${continueUrlObj.url}">\n                  <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n                </a>`)) : resumeUrlObj && resumeUrlObj.ep === curEp && element.prepend(j.html(`<a class="resumeStream mal-rem" title="Resume watching" target="_blank" style="margin: -2px 5px 0 0; color: #BABABA;" href="${resumeUrlObj.url}">\n                  <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n                </a>`)), 
                                yield en.fn.initProgress(), en.fn.progress && en.fn.progress.isAiring() && en.fn.progress.getCurrentEpisode() && element.parent().find(".progress").first().append(j.html(` <span class="mal-sync-ep-pre" title="${en.fn.progress.getAutoText()}">[<span style="border-bottom: 1px dotted ${en.fn.progress.getColor()};">${en.fn.progress.getCurrentEpisode()}</span>]</span>`));
                            }
                        })));
                    }
                    listProvider.getCompleteList().then(list => {
                        "anime" === this.page.type ? this.tempAnimelist = list : this.tempMangalist = list, 
                        fullListCallback(list);
                    }).catch(e => {
                        con.error(e), listProvider.flashmError(e);
                    });
                });
            }
        }
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return KitsuClass;
        }));
        var _provider_Kitsu_single__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34), _provider_Kitsu_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32), _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class KitsuClass {
            constructor(url) {
                this.url = url, this.page = null, this.same = !1, this.tempAnimelist = null, this.tempMangalist = null;
                let oldUrl = window.location.href.split("/").slice(0, 5).join("/");
                utils.changeDetect(() => {
                    if (this.same = !1, null !== this.page && "detail" === this.page.page) {
                        const tempUrl = window.location.href.split("/").slice(0, 5).join("/");
                        tempUrl === oldUrl && (this.same = !0), oldUrl = tempUrl;
                    }
                    this.url = window.location.href, this.init();
                }, () => null !== this.page && "bookmarks" === this.page.page && $(".library-content").length ? $(".library-content").first().height() : window.location.href), 
                $(document).ready(() => {
                    utils.waitUntilTrue((function() {
                        return $(".global-container").length;
                    }), () => {
                        this.init();
                    });
                }), api.storage.addStyle(__webpack_require__(296).toString());
            }
            init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.url.indexOf("?mal-sync=authentication") > -1 && this.authentication();
                    const urlpart = utils.urlPart(this.url, 3);
                    if ("anime" === urlpart || "manga" === urlpart) {
                        if (this.same && void 0 !== this.page && "undefined" !== this.page.malObj) return this.streamingUI(), 
                        this.malToKiss(), void this.pageRelation();
                        const malObj = new _provider_Kitsu_single__WEBPACK_IMPORTED_MODULE_0__.a(this.url);
                        yield malObj.update(), this.page = {
                            page: "detail",
                            id: malObj.getIds().kitsu.id,
                            malid: malObj.getIds().mal,
                            apiCacheKey: malObj.getApiCacheKey(),
                            type: urlpart,
                            malObj: malObj
                        }, con.log("page", this.page), this.streamingUI(), this.malToKiss(), this.pageRelation();
                    }
                    if ("library" === utils.urlPart(this.url, 5)) {
                        let type = "anime";
                        "manga" === utils.urlParam(this.url, "media") && (type = "manga"), this.page = {
                            page: "bookmarks",
                            type: type
                        }, con.log("page", this.page), this.bookmarks();
                    }
                }));
            }
            authentication() {
                try {
                    utils.checkDoubleExecution();
                } catch (e) {
                    con.error(e);
                }
                $(document).ready((function() {
                    $("body").after(j.html(`\n        <div id="mal-sync-login" style="text-align: center; margin-top: 50px; background-color: white; border: 1px solid lightgrey; padding: 10px; max-width: 600px; margin-left: auto; margin-right: auto;">\n          <h1>MAL-Sync</h1>\n          <br>\n          <p style="text-align: left;">\n            ${api.storage.lang("kitsuClass_authentication_text")}\n          </p>\n          <div class="modal-content">\n            <input type="email" id="email" placeholder="Email" required>\n            <input type="password" id="pass" name="password" placeholder="${api.storage.lang("kitsuClass_authentication_Password")}" required>\n          </div>\n          <div class="form-cta" style="margin-top: 30px;">\n            <button class="btn button--primary" type="submit" id="mal-sync-button">\n              ${api.storage.lang("kitsuClass_authentication_Login")}\n            </button>\n          </div>\n        </div>\n      `)), 
                    $("#mal-sync-login #mal-sync-button").click((function() {
                        $("#mal-sync-login #mal-sync-button").attr("disabled", "disabled"), $.ajax({
                            type: "POST",
                            url: "https://kitsu.io/api/oauth/token",
                            data: `grant_type=password&username=${encodeURIComponent(String($("#mal-sync-login #email").val()))}&password=${encodeURIComponent(String($("#mal-sync-login #pass").val()))}`,
                            success(result) {
                                return __awaiter(this, void 0, void 0, (function*() {
                                    const token = result.access_token;
                                    token && (con.info("token", token), yield api.settings.set("kitsuToken", token), 
                                    $("#mal-sync-login").html(j.html("<h1>MAL-Sync</h1><br>" + api.storage.lang("kitsuClass_authentication_Success"))));
                                }));
                            },
                            error(result) {
                                try {
                                    if (con.error(result), $("#mal-sync-login #mal-sync-button").prop("disabled", !1), 
                                    "invalid_grant" === result.responseJSON.error) return void utils.flashm(api.storage.lang("kitsuClass_authentication_Wrong"));
                                    utils.flashm(result.responseJSON.error_description);
                                } catch (e) {
                                    con.error(e), utils.flashm(result.responseText);
                                }
                            }
                        });
                    })), utils.waitUntilTrue((function() {
                        return $("body h1").length;
                    }), () => {
                        $("body h1").remove();
                    });
                }));
            }
            getMalUrl() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return null !== this.page && "detail" === this.page.page && this.page.malid ? `https://myanimelist.net/${this.page.type}/${this.page.malid}/${utils.urlPart(this.url, 5)}` : "";
                }));
            }
            streamingUI() {
                return __awaiter(this, void 0, void 0, (function*() {
                    con.log("Streaming UI"), $("#mal-sync-stream-div").remove();
                    const {malObj: malObj} = this.page, streamUrl = malObj.getStreamingUrl();
                    streamUrl && $(document).ready((function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            $(".media--title h3").first().after(j.html(`\n        <div class="data title progress" id="mal-sync-stream-div" style="display: inline-block; position: relative; top: -4px; display: inline;">\n          <a class="mal-sync-stream" title="${streamUrl.split("/")[2]}" target="_blank" style="margin: 0 0;" href="${streamUrl}">\n            <img src="${utils.favicon(streamUrl.split("/")[2])}">\n          </a>\n        </div>`));
                            const resumeUrlObj = malObj.getResumeWatching(), continueUrlObj = malObj.getContinueWatching();
                            con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === malObj.getEpisode() + 1 ? $("#mal-sync-stream-div").append(j.html(`<a class="nextStream" title="${api.storage.lang("overview_Continue_" + malObj.getType())}" target="_blank" style="margin: 0 5px 0 0; color: #BABABA;" href="${continueUrlObj.url}">\n              <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n            </a>`)) : resumeUrlObj && resumeUrlObj.ep === malObj.getEpisode() && $("#mal-sync-stream-div").append(j.html(`<a class="resumeStream" title="${api.storage.lang("overview_Resume_Episode_" + malObj.getType())}" target="_blank" style="margin: 0 5px 0 0; color: #BABABA;" href="${resumeUrlObj.url}">\n              <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n            </a>`));
                        }));
                    }));
                }));
            }
            malToKiss() {
                $(document).ready(() => {
                    con.log("malToKiss"), $(".mal_links").remove();
                    const title = $('meta[property="og:title"]').attr("content");
                    Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__.a)(this.page.type, this.page.apiCacheKey, title).then(links => {
                        let html = "";
                        links.forEach(page => {
                            let tempHtml = "";
                            page.links.forEach(stream => {
                                tempHtml += `\n              <div class="mal_links" style="margin-top: 5px;">\n                <a target="_blank" href="${stream.url}">\n                  ${stream.name}\n                </a>\n              </div>`;
                            }), html += `\n            <div id="${page.name}Links" class="mal_links library-state with-header" style="\n              background: white;\n              margin-bottom: 15px;\n              border-radius: 3px;\n              display: block;\n              padding: 8px 12px;\n              width: 100%;\n              font-size: 12px;\n\n            ">\n              <img src="${utils.favicon(page.domain)}">\n              <span style="font-weight: 500; line-height: 16px; vertical-align: middle;">${page.name}</span>\n              <span title="${page.name}" class="remove-mal-sync" style="float: right; cursor: pointer;">x</span>\n              ${tempHtml}\n            </div>`;
                        }), $("#mal-sync-search-links").length ? $("#mal-sync-search-links").first().after(j.html(html)) : $(".media-summary").first().after(j.html(html)), 
                        $(".remove-mal-sync").click((function() {
                            const key = $(this).attr("title");
                            Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_2__.c)(String(key)), window.location.reload();
                        }));
                    });
                });
            }
            pageRelation() {
                return __awaiter(this, void 0, void 0, (function*() {
                    $(".malsync-rel-link").remove(), yield this.page.malObj.fillRelations(), $(".media-summary h5").first().append(j.html('<div class="malsync-rel-link" style="display: inline-block; margin: 0 5px; vertical-align: bottom;"></div>')), 
                    this.page.malObj.getPageRelations().forEach(page => {
                        $(".malsync-rel-link").append(j.html(`\n          <a href="${page.link}" target="_blank" title="${page.name}" class="link">\n            <img src="${page.icon}" width="16" height="16">\n          </a>\n\n        `));
                    });
                }));
            }
            bookmarks() {
                const This = this;
                $(document).ready(() => {
                    if ("anime" === this.page.type) {
                        if (null !== this.tempAnimelist) return void fullListCallback(this.tempAnimelist);
                    } else if (null !== this.tempMangalist) return void fullListCallback(this.tempMangalist);
                    const listProvider = new _provider_Kitsu_list__WEBPACK_IMPORTED_MODULE_1__.a(1, this.page.type);
                    function fullListCallback(list) {
                        let cover = !0;
                        $(".library-list tbody tr").length && (cover = !1), con.log(list), $.each(list, (index, en) => __awaiter(this, void 0, void 0, (function*() {
                            if (con.log("en", en), void 0 !== en.malId && null !== en.malId && en.malId) {
                                const element = $(`.library-grid-popover:not(.malSyncDone2) a[href^="/${This.page.type}/${en.kitsuSlug}"], .library-list tbody tr:not(.malSyncDone2) a[href^="/${This.page.type}/${en.kitsuSlug}"]`).first().parent().parent().parent();
                                con.log(element), element.addClass("malSyncDone2"), en.options && en.options.u && (con.log(en.options.u), 
                                cover ? element.prepend(j.html(`\n                  <a class="mal-sync-stream mal-rem" title="${en.options.u.split("/")[2]}" target="_blank" style="margin: 0 0; z-index: 22; position:absolute; left: 0px; top: 0px; background-color: #ffffff5c; padding: 0 5px 3px 5px;" href="${en.options.u}">\n                    <img src="${utils.favicon(en.options.u.split("/")[2])}">\n                  </a>`)) : element.find(".title-wrapper").append(j.html(`\n                  <a class="mal-sync-stream mal-rem" title="${en.options.u.split("/")[2]}" target="_blank" style="padding: 0 5px;" href="${en.options.u}">\n                    <img src="${utils.favicon(en.options.u.split("/")[2])}">\n                  </a>`)));
                                const resumeUrlObj = en.options.r, continueUrlObj = en.options.c, curEp = en.watchedEp;
                                con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === curEp + 1 ? cover ? element.prepend(j.html(`<a class="nextStream mal-rem" title="Continue watching" target="_blank" style="color: #BABABA; z-index: 22; position:absolute; top: 0px; left: 26px; background-color: #ffffff5c; padding: 0 5px 3px 5px;" href="${continueUrlObj.url}">\n                    <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n                  </a>`)) : element.find(".title-wrapper").append(j.html(`<a class="nextStream mal-rem" title="Continue watching" target="_blank" style="padding: 0;" href="${continueUrlObj.url}">\n                    <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n                  </a>`)) : resumeUrlObj && resumeUrlObj.ep === curEp && (cover ? element.prepend(j.html(`<a class="resumeStream mal-rem" title="Resume watching" target="_blank" style="color: #BABABA; z-index: 22; position:absolute; top: 0px; left: 26px; background-color: #ffffff5c; padding: 0 5px 3px 5px;" href="${resumeUrlObj.url}">\n                    <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n                  </a>`)) : element.find(".title-wrapper").append(j.html(`<a class="resumeStream mal-rem" title="Resume watching" target="_blank" style="padding: 0;" href="${resumeUrlObj.url}">\n                    <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n                  </a>`))), 
                                yield en.fn.initProgress(), en.fn.progress && en.fn.progress.isAiring() && en.fn.progress.getCurrentEpisode() && element.parent().find(".entry-unit, .progress-cell > span:last-of-type").first().append(j.html(` <span class="mal-sync-ep-pre" title="${en.fn.progress.getAutoText()}">[<span style="border-bottom: 1px dotted ${en.fn.progress.getColor()};">${en.fn.progress.getCurrentEpisode()}</span>]</span>`));
                            }
                        })));
                    }
                    listProvider.getCompleteList().then(list => {
                        "anime" === this.page.type ? this.tempAnimelist = list : this.tempMangalist = list, 
                        fullListCallback(list);
                    }).catch(e => {
                        con.error(e), listProvider.flashmError(e);
                    });
                });
            }
        }
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SimklClass;
        }));
        var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26), _provider_Simkl_single__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35), _provider_Simkl_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28), _provider_Simkl_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86), _malkiss_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(259), _utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class SimklClass {
            constructor(url) {
                this.url = url, this.page = null, utils.urlChangeDetect(() => {
                    clearInterval(this.interval), this.interval = utils.waitUntilTrue((function() {
                        return !($("#global_div").length && 1 !== parseInt($("#global_div").css("opacity")) || $("#tvMainTable").length && 1 !== parseInt($("#tvMainTable").css("opacity")));
                    }), () => {
                        this.url = window.location.href, this.init();
                    }, 1e3);
                }), api.storage.addStyle(__webpack_require__(300).toString()), $(document).ready(() => {
                    this.init();
                });
            }
            init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    con.log(this.url), clearInterval(this.interval2), this.url.indexOf("apps/chrome/mal-sync") > -1 && this.authentication();
                    const urlpart = utils.urlPart(this.url, 3), url2part = utils.urlPart(this.url, 4);
                    if (("anime" === urlpart || "manga" === urlpart) && !Number.isNaN(Number(url2part))) {
                        const malObj = new _provider_Simkl_single__WEBPACK_IMPORTED_MODULE_1__.a(this.url);
                        return yield malObj.update(), this.page = {
                            page: "detail",
                            id: malObj.getIds().simkl,
                            malid: malObj.getIds().mal,
                            type: urlpart,
                            malObj: malObj
                        }, con.log("page", this.page), $("#malkiss").length || $(".SimklTVAboutBlockTitle, .simkltvdetailmobilesummaryinfo").after(j.html('<div id="malkiss"></div>')), 
                        this.malkiss && this.malkiss.$destroy(), this.malkiss = new vue__WEBPACK_IMPORTED_MODULE_0__.a({
                            el: "#malkiss",
                            render: h => h(_malkiss_vue__WEBPACK_IMPORTED_MODULE_4__.a)
                        }).$children[0], this.streamingUI(), this.malToKiss(), void this.pageRelation();
                    }
                    if ("anime" !== urlpart && "manga" !== urlpart || "all" !== url2part || (this.page = {
                        page: "bookmarks",
                        type: urlpart
                    }, this.bookmarksAnime()), "anime" === url2part || "manga" === url2part) {
                        "watching" === utils.urlPart(this.url, 5) && (this.page = {
                            page: "bookmarks",
                            type: url2part
                        }, this.bookmarksProfile());
                    }
                }));
            }
            getMalUrl() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const urlpart = utils.urlPart(this.url, 3);
                    if ("anime" === urlpart || "manga" === urlpart) {
                        const simklId = utils.urlPart(this.url, 4);
                        return _provider_Simkl_helper__WEBPACK_IMPORTED_MODULE_3__.c(simklId).then(malId => malId ? `https://myanimelist.net/${urlpart}/${malId}/${utils.urlPart(this.url, 5)}` : "");
                    }
                    return "";
                }));
            }
            authentication() {
                try {
                    utils.checkDoubleExecution();
                } catch (e) {
                    con.error(e);
                }
                try {
                    const code = utils.urlParam(this.url, "code");
                    if (!code) throw "No code found!";
                    _provider_Simkl_helper__WEBPACK_IMPORTED_MODULE_3__.a("https://api.simkl.com/oauth/token", JSON.stringify({
                        code: code,
                        client_id: _provider_Simkl_helper__WEBPACK_IMPORTED_MODULE_3__.b,
                        client_secret: "3f883e8e6cdd60d2d5e765aaf0612953f743dc77f44c422af98b38e083cf038b",
                        redirect_uri: "https://simkl.com/apps/chrome/mal-sync/connected/",
                        grant_type: "authorization_code"
                    }), !1, "POST").then(access_token => {
                        if (void 0 !== access_token.error || void 0 === access_token.access_token) throw access_token;
                        return api.settings.set("simklToken", access_token.access_token);
                    }).then(access_token => {
                        $(".firstStage").addClass("HideImportant"), $(".secondStage").removeClass("HideImportant"), 
                        $(".secondStage .SimklTVKodiheaddesc").css("text-align", "center");
                    }).catch(e => {
                        ee(e);
                    });
                } catch (e) {
                    ee(e);
                }
                function ee(e) {
                    con.error(e), $(".firstStage .SimklTVKodititletext, .secondStage .SimklTVKodititletext").text("Something went wrong");
                }
            }
            streamingUI() {
                return __awaiter(this, void 0, void 0, (function*() {
                    con.log("Streaming UI");
                    const {malObj: malObj} = this.page, streamUrl = malObj.getStreamingUrl();
                    if (void 0 !== streamUrl) {
                        this.malkiss.streamUrl = streamUrl;
                        const resumeUrlObj = malObj.getResumeWatching(), continueUrlObj = malObj.getContinueWatching();
                        con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === malObj.getEpisode() + 1 ? this.malkiss.continueUrl = continueUrlObj.url : resumeUrlObj && resumeUrlObj.ep === malObj.getEpisode() && (this.malkiss.resumeUrl = resumeUrlObj.url);
                    } else this.malkiss.streamUrl = null;
                }));
            }
            malToKiss() {
                con.log("malToKiss");
                const title = $("h1").first().text().trim();
                Object(_utils_quicklinksBuilder__WEBPACK_IMPORTED_MODULE_5__.a)(this.page.type, this.page.malid, title).then(links => {
                    this.malkiss.links = links;
                });
            }
            pageRelation() {
                return __awaiter(this, void 0, void 0, (function*() {
                    yield this.page.malObj.fillRelations(), this.malkiss.pageRelation = this.page.malObj.getPageRelations();
                }));
            }
            bookmarksProfile() {
                const listProvider = new _provider_Simkl_list__WEBPACK_IMPORTED_MODULE_2__.a(1, this.page.type);
                listProvider.getCompleteList().then(list => {
                    $.each(list, (index, en) => __awaiter(this, void 0, void 0, (function*() {
                        con.log("en", en);
                        const element = $(`a[href^="/${this.page.type}/${en.uid}"]`);
                        if (element && !element.hasClass("malSyncDone2") && (element.addClass("malSyncDone2"), 
                        en.options && en.options.u)) {
                            con.log(en.options.u), element.after(j.html(`\n            <a class="mal-sync-stream mal-rem" onclick="event.stopPropagation();" title="${en.options.u.split("/")[2]}" target="_blank" style="display: inline-block; height: 0; position: relative; top: -11px; margin-left: 5px;" href="${en.options.u}">\n              <img src="${utils.favicon(en.options.u.split("/")[2])}">\n            </a>`));
                            const resumeUrlObj = en.options.r, continueUrlObj = en.options.c, curEp = en.watchedEp;
                            con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === curEp + 1 ? element.parent().append(j.html(`<a class="nextStream mal-rem" onclick="event.stopPropagation();" title="Continue watching" target="_blank" style="display: inline-block; height: 0; position: relative; top: -11px; margin-left: 5px; color: #BABABA;" href="${continueUrlObj.url}">\n                <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n              </a>`)) : resumeUrlObj && resumeUrlObj.ep === curEp && element.parent().append(j.html(`<a class="resumeStream mal-rem" onclick="event.stopPropagation();" title="Resume watching" target="_blank" style="display: inline-block; height: 0; position: relative; top: -11px; margin-left: 5px; color: #BABABA;" href="${resumeUrlObj.url}">\n                <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n              </a>`));
                        }
                    })));
                }).catch(e => {
                    con.error(e), listProvider.flashmError(e);
                });
            }
            bookmarksAnime() {
                const listProvider = new _provider_Simkl_list__WEBPACK_IMPORTED_MODULE_2__.a(1, this.page.type);
                listProvider.getCompleteList().then(list => {
                    function exec() {
                        con.info("list"), $.each(list, (index, en) => __awaiter(this, void 0, void 0, (function*() {
                            const element = $("#c" + en.uid);
                            if (element && element.length && !element.hasClass("malSyncDone2") && (element.addClass("malSyncDone2").css("position", "relative"), 
                            en.options && en.options.u)) {
                                con.log(en.options.u), element.append(j.html(`\n              <a class="mal-sync-stream mal-rem" onclick="event.stopPropagation();" title="${en.options.u.split("/")[2]}" target="_blank" style="position: absolute; z-index: 10; right: 0; top: 0; background-color: #00000057; padding: 5px;" href="${en.options.u}">\n                <img src="${utils.favicon(en.options.u.split("/")[2])}">\n              </a>`));
                                const resumeUrlObj = en.options.r, continueUrlObj = en.options.c, curEp = en.watchedEp;
                                con.log("Resume", resumeUrlObj, "Continue", continueUrlObj), continueUrlObj && continueUrlObj.ep === curEp + 1 ? element.append(j.html(`<a class="nextStream mal-rem" onclick="event.stopPropagation();" title="Continue watching" target="_blank" style="position: absolute; z-index: 10; right: 0; top: 26px; background-color: #00000057; padding: 5px;" href="${continueUrlObj.url}">\n                  <img src="${api.storage.assetUrl("double-arrow-16px.png")}" width="16" height="16">\n                </a>`)) : resumeUrlObj && resumeUrlObj.ep === curEp && element.append(j.html(`<a class="resumeStream mal-rem" onclick="event.stopPropagation();" title="Resume watching" target="_blank" style="position: absolute; z-index: 10; right: 0; top: 26px; background-color: #00000057; padding: 5px;" href="${resumeUrlObj.url}">\n                  <img src="${api.storage.assetUrl("arrow-16px.png")}" width="16" height="16">\n                </a>`));
                            }
                        })));
                    }
                    exec(), this.interval2 = utils.changeDetect(() => {
                        exec();
                    }, () => $("#tv_best_left_addContainer li").length + $("#tv_best_left_addContainer > div").height());
                }).catch(e => {
                    con.error(e), listProvider.flashmError(e);
                });
            }
        }
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return pages;
    }));
    var _hanime_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(118), _HentaiHaven_main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119), _Hentaigasm_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(120), _KissHentai_main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(121), _UnderHentai_main__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(122), _Nhentai_main__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(123);
    const pages = {
        hanime: _hanime_main__WEBPACK_IMPORTED_MODULE_0__.a,
        HentaiHaven: _HentaiHaven_main__WEBPACK_IMPORTED_MODULE_1__.a,
        Hentaigasm: _Hentaigasm_main__WEBPACK_IMPORTED_MODULE_2__.a,
        KissHentai: _KissHentai_main__WEBPACK_IMPORTED_MODULE_3__.a,
        UnderHentai: _UnderHentai_main__WEBPACK_IMPORTED_MODULE_4__.a,
        Nhentai: _Nhentai_main__WEBPACK_IMPORTED_MODULE_5__.a
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return hanime;
        }));
        const hanime = {
            name: "hanime",
            domain: "https://hanime.tv",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "videos" === url.split("/")[3] && "hentai" === url.split("/")[4],
            sync: {
                getTitle: url => j.$("h1.tv-title").text().replace(/ ([^a-z]*)$/gim, "").trim(),
                getIdentifier(url) {
                    const urlPart5 = utils.urlPart(url, 5);
                    return urlPart5 ? urlPart5.replace(/-([^a-z]*)$/gim, "").trim() : "";
                },
                getOverviewUrl(url) {
                    const overviewPart = utils.urlPart(url, 5);
                    if (!overviewPart) return "";
                    return null !== overviewPart.match(/-([^a-z]*)$/gim) ? `${hanime.domain}/videos/hentai/${hanime.sync.getIdentifier(url)}-1` : `${hanime.domain}/videos/hentai/${hanime.sync.getIdentifier(url)}`;
                },
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = utils.urlPart(url, 5);
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-([^a-z]*)$/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(302).toString()), j.$(document).ready((function() {
                    "videos" === page.url.split("/")[3] && "hentai" === page.url.split("/")[4] && utils.waitUntilTrue((function() {
                        return j.$("h1.tv-title").text();
                    }), (function() {
                        page.handlePage();
                    }));
                })), utils.urlChangeDetect((function() {
                    page.reset(), "videos" === page.url.split("/")[3] && "hentai" === page.url.split("/")[4] && utils.waitUntilTrue((function() {
                        return j.$("h1.tv-title").text();
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return HentaiHaven;
        }));
        const HentaiHaven = {
            name: "HentaiHaven",
            domain: "https://hentaihaven.org",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !(null === url.split("/")[3] || !j.$("h1.entry-title")[0] || !j.$("div.hentaiha-post-tabs")[0]),
            sync: {
                getTitle: url => j.$("div > header > div > a").text(),
                getIdentifier(url) {
                    const anchorHref = j.$("div > header > div > a").attr("href");
                    return anchorHref ? anchorHref.split("/")[4] : "";
                },
                getOverviewUrl: url => j.$("div > header > div > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[3];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-episode-\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("h1.archive-title").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.archive-meta.category-meta").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(304).toString()), j.$(document).ready((function() {
                    (null !== page.url.split("/")[3] && j.$("h1.entry-title")[0] && j.$("div.hentaiha-post-tabs")[0] || "series" === page.url.split("/")[3]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Hentaigasm;
        }));
        const Hentaigasm = {
            name: "Hentaigasm",
            domain: "http://hentaigasm.com",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !(null === url.split("/")[6] || !j.$("#extras > h4:nth-child(2) > a")[0] || !j.$("div.entry-content.rich-content")[0]),
            sync: {
                getTitle: url => j.$("h1#title").text().replace(/\d+ (subbed|raw)/gim, "").trim(),
                getIdentifier: url => url.split("/")[6].replace(/-\d*-(subbed|raw)/gim, "").trim(),
                getOverviewUrl: url => j.$("#extras > h4:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[6];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-\d+-(subbed|raw)/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("#content > div.loop-header > h1 > em").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.loop-actions").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(306).toString()), j.$(document).ready((function() {
                    (null !== page.url.split("/")[6] && j.$("#extras > h4:nth-child(2) > a")[0] && j.$("div.entry-content.rich-content")[0] || "hentai" === page.url.split("/")[3]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return KissHentai;
        }));
        const KissHentai = {
            name: "KissHentai",
            domain: "http://kisshentai.net",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !("Hentai" !== url.split("/")[3] || !j.$("div#videoKissHentai")[0]),
            sync: {
                getTitle: url => j.$("#navsubbar a").first().text().replace("Hentai", "").replace("information", "").trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl(url) {
                    const anchorHref = j.$("#navsubbar a").first().attr("href");
                    return anchorHref ? KissHentai.domain + anchorHref : "";
                },
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/Episode-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: () => j.$(".bigChar").first().text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$(".bigChar").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(308).toString()), j.$(document).ready((function() {
                    "Hentai" === page.url.split("/")[3] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return UnderHentai;
        }));
        const UnderHentai = {
            name: "UnderHentai",
            domain: "https://www.underhentai.net",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "watch" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.content-box.content-head.sidebar-light").first().text().trim().replace(/- episode.*\d+/gim, "").trim(),
                getIdentifier: url => UnderHentai.sync.getTitle(url).toLowerCase().replace(/[^A-Z0-9 ]/gim, "").replace(/\s+/gm, "-").trim().replace(" ", "-"),
                getOverviewUrl: url => `${UnderHentai.domain}/${UnderHentai.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const episodePart = j.$("div.content-box.content-head.sidebar-light").first().text().trim();
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/- episode.*\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("h1.content-box.content-head.sidebar-light").first().text().trim(),
                getIdentifier: url => url.split("/")[3],
                uiSelector(selector) {
                    j.$("div.content-table").first().before(j.html(selector));
                }
            },
            init(page) {
                if ("Just a moment..." === document.title) return con.log("loading"), void page.cdn();
                api.storage.addStyle(__webpack_require__(310).toString()), j.$(document).ready((function() {
                    ("watch" === page.url.split("/")[3] || null !== page.url.split("/")[3] && "Episode" === j.$("div.content-table > table > thead > tr > th.c1").text()) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, con, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Nhentai;
        }));
        const Nhentai = {
            name: "Nhentai",
            domain: "https://nhentai.net",
            languages: [ "English", "Chinese", "Japanese" ],
            type: "manga",
            isSyncPage: url => !(!url.split("/")[5] || !url.split("/")[5].length),
            sync: {
                getTitle(url) {
                    const scripts = j.$("script").text().replace(/\\u0022/g, '"');
                    con.info(scripts);
                    try {
                        const pl = "";
                        return scripts.split(`"pretty":${pl}"`)[1].split('"}')[0];
                    } catch (e) {
                        return "";
                    }
                },
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => `${Nhentai.domain}/g/${Nhentai.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    try {
                        const scripts = j.$("script").text();
                        let episodePart;
                        if (episodePart = -1 !== scripts.indexOf('"english":"') ? scripts.split('"english":"')[1].split('"')[0] : scripts.split('"japanese":"')[1].split('"')[0], 
                        episodePart.length) {
                            const temp = episodePart.match(/(ch|ch.|chapter).?\d+/gim);
                            if (null !== temp) return Number(temp[0].replace(/\D+/g, ""));
                        }
                    } catch (e) {
                        con.info(e);
                    }
                    return 1;
                }
            },
            overview: {
                getTitle: () => j.$('meta[itemprop="name"]').first().attr("content").replace(/(\([^)]*\)|\[[^\]]*\])/g, "").trim(),
                getIdentifier: url => Nhentai.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("#info h1").first().after(j.html(selector));
                }
            },
            init: page => (api.storage.addStyle(__webpack_require__(312).toString()), void j.$(document).ready((function() {
                page.url.match(/nhentai.[^/]*\/g\/\d+/i) && page.handlePage();
            })))
        };
    }).call(this, __webpack_require__(2), __webpack_require__(4), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return floatClick;
        }));
        var _minimal_minimalClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
        let minimalObj;
        function floatClick(page) {
            con.log("Open miniMAL"), "none" === j.$("#info-popup").css("display") ? (document.getElementById("info-popup").style.display = "block", 
            j.$(".floatbutton").fadeOut(), j.$("#info-iframe").length ? void 0 !== minimalObj && void 0 !== page.malObj && (minimalObj.fillBase(page.malObj.url), 
            minimalObj.setPageSync(page)) : function(page) {
                const iframe = document.createElement("iframe");
                iframe.setAttribute("id", "info-iframe"), iframe.setAttribute("style", "height:100%;width:100%;border:0;display:block;"), 
                iframe.onload = function() {
                    const head = j.$("#info-iframe").contents().find("head");
                    api.storage.injectjsResource("material.js", head), api.storage.updateDom(head), 
                    api.storage.injectCssResource("material.css", head), api.storage.injectCssResource("materialFont.css", head), 
                    setTimeout((function() {
                        minimalObj = new _minimal_minimalClass__WEBPACK_IMPORTED_MODULE_0__.a(j.$("#info-iframe").contents().find("html")), 
                        void 0 !== page && (void 0 !== page.singleObj ? minimalObj.fillBase(page.singleObj.getUrl()) : minimalObj.fillBase(null), 
                        minimalObj.setPageSync(page));
                    }), 200);
                }, document.getElementById("modal-content").appendChild(iframe), j.$("#modal-content").append(j.html('<div class="kal-tempHeader" style="position:  absolute; width: 100%; height:  103px; background-color: rgb(63,81,181); "></div>')), 
                j.$("#info-iframe").length && "block" === j.$("#info-iframe").css("display") || (j.$("#info-popup").remove(), 
                alert("The miniMAL iframe could not be loaded.\nThis could be caused by an AdBlocker."));
            }(page)) : (document.getElementById("info-popup").style.display = "none", j.$(".floatbutton").fadeIn());
        }
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, con, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Minimal;
        }));
        var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26), vue_dompurify_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126), vue_dompurify_html__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(vue_dompurify_html__WEBPACK_IMPORTED_MODULE_1__), vue_clazy_load__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127), _minimalApp_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(261), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        vue__WEBPACK_IMPORTED_MODULE_0__.a.use(vue_clazy_load__WEBPACK_IMPORTED_MODULE_2__), 
        vue__WEBPACK_IMPORTED_MODULE_0__.a.use(vue_dompurify_html__WEBPACK_IMPORTED_MODULE_1___default.a, {
            default: {
                ADD_ATTR: [ "target" ]
            }
        });
        class Minimal {
            constructor(minimal) {
                function handleConnectionChange(event) {
                    "offline" === event.type && (con.log("Offline"), utils.flashm("You're offline check your connection", {
                        error: !0,
                        type: "offline",
                        permanent: !0
                    })), "online" === event.type && (con.log("You are now back online."), $(".type-offline").remove());
                }
                this.minimal = minimal, this.history = [], this.minimal.find("body").append(j.html('<div id="minimalApp"></div>')), 
                this.minimalVue = new vue__WEBPACK_IMPORTED_MODULE_0__.a({
                    el: this.minimal.find("#minimalApp").get(0),
                    methods: {
                        updateDom: () => {
                            this.updateDom();
                        }
                    },
                    render: h => h(_minimalApp_vue__WEBPACK_IMPORTED_MODULE_3__.a)
                }), this.minimal.find("head").append(j.html('<base href="https://myanimelist.net/">')), 
                this.uiListener(), this.injectCss(), this.loadSettings(), this.updateDom(), window.addEventListener("online", handleConnectionChange), 
                window.addEventListener("offline", handleConnectionChange);
            }
            uiListener() {
                const modal = document.getElementById("info-popup"), This = this;
                this.minimal.on("click", ".mdl-layout__content a", (function(e) {
                    if ("_blank" === j.$(this).attr("target") || j.$(this).hasClass("nojs")) return;
                    e.preventDefault();
                    let url = j.$(this).attr("href") || "";
                    if (/^local:\/\//i.test(url) || (url = utils.absoluteLink(url, "https://myanimelist.net")), 
                    !This.fill(url)) {
                        const win = window.open(url, "_blank");
                        win ? win.focus() : alert(api.storage.lang("minimalClass_Popup"));
                    }
                })), this.minimal.find("#close-info-popup").click((function() {
                    This.isPopup() ? window.close() : (modal.style.display = "none", j.$(".floatbutton").fadeIn());
                })), this.minimal.find("#material-fullscreen").click((function() {
                    j.$(".modal-content-kal.fullscreen").length ? (j.$(".modal-content-kal").removeClass("fullscreen"), 
                    j.$(this).find("i").text("fullscreen")) : (j.$(".modal-content-kal").addClass("fullscreen"), 
                    j.$(this).find("i").text("fullscreen_exit"));
                }));
            }
            isPopup() {
                return !!j.$("#Mal-Sync-Popup").length;
            }
            updateDom() {
                this.minimal.find("head").click();
            }
            injectCss() {
                this.minimal.find("head").append(j.$("<style>").html(__webpack_require__(577).toString()));
            }
            fill(url) {
                return this.minimalVue.$children[0].fill(url);
            }
            fillBase(url) {
                return this.minimalVue.$children[0].fillBase(url);
            }
            setPageSync(page) {
                this.minimalVue.$children[0].setPage(page);
            }
            loadSettings() {
                const This = this;
                this.minimal.find("#posLeft").val(api.settings.get("posLeft")), this.minimal.find("#posLeft").change((function() {
                    api.settings.set("posLeft", j.$(this).val()), j.$("#modal-content").css("right", "auto").css("left", "auto").css(String(j.$(this).val()), "0");
                })), this.minimal.find("#autoTrackingModeanime").val(api.settings.get("autoTrackingModeanime")), 
                this.minimal.find("#autoTrackingModeanime").change((function() {
                    api.settings.set("autoTrackingModeanime", j.$(this).val());
                })), this.minimal.find("#theme").val(api.settings.get("theme")), this.minimal.find("#theme").change((function() {
                    api.settings.set("theme", j.$(this).val()), This.minimal.attr("id", "cr");
                })), this.minimal.find("#autoTrackingModemanga").val(api.settings.get("autoTrackingModemanga")), 
                this.minimal.find("#autoTrackingModemanga").change((function() {
                    api.settings.set("autoTrackingModemanga", j.$(this).val());
                })), this.minimal.find("#miniMalWidth").on("input", (function() {
                    let miniMalWidth = This.minimal.find("#miniMalWidth").val();
                    null !== miniMalWidth && ("" === miniMalWidth && (miniMalWidth = "30%", utils.flashm("Width reset")), 
                    api.settings.set("miniMalWidth", miniMalWidth)), j.$("#modal-content").css("width", miniMalWidth);
                })), this.minimal.find("#syncMode").change((function() {
                    const value = j.$(this).val();
                    api.settings.set("syncMode", value), This.minimal.find("#clearCache").click();
                })), this.minimal.find("#syncMode").val(api.settings.get("syncMode")), this.minimal.find("#miniMalHeight").on("input", (function() {
                    let miniMalHeight = This.minimal.find("#miniMalHeight").val();
                    null !== miniMalHeight && ("" === miniMalHeight && (miniMalHeight = "90%", utils.flashm("Height reset")), 
                    api.settings.set("miniMalHeight", miniMalHeight)), j.$("#modal-content").css("height", miniMalHeight);
                })), this.minimal.find("#malThumbnail").val(api.settings.get("malThumbnail")), this.minimal.find("#malThumbnail").change((function() {
                    api.settings.set("malThumbnail", This.minimal.find("#malThumbnail").val());
                })), this.minimal.find("#clearCache").click((function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const cacheArray = yield api.storage.list();
                        let deleted = 0;
                        j.$.each(cacheArray, (function(index, cache) {
                            utils.syncRegex.test(String(index)) || /(^tagSettings\/.*)/.test(String(index)) || (api.storage.remove(String(index)), 
                            deleted++);
                        })), utils.flashm(`Cache Cleared [${deleted}]`);
                    }));
                })), "webextension" === api.type && this.minimal.find(".option-extension").show(), 
                "webextension" === api.type && this.isPopup() && this.minimal.find(".option-extension-popup").show(), 
                "webextension" === api.type && this.isPopup() && (chrome.alarms.get("updateCheck", a => {
                    con.log(a);
                    let interval = 0;
                    if (void 0 !== a && (interval = a.periodInMinutes, this.minimal.find(".updateCheckEnable").show()), 
                    this.minimal.find("#updateCheckTime").val(interval), interval) {
                        function setUpdateCheckLast() {
                            api.storage.get("updateCheckLast").then(updateCheckTime => {
                                if (Number.isNaN(updateCheckTime)) return;
                                const delta = Math.abs(updateCheckTime - Date.now());
                                let text = utils.timeDiffToText(delta);
                                "" !== text && (text += "ago", $("#updateCheckAgo").text(text));
                            });
                        }
                        setUpdateCheckLast(), setInterval((function() {
                            setUpdateCheckLast();
                        }), 6e4);
                    }
                }), this.minimal.find("#updateCheckTime").change(() => {
                    const updateCheckTime = this.minimal.find("#updateCheckTime").val();
                    api.storage.set("updateCheckTime", updateCheckTime), 0 !== updateCheckTime && "0" !== updateCheckTime ? (this.minimal.find(".updateCheckEnable").show(), 
                    chrome.alarms.create("updateCheck", {
                        periodInMinutes: parseInt(updateCheckTime)
                    }), utils.canHideTabs() || chrome.permissions.request({
                        permissions: [ "webRequest", "webRequestBlocking" ],
                        origins: chrome.runtime.getManifest().optional_permissions.filter(permission => "webRequest" !== permission && "webRequestBlocking" !== permission)
                    }, (function(granted) {
                        con.log("optional_permissions", granted);
                    })), chrome.alarms.create("updateCheckNow", {
                        when: Date.now() + 1e3
                    })) : (this.minimal.find(".updateCheckEnable").hide(), chrome.alarms.clear("updateCheck"));
                }), this.minimal.find("#updateCheck").show()), this.minimal.find("#updateCheckUi").click(() => {
                    this.minimalVue.$children[0].selectTab("updateCheck");
                }), this.minimal.find("#listSyncUi").click(() => {
                    this.minimalVue.$children[0].selectTab("listSync");
                }), this.minimal.find("#cleanTagsUi").click(() => {
                    this.minimalVue.$children[0].selectTab("cleanTags");
                }), this.minimal.find("#allSitesUi").click(() => {
                    this.minimalVue.$children[0].selectTab("allSites");
                }), this.minimal.find("#customDomainsUi").click(() => {
                    this.minimalVue.$children[0].selectTab("customDomains");
                }), this.minimal.find("#quicklinkoverview").click(() => {
                    this.minimalVue.$children[0].selectTab("quicklinks");
                }), api.storage.get("tempVersion").then(version => {
                    let versionMsg = "";
                    version !== api.storage.version() && (versionMsg = api.storage.lang("minimalClass_versionMsg", [ api.storage.version(), `[<a class="close" target="_blank" href="https://malsync.lolamtisch.de/changelog#${api.storage.version()}">` ])), 
                    con.log(version), void 0 === version && "webextension" !== api.type && (versionMsg = `\n            <div style="\n              text-align: left;\n              margin-left: auto;\n              margin-right: auto;\n              display: inline-block;\n              padding: 10px 15px;\n              background-color: #3d4e9a;\n              margin-top: -5px;\n            ">\n              <span style="text-decoration: underline; font-size: 15px;">${api.storage.lang("minimalClass_versionMsg_Text_1")}</span><br>\n              <br>\n              ${api.storage.lang("minimalClass_versionMsg_Text_4")}<br>\n              <a target="_blank" href="https://github.com/Karmesinrot/Anifiltrs#anifiltrs">\n                <img alt="Filter List" src="https://img.shields.io/badge/ublock-Anifiltrs-800900.svg?style=flat-square">\n              </a><br>\n              <br>\n\n\n              ${api.storage.lang("minimalClass_versionMsg_Text_2")}<br>\n              <a target="_blank" href="https://discord.com/invite/cTH4yaw">\n                <img alt="Discord" src="https://img.shields.io/discord/358599430502481920.svg?style=flat-square&amp;logo=discord&amp;label=Discord&amp;colorB=7289DA">\n              </a><br>\n              <a target="_blank" href="https://github.com/MALSync/MALSync/issues">\n                <img alt="Github Issues" src="https://img.shields.io/github/issues/MALSync/MALSync.svg?style=flat-square&amp;logo=github&amp;logoColor=white">\n              </a><br>\n              <br>\n              ${api.storage.lang("minimalClass_versionMsg_Text_3")}<br>\n              <a target="_blank" href="https://github.com/MALSync/MALSync">\n                <img alt="Github" src="https://img.shields.io/github/last-commit/MALSync/MALSync.svg?style=flat-square&amp;logo=github&amp;logoColor=white&amp;label=Github">\n              </a>\n            </div>\n          `), 
                    "" !== versionMsg && this.flashm(versionMsg, (function() {
                        api.storage.set("tempVersion", api.storage.version());
                    }));
                });
            }
            searchMal(keyword, type = "all", selector, callback) {
                const This = this;
                this.minimal.find(selector).html(j.html("")), api.request.xhr("GET", `https://myanimelist.net/search/prefix.json?type=${type}&keyword=${keyword}&v=1`).then(response => {
                    const searchResults = j.$.parseJSON(response.responseText);
                    this.minimal.find(selector).append(j.html('<div class="mdl-grid">\n            <select name="myinfo_score" id="searchListType" class="inputtext mdl-textfield__input mdl-cell mdl-cell--12-col" style="outline: none; background-color: white; border: none;">\n              <option value="anime">Anime</option>\n              <option value="manga">Manga</option>\n            </select>\n          </div>')), 
                    this.minimal.find("#searchListType").val(type), this.minimal.find("#searchListType").change((function(event) {
                        This.searchMal(keyword, This.minimal.find("#searchListType").val(), selector, callback);
                    })), j.$.each(searchResults, (i, value0) => {
                        j.$.each(value0, (i2, value2) => {
                            j.$.each(value2, (i3, value3) => {
                                "object" == typeof value3 && j.$.each(value3, (i4, value) => {
                                    void 0 !== value.name && This.minimal.find(selector + " > div").append(j.html(`<a class="mdl-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--2dp mdl-grid searchItem" href="${value.url}" style="cursor: pointer;">                  <img src="${value.image_url}" style="margin: -8px 0px -8px -8px; height: 100px; width: 64px; background-color: grey;"></img>                  <div style="flex-grow: 100; cursor: pointer; margin-top: 0; margin-bottom: 0;" class="mdl-cell">                    <span style="font-size: 20px; font-weight: 400; line-height: 1;">${value.name}</span>                    <p style="margin-bottom: 0; line-height: 20px; padding-top: 3px;">${api.storage.lang("search_Type")} ${value.payload.media_type}</p>                    <p style="margin-bottom: 0; line-height: 20px;">${api.storage.lang("search_Score")} ${value.payload.score}</p>                    <p style="margin-bottom: 0; line-height: 20px;">${api.storage.lang("search_Year")} ${value.payload.start_year}</p>                  </div>                  </a>`));
                                });
                            });
                        });
                    }), callback();
                });
            }
            flashm(text, closefn) {
                const mess = `\n      <div style="\n        background-color: #3f51b5;\n        text-align: center;\n        padding: 5px 24px;\n        color: white;\n        border-top: 1px solid #fefefe;\n      ">\n        ${text}\n        <i class="material-icons close" style="\n          float: right;\n          font-size: 24px;\n          margin-top: -2px;\n          margin-right: -24px;\n          margin-bottom: -5px;\n        ">${api.storage.lang("close")}</i>\n      </div>\n    `, flashmDiv = j.$(j.html(mess)).appendTo(this.minimal.find(".mdl-layout"));
                return flashmDiv.find(".close").click((function() {
                    flashmDiv.slideUp(100, (function() {
                        flashmDiv.remove(), closefn();
                    }));
                })), flashmDiv;
            }
        }
    }).call(this, __webpack_require__(2), __webpack_require__(4), __webpack_require__(1), __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var dompurify_html_1 = __webpack_require__(314);
    exports.default = {
        install: function(Vue, config) {
            void 0 === config && (config = {}), Vue.directive("dompurify-html", dompurify_html_1.buildDirective(config));
        }
    };
}, function(module, exports, __webpack_require__) {
    var factory;
    "undefined" != typeof self && self, factory = function() {
        return function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: !1,
                    exports: {}
                };
                return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
                module.l = !0, module.exports;
            }
            return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
            __webpack_require__.d = function(exports, name, getter) {
                __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                    configurable: !1,
                    enumerable: !0,
                    get: getter
                });
            }, __webpack_require__.n = function(module) {
                var getter = module && module.__esModule ? function() {
                    return module.default;
                } : function() {
                    return module;
                };
                return __webpack_require__.d(getter, "a", getter), getter;
            }, __webpack_require__.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
            }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 0);
        }([ function(module, __webpack_exports__, __webpack_require__) {
            "use strict";
            Object.defineProperty(__webpack_exports__, "__esModule", {
                value: !0
            }), __webpack_require__.d(__webpack_exports__, "install", (function() {
                return install;
            })), __webpack_require__.d(__webpack_exports__, "VueClazyLoad", (function() {
                return VueClazyLoad;
            }));
            var ClazyLoadComponent = {
                name: "ClazyLoad",
                props: {
                    tag: {
                        type: String,
                        default: "div"
                    },
                    src: {
                        type: String,
                        required: !0
                    },
                    element: String,
                    threshold: {
                        type: [ Array, Number ],
                        default: function() {
                            return [ 0, .5, 1 ];
                        }
                    },
                    ratio: {
                        type: Number,
                        default: .4,
                        validator: function(value) {
                            return value > 0 && value <= 1;
                        }
                    },
                    margin: {
                        type: String,
                        default: "0px"
                    },
                    crossorigin: {
                        type: String,
                        default: null,
                        validator: function(value) {
                            return "anonymous" === value || "use-credentials" === value;
                        }
                    },
                    loadedClass: {
                        type: String,
                        default: "loaded"
                    },
                    loadingClass: {
                        type: String,
                        default: "loading"
                    },
                    errorClass: {
                        type: String,
                        default: null
                    }
                },
                data: function() {
                    return {
                        loaded: !1,
                        observer: null,
                        errored: !1
                    };
                },
                methods: {
                    load: function() {
                        var _this = this;
                        if (this.$emit("loading"), this.observer.disconnect(), !this.loaded) {
                            var img = new Image;
                            img.addEventListener("load", (function() {
                                _this.loaded = !0, _this.$emit("load"), _clear();
                            })), img.addEventListener("error", (function(event) {
                                _this.errored = !0, _this.$emit("error", event), _clear();
                            }));
                            var _clear = function() {
                                img = null, _this.observer = null;
                            };
                            null !== this.crossorigin && (img.crossOrigin = this.crossorigin), img.src = this.src;
                        }
                    },
                    observe: function() {
                        var _this2 = this, options = {
                            threshold: this.threshold,
                            root: this.element ? document.querySelector(this.element) : null,
                            rootMargin: this.margin
                        };
                        this.observer = new IntersectionObserver((function(entries) {
                            entries[0].intersectionRatio >= _this2.ratio && _this2.load();
                        }), options), this.observer.observe(this.$el);
                    }
                },
                render: function(h) {
                    var elementClass = this.loaded ? this.loadedClass : this.loadingClass;
                    return h(this.tag, {
                        class: this.errored && this.errorClass ? this.errorClass : elementClass
                    }, [ this.loaded ? this.$slots.default || this.$slots.image : this.$slots.placeholder ]);
                },
                mounted: function() {
                    this.$nextTick(this.observe);
                }
            }, install = function(Vue) {
                Vue.component("clazy-load", ClazyLoadComponent);
            }, VueClazyLoad = ClazyLoadComponent;
            __webpack_exports__.default = {
                install: install
            };
        } ]);
    }, module.exports = factory();
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                return super(url), this.logger = this.logger.m("Local"), this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this;
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this;
                }));
            }
        }
    }).call(this, __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                if (super(url), this.logger = this.logger.m("MAL"), url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.malId = Number(utils.urlPart(url, 4)), this;
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.logger.log("Retrieve", this.type, "MAL: " + this.malId);
                    const data = yield this.getData();
                    this.title(data), this.description(data), this.image(data), this.alternativeTitle(data), 
                    this.characters(data), this.statistics(data), this.info(data), this.openingSongs(data), 
                    this.endingSongs(data), this.related(data), this.logger.log("Res", this.meta);
                }));
            }
            getData() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return api.request.xhr("GET", `https://myanimelist.net/${this.type}/${this.malId}`).then(response => response.responseText);
                }));
            }
            title(data) {
                let title = "";
                try {
                    title = data.split('itemprop="name">')[1].split("<")[0].replace(/&quot;/g, '"').replace(/&#039;/g, "'");
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.title = $("<div>").html(j.html(title)).text();
            }
            description(data) {
                let description = "";
                try {
                    description = data.split('itemprop="description">')[1].split("</p")[0].split("</span")[0];
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.description = description;
            }
            image(data) {
                let image = "";
                try {
                    image = data.split('property="og:image"')[1].split('content="')[1].split('"')[0];
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.image = image;
            }
            alternativeTitle(data) {
                let altTitle = [];
                try {
                    const tempHtml = j.$.parseHTML(`<div>${data.split("<h2>Alternative Titles</h2>")[1].split("<h2>")[0]}</div>`);
                    altTitle = j.$(tempHtml).find(".spaceit_pad").toArray().map((function(i) {
                        return utils.getBaseText(j.$(i)).trim();
                    }));
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.alternativeTitle = altTitle;
            }
            characters(data) {
                const charArray = [];
                try {
                    const characterBlock = data.split("detail-characters-list")[1].split("</h2>")[0], charHtml = j.$.parseHTML('<div class="detail-characters-list ' + characterBlock);
                    j.$.each(j.$(charHtml).find(":not(td) > table"), (index, value) => {
                        const regexDimensions = /\/r\/\d*x\d*/g;
                        let charImg = j.$(value).find("img").first().attr("data-src");
                        charImg = charImg && regexDimensions.test(charImg) ? charImg.replace(regexDimensions, "") : api.storage.assetUrl("questionmark.gif"), 
                        charImg = utils.handleMalImages(charImg);
                        const charObjLink = j.$(value).find(".borderClass .spaceit_pad").first().parent();
                        charArray.push({
                            img: charImg,
                            name: charObjLink.find("a").first().text(),
                            url: charObjLink.find("a").first().attr("href"),
                            subtext: charObjLink.find(".spaceit_pad").first().text().trim()
                        });
                    });
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.characters = charArray;
            }
            statistics(data) {
                const stats = [];
                try {
                    const statsBlock = data.split("<h2>Statistics</h2>")[1].split("<h2>")[0], tempHtml = j.$.parseHTML(statsBlock);
                    j.$.each(j.$(tempHtml).filter("div").slice(0, 5), (function(index, value) {
                        const title = j.$(value).find(".dark_text").text(), body = void 0 !== j.$(value).find("span[itemprop=ratingValue]").height() ? j.$(value).find("span[itemprop=ratingValue]").text() : j.$(value).clone().children().remove().end().text();
                        stats.push({
                            title: title,
                            body: body.trim()
                        });
                    }));
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.statistics = stats;
            }
            info(data) {
                const html = [];
                try {
                    const infoBlock = data.split("<h2>Information</h2>")[1].split("<h2>")[0], infoData = j.$.parseHTML(infoBlock);
                    j.$.each(j.$(infoData).filter("div"), (index, value) => {
                        const title = j.$(value).find(".dark_text").text();
                        j.$(value).find(".dark_text").remove();
                        const aTags = j.$(value).find("a").map((i, el) => ({
                            text: j.$(el).text().trim(),
                            url: j.$(el).attr("href")
                        }));
                        j.$(value).find("a, span").remove();
                        const textTags = j.$(value).text().split(",");
                        let body = [];
                        body = aTags.length ? aTags.length === textTags.length ? aTags.map((i, el) => (el.subtext = textTags[i].trim(), 
                        el)) : aTags : textTags.map(el => ({
                            text: el
                        })), html.push({
                            title: title.trim(),
                            body: body
                        });
                    }), this.getExternalLinks(html, data);
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.info = html;
            }
            getExternalLinks(html, data) {
                try {
                    const infoBlock = data.split("<h2>External Links</h2>")[1].split("</div>")[0] + "</div>", infoData = j.$.parseHTML(infoBlock), body = [];
                    j.$.each(j.$(infoData).find("a"), (index, value) => {
                        body.push({
                            text: j.$(value).text(),
                            url: j.$(value).attr("href")
                        });
                    }), body.length && html.push({
                        title: "External Links",
                        body: body
                    });
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
            }
            openingSongs(data) {
                const openingSongs = [];
                try {
                    const openingBlock = `<div>${data.split('opnening">')[1].split("</div>")[0]}</div>`, openingData = j.$.parseHTML(openingBlock);
                    j.$(openingData).find(".theme-song").each((_, el) => {
                        openingSongs.push($(el).text());
                    });
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.openingSongs = openingSongs;
            }
            endingSongs(data) {
                const endingSongs = [];
                try {
                    const endingBlock = `<div>${data.split(' ending">')[1].split("</div>")[0]}</div>`, endingData = j.$.parseHTML(endingBlock);
                    j.$(endingData).find(".theme-song").each((_, el) => {
                        endingSongs.push($(el).text());
                    });
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.endingSongs = endingSongs;
            }
            related(data) {
                const el = [];
                try {
                    const relatedBlock = data.split("Related ")[1].split("</h2>")[1].split("<h2>")[0], related = j.$.parseHTML(relatedBlock);
                    j.$.each(j.$(related).filter("table").find("tr"), (function(index, value) {
                        const links = [];
                        j.$(value).find(".borderClass").last().find("a").each((function(indexB, valueB) {
                            links.push({
                                url: j.$(valueB).attr("href") || "",
                                title: j.$(valueB).text(),
                                statusTag: ""
                            });
                        })), el.push({
                            type: j.$(value).find(".borderClass").first().text(),
                            links: links
                        });
                    }));
                } catch (e) {
                    console.log("[iframeOverview] Error:", e);
                }
                this.meta.related = el;
            }
        }
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var mediaTypeDefinition, airingStatusDefinition, sourceDefinition, ratingDefinition, _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10), _utils_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        !function(mediaTypeDefinition) {
            mediaTypeDefinition.unknown = "Unknown", mediaTypeDefinition.tv = "TV", mediaTypeDefinition.ova = "OVA", 
            mediaTypeDefinition.movie = "Movie", mediaTypeDefinition.special = "Special", mediaTypeDefinition.ona = "ONA", 
            mediaTypeDefinition.music = "Music", mediaTypeDefinition.manga = "Manga", mediaTypeDefinition.novel = "Novel", 
            mediaTypeDefinition.one_shot = "One shot", mediaTypeDefinition.doujinshi = "Doujinshi", 
            mediaTypeDefinition.manhwa = "Manhwa", mediaTypeDefinition.manhua = "Manhua", mediaTypeDefinition.oel = "OEL";
        }(mediaTypeDefinition || (mediaTypeDefinition = {})), function(airingStatusDefinition) {
            airingStatusDefinition.finished_airing = "Finished Airing", airingStatusDefinition.currently_airing = "Currently Airing", 
            airingStatusDefinition.not_yet_aired = "Not Yet Aired", airingStatusDefinition.finished = "Finished", 
            airingStatusDefinition.currently_publishing = "Currently Publishing", airingStatusDefinition.not_yet_published = "Not Yet Published";
        }(airingStatusDefinition || (airingStatusDefinition = {})), function(sourceDefinition) {
            sourceDefinition.other = "Other", sourceDefinition.original = "Original", sourceDefinition.manga = "Manga", 
            sourceDefinition["4_koma_manga"] = "4 Koma Manga", sourceDefinition.web_manga = "Web Manga", 
            sourceDefinition.digital_manga = "Digital Manga", sourceDefinition.novel = "Novel", 
            sourceDefinition.light_novel = "Light Novel", sourceDefinition.visual_novel = "Visual Novel", 
            sourceDefinition.game = "Game", sourceDefinition.card_game = "Card Game", sourceDefinition.book = "Book", 
            sourceDefinition.picture_book = "Picture Book", sourceDefinition.radio = "Radio", 
            sourceDefinition.music = "Music";
        }(sourceDefinition || (sourceDefinition = {})), function(ratingDefinition) {
            ratingDefinition.g = "G - All Ages", ratingDefinition.pg = "PG - Children", ratingDefinition.pg_13 = "PG 13 - Teens 13 and Older", 
            ratingDefinition.r = "R - 17+ (violence & profanity)", ratingDefinition["r+"] = "R+ - Profanity & Mild Nudity", 
            ratingDefinition.rx = "Rx - Hentai";
        }(ratingDefinition || (ratingDefinition = {}));
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                if (super(url), this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_2__.b, this.logger = this.logger.m("MAL"), 
                url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                void (this.malId = Number(utils.urlPart(url, 4)));
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.logger.log("Retrieve", this.type, this.malId);
                    const data = yield this.getData();
                    this.logger.log("Data", data), this.title(data), this.description(data), this.image(data), 
                    this.alternativeTitle(data), this.statistics(data), this.info(data), this.related(data), 
                    this.logger.log("Res", this.meta);
                }));
            }
            getData() {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.apiCall({
                        type: "GET",
                        path: `${this.type}/${this.malId}`,
                        fields: [ "synopsis", "alternative_titles", "mean", "rank", "popularity", "num_list_users", "num_scoring_users", "related_anime", "related_manga", "media_type", "num_episodes", "num_chapters", "num_volumes", "status", "start_date", "end_date", "start_season", "broadcast", "studios", "authors{first_name,last_name}", "source", "genres", "average_episode_duration", "rating", "serialization" ]
                    });
                }));
            }
            title(data) {
                this.meta.title = data.title;
            }
            description(data) {
                data.synopsis && (this.meta.description = data.synopsis);
            }
            image(data) {
                data.main_picture && data.main_picture.medium && (this.meta.image = data.main_picture.medium);
            }
            alternativeTitle(data) {
                if (data.alternative_titles) for (const prop in data.alternative_titles) {
                    const el = data.alternative_titles[prop];
                    Array.isArray(el) ? this.meta.alternativeTitle = this.meta.alternativeTitle.concat(el) : el && this.meta.alternativeTitle.push(el);
                }
            }
            statistics(data) {
                data.mean && this.meta.statistics.push({
                    title: "Score:",
                    body: data.mean
                }), data.rank && this.meta.statistics.push({
                    title: "Ranked:",
                    body: "#" + data.rank
                }), data.popularity && this.meta.statistics.push({
                    title: "Popularity:",
                    body: "#" + data.popularity
                }), data.num_list_users && this.meta.statistics.push({
                    title: "Members:",
                    body: data.num_list_users.toLocaleString()
                }), data.num_scoring_users && this.meta.statistics.push({
                    title: "Rated:",
                    body: data.num_scoring_users.toLocaleString()
                });
            }
            info(data) {
                if (data.media_type) {
                    const format = mediaTypeDefinition[data.media_type];
                    this.meta.info.push({
                        title: "Format:",
                        body: [ {
                            text: null != format ? format : data.media_type,
                            url: `https://myanimelist.net/top${this.type}.php?type=${data.media_type}`
                        } ]
                    });
                }
                if (data.num_episodes ? this.meta.info.push({
                    title: "Episodes:",
                    body: [ {
                        text: data.num_episodes
                    } ]
                }) : 0 === data.num_episodes && this.meta.info.push({
                    title: "Episodes:",
                    body: [ {
                        text: "Unknown"
                    } ]
                }), data.num_chapters ? this.meta.info.push({
                    title: "Chapters:",
                    body: [ {
                        text: data.num_chapters
                    } ]
                }) : 0 === data.num_chapters && this.meta.info.push({
                    title: "Chapters:",
                    body: [ {
                        text: "Unknown"
                    } ]
                }), data.num_volumes ? this.meta.info.push({
                    title: "Volumes:",
                    body: [ {
                        text: data.num_volumes
                    } ]
                }) : 0 === data.num_volumes && this.meta.info.push({
                    title: "Volumes:",
                    body: [ {
                        text: "Unknown"
                    } ]
                }), data.status) {
                    const format = airingStatusDefinition[data.status];
                    this.meta.info.push({
                        title: "Status:",
                        body: [ {
                            text: null != format ? format : data.status
                        } ]
                    });
                }
                if (data.start_date) {
                    let format = "";
                    data.start_date && (format += data.start_date + " "), format += "to ", data.end_date ? format += data.end_date : format += "?", 
                    this.meta.info.push({
                        title: "Aired:",
                        body: [ {
                            text: format
                        } ]
                    });
                }
                if (data.start_season) {
                    let format = "";
                    data.start_season.season && (format += data.start_season.season + " "), data.start_season.year && (format += data.start_season.year), 
                    this.meta.info.push({
                        title: "Premiered:",
                        body: [ {
                            url: `https://myanimelist.net/${this.type}/season/${data.start_season.year}/${data.start_season.season}`,
                            text: format
                        } ]
                    });
                }
                if (data.broadcast) {
                    let format = "";
                    data.broadcast.day_of_the_week && (format += data.broadcast.day_of_the_week + " "), 
                    data.broadcast.day_of_the_week && data.broadcast.start_time && (format += "at "), 
                    data.broadcast.start_time && (format += data.broadcast.start_time + " (JST)"), this.meta.info.push({
                        title: "Broadcast:",
                        body: [ {
                            text: format
                        } ]
                    });
                }
                if (data.studios) {
                    const studios = [];
                    data.studios.forEach((function(i, index) {
                        studios.push({
                            text: i.name,
                            url: "https://myanimelist.net/anime/producer/" + i.id
                        });
                    })), studios.length && this.meta.info.push({
                        title: "Studios:",
                        body: studios
                    });
                }
                if (data.authors) {
                    const authors = [];
                    data.authors.forEach((function(i, index) {
                        var _a, _b;
                        authors.push({
                            text: `${null !== (_a = i.node.last_name) && void 0 !== _a ? _a : ""}${i.node.last_name && i.node.first_name ? "," : ""} ${null !== (_b = i.node.first_name) && void 0 !== _b ? _b : ""}`,
                            url: "https://myanimelist.net/people/" + i.node.id,
                            subtext: i.role ? `(${i.role})` : ""
                        });
                    })), authors.length && this.meta.info.push({
                        title: "Authors:",
                        body: authors
                    });
                }
                if (data.source) {
                    const format = sourceDefinition[data.source];
                    this.meta.info.push({
                        title: "Source:",
                        body: [ {
                            text: null != format ? format : data.source
                        } ]
                    });
                }
                if (data.genres) {
                    const genres = [];
                    data.genres.forEach((i, index) => {
                        genres.push({
                            text: i.name,
                            url: `https://myanimelist.net/${this.type}/genre/${i.id}`
                        });
                    }), genres.length && this.meta.info.push({
                        title: "Genres:",
                        body: genres
                    });
                }
                if (data.average_episode_duration && this.meta.info.push({
                    title: "Episode Duration:",
                    body: [ {
                        text: Object(_utils_time__WEBPACK_IMPORTED_MODULE_3__.a)(1e3 * data.average_episode_duration)
                    } ]
                }), data.rating) {
                    const format = ratingDefinition[data.rating];
                    this.meta.info.push({
                        title: "Rating:",
                        body: [ {
                            text: null != format ? format : data.rating
                        } ]
                    });
                }
                if (data.serialization) {
                    const serialization = [];
                    data.serialization.forEach((function(i, index) {
                        serialization.push({
                            text: i.node.name,
                            url: "https://myanimelist.net/manga/magazine/" + i.node.id
                        });
                    })), serialization.length && this.meta.info.push({
                        title: "Serialization:",
                        body: serialization
                    });
                }
            }
            related(data) {
                const links = {};
                data.related_anime.length && data.related_anime.forEach(el => {
                    void 0 === links[el.relation_type] && (links[el.relation_type] = {
                        type: el.relation_type_formatted,
                        links: []
                    }), links[el.relation_type].links.push({
                        url: "https://myanimelist.net/anime/" + el.node.id,
                        title: el.node.title,
                        statusTag: ""
                    });
                }), data.related_manga.length && data.related_manga.forEach(el => {
                    void 0 === links[el.relation_type] && (links[el.relation_type] = {
                        type: el.relation_type_formatted,
                        links: []
                    }), links[el.relation_type].links.push({
                        url: "https://myanimelist.net/manga/" + el.node.id,
                        title: el.node.title,
                        statusTag: ""
                    });
                }), this.meta.related = Object.keys(links).map(key => links[key]);
            }
        }
    }).call(this, __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                if (super(url), this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_2__.b, this.logger = this.logger.m("Anilist"), 
                url.match(/anilist\.co\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.aniId = Number(utils.urlPart(url, 4)), this.malId = NaN, this;
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.malId = Number(utils.urlPart(url, 4)), this.aniId = NaN, this;
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.logger.log("Retrieve", this.type, this.aniId ? "Anilist: " + this.aniId : "MAL: " + this.malId);
                    const data = yield this.getData();
                    this.logger.log("Data", data), this.title(data), this.description(data), this.image(data), 
                    this.alternativeTitle(data), this.characters(data), this.statistics(data), this.info(data), 
                    this.related(data), this.logger.log("Res", this.meta);
                }));
            }
            getData() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let selectId = this.malId, selectQuery = "idMal";
                    Number.isNaN(this.malId) && (selectId = this.aniId, selectQuery = "id");
                    const query = `\n    query ($id: Int, $type: MediaType) {\n      Media (${selectQuery}: $id, type: $type) {\n        id\n        idMal\n        siteUrl\n        episodes\n        chapters\n        volumes\n        averageScore\n        synonyms\n        description(asHtml: true)\n        coverImage{\n          large\n        }\n        title {\n          userPreferred\n          romaji\n          english\n          native\n        }\n        characters (perPage: 6, sort: [ROLE, ID]) {\n            edges {\n                id\n                role\n                node {\n                    id\n                    siteUrl\n                    name {\n                        first\n                        last\n                    }\n                    image {\n                        large\n                    }\n                }\n            }\n        }\n        popularity\n        favourites\n        rankings {\n          id\n          rank\n          type\n          format\n          year\n          season\n          allTime\n          context\n        }\n        relations {\n            edges {\n                id\n                relationType (version: 2)\n                node {\n                    id\n                    siteUrl\n                    title {\n                        userPreferred\n                    }\n                }\n            }\n        }\n        format\n        episodes\n        duration\n        status\n        startDate {\n          year\n          month\n          day\n        }\n        endDate {\n          year\n          month\n          day\n        }\n        season\n        studios {\n            edges {\n                isMain\n                node {\n                    siteUrl\n                    id\n                    name\n                }\n            }\n        }\n        source(version: 2)\n        genres\n        externalLinks {\n          site\n          url\n        }\n      }\n    }\n    `, variables = {
                        id: selectId,
                        type: this.type.toUpperCase()
                    };
                    return this.apiCall(query, variables, !1);
                }));
            }
            title(data) {
                var _a, _b, _c;
                const title = null === (_c = null === (_b = null === (_a = null == data ? void 0 : data.data) || void 0 === _a ? void 0 : _a.Media) || void 0 === _b ? void 0 : _b.title) || void 0 === _c ? void 0 : _c.userPreferred;
                title && (this.meta.title = title);
            }
            description(data) {
                var _a, _b;
                const description = null === (_b = null === (_a = null == data ? void 0 : data.data) || void 0 === _a ? void 0 : _a.Media) || void 0 === _b ? void 0 : _b.description;
                description && (this.meta.description = description);
            }
            image(data) {
                var _a, _b, _c;
                const image = null === (_c = null === (_b = null === (_a = null == data ? void 0 : data.data) || void 0 === _a ? void 0 : _a.Media) || void 0 === _b ? void 0 : _b.coverImage) || void 0 === _c ? void 0 : _c.large;
                image && (this.meta.image = image);
            }
            alternativeTitle(data) {
                var _a, _b;
                const titles = null === (_b = null === (_a = null == data ? void 0 : data.data) || void 0 === _a ? void 0 : _a.Media) || void 0 === _b ? void 0 : _b.title;
                if (titles) for (const prop in titles) {
                    const el = data.data.Media.title[prop];
                    el !== this.meta.title && el && this.meta.alternativeTitle.push(el);
                }
            }
            characters(data) {
                var _a, _b, _c;
                const chars = null === (_c = null === (_b = null === (_a = null == data ? void 0 : data.data) || void 0 === _a ? void 0 : _a.Media) || void 0 === _b ? void 0 : _b.characters) || void 0 === _c ? void 0 : _c.edges;
                chars && chars.forEach(i => {
                    let name = "";
                    i.node.name.last && (name += i.node.name.last), i.node.name.first && i.node.name.last && (name += ", "), 
                    i.node.name.first && (name += i.node.name.first), this.meta.characters.push({
                        img: i.node.image.large,
                        name: name,
                        url: i.node.siteUrl
                    });
                });
            }
            statistics(data) {
                data.data.Media.averageScore && this.meta.statistics.push({
                    title: "Score:",
                    body: data.data.Media.averageScore
                }), data.data.Media.favourites && this.meta.statistics.push({
                    title: "Favourites:",
                    body: data.data.Media.favourites
                }), data.data.Media.popularity && this.meta.statistics.push({
                    title: "Popularity:",
                    body: data.data.Media.popularity
                }), data.data.Media.rankings.forEach(i => {
                    if (this.meta.statistics.length < 4 && i.allTime) {
                        let title = i.context.replace("all time", "").trim() + ":";
                        title = title.charAt(0).toUpperCase() + title.slice(1), this.meta.statistics.push({
                            title: title,
                            body: "#" + i.rank
                        });
                    }
                });
            }
            info(data) {
                if (data.data.Media.format) {
                    let format = data.data.Media.format.toLowerCase().replace("_", " ");
                    format = format.charAt(0).toUpperCase() + format.slice(1), this.meta.info.push({
                        title: "Format:",
                        body: [ {
                            text: format
                        } ]
                    });
                }
                if (data.data.Media.episodes && this.meta.info.push({
                    title: "Episodes:",
                    body: [ {
                        text: data.data.Media.episodes
                    } ]
                }), data.data.Media.duration && this.meta.info.push({
                    title: "Episode Duration:",
                    body: [ {
                        text: data.data.Media.duration + " mins"
                    } ]
                }), data.data.Media.status) {
                    let status = data.data.Media.status.toLowerCase().replace("_", " ");
                    status = status.charAt(0).toUpperCase() + status.slice(1), this.meta.info.push({
                        title: "Status:",
                        body: [ {
                            text: status
                        } ]
                    });
                }
                if (data.data.Media.startDate.year && this.meta.info.push({
                    title: "Start Date:",
                    body: [ {
                        text: `${data.data.Media.startDate.year}-${data.data.Media.startDate.month}-${data.data.Media.startDate.day}`
                    } ]
                }), data.data.Media.endDate.year && this.meta.info.push({
                    title: "End Date:",
                    body: [ {
                        text: `${data.data.Media.endDate.year}-${data.data.Media.endDate.month}-${data.data.Media.endDate.day}`
                    } ]
                }), data.data.Media.season) {
                    let season = data.data.Media.season.toLowerCase().replace("_", " ");
                    season = season.charAt(0).toUpperCase() + season.slice(1), data.data.Media.endDate.year && (season += " " + data.data.Media.endDate.year), 
                    this.meta.info.push({
                        title: "Season:",
                        body: [ {
                            text: season
                        } ]
                    });
                }
                const studios = [];
                if (data.data.Media.studios.edges.forEach((function(i, index) {
                    i.isMain && studios.push({
                        text: i.node.name,
                        url: i.node.siteUrl
                    });
                })), studios.length && this.meta.info.push({
                    title: "Studios:",
                    body: studios
                }), data.data.Media.source) {
                    let source = data.data.Media.source.toLowerCase().replace("_", " ");
                    source = source.charAt(0).toUpperCase() + source.slice(1), this.meta.info.push({
                        title: "Source:",
                        body: [ {
                            text: source
                        } ]
                    });
                }
                if (data.data.Media.genres) {
                    const gen = [];
                    data.data.Media.genres.forEach((function(i, index) {
                        gen.push({
                            text: i,
                            url: "https://anilist.co/search/anime?includedGenres=" + i
                        });
                    })), this.meta.info.push({
                        title: "Genres:",
                        body: gen
                    });
                }
                const external = [];
                data.data.Media.externalLinks.forEach((function(i, index) {
                    external.push({
                        text: i.site,
                        url: i.url
                    });
                })), external.length && this.meta.info.push({
                    title: "External Links:",
                    body: external
                });
            }
            related(data) {
                const links = {};
                data.data.Media.relations.edges.forEach(i => {
                    if (void 0 === links[i.relationType]) {
                        let title = i.relationType.toLowerCase().replace("_", " ");
                        title = title.charAt(0).toUpperCase() + title.slice(1), links[i.relationType] = {
                            type: title,
                            links: []
                        };
                    }
                    links[i.relationType].links.push({
                        url: i.node.siteUrl,
                        title: i.node.title.userPreferred,
                        statusTag: ""
                    });
                }), this.meta.related = Object.keys(links).map(key => links[key]);
            }
        }
    }).call(this, __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                if (super(url), this.kitsuId = NaN, this.apiCall = _helper__WEBPACK_IMPORTED_MODULE_2__.a, 
                this.malToKitsu = _helper__WEBPACK_IMPORTED_MODULE_2__.e, this.logger = this.logger.m("Kitsu"), 
                url.match(/kitsu\.io\/(anime|manga)\/.*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.kitsuSlug = utils.urlPart(url, 4), this.malId = NaN, this;
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) return this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", 
                this.malId = Number(utils.urlPart(url, 4)), this.kitsuSlug = "", this;
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            animeI() {
                return this.animeInfo.data;
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.logger.log("Retrieve", this.type, this.kitsuSlug ? "Kitsu: " + this.kitsuSlug : "MAL: " + this.malId), 
                    yield this.getData(), this.logger.log("Data", this.animeInfo), this.title(), this.description(), 
                    this.image(), this.alternativeTitle(), this.characters(), this.statistics(), this.info(), 
                    this.related(), this.logger.log("Res", this.meta);
                }));
            }
            getData() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (!this.kitsuSlug) {
                        const kitsuRes = yield this.malToKitsu(this.malId, this.type);
                        try {
                            if (this.kitsuId = kitsuRes.data[0].relationships.item.data.id, kitsuRes.included.forEach(el => {
                                el.id === this.kitsuId && (this.kitsuSlug = el.attributes.slug);
                            }), !this.kitsuSlug) throw "No slug";
                        } catch (e) {
                            throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.EntryNotFound, e.message);
                        }
                    }
                    return this.apiCall("GET", `https://kitsu.io/api/edge/${this.type}?filter[slug]=${this.kitsuSlug}&include=characters.character,mediaRelationships.destination,categories&fields[categories]=slug,title&nsfw=true`, {}, !0).then(res => {
                        try {
                            res.data = res.data[0], res.data.attributes.slug;
                        } catch (e) {
                            throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.EntryNotFound, e.message);
                        }
                        this.animeInfo = res;
                    });
                }));
            }
            title() {
                this.meta.title = _helper__WEBPACK_IMPORTED_MODULE_2__.c(this.animeI().attributes.titles, this.animeI().attributes.canonicalTitle);
            }
            description() {
                this.meta.description = `<span style="white-space: pre-line;">${this.animeI().attributes.synopsis.replace("â€”", " ")}</span>`;
            }
            image() {
                this.meta.image = this.animeI().attributes.posterImage.large;
            }
            alternativeTitle() {
                for (const prop in this.animeI().attributes.abbreviatedTitles) {
                    const el = this.animeI().attributes.abbreviatedTitles[prop];
                    el !== this.meta.title && el && this.meta.alternativeTitle.push(el);
                }
                for (const prop in this.animeI().attributes.titles) {
                    const el = this.animeI().attributes.titles[prop];
                    el !== this.meta.title && el && this.meta.alternativeTitle.push(el);
                }
            }
            characters() {
                this.animeInfo.included && this.animeInfo.included.length && this.animeInfo.included.forEach(i => {
                    if ("characters" === i.type && this.meta.characters.length < 10) {
                        const {name: name} = i.attributes;
                        this.meta.characters.push({
                            img: null !== i.attributes.image ? i.attributes.image.original : api.storage.assetUrl("questionmark.gif"),
                            name: name,
                            url: "https://myanimelist.net/character/" + i.attributes.malId
                        });
                    }
                });
            }
            statistics() {
                null !== this.animeI().attributes.averageRating && this.meta.statistics.push({
                    title: "Score:",
                    body: this.animeI().attributes.averageRating
                }), null !== this.animeI().attributes.ratingRank && this.meta.statistics.push({
                    title: "Ranked:",
                    body: "#" + this.animeI().attributes.ratingRank
                }), null !== this.animeI().attributes.popularityRank && this.meta.statistics.push({
                    title: "Popularity:",
                    body: "#" + this.animeI().attributes.popularityRank
                }), null !== this.animeI().attributes.userCount && this.meta.statistics.push({
                    title: "Members:",
                    body: this.animeI().attributes.userCount
                });
            }
            info() {
                if (void 0 !== this.animeI().attributes.subtype && null !== this.animeI().attributes.subtype) {
                    let format = this.animeI().attributes.subtype.toLowerCase().replace("_", " ");
                    format = format.charAt(0).toUpperCase() + format.slice(1), this.meta.info.push({
                        title: "Format:",
                        body: [ {
                            text: format
                        } ]
                    });
                }
                if (void 0 !== this.animeI().attributes.episodeCount && null !== this.animeI().attributes.episodeCount && this.meta.info.push({
                    title: "Episodes:",
                    body: [ {
                        text: this.animeI().attributes.episodeCount
                    } ]
                }), void 0 !== this.animeI().attributes.episodeLength && null !== this.animeI().attributes.episodeLength && this.meta.info.push({
                    title: "Episode Duration:",
                    body: [ {
                        text: this.animeI().attributes.episodeLength + " mins"
                    } ]
                }), void 0 !== this.animeI().attributes.status && null !== this.animeI().attributes.status) {
                    let status = this.animeI().attributes.status.toLowerCase().replace("_", " ");
                    status = status.charAt(0).toUpperCase() + status.slice(1), this.meta.info.push({
                        title: "Status:",
                        body: [ {
                            text: status
                        } ]
                    });
                }
                void 0 !== this.animeI().attributes.startDate && null !== this.animeI().attributes.startDate && this.meta.info.push({
                    title: "Start Date:",
                    body: [ {
                        text: this.animeI().attributes.startDate
                    } ]
                }), void 0 !== this.animeI().attributes.endDate && null !== this.animeI().attributes.endDate && this.meta.info.push({
                    title: "Start Date:",
                    body: [ {
                        text: this.animeI().attributes.endDate
                    } ]
                });
                const genres = [];
                this.animeInfo.included && this.animeInfo.included.length && this.animeInfo.included.forEach(i => {
                    "categories" === i.type && genres.length < 6 && genres.push({
                        text: i.attributes.title,
                        url: `https://kitsu.io/${this.type}?categories=${i.attributes.slug}`
                    });
                }), genres.length && this.meta.info.push({
                    title: "Genres:",
                    body: genres
                }), void 0 !== this.animeI().attributes.ageRating && null !== this.animeI().attributes.ageRating && this.meta.info.push({
                    title: "Rating:",
                    body: [ {
                        text: this.animeI().attributes.ageRating
                    } ]
                }), void 0 !== this.animeI().attributes.totalLength && null !== this.animeI().attributes.totalLength && this.meta.info.push({
                    title: "Total playtime:",
                    body: [ {
                        text: this.animeI().attributes.totalLength + " mins"
                    } ]
                });
            }
            related() {
                const links = {}, an = [];
                this.animeInfo.included && this.animeInfo.included.length && (this.animeInfo.included.forEach((function(i) {
                    "manga" !== i.type && "anime" !== i.type || (an[i.id] = {
                        url: `https://kitsu.io/${i.type}/${i.attributes.slug}`,
                        title: _helper__WEBPACK_IMPORTED_MODULE_2__.c(i.attributes.titles, i.attributes.canonicalTitle),
                        statusTag: ""
                    });
                })), this.animeInfo.included.forEach((function(i) {
                    if ("mediaRelationships" === i.type) {
                        if (void 0 === links[i.attributes.role]) {
                            let title = i.attributes.role.toLowerCase().replace("_", " ");
                            title = title.charAt(0).toUpperCase() + title.slice(1), links[i.attributes.role] = {
                                type: title,
                                links: []
                            };
                        }
                        const tempEl = an[i.relationships.destination.data.id];
                        links[i.attributes.role].links.push(tempEl);
                    }
                }))), this.meta.related = Object.keys(links).map(key => links[key]);
            }
        }
    }).call(this, __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MetaOverview;
        }));
        var _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5), _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        class MetaOverview extends _metaOverviewAbstract__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(url) {
                if (super(url), this.call = _helper__WEBPACK_IMPORTED_MODULE_2__.a, this.errorHandling = _helper__WEBPACK_IMPORTED_MODULE_2__.c, 
                this.logger = this.logger.m("Simkl"), url.match(/simkl\.com\/(anime|manga)\/\d*/i)) {
                    if (this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", this.simklId = parseInt(utils.urlPart(url, 4)), 
                    this.malId = NaN, "manga" === this.type) throw "Simkl has no manga support";
                    return this;
                }
                if (url.match(/myanimelist\.net\/(anime|manga)\/\d*/i)) {
                    if (this.type = "anime" === utils.urlPart(url, 3) ? "anime" : "manga", this.malId = Number(utils.urlPart(url, 4)), 
                    this.simklId = NaN, "manga" === this.type) throw "Simkl has no manga support";
                    return this;
                }
                throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.UrlNotSuported, "Url not supported");
            }
            _init() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.logger.log("Retrieve", this.type, this.simklId ? "Simkl: " + this.simklId : "MAL: " + this.malId);
                    const data = yield this.getData();
                    this.logger.log("Data", data), this.title(data), this.description(data), this.image(data), 
                    this.alternativeTitle(data), this.statistics(data), this.info(data), this.related(data), 
                    this.logger.log("Res", this.meta);
                }));
            }
            getData() {
                return __awaiter(this, void 0, void 0, (function*() {
                    let de;
                    if (de = Number.isNaN(this.malId) ? {
                        simkl: this.simklId
                    } : {
                        mal: this.malId
                    }, Number.isNaN(this.simklId)) {
                        const el = yield this.call("https://api.simkl.com/search/id", de, !0);
                        if (!el) throw this.errorObj(_definitions__WEBPACK_IMPORTED_MODULE_1__.a.EntryNotFound, "simklId");
                        this.simklId = el[0].ids.simkl;
                    }
                    return this.call("https://api.simkl.com/anime/" + this.simklId, {
                        extended: "full"
                    }, !0);
                }));
            }
            title(data) {
                const {title: title} = data;
                title && (this.meta.title = title);
            }
            description(data) {
                const description = data.overview;
                description && (this.meta.description = description);
            }
            image(data) {
                const image = data.poster;
                image && (this.meta.image = `https://simkl.in/posters/${image}_ca.jpg`);
            }
            alternativeTitle(data) {
                void 0 !== data.en_title && data.en_title && this.meta.alternativeTitle.push(data.en_title);
            }
            statistics(data) {
                data.ratings.simkl.rating && this.meta.statistics.push({
                    title: "Score:",
                    body: data.ratings.simkl.rating
                }), data.ratings.mal && data.ratings.mal.rating && this.meta.statistics.push({
                    title: "MAL Score:",
                    body: data.ratings.mal.rating
                }), data.rank && data.rank && this.meta.statistics.push({
                    title: "Ranked:",
                    body: "#" + data.rank
                }), data.ratings.simkl.votes && this.meta.statistics.push({
                    title: "Votes:",
                    body: data.ratings.simkl.votes
                });
            }
            info(data) {
                data.anime_type && data.anime_type && this.meta.info.push({
                    title: "Type:",
                    body: [ {
                        text: data.anime_type
                    } ]
                }), data.total_episodes && data.total_episodes && this.meta.info.push({
                    title: "Episodes:",
                    body: [ {
                        text: data.total_episodes
                    } ]
                }), data.status && data.status && this.meta.info.push({
                    title: "Status:",
                    body: [ {
                        text: data.status
                    } ]
                }), data.year && data.year && this.meta.info.push({
                    title: "Year:",
                    body: [ {
                        text: data.year
                    } ]
                }), data.airs && data.airs && this.meta.info.push({
                    title: "Broadcast:",
                    body: [ {
                        text: `${data.airs.day} at ${data.airs.time}`
                    } ]
                }), data.network && data.network && this.meta.info.push({
                    title: "Licensor:",
                    body: [ {
                        text: data.network
                    } ]
                });
                const genres = [];
                data.genres.forEach(i => {
                    genres.length < 6 && genres.push({
                        text: i,
                        url: `https://simkl.com/${this.type}/${i.toLowerCase()}`
                    });
                }), genres.length && this.meta.info.push({
                    title: "Genres:",
                    body: genres
                }), data.runtime && data.runtime && this.meta.info.push({
                    title: "Duration:",
                    body: [ {
                        text: data.runtime + "mins"
                    } ]
                }), data.certification && data.certification && this.meta.info.push({
                    title: "Rating:",
                    body: [ {
                        text: data.certification
                    } ]
                });
            }
            related(data) {
                const links = {};
                data.relations && (data.relations.forEach(i => {
                    if (!links[i.relation_type]) {
                        let title = i.relation_type.toLowerCase().replace("_", " ");
                        title = title.charAt(0).toUpperCase() + title.slice(1), links[i.relation_type] = {
                            type: title,
                            links: []
                        };
                    }
                    links[i.relation_type].links.push({
                        url: `https://simkl.com/anime/${i.ids.simkl}/${i.ids.slug}`,
                        title: i.title,
                        statusTag: ""
                    });
                }), this.meta.related = Object.keys(links).map(key => links[key]));
            }
            jsonParse(response) {
                if ("" === response.responseText) throw {
                    code: 444,
                    message: "No Response"
                };
                try {
                    return JSON.parse(response.responseText);
                } catch (e) {
                    throw {
                        code: 406,
                        message: "Not Acceptable",
                        error: e
                    };
                }
            }
        }
    }).call(this, __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return nineAnime;
        }));
        const nineAnime = {
            name: "9anime",
            domain: "https://9anime.to",
            database: "9anime",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => j.$("h1.title").text(),
                getIdentifier: url => ((url = utils.urlPart(url, 4)).indexOf(".") > -1 && (url = url.split(".")[1]), 
                url),
                getOverviewUrl: url => utils.absoluteLink(j.$("ul.episodes > li > a").first().attr("href"), nineAnime.domain),
                getEpisode: url => parseInt(j.$("ul.episodes > li > a.active").attr("data-base")),
                nextEpUrl(url) {
                    const nextEp = j.$("ul.episodes > li > a.active").parent("li").next().find("a").attr("href");
                    return nextEp ? utils.absoluteLink(nextEp, nineAnime.domain) : nextEp;
                },
                uiSelector(selector) {
                    j.$("#episodes").after(j.html(`<section>${selector}</section>`));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector(selector) {},
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.episodes > li > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), nineAnime.domain),
                    elementEp: selector => Number(selector.attr("data-base"))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(321).toString()), utils.waitUntilTrue((function() {
                    return j.$("ul.episodes > li").length;
                }), (function() {
                    con.info("Start check"), page.handlePage(), utils.urlChangeDetect((function() {
                        con.info("Check"), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Crunchyroll;
        }));
        var _beta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
        const Crunchyroll = {
            name: "Crunchyroll",
            domain: "https://www.crunchyroll.com",
            languages: [ "English", "Spanish", "Portuguese", "French", "German", "Arabic", "Italian", "Russian" ],
            type: "anime",
            isSyncPage: url => !(void 0 === url.split("/")[4] || !j.$("#showmedia_video").length),
            sync: {
                getTitle(url) {
                    var _a;
                    return null !== (_a = j.$('link[rel="index"]').first().attr("title")) && void 0 !== _a ? _a : "";
                },
                getIdentifier: url => Crunchyroll.sync.getTitle(url),
                getOverviewUrl(url) {
                    var _a;
                    return utils.absoluteLink(null !== (_a = j.$('link[rel="index"]').first().attr("href")) && void 0 !== _a ? _a : "", Crunchyroll.domain);
                },
                getEpisode: url => function(url, _episodeText) {
                    let episodePart = "";
                    if (/\d+\.\d+/.test(_episodeText)) {
                        const matches = _episodeText.match(/\d+\.\d+/);
                        matches && 0 !== matches.length && (episodePart = "episode" + matches[0]);
                    } else episodePart = utils.urlPart(function(url) {
                        const langslug = j.$("#home_link, #logo_beta a").first().attr("href");
                        if ("/" === langslug) return url;
                        return url.replace(langslug, "");
                    }(url), 4) || "";
                    if (!episodePart) return NaN;
                    const episodeTextMatches = episodePart.match(/([e,E][p,P][i,I]?[s,S]?[o,O]?[d,D]?[e,E]?|[f,F][o,O][l,L][g,G]?[e,E])\D?\d+/);
                    if (!episodeTextMatches || 0 === episodeTextMatches.length) return NaN;
                    const episodeNumberMatches = episodeTextMatches[0].match(/\d+/);
                    return episodeNumberMatches && 0 !== episodeNumberMatches.length ? Number(episodeNumberMatches[0]) : NaN;
                }(url, j.$("h1.ellipsis").text().replace(j.$("h1.ellipsis > a").text(), "").trim()),
                nextEpUrl(url) {
                    const nextEp = j.$(".collection-carousel-media-link-current").parent().next().find(".link").attr("href");
                    return nextEp ? utils.absoluteLink(nextEp, Crunchyroll.domain) : nextEp;
                }
            },
            init(page) {
                j.$(document).ready((function() {
                    if ($("#content").length) return Crunchyroll.database = _beta__WEBPACK_IMPORTED_MODULE_0__.a.database, 
                    Crunchyroll.isSyncPage = _beta__WEBPACK_IMPORTED_MODULE_0__.a.isSyncPage, Crunchyroll.isOverviewPage = _beta__WEBPACK_IMPORTED_MODULE_0__.a.isOverviewPage, 
                    Crunchyroll.sync = _beta__WEBPACK_IMPORTED_MODULE_0__.a.sync, Crunchyroll.overview = _beta__WEBPACK_IMPORTED_MODULE_0__.a.overview, 
                    Crunchyroll.name = _beta__WEBPACK_IMPORTED_MODULE_0__.a.name, void _beta__WEBPACK_IMPORTED_MODULE_0__.a.init(page);
                    api.storage.addStyle(__webpack_require__(325).toString()), page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Mangadex;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const {asyncWaitUntilTrue: awaitUi, reset: resetAwaitUi} = utils.getAsyncWaitUntilTrue(() => j.$(".title__desktop").length), mangaData = {
            id: "",
            title: "",
            coverFilename: "",
            links: {
                mal: "",
                kt: "",
                al: ""
            }
        }, chapterData = {
            id: "",
            chapter: "",
            volume: "",
            translatedLanguage: ""
        }, Mangadex = {
            name: "Mangadex",
            domain: "https://www.mangadex.org",
            database: "Mangadex",
            languages: [ "Many" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[3] && "chapter" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            isOverviewPage: url => void 0 !== url.split("/")[3] && "title" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            getImage() {
                return __awaiter(this, void 0, void 0, (function*() {
                    if (mangaData.coverFilename) return `https://uploads.mangadex.org/covers/${mangaData.id}/${mangaData.coverFilename}`;
                }));
            },
            sync: {
                getTitle: url => mangaData.title,
                getIdentifier: url => mangaData.id,
                getOverviewUrl: url => utils.absoluteLink("/title/" + mangaData.id, Mangadex.domain),
                getEpisode: url => parseInt(chapterData.chapter) || 1,
                getVolume: url => parseInt(chapterData.volume),
                getMalUrl(provider) {
                    var _a, _b, _c;
                    return (null === (_a = mangaData.links) || void 0 === _a ? void 0 : _a.mal) ? "https://myanimelist.net/manga/" + mangaData.links.mal : "ANILIST" === provider && (null === (_b = mangaData.links) || void 0 === _b ? void 0 : _b.al) ? "https://anilist.co/manga/" + mangaData.links.al : !("KITSU" !== provider || !(null === (_c = mangaData.links) || void 0 === _c ? void 0 : _c.kt)) && "https://kitsu.io/manga/" + mangaData.links.kt;
                }
            },
            overview: {
                getTitle: url => mangaData.title,
                getIdentifier: url => mangaData.id,
                uiSelector(selector) {
                    j.$("div.title__desktop").first().after(j.html(selector));
                },
                getMalUrl: provider => Mangadex.sync.getMalUrl(provider)
            },
            init(page) {
                function check() {
                    var _a, _b, _c, _d, _e;
                    return __awaiter(this, void 0, void 0, (function*() {
                        if (resetAwaitUi(), !Mangadex.isSyncPage(window.location.href) && !Mangadex.isOverviewPage(window.location.href)) return;
                        let manga = {};
                        if (Mangadex.isSyncPage(window.location.href)) {
                            const chapterResponse = yield request(`chapter/${utils.urlPart(window.location.href, 4)}?includes[]=manga`), chapter = JSON.parse(chapterResponse.responseText);
                            chapterData.chapter = chapter.data.attributes.chapter, chapterData.volume = chapter.data.attributes.volume, 
                            chapterData.translatedLanguage = chapter.data.attributes.translatedLanguage, manga.data = chapter.relationships.find(relation => "manga" === relation.type);
                        }
                        if (Mangadex.isOverviewPage(window.location.href)) {
                            const id = utils.urlPart(window.location.href, 4);
                            if ("random" === id.toLowerCase()) throw "The random page is not supported";
                            const mangaResponse = yield request(`manga/${id}?includes[]=cover_art`);
                            manga = JSON.parse(mangaResponse.responseText), yield awaitUi();
                        }
                        mangaData.id = manga.data.id;
                        const titleData = manga.data.attributes.title;
                        mangaData.title = null !== (_b = null !== (_a = titleData.en) && void 0 !== _a ? _a : titleData[manga.data.attributes.originalLanguage]) && void 0 !== _b ? _b : titleData[Object.keys(titleData)[0]], 
                        mangaData.links = manga.data.attributes.links, mangaData.coverFilename = null === (_e = null === (_d = null === (_c = manga.relationships) || void 0 === _c ? void 0 : _c.find(relation => "cover_art" === relation.type)) || void 0 === _d ? void 0 : _d.attributes) || void 0 === _e ? void 0 : _e.fileName, 
                        page.handlePage();
                    }));
                }
                api.storage.addStyle(__webpack_require__(327).toString()), utils.changeDetect(() => {
                    page.reset(), check();
                }, () => "chapter" === utils.urlPart(window.location.href, 3).toLowerCase() ? `${utils.urlPart(window.location.href, 3)}/${utils.urlPart(window.location.href, 4)}` : utils.urlStrip(window.location.href)), 
                check();
            }
        };
        function request(path) {
            return api.request.xhr("GET", "https://api.mangadex.org/" + path);
        }
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Gogoanime;
        }));
        const Gogoanime = {
            name: "Gogoanime",
            domain: [ "https://gogoanime.tv", "https://gogoanimes.co", "https://animego.to" ],
            database: "Gogoanime",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "category" !== utils.urlPart(url, 3),
            sync: {
                getTitle: url => j.$(".anime-info a").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 3).split("-episode")[0],
                getOverviewUrl: url => `${url.split("/").slice(0, 3).join("/")}/category/${Gogoanime.sync.getIdentifier(url)}`,
                getEpisode: url => Number(utils.urlPart(url, 3).split("episode-")[1]),
                nextEpUrl(url) {
                    const href = j.$(".anime_video_body_episodes_r a").last().attr("href");
                    return void 0 !== href ? Gogoanime.domain + href : "";
                }
            },
            overview: {
                getTitle: url => j.$(".anime_info_body_bg > h1").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".anime_info_body").first().prepend(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#episode_related a"),
                    elementUrl(selector) {
                        const anchorHref = selector.attr("href");
                        return anchorHref ? utils.absoluteLink(anchorHref.replace(/^ /, ""), Gogoanime.domain) : "";
                    },
                    elementEp(selector) {
                        const url = Gogoanime.overview.list.elementUrl(selector);
                        return Gogoanime.sync.getEpisode(url);
                    },
                    paginationNext() {
                        let next = !1, nextReturn = !1;
                        return j.$(j.$("#episode_page a").get().reverse()).each((function(index, el) {
                            if (next && !nextReturn) return el.click(), void (nextReturn = !0);
                            j.$(el).hasClass("active") && (next = !0);
                        })), nextReturn;
                    }
                }
            },
            init(page) {
                function start() {
                    Gogoanime.domain = `${window.location.protocol}//${window.location.hostname}`, page.handlePage(), 
                    j.$("#episode_page").click((function() {
                        setTimeout((function() {
                            page.handleList();
                        }), 500);
                    }));
                }
                api.storage.addStyle(__webpack_require__(329).toString()), Gogoanime.isSyncPage(page.url) ? j.$(document).ready((function() {
                    start();
                })) : (con.log("noSync"), utils.waitUntilTrue((function() {
                    return j.$("#episode_related").length;
                }), (function() {
                    start();
                })));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Branitube;
        }));
        const Branitube = {
            name: "Branitube",
            domain: "https://www.branitube.net",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => "video" === url.split("/")[3],
            sync: {
                getTitle: url => "anime" !== getType() ? `${j.$(".nomeAnime").text()} ${getType()}` : j.$(".nomeAnime").text(),
                getIdentifier: url => `${j.$(".nomeAnime").data("anid")}?${getType().replace(/\s/gm, "")}`,
                getOverviewUrl(url) {
                    const tempUrl = Branitube.domain + (j.$("div.buttonEpisodes > a").attr("href") || "");
                    return "anime" === getType() ? tempUrl : "ova" === getType() ? tempUrl + "/ovas" : "special" === getType() ? tempUrl + "/especiais" : tempUrl + "/filmes";
                },
                getEpisode: url => -1 === getType().indexOf("movie") ? Number(j.$(".epInfo").text().replace(/\D+/g, "")) : 1,
                nextEpUrl: url => -1 === getType().indexOf("movie") && j.$(".cplPl").attr("data-npl") && j.$(".cplPl").attr("data-cpl") && j.$(".cplPl").attr("data-npltype") && j.$(".cplPl").attr("data-cpl") === j.$(".cplPl").attr("data-npltype") ? `${Branitube.domain}/video/${j.$(".cplPl").attr("data-npl")}/${url.split("/")[5]}` : "",
                getMalUrl(provider) {
                    let malid;
                    return "anime" === getType() ? (malid = j.$(".nomeAnime").attr("data-anmalid"), 
                    malid && "0" !== malid || (malid = j.$(".epInfo").attr("data-epmalid"))) : malid = j.$(".epInfo").attr("data-epmalid"), 
                    !(!malid || "0" === malid) && "https://myanimelist.net/anime/" + malid;
                }
            },
            overview: {
                getTitle: url => "anime" !== getType() ? `${j.$("div.animeInfos > ul > li.largeSize").text()} ${getType()}` : j.$("div.animeInfos > ul > li.largeSize").text(),
                getIdentifier: url => `${url.split("/")[4]}?${getType()}`,
                uiSelector(selector) {
                    j.$("div.areaEpsList").first().prepend(j.html(`<div class="animeResult" style="margin:8px;"> ${selector}</div>`));
                },
                getMalUrl(provider) {
                    let malid;
                    return "anime" === getType() && (malid = j.$("div.animeInfos > ul > li.largeSize").attr("data-malid")), 
                    !(!malid || "0" === malid) && "https://myanimelist.net/anime/" + malid;
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".areaEpsList > .getTotalShowingEp > .item-ep > div.area-ep"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Branitube.domain),
                    elementEp: selector => utils.getBaseText(selector.find("div.infos-bottom > div.ep-info > div.anime-content").first()).replace(/\D+/g, "")
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(331).toString()), j.$(document).ready((function() {
                    void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && "filmes" !== page.url.split("/")[6] && "0" !== j.$("div.areaTypesList.no-padding > ul > li > a.active > span.totalEps").text().replace(/\D+/g, "") && page.handlePage();
                }));
            }
        };
        function getType() {
            let epInfo;
            return epInfo = "video" === window.location.href.split("/")[3] ? j.$(".epInfo").text().toLowerCase() : j.$("div.areaTypesList.no-padding > ul > li > a.active").text().toLowerCase(), 
            -1 !== epInfo.indexOf("ova") ? "ova" : -1 !== epInfo.indexOf("especial") || -1 !== epInfo.indexOf("especiais") ? "special" : -1 !== epInfo.indexOf("filme") ? "movie " + epInfo.replace(/\D+/g, "").replace(/^0+/gm, "") : "anime";
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TurkAnime;
        }));
        const TurkAnime = {
            name: "TurkAnime",
            domain: "https://www.turkanime.net",
            languages: [ "Turkish" ],
            type: "anime",
            isSyncPage: url => "video" === url.split("/")[3],
            sync: {
                getTitle: () => j.$(".breadcrumb a").first().text().trim(),
                getIdentifier: url => TurkAnime.overview.getIdentifier(TurkAnime.sync.getOverviewUrl(url)),
                getOverviewUrl: () => utils.absoluteLink(j.$(".breadcrumb a").first().attr("href"), TurkAnime.domain),
                getEpisode(episodeURL) {
                    const animeNameSlug = TurkAnime.overview.getIdentifier(TurkAnime.isSyncPage(window.location.href) ? TurkAnime.sync.getOverviewUrl("") : window.location.href), episodeNumberMatches = TurkAnime.overview.getIdentifier(episodeURL).replace(animeNameSlug + "-", "").match(/^(?<episodeNumber>\d+)-bolum(?:-final)?$/i);
                    return (null == episodeNumberMatches ? void 0 : episodeNumberMatches.groups) ? Number(episodeNumberMatches.groups.episodeNumber) : NaN;
                },
                nextEpUrl() {
                    const href = j.$("div.panel-footer a[href^='video']:nth-child(2)").attr("href");
                    return href ? utils.absoluteLink(href, TurkAnime.domain) : "";
                }
            },
            overview: {
                getTitle: () => j.$("#detayPaylas .panel-title").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("#detayPaylas .panel-body").first().prepend(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".list.menum > li"),
                    elementUrl(selector) {
                        const anchorHref = selector.find("a").last().attr("href");
                        return anchorHref ? utils.absoluteLink(anchorHref.replace(/^\/\//, "https://"), TurkAnime.domain) : "";
                    },
                    elementEp(selector) {
                        const episodeURL = TurkAnime.overview.list.elementUrl(selector);
                        return TurkAnime.sync.getEpisode(episodeURL);
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(333).toString()), j.$(() => {
                    utils.waitUntilTrue(() => document.querySelector(".list.menum"), () => page.handlePage());
                });
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Twistmoe;
        }));
        const Twistmoe = {
            name: "Twistmoe",
            domain: "https://twist.moe",
            database: "Twistmoe",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => j.$(".series-title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => `${Twistmoe.domain}/a/${Twistmoe.sync.getIdentifier(url)}/1`,
                getEpisode(url) {
                    const urlPart5 = utils.urlPart(url, 5);
                    return urlPart5 ? parseInt(urlPart5) : NaN;
                },
                nextEpUrl: url => utils.absoluteLink(j.$(".episode-list .current").first().parent().next().find("a").attr("href"), Twistmoe.domain),
                uiSelector(selector) {
                    j.$(".information").first().after(j.html(selector));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector: selector => "",
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episode-list li"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Twistmoe.domain),
                    elementEp: selector => Twistmoe.sync.getEpisode(Twistmoe.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                const start = () => {
                    if (!$(".information .series-title").text().trim()) return;
                    utils.urlPart(page.url, 3) ? page.handlePage() : con.log("Not an anime page!");
                };
                api.storage.addStyle(__webpack_require__(335).toString()), j.$(document).ready((function() {
                    start(), utils.changeDetect(() => {
                        page.reset(), start();
                    }, () => $(".information").text());
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Emby;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        let item;
        function getApiKey() {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.get("emby_Api_Key");
            }));
        }
        function setApiKey(key) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set("emby_Api_Key", key);
            }));
        }
        function getBase() {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.get("emby_Base");
            }));
        }
        function setBase(key) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set("emby_Base", key);
            }));
        }
        function checkApi(page) {
            return __awaiter(this, void 0, void 0, (function*() {
                const videoEl = $("video");
                if (videoEl.length) {
                    $("html").addClass("miniMAL-hide");
                    const url = videoEl.attr("src");
                    con.log(url);
                    let itemId = "", apiKey = "", apiBase = "";
                    url && (/blob:/i.test(url) ? (apiBase = yield getBase(), itemId = yield function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            return new Promise((resolve, reject) => {
                                setTimeout(() => {
                                    resolve();
                                }, 1e4);
                            }).then(() => apiCall("/Sessions").then(response => {
                                con.error(response);
                                const data = JSON.parse(response.responseText);
                                con.log(data);
                                for (let i = 0; i < data.length; i++) {
                                    const sess = data[i];
                                    if (void 0 !== sess.NowPlayingItem) return con.log(sess.NowPlayingItem), sess.NowPlayingItem.Id;
                                }
                                return "";
                            }));
                        }));
                    }(), apiKey = yield getApiKey()) : (apiBase = url.split("/").splice(0, 4).join("/"), 
                    itemId = utils.urlPart(url, 5), apiKey = yield getApiKey(), setBase(apiBase)));
                    let reqUrl = `${apiBase}/Items?ids=${itemId}&api_key=${apiKey}`;
                    con.log("reqUrl", reqUrl, "base", apiBase, "apiKey", apiKey), api.request.xhr("GET", reqUrl).then(response => {
                        const data = JSON.parse(response.responseText);
                        return item = data.Items[0], reqUrl = `${apiBase}/Genres?Ids=${item.SeriesId}&api_key=${apiKey}`, 
                        con.log(data), api.request.xhr("GET", reqUrl);
                    }).then(response => {
                        const genres = JSON.parse(response.responseText);
                        con.log("genres", genres);
                        for (let i = 0; i < genres.Items.length; i++) {
                            if ("Anime" === genres.Items[i].Name) {
                                con.info("Anime detected"), page.url = `${window.location.origin}/#!/itemdetails.html?id=${itemId}`, 
                                page.handlePage(page.url), $("html").removeClass("miniMAL-hide");
                                break;
                            }
                        }
                    });
                }
            }));
        }
        function urlChange(page) {
            return __awaiter(this, void 0, void 0, (function*() {
                if ($("html").addClass("miniMAL-hide"), -1 !== window.location.href.indexOf("id=")) {
                    let reqUrl = "/Items?ids=" + utils.urlParam(window.location.href, "id");
                    apiCall(reqUrl).then(response => {
                        const data = JSON.parse(response.responseText);
                        switch (data.Items[0].Type) {
                          case "Season":
                            con.log("Season", data), item = data.Items[0], reqUrl = "/Genres?Ids=" + item.SeriesId, 
                            apiCall(reqUrl).then(response2 => {
                                const genres = JSON.parse(response2.responseText);
                                con.log("genres", genres);
                                for (let i = 0; i < genres.Items.length; i++) {
                                    if ("Anime" === genres.Items[i].Name) {
                                        con.info("Anime detected"), page.handlePage(), $("html").removeClass("miniMAL-hide");
                                        break;
                                    }
                                }
                            });
                            break;

                          case "Series":
                            con.log("Series", data);
                            break;

                          default:
                            con.log("Not recognized", data);
                        }
                    });
                }
            }));
        }
        function testApi(retry = 0) {
            return __awaiter(this, void 0, void 0, (function*() {
                let base = yield getBase();
                return void 0 !== base && "" !== base || (con.info("No base"), base = yield function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        return new Promise((resolve, reject) => {
                            utils.waitUntilTrue((function() {
                                return j.$("*[data-url]").length || j.$(".view:not(.hide) .cardImageContainer").first().css("background-image") && "none" !== j.$(".view:not(.hide) .cardImageContainer").first().css("background-image");
                            }), (function() {
                                let elementUrl = j.$("*[data-url]").first().attr("data-url") || "";
                                elementUrl || (elementUrl = j.$(".view:not(.hide) .cardImageContainer").first().css("background-image").replace('url("', "").replace('")', ""));
                                const base = elementUrl.split("/").splice(0, 4).join("/");
                                con.log("Base Found", base), resolve(base);
                            }));
                        });
                    }));
                }()), setBase(base), apiCall("/System/Info", null, base).then(response => __awaiter(this, void 0, void 0, (function*() {
                    if (200 !== response.status) {
                        if (con.error("Not Authenticated"), setBase(""), retry < 1) try {
                            const apiC = yield function() {
                                return __awaiter(this, void 0, void 0, (function*() {
                                    return new Promise((resolve, reject) => {
                                        proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                                            const apiClient = proxy.getCaptureVariable("ApiClient");
                                            if (con.m("apiClient").log(apiClient), apiClient && apiClient._serverInfo && apiClient._serverInfo.RemoteAddress && apiClient._serverInfo.AccessToken) {
                                                const base = yield getBase();
                                                return void 0 !== base && "" !== base || setBase(apiClient._serverInfo.RemoteAddress + "/emby"), 
                                                setApiKey(apiClient._serverInfo.AccessToken), void resolve(!0);
                                            }
                                            reject();
                                        })));
                                    });
                                }));
                            }();
                            if (retry++, apiC) return testApi(retry);
                        } catch (e) {
                            con.error("Could not get ApiClient", e);
                        }
                        throw "Not Authenticated [Emby]";
                    }
                    return !0;
                })));
            }));
        }
        function apiCall(url, apiKey = null, base = null) {
            return __awaiter(this, void 0, void 0, (function*() {
                let pre;
                return null === apiKey && (apiKey = yield getApiKey()), null === base && (base = yield getBase()), 
                pre = -1 !== url.indexOf("?") ? "&" : "?", url = `${base + url + pre}api_key=${apiKey}`, 
                con.log("Api Call", url), api.request.xhr("GET", url);
            }));
        }
        proxy.addCaptureVariable("ApiClient", '\n    if (window.hasOwnProperty("ApiClient")) {\n      return ApiClient;\n    } else {\n      return undefined;\n    }\n  ');
        const Emby = {
            name: "Emby",
            domain: "http://app.emby.media",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => "Episode" === item.Type,
            sync: {
                getTitle: url => item.SeriesName + (item.ParentIndexNumber > 1 ? " Season " + item.ParentIndexNumber : ""),
                getIdentifier: url => void 0 !== item.SeasonId ? item.SeasonId : void 0 !== item.SeriesId ? item.SeriesId : item.Id,
                getOverviewUrl: url => `${Emby.domain}/#!/itemdetails.html?id=${Emby.sync.getIdentifier(url)}`,
                getEpisode: url => item.IndexNumber
            },
            overview: {
                getTitle: url => item.SeriesName + (item.IndexNumber > 1 ? " Season " + item.IndexNumber : ""),
                getIdentifier: url => item.Id,
                uiSelector(selector) {
                    j.$(".page:not(.hide) .nameContainer").first().append(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(337).toString()), testApi().catch(() => (con.info("Not Authenticated"), 
                function askForApiKey() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        return new Promise((resolve, reject) => {
                            const msg = utils.flashm(`<p>${api.storage.lang("Emby_Authenticate")}</p>\n      <p><input id="MS-ApiKey" type="text" placeholder="Please enter the Api Key here" style="width: 100%;"></p>\n      <div style="display: flex; justify-content: space-around;">\n        <button class="Yes" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px; cursor:pointer;">OK</button>\n        <button class="Cancel" style="background-color: transparent; border: none; color: rgb(255,64,129);margin-top: 10px; cursor:pointer;">CANCEL</button>\n      </div>\n      `, {
                                position: "bottom",
                                permanent: !0,
                                type: "getApi"
                            });
                            msg.find(".Yes").click((function(evt) {
                                const api = j.$("#MS-ApiKey").val();
                                con.info("api", api), setApiKey(api), j.$(evt.target).parentsUntil(".flash").remove(), 
                                testApi().then(() => {
                                    resolve(!0);
                                }).catch(() => __awaiter(this, void 0, void 0, (function*() {
                                    utils.flashm("Could not Authenticate"), yield askForApiKey(), resolve(!0);
                                })));
                            })), msg.find(".Cancel").click((function(evt) {
                                j.$(evt.target).parentsUntil(".flash").remove(), reject();
                            }));
                        });
                    }));
                }())).then(() => {
                    con.info("Authenticated"), utils.changeDetect(() => {
                        page.reset(), checkApi(page);
                    }, () => {
                        const src = $("video").first().attr("src");
                        return void 0 === src ? "NaN" : src;
                    }), utils.urlChangeDetect((function() {
                        -1 === window.location.href.indexOf("video") && -1 === window.location.href.indexOf("#dlg") && (page.reset(), 
                        urlChange(page));
                    })), j.$(document).ready((function() {
                        utils.waitUntilTrue((function() {
                            return j.$(".page").length;
                        }), (function() {
                            urlChange(page);
                        }));
                    })), document.addEventListener("fullscreenchange", (function() {
                        window.fullScreen || window.innerWidth === window.screen.width && window.innerHeight === window.screen.height ? $("html").addClass("miniMAL-Fullscreen") : $("html").removeClass("miniMAL-Fullscreen");
                    }));
                });
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, con, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Plex;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let item;
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        proxy.addCaptureVariable("auth", '\n    if (window.hasOwnProperty("localStorage")) {\n      return {\n        apiKey: window.localStorage.myPlexAccessToken,\n        users: window.localStorage.users\n      }\n    } else {\n      return undefined;\n    }\n  ');
        const auth = {
            apiKey: null,
            serverApiKey: null,
            base: null
        };
        let loadInterval;
        function urlChange(page) {
            return __awaiter(this, void 0, void 0, (function*() {
                window.clearInterval(loadInterval), page.reset(), $("html").addClass("miniMAL-hide");
                let curUrl = window.location.href;
                $('[class*="MetadataPosterTitle-isSecondary"] [data-qa-id="metadataTitleLink"]').attr("href") && (curUrl = $('[class*="MetadataPosterTitle-isSecondary"] [data-qa-id="metadataTitleLink"]').attr("href"));
                const path = String(utils.urlParam(curUrl, "key"));
                path && -1 !== path.indexOf("metadata") && function apiCall(url) {
                    return __awaiter(this, void 0, void 0, (function*() {
                        let pre;
                        auth.apiKey && auth.base || (yield function() {
                            return __awaiter(this, void 0, void 0, (function*() {
                                const logger = con.m("auth");
                                return logger.log("Start"), new Promise((resolve, reject) => {
                                    proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                                        try {
                                            const tempAuth = proxy.getCaptureVariable("auth");
                                            if (!tempAuth) throw "authInfo not found";
                                            if (!tempAuth.users) throw "users not found";
                                            const users = JSON.parse(tempAuth.users);
                                            if (!tempAuth.apiKey) {
                                                if (users && users.users && users.users.length && (!users.users[0].servers.length || void 0 === users.users[0].servers[0].accessToken)) return logger.log("Switching to no account mode"), 
                                                auth.apiKey = null, auth.serverApiKey = null, auth.base = window.location.origin, 
                                                void resolve("");
                                                throw "apiKey not found";
                                            }
                                            auth.apiKey = tempAuth.apiKey;
                                            const user = users.users.find(el => el.authToken === auth.apiKey);
                                            if (!user) throw "User not found";
                                            logger.log("User found", user.id);
                                            const serverId = user.lastPrimaryServerID;
                                            logger.log("Server", serverId);
                                            const server = user.servers.find(el => el.machineIdentifier === serverId);
                                            if (!server) throw "Server not found";
                                            if (auth.serverApiKey = server.accessToken, logger.log("Connections", server.connections), 
                                            !server.connections.length) throw "No connection found";
                                            let connection = server.connections[0];
                                            if (server.connections.length > 1) for (let i = 0; i < server.connections.length; i += 1) {
                                                const url = server.connections[i].uri;
                                                logger.log("Trying " + url);
                                                try {
                                                    if (200 !== (yield api.request.xhr("GET", {
                                                        url: `${url}/library/sections?X-Plex-Token=${auth.apiKey}`,
                                                        headers: {
                                                            Accept: "application/json"
                                                        }
                                                    })).status) throw "Not reached";
                                                    logger.log("Reached " + url), connection = server.connections[i];
                                                    break;
                                                } catch (e) {
                                                    logger.log("Ignoring unreachable server url " + url);
                                                }
                                            }
                                            auth.base = connection.uri, logger.log("Done", auth), resolve("");
                                        } catch (e) {
                                            logger.error(e), reject(e);
                                        }
                                    })));
                                });
                            }));
                        }()), pre = -1 !== url.indexOf("?") ? "&" : "?";
                        const reqUrl = `${auth.base + url + pre}X-Plex-Token=${auth.apiKey}`;
                        return con.log("Api Call", reqUrl), api.request.xhr("GET", {
                            url: reqUrl,
                            headers: {
                                Accept: "application/json"
                            }
                        }).then(response => {
                            if (200 !== response.status) {
                                if (!auth.serverApiKey) throw "Could not authenticate";
                                return auth.apiKey = auth.serverApiKey, auth.serverApiKey = null, con.log("Use server apikey"), 
                                apiCall(url);
                            }
                            return response;
                        });
                    }));
                }(decodeURIComponent(path)).then(response => {
                    let data;
                    try {
                        data = JSON.parse(response.responseText);
                    } catch (e) {
                        return void con.error(e);
                    }
                    if (/(anime|asian)/i.test(data.MediaContainer.librarySectionTitle)) switch (item = data.MediaContainer.Metadata[0], 
                    item.type) {
                      case "show":
                        if (con.log("Show", data), !item.skipChildren) return con.log("Series overview. Dont do anything"), 
                        void (item = void 0);
                        loadInterval = utils.waitUntilTrue((function() {
                            return j.$('[data-qa-id="preplay-mainTitle"]').length;
                        }), (function() {
                            page.UILoaded = !1, page.handlePage(curUrl), $("html").removeClass("miniMAL-hide");
                        }));
                        break;

                      case "season":
                        con.log("Season", data), loadInterval = utils.waitUntilTrue((function() {
                            return j.$('[data-qa-id="preplay-mainTitle"]').length;
                        }), (function() {
                            page.UILoaded = !1, page.handlePage(curUrl), $("html").removeClass("miniMAL-hide");
                        }));
                        break;

                      case "episode":
                        con.log("Episode", data), page.handlePage(curUrl), $("html").removeClass("miniMAL-hide");
                        break;

                      default:
                        con.log("Not recognized", data);
                    } else con.info("!Not an Anime!");
                });
            }));
        }
        const Plex = {
            name: "Plex",
            domain: "http://app.plex.tv",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => !(!item || "episode" !== item.type),
            sync: {
                getTitle: url => item.grandparentTitle + (item.parentIndex > 1 ? " Season " + item.parentIndex : ""),
                getIdentifier: url => void 0 !== item.parentKey ? item.parentKey.split("/")[3] : void 0 !== item.grandparentKey ? item.grandparentKey.split("/")[3] : item.key.split("/")[3],
                getOverviewUrl(url) {
                    let base = window.location.href.split("?")[0];
                    if (!base.includes("server/")) {
                        base = (window.location.href.split("#")[0] + j.$('[href^="#!/server"]').first().attr("href")).split("?")[0];
                    }
                    return `${base}?key=/library/metadata/${Plex.sync.getIdentifier(url)}`;
                },
                getEpisode: url => item.index
            },
            overview: {
                getTitle: url => item.parentTitle ? item.parentTitle : item.title,
                getIdentifier: url => item.key.split("/")[3],
                uiSelector(selector) {
                    j.$('[data-qa-id="preplay-mainTitle"]').first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(339).toString()), j.$(document).ready((function() {
                    urlChange(page);
                })), utils.changeDetect(() => urlChange(page), () => {
                    const epUrl = $('[class*="MetadataPosterTitle-isSecondary"] [data-qa-id="metadataTitleLink"]').attr("href");
                    return epUrl || String(utils.urlParam(window.location.href, "key"));
                }), document.addEventListener("fullscreenchange", (function() {
                    window.fullScreen || window.innerWidth === window.screen.width && window.innerHeight === window.screen.height ? $("html").addClass("miniMAL-Fullscreen") : $("html").removeClass("miniMAL-Fullscreen");
                })), setInterval(() => {
                    if (Plex.isSyncPage(page.url) && !$("video").length) {
                        const seekbar = $('[class*="SeekBar-seekBar-"] [aria-valuemax]').first();
                        if (!seekbar) return void con.m("Player").log("no seekbar");
                        const total = seekbar.attr("aria-valuemax"), cur = seekbar.attr("aria-valuenow"), playing = Boolean($('[data-qa-id="pauseButton"]').length);
                        con.m("Player").debug(cur, total, !playing), total && cur && page.setVideoTime({
                            current: cur,
                            duration: total,
                            paused: !playing
                        }, () => {
                            con.log("Not supported during chromecast");
                        });
                    }
                }, 1e3);
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(4), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, api, con, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Netflix;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let seasonData, episodeData, nextEpisodeData, titleName, titleId;
        const genres = [ 2797624, 7424, 67614, 2653, 587, 625, 79307, 9302, 79488, 452, 79448, 11146, 79440, 3063, 79543, 79427, 10695, 2729, 79329, 79572, 64256, 2951909, 6721, 2867325, 1522234, 1623841, 81216565, 3073, 3095 ], proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        function getSeries(page) {
            const meta = function() {
                const meta = proxy.getCaptureVariable("netflix");
                if (!(meta instanceof Object)) throw new Error("Invalid metadata");
                return meta;
            }(), videoId = utils.urlPart(window.location.href, 4);
            api.request.xhr("GET", `${meta.models.playerModel.data.config.ui.initParams.apiUrl}/metadata?movieid=${videoId}`).then(response => {
                const data = JSON.parse(response.responseText);
                titleId = data.video.id, titleName = data.video.title;
                const reqUrl = `${Netflix.domain}/title/${titleId}`;
                api.request.xhr("GET", reqUrl).then(response2 => {
                    con.log(response2);
                    let anime = !1;
                    const genresRaw = response2.responseText.match(/"genres":\s*\[.*?\]/i);
                    if (genresRaw && genresRaw.length) {
                        const genresParsed = JSON.parse(`{${genresRaw[0].replace(/\\/gm, "\\\\")}}`);
                        for (const genre of genresParsed.genres) if (genres.includes(genre.id)) {
                            anime = !0;
                            break;
                        }
                    }
                    if (anime) {
                        if ("movie" !== data.video.type) {
                            seasonData = data.video.seasons.find(season => (episodeData = season.episodes.find(episode => episode.id === data.video.currentEpisode), 
                            episodeData));
                            try {
                                nextEpisodeData = seasonData.episodes[seasonData.episodes.findIndex(episode => episode.id === episodeData.id) + 1];
                            } catch (e) {
                                nextEpisodeData = void 0;
                            }
                        } else seasonData = {
                            longName: titleName,
                            title: titleName,
                            seq: 1
                        }, episodeData = {
                            seq: 1
                        }, nextEpisodeData = void 0;
                        page.handlePage(), $("html").removeClass("miniMAL-hide");
                    } else con.info("No Anime");
                });
            });
        }
        proxy.addCaptureVariable("netflix", '\n    if (window.hasOwnProperty("netflix")) {\n      return netflix.reactContext;\n    } else {\n      return undefined;\n    }\n  ');
        const Netflix = {
            name: "Netflix",
            domain: "https://www.netflix.com",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => seasonData.longName !== seasonData.title ? seasonData.title : seasonData.seq > 1 ? `${titleName} season ${seasonData.seq}` : titleName,
                getIdentifier: url => `${titleId}?s=${seasonData.seq}`,
                getOverviewUrl: url => `${Netflix.domain}/title/${titleId}`,
                getEpisode: url => episodeData.seq,
                nextEpUrl: url => nextEpisodeData ? `${Netflix.domain}/watch/${nextEpisodeData.id}` : ""
            },
            init(page) {
                function ready() {
                    page.reset(), $("html").addClass("miniMAL-hide"), "watch" === utils.urlPart(window.location.href, 3) && utils.waitUntilTrue((function() {
                        return j.$(".ellipsize-text").length;
                    }), (function() {
                        proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                            getSeries(page);
                        })));
                    }));
                }
                api.storage.addStyle(__webpack_require__(341).toString()), j.$(document).ready((function() {
                    ready();
                })), utils.urlChangeDetect((function() {
                    ready();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(0), __webpack_require__(4), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return animepahe;
        }));
        const animepahe = {
            name: "animepahe",
            domain: "https://animepahe.com",
            languages: [ "English" ],
            database: "animepahe",
            type: "anime",
            isSyncPage: url => "play" === window.location.href.split("/")[3],
            sync: {
                getTitle: url => j.$(".theatre-info h1 a").first().text().trim(),
                getIdentifier: url => getId(),
                getOverviewUrl: url => getUrl(getId(), !0),
                getEpisode: url => Number((j.$(".theatre-info h1")[0].childNodes[2].textContent || "").replace(/[^0-9.]+/g, "")),
                nextEpUrl: url => j.$(".sequel a").first().attr("href") ? getUrl(getId(), !1, 1) : "",
                uiSelector(selector) {
                    j.$(".anime-season").after(j.html(selector));
                }
            },
            overview: {
                getTitle: url => utils.getBaseText(j.$(".title-wrapper h1").first()).trim(),
                getIdentifier: url => getId(),
                uiSelector(selector) {
                    j.$(".anime-detail").after(j.html(selector));
                },
                getMalUrl(provider) {
                    let url = j.$('a[href^="//myanimelist.net/anime/"]').not("#malRating").first().attr("href");
                    return (url || "ANILIST" === provider && (url = j.$('a[href^="//anilist.co/anime/"]').not("#malRating").first().attr("href"), 
                    url) || !("KITSU" !== provider || (url = j.$('a[href^="//kitsu.io/anime/"]').not("#malRating").first().attr("href"), 
                    !url))) && url.replace(/^\/\//, "https://");
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episode-list .episode"),
                    elementUrl(selector) {
                        const anchor = selector.find("a").first();
                        if (!anchor) return "";
                        const path = anchor.attr("href");
                        return path ? animepahe.domain + path : "";
                    },
                    elementEp: selector => Number(selector.find(".episode-number").first().text().replace(selector.find(".episode-number > *").text(), ""))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(343).toString()), utils.waitUntilTrue((function() {
                    return (animepahe.isSyncPage(window.location.href) || animepahe.overview.list.elementsSelector()) && void 0 !== getId();
                }), (function() {
                    page.handlePage(getUrl(getId(), !1));
                }));
            }
        };
        let id;
        function getId() {
            if (id) return id;
            const href = j.$('a[href^="//pahe.win/a/"]').attr("href");
            if (href) return id = href.split("/")[4], id;
            const script = $("script").filter((function(idx) {
                return this.innerHTML.includes("getUrls(");
            }));
            if (script && script.length) {
                const matches = script[0].innerHTML.match(/getUrls\(\d+/);
                if (matches && matches.length) return id = matches[0].replace(/\D+/g, ""), id;
            }
        }
        function getUrl(aid, overviewForce, increment = 0) {
            return "play" !== window.location.href.split("/")[3] || overviewForce ? "https://pahe.win/a/" + aid : `https://pahe.win/a/${aid}/${animepahe.sync.getEpisode(window.location.href) + increment}`;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Animeflv;
        }));
        const Animeflv = {
            name: "Animeflv",
            domain: "https://animeflv.net",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => "ver" === utils.urlPart(url, 3),
            isOverviewPage: url => "anime" === utils.urlPart(url, 3),
            sync: {
                getTitle: url => j.$("h1.Title").text().split(" Episodio")[0].trim(),
                getIdentifier: url => utils.urlPart(`${Animeflv.domain}${j.$(".fa-th-list").attr("href")}`, 4),
                getOverviewUrl: url => Animeflv.domain + (j.$(".fa-th-list").attr("href") || ""),
                getEpisode: url => parseInt(j.$("h2.SubTitle").text().replace("Episodio ", "").trim()),
                nextEpUrl(url) {
                    const nextEp = j.$(".fa-chevron-right").attr("href");
                    return nextEp ? Animeflv.domain + nextEp : nextEp;
                },
                uiSelector(selector) {
                    j.$(".CapOptns").after(j.html(selector));
                }
            },
            overview: {
                getTitle: url => j.$("h1.Title").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".Description").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector() {
                        const url = window.location.href;
                        document.body.insertAdjacentHTML("afterbegin", '<div id="MALSync" class="MALSync" style="display: none;"><ul id="MALSyncUl" class="MALSyncUl"></ul></div>');
                        const idMALSync = document.getElementById("MALSyncUl"), html = document.body.innerHTML;
                        let scriptEps = /<script>\s\s {3}var([^]*?)<\/script>/g.exec(html);
                        if (null !== scriptEps && (scriptEps = scriptEps[1] || null, null !== scriptEps)) {
                            const patron2 = /\[([^[\]]{0,10},{0,10})\]/g, eps = scriptEps.toString().match(patron2);
                            null !== eps && eps.forEach(element => {
                                if (null !== idMALSync) {
                                    const Url = `${Animeflv.domain}/ver/${utils.urlPart(url, 4)}-${element.split(",")[0].replace("[", "")}`, Episodio = element.split(",")[0].replace("[", "");
                                    idMALSync.innerHTML += j.html(`<li><a href="${Url}" epi="${Episodio}"></a> </li>`);
                                }
                            });
                        }
                        return j.$(".MALSync a");
                    },
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), Animeflv.domain),
                    elementEp: selector => Number(selector.attr("epi")),
                    handleListHook(epi, epilist) {
                        if (epi++, epilist.length - 1 >= epi) {
                            const cover = j.$(".AnimeCover img").attr("src"), name = j.$(".Container h2").text(), epiAct = `<li class="fa-play-circle Next"><a href="${epilist[epi][0].toString()}"><figure><img src="${cover}" alt=""></figure><h3 class="Title">${name}</h3><p>Episodio ${epi}</p><span style="position: absolute; top: 0; bottom: 0; margin: auto; right: 20px; line-height: 30px; font-size: 16px; font-weight: 700; height: 30px;">Siguiente Episodio</span></a></li>`;
                            j.$(".Main .ListCaps").prepend(j.html(epiAct));
                        }
                    }
                }
            },
            init(page) {
                if (api.storage.addStyle(__webpack_require__(345).toString()), "Verifica que no eres un bot | AnimeFLV" === document.title) return con.log("loading"), 
                void page.cdn();
                j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Jkanime;
        }));
        const Jkanime = {
            name: "Jkanime",
            domain: "https://jkanime.net",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => !(Number.isNaN(parseInt(utils.urlPart(url, 4))) && ("pelicula" !== utils.urlPart(url, 4) || !Jkanime.sync.getTitle(url).length)),
            isOverviewPage: url => Jkanime.overview.getTitle(url).length > 0,
            sync: {
                getTitle: url => j.$("div.breadcrumb-option > div > div > div> div.breadcrumb__links > h1").first().text().split(" - ")[0],
                getIdentifier: url => utils.urlPart(url, 3),
                getOverviewUrl: url => `${Jkanime.domain}/${Jkanime.sync.getIdentifier(url)}`,
                getEpisode: url => parseInt(utils.urlPart(url, 4)) || 1,
                nextEpUrl: url => j.$('div:contains("Proximo Episodio")').parent("a").attr("href")
            },
            overview: {
                getTitle: url => j.$("div.anime__details__title > h3").text(),
                getIdentifier: url => utils.urlPart(url, 3),
                uiSelector(selector) {
                    j.$("section.contenido.spad > div > div.row").before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.epcontent > div.anime__item a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), Jkanime.domain),
                    elementEp(selector) {
                        var _a, _b;
                        return Jkanime.sync.getEpisode((null === (_b = null === (_a = Jkanime.overview) || void 0 === _a ? void 0 : _a.list) || void 0 === _b ? void 0 : _b.elementUrl(selector)) || "");
                    },
                    paginationNext(updateCheck) {
                        let el;
                        return con.log("updatecheck", updateCheck), updateCheck ? (el = j.$("div.anime__pagination > a").last(), 
                        void 0 !== el[0] && !el.hasClass("pagination-active") && (el[0].click(), !0)) : (el = j.$("div.anime__pagination > a.pagination-active").next("a"), 
                        void 0 !== el[0] && (el[0].click(), !0));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(347).toString()), j.$(document).ready((function() {
                    $("div.anime__pagination > a").first().addClass("pagination-active"), page.handlePage();
                })), utils.changeDetect(() => {
                    page.handleList();
                }, () => j.$("div.epcontent > div.anime__item a").first().attr("href")), $("div.anime__pagination > a").click((function() {
                    $("div.anime__pagination > a").removeClass("pagination-active"), $(this).addClass("pagination-active");
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils, j) {
        let json, ident, seasonInterval;
        function getSeries(page, overview = "") {
            json = void 0, ident = void 0, api.request.xhr("GET", page.url).then(response => {
                con.log(response), json = JSON.parse(`{${response.responseText.split("__INITIAL_STATE__ = {")[1].split("};")[0]}}`), 
                con.log(json), overview.length ? json.seriesPage.seasons.forEach((function(element) {
                    -1 !== overview.indexOf(element.json.title) && (con.log("Season Found", element), 
                    ident = element);
                })) : json.seriesPage.seasons.length && (con.log("Season", json.seriesPage.seasons[0]), 
                ident = json.seriesPage.seasons[0]), page.handlePage();
            });
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Vrv;
        }));
        const Vrv = {
            name: "Vrv",
            domain: "https://vrv.co",
            languages: [ "English", "Spanish", "Portuguese", "French", "German", "Arabic", "Italian", "Russian" ],
            type: "anime",
            isSyncPage: url => "series" !== utils.urlPart(window.location.href, 3),
            sync: {
                getTitle: url => `${json.watch.mediaResource.json.series_title} - ${json.watch.mediaResource.json.season_title.replace(json.watch.mediaResource.json.series_title, "")}`,
                getIdentifier: url => json.watch.mediaResource.json.season_id,
                getOverviewUrl: url => `${Vrv.domain}/series/${json.watch.mediaResource.json.series_id}?season=${Vrv.sync.getIdentifier(url)}`,
                getEpisode: url => json.watch.mediaResource.json.episode_number,
                nextEpUrl: url => void 0 === json.watch.mediaResource.json.next_episode_id ? "" : `${Vrv.domain}/watch/${json.watch.mediaResource.json.next_episode_id}`
            },
            overview: {
                getTitle: url => `${json.seriesPage.series.json.title} - ${ident.json.title.replace(json.seriesPage.series.json.title, "")}`,
                getIdentifier: url => ident.json.id,
                uiSelector(selector) {
                    $(".erc-series-info .series-title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !0,
                    elementsSelector: () => j.$(".erc-series-media-list-element"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Vrv.domain),
                    elementEp(selector) {
                        const temp = selector.find(".episode-title").text().trim().match(/^E\d+/i);
                        return temp ? Number(temp[0].replace("E", "")) : NaN;
                    },
                    getTotal() {
                        throw "Not supported";
                    }
                }
            },
            init(page) {
                function ready() {
                    clearInterval(seasonInterval), page.reset(), "watch" === utils.urlPart(window.location.href, 3) && getSeries(page), 
                    "series" === utils.urlPart(window.location.href, 3) && utils.waitUntilTrue((function() {
                        return j.$(".erc-series-info .series-title").first().length;
                    }), (function() {
                        j.$(".erc-series-media-list-element").length && void 0 === j.$(".erc-series-media-list-element a").first().attr("href") || getSeries(page, $(".controls-select-trigger .season-info").text().trim()), 
                        seasonInterval = utils.changeDetect((function() {
                            page.reset(), getSeries(page, $(".controls-select-trigger .season-info").text().trim());
                        }), (function() {
                            return j.$(".erc-series-media-list-element a").first().attr("href");
                        }));
                    }));
                }
                api.storage.addStyle(__webpack_require__(349).toString()), j.$(document).ready((function() {
                    ready();
                })), utils.urlChangeDetect((function() {
                    page.url = window.location.href, ready();
                }));
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Proxer;
        }));
        const Proxer = {
            name: "Proxer",
            domain: "https://proxer.me",
            languages: [ "German", "English" ],
            type: "anime",
            isSyncPage: url => "watch" === url.split("/")[3] || "read" === url.split("/")[3],
            sync: {
                getTitle: url => -1 !== url.indexOf("watch") ? j.$(".wName").text().trim() : -1 !== url.indexOf("read") ? j.$("div#breadcrumb a:first").text() : "",
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => `${Proxer.domain}/info/${Proxer.sync.getIdentifier(url)}/list`,
                getEpisode: url => -1 !== url.indexOf("watch") ? getEpisodeFallback("episode " + $(".wEp").last().text().trim(), url.split("/")[5]) : getEpisodeFallback($("#breadcrumb > a").last().text().trim(), url.split("/")[5]),
                nextEpUrl: url => Proxer.domain + $(".no_details a").last().attr("href")
            },
            overview: {
                getTitle: url => j.$("#pageMetaAjax").text().split(" - ")[0].replace(/\(Anime\)|\(Manga\)$/gim, "").trim(),
                getIdentifier: url => Proxer.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$(".hreview-aggregate > span").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$('span[id^="listTitle"]').parent().parent(),
                    elementUrl: selector => utils.absoluteLink(selector.find('a[href^="/watch"],a[href^="/read"],a[href^="/chapter"]').first().attr("href"), Proxer.domain),
                    elementEp: selector => getEpisodeFallback(selector.find('span[id^="listTitle"]').first().text().trim(), Proxer.overview.list.elementUrl(selector).split("/")[5]),
                    paginationNext(updateCheck) {
                        let el;
                        return con.error("sadsad", updateCheck), updateCheck ? (el = j.$(".menu").last(), 
                        void 0 !== el[0] && !el.hasClass("active") && (el[0].click(), !0)) : (el = j.$(".menu.active").first().next(), 
                        void 0 !== el[0] && (el[0].click(), !0));
                    },
                    getTotal() {
                        const el = $('img[src="/images/misc/manga.png"], img[src="/images/misc/play.png"]').last().parent().parent().parent().parent();
                        if (el.length) return Proxer.overview.list.elementEp(el);
                    }
                }
            },
            init(page) {
                if (api.storage.addStyle(__webpack_require__(351).toString()), j.$(".g-recaptcha").length) return con.log("loading"), 
                void page.cdn("captcha");
                "watch" !== page.url.split("/")[3] && "read" !== page.url.split("/")[3] || ("watch" === page.url.split("/")[3] ? Proxer.type = "anime" : "read" === page.url.split("/")[3] && (Proxer.type = "manga"), 
                j.$(document).ready((function() {
                    page.handlePage();
                }))), ajaxHandle(page), utils.urlChangeDetect((function() {
                    page.reset(), ajaxHandle(page);
                }));
            }
        };
        let current = 0;
        function ajaxHandle(page) {
            if ("info" !== utils.urlPart(page.url, 3)) return;
            const detailPart = utils.urlPart(page.url, 5);
            con.info("page", detailPart), "list" === detailPart && utils.waitUntilTrue((function() {
                return j.$("#contentList").length;
            }), (function() {
                j.$('#simple-navi a[href*="manga"]').length ? Proxer.type = "manga" : Proxer.type = "anime";
                const tempCurrent = parseInt(Proxer.overview.getIdentifier(page.url));
                if (tempCurrent !== current) current = tempCurrent, page.handlePage(); else try {
                    page.handleList();
                } catch (e) {
                    con.error(e), page.handlePage();
                }
            })), "details" !== detailPart && detailPart || utils.waitUntilTrue((function() {
                return j.$(".hreview-aggregate").length;
            }), (function() {
                current = parseInt(Proxer.overview.getIdentifier(page.url)), j.$('#simple-navi a[href*="manga"]').length ? Proxer.type = "manga" : Proxer.type = "anime", 
                page.handlePage();
            }));
        }
        function getEpisodeFallback(string, fallback) {
            if (null !== string.match(/(special|extra)/gi)) return "";
            const temp = string.match(/(kapitel |ep. |chapter |episode )\d+/gi);
            return null !== temp ? temp[0].match(/\d+/)[0] : fallback;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return fourAnime;
        }));
        const fourAnime = {
            name: "4Anime",
            domain: "https://4anime.to",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !(!j.$(".singletitletop").length || !j.$(".episodes").length),
            sync: {
                getTitle: url => j.$("span.singletitletop a").text().trim(),
                getIdentifier: url => utils.urlPart(fourAnime.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => j.$("span.singletitletop a").attr("href") || "",
                getEpisode: url => Number(j.$("ul.episodes a.active").text().replace(/\D+/g, "")),
                nextEpUrl(url) {
                    const href = j.$(".anipager-next a").first().attr("href");
                    return void 0 !== href ? utils.absoluteLink(href, fourAnime.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("p.single-anime-desktop").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("p.description-mobile").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episodes.range a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), fourAnime.domain),
                    elementEp: selector => Number(selector.text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(353).toString()), j.$(document).ready((function() {
                    (j.$(".singletitletop").length && j.$(".episodes").length || "anime" === page.url.split("/")[3]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return animeultima;
        }));
        const animeultima = {
            name: "animeultima",
            domain: "https://animeultima.to",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !("a" !== url.split("/")[3] || !j.$("h1.title.is-marginless span.is-size-4.is-size-5-touch.is-size-6-mobile")[0]),
            sync: {
                getTitle: url => j.$("h1.title.is-marginless span.is-size-4.is-size-5-touch.is-size-6-mobile").text().replace(/\n.*/g, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4).replace(/_\d+$/, ""),
                getOverviewUrl: url => `${animeultima.domain}/a/${animeultima.sync.getIdentifier(url)}`,
                getEpisode: url => Number(j.$("h1.title.is-marginless span.is-size-4.is-size-5-touch.is-size-6-mobile").text().replace(/.*\n/g, "").replace(/\D+/g, "")),
                nextEpUrl(url) {
                    const href = j.$(".level-right a").first().attr("href");
                    return void 0 !== href ? utils.absoluteLink(href, animeultima.domain) : "";
                }
            },
            overview: {
                getTitle: url => utils.getBaseText($("h1.title.is-marginless.is-paddingless").first()).replace(/[^ \w]+/g, "").trim(),
                getIdentifier: url => animeultima.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("div.tags.is-marginless").first().after(j.html(selector));
                },
                getMalUrl(provider) {
                    const url = j.$('a[href^="https://myanimelist.net/anime/"]').not("#malRating").first().attr("href");
                    return url || !1;
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(355).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Aniflix;
        }));
        const Aniflix = {
            name: "Aniflix",
            domain: "https://www1.aniflix.tv",
            languages: [ "German" ],
            type: "anime",
            isSyncPage: url => "season" === url.split("/")[6],
            sync: {
                getTitle(url) {
                    const urlParts = url.split("/");
                    return "1" === urlParts[7] || "0" === urlParts[7] ? j.$("a.episode-showname").text() : `${j.$("a.episode-showname").text()} season ${url.split("/")[7]}`;
                },
                getIdentifier: url => `${url.split("/")[4]}?s=${url.split("/")[7]}`,
                getOverviewUrl: url => Aniflix.domain + (j.$("a.episode-showname").attr("href") || ""),
                getEpisode: url => Number(url.split("/")[9])
            },
            overview: {
                getTitle: url => 1 === Number(j.$("div.seasons-wrapper > div.season.season-active > div").first().text().replace(/\D+/g, "")) || "Specials" === j.$("div.seasons-wrapper > div.season.season-active > div").first().text() ? j.$("h1.show-name").text() : `${j.$("h1.show-name").text()} season ${j.$("div.seasons-wrapper > div.season.season-active > div").first().text().replace(/\D+/g, "")}`,
                getIdentifier: url => "Specials" === j.$("div.seasons-wrapper > div.season.season-active > div").first().text() ? url.split("/")[4] + "?s=0" : `${url.split("/")[4]}?s=${j.$("div.seasons-wrapper > div.season.season-active > div").first().text().replace(/\D+/g, "")}`,
                uiSelector(selector) {
                    j.$("div.episodes").first().before(j.html(selector));
                }
            },
            init(page) {
                function ready() {
                    page.reset(), "show" === page.url.split("/")[3] && (Aniflix.isSyncPage(page.url) ? utils.waitUntilTrue((function() {
                        return !!j.$("a.episode-showname").length;
                    }), (function() {
                        page.handlePage();
                    })) : (page.reset(), utils.waitUntilTrue((function() {
                        return !(!j.$("h1.show-name").length || !j.$("h1.show-name").first().text());
                    }), (function() {
                        page.handlePage(), $("div.seasons-wrapper").unbind("click").click((function() {
                            page.reset(), page.handlePage();
                        }));
                    }))));
                }
                api.storage.addStyle(__webpack_require__(357).toString()), page.url = window.location.href, 
                ready(), utils.urlChangeDetect((function() {
                    ready();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Animefreak;
        }));
        const Animefreak = {
            name: "Animefreak",
            domain: "https://www.animefreak.tv",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "episode" === url.split("/")[5],
            sync: {
                getTitle: url => j.$("div.top-breadcrumb li:nth-child(2) a").text(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => `${Animefreak.domain}/watch/${Animefreak.sync.getIdentifier(url)}`,
                getEpisode: url => Number(url.split("/")[6].replace(/\D+/g, "")),
                nextEpUrl(url) {
                    const href = j.$(".fa-step-forward").first().parent().attr("href");
                    return void 0 !== href ? utils.absoluteLink(href, Animefreak.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("div.top-breadcrumb li:nth-child(2) a").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.anime-title").first().before(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(359).toString()), j.$(document).ready((function() {
                    "watch" === page.url.split("/")[3] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeLab;
        }));
        const proxy = new (__webpack_require__(11).a);
        function extractMetadata() {
            const videos = proxy.getCaptureVariable("videos");
            if (!(videos instanceof Array)) throw new Error("Invalid metadata");
            const slug = document.URL.split("/").pop();
            let playlistPosition = -1;
            for (let index = 0; index < videos.length; index++) if ("videoEntry" in videos[index] && videos[index].videoEntry.slug === slug) {
                playlistPosition = index;
                break;
            }
            if (-1 === playlistPosition) throw new Error("Failed to identify playlist position");
            return {
                videos: videos,
                playlistPosition: playlistPosition
            };
        }
        proxy.addCaptureVariable("videos", '\n    if (window.hasOwnProperty("videos")) {\n      return videos;\n    } else {\n      return undefined;\n    }\n  ');
        const AnimeLab = {
            name: "AnimeLab",
            domain: "https://www.animelab.com",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => url.startsWith("https://www.animelab.com/player/"),
            sync: {
                getTitle(url) {
                    const meta = extractMetadata(), seasonInfo = meta.videos[meta.playlistPosition].videoEntry.season;
                    return seasonInfo.seasonNumber > 1 ? seasonInfo.name.length > seasonInfo.showTitle.length && !seasonInfo.name.startsWith("Season") ? seasonInfo.name : `${seasonInfo.showTitle} ${seasonInfo.name}` : seasonInfo.showTitle;
                },
                getIdentifier: url => AnimeLab.sync.getTitle(url),
                getOverviewUrl(url) {
                    const meta = extractMetadata();
                    return "https://www.animelab.com/shows/" + meta.videos[meta.playlistPosition].videoEntry.showSlug;
                },
                getEpisode(url) {
                    const meta = extractMetadata();
                    return parseInt(meta.videos[meta.playlistPosition].videoEntry.episodeNumber);
                },
                nextEpUrl(url) {
                    const meta = extractMetadata();
                    if (meta.videos.length > meta.playlistPosition + 1) return "https://www.animelab.com/player/" + meta.videos[meta.playlistPosition + 1].videoEntry.slug;
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(361).toString());
                const callback = caller => {
                    page.handlePage();
                };
                AnimeLab.isSyncPage(page.url) && j.$(document).ready(() => {
                    proxy.addProxy(callback), j.$("#video-component").on("loadstart", () => {
                        proxy.addProxy(callback);
                    });
                });
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return KickAssAnime;
        }));
        const KickAssAnime = {
            name: "KickAssAnime",
            domain: "https://www.kickassanime.ro",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => void 0 !== url.split("/")[5],
            sync: {
                getTitle: url => utils.getBaseText($("#animeInfoTab > a")),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => `${KickAssAnime.domain}/anime/${KickAssAnime.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/episode-\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl(url) {
                    const href = j.$("#sidebar-anime-info > div > div > a:contains('Next Episode')").attr("href");
                    return href ? utils.absoluteLink(href, KickAssAnime.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("h1.title").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.anime-info").first().after(j.html(`<div class="border rounded mb-2 p-3"><div class="font-weight-bold">MAL-Sync</div>${selector}</div`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.anime-list tbody > tr"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), KickAssAnime.domain),
                    elementEp(selector) {
                        const text = selector.find("a").text();
                        return text.toLowerCase().includes("episode") ? Number(text.replace(/\D+/g, "")) : NaN;
                    },
                    paginationNext(updateCheck) {
                        con.log("updatecheck", updateCheck);
                        const el = j.$(" div.main-episode-list > div > div > div > button:nth-child(2):enabled");
                        return void 0 !== el[0] && (el[0].click(), !0);
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(363).toString()), j.$(document).ready((function() {
                    "anime" === page.url.split("/")[3] && utils.waitUntilTrue((function() {
                        return KickAssAnime.sync.getTitle(page.url) || KickAssAnime.overview.getTitle(page.url);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeKisa;
        }));
        const AnimeKisa = {
            name: "AnimeKisa",
            domain: "https://animekisa.tv",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !(null === url.split("/")[3] || !j.$("div.c a.infoan2")[0] || !j.$("#playerselector option:selected")[0]),
            isOverviewPage(url) {
                const infoElement = j.$("div.notmain > div > div.infobox > div.infoboxc > div.infodesbox > h1"), episodeList = j.$("div.notmain > div > div.infobox > div.infoepboxmain");
                return !(!url.split("/")[3] || 0 === infoElement.length || 0 === episodeList.length);
            },
            sync: {
                getTitle: url => j.$("div.c a.infoan2").text().trim(),
                getIdentifier: url => j.$("div.c a.infoan2").attr("href") || "",
                getOverviewUrl: url => `${AnimeKisa.domain}/${j.$("div.c a.infoan2").attr("href")}`,
                getEpisode: url => Number(j.$("#playerselector option:selected").text().replace(/\D+/g, "")),
                nextEpUrl(url) {
                    const num = $("#playerselector").find("option:selected").next().attr("value");
                    if (!num) return "";
                    const href = url.replace(/\d+$/, num);
                    return void 0 !== num && href !== url ? utils.absoluteLink(href, AnimeKisa.domain) : "";
                },
                getMalUrl: provider => AnimeKisa.overview.getMalUrl(provider)
            },
            overview: {
                getTitle: url => j.$("div.notmain > div > div.infobox > div.infoboxc > div.infodesbox > h1").text().trim(),
                getIdentifier: url => url.split("/")[3],
                uiSelector(selector) {
                    j.$(".infoepboxmain").first().before(j.html(selector));
                },
                getMalUrl(provider) {
                    let url = j.$('a[href^="https://myanimelist.net/anime/"]').not("#malRating").first().attr("href");
                    return url || ("ANILIST" === provider && (url = j.$('a[href^="https://anilist.co/anime/"]').not("#malRating").first().attr("href"), 
                    url) || !("KITSU" !== provider || (url = j.$('a[href^="https://kitsu.io/anime/"]').not("#malRating").first().attr("href"), 
                    !url))) && url;
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.infoepbox > a"),
                    elementUrl: selector => `${AnimeKisa.domain}/${selector.find(".infoepmain").first().parent().attr("href")}`,
                    elementEp: selector => Number(selector.find("div.infoept2r > div, div.infoept2 > div").first().text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(365).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Wakanim;
        }));
        const Wakanim = {
            name: "Wakanim",
            domain: "https://www.wakanim.tv",
            languages: [ "English", "Spanish", "Portuguese", "French", "German", "Arabic", "Italian", "Russian" ],
            type: "anime",
            isSyncPage: url => !!j.$("body > section.episode > div > div > div.episode_main > div.episode_video > div").length,
            sync: {
                getTitle: url => Wakanim.sync.getIdentifier(url),
                getIdentifier(url) {
                    const ses = seasonHelper(j.$("span.episode_subtitle > span:nth-child(2)").text());
                    return `${j.$('[itemprop="partOfSeries"] meta[itemprop="name"]').attr("content")} ${ses}`;
                },
                getOverviewUrl: url => Wakanim.domain + (j.$("body > section.episode > div > div > div.episode_info > div.episode_buttons > a:nth-child(2)").attr("href") || ""),
                getEpisode: url => Number(j.$("body > section.episode > div > div > div.episode_info > h1 > span.episode_subtitle > span > span").text()),
                nextEpUrl: url => j.$("body > section.episode > div > div > div.episode_main > div.episode_video > div > div.episode-bottom > div.episodeNPEp-wrapperBlock > a.episodeNPEp.episodeNextEp.active").attr("href")
            },
            overview: {
                getTitle: url => Wakanim.overview.getIdentifier(url),
                getIdentifier(url) {
                    const secondPart = seasonHelper(j.$("#list-season-container > div > select > option:selected").text());
                    return `${j.$('[itemtype="http://schema.org/TVSeries"] > meta[itemprop="name"]').attr("content")} ${secondPart}`;
                },
                uiSelector(selector) {
                    j.$("#nav-show").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !0,
                    elementsSelector: () => j.$("li.-big"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), Wakanim.domain),
                    elementEp(selector) {
                        const url = Wakanim.overview.list.elementUrl(selector), anchorTitle = selector.find("a").attr("title");
                        return anchorTitle ? function(url, _episodeText) {
                            let episodePart = "";
                            if (/\d+\.\d+/.test(_episodeText)) {
                                const matches = _episodeText.match(/\d+\.\d+/);
                                matches && 0 !== matches.length && (episodePart = "episode" + matches[0]);
                            } else episodePart = utils.urlPart(url, 8) || "";
                            if (!episodePart) return NaN;
                            const episodeTextMatches = episodePart.match(/([e,E][p,P][i,I]?[s,S]?[o,O]?[d,D]?[e,E]?|[f,F][o,O][l,L][g,G]?[e,E])\D?\d+/);
                            if (!episodeTextMatches || 0 === episodeTextMatches.length) return NaN;
                            const episodeNumberMatches = episodeTextMatches[0].match(/\d+/);
                            return episodeNumberMatches && 0 !== episodeNumberMatches.length ? Number(episodeNumberMatches[0]) : NaN;
                        }(url, anchorTitle.trim()) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(367).toString()), ("show" === page.url.split("/")[6] && "season" === page.url.split("/")[9] || "episode" === page.url.split("/")[6]) && utils.waitUntilTrue((function() {
                    return !(!j.$("body > div.SerieV2 > section > div.container > div > div.SerieV2-content").length && !j.$("#jwplayer-container").length);
                }), (function() {
                    page.reset(), page.handlePage();
                })), utils.urlChangeDetect((function() {
                    page.reset(), "show" === page.url.split("/")[6] && "season" === page.url.split("/")[9] && utils.waitUntilTrue((function() {
                        return !!j.$("#list-season-container").length;
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
        function seasonHelper(text) {
            if (text.includes("Cour")) {
                const temp = text.match(/Cour (\d+)/);
                return 2 === temp[1] ? text.replace(temp[0], "Part 2 ").trim().replace("-", "") : text.replace(/Cour \d+/, "").trim().replace("-", "");
            }
            return text;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeIndo;
        }));
        const AnimeIndo = {
            name: "AnimeIndo",
            domain: "https://animeindo.net",
            languages: [ "Indonesian" ],
            type: "anime",
            isSyncPage: url => !(null === url.split("/")[1] || !j.$("#sct_content > div > div.preview")[0]),
            sync: {
                getTitle: url => j.$("#sct_content > div > div.infobox > h3").text(),
                getIdentifier(url) {
                    const anchorHref = j.$("#sct_content > div > div.ep_nav.fr > span.nav.all > a").attr("href");
                    return anchorHref ? utils.urlPart(anchorHref, 4) : "";
                },
                getOverviewUrl: url => j.$("#sct_content > div > div.ep_nav.fr > span.nav.all > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[3];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-episode-\d*/g);
                    return temp ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl(url) {
                    const href = j.$(".nav.next a").first().attr("href");
                    return void 0 !== href ? utils.absoluteLink(href, AnimeIndo.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("#sct_content > div.nodeinfo > h2").first().text().replace(/sinopsis/gi, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#sct_content > h1").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.eps_lst,ul#epl").find("li:not(.hdr)"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), AnimeIndo.domain),
                    elementEp: selector => Number(selector.find("a").first().text().replace(/\D+/g, ""))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(369).toString()), j.$(document).ready((function() {
                    ("anime" === page.url.split("/")[3] || null !== page.url.split("/")[3] && j.$("#sct_content > div > div.preview")[0]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Shinden;
        }));
        const Shinden = {
            name: "Shinden",
            domain: "https://shinden.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage(url) {
                const urlPart = url.split("/")[3];
                return "episode" === urlPart || "epek" === urlPart;
            },
            sync: {
                getTitle: url => j.$(".page-title > a").text().trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$(".player-navigator > li:nth-child(2) > a").attr("href"), Shinden.domain),
                getEpisode(url) {
                    const episodeText = j.$("dl.info-aside-list:nth-child(1) > dd:nth-child(2)").text();
                    return episodeText ? Number(episodeText.replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl: url => utils.absoluteLink(j.$(".player-navigator > li:nth-child(3) > a").attr("href"), Shinden.domain)
            },
            overview: {
                getTitle: url => j.$("h1.page-title").text().replace(/anime:/gim, "").trim(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$(".title-other").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".list-episode-checkboxes > tr:has(.fa-check)"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Shinden.domain),
                    elementEp: selector => Number(selector.find("td").first().text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(371).toString()), j.$(document).ready((function() {
                    const urlPart = page.url.split("/")[3];
                    "series" !== urlPart && "episode" !== urlPart && "titles" !== urlPart && "epek" !== urlPart || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Voiranime;
        }));
        const Voiranime = {
            name: "Voiranime",
            domain: "https://voiranime.com",
            languages: [ "French" ],
            type: "anime",
            isSyncPage: url => !!$(".chapter-video-frame").length,
            sync: {
                getTitle: url => j.$(".breadcrumb > li:nth-child(2) > a:nth-child(1)").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => `${Voiranime.domain}/anime/${Voiranime.sync.getIdentifier(url)}`,
                getEpisode: url => Number(j.$("div.select-view:nth-child(2) > div:nth-child(2) > label:nth-child(1) > select >option:selected").text()),
                nextEpUrl: url => utils.absoluteLink(j.$("div.select-pagination:nth-child(3) > div:nth-child(1) > div:nth-child(2) > a:nth-child(1)").attr("href"), Voiranime.domain)
            },
            overview: {
                getTitle: url => $(".post-title > h1:nth-child(1)").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$(".post-title > h1:nth-child(1)").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !0,
                    elementsSelector: () => j.$("li.wp-manga-chapter"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), Voiranime.domain),
                    elementEp: selector => Number(selector.find("a").first().text().split("-").pop())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(373).toString()), j.$(document).ready((function() {
                    ($(".chapter-video-frame").length || $("body > div.wrap > div > div.site-content > div > div.profile-manga > div > div > div > div.tab-summary").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return DubbedAnime;
        }));
        const DubbedAnime = {
            name: "DubbedAnime",
            domain: "https://ww5.dubbedanime.net",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "episode" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("h1.dosis.ep-title").text().replace(/(episode|ova).*\d+/gim, "").trim(),
                getIdentifier: url => DubbedAnime.overview.getIdentifier(DubbedAnime.sync.getOverviewUrl(url)),
                getOverviewUrl: url => utils.absoluteLink(j.$('div.video-info a[href*="/anime/"]').attr("href"), DubbedAnime.domain),
                getEpisode(url) {
                    const temp = utils.urlPart(url, 4).match(/-(episode|ova)-\d+-/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => utils.absoluteLink(j.$("div.video-info i.fa-forward").closest("a").attr("href"), DubbedAnime.domain)
            },
            overview: {
                getTitle: url => j.$("h1.h3.dosis.mt-0.text-white.pt-2.d-none.d-sm-block").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#episodes > div > div.row.mb-3.pr-2").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.da-page-episodes > ul.list-unstyled > li.da-tbl:not(.ongoing-ep-new,:hidden)"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div.da-video-tbl > a").first().attr("href"), DubbedAnime.domain),
                    elementEp: selector => Number(selector.find("div.da-video-tbl > span.ep-num").first().text().replace(/\D+/, ""))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(375).toString()), j.$(document).ready((function() {
                    "episode" === page.url.split("/")[3] ? page.handlePage() : "anime" === page.url.split("/")[3] && (page.handlePage(), 
                    $("div.col-4.px-0 > button.subdub").unbind("click").click((function() {
                        page.handleList();
                    })));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return VIZ;
        }));
        const VIZ = {
            name: "VIZ",
            domain: "https://www.viz.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "shonenjump" === url.split("/")[3] && "chapter" === url.split("/")[5],
            sync: {
                getTitle: url => j.$("#product_row > div.bg-lighter-gray.mar-b-md.mar-b-lg--md.chapter_ribbon > div > h3 > a").text(),
                getIdentifier(url) {
                    const anchorHref = j.$("#product_row > div.bg-lighter-gray.mar-b-md.mar-b-lg--md.chapter_ribbon > div > h3 > a").attr("href");
                    return anchorHref ? anchorHref.split("/")[3] : "";
                },
                getOverviewUrl: url => VIZ.domain + (j.$("#product_row > div.bg-lighter-gray.mar-b-md.mar-b-lg--md.chapter_ribbon > div > h3 > a").attr("href") || ""),
                getEpisode(url) {
                    const episodePart = j.$("#product_row > div.bg-lighter-gray.mar-b-md.mar-b-lg--md.chapter_ribbon > div > h3 > span").text();
                    if (!episodePart) return NaN;
                    const episodeNumberMatches = episodePart.match(/\d+/gim);
                    return episodeNumberMatches && 0 !== episodeNumberMatches.length ? Number(episodeNumberMatches[0]) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("#series-intro > div.clearfix.mar-t-md.mar-b-lg > h2").text().trim(),
                getIdentifier: url => url.split("/")[5],
                uiSelector(selector) {
                    j.$("#series-intro").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".o_sortable-b,.o_sortable"),
                    elementUrl(selector) {
                        const anchorHref = selector.find("a").first().attr("href");
                        return anchorHref ? VIZ.domain + anchorHref.replace(/javascript:tryReadChapter\(\d+,'/gi, "").replace(/'\);/g, "") : "";
                    },
                    elementEp(selector) {
                        const anchorHref = selector.find("a").first().attr("href");
                        if (!anchorHref || anchorHref.match(/javascript:void\('join to read'\);/)) return NaN;
                        let episodePart = selector.find("td > div.disp-id.mar-r-sm").text();
                        if (0 === episodePart.length && (episodePart = selector.find("a").first().text().trim()), 
                        !episodePart || 0 === episodePart.length) throw "Join to read";
                        const temp = episodePart.match(/\d+/gim);
                        return temp ? Number(temp[0]) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(377).toString()), j.$(document).ready((function() {
                    "shonenjump" !== page.url.split("/")[3] || "chapter" !== page.url.split("/")[5] && "chapters" !== page.url.split("/")[4] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaNato;
        }));
        const MangaNato = {
            name: "MangaNato",
            domain: [ "https://manganato.com", "https://readmanganato.com" ],
            database: "MangaNato",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[3] && url.split("/")[3].startsWith("manga-") && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            isOverviewPage: url => void 0 !== url.split("/")[3] && url.split("/")[3].startsWith("manga-") && void 0 === url.split("/")[4],
            getImage: () => $("div.story-info-left > span.info-image > img").attr("src"),
            sync: {
                getTitle: url => j.$("div.body-site > div > div.panel-breadcrumb > a:nth-child(3)").text(),
                getIdentifier: url => utils.urlPart(url, 3),
                getOverviewUrl: url => j.$("div.body-site > div > div.panel-breadcrumb > a:nth-child(3)").attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 4).match(/chapter[_-]\d+/gi);
                    return temp && temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                },
                nextEpUrl: url => j.$("div.panel-navigation > div > a.navi-change-chapter-btn-next.a-h").first().attr("href")
            },
            overview: {
                getTitle: url => j.$("div.panel-story-info > div.story-info-right > h1").text(),
                getIdentifier: url => utils.urlPart(url, 3),
                uiSelector(selector) {
                    j.$("div.panel-story-chapter-list").first().before(j.html(`<div id="malthing" class="panel-story-chapter-list"> <p class="row-title-chapter" style="width: 100%;"><span class="row-title-chapter-name">MAL-Sync</span></p> <div class="panel-story-info-description" style="border-top: 0;margin-top: 0;background: inherit;">${selector}</div></div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.panel-story-chapter-list > ul.row-content-chapter > li.a-h"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => MangaNato.sync.getEpisode(String(selector.find("a").first().attr("href")))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(379).toString()), j.$(() => {
                    page.handlePage();
                });
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return NekoSama;
        }));
        const NekoSama = {
            name: "NekoSama",
            domain: "https://www.neko-sama.fr",
            languages: [ "French" ],
            type: "anime",
            isSyncPage: url => !!j.$("#watch").length,
            sync: {
                getTitle: url => j.$(".details > div > h1 > a").text(),
                getIdentifier(url) {
                    const urlPart5 = utils.urlPart(url, 5);
                    if (!urlPart5) return "";
                    const identifierMatches = urlPart5.match(/^\d*/);
                    return identifierMatches && 0 !== identifierMatches.length ? identifierMatches[0] : "";
                },
                getOverviewUrl: url => NekoSama.domain + (j.$(".details > div > h1 > a").attr("href") || ""),
                getEpisode(url) {
                    const headerElementText = j.$("#watch > div > div.row.no-gutters.anime-info > div.info > div > div > h2").text();
                    return headerElementText ? Number(headerElementText.split(" Episode ").pop()) : NaN;
                },
                nextEpUrl: url => utils.absoluteLink(j.$("#watch > div > div:nth-child(2) > div > div.item.right > a.ui.button.small.with-svg-right").attr("href"), NekoSama.domain)
            },
            overview: {
                getTitle: url => utils.getBaseText($("#head > div.content > div > div > div > h1")),
                getIdentifier: url => NekoSama.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("#head > div.content > div > div > div > div").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#stats > div > div.episodes > div.row.no-gutters.js-list-episode-container > div > div > div.text"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), NekoSama.domain),
                    elementEp: selector => Number(selector.find("a").first().text().replace(/\D+/, ""))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(381).toString()), utils.waitUntilTrue((function() {
                    return j.$("#stats,#watch").length;
                }), (function() {
                    page.handlePage(), j.$(".ui.toggle.checkbox, #stats > div > div.episodes > div > div").click((function() {
                        setTimeout((function() {
                            page.handleList();
                        }), 500);
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeZone;
        }));
        const AnimeZone = {
            name: "AnimeZone",
            domain: "https://www.animezone.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage: url => void 0 !== url.split("/")[5],
            sync: {
                getTitle: url => j.$(".category-description .panel-title").attr("title") || "",
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$(".all-episodes > a").attr("href"), AnimeZone.domain),
                getEpisode: url => Number(url.split("/")[5]),
                nextEpUrl(url) {
                    const href = j.$(".next a").attr("href");
                    return href ? utils.absoluteLink(href, AnimeZone.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$(".category-description .panel-title").attr("title") || "",
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$(".ratings .panel-body .description").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("table.episodes > tbody > tr"),
                    elementUrl(selector) {
                        const anchorHref = selector.find("td:nth-child(6) > a").first().attr("href");
                        return anchorHref ? utils.absoluteLink(anchorHref.replace(/^../gm, ""), AnimeZone.domain) : "";
                    },
                    elementEp(selector) {
                        var _a, _b, _c;
                        return Number(null === (_c = null === (_b = null === (_a = selector.find("td:nth-child(6) > a").first().attr("href")) || void 0 === _a ? void 0 : _a.split("/")) || void 0 === _b ? void 0 : _b[3]) || void 0 === _c ? void 0 : _c.replace(/\D+/, ""));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(383).toString()), j.$(document).ready((function() {
                    page.handlePage();
                    const target = j.$("#episode")[0], config = {
                        attributes: !1,
                        childList: !0,
                        subtree: !0
                    }, observer = new MutationObserver((function(mutationsList, observer) {
                        for (const mutation of mutationsList) {
                            if ("childList" !== mutation.type) return;
                            const srcElement = document.querySelector("#episode a,  #episode iframe");
                            if (!srcElement) return;
                            const src = (srcElement instanceof HTMLAnchorElement ? srcElement.href : srcElement.src).replace(/^http:\/\//i, "https://"), embedContainer = document.querySelector("#episode .embed-container");
                            if (!embedContainer) return;
                            embedContainer.innerHTML = "";
                            const iframe = document.createElement("iframe");
                            iframe.src = src, iframe.width = "100%", iframe.height = "100%", iframe.setAttribute("allowfullscreen", "true"), 
                            embedContainer.append(iframe), observer.disconnect();
                        }
                    }));
                    j.$(".btn.btn-xs.btn-success").each((function(i, e) {
                        j.$(e).click((function() {
                            observer.observe(target, config);
                        }));
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeOdcinki;
        }));
        const AnimeOdcinki = {
            name: "AnimeOdcinki",
            domain: "https://anime-odcinki.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage: url => void 0 !== url.split("/")[5],
            sync: {
                getTitle: url => j.$(".field-name-field-tytul-anime a").text(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$(".field-name-field-tytul-anime a").attr("href"), AnimeOdcinki.domain),
                getEpisode: url => parseInt(url.split("/")[5]),
                nextEpUrl: url => j.$("#video-next").attr("href")
            },
            overview: {
                getTitle: url => j.$(".page-header").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("#user-anime-top").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.view-content > ul > li.lista_odc_tytul_pozycja"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp(selector) {
                        var _a, _b, _c;
                        return Number(null === (_c = null === (_b = null === (_a = selector.find("a").first().attr("href")) || void 0 === _a ? void 0 : _a.split("/")) || void 0 === _b ? void 0 : _b[5]) || void 0 === _c ? void 0 : _c.match(/\d+/gim));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(385).toString()), j.$(document).ready((function() {
                    void 0 !== page.url.split("/")[5] ? page.handlePage() : utils.waitUntilTrue((function() {
                        return j.$("div.view-content").length;
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Animeflix;
        }));
        const Animeflix = {
            name: "Animeflix",
            domain: "https://animeflix.io",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => utils.getBaseText($("h4.title.text-truncate, h4.headline.text-truncate").first()).replace("()", "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => `${Animeflix.domain}/shows/${Animeflix.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/episode-\d*-/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("div.flex.xs12.lg8 > h1").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.my-3").first().after(j.html(`<div class="container"> ${selector}</div>`));
                }
            },
            init(page) {
                function check() {
                    "shows" === page.url.split("/")[3] && utils.waitUntilTrue((function() {
                        return !!(j.$("h4.title.text-truncate").text() || j.$("h4.headline.text-truncate").text() || j.$("div.flex.xs12.lg8 > h1").text());
                    }), (function() {
                        page.handlePage();
                    }));
                }
                api.storage.addStyle(__webpack_require__(387).toString()), check(), utils.urlChangeDetect((function() {
                    page.reset(), check();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return serimanga;
        }));
        const serimanga = {
            name: "serimanga",
            domain: "https://serimanga.com",
            languages: [ "Turkish" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => utils.getBaseText($("#reader > div.read-top-menu > div.rtm-logo > a.back.text-white")).trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => j.$("#reader > div.read-top-menu > div.rtm-logo > a.back.text-white").attr("href") || "",
                getEpisode: url => parseInt(utils.urlPart(url, 5)),
                nextEpUrl: url => j.$("#chapterButtons2 > div > div:nth-child(2) > a").first().attr("href")
            },
            overview: {
                getTitle: url => j.$("div.seri-img > div > div > div.name").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("div.sub-top-text").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(389).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return mangadenizi;
        }));
        const mangadenizi = {
            name: "mangadenizi",
            domain: "https://mangadenizi.com",
            languages: [ "Turkish" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => j.$("#navbar-collapse-1 > ul > li:nth-child(1) > a").text(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => j.$("#navbar-collapse-1 > ul > li:nth-child(1) > a").attr("href") || "",
                getEpisode: url => Number(url.split("/")[5]),
                nextEpUrl(url) {
                    let matches = j.$("body > div.container-fluid > script")[0].innerHTML.match(/next_chapter\s*=\s*".*"/gim);
                    return matches && 0 !== matches.length ? (matches = matches[0].match(/"(.*?)"/gm), 
                    matches && 0 !== matches.length ? matches[0].replace(/(^"|"$)/gm, "") : "") : "";
                }
            },
            overview: {
                getTitle: url => j.$("h2.widget-title").first().text(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("h2.widget-title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.chapters > li"),
                    elementUrl: selector => utils.absoluteLink(selector.find("h5 > a").first().attr("href"), mangadenizi.domain),
                    elementEp: selector => utils.absoluteLink(selector.find("h5 > a").first().attr("href"), mangadenizi.domain).split("/")[5]
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(391).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return moeclip;
        }));
        const moeclip = {
            name: "moeclip",
            domain: "https://moeclip.com",
            languages: [ "Indonesian" ],
            type: "anime",
            isSyncPage: url => !(!j.$("div.video-content")[0] || !j.$("h1.entry-title.title-font")[0]),
            sync: {
                getTitle: url => j.$("header h1.entry-title.title-font").text().replace(/\d+\ssub\s*indo/gim, "").trim(),
                getIdentifier: url => url.split("/")[3].replace(/-\d*-sub-indo.*/gim, "").trim(),
                getOverviewUrl: url => `${moeclip.domain}/anime/${moeclip.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[3];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-\d*-sub-indo.*/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl: url => j.$("div.episode-nav > div.select-episode > div:nth-child(3) > a").first().attr("href")
            },
            overview: {
                getTitle: url => utils.getBaseText($("#data2 > div:nth-child(2)")).trim().replace(/:[ ]*/g, ""),
                getIdentifier: url => url.split("/")[4].replace(/-sub-indo.*/gim, "").trim(),
                uiSelector(selector) {
                    j.$("div.entry-meta").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("li.episode-list"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div > a").first().attr("href"), moeclip.domain),
                    elementEp: selector => Number(selector.find("div > a").first().text().replace(/\D+/, ""))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(393).toString()), j.$(document).ready((function() {
                    ("anime" === page.url.split("/")[3] || j.$("div.video-content")[0] && j.$("h1.entry-title.title-font")[0] && j.$("#plv > div.contentsembed > div.episode-nav > div > div.eps-nav.pilih")[0]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return mangalivre;
        }));
        const mangalivre = {
            name: "mangalivre",
            domain: "https://mangalivre.net",
            languages: [ "Portuguese" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[6] && url.split("/")[6].length > 0,
            sync: {
                getTitle: url => j.$("div.series-title > span.title").text(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                getOverviewUrl: url => mangalivre.domain + (j.$("div.series-info-popup-container > div > div > div.series-cover > a").attr("href") || ""),
                getEpisode: url => parseInt(j.$("span.current-chapter > em[reader-current-chapter]").text()),
                nextEpUrl(url) {
                    const href = utils.absoluteLink(j.$("ul.chapter-list > li.selected").prev("li").find("a").attr("href"), mangalivre.domain);
                    if (href) return href;
                }
            },
            overview: {
                getTitle: url => j.$("#series-data > div.series-info.touchcarousel > span.series-title > h1").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("#series-data > div.series-info.touchcarousel > span.series-desc").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(395).toString()), j.$(document).ready((function() {
                    ("manga" === page.url.split("/")[3] || "ler" === page.url.split("/")[3]) && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return tmofans;
        }));
        const tmofans = {
            name: "tmofans",
            domain: [ "https://lectortmo.com", "https://tmofans.com" ],
            languages: [ "Spanish" ],
            type: "manga",
            isSyncPage: url => "viewer" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$("#app > section:nth-child(2) > div > div > h1").text().trim(),
                getIdentifier(url) {
                    const identifierAnchorHref = j.$("nav.navbar > div > div:nth-child(2) > a").last().attr("href");
                    return identifierAnchorHref ? identifierAnchorHref.split("/")[6] : "";
                },
                getOverviewUrl: url => j.$("nav.navbar > div > div:nth-child(2) > a").last().attr("href") || "",
                getEpisode(url) {
                    const episodePart = utils.getBaseText($("#app > section:nth-child(2) > div > div > h2").first()).trim();
                    if (episodePart.length) {
                        const temp = episodePart.match(/CapÃ­tulo *\d*/gim);
                        if (null !== temp) return temp[0].replace(/\D+/g, "");
                    }
                    return "";
                }
            },
            overview: {
                getTitle: url => utils.getBaseText($("h1.element-title.my-2").first()).trim(),
                getIdentifier: url => utils.urlPart(url, 6) || "",
                uiSelector(selector) {
                    j.$("header.container-fluid").first().after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(397).toString()), j.$(document).ready((function() {
                    ("library" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 || "viewer" === page.url.split("/")[3]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return unionmangas;
        }));
        const unionmangas = {
            name: "unionmangas",
            domain: [ "https://unionleitor.top", "https://unionmangas.top" ],
            languages: [ "Portuguese" ],
            type: "manga",
            isSyncPage: url => "leitor" === url.split("/")[3] && void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => utils.getBaseText($("body > div.breadcrumbs > div > div > a:nth-child(3)")).trim(),
                getIdentifier(url) {
                    const identifierAnchorHref = j.$("body > div.breadcrumbs > div > div > a:nth-child(3)").attr("href");
                    return identifierAnchorHref ? identifierAnchorHref.split("/")[4].toLowerCase() : "";
                },
                getOverviewUrl: url => j.$("body > div.breadcrumbs > div > div > a:nth-child(3)").attr("href") || "",
                getEpisode: url => parseInt(utils.urlPart(url, 5)),
                nextEpUrl(url) {
                    const newUrl = url.split(/[?#]/)[0], num = $("#capitulo_trocar").find("option:selected").next().attr("value");
                    if (!num) return "";
                    const href = newUrl.replace(/\d+$/, num);
                    return void 0 !== num && href !== newUrl ? utils.absoluteLink(href, unionmangas.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("div.row > div.col-md-12 > h2").first().text().trim(),
                getIdentifier(url) {
                    const urlPart4 = utils.urlPart(url, 4);
                    return urlPart4 ? urlPart4.toLowerCase() : "";
                },
                uiSelector(selector) {
                    j.$("div.row > div.col-md-12 > h2").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.row.lancamento-linha"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div > a").first().attr("href"), unionmangas.domain),
                    elementEp: selector => utils.absoluteLink(selector.find("div > a").first().attr("href"), unionmangas.domain).split("/")[5]
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(399).toString()), j.$(document).ready((function() {
                    "leitor" !== page.url.split("/")[3] && "perfil-manga" !== page.url.split("/")[3] && "manga" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaPlus;
        }));
        const MangaPlus = {
            name: "MangaPlus",
            domain: "https://mangaplus.shueisha.co.jp",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "viewer" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("h1.Navigation-module_title_180OT").first().text(),
                getIdentifier(url) {
                    const identifierHref = j.$("h1.Navigation-module_title_180OT").first().parent().attr("href");
                    return !identifierHref || identifierHref.length < 3 ? "" : identifierHref.split("/")[2];
                },
                getOverviewUrl: url => MangaPlus.domain + (j.$("h1.Navigation-module_title_180OT").first().parent().attr("href") || ""),
                getEpisode(url) {
                    const episodeText = j.$("p.Navigation-module_chapterTitle_20juD").first().text();
                    return episodeText ? Number(episodeText.replace(/\D+/g, "")) : NaN;
                }
            },
            overview: {
                getTitle: url => j.$("h1.TitleDetailHeader-module_title_Iy33M").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.TitleDetail-module_flexContainer_1oGb4").first().before(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(401).toString()), "viewer" !== page.url.split("/")[3] && "titles" !== page.url.split("/")[3] || utils.waitUntilTrue((function() {
                    return !(!j.$("h1.Navigation-module_title_180OT").text() && !j.$("h1.TitleDetailHeader-module_title_Iy33M").text());
                }), (function() {
                    page.handlePage();
                })), utils.urlChangeDetect((function() {
                    page.reset(), "viewer" !== page.url.split("/")[3] && "titles" !== page.url.split("/")[3] || utils.waitUntilTrue((function() {
                        return !(!j.$("h1.Navigation-module_title_180OT").text() && !j.$("h1.TitleDetailHeader-module_title_Iy33M").text());
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return JapScan;
        }));
        const JapScan = {
            name: "JapScan",
            domain: "https://www.japscan.ws",
            languages: [ "French" ],
            type: "manga",
            isSyncPage: url => "lecture-en-ligne" === url.split("/")[3],
            sync: {
                getTitle: url => utils.getBaseText($("ol.breadcrumb > li:nth-child(3) > a").first()).trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => JapScan.domain + (j.$("ol.breadcrumb > li:nth-child(3) > a").first().attr("href") || ""),
                getEpisode: url => Number(url.split("/")[5]),
                nextEpUrl(url) {
                    const anchorHref = j.$("div.clearfix > p > a").last().attr("href") || "";
                    return "Chapitre Suivant" === j.$("div.clearfix > p > span").last().text() && anchorHref.length ? JapScan.domain + (j.$("div.clearfix > p > a").last().attr("href") || "") : "";
                }
            },
            overview: {
                getTitle: url => j.$("div#main > div.card > div.card-body > h1").first().text().replace(/^[a-z]+/gim, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div#main > div.card > div.card-body > h1").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#chapters_list > div > div.chapters_list.text-truncate"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), JapScan.domain),
                    elementEp(selector) {
                        var _a, _b, _c;
                        return Number(null === (_c = null === (_b = null === (_a = selector.find("a").first().attr("href")) || void 0 === _a ? void 0 : _a.split("/")) || void 0 === _b ? void 0 : _b[3]) || void 0 === _c ? void 0 : _c.match(/\d+/gim));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(403).toString()), j.$(document).ready((function() {
                    ("manga" === page.url.split("/")[3] || "lecture-en-ligne" === page.url.split("/")[3] && j.$("div#image").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Goyabu;
        }));
        const Goyabu = {
            name: "Goyabu",
            domain: "https://goyabu.com",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => "videos" === url.split("/")[3],
            isOverviewPage: url => "assistir" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.sidebar-holder.kanra-info > span:nth-child(2)").text(),
                getIdentifier: url => Goyabu.sync.getOverviewUrl(url).split("/")[4],
                getOverviewUrl: url => j.$('div.kanra-controls > a[href*="/assistir/"]').attr("href") || "",
                getEpisode: url => getEpisode(j.$("#main > div > div.left-single > h1").text()),
                nextEpUrl: url => j.$('div.kanra-controls > a[rel="next"]').first().attr("href")
            },
            overview: {
                getTitle: url => j.$("div.anime-title > h1").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.anime-single-index.episodes-container").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.anime-single-index.episodes-container div.anime-episode"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), Goyabu.domain),
                    elementEp: selector => getEpisode(selector.find("h3").text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(405).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
        function getEpisode(text) {
            if (0 === text.length) return NaN;
            const matches = text.match(/(episÃ³dio|episodio)\s*\d+/gim);
            return matches && 0 !== matches.length ? Number(matches[0].replace(/\D+/g, "")) : 1;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimesVision;
        }));
        const AnimesVision = {
            name: "AnimesVision",
            domain: "https://animesvision.biz",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => void 0 !== url.split("/")[5],
            sync: {
                getTitle: url => utils.getBaseText($("div.goblock.play-anime > div.gobread > ol > li.active > h1")).replace(/Dublado/gim, "").replace(/[\s-\s]*$/, "").trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => j.$("#episodes-sv-1 > li > div.sli-name > a").attr("href") || "",
                getEpisode(url) {
                    const episodetemp = utils.urlPart(url, 5).replace(/\D+/, "");
                    return episodetemp ? Number(episodetemp) : 1;
                },
                nextEpUrl: url => utils.absoluteLink(j.$("#nextEp").attr("href"), AnimesVision.domain)
            },
            overview: {
                getTitle: url => utils.getBaseText($("div.goblock.detail-anime > div.gobread > ol > li.active > span")).replace(/Dublado/gim, "").replace(/[\s-\s]*$/, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.goblock.detail-anime > div.goblock-content.go-full > div.detail-content").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#episodes-sv-1 > li.ep-item"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp(selector) {
                        var _a, _b, _c;
                        return Number(null === (_c = null === (_b = null === (_a = selector.find("a").first().attr("href")) || void 0 === _a ? void 0 : _a.split("/")) || void 0 === _b ? void 0 : _b[5]) || void 0 === _c ? void 0 : _c.replace(/\D+/, ""));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(407).toString()), j.$(document).ready((function() {
                    "animes" !== page.url.split("/")[3] && "filmes" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, con, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Hulu;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let huluId, name, nextEp, episode = 0, season = 0, movie = !1;
        const Hulu = {
            name: "Hulu",
            domain: "https://www.hulu.com",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "watch" === url.split("/")[3],
            sync: {
                getTitle: url => name,
                getIdentifier: url => `${huluId}?s=${season}`,
                getOverviewUrl: url => movie ? `${Hulu.domain}/movie/${huluId}` : `${Hulu.domain}/series/${huluId}`,
                getEpisode: url => episode,
                nextEpUrl: url => nextEp
            },
            overview: {
                getTitle(url) {
                    const currentSeason = j.$("div.DetailsDropdown > div > div > button.Select__control > div.Select__single-value, div.DetailsDropdown > div > div > div.Select__control > div.Select__single-value").text().replace(/\D+/g, "");
                    return void 0 !== currentSeason && Number(currentSeason) > 1 ? `${name} season ${currentSeason}` : name;
                },
                getIdentifier: url => movie ? (con.log("movie"), huluId + "?s=1") : (con.log("not a movie"), 
                `${huluId}?s=${j.$("div.DetailsDropdown > div > div > button.Select__control > div.Select__single-value, div.DetailsDropdown > div > div > div.Select__control > div.Select__single-value").first().text().replace(/\D+/g, "")}`),
                uiSelector(selector) {
                    j.$("#LevelTwo__scroll-area > div > div > div.Details__subnav").first().before(j.html(selector));
                }
            },
            init(page) {
                function startCheck() {
                    $("html").addClass("miniMAL-hide"), "watch" !== page.url.split("/")[3] && "series" !== page.url.split("/")[3] && "movie" !== page.url.split("/")[3] || utils.waitUntilTrue((function() {
                        return "series" !== page.url.split("/")[3] || j.$("div.DetailsDropdown > div > div > button.Select__control > div.Select__single-value, div.DetailsDropdown > div > div > .Select__control > div.Select__single-value").first().text();
                    }), (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            (yield function() {
                                return __awaiter(this, void 0, void 0, (function*() {
                                    const tempId = utils.urlPart(window.location.href, 4), reqUrl = "https://discover.hulu.com/content/v3/entity?language=en&eab_ids=" + tempId.substring(tempId.length - 36, tempId.length), response = yield api.request.xhr("GET", reqUrl), json = JSON.parse(response.responseText);
                                    if (!json.items[0].genre_names.includes("Anime") && !json.items[0].genre_names.includes("Animation")) return !1;
                                    if (episode = parseInt(json.items[0].number), json.items[0].season ? (huluId = json.items[0].series_id, 
                                    season = parseInt(json.items[0].season), name = json.items[0].series_name, movie = !1) : (huluId = json.items[0].id, 
                                    season = 1, name = json.items[0].name, "series" !== window.location.href.split("/")[3] && (movie = !0)), 
                                    season >= 1 && !movie && "watch" === window.location.href.split("/")[3]) {
                                        const reqUrl2 = `https://discover.hulu.com/content/v4/hubs/series/${huluId}/season/${season}?offset=0&limit=999&schema=9&referralHost=production`;
                                        return api.request.xhr("GET", reqUrl2).then(r => {
                                            const json2 = JSON.parse(r.responseText);
                                            return season > 1 && (episode = episode - json2.items[0].number + 1, name = `${name} season ${season}`), 
                                            nextEp = void 0 !== json2.items[episode + 1] ? `${Hulu.domain}/watch/${json2.items[episode + 1].id}` : void 0, 
                                            con.log(huluId), con.log(name), con.log(`episode: ${episode} season: ${season}`), 
                                            void 0 !== huluId;
                                        });
                                    }
                                    return con.log(huluId), con.log(name), con.log(`episode: ${episode} season: ${season}`), 
                                    void 0 !== huluId;
                                }));
                            }()) && (page.handlePage(), $("html").removeClass("miniMAL-hide"), "series" === page.url.split("/")[3] && $("body").on("DOMSubtreeModified", "div.DetailsDropdown > div > div > button.Select__control > div.Select__single-value", (function() {
                                page.reset(), page.handlePage(), $("html").removeClass("miniMAL-hide");
                            })));
                        }));
                    }));
                }
                api.storage.addStyle(__webpack_require__(409).toString()), startCheck(), utils.urlChangeDetect((function() {
                    page.reset(), con.log("url change"), startCheck();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(4), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Hidive;
        }));
        const Hidive = {
            name: "Hidive",
            domain: "https://www.hidive.com",
            languages: [ "English", "Spanish", "Portuguese", "French", "German", "Arabic", "Italian", "Russian" ],
            type: "anime",
            isSyncPage: url => "stream" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("#TitleDetails").text(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => Hidive.domain + (j.$("#TitleDetails").attr("href") || ""),
                getEpisode(url) {
                    const temp = url.split("/")[5];
                    return /^\d/.test(temp) ? Number(temp.slice(8)) : Number(temp.slice(4));
                },
                nextEpUrl(url) {
                    const nextEp = j.$("#StreamNextEpisode .episode-play").attr("data-key");
                    return nextEp ? nextEp !== url.split("/")[5] ? `${Hidive.domain}/stream/${j.$("#StreamNextEpisode .episode-play").attr("data-videotitle")}/${nextEp}` : void 0 : nextEp;
                }
            },
            overview: {
                getTitle: url => j.$("div.text-container a").text().replace("Score It", "").trim(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.details").first().after(j.html(`<div class="container"> ${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.episode-slider > div > div > div.cell > div:nth-child(1) > div.hitbox").filter((function() {
                        if (j.$(this).find("div.na").length) return !1;
                        const playerUrl = j.$(this).find(".player > a").attr("data-playurl") || "";
                        return !(!j.$(this).find(".player > a").attr("data-playurl") || window.location.href.split("/")[4] !== playerUrl.split("/")[4]);
                    })),
                    elementUrl: selector => selector.find("div.player > a").attr("data-playurl") || "",
                    elementEp(selector) {
                        const temp = selector.find("div.player > a").attr("data-key");
                        return temp && /^\d/.test(temp) ? Number(temp.slice(8)) : temp ? Number(temp.slice(4)) : 0;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(411).toString()), j.$(document).ready((function() {
                    "stream" !== page.url.split("/")[3] && "tv" !== page.url.split("/")[3] && "movies" !== page.url.split("/")[3] || void 0 === page.url.split("/")[4] || (page.handlePage(), 
                    utils.urlChangeDetect((function() {
                        con.info("Check"), page.handlePage();
                    })));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return FallenAngels;
        }));
        const FallenAngels = {
            name: "FallenAngels",
            domain: "https://manga.fascans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => j.$("#navbar-collapse-1 > ul > li:nth-child(1) > a").text().replace(/manga$/gi, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$("#navbar-collapse-1 > ul > li:nth-child(1) > a").attr("href") || "",
                getEpisode: url => Number(url.split("/")[5]),
                nextEpUrl(url) {
                    const nextChapterMatches = j.$("body > div.container-fluid > script").html().match(/next_chapter\s*=\s*".*"/gim);
                    if (!nextChapterMatches || 0 === nextChapterMatches.length) return "";
                    const matchesOfRestOfNextChapter = nextChapterMatches[0].match(/"(.*?)"/gm);
                    return matchesOfRestOfNextChapter && 0 !== matchesOfRestOfNextChapter.length ? matchesOfRestOfNextChapter[0].replace(/(^"|"$)/gm, "") : "";
                }
            },
            overview: {
                getTitle: url => j.$("h2.widget-title").first().text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("h2.widget-title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.chapters > li"),
                    elementUrl: selector => utils.absoluteLink(selector.find("h5 > a").first().attr("href"), FallenAngels.domain),
                    elementEp: selector => utils.absoluteLink(selector.find("h5 > a").first().attr("href"), FallenAngels.domain).split("/")[5]
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(413).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return PrimeVideo;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let thisData = null;
        const PrimeVideo = {
            name: "Amazon Prime Video",
            domain: "https://www.primevideo.com",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => !(!thisData || !thisData.ep),
            sync: {
                getTitle: url => thisData && thisData.title ? $("<div/>").html(j.html(thisData.title)).text() : "",
                getIdentifier(url) {
                    if (thisData && thisData.id) return thisData.id;
                    throw "No Id Found";
                },
                getOverviewUrl(url) {
                    if (thisData && thisData.id) return "https://www.primevideo.com/detail/" + thisData.id;
                    throw "No Id Found";
                },
                getEpisode: url => thisData && thisData.ep ? thisData.ep : 1
            },
            overview: {
                getTitle: url => PrimeVideo.sync.getTitle(url),
                getIdentifier: url => PrimeVideo.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("div.av-detail-section > div > h1").first().before(j.html(selector));
                }
            },
            init(page) {
                let epId;
                function ready() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        if (thisData = null, epId = void 0, page.reset(), $("html").addClass("miniMAL-hide"), 
                        "detail" === utils.urlPart(window.location.href, 3)) {
                            const tempData = yield getApi(window.location.href);
                            if (!tempData.genres.includes("av_genre_anime")) return void con.error("Not an Anime");
                            thisData = tempData, $("html").removeClass("miniMAL-hide"), page.handlePage();
                        }
                    }));
                }
                api.storage.addStyle(__webpack_require__(415).toString()), j.$(document).ready((function() {
                    ready();
                })), utils.urlChangeDetect((function() {
                    ready();
                })), utils.changeDetect(() => {
                    j.$(".dv-player-fullscreen").length || ready();
                }, () => j.$(".dv-player-fullscreen").length), utils.changeDetect(() => __awaiter(this, void 0, void 0, (function*() {
                    if (!epId) return void con.error("No Episode Id found");
                    thisData = null, page.reset(), $("html").addClass("miniMAL-hide");
                    const tempData = yield getApi(utils.absoluteLink(epId.vidUrl, PrimeVideo.domain), epId.internalId);
                    if (!tempData.genres.includes("av_genre_anime")) return void con.error("Not an Anime");
                    tempData.ep = null;
                    const episodeText = j.$(".dv-player-fullscreen .webPlayer .subtitle").text();
                    if (episodeText.length) {
                        const temp = episodeText.match(/ep..\d*/gim);
                        null !== temp && (tempData.ep = parseInt(temp[0].replace(/\D+/g, "")));
                    }
                    thisData = tempData, $("html").removeClass("miniMAL-hide"), page.handlePage();
                })), () => {
                    const tempT = j.$(".dv-player-fullscreen .webPlayer .subtitle").text();
                    if (tempT) return tempT;
                }), $("html").on("click", "a[data-video-type]", (function(e) {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const vidUrl = j.$(this).attr("href"), internalId = j.$(this).attr("data-title-id");
                        epId = {
                            vidUrl: vidUrl,
                            internalId: internalId
                        };
                    }));
                }));
            }
        };
        function getApi(url, epId = 0) {
            con.log("Request Info", url, epId);
            const data = {
                id: void 0,
                title: void 0,
                genres: [],
                ep: null,
                gti: void 0
            }, fns = [ function(e) {
                if (e && e.props && e.props.state && e.props.state.self && Object.keys(e.props.state.self).length) {
                    const self = Object.values(e.props.state.self)[0];
                    self && ("season" === self.titleType || "movie" === self.titleType) && self.compactGTI && self.gti && (data.id = self.compactGTI, 
                    data.gti = self.gti);
                }
            }, function(e) {
                if (e && e.props && e.props.state && e.props.state.detail && e.props.state.detail.detail && Object.keys(e.props.state.detail.detail).length) {
                    let detail;
                    if (detail = data.gti && Object.prototype.hasOwnProperty.call(e.props.state.detail.detail, data.gti) ? e.props.state.detail.detail[data.gti] : Object.values(e.props.state.detail.detail)[0], 
                    !detail || "season" !== detail.titleType && "movie" !== detail.titleType || detail.title && (data.title = detail.title), 
                    detail && !data.genres.length && detail.genres && detail.genres.length && (data.genres = detail.genres.map(e2 => e2.id)), 
                    epId && Object.prototype.hasOwnProperty.call(e.props.state.detail.detail, epId)) {
                        const epDetail = e.props.state.detail.detail[epId];
                        epDetail.episodeNumber && (data.ep = epDetail.episodeNumber), "Movie" === epDetail.entityType && (data.ep = 1), 
                        !data.genres.length && epDetail.genres && epDetail.genres.length && (data.genres = epDetail.genres.map(e3 => e3.id));
                    }
                }
            } ];
            return api.request.xhr("GET", url).then(response => {
                const templateMatches = response.responseText.match(/<script type="text\/template">.*(?=<\/script>)/g);
                if (templateMatches && templateMatches.length > 0) {
                    const templates = templateMatches.map(e => JSON.parse(e.replace('<script type="text/template">', "")));
                    fns.forEach(fn => {
                        templates.forEach(fn);
                    });
                }
                return con.log("result", data), data;
            });
        }
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaKatana;
        }));
        let obfusList = !1;
        const MangaKatana = {
            name: "MangaKatana",
            domain: "http://mangakatana.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => utils.getBaseText($("#breadcrumb_wrap > ol > li:nth-child(2) > a > span")).trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$("#breadcrumb_wrap > ol > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/c\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl() {
                    const nextEpisodeAnchor = document.querySelector("a.nav_button.next");
                    return (null == nextEpisodeAnchor ? void 0 : nextEpisodeAnchor.href.startsWith("javascript")) ? "" : nextEpisodeAnchor.href;
                }
            },
            overview: {
                getTitle: url => j.$("div.info > h1.heading").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#single_book").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => void 0 !== j.$("div.chapters:not('.uk-hidden') > table > tbody > tr") && j.$("div.chapters:not('.uk-hidden') > table > tbody > tr").length ? j.$("div.chapters:not('.uk-hidden') > table > tbody > tr") : void 0 === window.location.href.split("/")[5] && void 0 !== j.$("#single_book > script").prev().children().children() && j.$("#single_book > script").prev().children().children().length ? (obfusList = !0, 
                    j.$("#single_book > script").prev().children().children()) : j.$(".nowaythisexists"),
                    elementUrl: selector => obfusList ? utils.absoluteLink(selector.find("div > div > a").first().attr("href"), MangaKatana.domain) : utils.absoluteLink(selector.find("td > div.chapter > a").first().attr("href"), MangaKatana.domain),
                    elementEp: selector => obfusList ? MangaKatana.sync.getEpisode(String(selector.find("div > div > a").first().attr("href"))) : MangaKatana.sync.getEpisode(String(selector.find("td > div.chapter > a").first().attr("href")))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(417).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return manga4life;
        }));
        const manga4life = {
            name: "manga4life",
            domain: "https://manga4life.com",
            languages: [ "English" ],
            type: "manga",
            database: "MangaSee",
            isSyncPage: url => "read-online" === url.split("/")[3],
            isOverviewPage: url => "manga" === url.split("/")[3],
            sync: {
                getTitle: url => utils.getBaseText($("div.MainContainer > div.container > div.row > div.Column > a").first()).trim(),
                getIdentifier: url => utils.urlPart(manga4life.sync.getOverviewUrl(url), 4) || "",
                getOverviewUrl: url => utils.absoluteLink(j.$("div.MainContainer > div.container > div.row > div.Column > a").first().attr("href"), manga4life.domain),
                getEpisode: url => utils.getBaseText($("div.MainContainer > div.container > div.row > div.Column:nth-child(2) > button").first()).match(/\d+/gim)
            },
            overview: {
                getTitle: url => j.$("div.BoxBody > div.row > div.top-5 > ul > li:nth-child(1) > h1").first().text(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("div.BoxBody > div.row > div.top-5 > ul > li:nth-child(1) > h1").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => (j.$("div.BoxBody > div.list-group > div.list-group-item.ShowAllChapters").click(), 
                    j.$("div.BoxBody > div.list-group > a.list-group-item.ChapterLink")),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), manga4life.domain),
                    elementEp: selector => Number(selector.find("span").first().text().match(/\d+/gim))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(419).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return manga4life.isSyncPage(page.url) ? manga4life.sync.getTitle(page.url) && manga4life.sync.getEpisode(page.url) : !!manga4life.isOverviewPage(page.url) && (manga4life.overview.getTitle(page.url) && !j.$('a[href$="{{vm.ChapterURLEncode(vm.Chapters[vm.Chapters.length-1].Chapter)}}"]').length);
                    }), (function() {
                        manga4life.isOverviewPage(page.url) && page.handlePage(), manga4life.isSyncPage(page.url) && function(callback, func) {
                            let currentPage = "";
                            const intervalId = setInterval((function() {
                                const temp = func();
                                void 0 !== temp && currentPage !== temp && (currentPage = func(), callback());
                            }), 500);
                            Number(intervalId);
                        }(() => {
                            page.handlePage();
                        }, () => j.$("div.Column.col-lg-2.col-6 button.btn.btn-sm.btn-outline-secondary.ng-binding").first().text().trim());
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return bato;
        }));
        const bato = {
            name: "bato",
            domain: "https://bato.to",
            languages: [ "Many" ],
            type: "manga",
            isSyncPage: url => "chapter" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("h3.nav-title > a").text(),
                getIdentifier: url => utils.urlPart(bato.sync.getOverviewUrl(url), 4) || "",
                getOverviewUrl: url => utils.absoluteLink(j.$("h3.nav-title > a").attr("href"), bato.domain),
                getEpisode(url) {
                    const selectedOptionText = j.$("div.nav-epis > select > optgroup > option:selected").text();
                    if (!selectedOptionText) return NaN;
                    const chapterTextMatches = selectedOptionText.match(/(ch\.|chapter)\D?\d+/i);
                    return chapterTextMatches && 0 !== chapterTextMatches.length ? Number(chapterTextMatches[0].match(/\d+/)) : NaN;
                },
                nextEpUrl(url) {
                    const href = utils.absoluteLink(j.$("div.nav-next > a").first().attr("href"), bato.domain);
                    return "chapter" === href.split("/")[3] ? href : "";
                }
            },
            overview: {
                getTitle: url => j.$("h3.item-title > a").first().text(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("h3.item-title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.episode-list > div.main > div.item"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), bato.domain),
                    elementEp(selector) {
                        const episodeText = selector.find("a > b").text();
                        if (!episodeText) return NaN;
                        const matches = episodeText.match(/(ch\.|chapter)\D?\d+/i);
                        return matches && 0 !== matches.length ? Number(matches[0].match(/\d+/)) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(421).toString()), j.$(document).ready((function() {
                    "chapter" !== page.url.split("/")[3] && "series" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return DreamSub;
        }));
        const DreamSub = {
            name: "DreamSub",
            domain: "https://dreamsub.cc",
            languages: [ "Italian" ],
            type: "anime",
            isSyncPage: url => jsonData.isStreaming,
            sync: {
                getTitle: url => jsonData.animeName,
                getIdentifier: url => jsonData.clean,
                getOverviewUrl: url => jsonData.overview_url,
                getEpisode: url => jsonData.nEpisode,
                nextEpUrl: url => jsonData.nextEpisode ? jsonData.nextEpisode : "",
                getMalUrl: provider => !!jsonData.mal_id && "https://myanimelist.net/anime/" + jsonData.mal_id
            },
            overview: {
                getTitle: url => DreamSub.sync.getTitle(url),
                getIdentifier: url => DreamSub.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("div.detail-content").first().after(j.html(selector));
                },
                getMalUrl: provider => !!jsonData.mal_id && "https://myanimelist.net/anime/" + jsonData.mal_id,
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul#episodes-sv ul.innerSeas > li.ep-item").filter((function(index) {
                        return !$(this).find("div.sli-name > a.disabled").length;
                    })),
                    elementUrl: selector => utils.absoluteLink(selector.find("div.sli-name > a").first().attr("href"), DreamSub.domain),
                    elementEp: selector => parseInt(DreamSub.overview.list.elementUrl(selector).split("/")[5])
                }
            },
            init(page) {
                if (api.storage.addStyle(__webpack_require__(423).toString()), "Verifica che non sei un bot | DreamSub" === document.title) return con.log("loading"), 
                void page.cdn();
                j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return j.$("#syncData").length;
                    }), (function() {
                        jsonData = JSON.parse(j.$("#syncData").text()), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaPark;
        }));
        const MangaPark = {
            name: "MangaPark",
            domain: "https://mangapark.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => !!("comic" === url.split("/")[3] && void 0 !== url.split("/")[6] && "chapter" === url.split("/")[6] || "chapter" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4]),
            isOverviewPage: url => "comic" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => utils.getBaseText($("h3.nav-title > a")).trim(),
                getIdentifier: url => utils.urlPart(MangaPark.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("h3.nav-title > a").attr("href"), MangaPark.domain),
                getEpisode(url) {
                    let string = j.$("#select-chapters option:selected").text(), temp = string.match(/(ch\.|chapter)\D?\d+/i);
                    return null !== temp && (string = temp[0], temp = string.match(/\d+/), null !== temp) ? temp[0] : NaN;
                },
                getVolume(url) {
                    let string = j.$("#select-chapters option:selected").text(), temp = string.match(/(vol\.|volume)\D?\d+/i);
                    return null !== temp && (string = temp[0], temp = string.match(/\d+/), null !== temp) ? temp[0] : NaN;
                },
                nextEpUrl(url) {
                    const next = utils.absoluteLink(j.$("div.nav-next a").attr("href"), MangaPark.domain);
                    return MangaPark.isSyncPage(next) ? next : "";
                }
            },
            overview: {
                getTitle: url => j.$("h3.item-title > a").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.episode-list").first().before(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(425).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimesHouse;
        }));
        let film = !1;
        const AnimesHouse = {
            name: "AnimesHouse",
            domain: "https://animeshouse.net",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => film ? j.$("div.sheader > div.data > h1").text() : j.$("#info > h1.epih1").text(),
                getIdentifier: url => film ? url.split("/")[4] : AnimesHouse.sync.getTitle(url).toLowerCase().replace(/\s+/g, "_"),
                getOverviewUrl: url => film ? url : j.$("div.pag_episodes > div:nth-child(2) > a").attr("href") || "",
                getEpisode: url => film ? 1 : Number(j.$("#info > div > h3.epih3").text().replace(/\D+/g, ""))
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(427).toString()), j.$(document).ready((function() {
                    if (void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0) {
                        if ("episodio" === page.url.split("/")[3]) {
                            const episodeText = j.$("#info > div > h3.epih3").text().toLowerCase();
                            !episodeText.length || -1 === episodeText.indexOf("episÃ³dio") && -1 === episodeText.indexOf("episodio") || -1 !== episodeText.indexOf("ona") || -1 !== episodeText.indexOf("ova") || -1 !== episodeText.indexOf("special") || -1 !== episodeText.indexOf("oad") || -1 !== episodeText.indexOf("oav") || page.handlePage();
                        }
                        "filme" === page.url.split("/")[3] && (film = !0, page.handlePage());
                    }
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeXin;
        }));
        const AnimeXin = {
            name: "AnimeXin",
            domain: "https://animexin.xyz",
            languages: [ "English", "Spanish", "Indonesian", "Portuguese", "Turkish", "Italian" ],
            type: "anime",
            isSyncPage: url => "anime" !== url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a > span").text(),
                getIdentifier: url => AnimeXin.sync.getOverviewUrl(url).split("/")[4],
                getOverviewUrl: url => j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[3];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/-episode-\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl(url) {
                    const href = j.$("div.naveps.bignav > div:nth-child(3) > a").first().attr("href");
                    return href && AnimeXin.sync.getEpisode(url) < AnimeXin.sync.getEpisode(href) ? href : "";
                }
            },
            overview: {
                getTitle: url => j.$("div.infox > h1.entry-title").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.infox > h1.entry-title").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.bixbox.bxcl.epcheck > div.eplister > ul > li"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => AnimeXin.sync.getEpisode(String(selector.find("a").first().attr("href")))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(429).toString()), j.$(document).ready((function() {
                    ("anime" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length && j.$("div.infox > h1.entry-title").length && j.$("div.bixbox.bxcl.epcheck").length || j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a").length && j.$("div.video-content").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MonosChinos;
        }));
        const MonosChinos = {
            name: "MonosChinos",
            domain: "https://monoschinos2.com",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => "ver" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("h1.Title-epi").text().replace(/(\d+\s+)(Sub|Dub)(\s+EspaÃ±ol)$/gi, "").trim(),
                getIdentifier: url => MonosChinos.sync.getOverviewUrl(url).split("/")[4],
                getOverviewUrl: url => j.$("a.btnWeb.green.Current").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[4];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/episodio-\d+/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl(url) {
                    const href = j.$("a.btnWeb:nth-child(3)").first().attr("href");
                    return href && MonosChinos.sync.getEpisode(url) < MonosChinos.sync.getEpisode(href) ? href : "";
                }
            },
            overview: {
                getTitle: url => j.$("h1.Title").text().replace(/(Sub|Dub)(\s+EspaÃ±ol)$/gi, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("h1.Title").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.SerieCaps > a.item"),
                    elementUrl: selector => selector.attr("href") || "",
                    elementEp: selector => MonosChinos.sync.getEpisode(String(selector.attr("href")))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(431).toString()), j.$(document).ready((function() {
                    "ver" !== page.url.split("/")[3] && "anime" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeFire;
        }));
        const AnimeFire = {
            name: "AnimeFire",
            domain: "https://animefire.net",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => "animes" === url.split("/")[3],
            sync: {
                getTitle: url => AnimeFire.sync.getIdentifier(url).replace(/-/g, " "),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl(url) {
                    const oUrl = j.$("li.page-item:nth-child(3) > a.page-link").attr("href");
                    return oUrl && -1 !== oUrl.indexOf("animes") ? oUrl : j.$("li.page-item:nth-child(4) > a.page-link").attr("href") || "";
                },
                getEpisode: url => Number(utils.urlPart(url, 5)),
                nextEpUrl: url => j.$("li.page-item:nth-child(5) > a.page-link > span.prox").length ? buildNext(url, j.$("li.page-item:nth-child(5) > a.page-link").attr("href")) : j.$("li.page-item:nth-child(4) > a.page-link > span.prox").length ? buildNext(url, j.$("li.page-item:nth-child(4) > a.page-link").attr("href")) : ""
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(433).toString()), j.$(document).ready((function() {
                    "animes" === page.url.split("/")[3] && void 0 !== page.url.split("/")[5] && page.handlePage();
                }));
            }
        };
        function buildNext(url, episode) {
            return `${AnimeFire.domain}/animes/${url.split("/")[4]}/${episode}`;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return OtakuFR;
        }));
        const OtakuFR = {
            name: "OtakuFR",
            domain: "https://otakufr.co",
            languages: [ "French" ],
            type: "anime",
            isSyncPage: url => "episode" === url.split("/")[3] && url.split("/")[4].length > 0,
            isOverviewPage: url => "anime" === url.split("/")[3] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$('.single-episode > nav li > a[href*="/anime/"]').text().trim(),
                getIdentifier: url => utils.urlPart(OtakuFR.sync.getOverviewUrl(url), 4) || "",
                getOverviewUrl: url => j.$('.single-episode > nav li > a[href*="/anime/"]').attr("href") || "",
                getEpisode: url => getEp(utils.urlPart(url, 4)),
                nextEpUrl(url) {
                    const nextEp = j.$(".players > div > div:nth-child(3) > a").attr("href");
                    return !nextEp || nextEp.includes("javascript") ? "" : utils.absoluteLink(nextEp, OtakuFR.domain);
                }
            },
            overview: {
                getTitle: url => j.$(".list > div").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".card").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !0,
                    elementsSelector: () => j.$("div.list-episodes.list-group > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), OtakuFR.domain),
                    elementEp: selector => getEp(utils.urlPart(OtakuFR.overview.list.elementUrl(selector), 4))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(435).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
        function getEp(urlPath) {
            const ep = urlPath.match(/(\d+-(vostfr|vf))|((vostfr|vf)-\d+)/i);
            return ep && ep.length ? Number(ep[0].match(/\d+/)[0]) : 1;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Samehadaku;
        }));
        const Samehadaku = {
            name: "Samehadaku",
            domain: "https://samehadaku.vip",
            languages: [ "Indonesian" ],
            type: "anime",
            isSyncPage: url => "anime" !== url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.infoeps > div.episodeinf > div.infoanime > div > div.infox > h2").text(),
                getIdentifier: url => Samehadaku.sync.getOverviewUrl(url).split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$("div.naveps > div.nvs.nvsc > a").attr("href"), Samehadaku.domain),
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[3];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/episode-\d+/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl(url) {
                    const href = j.$("div.naveps > div.nvs.rght > a:not('.nonex')").attr("href");
                    return href ? utils.absoluteLink(href, Samehadaku.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("#infoarea > div > div.infoanime > div.infox > h1.entry-title").text().replace(/subtitle indonesia/i, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("#infoarea > div > div.infoanime > div.infox > h1.entry-title").before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.lstepsiode.listeps > ul > div > div > li"),
                    elementUrl: selector => selector.find("div.epsright > span.eps > a").attr("href") || "",
                    elementEp: selector => Samehadaku.sync.getEpisode(Samehadaku.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(437).toString()), j.$(document).ready((function() {
                    ("anime" === page.url.split("/")[3] || j.$("div.player-area.widget_senction > div.plarea").length && j.$("div.infoeps > div.episodeinf > div.infoanime > div > div.infox > h2").length && j.$("div.naveps > div.nvs.nvsc > a").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TsukiMangas;
        }));
        const TsukiMangas = {
            name: "Tsuki MangÃ¡s",
            domain: "https://www.tsukimangas.com",
            languages: [ "Portuguese" ],
            type: "manga",
            isSyncPage: url => jsonData.isReaderPage,
            sync: {
                getTitle: url => jsonData.mangaName,
                getIdentifier: url => jsonData.identifier,
                getOverviewUrl: url => jsonData.overview_url,
                getEpisode: url => jsonData.currentChapter,
                nextEpUrl: url => jsonData.nextChapter ? jsonData.nextChapter : "",
                getMalUrl: provider => jsonData.myanimelistID && "0" !== jsonData.myanimelistID ? "https://myanimelist.net/manga/" + jsonData.myanimelistID : !("ANILIST" !== provider || !jsonData.anilistID || "0" === jsonData.anilistID) && "https://anilist.co/manga/" + jsonData.anilistID
            },
            overview: {
                getTitle: url => TsukiMangas.sync.getTitle(url),
                getIdentifier: url => TsukiMangas.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("h2").after(j.html(selector));
                },
                getMalUrl: provider => TsukiMangas.sync.getMalUrl(provider),
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.over23 > div.allbox > div.allcap"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), TsukiMangas.domain),
                    elementEp: selector => utils.absoluteLink(selector.find("a").first().attr("href"), TsukiMangas.domain).split("/")[7]
                }
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(439).toString());
                let oldJsonString = "", oldJson = {
                    currentChapter: null,
                    mangaName: null
                };
                utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        if (j.$("#syncData").length) {
                            jsonData = JSON.parse(j.$("#syncData").text());
                            const newJsonString = JSON.stringify(jsonData);
                            if (jsonData.mangaName && newJsonString !== oldJsonString && (oldJson.mangaName !== jsonData.mangaName || oldJson.currentChapter !== jsonData.currentChapter)) return oldJson = jsonData, 
                            oldJsonString = newJsonString, !0;
                        }
                        return !1;
                    }), (function() {
                        Object.prototype.hasOwnProperty.call(jsonData, "isReaderPage") && Object.prototype.hasOwnProperty.call(jsonData, "identifier") && Object.prototype.hasOwnProperty.call(jsonData, "overview_url") && page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return mangatx;
        }));
        const mangatx = {
            name: "mangatx",
            domain: "https://mangatx.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => j.$("div.entry-header.header > div > div.entry-header_wrap > div > div.c-breadcrumb > ol > li:nth-child(2) > a").text().trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => j.$("div.entry-header.header > div > div.entry-header_wrap > div > div.c-breadcrumb > ol > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl: url => j.$("div.entry-header.header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => utils.getBaseText(j.$("div.profile-manga > div > div > div > div.post-title > h1")).trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.page-content-listing.single-page > div > ul > li.wp-manga-chapter"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), mangatx.domain),
                    elementEp: selector => mangatx.sync.getEpisode(mangatx.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(441).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        function GetOverviewAnchor() {
            const anchor = document.querySelector('a[href^="/anime"]');
            if (!anchor) throw Error("Can't find overview anchor element");
            return anchor;
        }
        function RemoveTurkishPhrases(title) {
            return title.replace(/(?: |-)[Ä°i]zle.*/i, "");
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TRanimeizle;
        }));
        const TRanimeizle = {
            name: "TRanimeizle",
            domain: "https://www.tranimeizle.net/",
            languages: [ "Turkish" ],
            type: "anime",
            isSyncPage(_url) {
                const url = new URL(_url), [, path] = url.pathname.split("/");
                return null == path ? void 0 : path.toLowerCase().includes("-bolum-");
            },
            sync: {
                getTitle: () => RemoveTurkishPhrases(GetOverviewAnchor().innerText),
                getOverviewUrl: () => GetOverviewAnchor().href,
                getIdentifier: () => {
                    var _a;
                    const overviewUrl = TRanimeizle.sync.getOverviewUrl(""), identifier = null === (_a = TRanimeizle.overview) || void 0 === _a ? void 0 : _a.getIdentifier(overviewUrl);
                    if (!identifier) throw Error("Can't find identifier");
                    return identifier;
                },
                getEpisode: url => url ? Number(url.replace(/.*-(\d{1,})-.*/, "$1") || void 0) : NaN,
                nextEpUrl: () => {
                    const nextEpisodeAnchor = document.querySelector(".youtube-wrapper .my-15 a:first-child");
                    if (!nextEpisodeAnchor) throw Error("Can't find next episode anchor element");
                    if (nextEpisodeAnchor.href.includes("izle") && nextEpisodeAnchor.href.includes("bolum")) return nextEpisodeAnchor.href;
                }
            },
            overview: {
                getTitle: () => {
                    const titleElement = document.querySelector(".playlist-title > h1");
                    if (!titleElement) throw Error("Can't find title element");
                    return RemoveTurkishPhrases(titleElement.innerText);
                },
                uiSelector: HTML => {
                    const statusBarContainerElement = document.querySelector("div.animeDetail");
                    if (!statusBarContainerElement) throw Error("Can't find the element where the status bar will be placed");
                    const wrapper = document.createElement("div");
                    statusBarContainerElement.prepend(wrapper), wrapper.insertAdjacentHTML("beforebegin", j.html(HTML));
                },
                getIdentifier: url => {
                    const identifier = utils.urlPart(url, 4);
                    return identifier || "";
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".animeDetail-items li.episodeBtn"),
                    elementUrl: selector => {
                        const episodeSlug = selector.data("slug");
                        return TRanimeizle.domain + episodeSlug;
                    },
                    elementEp: episodeElement => {
                        const episodeMeta = $('meta[itemprop="episodeNumber"]', episodeElement);
                        return Number(episodeMeta.attr("content"));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(443).toString()), j.$(() => {
                    var url;
                    (TRanimeizle.isSyncPage(page.url) || (url = page.url, /\/anime\//.test(url))) && page.handlePage();
                });
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Anihub;
        }));
        const Anihub = {
            name: "Anihub",
            domain: "https://anihub.tv",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => jsonData.isStreaming,
            sync: {
                getTitle: url => jsonData.animeName,
                getIdentifier: url => jsonData.id,
                getOverviewUrl: url => jsonData.overview_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.nextEpisode ? jsonData.nextEpisode : "",
                getMalUrl: provider => !(!jsonData.mal_id || "0" === jsonData.mal_id) && "https://myanimelist.net/anime/" + jsonData.mal_id
            },
            overview: {
                getTitle: url => Anihub.sync.getTitle(url),
                getIdentifier: url => Anihub.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("div.aniinfos > p > b").after(j.html(selector));
                },
                getMalUrl: provider => Anihub.sync.getMalUrl(provider)
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(445).toString());
                let oldJson = "";
                utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return !(!j.$("#syncData").length || (jsonData = JSON.parse(j.$("#syncData").text()), 
                        !jsonData.animeName || jsonData.animeName.toLowerCase().includes("carregando") || JSON.stringify(jsonData) === oldJson) || (oldJson = JSON.stringify(jsonData), 
                        0));
                    }), (function() {
                        Object.prototype.hasOwnProperty.call(jsonData, "isStreaming") && Object.prototype.hasOwnProperty.call(jsonData, "id") && Object.prototype.hasOwnProperty.call(jsonData, "overview_url") && page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, con, api) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeStreamingFR;
        }));
        const AnimeStreamingFR = {
            name: "AnimeStreamingFR",
            domain: "https://www.animestreamingfr.fr",
            languages: [ "French" ],
            type: "anime",
            isSyncPage: url => jsonData.isStreaming,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.id,
                getOverviewUrl: url => jsonData.main_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.nextEpisode ? jsonData.nextEpisode : "",
                getMalUrl: provider => jsonData.mal_id ? "https://myanimelist.net/anime/" + jsonData.mal_id : !("ANILIST" !== provider || !jsonData.anilist_id) && "https://anilist.co/anime/" + jsonData.anilist_id,
                uiSelector(selector) {
                    j.$(jsonData.selector_position).first().append(j.html(selector));
                }
            },
            init(page) {
                function checkPage() {
                    page.reset(), page.url.split("/").length > 3 && "anime" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return j.$("#syncData").length;
                    }), (function() {
                        const jsonText = j.$("#syncData").text().replace(/&quot;/g, '"');
                        con.m("json").log(jsonText), jsonData = JSON.parse(jsonText), page.handlePage();
                    }));
                }
                api.storage.addStyle(__webpack_require__(447).toString()), checkPage(), utils.urlChangeDetect((function() {
                    checkPage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Scantrad;
        }));
        const Scantrad = {
            name: "Scantrad",
            domain: "https://scantrad.net",
            languages: [ "French" ],
            type: "manga",
            isSyncPage: url => "mangas" === url.split("/")[3],
            sync: {
                getTitle: url => utils.urlPart(url, 4).replace(/-/g, " ").replace(/(^\w{1})|(\s+\w{1})/g, letter => letter.toUpperCase()),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: () => utils.absoluteLink(j.$(".logo_box").first().attr("href"), Scantrad.domain),
                getEpisode: url => parseInt(utils.urlPart(url, 5)),
                nextEpUrl() {
                    const href = j.$("a.next_chapitre").attr("href");
                    return href && "forum" === href.split("/")[3] ? "" : utils.absoluteLink(href, Scantrad.domain);
                }
            },
            overview: {
                getTitle: () => j.$("div.titre").clone().children().remove().end().text(),
                getIdentifier: url => utils.urlPart(url, 3),
                uiSelector(selector) {
                    j.$(".ct-top").after(j.html(`<h3 class="home-titre" style="margin-top: 31px;">MAL-Sync</h3><div class="new-main">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#chapitres > div.chapitre "),
                    elementUrl: selector => utils.absoluteLink(selector.find('a[href*="/mangas/"]').attr("href") || "", Scantrad.domain),
                    elementEp: selector => Scantrad.sync.getEpisode(Scantrad.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(449).toString()), j.$(document).ready((function() {
                    ("mangas" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] || j.$("body > div.main-fiche > div.mf-chapitre > div.ct-top > div.info > div.titre").length && j.$("#chap-top").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Furyosquad;
        }));
        const Furyosquad = {
            name: "Furyosquad",
            domain: "https://furyosquad.com/",
            languages: [ "French" ],
            type: "manga",
            isSyncPage: url => "read" === url.split("/")[3],
            sync: {
                getTitle: () => j.$(".fs-read-comic-link").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: () => utils.absoluteLink(j.$(".fs-read-comic-link a").attr("href"), Furyosquad.domain),
                getVolume: url => parseInt(utils.urlPart(url, 6)),
                getEpisode: url => parseInt(utils.urlPart(url, 7)),
                nextEpUrl() {
                    const href = j.$(".vertical-next-chapter a").attr("href");
                    return href && 6 === href.split("/").length ? "" : utils.absoluteLink(href, Furyosquad.domain);
                }
            },
            overview: {
                getTitle: () => j.$(".fs-comic-title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".comic-info").after(j.html(`<div class="list fs-chapter-list"><div class="group"><div class="title">MAL-Sync</div>${selector}</div></div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".group > div.element"),
                    elementUrl: selector => utils.absoluteLink(selector.find('a[href*="/read/"]').attr("href") || "", Furyosquad.domain),
                    elementEp: selector => Furyosquad.sync.getEpisode(Furyosquad.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(451).toString()), j.$(document).ready((function() {
                    ("read" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] || j.$(".fs-comic-title").length && j.$("div.main-container-top.comic").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeId;
        }));
        const AnimeId = {
            name: "AnimeId",
            domain: "https://www.animeid.tv",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => "v" === utils.urlPart(url, 3),
            isOverviewPage: url => !!j.$("section#capitulos")[0],
            sync: {
                getTitle: url => j.$("#infoanime h1 a")[0].innerText,
                getIdentifier(url) {
                    var _a;
                    return (null === (_a = j.$("#infoanime h1 a")[0].getAttribute("href")) || void 0 === _a ? void 0 : _a.split("/").pop()) || "";
                },
                getOverviewUrl: url => `${AnimeId.domain}${$("#infoanime h1 a")[0].getAttribute("href")}`,
                getEpisode: url => Number.parseInt(j.$("#infoanime strong")[0].innerText.replace("CapÃ­tulo ", "").trim()),
                nextEpUrl: url => `${AnimeId.domain}${j.$(".buttons li a")[2].getAttribute("href")}`
            },
            overview: {
                getTitle: url => j.$("article hgroup h1").text(),
                getIdentifier: url => utils.urlPart(url, 3),
                uiSelector(selector) {
                    j.$("article").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector() {
                        const url = window.location.href;
                        document.body.insertAdjacentHTML("afterbegin", '<div id="MALSync" class="MALSync" style="display: none;"><ul id="MALSyncUl" class="MALSyncUl"></ul></div>');
                        const idMALSync = document.getElementById("MALSyncUl");
                        let lastEpi = j.$("section#capitulos li a")[0];
                        if (lastEpi) {
                            lastEpi = lastEpi.getAttribute("href");
                            const numLastEpi = lastEpi.split("-").pop();
                            if (void 0 !== numLastEpi) for (let x = 1; x < Number.parseInt(numLastEpi) + 1; x++) null !== idMALSync && (idMALSync.innerHTML += j.html(`<li><a href="${AnimeId.domain}/v/${utils.urlPart(url, 3)}-${x}" epi="${x}"></a> </li>`));
                        }
                        return j.$(".MALSync a");
                    },
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), AnimeId.domain),
                    elementEp: selector => Number(selector.attr("epi")),
                    handleListHook(epi, epilist) {
                        if (epi++, epilist.length - 1 >= epi) {
                            const epiAct = `<li><a href="${epilist[epi][0].toString()}"><strong>CapÃ­tulo ${epi}</strong><small class="right">Siguiente Episodio</small></li><li></li>`;
                            j.$("#listado").prepend(j.html(epiAct));
                        }
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(453).toString()), con.log("loading"), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AniMixPlay;
        }));
        const AniMixPlay = {
            name: "AniMixPlay",
            domain: "https://animixplay.to",
            database: "AniMixPlay",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !!url.split("/")[3].startsWith("v"),
            isOverviewPage: url => "anime" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("span.animetitle").text(),
                getIdentifier: url => hasMalOverview() ? j.$("#animebtn").attr("href").split("/")[2] : "nomal_" + utils.urlPart(url, 4),
                getOverviewUrl: url => hasMalOverview() ? `${AniMixPlay.domain}/anime/${AniMixPlay.sync.getIdentifier(url)}` : url.replace(/ep\d+$/i, "").replace(/\/$/, ""),
                getEpisode: url => Number(j.$("#epslistplace > button:disabled").last().text().replace(/\D+/g, "")),
                uiSelector(selector) {
                    hasMalOverview() || j.$("button#followbtn").first().after(j.html(selector));
                },
                nextEpUrl(url) {
                    const nextEpisodeButton = j.$("#epslistplace > button:disabled").last().next();
                    return nextEpisodeButton && nextEpisodeButton.length ? AniMixPlay.overview.list.elementUrl(nextEpisodeButton) : "";
                }
            },
            overview: {
                getTitle: url => j.$("#animepagetitle").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#animepagetitle").after(j.html("" + selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#epslistplace > button"),
                    elementUrl(selector) {
                        const regex = /\/ep\d+$/, episode = selector.text().replace(/\D+/g, ""), url = window.location.href;
                        return regex.test(url) ? url.replace(regex, "/ep" + episode) : `${url}/ep${episode}`;
                    },
                    elementEp: selector => Number(selector.text().replace(/\D+/g, ""))
                }
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(455).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return AniMixPlay.sync.getEpisode(page.url) || AniMixPlay.isOverviewPage(window.location.href);
                    }), (function() {
                        page.handlePage();
                    }));
                }), !0);
            }
        };
        function hasMalOverview() {
            return j.$("#animebtn[href]").length > 0;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MyAnimeListVideo;
        }));
        const MyAnimeListVideo = {
            name: "MyAnimeList",
            domain: "https://myanimelist.net",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => utils.getBaseText(j.$("div.h1-title > div > h1")).trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => url.replace(/\/\d+$/, ""),
                getEpisode: url => parseInt(utils.urlPart(url, 7)),
                getMalUrl: provider => "https://myanimelist.net/anime/" + window.location.href.split("/")[4]
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(457).toString()), j.$(document).ready((function() {
                    void 0 !== page.url.split("/")[7] && page.url.split("/")[7].length > 0 && j.$("div.video-embed.clearfix").length && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, con, api) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeSimple;
        }));
        const AnimeSimple = {
            name: "AnimeSimple",
            domain: "https://ww1.animesimple.com",
            database: "AnimeSimple",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => jsonData.page && "episode" === jsonData.page,
            isOverviewPage: url => jsonData.page && "anime" === jsonData.page,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.anime_id,
                getOverviewUrl: url => jsonData.series_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.next_episode_url ? jsonData.next_episode_url : "",
                getMalUrl: provider => !!jsonData.mal_id && "https://myanimelist.net/anime/" + jsonData.mal_id
            },
            overview: {
                getTitle: url => AnimeSimple.sync.getTitle(url),
                getIdentifier: url => AnimeSimple.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$(jsonData.selector_position).first().after(j.html(selector));
                },
                getMalUrl: provider => AnimeSimple.sync.getMalUrl(provider),
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#episode-list > a"),
                    elementUrl: selector => selector.attr("href") || "",
                    elementEp(selector) {
                        const text = utils.getBaseText($(selector));
                        return text.toLowerCase().includes("episode") ? Number(text.replace(/\D+/g, "")) : NaN;
                    },
                    paginationNext(updateCheck) {
                        let el;
                        return con.log("updatecheck", updateCheck), updateCheck ? (el = j.$("ul.pagination  > li.page-item > a").last(), 
                        void 0 !== el[0] && !el.hasClass("active") && (el[0].click(), !0)) : (el = j.$("ul.pagination  > li.active.page-item").next("li").find("a"), 
                        void 0 !== el[0] && (el[0].click(), !0));
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(459).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return j.$("#syncData").length;
                    }), (function() {
                        jsonData = JSON.parse(j.$("#syncData").text()), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeUnity;
        }));
        const AnimeUnity = {
            name: "AnimeUnity",
            domain: "https://animeunity.it",
            languages: [ "Italian" ],
            type: "anime",
            isSyncPage: url => !(void 0 === url.split("/")[4] || !url.split("/")[4].length),
            sync: {
                getTitle: url => j.$("div.general > h1.title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => `${AnimeUnity.domain}/anime/${AnimeUnity.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const episode = Number(j.$("div.episode-wrapper > div.episode.episode-item.active").text().trim());
                    return episode || 1;
                },
                uiSelector(selector) {
                    j.$("div.general > h1.title").after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(461).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return JustAnime;
        }));
        const JustAnime = {
            name: "JustAnime",
            domain: "https://justanime.app",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => jsonData.page && "episode" === jsonData.page,
            isOverviewPage: url => jsonData.page && "anime" === jsonData.page,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.mal_id,
                getOverviewUrl: url => jsonData.series_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.next_episode_url ? jsonData.next_episode_url : "",
                getMalUrl: provider => "https://myanimelist.net/anime/" + JustAnime.sync.getIdentifier(window.location.href)
            },
            overview: {
                getTitle: url => JustAnime.sync.getTitle(url),
                getIdentifier: url => JustAnime.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$(jsonData.selector_position).first().after(j.html(selector));
                },
                getMalUrl: provider => JustAnime.sync.getMalUrl(provider),
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#episodeswrapper > #episodes > button"),
                    elementUrl: selector => selector.attr("episodeurl") || "",
                    elementEp(selector) {
                        const text = utils.getBaseText($(selector).find("span"));
                        return text.toLowerCase().includes("next") ? NaN : text.toLowerCase().includes("movie") ? 1 : Number(text.replace(/\D+/g, ""));
                    }
                }
            },
            init(page) {
                let interval, oldJson;
                api.storage.addStyle(__webpack_require__(465).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return !(!j.$("#syncData").length || (jsonData = JSON.parse(j.$("#syncData").text()), 
                        JSON.stringify(jsonData) === oldJson) || (oldJson = JSON.stringify(jsonData), 0));
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return YayAnimes;
        }));
        const YayAnimes = {
            name: "YayAnimes",
            domain: "https://yayanimes.net",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => !(!YayAnimes.sync.getEpisode(url) || YayAnimes.isOverviewPage(url)),
            isOverviewPage: url => !!(YayAnimes.overview.getTitle(url) && YayAnimes.overview.getIdentifier(url) && j.$("div.boxAnimeSobre").length),
            sync: {
                getTitle(url) {
                    const content = j.$("#content > div:nth-child(1) > div > h1 > div > b > p > span").text();
                    if (!content) return "";
                    return content.replace(/â€“.*$/, "").trim();
                },
                getIdentifier(url) {
                    const href = YayAnimes.sync.getOverviewUrl(url);
                    return href ? href.split("/")[3] : "";
                },
                getOverviewUrl(url) {
                    const href = j.$("div.pag_episodes > div:nth-child(2) > a").attr("href");
                    return href || "";
                },
                getEpisode(url) {
                    const episodePart = url.split("/")[3], temp = episodePart.match(/episodio-\d+/gi);
                    return temp ? Number(temp[0].replace(/\D+/g, "")) : episodePart.includes("filme") ? 1 : NaN;
                },
                nextEpUrl(url) {
                    const href = j.$("div.pag_episodes > div:nth-child(3) > a").attr("href");
                    return href || "";
                }
            },
            overview: {
                getTitle: url => YayAnimes.sync.getTitle(url),
                getIdentifier: url => utils.urlPart(url, 3),
                uiSelector(selector) {
                    j.$("#content > div.contentBox > div > div > div.boxAnimeSobre").after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(467).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return DesuOnline;
        }));
        const DesuOnline = {
            name: "DesuOnline",
            domain: "https://desu-online.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage: url => "anime" !== url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a > span").text(),
                getIdentifier: url => DesuOnline.sync.getOverviewUrl(url).split("/")[4],
                getOverviewUrl: url => j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const temp = url.split("/")[3].match(/-odcinek-\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl(url) {
                    const href = j.$("div.naveps.bignav > div:nth-child(3) > a").first().attr("href");
                    return href && DesuOnline.sync.getEpisode(url) < DesuOnline.sync.getEpisode(href) ? href : "";
                }
            },
            overview: {
                getTitle: url => j.$("div.infox > h1.entry-title").text(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("div.infox > h1.entry-title").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.bixbox.bxcl.epcheck > div.eplister > ul > li"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => DesuOnline.sync.getEpisode(String(selector.find("a").first().attr("href")))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(469).toString()), j.$(document).ready((function() {
                    ("anime" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length && j.$("div.infox > h1.entry-title").length && j.$("div.bixbox.bxcl.epcheck").length || j.$("div.ts-breadcrumb.bixbox > ol > li:nth-child(2) > a").length && j.$("div.video-content").length) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, utils, j) {
        let jsonData, loadedTimeout;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Simplyaweeb;
        }));
        const Simplyaweeb = {
            name: "Simplyaweeb",
            domain: "https://simplyaweeb.com",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.id,
                getOverviewUrl: url => jsonData.series_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.next_episode_url ? jsonData.next_episode_url : ""
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(471).toString()), utils.changeDetect((function() {
                    const text = j.$("#syncData").text();
                    text && (clearTimeout(loadedTimeout), loadedTimeout = utils.waitUntilTrue(() => !$(".preloader-load.changed-indicate").length, () => {
                        const data = JSON.parse(text);
                        data && data.length && (jsonData = data[0], "anime" === jsonData.type ? (Simplyaweeb.type = "anime", 
                        Simplyaweeb.database = "Gogoanime") : Simplyaweeb.type = "manga", page.handlePage());
                    }));
                }), () => {
                    const data = j.$("#syncData").text();
                    return data || page.reset(), data;
                });
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(1), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Animevibe;
        }));
        const Animevibe = {
            name: "Animevibe",
            domain: [ "https://animevibe.wtf", "https://animemate.xyz" ],
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "ani" === url.split("/")[3],
            sync: {
                getTitle: url => utils.getBaseText(j.$("div.episode-title-episode > h3")).trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => `${Animevibe.domain}/ani/${Animevibe.sync.getIdentifier(url)}/1/`,
                getEpisode: url => utils.urlPart(url, 5) ? parseInt(utils.urlPart(url, 5)) : 1,
                nextEpUrl: url => j.$('div.player-section.container-fluid > a:contains("Next Episode")').attr("href"),
                uiSelector(selector) {
                    j.$("div.episode-title-episode > h3").after(j.html(selector));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector(selector) {},
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#collapse-episode > div.wrap-episode-list > a, #collapse-episode > div.wrap-episode-list > button"),
                    elementUrl: selector => `${Animevibe.domain}/ani/${Animevibe.sync.getIdentifier(window.location.href)}/${selector.text().trim()}/`,
                    elementEp: selector => Animevibe.sync.getEpisode(Animevibe.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(473).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return WuxiaWorld;
        }));
        const WuxiaWorld = {
            name: "WuxiaWorld",
            domain: "https://wuxiaworld.site",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            isOverviewPage: url => void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$("div.entry-header > div > div.entry-header_wrap > div > div.c-breadcrumb > ol > li:nth-child(2) > a").text().replace(/(comics|comic)\s*$/i, "").trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => j.$("div.entry-header> div > div.entry-header_wrap > div > div.c-breadcrumb > ol > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const temp = url.split("/")[5].match(/(chapter|ch)-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl: url => j.$("div.entry-header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => utils.getBaseText(j.$("div.profile-manga > div > div > div > div.post-title > h1")).replace(/(comics|comic)\s*$/i, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.profile-manga > div > div > div > div.post-title > h1").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.page-content-listing.single-page > div > ul > li.wp-manga-chapter"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), WuxiaWorld.domain),
                    elementEp: selector => WuxiaWorld.sync.getEpisode(WuxiaWorld.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(475).toString()), j.$(document).ready((function() {
                    if (WuxiaWorld.isSyncPage(page.url)) j.$(".entry-content .reading-content img").length ? page.novel = !1 : page.novel = !0, 
                    page.handlePage(); else if (WuxiaWorld.isOverviewPage(page.url)) {
                        const descriptionType = j.$('div.post-content > div.post-content_item > div.summary-heading > h5:contains("Type")').parent().parent().find("div.summary-content").text().toLowerCase();
                        descriptionType.includes("manga") || descriptionType.includes("comic") ? (page.novel = !1, 
                        page.handlePage()) : descriptionType.includes("novel") ? (page.novel = !0, page.handlePage()) : con.error("could not detect type");
                    } else con.error("could not detect page");
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeOnDemand;
        }));
        const AnimeOnDemand = {
            name: "AnimeOnDemand",
            domain: "https://www.anime-on-demand.de",
            languages: [ "German" ],
            type: "anime",
            isSyncPage: url => "anime" === url.split("/")[3] && void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$("div.l-mainsection > div.l-maincontent > div> h1[itemprop=name]").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => `${AnimeOnDemand.domain}/anime/${AnimeOnDemand.sync.getIdentifier(url)}`,
                getEpisode(url) {
                    const episodeTitle = j.$("#player_container div.jw-title > div.jw-title-primary").text();
                    return episodeTitle.length ? void 0 !== episodePartToEpisode(episodeTitle) ? Number(episodePartToEpisode(episodeTitle)) : 1 : NaN;
                },
                uiSelector(selector) {
                    j.$("div.l-mainsection > div.l-maincontent > div> h1[itemprop=name]").after(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(477).toString()), utils.changeDetect((function() {
                    page.reset(), page.handlePage();
                }), () => "" + AnimeOnDemand.sync.getEpisode(page.url));
            }
        };
        function episodePartToEpisode(string) {
            if (!string) return;
            let temp = [];
            return temp = string.match(/(ep\.|episode)\D?\d+/i), null !== temp && (temp = (string = temp[0]).match(/\d+/), 
            null !== temp) ? temp[0] : void 0;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return LeviatanScans;
        }));
        const LeviatanScans = {
            name: "LeviatanScans",
            domain: "https://leviatanscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => $("div.wp-manga-nav").length > 0,
            isOverviewPage: url => j.$("ul > li.wp-manga-chapter").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 5),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const episodePart = utils.urlPart(url, 6);
                    return episodePart.match(/season-\d+/gim) ? Number(utils.urlPart(url, 7)) : Number(episodePart);
                },
                nextEpUrl: url => j.$(".nav-links .next_page").attr("href")
            },
            overview: {
                getTitle: url => j.$(j.$("ol.breadcrumb li a")[2]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 5),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => LeviatanScans.sync.getEpisode(LeviatanScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(481).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[4] && void 0 !== page.url.split("/")[5] && page.url.split("/")[5].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SKScans;
        }));
        const SKScans = {
            name: "SKScans",
            domain: "https://skscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => j.$("div.wp-manga-nav").length > 0,
            isOverviewPage: url => j.$("ul > li.wp-manga-chapter").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const episodePart = utils.urlPart(url, 5);
                    return episodePart.match(/season-\d+/gim) ? Number(utils.urlPart(url, 6)) : Number(episodePart);
                },
                nextEpUrl: url => j.$(".nav-links .next_page").first().attr("href")
            },
            overview: {
                getTitle: url => j.$(j.$("ol.breadcrumb li a")[2]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => SKScans.sync.getEpisode(SKScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(483).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return DeathTollScans;
        }));
        const DeathTollScans = {
            name: "DeathTollScans",
            domain: "https://reader.deathtollscans.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "read" === url.split("/")[3],
            isOverviewPage: url => !!j.$("div.comic.info").length,
            sync: {
                getTitle: url => j.$("div.tbtitle div.text a").first().text(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => j.$("div.tbtitle div.text a").first().attr("href") || "",
                getEpisode: url => Number(url.split("/")[7]),
                getVolume: url => Number(url.split("/")[6]),
                nextEpUrl: url => j.$(`div.tbtitle ul.dropdown li a[href='${j.$("div.tbtitle div.text a").eq(1).attr("href")}']`).parent().prev().find("a").attr("href")
            },
            overview: {
                getTitle: url => j.$("h1.title").first().text().trim(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("h1.title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.group div.element"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div.title a").first().attr("href"), DeathTollScans.domain),
                    elementEp: selector => parseInt(DeathTollScans.overview.list.elementUrl(selector).split("/")[7])
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(485).toString()), j.$(document).ready((function() {
                    "series" !== page.url.split("/")[3] && "read" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return KireiCake;
        }));
        const KireiCake = {
            name: "KireiCake",
            domain: "https://reader.kireicake.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "read" === url.split("/")[3],
            isOverviewPage: url => !!j.$("div.list").length,
            sync: {
                getTitle: url => j.$("div.topbar_left h1 a").first().text(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => j.$("div.topbar_left h1 a").first().attr("href") || "",
                getEpisode: url => Number(url.split("/")[7]),
                getVolume: url => Number(url.split("/")[6]),
                nextEpUrl(url) {
                    const nextUrl = j.$(`select option[value='${j.$("div.topbar_left form").last().find("select option").first().attr("value")}']`).last().prev().attr("value");
                    if (j.$("div.topbar_left form").last().find("select option").first().attr("value") !== nextUrl) return nextUrl;
                }
            },
            overview: {
                getTitle: url => j.$("h1.title").first().text().trim(),
                getIdentifier: url => url.split("/")[4],
                uiSelector(selector) {
                    j.$("h1.title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.list div.element"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div.title a").first().attr("href"), KireiCake.domain),
                    elementEp: selector => parseInt(KireiCake.overview.list.elementUrl(selector).split("/")[7])
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(487).toString()), j.$(document).ready((function() {
                    "series" !== page.url.split("/")[3] && "read" !== page.url.split("/")[3] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SenseScans;
        }));
        const SenseScans = {
            name: "SenseScans",
            domain: "https://sensescans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "read" === url.split("/")[4],
            isOverviewPage: url => !!j.$("div.comic.info").length,
            sync: {
                getTitle: url => j.$("div.tbtitle div.text a").first().text(),
                getIdentifier: url => url.split("/")[5],
                getOverviewUrl: url => j.$("div.tbtitle div.text a").first().attr("href") || "",
                getEpisode: url => Number(url.split("/")[8]),
                getVolume: url => Number(url.split("/")[7]),
                nextEpUrl: url => j.$(`div.tbtitle ul.dropdown li a[href='${j.$("div.tbtitle div.text a").eq(1).attr("href")}']`).parent().prev().find("a").attr("href")
            },
            overview: {
                getTitle: url => j.$("h1.title").first().text().trim(),
                getIdentifier: url => url.split("/")[5],
                uiSelector(selector) {
                    j.$("h1.title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.group div.element"),
                    elementUrl: selector => utils.absoluteLink(selector.find("div.title a").first().attr("href"), SenseScans.domain),
                    elementEp: selector => parseInt(SenseScans.overview.list.elementUrl(selector).split("/")[8])
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(489).toString()), j.$(document).ready((function() {
                    "reader" !== page.url.split("/")[3] || "series" !== page.url.split("/")[4] && "read" !== page.url.split("/")[4] || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ManhuaPlus;
        }));
        const ManhuaPlus = {
            name: "ManhuaPlus",
            domain: "https://manhuaplus.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => url.split("/")[5].indexOf("chapter") >= 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => j.$("div.entry-header.header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => j.$(j.$("ol.breadcrumb li a")[2]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => ManhuaPlus.sync.getEpisode(ManhuaPlus.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(491).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Readm;
        }));
        const Readm = {
            name: "Readm",
            domain: "https://readm.org",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            isOverviewPage: url => void 0 !== url.split("/")[4] && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$("h1.page-title > a").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("h1.page-title > a").attr("href"), Readm.domain),
                getEpisode: url => parseInt(utils.urlPart(url, 5)) || 1,
                nextEpUrl: url => utils.absoluteLink(j.$("#series-tabs > a.item.navigate.ch-next-page.navigate-next").attr("href"), Readm.domain)
            },
            overview: {
                getTitle: url => j.$("h1.page-title").text().trim(),
                getIdentifier: url => Readm.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("#router-view > div > div.ui.grid").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.season-list-column > div.ui.tab div.item tr"),
                    elementUrl: selector => utils.absoluteLink(selector.find("h6 > a").attr("href"), Readm.domain),
                    elementEp: selector => Readm.sync.getEpisode(Readm.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(493).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return tioanime;
        }));
        const tioanime = {
            name: "tioanime",
            domain: "https://tioanime.com",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => "ver" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.container div.episode-single h1.anime-title").text().replace(/ \d+$/, ""),
                getIdentifier: url => utils.urlPart(tioanime.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$('div.episode-single div.options > div.episodes-nav > span > a[href^="/anime/"]').first().attr("href"), tioanime.domain),
                getEpisode: url => parseInt(url.match(/-(\d+$)/)[1]),
                nextEpUrl: url => utils.absoluteLink(j.$('div.episode-single div.options > div.episodes-nav > span > a[href^="/ver/"]').eq(1).attr("href"), tioanime.domain)
            },
            overview: {
                getTitle: url => j.$("article h1.title").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".principal").first().prepend(j.html(`<div class="info">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("section > ul.episodes-list > li > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), tioanime.domain),
                    elementEp: selector => tioanime.sync.getEpisode(tioanime.overview.list.elementUrl(selector))
                },
                getMalUrl(provider) {
                    const jikan = $("body").html().match(/api\.jikan\.moe\/v\d+\/anime\/(\d+)/im);
                    return !(!jikan || !jikan.length) && "https://myanimelist.net/anime/" + jikan[1];
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(495).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return YugenAnime;
        }));
        const YugenAnime = {
            name: "YugenAnime",
            domain: "https://yugenani.me",
            languages: [ "English" ],
            type: "anime",
            database: "YugenAnime",
            isSyncPage: url => jsonData.page && "episode" === jsonData.page,
            isOverviewPage: url => jsonData.page && "anime" === jsonData.page,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.anime_id,
                getOverviewUrl: url => jsonData.series_url,
                getEpisode: url => jsonData.episode,
                nextEpUrl: url => jsonData.next_episode_url ? jsonData.next_episode_url : "",
                getMalUrl: provider => !!jsonData.mal_id && "https://myanimelist.net/anime/" + jsonData.mal_id
            },
            overview: {
                getTitle: url => YugenAnime.sync.getTitle(url),
                getIdentifier: url => YugenAnime.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$(jsonData.selector_position).first().after(j.html(selector));
                },
                getMalUrl: provider => YugenAnime.sync.getMalUrl(provider)
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(497).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return j.$("#syncData").length;
                    }), (function() {
                        jsonData = JSON.parse(j.$("#syncData").text()), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaSee;
        }));
        const MangaSee = {
            name: "MangaSee",
            domain: "https://mangasee123.com",
            languages: [ "English" ],
            type: "manga",
            database: "MangaSee",
            isSyncPage: url => "read-online" === url.split("/")[3],
            isOverviewPage: url => "manga" === url.split("/")[3],
            getImage: () => $("div.container.MainContainer div.row > div > img.img-fluid").attr("src"),
            sync: {
                getTitle: url => j.$("div.Column.col-lg-4.col-12").first().text().trim(),
                getIdentifier: url => utils.urlPart(MangaSee.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("div.Column.col-lg-4.col-12 a").first().attr("href"), MangaSee.domain),
                getEpisode(url) {
                    const temp = utils.urlPart(url, 4).match(/chapter-\d+/gim);
                    return temp && temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                },
                getVolume(url) {
                    const temp = utils.urlPart(url, 4).match(/index-\d+/gim);
                    return temp && temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                }
            },
            overview: {
                getTitle: url => j.$("li.list-group-item").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(j.$("li.list-group-item")[1]).after(j.html(`<li class="list-group-item d-none d-sm-block"><span class="mlabel">MAL-Sync:</span>${selector}</li>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => (j.$("div.list-group-item.ShowAllChapters").click(), j.$("a.list-group-item.ChapterLink")),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), MangaSee.domain) || "",
                    elementEp: selector => MangaSee.sync.getEpisode(MangaSee.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(499).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return MangaSee.isSyncPage(page.url) ? MangaSee.sync.getTitle(page.url) && MangaSee.sync.getEpisode(page.url) : !!MangaSee.isOverviewPage(page.url) && (MangaSee.overview.getTitle(page.url) && !j.$('a[href$="{{vm.ChapterURLEncode(vm.Chapters[vm.Chapters.length-1].Chapter)}}"]').length);
                    }), (function() {
                        MangaSee.isOverviewPage(page.url) && page.handlePage(), MangaSee.isSyncPage(page.url) && function(callback, func) {
                            let currentPage = "";
                            const intervalId = setInterval((function() {
                                const temp = func();
                                void 0 !== temp && currentPage !== temp && (currentPage = func(), callback());
                            }), 500);
                            Number(intervalId);
                        }(() => {
                            page.handlePage();
                        }, () => j.$("div.Column.col-lg-2.col-6 button.btn.btn-sm.btn-outline-secondary.ng-binding").first().text().trim());
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeTribes;
        }));
        const AnimeTribes = {
            name: "AnimeTribes",
            domain: "https://animetribes.ru",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "watch" === url.split("/")[3] && void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: url => j.$("div.video-info-title > h1").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("#dropdown-menu > div.dropdown-content > a").last().attr("href"), AnimeTribes.domain),
                getEpisode: url => utils.urlPart(url, 5) ? parseInt(utils.urlPart(url, 5)) : 1,
                nextEpUrl: url => utils.absoluteLink(j.$("nav.pagination span.typcn.typcn-media-fast-forward").parent("a").attr("href"), AnimeTribes.domain),
                uiSelector(selector) {
                    j.$("div.video-info-title > h1").after(j.html(selector));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector(selector) {},
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#dropdown-menu > div.dropdown-content > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), AnimeTribes.domain),
                    elementEp: selector => AnimeTribes.sync.getEpisode(AnimeTribes.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(501).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Okanime;
        }));
        const Okanime = {
            name: "Okanime",
            domain: "https://okanime.tv",
            type: "anime",
            languages: [ "Arabic" ],
            isOverviewPage: url => "animes" === utils.urlPart(url, 3) || "movies" === utils.urlPart(url, 3),
            isSyncPage: url => "episodes" === utils.urlPart(url, 5) || "movies" === utils.urlPart(url, 3) && "watch" === utils.urlPart(url, 5),
            overview: {
                getTitle: url => isRealOverview(url) ? j.$(".author-info-title > span").first().text() : Okanime.sync.getTitle(url),
                getIdentifier: url => isRealOverview(url) ? utils.urlPart(url, 4) : Okanime.sync.getIdentifier(url),
                uiSelector: selector => {
                    j.$("div.whitebox .whitebox-wrap .review-author-info .author-info-title").first().append(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => isRealOverview(window.location.href) ? j.$("#episodes .enable-photos-box a:not(.btn)") : j.$(".result-item.episode"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), Okanime.domain),
                    elementEp: selector => Okanime.sync.getEpisode(Okanime.overview.list.elementUrl(selector)),
                    getTotal: () => isRealOverview(window.location.href) ? Number(j.$("div.review-author-wrap .content-block .full-list-info:last-child small:last-child").first().text().split("/")[1]) : void 0
                }
            },
            sync: {
                getTitle: url => j.$(".summary-block p a").first().text(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => "" + url.split("/").slice(0, 5).join("/"),
                getEpisode: url => Number(utils.urlPart(url, 6).split("-").slice(-2)[0]),
                nextEpUrl: url => utils.absoluteLink(j.$("div.action-tiem.backward a").first().attr("href"), Okanime.domain),
                uiSelector: selector => {
                    j.$("div.user-block .translated-box").first().prepend(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(503).toString()), j.$(() => {
                    utils.waitUntilTrue(() => Okanime.overview.list.elementsSelector().length, () => {
                        page.handlePage();
                    });
                });
            }
        }, isRealOverview = url => {
            const overview = url.split("/");
            return ("animes" === overview[3] || "movies" === overview[3]) && 5 === overview.length;
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return BSTO;
        }));
        const BSTO = {
            domain: "https://bs.to",
            languages: [ "German" ],
            name: "bs.to",
            type: "anime",
            isSyncPage: url => "serie" === url.split("/")[3] && url.split("/").length > 7,
            isOverviewPage: url => "serie" === url.split("/")[3] && url.split("/").length >= 4,
            sync: {
                getTitle: url => BSTO.overview.getTitle(url),
                getIdentifier: url => BSTO.overview.getIdentifier(url),
                getOverviewUrl: url => url.split("/").slice(0, 5).join("/"),
                getEpisode: url => Number(j.$(".episode .active > a").text()),
                nextEpUrl(url) {
                    const nextEp = BSTO.sync.getEpisode(url) + 1, nextEle = j.$(`.e${nextEp} > a`);
                    return nextEle.length ? utils.absoluteLink(nextEle.attr("href"), BSTO.domain) : "";
                },
                uiSelector(selector) {
                    j.$(".selectors").first().before(j.html(`<div class="MALContainer"> ${selector}</div>`));
                }
            },
            overview: {
                getTitle(url) {
                    let title = utils.getBaseText(j.$("h2").first()).trim();
                    title = title.split("|")[0];
                    let Season = 1;
                    return utils.urlPart(url, 5) && (Season = Number(utils.urlPart(url, 5))), `${title} ${Season}`;
                },
                getIdentifier(url) {
                    const mainId = url.split("/")[4];
                    let Season = 1;
                    return utils.urlPart(url, 5) && (Season = Number(utils.urlPart(url, 5))), `${mainId}?s=${Season}`;
                },
                uiSelector(selector) {
                    j.$(".selectors").first().before(j.html(`<div class="MALContainer"> ${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$('table.episodes tr, div.episode li[class^="e"]'),
                    elementUrl(selector) {
                        const anchorHref = selector.find("a").first().attr("href");
                        return anchorHref || "";
                    },
                    elementEp(selector) {
                        const anchorNb = selector.find("a").first().text();
                        return anchorNb ? Number(anchorNb) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(505).toString()), j.$(document).ready((function() {
                    j.$("body").append('<script>var openWindow = window.open; window.open = function (url, windowName, windowFeatures) {if(!url.startsWith("https://vivo")) openWindow(url, windowName, windowFeatures)}<\/script>'), 
                    $("html").addClass("miniMAL-hide"), j.$('.infos span:contains("Genres")').next("p").text().indexOf("Anime") >= 0 && 0 !== parseInt(utils.urlPart(page.url, 5)) && ($("html").removeClass("miniMAL-hide"), 
                    page.handlePage());
                })), utils.waitUntilTrue((function() {
                    return j.$('div.hoster-player > a[href^="https://vivo"]').length;
                }), (function() {
                    const array = j.$('div.hoster-player > a[href^="https://vivo"]').attr("href").split("/"), id = array.pop();
                    array.push("embed"), array.push(id);
                    const output = array.join("/");
                    j.$("div.hoster-player").html(""), j.$("div.hoster-player").append(`<iframe src="${output}" width="560" height="315" scrolling="no" frameborder="0" allowfullscreen></iframe>`);
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Pantsubase;
        }));
        const Pantsubase = {
            name: "Pantsubase",
            domain: "https://pantsubase.tv",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "watch" === url.split("/")[3],
            isOverviewPage: url => "anime" === url.split("/")[3],
            sync: {
                getTitle: url => j.$('div.breadcrumb a[href*="/anime/"] > span').text().trim(),
                getIdentifier: url => utils.urlPart(Pantsubase.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$('div.breadcrumb a[href*="/anime/"]').attr("href"), Pantsubase.domain),
                getEpisode(url) {
                    const temp = utils.urlPart(url, 4).match(/-episode-\d*/gi);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => utils.absoluteLink(j.$('div.theatre-settings > div.row a:contains("Next")').attr("href"), Pantsubase.domain)
            },
            overview: {
                getTitle: url => j.$("div.info > h1 > div").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.info > h1").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.episode > li.epi-me"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), Pantsubase.domain),
                    elementEp: selector => Pantsubase.sync.getEpisode(Pantsubase.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(507).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return Pantsubase.sync.getTitle(page.url) || Pantsubase.overview.getTitle(page.url) && Pantsubase.overview.list.elementsSelector().length;
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeOwl;
        }));
        const AnimeOwl = {
            name: "AnimeOwl",
            domain: "https://animeowl.net",
            languages: [ "English" ],
            type: "anime",
            isSyncPage(url) {
                if (!url) throw "No url passed";
                return !!(AnimeOwl.sync.getTitle(url) && j.$("div.player-wrapper").length && void 0 !== url.split("/")[3] && url.split("/")[3].length > 0);
            },
            isOverviewPage: url => "watch" === url.split("/")[3] && void 0 !== url.split("/")[3] && url.split("/")[3].length > 0,
            sync: {
                getTitle: url => j.$("a.back-tv-show").text().trim(),
                getIdentifier: url => utils.urlPart(AnimeOwl.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => j.$("a.back-tv-show").attr("href") || "",
                getEpisode: url => parseInt(j.$(".episodes-list button.active").closest("a").text()),
                nextEpUrl: url => j.$(".episodes-list button.active").parents("div").next().find("a").attr("href"),
                getMalUrl(provider) {
                    const malid = j.$("[data-mal-id]").attr("data-mal-id");
                    return !!malid && "https://myanimelist.net/anime/" + malid;
                }
            },
            overview: {
                getTitle: url => j.$("div.post-inner > .anime-title").html().split("<br>")[0].replace(/-\s*$/, "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.post-info").first().before(j.html(`<div class="row"><div class="col-12">${selector}</div></div>`));
                },
                getMalUrl: provider => AnimeOwl.sync.getMalUrl(provider),
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#episodes > div.episode-number"),
                    elementUrl: selector => selector.find("a").attr("href") || "",
                    elementEp: selector => parseInt(selector.find("a").text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(509).toString()), j.$(document).ready((function() {
                    AnimeOwl.isSyncPage(page.url) ? page.handlePage(j.$(".episodes-list button.active").closest("a").attr("href") || "") : page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AsuraScans;
        }));
        const AsuraScans = {
            name: "AsuraScans",
            domain: "https://asurascans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => !!/cha?p?t?e?r?-\d+/i.test(url.split("/")[3]),
            isOverviewPage: url => "comics" === url.split("/")[3] && "" !== url.split("/")[4],
            sync: {
                getTitle: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox span")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(AsuraScans.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 3).match(/cha?p?t?e?r?-\d+/i);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl(url) {
                    const next = j.$("a.ch-next-btn").attr("href");
                    if ("#/next/" !== next) return next;
                }
            },
            overview: {
                getTitle: url => j.$("h1.entry-title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.bixbox.animefull").first().after(j.html(`<div id= "malthing" class="bixbox animefull">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#chapterlist li div.chbox"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => AsuraScans.sync.getEpisode(AsuraScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(511).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return NaniScans;
        }));
        const NaniScans = {
            name: "NaniScans",
            domain: "https://naniscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "chapters" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("a.section").text().trim(),
                getIdentifier: url => utils.urlPart(NaniScans.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("a.section").attr("href"), NaniScans.domain),
                getEpisode: url => Number(j.$("div#chapter-selector div.text").text().trim().replace("Chapter ", "")),
                nextEpUrl: url => utils.absoluteLink(j.$("i.chevron.right.icon").parent().attr("href"), NaniScans.domain)
            },
            overview: {
                getTitle: url => j.$("h1.ui.centered.header").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.content div.description").first().after(j.html(`<div class="ui hidden divider"></div><div id= "malthing"><h5>MALSync</h5>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#chapters div.item"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").last().attr("href"), NaniScans.domain) || "",
                    elementEp(selector) {
                        let temp = selector.find("a").last().text().trim().match(/(ch\.|chapter)\D?\d+/i);
                        return temp && (temp = temp[0].match(/\d+/), temp) ? Number(temp[0]) : NaN;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(513).toString()), j.$(document).ready((function() {
                    ("chapters" === page.url.split("/")[3] || "titles" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4]) && page.handlePage(), 
                    "titles" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && utils.changeDetect(() => {
                        page.handleList();
                    }, () => j.$("div#chapters div.item").length);
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, con, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MerakiScans;
        }));
        const MerakiScans = {
            name: "MerakiScans",
            domain: "https://merakiscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "manga" === url.split("/")[3] && void 0 !== url.split("/")[6],
            sync: {
                getTitle: url => j.$("h1#reader_text a").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("h1#reader_text a").first().attr("href"), MerakiScans.domain),
                getEpisode: url => Number(url.split("/")[5]),
                nextEpUrl(url) {
                    const nextChap = j.$("#chapter_select option:selected").next().val();
                    if (void 0 === nextChap) return;
                    const urlSplit = url.split("/");
                    return urlSplit.splice(5, 1, nextChap), urlSplit.join("/");
                }
            },
            overview: {
                getTitle: url => j.$("b#manga_name").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.tab").first().before(j.html(`<div id="malthing"><b id="MALSync">MALSync</b>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("tr#chapter-head"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("data-href"), MerakiScans.domain),
                    elementEp: selector => Number(MerakiScans.overview.list.elementUrl(selector).split("/")[5]),
                    paginationNext(updateCheck) {
                        if (con.log("updatecheck", updateCheck), updateCheck) return !1;
                        const el = j.$("#chapter_table_paginate > span > a.paginate_button.current").next("a");
                        return void 0 !== el[0] && (el[0].click(), !0);
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(515).toString()), j.$(document).ready((function() {
                    "manga" !== page.url.split("/")[3] || 6 !== page.url.split("/").length && 7 !== page.url.split("/").length || page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(api, con, utils, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Jellyfin;
        }));
        var _utils_general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1), _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_1__.a;
        let item;
        function getApiKey() {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.get("Jellyfin_Api_Key");
            }));
        }
        function setApiKey(key) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set("Jellyfin_Api_Key", key);
            }));
        }
        function getBase() {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.get("Jellyfin_Base");
            }));
        }
        function setBase(key) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set("Jellyfin_Base", key);
            }));
        }
        function getUser() {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.get("Jellyfin_User");
            }));
        }
        function setUser(key) {
            return __awaiter(this, void 0, void 0, (function*() {
                return api.storage.set("Jellyfin_User", key);
            }));
        }
        function checkApi(page) {
            return __awaiter(this, void 0, void 0, (function*() {
                const videoEl = $("video");
                if (videoEl.length) {
                    $("html").addClass("miniMAL-hide");
                    const url = videoEl.attr("src");
                    if (con.log("Video", url), url) {
                        const itemId = yield function() {
                            return __awaiter(this, void 0, void 0, (function*() {
                                const deviceId = yield function() {
                                    return __awaiter(this, void 0, void 0, (function*() {
                                        return new Promise((resolve, reject) => {
                                            proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                                                const apiClient = proxy.getCaptureVariable("ApiClient");
                                                if (con.m("apiClient").log(apiClient), apiClient && apiClient._deviceId) return con.m("apiClient").log("clientId", apiClient._deviceId), 
                                                void resolve(apiClient._deviceId);
                                                reject();
                                            })));
                                        });
                                    }));
                                }(), userId = yield getUser();
                                return new Promise((resolve, reject) => {
                                    setTimeout(() => {
                                        resolve();
                                    }, 1e4);
                                }).then(() => __awaiter(this, void 0, void 0, (function*() {
                                    return getSession(deviceId, userId).then(sess => (con.log("Now Playing", sess.NowPlayingItem), 
                                    sess.NowPlayingItem.Id));
                                })));
                            }));
                        }();
                        itemId || con.log("No video id");
                        const curUrl = `${window.location.origin}/#!/details?id=${itemId}`;
                        checkItemId(page, itemId, curUrl, !0);
                    }
                }
            }));
        }
        function urlChange(page) {
            return __awaiter(this, void 0, void 0, (function*() {
                if ($("html").addClass("miniMAL-hide"), -1 !== window.location.href.indexOf("id=")) {
                    const id = utils.urlParam(window.location.href, "id");
                    checkItemId(page, id);
                }
            }));
        }
        function checkItemId(page, id, curUrl = "", video = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                let reqUrl = "/Items?ids=" + id;
                apiCall(reqUrl, !0).then(response => {
                    const data = JSON.parse(response.responseText);
                    if (!data.Items.length) return function() {
                        proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                            const apiClient = proxy.getCaptureVariable("ApiClient");
                            con.m("apiClient").log(apiClient);
                            const curKey = getApiKey();
                            apiClient && apiClient._serverInfo && apiClient._serverInfo.AccessToken && curKey === apiClient._serverInfo.AccessToken || (con.error("Reset Authentication"), 
                            yield setBase(""), yield setApiKey(""), yield setUser(""), yield checkApiClient());
                        })));
                    }();
                    switch (data.Items[0].Type) {
                      case "Episode":
                      case "Season":
                        if ("Episode" === data.Items[0].Type && !video) return void con.log("Execute Episode only on video");
                        con.log("Season", data), item = data.Items[0], reqUrl = "/Items/" + item.SeriesId, 
                        apiCall(reqUrl, !0).then(response2 => {
                            const genres = JSON.parse(response2.responseText);
                            con.log("genres", genres), genres.Path.includes("Anime") || genres.GenreItems.find(genre => "anime" === genre.Name.toLowerCase()) ? (con.info("Anime detected"), 
                            curUrl ? (page.url = curUrl, page.handlePage(page.url)) : page.handlePage(), $("html").removeClass("miniMAL-hide")) : con.error("Not an Anime");
                        });
                        break;

                      case "Series":
                        con.log("Series", data);
                        break;

                      default:
                        con.log("Not recognized", data);
                    }
                });
            }));
        }
        function getSession(deviceId, userId, user = !0) {
            return __awaiter(this, void 0, void 0, (function*() {
                return apiCall("/Sessions", !1, user).then(response => {
                    const data = JSON.parse(response.responseText);
                    return con.m("Session").log("Session", data, deviceId, userId, user), function parseSession(data, deviceId, userId, user) {
                        return __awaiter(this, void 0, void 0, (function*() {
                            if (deviceId ? data = data.filter(el => el.DeviceId === deviceId) : userId && (data = data.filter(el => el.UserId === userId)), 
                            !(data = data.filter(el => void 0 !== el.NowPlayingItem)).length) {
                                if (deviceId) return con.m("Session").m(user).log("Fallback to userId"), parseSession(data, null, userId, user);
                                if (user) return con.m("Session").m(user).log("Fallback to request without ControllableByUserId"), 
                                getSession(deviceId, userId, !1);
                                throw "Could not get session";
                            }
                            return con.m("Session").log("found", data), data[0];
                        }));
                    }(data, deviceId, userId, user);
                });
            }));
        }
        function checkApiClient() {
            return __awaiter(this, void 0, void 0, (function*() {
                return new Promise((resolve, reject) => {
                    proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                        const apiClient = proxy.getCaptureVariable("ApiClient");
                        if (con.m("apiClient").log(apiClient), apiClient) return apiClient._serverInfo && apiClient._serverInfo.AccessToken && setApiKey(apiClient._serverInfo.AccessToken), 
                        apiClient._serverAddress && setBase(apiClient._serverAddress), apiClient._currentUser && apiClient._currentUser.Id ? setUser(apiClient._currentUser.Id) : apiClient._serverInfo && apiClient._serverInfo.UserId && setUser(apiClient._serverInfo.UserId), 
                        void resolve(!0);
                        reject();
                    })));
                });
            }));
        }
        function apiCall(url, needsUser = !1, filterByUser = !1) {
            return __awaiter(this, void 0, void 0, (function*() {
                const apiKey = yield getApiKey(), base = yield getBase();
                let pre;
                if (pre = -1 !== url.indexOf("?") ? "&" : "?", needsUser) {
                    const user = yield getUser();
                    url = `/Users/${user}${url}`;
                }
                if (url = `${base + url + pre}api_key=${apiKey}`, filterByUser) {
                    const user = yield getUser();
                    url = `${url}&ControllableByUserId=${user}`;
                }
                return con.log("Api Call", url), api.request.xhr("GET", url).then(res => {
                    if (500 === res.status) throw con.error("Something went wrong", url, res), "Something went wrong";
                    return res;
                });
            }));
        }
        proxy.addCaptureVariable("ApiClient", '\n    if (window.hasOwnProperty("ApiClient")) {\n      return ApiClient;\n    } else {\n      return undefined;\n    }\n  ');
        const Jellyfin = {
            name: "Jellyfin",
            domain: "https://jellyfin.org/",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => "Episode" === item.Type,
            sync: {
                getTitle: url => item.SeriesName + (item.ParentIndexNumber > 1 ? " Season " + item.ParentIndexNumber : ""),
                getIdentifier: url => void 0 !== item.SeasonId ? item.SeasonId : void 0 !== item.SeriesId ? item.SeriesId : item.Id,
                getOverviewUrl: url => `${Jellyfin.domain}/#!/details?id=${Jellyfin.sync.getIdentifier(url)}`,
                getEpisode: url => item.IndexNumber
            },
            overview: {
                getTitle: url => item.SeriesName + (item.IndexNumber > 1 ? " Season " + item.IndexNumber : ""),
                getIdentifier: url => item.Id,
                uiSelector(selector) {
                    j.$(".page:not(.hide) .detailPageContent").first().prepend(j.html(selector));
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(517).toString()), function testApi(retry = 0) {
                    return __awaiter(this, void 0, void 0, (function*() {
                        if (retry > 19) throw Object(_utils_general__WEBPACK_IMPORTED_MODULE_0__.flashm)("MALSync could not Authenticate", {
                            error: !0
                        }), "Not Authenticated [Jellyfin]";
                        const key = yield getApiKey(), base = yield getBase(), user = yield getUser();
                        return key && base && user ? apiCall("/System/Info").then(response => 200 !== response.status ? (con.error("Not Authenticated"), 
                        setBase(""), setApiKey(""), setUser(""), testApi(++retry)) : apiCall("", !0).catch(e => (con.error("User wrong", e), 
                        setUser(""), testApi(++retry))).then(response2 => 200 === response2.status || (con.error("User wrong"), 
                        setUser(""), testApi(++retry)))) : (con.m("Authentication").error("base, user or Key are not set", base, user, key), 
                        yield checkApiClient(), testApi(++retry));
                    }));
                }().then(() => {
                    con.info("Authenticated"), utils.changeDetect(() => {
                        page.reset(), checkApi(page);
                    }, () => {
                        const src = $("video").first().attr("src");
                        return void 0 === src ? "NaN" : src;
                    }), utils.urlChangeDetect((function() {
                        -1 === window.location.href.indexOf("video") && (page.reset(), urlChange(page));
                    })), j.$(document).ready((function() {
                        utils.waitUntilTrue((function() {
                            return j.$(".page").length;
                        }), (function() {
                            urlChange(page);
                        }));
                    })), document.addEventListener("fullscreenchange", (function() {
                        window.fullScreen || window.innerWidth === window.screen.width && window.innerHeight === window.screen.height ? $("html").addClass("miniMAL-Fullscreen") : $("html").removeClass("miniMAL-Fullscreen");
                    }));
                });
            }
        };
    }).call(this, __webpack_require__(0), __webpack_require__(4), __webpack_require__(1), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return An1me;
        }));
        const An1me = {
            name: "An1me",
            domain: "https://an1me.nl",
            languages: [ "Greek" ],
            type: "anime",
            isSyncPage(url) {
                const breadcrumbElement = j.$("#manga-reading-nav-head > div > div.entry-header_wrap > div > div.c-breadcrumb");
                return void 0 !== url.split("/")[5] && url.split("/")[5].length > 0 && 0 !== breadcrumbElement.length;
            },
            isOverviewPage(url) {
                const titleElement = j.$("div.site-content > div > div.profile-manga > div > div > div > div.post-title > h1");
                return !(!url.split("/")[4] || 0 === titleElement.length);
            },
            sync: {
                getTitle: url => j.$("ol.breadcrumb > li:nth-child(2) > a").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4).toString(),
                getOverviewUrl: url => j.$("ol.breadcrumb > li:nth-child(2) > a").attr("href") || "",
                getEpisode(url) {
                    const urlParts = url.split("/");
                    if (!urlParts || 0 === urlParts.length) return NaN;
                    const episodePart = urlParts[5];
                    if (0 === episodePart.length) return NaN;
                    const temp = episodePart.match(/episode-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl(url) {
                    const href = j.$("div.select-pagination > div > div.nav-next > a").attr("href");
                    return href && An1me.sync.getEpisode(url) < An1me.sync.getEpisode(href) ? href : "";
                }
            },
            overview: {
                getTitle: url => utils.getBaseText(j.$("div.profile-manga > div > div > div > div.post-title > h1")).trim(),
                getIdentifier: url => utils.urlPart(url, 4) || "",
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing">\n              <div id= "MALSyncheading" class="c-blog__heading style-2 font-heading">\n                <h2 class="h4">\n                  <i class="icon ion-ios-star"></i>\n                  MAL-Sync\n                </h2>\n              </div>\n              ${selector}\n            </div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.page-content-listing.single-page > div > ul > li.wp-manga-chapter"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), An1me.domain),
                    elementEp: selector => An1me.sync.getEpisode(An1me.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(519).toString()), j.$(document).ready((function() {
                    void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaJar;
        }));
        const MangaJar = {
            name: "MangaJar",
            domain: "https://mangajar.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "chapter" === url.split("/")[5],
            isOverviewPage: url => !(void 0 === url.split("/")[4] || !url.split("/")[4].length),
            sync: {
                getTitle: url => j.$("div.container-fluid.chapter-container > div > h1 > a").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => utils.absoluteLink(j.$("div.container-fluid.chapter-container > div > h1 > a").attr("href"), MangaJar.domain),
                getEpisode: url => parseInt(utils.urlPart(url, 6)),
                getVolume(url) {
                    let temp = utils.getBaseText(j.$("div.container-fluid.chapter-container > div > h1")).match(/(vol\.|volume)\D?\d+/i);
                    return temp && (temp = temp[0].match(/\d+/), temp) ? parseInt(temp[0]) : 0;
                },
                nextEpUrl: url => utils.absoluteLink(j.$("body > div.container-fluid.chapter-container > div.row.text-center > div > a.btn-primary").first().attr("href"), MangaJar.domain)
            },
            overview: {
                getTitle: url => j.$("h1.entry-title > span.post-name").text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("h1.entry-title").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.chaptersList > li.chapter-item"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href") || "", MangaJar.domain),
                    elementEp: selector => MangaJar.sync.getEpisode(MangaJar.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(521).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeDao;
        }));
        const AnimeDao = {
            name: "AnimeDao",
            domain: "https://animedao.to",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !("view" !== url.split("/")[3] || void 0 === url.split("/")[4] || !url.split("/")[4].length),
            isOverviewPage: url => !("anime" !== url.split("/")[3] || void 0 === url.split("/")[4] || !url.split("/")[4].length),
            sync: {
                getTitle: url => j.$("h2.page_title").text().replace(/episode.*/i, "").trim(),
                getIdentifier: url => utils.urlPart(AnimeDao.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => utils.absoluteLink(j.$('#videocontent a[href*="/anime/"]').attr("href") || "", AnimeDao.domain),
                getEpisode(url) {
                    const text = j.$("h2.page_title").text().toLowerCase();
                    if (text.includes("special") || text.includes("ova") || text.includes("movie")) throw new Error("specials are not supported");
                    if (!text.includes("episode")) throw new Error("episode is missing");
                    return episodePartToEpisode(text);
                },
                nextEpUrl(url) {
                    const href = j.$("div.btn-group > a > button > span.glyphicon-arrow-right").closest("a").attr("href");
                    return href || "";
                }
            },
            overview: {
                getTitle: url => j.$("div.animeinfo-div > div > h2 > b").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.animeinfo-div > div > h2").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#eps > div:nth-child(1) > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), AnimeDao.domain),
                    elementEp(selector) {
                        try {
                            return episodePartToEpisode(selector.text());
                        } catch (error) {
                            return NaN;
                        }
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(523).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
        function episodePartToEpisode(string) {
            let temp = [];
            return temp = string.match(/(episode)\D?\d+/i), null !== temp && (temp = (string = temp[0]).match(/\d+/), 
            null !== temp) ? temp[0] : 1;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Otakustv;
        }));
        const Otakustv = {
            name: "Otakustv",
            domain: "https://www.otakustv.com",
            languages: [ "Spanish" ],
            type: "anime",
            isSyncPage: url => !!utils.urlPart(url, 5),
            isOverviewPage: url => !(!utils.urlPart(url, 4) || utils.urlPart(url, 5)),
            sync: {
                getTitle(url) {
                    const title = j.$("title").text().trim(), content = j.$(".epsd h1").text().trim();
                    let endTitle = "";
                    for (let i = 0; i < title.length; i++) title[i] && content[i] && title[i] === content[i] && (endTitle += title[i]);
                    return endTitle.trim();
                },
                getIdentifier: url => Otakustv.overview.getIdentifier(url),
                getOverviewUrl: url => `${Otakustv.domain}/anime/${Otakustv.sync.getIdentifier(url)}`,
                getEpisode: url => getEpisode(url),
                nextEpUrl(url) {
                    const href = j.$(".vid_next a").first().attr("href");
                    return void 0 === href || href.includes(":void(0)") ? "" : utils.absoluteLink(href, Otakustv.domain);
                }
            },
            overview: {
                getTitle: url => j.$(".inn-text h1").first().text().trim(),
                getIdentifier(url) {
                    const urlPart4 = utils.urlPart(url, 4);
                    return urlPart4 || "";
                },
                uiSelector(selector) {
                    j.$(".inn-text h1").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episodios-bottom .row > div"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Otakustv.domain),
                    elementEp: selector => getEpisode(Otakustv.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(525).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
        function getEpisode(url) {
            const epPath = utils.urlPart(url, 5).toLowerCase();
            if ("pelicula" === epPath) return 1;
            const temp = epPath.match(/\d+$/gim);
            return temp && 0 !== temp.length ? Number(temp) : 1;
        }
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(con, api, utils, j) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Komga;
        }));
        var __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function apiCall(url) {
            return __awaiter(this, void 0, void 0, (function*() {
                return url = window.location.origin + url, con.log("Api Call", url), api.request.xhr("GET", url);
            }));
        }
        const chapter = {
            pid: "",
            name: "",
            chapter: "",
            mode: "chapter"
        }, Komga = {
            name: "Komga",
            domain: "https://komga.org",
            languages: [ "Many" ],
            type: "manga",
            isSyncPage: url => "read" === utils.urlPart(url, 5),
            isOverviewPage: url => "series" === utils.urlPart(url, 3) && "read" !== utils.urlPart(url, 5),
            sync: {
                getTitle(url) {
                    if (!chapter.name) throw "No name";
                    return chapter.name;
                },
                getIdentifier(url) {
                    if (!chapter.pid) throw "No pid";
                    return chapter.pid;
                },
                getOverviewUrl: url => `${window.location.origin}/series/${chapter.pid}`,
                getEpisode(url) {
                    if ("chapter" !== chapter.mode) return 0;
                    if (!chapter.chapter || !parseInt(chapter.chapter)) throw "No chapter number";
                    return parseInt(chapter.chapter);
                },
                getVolume(url) {
                    if ("volume" !== chapter.mode) return 0;
                    if (!chapter.chapter || !parseInt(chapter.chapter)) throw "No volume number";
                    return parseInt(chapter.chapter);
                }
            },
            overview: {
                getTitle: () => j.$(".v-toolbar__title > span:nth-child(1)").first().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".text-h5").first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.my-2"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href"), Komga.domain),
                    elementEp(selector) {
                        const chapterAsText = selector.find("div:nth-child(1) > a:nth-child(2) > div:nth-child(1)").first().text().split(" - ")[0].replace(/( |#)/g, "");
                        return Number(chapterAsText);
                    }
                }
            },
            init(page) {
                let checker;
                function loaded() {
                    chapter.chapter = "", chapter.name = "", chapter.pid = "", chapter.mode = "chapter", 
                    page.strongVolumes = !1, clearInterval(checker), Komga.isOverviewPage(window.location.href) ? checker = utils.waitUntilTrue(() => Komga.overview.getTitle(window.location.href), () => {
                        con.log("pagehandle"), page.reset(), page.handlePage();
                    }) : Komga.isSyncPage(window.location.href) ? apiCall("/api/v1/books/" + utils.urlPart(window.location.href, 4)).then(res => {
                        const jn = JSON.parse(res.responseText);
                        if (!jn.seriesId) throw "No seriesId found";
                        return con.m("Book").log(jn), chapter.chapter = jn.metadata.number, chapter.pid = jn.seriesId, 
                        apiCall("/api/v1/series/" + jn.seriesId);
                    }).then(res => {
                        const jn = JSON.parse(res.responseText);
                        if (con.m("Series").log(jn), chapter.name = jn.name, jn.metadata && jn.metadata.tags && jn.metadata.tags.length) {
                            const lowerArray = jn.metadata.tags.map(el => el.toLowerCase());
                            (lowerArray.includes("volume") || lowerArray.includes("volumes")) && (chapter.mode = "volume", 
                            page.strongVolumes = !0);
                        }
                        con.m("Object").log(chapter), page.reset(), page.handlePage();
                    }) : page.reset();
                }
                api.storage.addStyle(__webpack_require__(527).toString()), loaded(), utils.changeDetect(loaded, () => window.location.href.split("?")[0].split("#")[0]);
            }
        };
    }).call(this, __webpack_require__(4), __webpack_require__(0), __webpack_require__(1), __webpack_require__(2));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeWho;
        }));
        const AnimeWho = {
            name: "AnimeWho",
            domain: "https://animewho.com",
            languages: [ "Turkish" ],
            type: "anime",
            isSyncPage: url => "true" === j.$("#malsync-data").attr("issyncpage"),
            sync: {
                getTitle: url => j.$("#malsync-data").attr("name"),
                getIdentifier: url => `${j.$("#malsync-data").attr("type")}-${j.$("#malsync-data").attr("series_id")}`,
                getOverviewUrl: url => utils.absoluteLink(j.$("#malsync-data").attr("overview_link"), AnimeWho.domain),
                getEpisode: url => Number(j.$("#malsync-data").attr("episode")),
                nextEpUrl: url => j.$("#malsync-data").attr("next_episode") ? utils.absoluteLink(j.$("#malsync-data").attr("next_episode"), AnimeWho.domain) : "",
                getMalUrl: provider => !(!j.$("#malsync-data").attr("mal_url") || "-" === j.$("#malsync-data").attr("mal_url")) && j.$("#malsync-data").attr("mal_url")
            },
            overview: {
                getTitle: url => AnimeWho.sync.getTitle(url),
                getIdentifier: url => AnimeWho.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$("#malsync_selector").append(j.html(selector));
                },
                getMalUrl: provider => AnimeWho.sync.getMalUrl(provider)
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(529).toString());
                let oldHtml = "";
                utils.fullUrlChangeDetect((function() {
                    page.reset(), function() {
                        j.$("#malsync-data").length || (oldHtml = "");
                        clearInterval(interval), interval = utils.waitUntilTrue((function() {
                            return !(!j.$("#malsync-data").length || j.$("#malsync-data").prop("outerHTML") === oldHtml) && (oldHtml = j.$("#malsync-data").prop("outerHTML"), 
                            !0);
                        }), (function() {
                            "anime" === j.$("#malsync-data").attr("type") ? AnimeWho.type = "anime" : AnimeWho.type = "manga", 
                            page.handlePage();
                        }));
                    }();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeSuge;
        }));
        const AnimeSuge = {
            name: "AnimeSuge",
            domain: "https://animesuge.io",
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => !0,
            sync: {
                getTitle: url => j.$("h1.title").text(),
                getIdentifier(url) {
                    const splitUrl = utils.urlPart(url, 4).split("-");
                    return splitUrl[splitUrl.length - 1];
                },
                getOverviewUrl: url => utils.absoluteLink(j.$("ul.episodes > li > a").first().attr("href"), AnimeSuge.domain),
                getEpisode: url => parseInt(j.$("ul.episodes > li > a.active").attr("data-base")),
                nextEpUrl(url) {
                    const nextEp = j.$("ul.episodes > li > a.active").parent("li").next().find("a").attr("href");
                    return nextEp ? utils.absoluteLink(nextEp, AnimeSuge.domain) : nextEp;
                },
                uiSelector(selector) {
                    j.$("#episodes").after(j.html(`<section>${selector}</section>`));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector(selector) {},
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul.episodes > li > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), AnimeSuge.domain),
                    elementEp: selector => Number(selector.attr("data-base"))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(531).toString()), AnimeSuge.database = "9anime", 
                utils.waitUntilTrue((function() {
                    return j.$("ul.episodes > li").length;
                }), (function() {
                    con.info("Start check"), page.handlePage(), utils.urlChangeDetect((function() {
                        con.info("Check"), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Toonily;
        }));
        const Toonily = {
            name: "Toonily",
            domain: "https://toonily.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length >= 9,
            sync: {
                getTitle: url => j.$('.breadcrumb li > a[href*="/manga/"]').text().trim(),
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$('.breadcrumb li > a[href*="/manga/"]').attr("href"), Toonily.domain) || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : NaN;
                },
                nextEpUrl: url => j.$('.nav-links .nav-next a:not([class^="back"])').attr("href")
            },
            overview: {
                getTitle: url => Toonily.sync.getTitle(url),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".tab-summary").first().after(j.html(`<div id="MALSyncheading" class="post-content_item"> <h6 class="text-highlight">MAL-Sync</h6></div><div id="malthing" class="post-content_item">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div.listing-chapters_wrap > ul > li.wp-manga-chapter"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").attr("href"), Toonily.domain),
                    elementEp: selector => Toonily.sync.getEpisode(Toonily.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(533).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Fumetsu;
        }));
        const Fumetsu = {
            name: "Fumetsu",
            domain: "https://fumetsu.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage: url => "" !== url.split("/")[5],
            sync: {
                getTitle: url => j.$(".text-center > a > h2").text() || "",
                getIdentifier: url => url.split("/")[4],
                getOverviewUrl: url => utils.absoluteLink(j.$(".text-center > a").first().attr("href"), Fumetsu.domain),
                getEpisode: url => getEpNumber(j.$(".text-center > h5").text()),
                nextEpUrl(url) {
                    const nextEp = j.$(".text-center > a.float-right").attr("href");
                    return nextEp ? utils.absoluteLink(nextEp, Fumetsu.domain) : nextEp;
                }
            },
            overview: {
                getTitle: url => j.$(".ep-info h2").first().text(),
                getIdentifier: url => Fumetsu.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$(".newsy.container > .row").first().before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episodes"),
                    elementUrl: selector => utils.absoluteLink(j.$(selector).parent().attr("href"), Fumetsu.domain),
                    elementEp: selector => getEpNumber(j.$(selector).find(".float-left").text())
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(535).toString()), j.$(document).ready((function() {
                    "anime" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && page.handlePage();
                }));
            }
        };
        function getEpNumber(text) {
            const ep = text.trim().match(/Odcinek:?\s?([0-9]+)/);
            return ep ? Number(ep[1]) : ep;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return NonstopScans;
        }));
        const NonstopScans = {
            name: "NonstopScans",
            domain: "https://www.nonstopscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => !!j.$("div#content.readercontent").length,
            sync: {
                getTitle: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox span")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(NonstopScans.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 3).match(/\d+/);
                    return temp && 0 !== temp.length ? Number(temp) : 1;
                },
                nextEpUrl(url) {
                    const next = j.$("a.ch-next-btn").attr("href");
                    if ("#/next/" !== next) return next;
                }
            },
            overview: {
                getTitle: url => j.$("h1.entry-title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.bixbox.animefull").first().after(j.html(`<div id= "malthing" class="bixbox animefull">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#chapterlist li div.chbox"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => NonstopScans.sync.getEpisode(NonstopScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(537).toString()), j.$(document).ready((function() {
                    (j.$("div#content.readercontent").length || "manga" === page.url.split("/")[3] && "" !== page.url.split("/")[4]) && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return FrixySubs;
        }));
        const FrixySubs = {
            name: "FrixySubs",
            domain: "https://frixysubs.pl",
            languages: [ "Polish" ],
            type: "anime",
            isSyncPage: url => !!url.split("/")[3].startsWith("ogladaj"),
            isOverviewPage: url => !!url.split("/")[3].startsWith("odcinki"),
            sync: {
                getTitle(url) {
                    const title = j.$("#anime-watch-title").text();
                    return title || (j.$("#watch-title").text() || "");
                },
                getIdentifier(url) {
                    if ("true" === utils.urlParam(url, "video")) {
                        return (utils.urlParam(url, "id") || "") + "v";
                    }
                    return j.$('.watch-player-button:contains("WrÃ³Ä‡")').attr("idd") || "";
                },
                getOverviewUrl(url) {
                    const id = j.$('.watch-player-button:contains("WrÃ³Ä‡")').attr("idd");
                    return id ? utils.absoluteLink("odcinki.html?id=" + id, FrixySubs.domain) : "";
                },
                getEpisode: url => getEpNumber(j.$("#watch-title").text(), /\|#(\d+)/),
                nextEpUrl(url) {
                    const id = j.$('.watch-player-button:contains("NastÄ™pny")').attr("idd");
                    return id ? utils.absoluteLink("ogladaj.html?id=" + id, FrixySubs.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("#series-info-title").text(),
                getIdentifier: url => utils.urlParam(url, "id") || "",
                uiSelector(selector) {
                    j.$("#series-info").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episodes-episode"),
                    elementUrl(selector) {
                        const id = j.$(selector).attr("idd");
                        return utils.absoluteLink("ogladaj.html?id=" + id, FrixySubs.domain);
                    },
                    elementEp: selector => getEpNumber(j.$(selector).find(".episodes-h1").text(), /Odcinek (\d+)/)
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(539).toString()), j.$(document).ready((function() {
                    const urlPart = page.url.split("/")[3];
                    (urlPart.startsWith("ogladaj") || urlPart.startsWith("odcinki")) && utils.waitUntilTrue(() => !(!FrixySubs.overview.getTitle(page.url).length && !FrixySubs.sync.getTitle(page.url).length), () => {
                        page.handlePage();
                    });
                }));
            }
        };
        function getEpNumber(text, pattern) {
            const ep = text.match(pattern);
            return ep ? parseInt(ep[1]) : 1;
        }
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Guya;
        }));
        const excluded = [ "gist", "imgur" ], Guya = {
            name: "Guya & Cubari",
            domain: [ "https://guya.moe", "https://cubari.moe" ],
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => "read" === url.split("/")[3] && !excluded.includes(url.split("/")[4]) && url.split("/").length >= 8,
            isOverviewPage: url => "read" === url.split("/")[3] && !excluded.includes(url.split("/")[4]) && url.split("/").length >= 6,
            sync: {
                getTitle: url => j.$("#rdr-main > aside > header > h1 > a").text(),
                getIdentifier: url => utils.urlPart(url, 5),
                getOverviewUrl: url => utils.absoluteLink(j.$("#rdr-main > aside > header > h1 > a").attr("href"), Guya.domain),
                getEpisode: url => parseInt(utils.urlPart(url, 6))
            },
            overview: {
                getTitle: url => j.$("div.series-content > article > h1, article content > h1").first().text(),
                getIdentifier: url => utils.urlPart(url, 5),
                uiSelector(selector) {
                    j.$("div.series-content > article").after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#detailedView, div#compactView, tbody#chapterTable").not(".d-none").first().find(`a[href*="/read/${utils.urlPart(window.location.href, 4)}"]`),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href") || "", Guya.domain),
                    elementEp: selector => Guya.sync.getEpisode(Guya.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(541).toString());
                let urlWithoutPage = "";
                utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return !(!Guya.overview.getTitle(window.location.href).length && !Guya.sync.getTitle(window.location.href).length);
                    }), (function() {
                        if (window.location.href.split("/").slice(0, 7).join("/") !== urlWithoutPage) {
                            switch (urlWithoutPage = window.location.href.split("/").slice(0, 7).join("/"), 
                            window.location.href.split("/")[4]) {
                              case "mangadex":
                                Guya.database = "Mangadex";
                                break;

                              case "mangasee":
                                Guya.database = "MangaSee";
                                break;

                              default:
                                Guya.database = void 0;
                            }
                            page.handlePage();
                        }
                    }));
                })), j.$(document).on("click", "div.series-content > div.btn-group", () => {
                    page.handleList();
                });
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaHub;
        }));
        const MangaHub = {
            name: "MangaHub",
            domain: "https://mangahub.io",
            languages: [ "English" ],
            type: "manga",
            getImage: () => $("#mangadetail img.manga-thumb").first().attr("src"),
            isSyncPage: url => !!j.$("#mangareader").length,
            isOverviewPage: url => !!j.$("#mangadetail").length,
            sync: {
                getTitle: url => j.$("#mangareader .container-fluid h3 a").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$("#mangareader .container-fluid h3 a").attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                },
                nextEpUrl: url => j.$("#mangareader ul.dropdown-menu li.active").next().find("a").attr("href")
            },
            overview: {
                getTitle: url => j.$("#mangadetail h1").clone().children().remove().end().text(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#mangadetail section._2fecr").after(j.html(`<section id="malthing" class="_2fecr"><div style="background-color: inherit;" class="container-fluid"><div class="row" style="background-color: inherit;"><div class="col-md-1"><span style="font-weight: 700;">MALSync:</span></div><div class="col-md-11" style="background-color: inherit;">${selector}</div></div></div></section>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#noanim-content-tab div li"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => MangaHub.sync.getEpisode(MangaHub.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                let Interval;
                function start() {
                    j.$("#mangareader").length && (clearInterval(Interval), Interval = utils.waitUntilTrue((function() {
                        return j.$("#mangareader ul.dropdown-menu li.active").length;
                    }), (function() {
                        page.handlePage();
                    }))), j.$("#mangadetail").length && (j.$("#malthing").length && j.$("#malthing").remove(), 
                    clearInterval(Interval), Interval = utils.waitUntilTrue((function() {
                        return j.$("#mangadetail div.ads-container").length > 0;
                    }), (function() {
                        page.handlePage();
                    })));
                }
                api.storage.addStyle(__webpack_require__(543).toString()), j.$(document).ready((function() {
                    start(), utils.changeDetect(() => {
                        page.reset(), start();
                    }, () => j.$("head > title").text());
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, api, utils) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ComicK;
        }));
        const ComicK = {
            name: "ComicK",
            domain: "https://comick.fun",
            languages: [ "Many" ],
            type: "manga",
            isSyncPage: url => void 0 !== jsonData.chap,
            sync: {
                getTitle: url => jsonData.md_comic.title,
                getIdentifier: url => jsonData.md_comic.id,
                getOverviewUrl: url => jsonData.comic_url,
                getEpisode: url => parseInt(jsonData.chap) || 1,
                getVolume: url => jsonData.vol || 0,
                getMalUrl(provider) {
                    if (jsonData.md_comic.links) {
                        if (jsonData.md_comic.links.mal) return "https://myanimelist.net/manga/" + jsonData.md_comic.links.mal;
                        if ("ANILIST" === provider && jsonData.md_comic.links.al) return "https://anilist.co/manga/" + jsonData.md_comic.links.al;
                    }
                    return !1;
                }
            },
            overview: {
                getTitle: url => jsonData.title,
                getIdentifier: url => jsonData.id,
                uiSelector(selector) {
                    j.$(jsonData.selector_position).first().append(j.html(selector));
                },
                getMalUrl(provider) {
                    if (jsonData.links) {
                        if (jsonData.links.mal) return "https://myanimelist.net/manga/" + jsonData.links.mal;
                        if ("ANILIST" === provider && jsonData.links.al) return "https://anilist.co/manga/" + jsonData.links.al;
                    }
                    return !1;
                }
            },
            init(page) {
                let interval;
                api.storage.addStyle(__webpack_require__(545).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return j.$("#__MALSYNC__").length;
                    }), (function() {
                        jsonData = JSON.parse(j.$("#__MALSYNC__").text()), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(0), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimeShitai;
        }));
        const AnimeShitai = {
            name: "AnimeShitai",
            domain: "https://www.anime-shitai.com",
            languages: [ "German" ],
            type: "anime",
            isSyncPage: url => "anschauen" === url.split("/")[3],
            isOverviewPage: url => "info" === url.split("/")[3] || "anime" === url.split("/")[3],
            sync: {
                getTitle: url => j.$("div.title > span.navmiddle").first().text().replace(/(?=-).*?$/, "").replace(/:\s*$/, "").replace(/staffel/gi, "season").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => utils.absoluteLink(j.$('div.content > div.dish > a[href*="/info"]').attr("href"), AnimeShitai.domain),
                getEpisode(url) {
                    const temp = url.split("/")[6].match(/(folge|episode|ep)-\d+/i);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => utils.absoluteLink(j.$("div.content div.eright").parent("a").attr("href"), AnimeShitai.domain)
            },
            overview: {
                getTitle: url => j.$("div.title > animename").text().replace(/staffel/gi, "season"),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("#ani > div.body > div.br").first().prepend(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("table.ep_table > tbody > tr"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("onclick").match(/window\.location\.href='(.+?)'/i)[1], AnimeShitai.domain),
                    elementEp: selector => AnimeShitai.sync.getEpisode(AnimeShitai.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(547).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return KangaryuTeam;
        }));
        const KangaryuTeam = {
            name: "KangaryuTeam",
            domain: "https://kangaryu-team.fr",
            languages: [ "French" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: () => j.$("#navbar-collapse-1 > ul > li:nth-child(1) > a").text().replace("Manga", "").trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => `${KangaryuTeam.domain}/manga/${utils.urlPart(url, 4)}`,
                getEpisode: url => parseInt(utils.urlPart(url, 5)),
                nextEpUrl: () => j.$("#chapter-list .dropdown-menu li.active").prev().find("a").attr("href")
            },
            overview: {
                getTitle: () => j.$(".titre-projets").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.bg > div:nth-child(3)").first().before(j.html(`<div class="col-lg-12"><div class="well2">${selector}</div></div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".chapters > li"),
                    elementUrl: selector => utils.absoluteLink(selector.find('a[href*="/manga/"]').attr("href") || "", KangaryuTeam.domain),
                    elementEp: selector => KangaryuTeam.sync.getEpisode(KangaryuTeam.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(549).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api, con) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Japanread;
        }));
        const Japanread = {
            name: "Japanread",
            domain: "https://www.japanread.cc/",
            languages: [ "French" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[5] && url.split("/")[5].length > 0,
            sync: {
                getTitle: () => j.$(".reader-controls-title > div > a").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => url.substr(0, url.lastIndexOf("/")),
                getEpisode: url => parseInt(utils.urlPart(url, 5)),
                getVolume() {
                    const currentChapter = j.$("#jump-chapter option:selected");
                    if (currentChapter.length) {
                        let temp = currentChapter.text().trim().match(/(vol\.|volume)\D?\d+/i);
                        if (null !== temp && (temp = temp[0].match(/\d+/), null !== temp)) return parseInt(temp[0]);
                    }
                    return 0;
                },
                nextEpUrl(url) {
                    const nextChapter = j.$("#jump-chapter option:selected").prev();
                    if (nextChapter && void 0 !== nextChapter) {
                        let temp = nextChapter.text().trim().match(/(ch\.|chapitre)\D?\d+/i);
                        if (null !== temp && (temp = temp[0].replace(".", "-").match(/\d+/), null !== temp)) return utils.absoluteLink(temp[0], Japanread.sync.getOverviewUrl(url));
                    }
                    return "";
                }
            },
            overview: {
                getTitle: () => j.$("h1.card-header").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$(".card.card-manga .card-body .row.edit .col-md-7").first().append(j.html('<div class="row m-0 py-1 px-0 border-top"><div class="col-lg-3 col-xl-2 strong">MAL-Sync:</div><div class="col-lg-9 col-xl-10 mal-sync"></div></div>')), 
                    j.$(".container .card .mal-sync").first().append(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("[data-row=chapter]"),
                    elementUrl: selector => 0 === j.$("#navbar-guest").length ? utils.absoluteLink(selector.find("a").eq(1).attr("href"), Japanread.domain) : utils.absoluteLink(selector.find("a").first().attr("href"), Japanread.domain),
                    elementEp: selector => Japanread.sync.getEpisode(Japanread.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(551).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && (con.info("Waiting"), 
                    utils.waitUntilTrue(() => "" !== j.$("#jump-chapter option:selected").text() || j.$("[data-row=chapter]").length, () => {
                        con.info("Start"), page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0), __webpack_require__(4));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(utils, j, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CatManga;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let pageData;
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        proxy.addCaptureVariable("NEXT_DATA", '\n    if (window.hasOwnProperty("__NEXT_DATA__")) {\n      return __NEXT_DATA__;\n    } else {\n      return undefined;\n    }\n  ');
        const CatManga = {
            name: "CatManga",
            domain: "https://catmanga.org",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => !("series" !== url.split("/")[3] || void 0 === url.split("/")[5] || !url.split("/")[5].length),
            isOverviewPage: url => !("series" !== url.split("/")[3] || void 0 === url.split("/")[4] || !url.split("/")[4].length),
            sync: {
                getTitle: url => pageData.title,
                getIdentifier: url => pageData.series_id,
                getOverviewUrl: url => `${CatManga.domain}/series/${CatManga.sync.getIdentifier(url)}`,
                getEpisode: url => parseInt(utils.urlPart(url, 5)) || 1,
                nextEpUrl(url) {
                    const nextEpNr = CatManga.sync.getEpisode(url) + 1;
                    return pageData.chapters.find(el => el.number === nextEpNr) && nextEpNr ? `${CatManga.sync.getOverviewUrl(url)}/${nextEpNr}` : "";
                }
            },
            overview: {
                getTitle: url => CatManga.sync.getTitle(url),
                getIdentifier: url => CatManga.sync.getIdentifier(url),
                uiSelector(selector) {
                    j.$('p:contains("Chapter")').first().after(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(`a[href^="/series/${CatManga.sync.getIdentifier(window.location.href)}/"]`),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href") || "", CatManga.domain),
                    elementEp(selector) {
                        var _a, _b;
                        return CatManga.sync.getEpisode((null === (_b = null === (_a = CatManga.overview) || void 0 === _a ? void 0 : _a.list) || void 0 === _b ? void 0 : _b.elementUrl(selector)) || "");
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(553).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), function() {
                        (CatManga.isOverviewPage(window.location.href) || CatManga.isSyncPage(window.location.href)) && proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                            const nextData = function() {
                                const meta = proxy.getCaptureVariable("NEXT_DATA");
                                if (!(meta instanceof Object)) throw new Error("Invalid metadata");
                                return meta;
                            }(), {buildId: buildId} = nextData, seriesId = utils.urlPart(window.location.href, 4), xhr = new XMLHttpRequest;
                            xhr.onload = () => {
                                200 === xhr.status && (pageData = JSON.parse(xhr.responseText).pageProps.series, 
                                page.handlePage());
                            }, xhr.open("GET", `https://catmanga.org/_next/data/${buildId}/series/${seriesId}.json`), 
                            xhr.send();
                        })));
                    }();
                }), !0);
            }
        };
    }).call(this, __webpack_require__(1), __webpack_require__(2), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MangaSushi;
        }));
        const MangaSushi = {
            name: "MangaSushi",
            domain: "https://mangasushi.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => $("div.wp-manga-nav").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => j.$("div.entry-header.header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => j.$("ol.breadcrumb li a").last().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => MangaSushi.sync.getEpisode(MangaSushi.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(555).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ArangScans;
        }));
        const ArangScans = {
            name: "ArangScans",
            domain: "https://arangscans.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => $("div.wp-manga-nav").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    let episodePartAS = utils.urlPart(url, 5);
                    episodePartAS.match(/volume-\d+/gim) && (episodePartAS = utils.urlPart(url, 6));
                    const temp = episodePartAS.match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                }
            },
            overview: {
                getTitle: url => j.$("ol.breadcrumb li a").last().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => ArangScans.sync.getEpisode(ArangScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(557).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TritiniaScans;
        }));
        const TritiniaScans = {
            name: "TritiniaScans",
            domain: "https://tritinia.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => j.$('div.wp-manga-nav div.chapter-selection.chapters_selectbox_holder option.short[selected="selected"]').length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[2]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[2]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/ch-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => j.$('div.chapter-selection.chapters_selectbox_holder option.short[selected="selected"]').first().prev().attr("data-redirect")
            },
            overview: {
                getTitle: url => j.$("ol.breadcrumb li a").last().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => TritiniaScans.sync.getEpisode(TritiniaScans.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(559).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$('div.wp-manga-nav div.chapter-selection.chapters_selectbox_holder option.short[selected="selected"]').length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ReadManhua;
        }));
        const ReadManhua = {
            name: "ReadManhua",
            domain: "https://readmanhua.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => $("div.wp-manga-nav").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => j.$("div.entry-header.header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => j.$("ol.breadcrumb li a").last().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => ReadManhua.sync.getEpisode(ReadManhua.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(561).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return FlameScans;
        }));
        const FlameScans = {
            name: "FlameScans",
            domain: "https://flamescans.org",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => !!j.$("div#content.readercontent").length,
            sync: {
                getTitle: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox span")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(FlameScans.sync.getOverviewUrl(url), 4),
                getOverviewUrl: url => j.$(j.$("div#content.readercontent div.ts-breadcrumb.bixbox a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = j.$('select#chapter option[selected="selected"]').first().text().match(/chapter \d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                },
                nextEpUrl(url) {
                    const next = j.$("a.ch-next-btn").attr("href");
                    if ("#/next/" !== next) return next;
                }
            },
            overview: {
                getTitle: url => j.$("h1.entry-title").text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.info-desc.bixbox").first().after(j.html(`<div id= "malthing" class="bixbox animefull">${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("div#chapterlist li div.chbox"),
                    elementUrl: selector => selector.parent().attr("href") || "",
                    elementEp(selector) {
                        const temp = selector.find("span").first().text().match(/chapter \d+/gim);
                        return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                    }
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(563).toString()), j.$(document).ready((function() {
                    "series" === page.url.split("/")[3] && "" !== page.url.split("/")[4] && page.handlePage(), 
                    j.$("div#content.readercontent").length && utils.waitUntilTrue((function() {
                        return !!j.$('select#chapter option[selected="selected"]').first().length;
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ImmortalUpdates;
        }));
        const ImmortalUpdates = {
            name: "ImmortalUpdates",
            domain: "https://immortalupdates.com",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => $("div.wp-manga-nav").length > 0,
            sync: {
                getTitle: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                getOverviewUrl: url => j.$(j.$("div.c-breadcrumb-wrapper ol.breadcrumb li a")[1]).attr("href") || "",
                getEpisode(url) {
                    const temp = utils.urlPart(url, 5).match(/chapter-\d+/gim);
                    return temp && 0 !== temp.length ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl: url => j.$("div.entry-header.header > div > div.select-pagination > div.nav-links > div.nav-next > a.next_page").attr("href")
            },
            overview: {
                getTitle: url => j.$("ol.breadcrumb li a").last().text().trim(),
                getIdentifier: url => utils.urlPart(url, 4),
                uiSelector(selector) {
                    j.$("div.c-page__content div.c-blog__heading").first().before(j.html(`<div id="malthing"><div id= "MALSyncheading" class="c-blog__heading style-2 font-heading"><h2 class="h4"> <i class="icon ion-ios-star"></i> MAL-Sync</h2></div>${selector}</div>`));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("ul > li.wp-manga-chapter"),
                    elementUrl: selector => selector.find("a").first().attr("href") || "",
                    elementEp: selector => ImmortalUpdates.sync.getEpisode(ImmortalUpdates.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(565).toString()), j.$(document).ready((function() {
                    "manga" === page.url.split("/")[3] && void 0 !== page.url.split("/")[4] && page.url.split("/")[4].length > 0 && utils.waitUntilTrue((function() {
                        return !(!j.$("ul > li.wp-manga-chapter").length && !j.$("div.wp-manga-nav").length);
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        let jsonData;
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Zoro;
        }));
        const Zoro = {
            name: "Zoro",
            domain: "https://zoro.to",
            languages: [ "English" ],
            type: "anime",
            database: "Zoro",
            isSyncPage: url => "episode" === jsonData.page,
            isOverviewPage: url => "anime" === jsonData.page,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.anime_id,
                getOverviewUrl: url => jsonData.series_url,
                getEpisode: url => parseInt(jsonData.episode),
                nextEpUrl: url => jsonData.next_episode_url,
                getMalUrl: provider => !!jsonData.mal_id && "https://myanimelist.net/anime/" + jsonData.mal_id
            },
            overview: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.anime_id,
                uiSelector(selector) {
                    j.$(jsonData.selector_position).append(j.html(selector));
                },
                getMalUrl: provider => Zoro.sync.getMalUrl(provider),
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".ss-list > a"),
                    elementUrl: selector => utils.absoluteLink(selector.attr("href"), Zoro.domain),
                    elementEp: selector => Number(selector.attr("data-number"))
                }
            },
            init(page) {
                let interval, _debounce;
                api.storage.addStyle(__webpack_require__(567).toString()), utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        return !!j.$("#syncData").length && (jsonData = JSON.parse(j.$("#syncData").text()), 
                        !0);
                    }), (function() {
                        clearTimeout(_debounce), _debounce = setTimeout(() => {
                            page.handlePage();
                        }, 500);
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Funimation;
        }));
        var _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let idPosition;
        const proxy = new _utils_scriptProxy__WEBPACK_IMPORTED_MODULE_0__.a;
        function extractMetadata() {
            const meta = proxy.getCaptureVariable("TITLE_DATA");
            if (!(meta instanceof Object)) throw new Error("Invalid metadata");
            if ("extras" === meta.alpha) throw new Error("Not a Episode page");
            return meta;
        }
        proxy.addCaptureVariable("TITLE_DATA", "\n    if (window.hasOwnProperty(\"TITLE_DATA\")) {\n      return TITLE_DATA;\n    } else {\n      var bodyh = document.body.innerHTML;\n      if (bodyh.includes('TITLE_DATA')) {\n        var bomatch = bodyh.match(/TITLE_DATA *= *({[^}]*})/);\n\n        if (bomatch) {\n          return {\n            seasonNum: parseInt(bomatch[1].match(/seasonNum *: *(\\d+|null),/)[1]),\n            episodeNum: parseInt(bomatch[1].match(/episodeNum *: *(\\d+|null),/)[1]),\n            alpha: bomatch[1].includes('extras') ? 'extras' : 'something',\n          }\n        }\n      }\n\n      return undefined;\n    }\n  ");
        const Funimation = {
            name: "Funimation",
            domain: "https://www.funimation.com",
            languages: [ "Many" ],
            type: "anime",
            isSyncPage: url => !!j.$("h1.show-headline.video-title").length,
            sync: {
                getTitle(url) {
                    const meta = extractMetadata();
                    let season = "";
                    return meta.seasonNum > 1 && (season = " season " + meta.seasonNum), j.$("h1.show-headline.video-title a").text().trim() + season;
                },
                getIdentifier(url) {
                    const meta = extractMetadata();
                    return `${url.split("/")[idPosition]}?s=${meta.seasonNum}`;
                },
                getOverviewUrl: url => utils.absoluteLink(j.$("h1.show-headline.video-title a").attr("href") || "", Funimation.domain),
                getEpisode: url => extractMetadata().episodeNum || 1
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(569).toString()), j.$(document).ready((function() {
                    utils.waitUntilTrue((function() {
                        return j.$("h1.show-headline.video-title").length;
                    }), (function() {
                        proxy.addProxy(caller => __awaiter(this, void 0, void 0, (function*() {
                            idPosition = window.location.href.split("/").indexOf("shows") + 1, page.handlePage();
                        })));
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Kitsune;
        }));
        var _provider_AniList_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        let jsonData;
        const Kitsune = {
            name: "Kitsune",
            domain: [ "https://beta.kitsune.tv", "https://kitsune.tv" ],
            languages: [ "English" ],
            type: "anime",
            isSyncPage: url => "episode/watch" === jsonData.page,
            sync: {
                getTitle: url => jsonData.name,
                getIdentifier: url => jsonData.anime_id,
                getOverviewUrl: url => jsonData.seriesUrl,
                getEpisode: url => parseInt(jsonData.episode) || 0,
                nextEpUrl: url => j.$(".episodes-list a.active").parents("div").next().find("a").attr("href"),
                getMalUrl(provider) {
                    return __awaiter(this, void 0, void 0, (function*() {
                        try {
                            return "https://myanimelist.net/anime/" + (yield Object(_provider_AniList_helper__WEBPACK_IMPORTED_MODULE_0__.a)(jsonData.anilistId, "anime"));
                        } catch (e) {}
                        return "ANILIST" === provider && "https://anilist.co/anime/" + jsonData.anilistId;
                    }));
                }
            },
            overview: {
                getTitle: url => "",
                getIdentifier: url => "",
                uiSelector(selector) {},
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$(".episodes-list > a"),
                    elementUrl: selector => selector.attr("href") || "",
                    elementEp: selector => Number(utils.getBaseText($(selector)))
                }
            },
            init(page) {
                let interval;
                utils.fullUrlChangeDetect((function() {
                    page.reset(), clearInterval(interval), interval = utils.waitUntilTrue((function() {
                        const elem = j.$("#sync-info");
                        return !(!elem.length || !elem.text() || (jsonData = JSON.parse(elem.text()), 0));
                    }), (function() {
                        page.handlePage();
                    }));
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AnimesOnline;
        }));
        const AnimesOnline = {
            name: "AnimesOnline",
            domain: "https://animesonline.org",
            languages: [ "Portuguese" ],
            type: "anime",
            isSyncPage: url => ("filmes" === url.split("/")[3] || "episodio" === url.split("/")[3]) && url.split("/").length >= 4 && url.split("/")[4].length > 0,
            sync: {
                getTitle: url => j.$("#info > h1, #single > div.content > div.sheader > div.data > h1").first().text().replace(/\s+-\s+episÃ³dio\s+\d+/i, ""),
                getIdentifier: url => utils.urlPart(url, 4).replace(/-episodio-\d+/, ""),
                getOverviewUrl: url => utils.absoluteLink(j.$("#single > div.content > div.pag_episodes > div:nth-child(2) > a").attr("href"), AnimesOnline.domain) || url,
                getEpisode(url) {
                    const temp = utils.urlPart(url, 4).match(/episodio-\d+/gi);
                    return temp ? Number(temp[0].replace(/\D+/g, "")) : 1;
                },
                nextEpUrl(url) {
                    const nextUrl = j.$("#single > div.content > div.pag_episodes > div:nth-child(3) > a").attr("href");
                    return nextUrl && "#" !== nextUrl ? utils.absoluteLink(nextUrl, AnimesOnline.domain) : "";
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(571).toString()), j.$(document).ready((function() {
                    page.handlePage();
                }));
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(j, utils, api) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return LHTranslation;
        }));
        const LHTranslation = {
            name: "LHTranslation",
            domain: "https://lhtranslation.net",
            languages: [ "English" ],
            type: "manga",
            isSyncPage: url => void 0 !== url.split("/")[3] && url.split("/")[3].startsWith("read-") && !/page-([2-9]|1\d+)/.test(url.split("/")[3]),
            isOverviewPage: url => void 0 !== url.split("/")[3] && url.split("/")[3].startsWith("manga-"),
            getImage: () => $(".info-cover > img.thumbnail").attr("src"),
            sync: {
                getTitle: url => j.$("a.manga-name").text(),
                getIdentifier: url => LHTranslation.overview.getIdentifier(LHTranslation.sync.getOverviewUrl(url)),
                getOverviewUrl: url => utils.absoluteLink(j.$("a.manga-name").attr("href") || "", LHTranslation.domain),
                getEpisode(url) {
                    const temp = utils.urlPart(url, 3).match(/chapter[_-]\d+/gi);
                    return temp && temp.length ? Number(temp[0].replace(/\D+/g, "")) : 0;
                },
                nextEpUrl(url) {
                    const next = j.$("ul.chapter_select option:selected").prev().val();
                    return next ? utils.absoluteLink(next, LHTranslation.domain) : "";
                }
            },
            overview: {
                getTitle: url => j.$("ul.manga-info > h1").text(),
                getIdentifier(url) {
                    const part = utils.urlPart(url, 3);
                    return part.substring(part.indexOf("-") + 1, part.lastIndexOf(".") > -1 ? part.lastIndexOf(".") : part.length);
                },
                uiSelector(selector) {
                    j.$("#listchapter").before(j.html(selector));
                },
                list: {
                    offsetHandler: !1,
                    elementsSelector: () => j.$("#list-chapters .titleLink"),
                    elementUrl: selector => utils.absoluteLink(selector.find("a").first().attr("href") || "", LHTranslation.domain),
                    elementEp: selector => LHTranslation.sync.getEpisode(LHTranslation.overview.list.elementUrl(selector))
                }
            },
            init(page) {
                api.storage.addStyle(__webpack_require__(573).toString()), j.$(() => {
                    page.handlePage();
                });
            }
        };
    }).call(this, __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "simkltvdetailonline",
            class: {
                Minimized: _vm.classes.minimized,
                Search: _vm.classes.search
            },
            attrs: {
                id: "malkiss"
            }
        }, [ _c("div", {
            staticClass: "malsync-page-relation"
        }, _vm._l(_vm.pageRelation, (function(page) {
            return _c("a", {
                key: page.title,
                attrs: {
                    href: page.link,
                    target: "_blank",
                    title: page.name
                }
            }, [ _c("img", {
                attrs: {
                    src: page.icon,
                    width: "16",
                    height: "16"
                }
            }) ]);
        })), 0), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlinehead"
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadleft"
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadtitle"
        }, [ _vm._v("Stream online:") ]), _vm._v(" "), _vm.streamUrl ? _c("a", {
            staticClass: "simkltvdetailonlineheadbutton simkltvdetailonlineheadbuttonstream",
            attrs: {
                href: _vm.streamUrl,
                target: "_blank"
            }
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadbuttonimage"
        }, [ _c("img", {
            attrs: {
                src: _vm.favicon(_vm.streamUrl.split("/")[2]),
                alt: "",
                title: _vm.streamUrl.split("/")[2]
            }
        }) ]) ]) : _vm._e(), _vm._v(" "), _vm.continueUrl ? _c("a", {
            staticClass: "simkltvdetailonlineheadbutton",
            attrs: {
                href: _vm.continueUrl,
                target: "_blank"
            }
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadbuttontitle"
        }, [ _vm._v("\n          Watch next episode\n        ") ]), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineheadbuttonico",
            staticStyle: {
                "margin-top": "-4px"
            }
        }) ]) : _vm._e(), _vm._v(" "), _vm.resumeUrl && !_vm.continueUrl ? _c("a", {
            staticClass: "simkltvdetailonlineheadbutton",
            attrs: {
                href: _vm.resumeUrl,
                target: "_blank"
            }
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadbuttontitle"
        }, [ _vm._v("Resume episode") ]), _vm._v(" "), _c("img", {
            staticStyle: {
                filter: "invert(1)",
                "margin-top": "-1px"
            },
            attrs: {
                src: _vm.assetUrl("arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }) ]) : _vm._e(), _vm._v(" "), null === _vm.links || Object.keys(_vm.links).length ? _c("div", {
            staticClass: "simkltvdetailonlineheadbutton Sources",
            on: {
                click: function($event) {
                    return _vm.toggleMinimized();
                }
            }
        }, [ null !== _vm.links && Object.keys(_vm.links).length ? _c("div", {
            staticClass: "simkltvdetailonlineheadbuttontitle"
        }, [ _vm._v("\n          " + _vm._s(Object.keys(_vm.links).length) + " streaming sources\n        ") ]) : _c("div", {
            staticClass: "simkltvdetailonlineheadbuttontitle"
        }, [ _vm._v("Loading") ]), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineheadbuttonicoarrow"
        }) ]) : _vm._e(), _vm._v(" "), null !== _vm.pageSearch ? _c("div", {
            staticClass: "simkltvdetailonlineheadbutton Search",
            on: {
                click: function($event) {
                    return _vm.toggleSearch();
                }
            }
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadbuttontitle"
        }, [ _vm._v("Search") ]), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineheadbuttonicoarrow"
        }) ]) : _vm._e() ]), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineheadright",
            on: {
                click: function($event) {
                    return _vm.pressMinimized();
                }
            }
        }, [ _vm._m(0) ]) ]), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineitems Search"
        }, _vm._l(_vm.pageSearch, (function(page) {
            return _c("div", {
                key: page.search,
                staticClass: "simkltvdetailonlineitemsearch"
            }, [ _c("a", {
                staticClass: "simkltvdetailonlineitemsearchhref",
                attrs: {
                    href: page.search,
                    target: "_blank"
                }
            }, [ _c("div", {
                staticClass: "simkltvdetailonlineitemsearchico"
            }, [ _c("img", {
                staticClass: "simkltvdetailonlineitemsearchicoimg",
                attrs: {
                    src: page.favicon
                }
            }) ]), _vm._v(" "), _c("div", {
                staticClass: "simkltvdetailonlineitemsearchtitle"
            }, [ _vm._v(_vm._s(page.name)) ]) ]), _vm._v(" "), page.googleSeach.length ? _c("a", {
                staticClass: "simkltvdetailonlineitemsearchgoogle",
                attrs: {
                    href: page.googleSeach,
                    target: "_blank"
                }
            }) : _vm._e() ]);
        })), 0), _vm._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineitems Links"
        }, [ null === _vm.links ? _c("div", [ _vm._v("Loading") ]) : _vm._e(), _vm._v(" "), _vm._l(_vm.links, (function(page) {
            return _c("div", {
                key: page.name,
                staticClass: "simkltvdetailonlineitem"
            }, [ _c("div", {
                staticClass: "simkltvdetailonlineitemtop"
            }, [ _c("div", {
                staticClass: "simkltvdetailonlineitemico"
            }, [ _c("img", {
                attrs: {
                    src: _vm.getMal2KissFavicon(page.domain),
                    alt: ""
                }
            }) ]), _vm._v(" "), _c("div", {
                staticClass: "simkltvdetailonlineitemname"
            }, [ _vm._v(_vm._s(page.name)) ]), _vm._v(" "), _c("div", {
                staticClass: "simkltvdetailonlineitemclose",
                on: {
                    click: function($event) {
                        return _vm.removeSource(page);
                    }
                }
            }) ]), _vm._v(" "), _c("div", {
                staticClass: "simkltvdetailonlineitemlinks"
            }, _vm._l(page.links, (function(stream) {
                return _c("a", {
                    key: stream.url,
                    staticClass: "simkltvdetailonlineitemhref",
                    attrs: {
                        target: "_blank",
                        href: stream.url
                    }
                }, [ _vm._v(_vm._s(stream.name)) ]);
            })), 0) ]);
        })) ], 2) ]);
    };
    render._withStripped = !0;
    var simkl_malkissvue_type_script_lang_js_ = __webpack_require__(43).a, componentNormalizer = (__webpack_require__(298), 
    __webpack_require__(6)), component = Object(componentNormalizer.a)(simkl_malkissvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "simkltvdetailonlineheadrightclose"
        }, [ _c("div", {
            staticClass: "simkltvdetailonlineheadrightname",
            staticStyle: {
                "--data-online-block-title": "'MAL-Sync'"
            }
        }), this._v(" "), _c("div", {
            staticClass: "simkltvdetailonlineheadrightcloseico"
        }) ]);
    } ], !1, null, "55d18076", null);
    component.options.__file = "src/simkl/malkiss.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            attrs: {
                id: "material"
            }
        }, [ _vm.syncMode && _vm.minimized ? _c("div", [ _c("a", {
            staticStyle: {
                cursor: "pointer"
            },
            on: {
                click: function($event) {
                    _vm.minimized = !1;
                }
            }
        }, [ _vm._v("\n      Action required\n    ") ]) ]) : _c("div", {
            staticClass: "scroll"
        }, [ _vm.syncMode ? _vm._e() : _c("entry", {
            attrs: {
                obj: _vm.syncPage.singleObj
            }
        }), _vm._v(" "), _c("rules", {
            attrs: {
                obj: _vm.rulesClass
            }
        }), _vm._v(" "), _vm.syncMode ? _vm._e() : _c("input-button", {
            attrs: {
                label: "URL",
                state: _vm.searchClass.getUrl()
            },
            on: {
                clicked: _vm.setPage
            }
        }), _vm._v(" "), _vm.syncMode ? _vm._e() : _c("input-button", {
            attrs: {
                label: _vm.lang("correction_Offset"),
                state: _vm.offset,
                type: "number"
            },
            on: {
                clicked: _vm.setOffset,
                change: function(val) {
                    return _vm.inputOffset = val;
                }
            }
        }), _vm._v(" "), _vm.inputOffset && "0" !== _vm.inputOffset ? _c("div", {
            attrs: {
                id: "offsetUi"
            }
        }, [ _vm._l(5, (function(index) {
            return _c("div", {
                key: index,
                staticClass: "offsetBox"
            }, [ _c("div", {
                staticClass: "mdl-color--primary top"
            }, [ _vm._v(_vm._s(index)) ]), _vm._v(" "), _c("div", {
                staticClass: "bottom",
                class: {
                    active: parseInt(_vm.currentStateEp) === _vm.calcEpOffset(index)
                }
            }, [ _vm._v("\n          " + _vm._s(_vm.calcEpOffset(index)) + "\n        ") ]) ]);
        })), _vm._v(" "), _vm._m(0), _vm._v(" "), _vm._m(1) ], 2) : _vm._e(), _vm._v(" "), _c("search", {
            attrs: {
                keyword: _vm.searchClass.getSanitizedTitel(),
                type: _vm.searchClass.getNormalizedType(),
                "sync-mode": _vm.syncMode,
                "current-id": _vm.searchClass.getId()
            },
            on: {
                clicked: function($event) {
                    return _vm.setPage($event.url, $event.id);
                }
            }
        }) ], 1), _vm._v(" "), _vm.syncMode && _vm.minimized ? _vm._e() : _c("a", {
            staticClass: "close",
            on: {
                click: function($event) {
                    return _vm.close();
                }
            }
        }, [ _vm._v(_vm._s(_vm.lang("close"))) ]) ]);
    };
    render._withStripped = !0;
    var Search_correctionAppvue_type_script_lang_js_ = __webpack_require__(38).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(Search_correctionAppvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "offsetBox"
        }, [ _c("div", {
            staticClass: "mdl-color--primary top"
        }, [ this._v("...") ]), this._v(" "), _c("div", {
            staticClass: "bottom"
        }, [ this._v("...") ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "offsetBox"
        }, [ _c("div", {
            staticClass: "mdl-color--primary top"
        }, [ this._v("âˆž") ]), this._v(" "), _c("div", {
            staticClass: "bottom"
        }, [ this._v("âˆž") ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/_provider/Search/correctionApp.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _obj, _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            class: (_obj = {
                "pop-over": !_vm.navigation
            }, _obj[_vm.getTheme(_vm.options)] = !0, _obj),
            staticStyle: {
                height: "100%"
            },
            attrs: {
                id: "material"
            }
        }, [ _c("div", {
            staticClass: "mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-tabs mdl-shadow--2dp"
        }, [ _c("header", {
            staticClass: "mdl-layout__header",
            staticStyle: {
                "min-height": "0"
            }
        }, [ _c("button", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.backbutton,
                expression: "backbutton"
            } ],
            staticClass: "mdl-button mdl-js-button mdl-button--icon mdl-layout__drawer-button",
            staticStyle: {
                display: "none"
            },
            attrs: {
                id: "backbutton"
            },
            on: {
                click: function($event) {
                    return _vm.backbuttonClick();
                }
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("arrow_back") ]) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-layout__header-row"
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--icon mdl-layout__drawer-button",
            style: _vm.backbuttonBookStyle,
            attrs: {
                id: "book"
            },
            on: {
                click: function($event) {
                    return _vm.bookClick();
                }
            }
        }, [ _c("i", {
            staticClass: "material-icons md-48 bookIcon"
        }, [ _vm._v(_vm._s(_vm.bookIcon)) ]) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-textfield mdl-js-textfield mdl-textfield--expandable",
            class: {
                "is-dirty": _vm.currentTab == _vm.tabs.search.title
            },
            staticStyle: {
                "margin-left": "-57px",
                "margin-top": "3px",
                "padding-left": "40px"
            },
            style: _vm.backbuttonSearchStyle,
            attrs: {
                id: "SearchButton"
            }
        }, [ _vm._m(0), _vm._v(" "), _c("div", {
            staticClass: "mdl-textfield__expandable-holder"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.keyword,
                expression: "keyword"
            } ],
            staticClass: "mdl-textfield__input",
            attrs: {
                id: "headMalSearch",
                type: "text"
            },
            domProps: {
                value: _vm.keyword
            },
            on: {
                keyup: function($event) {
                    return _vm.keywordSet();
                },
                input: function($event) {
                    $event.target.composing || (_vm.keyword = $event.target.value);
                }
            }
        }), _vm._v(" "), _c("label", {
            staticClass: "mdl-textfield__label",
            attrs: {
                for: "headMalSearch"
            }
        }) ]) ]), _vm._v(" "), _vm._m(1), _vm._v(" "), _vm._m(2) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-layout__tab-bar mdl-js-ripple-effect"
        }, [ _c("a", {
            staticClass: "mdl-layout__tab",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.overview.title
            },
            on: {
                click: function($event) {
                    return _vm.selectTab(_vm.tabs.overview.title);
                }
            }
        }, [ _vm._v(_vm._s(_vm.lang("minimalApp_Overview"))) ]), _vm._v(" "), _c("a", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.showReviewAndRecom,
                expression: "showReviewAndRecom"
            } ],
            staticClass: "mdl-layout__tab reviewsTab",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.reviews.title
            },
            on: {
                click: function($event) {
                    return _vm.selectTab(_vm.tabs.reviews.title);
                }
            }
        }, [ _vm._v(_vm._s(_vm.lang("minimalApp_Reviews"))) ]), _vm._v(" "), _c("a", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.showReviewAndRecom,
                expression: "showReviewAndRecom"
            } ],
            staticClass: "mdl-layout__tab recommendationTab",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.recommendations.title
            },
            on: {
                click: function($event) {
                    return _vm.selectTab(_vm.tabs.recommendations.title);
                }
            }
        }, [ _vm._v(_vm._s(_vm.lang("minimalApp_Recommendations"))) ]), _vm._v(" "), _c("a", {
            staticClass: "mdl-layout__tab settingsTab",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.settings.title
            },
            on: {
                click: function($event) {
                    return _vm.selectTab(_vm.tabs.settings.title);
                }
            }
        }, [ _vm._v(_vm._s(_vm.lang("minimalApp_Settings"))) ]) ]) ]), _vm._v(" "), _c("main", {
            staticClass: "mdl-layout__content",
            staticStyle: {
                height: "100%"
            }
        }, [ _c("section", {
            staticClass: "mdl-layout__tab-panel",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.overview.title
            },
            attrs: {
                id: "fixed-tab-1"
            }
        }, [ _c("overviewVue", {
            attrs: {
                "render-obj": _vm.renderObj
            }
        }) ], 1), _vm._v(" "), _c("section", {
            staticClass: "mdl-layout__tab-panel",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.reviews.title
            },
            attrs: {
                id: "fixed-tab-2"
            }
        }, [ _c("reviewsVue", {
            attrs: {
                url: _vm.renderMalUrl,
                state: _vm.currentTab == _vm.tabs.reviews.title
            }
        }) ], 1), _vm._v(" "), _c("section", {
            staticClass: "mdl-layout__tab-panel",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.recommendations.title
            },
            attrs: {
                id: "fixed-tab-3"
            }
        }, [ _c("recommendationsVue", {
            attrs: {
                url: _vm.renderMalUrl,
                state: _vm.currentTab == _vm.tabs.recommendations.title
            }
        }) ], 1), _vm._v(" "), _c("section", {
            staticClass: "mdl-layout__tab-panel",
            class: {
                "is-active": _vm.popOver
            },
            attrs: {
                id: "fixed-tab-4"
            }
        }, [ _c("keepAlive", {
            attrs: {
                max: 1
            }
        }, [ _vm.currentTab == _vm.tabs.bookmarks.title ? _c("bookmarksVue", {
            attrs: {
                state: _vm.tabs.bookmarks.state,
                "list-type": _vm.tabs.bookmarks.type,
                sort: _vm.tabs.bookmarks.sort
            },
            on: {
                rewatch: function($event) {
                    _vm.tabs.bookmarks.supportsRewatch = $event;
                },
                sort: function($event) {
                    _vm.tabs.bookmarks.sort = $event;
                }
            },
            scopedSlots: _vm._u([ {
                key: "default",
                fn: function(ref) {
                    var sorting = ref.sorting;
                    return [ _c("div", {
                        staticClass: "mdl-grid",
                        staticStyle: {
                            "justify-content": "space-around"
                        },
                        attrs: {
                            id: "malList"
                        }
                    }, [ _c("select", {
                        directives: [ {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.tabs.bookmarks.type,
                            expression: "tabs.bookmarks.type"
                        } ],
                        staticClass: "inputtext mdl-textfield__input mdl-cell mdl-cell--12-col",
                        staticStyle: {
                            outline: "none",
                            "background-color": "white",
                            border: "none"
                        },
                        attrs: {
                            id: "userListType",
                            name: "myinfo_score"
                        },
                        on: {
                            change: function($event) {
                                var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                                    return o.selected;
                                })).map((function(o) {
                                    return "_value" in o ? o._value : o.value;
                                }));
                                _vm.$set(_vm.tabs.bookmarks, "type", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                            }
                        }
                    }, [ _c("option", {
                        attrs: {
                            value: "anime"
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("Anime"))) ]), _vm._v(" "), _c("option", {
                        attrs: {
                            value: "manga"
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("Manga"))) ]) ]), _vm._v(" "), _c("div", {
                        staticClass: "mdl-cell mdl-cell--12-col",
                        staticStyle: {
                            display: "flex"
                        }
                    }, [ _c("select", {
                        directives: [ {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.tabs.bookmarks.state,
                            expression: "tabs.bookmarks.state"
                        } ],
                        staticClass: "inputtext mdl-textfield__input",
                        staticStyle: {
                            outline: "none",
                            "background-color": "white",
                            border: "none",
                            flex: "1",
                            width: "auto"
                        },
                        attrs: {
                            id: "userListState",
                            name: "myinfo_score"
                        },
                        on: {
                            change: function($event) {
                                var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                                    return o.selected;
                                })).map((function(o) {
                                    return "_value" in o ? o._value : o.value;
                                }));
                                _vm.$set(_vm.tabs.bookmarks, "state", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                            }
                        }
                    }, [ _c("option", {
                        domProps: {
                            value: 7
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("All"))) ]), _vm._v(" "), _c("option", {
                        attrs: {
                            selected: ""
                        },
                        domProps: {
                            value: 1
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_watching_" + _vm.tabs.bookmarks.type))) ]), _vm._v(" "), _c("option", {
                        domProps: {
                            value: 2
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_Completed"))) ]), _vm._v(" "), _c("option", {
                        domProps: {
                            value: 3
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_OnHold"))) ]), _vm._v(" "), _c("option", {
                        domProps: {
                            value: 4
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_Dropped"))) ]), _vm._v(" "), _c("option", {
                        domProps: {
                            value: 6
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_planTo_" + _vm.tabs.bookmarks.type))) ]), _vm._v(" "), _vm.tabs.bookmarks.supportsRewatch ? _c("option", {
                        domProps: {
                            value: 23
                        }
                    }, [ _vm._v(_vm._s(_vm.lang("UI_Status_Rewatching_" + _vm.tabs.bookmarks.type))) ]) : _vm._e() ]), _vm._v(" "), 6 === _vm.tabs.bookmarks.state ? _c("div", {
                        staticClass: "bg-cell",
                        staticStyle: {
                            padding: "0 5px",
                            "margin-left": "10px",
                            display: "flex",
                            cursor: "pointer"
                        },
                        on: {
                            click: function($event) {
                                return _vm.openRandom(6, _vm.tabs.bookmarks.type);
                            }
                        }
                    }, [ _c("i", {
                        staticClass: "material-icons",
                        staticStyle: {
                            position: "relative",
                            top: "2px"
                        }
                    }, [ _vm._v("shuffle") ]) ]) : _vm._e(), _vm._v(" "), _c("div", {
                        staticClass: "bg-cell",
                        staticStyle: {
                            padding: "0 5px",
                            "margin-left": "10px",
                            display: "flex",
                            cursor: "pointer"
                        },
                        on: {
                            click: function($event) {
                                _vm.listView = !_vm.listView;
                            }
                        }
                    }, [ _vm.listView ? _c("i", {
                        staticClass: "material-icons",
                        staticStyle: {
                            position: "relative",
                            top: "2px"
                        }
                    }, [ _vm._v("view_module") ]) : _c("i", {
                        staticClass: "material-icons",
                        staticStyle: {
                            position: "relative",
                            top: "2px"
                        }
                    }, [ _vm._v("view_list") ]) ]), _vm._v(" "), _c("div", {
                        directives: [ {
                            name: "show",
                            rawName: "v-show",
                            value: sorting && sorting.length && sorting.length > 1,
                            expression: "sorting && sorting.length && sorting.length > 1"
                        } ],
                        staticClass: "bg-cell",
                        staticStyle: {
                            padding: "0 5px",
                            "margin-left": "10px",
                            display: "flex",
                            cursor: "pointer"
                        },
                        attrs: {
                            id: "demo-menu-lower-left"
                        }
                    }, [ _vm.tabs.bookmarks.sort ? _c("i", {
                        staticClass: "material-icons"
                    }, [ _vm._v(_vm._s(_vm.tabs.bookmarks.sort.icon)) ]) : _vm._e() ]), _vm._v(" "), _c("div", [ _vm.tabs.bookmarks.sort ? _c("ul", {
                        staticClass: "mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect",
                        attrs: {
                            for: "demo-menu-lower-left"
                        }
                    }, _vm._l(sorting, (function(sort) {
                        return _c("li", {
                            key: sort.value,
                            staticClass: "mdl-menu__item",
                            class: {
                                active: sort.value === _vm.tabs.bookmarks.sort.value || sort.child && sort.child.value === _vm.tabs.bookmarks.sort.value
                            },
                            on: {
                                click: function($event) {
                                    sort.child && sort.value === _vm.tabs.bookmarks.sort.value ? _vm.tabs.bookmarks.sort = sort.child : _vm.tabs.bookmarks.sort = sort;
                                }
                            }
                        }, [ !sort.child || sort.value !== _vm.tabs.bookmarks.sort.value && sort.child.value !== _vm.tabs.bookmarks.sort.value ? _c("i", {
                            staticClass: "material-icons",
                            staticStyle: {
                                "vertical-align": "sub",
                                "margin-right": "10px"
                            }
                        }, [ _vm._v(_vm._s(sort.icon)) ]) : [ sort.value === _vm.tabs.bookmarks.sort.value ? _c("i", {
                            staticClass: "material-icons",
                            staticStyle: {
                                "vertical-align": "sub",
                                "margin-right": "10px"
                            }
                        }, [ _vm._v("arrow_downward") ]) : _c("i", {
                            staticClass: "material-icons",
                            staticStyle: {
                                "vertical-align": "sub",
                                "margin-right": "10px"
                            }
                        }, [ _vm._v("arrow_upward") ]) ], _vm._v("\n\n                        " + _vm._s(sort.title) + "\n                      ") ], 2);
                    })), 0) : _vm._e() ]) ]) ]) ];
                }
            } ], null, !1, 2489004280)
        }) : _vm._e() ], 1), _vm._v(" "), _vm.currentTab == _vm.tabs.search.title ? _c("searchVue", {
            attrs: {
                keyword: _vm.tabs.search.keyword,
                type: _vm.tabs.search.type
            },
            on: {
                clicked: _vm.searchClick
            }
        }, [ _c("div", {
            staticClass: "mdl-grid",
            staticStyle: {
                "justify-content": "space-around"
            }
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.tabs.search.type,
                expression: "tabs.search.type"
            } ],
            staticClass: "inputtext mdl-textfield__input mdl-cell mdl-cell--12-col",
            staticStyle: {
                outline: "none",
                "background-color": "white",
                border: "none"
            },
            attrs: {
                id: "userListType",
                name: "myinfo_score"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.$set(_vm.tabs.search, "type", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                }
            }
        }, [ _c("option", {
            attrs: {
                value: "anime"
            }
        }, [ _vm._v(_vm._s(_vm.lang("Anime"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "manga"
            }
        }, [ _vm._v(_vm._s(_vm.lang("Manga"))) ]) ]) ]) ]) : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.updateCheck.title ? _c("updateCheckVue") : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.listSync.title ? _c("listSyncVue", {
            attrs: {
                "list-type": _vm.tabs.listSync.type
            }
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.tabs.listSync.type,
                expression: "tabs.listSync.type"
            } ],
            staticClass: "typeSelect-updateCheck",
            staticStyle: {
                "margin-bottom": "20px"
            },
            on: {
                change: [ function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.$set(_vm.tabs.listSync, "type", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                }, function($event) {
                    return _vm.rebuildListSync();
                } ]
            }
        }, [ _c("option", {
            attrs: {
                value: "anime"
            }
        }, [ _vm._v(_vm._s(_vm.lang("Anime"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "manga"
            }
        }, [ _vm._v(_vm._s(_vm.lang("Manga"))) ]) ]) ]) : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.cleanTags.title ? _c("cleanTagsVue") : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.allSites.title ? _c("allSitesVue") : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.customDomains.title ? _c("customDomainsVue") : _vm._e(), _vm._v(" "), _vm.currentTab == _vm.tabs.quicklinks.title ? _c("quicklinksEdit") : _vm._e() ], 1), _vm._v(" "), _c("section", {
            staticClass: "mdl-layout__tab-panel",
            class: {
                "is-active": _vm.currentTab == _vm.tabs.settings.title
            },
            attrs: {
                id: "fixed-tab-5"
            }
        }, [ _c("div", {
            staticClass: "page-content malClear",
            attrs: {
                id: "malConfig"
            }
        }, [ _c("settingsVue", {
            attrs: {
                page: _vm.page
            }
        }) ], 1) ]) ]) ]) ]);
    };
    render._withStripped = !0;
    var minimal_minimalAppvue_type_script_lang_js_ = __webpack_require__(45).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimal_minimalAppvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("label", {
            staticClass: "mdl-button mdl-js-button mdl-button--icon",
            attrs: {
                for: "headMalSearch"
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ this._v("search") ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--icon mdl-layout__drawer-button",
            staticStyle: {
                left: "initial",
                right: "40px"
            },
            attrs: {
                id: "material-fullscreen"
            }
        }, [ _c("i", {
            staticClass: "material-icons md-48"
        }, [ this._v("fullscreen") ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--icon mdl-layout__drawer-button",
            staticStyle: {
                left: "initial",
                right: "0"
            },
            attrs: {
                id: "close-info-popup"
            }
        }, [ _c("i", {
            staticClass: "material-icons close"
        }, [ this._v("close") ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "search"
        }, [ _c("div", {
            staticClass: "input"
        }, [ _c("div", {
            staticClass: "group"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.searchKeyword,
                expression: "searchKeyword"
            } ],
            attrs: {
                type: "text",
                required: ""
            },
            domProps: {
                value: _vm.searchKeyword
            },
            on: {
                focus: function($event) {
                    return _vm.inputFocus();
                },
                input: function($event) {
                    $event.target.composing || (_vm.searchKeyword = $event.target.value);
                }
            }
        }), _vm._v(" "), _c("span", {
            staticClass: "bar"
        }), _vm._v(" "), _c("label", [ _vm._v(_vm._s(_vm.lang("correction_Search"))) ]) ]) ]), _vm._v(" "), _c("div", {
            staticClass: "loadingBar"
        }, [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.loading,
                expression: "loading"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("div", {
            staticClass: "progressbar bar bar1",
            staticStyle: {
                width: "0%"
            }
        }), _vm._v(" "), _c("div", {
            staticClass: "bufferbar bar bar2",
            staticStyle: {
                width: "100%"
            }
        }), _vm._v(" "), _c("div", {
            staticClass: "auxbar bar bar3",
            staticStyle: {
                width: "0%"
            }
        }) ]) ]), _vm._v(" "), _vm.searchKeyword ? _c("div", {
            staticClass: "results"
        }, [ _c("a", {
            staticClass: "result",
            staticStyle: {
                cursor: "pointer"
            },
            attrs: {
                href: ""
            },
            on: {
                click: function($event) {
                    return _vm.clickItem($event, "");
                }
            }
        }, [ _c("div", {
            staticClass: "image"
        }), _vm._v(" "), _c("div", {
            staticClass: "right"
        }, [ _c("span", {
            staticClass: "title"
        }, [ _vm._v(_vm._s(_vm.lang("correction_NoEntry"))) ]), _vm._v(" "), _c("p", [ _vm._v(_vm._s(_vm.lang("correction_NoMal"))) ]) ]) ]), _vm._v(" "), _vm._l(_vm.items, (function(item) {
            return _c("a", {
                key: item.id,
                staticClass: "result",
                class: {
                    active: _vm.currentId === item.id
                },
                attrs: {
                    href: item.url
                },
                on: {
                    click: function($event) {
                        return _vm.clickItem($event, item);
                    }
                }
            }, [ _c("div", {
                staticClass: "image"
            }, [ _c("img", {
                attrs: {
                    src: item.image
                }
            }) ]), _vm._v(" "), _c("div", {
                staticClass: "right"
            }, [ _c("span", {
                staticClass: "title"
            }, [ _vm._v(_vm._s(item.name)) ]), _vm._v(" "), _c("p", [ _vm._v(_vm._s(_vm.lang("search_Type")) + " " + _vm._s(item.media_type)) ]), _vm._v(" "), _c("p", [ _vm._v(_vm._s(_vm.lang("search_Score")) + " " + _vm._s(item.score)) ]), _vm._v(" "), _c("p", [ _vm._v(_vm._s(_vm.lang("search_Year")) + " " + _vm._s(item.year)) ]) ]) ]);
        })) ], 2) : _vm._e() ]);
    };
    render._withStripped = !0;
    var components_searchvue_type_script_lang_js_ = __webpack_require__(39).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_searchvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/_provider/Search/components/search.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "inputButton"
        }, [ _c("div", {
            staticClass: "group"
        }, [ "checkbox" === _vm.type ? _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.inputString,
                expression: "inputString"
            } ],
            attrs: {
                required: "",
                type: "checkbox"
            },
            domProps: {
                checked: Array.isArray(_vm.inputString) ? _vm._i(_vm.inputString, null) > -1 : _vm.inputString
            },
            on: {
                change: function($event) {
                    var $$a = _vm.inputString, $$el = $event.target, $$c = !!$$el.checked;
                    if (Array.isArray($$a)) {
                        var $$i = _vm._i($$a, null);
                        $$el.checked ? $$i < 0 && (_vm.inputString = $$a.concat([ null ])) : $$i > -1 && (_vm.inputString = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
                    } else _vm.inputString = $$c;
                }
            }
        }) : "radio" === _vm.type ? _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.inputString,
                expression: "inputString"
            } ],
            attrs: {
                required: "",
                type: "radio"
            },
            domProps: {
                checked: _vm._q(_vm.inputString, null)
            },
            on: {
                change: function($event) {
                    _vm.inputString = null;
                }
            }
        }) : _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.inputString,
                expression: "inputString"
            } ],
            attrs: {
                required: "",
                type: _vm.type
            },
            domProps: {
                value: _vm.inputString
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.inputString = $event.target.value);
                }
            }
        }), _vm._v(" "), _c("span", {
            staticClass: "bar"
        }), _vm._v(" "), _c("label", [ _vm._v(_vm._s(_vm.label)) ]) ]), _vm._v(" "), _vm.inputString !== _vm.state ? _c("button", {
            on: {
                click: _vm.click
            }
        }, [ _vm._v("Update") ]) : _vm._e() ]);
    };
    render._withStripped = !0;
    var components_inputButtonvue_type_script_lang_js_ = __webpack_require__(40).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_inputButtonvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/_provider/Search/components/inputButton.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _vm.obj ? _c("div", {
            staticClass: "entry"
        }, [ _c("a", {
            staticClass: "result",
            staticStyle: {
                cursor: "pointer"
            },
            attrs: {
                href: _vm.obj.getDisplayUrl(),
                target: "_blank"
            }
        }, [ _c("div", {
            staticClass: "image"
        }, [ _vm.image ? _c("img", {
            attrs: {
                src: _vm.image
            }
        }) : _vm._e() ]), _vm._v(" "), _c("div", {
            staticClass: "right"
        }, [ _c("span", {
            staticClass: "title"
        }, [ _vm._v(_vm._s(_vm.obj.getTitle())) ]), _vm._v(" "), _vm.obj.isOnList() ? _c("p", [ _vm._v(_vm._s(_vm.lang("UI_Status")) + " " + _vm._s(_vm.statusText(_vm.status))) ]) : _vm._e(), _vm._v(" "), _vm.obj.isOnList() ? _c("p", [ _vm._v(_vm._s(_vm.lang("UI_Score")) + " " + _vm._s(_vm.score)) ]) : _vm._e(), _vm._v(" "), _vm.obj.isOnList() ? _c("p", [ _vm._v("\n        " + _vm._s(_vm.utilsepisode(_vm.obj.getType())) + " " + _vm._s(_vm.episode)), _vm.obj.getTotalEpisodes() ? _c("span", {
            attrs: {
                id: "curEps"
            }
        }, [ _vm._v("/" + _vm._s(_vm.obj.getTotalEpisodes())) ]) : _c("span", [ _vm._v("/?") ]) ]) : _vm._e() ]) ]) ]) : _vm._e();
    };
    render._withStripped = !0;
    var components_entryvue_type_script_lang_js_ = __webpack_require__(41).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_entryvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/_provider/Search/components/entry.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _vm.rules && _vm.rules.length ? _c("div", {
            staticClass: "rules"
        }, [ _c("div", {
            staticClass: "title"
        }, [ _vm._v(_vm._s(_vm.lang("UI_Rules"))) ]), _vm._v(" "), _vm._l(_vm.rules, (function(rule, index) {
            return _c("div", {
                key: index,
                staticClass: "rule",
                class: _vm.activeRule(rule)
            }, [ _c("div", {
                staticClass: "header"
            }, [ rule.to.title ? [ _c("span", {
                staticClass: "noHover"
            }, [ _vm._v("\n          " + _vm._s(rule.to.title) + "\n        ") ]), _vm._v(" "), _c("span", {
                staticClass: "hover"
            }, [ _vm._v("\n          " + _vm._s(rule.to.url) + "\n        ") ]) ] : [ _vm._v("\n        " + _vm._s(rule.to.url) + "\n      ") ] ], 2), _vm._v(" "), _c("div", {
                staticClass: "content"
            }, [ _vm._v("\n      " + _vm._s(_vm.lang("UI_Episode")) + "\n      " + _vm._s(rule.from.start) + "\n      "), rule.from.start !== rule.from.end ? [ _vm._v("\n        - " + _vm._s(Number.MAX_SAFE_INTEGER === rule.from.end ? "âˆž" : rule.from.end)) ] : _vm._e(), _vm._v("\n      âžž\n      " + _vm._s(Number.MAX_SAFE_INTEGER === rule.to.start ? "âˆž" : rule.to.start) + "\n      "), rule.to.start !== rule.to.end ? [ _vm._v("\n        - " + _vm._s(Number.MAX_SAFE_INTEGER === rule.to.end ? "âˆž" : rule.to.end)) ] : _vm._e() ], 2) ]);
        })) ], 2) : _vm._e();
    };
    render._withStripped = !0;
    var components_rulesvue_type_script_lang_js_ = __webpack_require__(42).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_rulesvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/_provider/Search/components/rules.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("ul", {
            staticClass: "demo-list-control mdl-list",
            staticStyle: {
                margin: "0",
                padding: "0"
            }
        }, [ _c("div", {
            staticClass: "mdl-grid"
        }, [ _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp",
            staticStyle: {
                display: "none"
            },
            attrs: {
                id: "page-config"
            }
        }), _vm._v(" "), _vm.page && _vm.page.UILoaded ? _c("correction", {
            attrs: {
                page: _vm.page
            }
        }) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v(_vm._s(_vm.lang("settings_General"))) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_Mode")) + "\n        ") ]), _vm._v(" "), _vm._m(0) ]), _vm._v(" "), _c("login", {
            attrs: {
                option: "syncMode"
            }
        }), _vm._v(" "), "SIMKL" == _vm.options.syncMode ? _c("dropdown", {
            attrs: {
                option: "syncModeSimkl",
                text: "Manga Sync Mode"
            }
        }, [ _c("option", {
            attrs: {
                value: "MAL"
            }
        }, [ _vm._v("MyAnimeList") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "ANILIST"
            }
        }, [ _vm._v("AniList") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "KITSU"
            }
        }, [ _vm._v("Kitsu") ]) ]) : _vm._e(), _vm._v(" "), "SIMKL" == _vm.options.syncMode ? _c("login", {
            attrs: {
                option: "syncModeSimkl"
            }
        }) : _vm._e(), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_Animesync")) + "\n        ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "autoTrackingModeanime",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "video"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Animesync_Video"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "instant"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Animesync_Instant"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "manual"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Animesync_Manual"))) ]) ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_Mangasync")) + "\n        ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "autoTrackingModemanga",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "instant"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Animesync_Instant"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "manual"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Animesync_Manual"))) ]) ]) ]) ]), _vm._v(" "), _c("numberInput", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "video" == _vm.options.autoTrackingModeanime || "video" == _vm.options.autoTrackingModemanga,
                expression: "options.autoTrackingModeanime == 'video' || options.autoTrackingModemanga == 'video'"
            } ],
            attrs: {
                option: "videoDuration",
                min: 10,
                max: 99
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_AutoTracking_Video", [ _vm.options.videoDuration ]))) ]), _vm._v(" "), _c("numberInput", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "instant" == _vm.options.autoTrackingModeanime || "instant" == _vm.options.autoTrackingModemanga,
                expression: "options.autoTrackingModeanime == 'instant' || options.autoTrackingModemanga == 'instant'"
            } ],
            attrs: {
                option: "delay"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_AutoTracking_Instant", [ _vm.options.delay ]))) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            attrs: {
                id: "allSitesUi",
                type: "button"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_website_button")) + "\n        ") ]), _vm._v(" "), _vm.isExtension() ? _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-left": "15px"
            },
            attrs: {
                id: "customDomainsUi",
                type: "button"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_custom_domains_button")) + "\n        ") ]) : _vm._e() ]), _vm._v(" "), _c("shortcut", {
            attrs: {
                option: "correctionShort"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Shortcuts_Correction"))) ]), _vm._v(" "), _c("shortcut", {
            attrs: {
                option: "syncShort"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Shortcuts_Sync"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "localSync"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_LocalSync")) + "\n        "), _c("a", {
            staticStyle: {
                "margin-left": "auto",
                "margin-right": "10px"
            },
            attrs: {
                href: "https://github.com/MALSync/MALSync/wiki/Local-Sync",
                target: "_blank"
            }
        }, [ _vm._v("[INFO]") ]) ]), _vm._v(" "), _c("li", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.options.localSync,
                expression: "options.localSync"
            } ],
            staticClass: "mdl-list__item"
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            attrs: {
                id: "export",
                type: "button"
            },
            on: {
                click: function($event) {
                    return _vm.exportFallbackSync();
                }
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_LocalSync_Export")) + "\n        ") ]), _vm._v(" "), _c("fileUpload", {
            staticStyle: {
                "margin-left": "15px"
            },
            on: {
                upload: _vm.importFallbackSync
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_LocalSync_Import"))) ]) ], 1) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_StreamingSite")) + "\n        ") ]), _vm._v(" "), _c("tooltip", [ _vm._v(_vm._s(_vm.lang("settings_StreamingSite_text"))) ]) ], 1), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("quicklinksOverview") ], 1) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _vm._m(1), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_Thumbnails")) + "\n          "), _c("tooltip", [ _c("span", [ _vm._v(_vm._s(_vm.lang("settings_Thumbnails_text"))) ]) ]) ], 1), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "malThumbnail",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "144"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Thumbnails_Large"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "100"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Thumbnails_Medium"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "60"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Thumbnails_Small"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "0"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Thumbnails_Default"))) ]) ]) ]) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "friendScore"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_FriendScore"))) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _vm._m(2), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "epPredictions"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_epPredictions"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "malTags"
            }
        }, [ _vm._v("\n        " + _vm._s(_vm.lang("settings_malTags")) + "\n        "), _c("tooltip", {
            attrs: {
                direction: "bottom"
            }
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("settings_malTags_Text"))) ]) ]) ], 1), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "malContinue"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_malContinue"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "malResume"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_malResume"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "usedPage"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_usedPage"))) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_popup")) + " (miniMAL)") ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_miniMAL_theme")) + "\n        ") ]), _vm._v(" "), _vm._m(3) ]), _vm._v(" "), _c("span", {
            staticClass: "option-extension",
            staticStyle: {
                display: "none"
            }
        }, [ _c("checkbox", {
            attrs: {
                option: "minimalWindow"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_window"))) ]) ], 1), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "floatButtonStealth"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_floatButtonStealth"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "minimizeBigPopup"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_minimizeBigPopup"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "floatButtonCorrection"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_floatButtonCorrection"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "floatButtonHide"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_floatButtonHide"))) ]), _vm._v(" "), _vm.isExtension() ? _vm._e() : _c("checkbox", {
            attrs: {
                option: "autoCloseMinimal"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_autoCloseMinimal"))) ]), _vm._v(" "), _vm.commands ? _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_miniMAL_Open")) + "\n        ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _vm._v("\n          " + _vm._s(_vm.commands._execute_browser_action.shortcut) + "\n          "), _vm.commands._execute_browser_action.shortcut ? _vm._e() : _c("span", [ _c("a", {
            attrs: {
                href: "https://github.com/MALSync/MALSync/wiki/Shortcuts",
                target: "_blank"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_NotSet"))) ]) ]) ]) ]) : _vm._e(), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_miniMAL_Display")) + "\n        ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "posLeft",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "left"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_Display_Left"))) ]), _vm._v(" "), _vm.isExtension() ? _c("option", {
            attrs: {
                value: "center"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_Display_Center"))) ]) : _vm._e(), _vm._v(" "), _c("option", {
            attrs: {
                value: "right"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_miniMAL_Display_Right"))) ]) ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item",
            staticStyle: {
                display: "inline-block",
                width: "49%"
            }
        }, [ _c("div", {
            staticClass: "mdl-textfield mdl-js-textfield mdl-textfield--floating-label",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("input", {
            staticClass: "mdl-textfield__input",
            attrs: {
                id: "miniMalHeight",
                type: "text",
                step: "1"
            },
            domProps: {
                value: _vm.options.miniMalHeight
            }
        }), _vm._v(" "), _c("label", {
            staticClass: "mdl-textfield__label",
            attrs: {
                for: "miniMalHeight"
            }
        }, [ _vm._v("\n            " + _vm._s(_vm.lang("settings_miniMAL_Height")) + "\n          ") ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item",
            staticStyle: {
                display: "inline-block",
                width: "50%"
            }
        }, [ _c("div", {
            staticClass: "mdl-textfield mdl-js-textfield mdl-textfield--floating-label",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("input", {
            staticClass: "mdl-textfield__input",
            attrs: {
                id: "miniMalWidth",
                type: "text",
                step: "1"
            },
            domProps: {
                value: _vm.options.miniMalWidth
            }
        }), _vm._v(" "), _c("label", {
            staticClass: "mdl-textfield__label",
            attrs: {
                for: "miniMalWidth"
            }
        }, [ _vm._v("\n            " + _vm._s(_vm.lang("settings_miniMAL_Width")) + "\n          ") ]) ]) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_Video_Player")) + "\n        ") ]) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "autofull"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Video_Fullscreen"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "autoresume"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Video_Resume"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "autoNextEp"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_autoNextEp"))) ]), _vm._v(" "), _vm.isExtension() ? _c("shortcut", {
            attrs: {
                option: "nextEpShort"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Shortcuts_Next_Episode"))) ]) : _vm._e(), _vm._v(" "), _vm.isExtension() ? _c("shortcut", {
            attrs: {
                option: "introSkipFwd"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Shortcuts_Skip_Forward"))) ]) : _vm._e(), _vm._v(" "), _vm.isExtension() ? _c("shortcut", {
            attrs: {
                option: "introSkipBwd"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Shortcuts_Skip_Backward"))) ]) : _vm._e(), _vm._v(" "), _vm.isExtension() ? _c("numberInput", {
            attrs: {
                option: "introSkip",
                min: 5
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_introSkip", [ _vm.options.introSkip ]))) ]) : _vm._e() ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp",
            attrs: {
                id: "progressCheck"
            }
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_ProgressCheck")) + "\n        ") ]) ]), _vm._v(" "), _c("dropdown", {
            attrs: {
                option: "progressInterval",
                text: _vm.lang("settings_Interval")
            },
            on: {
                changed: function($event) {
                    return _vm.startProgressSync();
                }
            }
        }, [ _c("option", {
            attrs: {
                value: "0"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Interval_Off"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "30"
            }
        }, [ _vm._v("30min") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "60"
            }
        }, [ _vm._v("1h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "120"
            }
        }, [ _vm._v("2h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "240"
            }
        }, [ _vm._v("4h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "720"
            }
        }, [ _vm._v("12h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "1440"
            }
        }, [ _vm._v("24h") ]) ]), _vm._v(" "), _c("dropdown", {
            attrs: {
                option: "progressIntervalDefaultAnime",
                text: _vm.lang("settings_Interval_Default_Anime")
            },
            on: {
                changed: function($event) {
                    return _vm.startProgressSync();
                }
            }
        }, _vm._l(_vm.progressAnimeDropdown, (function(drop) {
            return _c("option", {
                key: drop.key,
                domProps: {
                    value: drop.key
                }
            }, [ _vm._v(_vm._s(drop.label)) ]);
        })), 0), _vm._v(" "), _c("dropdown", {
            attrs: {
                option: "progressIntervalDefaultManga",
                text: _vm.lang("settings_Interval_Default_Manga")
            },
            on: {
                changed: function($event) {
                    return _vm.startProgressSync();
                }
            }
        }, _vm._l(_vm.progressMangaDropdown, (function(drop) {
            return _c("option", {
                key: drop.key,
                domProps: {
                    value: drop.key
                }
            }, [ _vm._v(_vm._s(drop.label)) ]);
        })), 0), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "progressNotifications"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Notifications"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "loadPTWForProgress"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_loadPTWForProgress"))) ]) ], 1), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.legacy,
                expression: "legacy"
            } ],
            staticClass: "updateCheckEnable mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticStyle: {
                display: "none",
                border: "1px solid red"
            },
            attrs: {
                id: "updateCheck"
            }
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v("\n            " + _vm._s(_vm.lang("settings_UpdateCheck")) + "\n          ") ]), _vm._v(" "), _c("tooltip", [ _vm._v("\n            " + _vm._s(_vm.lang("settings_UpdateCheck_Text")) + "\n          ") ]), _vm._v(" "), _c("div", {
            staticStyle: {
                "margin-left": "auto"
            },
            attrs: {
                id: "updateCheckAgo"
            }
        }) ], 1), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n            " + _vm._s(_vm.lang("settings_Interval")) + "\n          ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "updateCheckTime",
                name: "updateCheckTime"
            }
        }, [ _c("option", {
            attrs: {
                value: "0"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Interval_Off"))) ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "60"
            }
        }, [ _vm._v("1h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "240"
            }
        }, [ _vm._v("4h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "720"
            }
        }, [ _vm._v("12h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "1440"
            }
        }, [ _vm._v("24h") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "2880"
            }
        }, [ _vm._v("48h") ]) ]) ]) ]), _vm._v(" "), _c("span", {
            staticClass: "updateCheckEnable",
            staticStyle: {
                display: "none"
            }
        }, [ _c("checkbox", {
            attrs: {
                option: "updateCheckNotifications"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Notifications"))) ]) ], 1), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item updateCheckEnable",
            staticStyle: {
                display: "none"
            }
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            attrs: {
                id: "updateCheckUi",
                type: "button"
            }
        }, [ _vm._v("\n            " + _vm._s(_vm.lang("settings_Debugging")) + "\n          ") ]) ]) ]) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v("Discord Rich Presence") ]), _vm._v(" "), _c("a", {
            staticStyle: {
                "margin-left": "auto"
            },
            attrs: {
                href: "https://github.com/MALSync/MALSync/wiki/Discord-Rich-Presence",
                target: "_blank"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_more_info"))) ]) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "rpc"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_enabled"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "presenceHidePage"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_presenceHidePage"))) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "presenceShowButtons"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_presenceShowButtons"))) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v(_vm._s(_vm.lang("settings_ETC"))) ]) ]), _vm._v(" "), _c("checkbox", {
            attrs: {
                option: "forceEn"
            }
        }, [ _vm._v("Force english") ]), _vm._v(" "), _c("span", {
            staticStyle: {
                display: "none"
            }
        }, [ _c("checkbox", {
            attrs: {
                option: "userscriptModeButton"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Userscriptmode"))), _c("tooltip", {
            attrs: {
                direction: "bottom"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_Userscriptmode_Text"))) ]) ], 1) ], 1), _vm._v(" "), _c("span", {
            staticClass: "option-extension",
            staticStyle: {
                display: "none"
            }
        }, [ _c("checkbox", {
            attrs: {
                option: "highlightAllEp"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_highlightAllEp"))), _c("tooltip", [ _vm._v(_vm._s(_vm.lang("settings_highlightAllEp_Text"))) ]) ], 1) ], 1), _vm._v(" "), _c("span", {
            staticClass: "option-extension",
            staticStyle: {
                display: "none"
            }
        }, [ _c("checkbox", {
            attrs: {
                option: "checkForFiller"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_filler"))), _c("tooltip", [ _vm._v(_vm._s(_vm.lang("settings_filler_text"))) ]) ], 1) ], 1), _vm._v(" "), _c("span", {
            staticClass: "option-legacy"
        }, [ _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n            Legacy options\n          ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("label", {
            staticClass: "mdl-switch mdl-js-switch mdl-js-ripple-effect",
            attrs: {
                for: "legacy"
            }
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.legacy,
                expression: "legacy"
            } ],
            staticClass: "mdl-switch__input",
            attrs: {
                id: "legacy",
                type: "checkbox"
            },
            domProps: {
                checked: Array.isArray(_vm.legacy) ? _vm._i(_vm.legacy, null) > -1 : _vm.legacy
            },
            on: {
                change: function($event) {
                    var $$a = _vm.legacy, $$el = $event.target, $$c = !!$$el.checked;
                    if (Array.isArray($$a)) {
                        var $$i = _vm._i($$a, null);
                        $$el.checked ? $$i < 0 && (_vm.legacy = $$a.concat([ null ])) : $$i > -1 && (_vm.legacy = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
                    } else _vm.legacy = $$c;
                }
            }
        }) ]) ]) ]) ]), _vm._v(" "), _vm._m(4), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            attrs: {
                id: "clearCache",
                type: "button"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_ClearCache")) + "\n        ") ]), _vm._v(" "), _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-left": "20px"
            },
            attrs: {
                id: "cleanTagsUi",
                type: "button"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("settings_clean_tags_button")) + "\n        ") ]) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp",
            class: {
                open: _vm.isOpen
            },
            attrs: {
                id: "contributer"
            },
            on: {
                click: function($event) {
                    return _vm.myOpen();
                }
            }
        }, [ _c("div", {
            staticStyle: {
                display: "table",
                width: "100%"
            }
        }, [ _vm._l(_vm.contributer, (function(contributerGroup, group) {
            return [ _c("div", {
                key: group,
                staticClass: "group"
            }, [ _vm._v(_vm._s(group)) ]), _vm._v(" "), _vm._l(contributerGroup, (function(contr) {
                return _c("div", {
                    key: contr.name,
                    staticClass: "inline-block"
                }, [ _c("div", {
                    staticClass: "user"
                }, [ _c("div", {
                    staticClass: "image align-middle"
                }, [ contr.gif ? _c("clazy-load", {
                    attrs: {
                        src: contr.gif
                    }
                }, [ _c("img", {
                    staticClass: "lazy init gif",
                    staticStyle: {
                        "max-width": "100%"
                    },
                    attrs: {
                        src: contr.gif
                    }
                }) ]) : _vm._e(), _vm._v(" "), _c("clazy-load", {
                    attrs: {
                        src: contr.image
                    }
                }, [ _c("img", {
                    staticClass: "lazy init",
                    staticStyle: {
                        "max-width": "100%"
                    },
                    attrs: {
                        src: contr.image
                    }
                }) ]) ], 1), _vm._v(" "), _c("div", {
                    staticClass: "text align-middle"
                }, [ _c("div", {
                    staticClass: "name",
                    style: "color:" + contr.color,
                    attrs: {
                        title: contr.name
                    }
                }, [ _vm._v("\n                  " + _vm._s(contr.name) + "\n                ") ]), _vm._v(" "), contr.subText ? _c("div", {
                    staticClass: "subtext"
                }, [ _vm._v("\n                  " + _vm._s(contr.subText) + "\n                ") ]) : _vm._e() ]) ]) ]);
            })) ];
        })), _vm._v(" "), _vm._m(5), _vm._v(" "), _c("a", {
            staticClass: "discord",
            staticStyle: {
                "min-height": "160px"
            },
            attrs: {
                rel: "noreferrer",
                href: "https://discord.com/invite/cTH4yaw"
            }
        }, [ _c("div", {
            staticStyle: {
                height: "20px",
                margin: "-15px",
                "margin-top": "15px",
                background: "-webkit-linear-gradient(top, #fff 0%,#738bd7 74%)"
            }
        }), _vm._v(" "), _c("clazy-load", {
            staticStyle: {
                background: "linear-gradient(to bottom, #738bd7 0%,#738bd7 64%,#697ec4 64%,#697ec4 100%)",
                "background-color": "#697ec4",
                position: "relative",
                overflow: "hidden",
                "margin-left": "-15px",
                "margin-right": "-15px",
                "margin-bottom": "-15px",
                "margin-top": "15px"
            },
            attrs: {
                src: "https://discord.com/api/guilds/358599430502481920/widget.png?style=banner3"
            }
        }, [ _c("img", {
            staticStyle: {
                margin: "auto",
                display: "block"
            },
            attrs: {
                src: "https://discord.com/api/guilds/358599430502481920/widget.png?style=banner3"
            }
        }) ]) ], 1) ], 2) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("div", {
            staticStyle: {
                "line-height": "30px"
            }
        }, [ _c("clazy-load", {
            attrs: {
                tag: "a",
                rel: "noreferrer",
                href: _vm.version.link,
                src: _vm.version.img
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.version.img
            }
        }), _vm._v(" "), _c("span", {
            attrs: {
                slot: "placeholder"
            },
            slot: "placeholder"
        }, [ _vm._v("\n              " + _vm._s(_vm.lang("Loading")) + "\n            ") ]) ]), _vm._v(" "), _c("br"), _vm._v(" "), _c("clazy-load", {
            attrs: {
                tag: "a",
                rel: "noreferrer",
                href: "https://discord.com/invite/cTH4yaw",
                src: "https://img.shields.io/discord/358599430502481920.svg?style=flat-square&logo=discord&label=Chat%20%2F%20Support&colorB=7289DA"
            }
        }, [ _c("img", {
            attrs: {
                src: "https://img.shields.io/discord/358599430502481920.svg?style=flat-square&logo=discord&label=Chat%20%2F%20Support&colorB=7289DA"
            }
        }), _vm._v(" "), _c("span", {
            attrs: {
                slot: "placeholder"
            },
            slot: "placeholder"
        }, [ _vm._v("\n              " + _vm._s(_vm.lang("Loading")) + "\n            ") ]) ]), _vm._v(" "), _c("br"), _vm._v(" "), _c("clazy-load", {
            attrs: {
                tag: "a",
                rel: "noreferrer",
                href: "https://github.com/MALSync/MALSync",
                src: "https://img.shields.io/github/last-commit/MALSync/MALSync.svg?style=flat-square&logo=github&logoColor=white&label=Github"
            }
        }, [ _c("img", {
            attrs: {
                src: "https://img.shields.io/github/last-commit/MALSync/MALSync.svg?style=flat-square&logo=github&logoColor=white&label=Github"
            }
        }), _vm._v(" "), _c("span", {
            attrs: {
                slot: "placeholder"
            },
            slot: "placeholder"
        }, [ _vm._v("\n              " + _vm._s(_vm.lang("Loading")) + "\n            ") ]) ]), _vm._v(" "), _c("br"), _vm._v(" "), _c("clazy-load", {
            attrs: {
                tag: "a",
                rel: "noreferrer",
                href: "https://github.com/MALSync/MALSync/issues",
                src: "https://img.shields.io/github/issues/MALSync/MALSync.svg?style=flat-square&logo=github&logoColor=white"
            }
        }, [ _c("img", {
            attrs: {
                src: "https://img.shields.io/github/issues/MALSync/MALSync.svg?style=flat-square&logo=github&logoColor=white"
            }
        }), _vm._v(" "), _c("span", {
            attrs: {
                slot: "placeholder"
            },
            slot: "placeholder"
        }, [ _vm._v("\n              " + _vm._s(_vm.lang("Loading")) + "\n            ") ]) ]) ], 1) ]) ]) ], 1) ]);
    };
    render._withStripped = !0;
    var minimalApp_settingsvue_type_script_lang_js_ = __webpack_require__(46).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_settingsvue_type_script_lang_js_, render, [ function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "syncMode",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "MAL"
            }
        }, [ _vm._v("MyAnimeList API (Hybrid)") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "ANILIST"
            }
        }, [ _vm._v("AniList") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "KITSU"
            }
        }, [ _vm._v("Kitsu") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "SIMKL"
            }
        }, [ _vm._v("Simkl") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "MALAPI"
            }
        }, [ _vm._v("MyAnimeList API (Full) (BETA)") ]) ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ this._v("MyAnimeList") ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ this._v("\n          MyAnimeList / AniList / Kitsu / Simkl\n        ") ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "theme",
                name: "myinfo_score"
            }
        }, [ _c("option", {
            attrs: {
                value: "auto"
            }
        }, [ this._v("Auto") ]), this._v(" "), _c("option", {
            attrs: {
                value: "light"
            }
        }, [ this._v("Light") ]), this._v(" "), _c("option", {
            attrs: {
                value: "dark"
            }
        }, [ this._v("Dark") ]), this._v(" "), _c("option", {
            attrs: {
                value: "serial"
            }
        }, [ this._v("Serial") ]) ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ this._v("\n          List Sync\n        ") ]), this._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            attrs: {
                id: "listSyncUi",
                type: "button"
            }
        }, [ this._v("\n            Sync\n          ") ]) ]) ]);
    }, function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "user pop"
        }, [ _c("div", {
            staticClass: "image align-middle"
        }, [ _c("i", {
            staticClass: "material-icons",
            staticStyle: {
                color: "white",
                padding: "4px 4px",
                cursor: "pointer"
            }
        }, [ this._v("\n              arrow_right_alt\n            ") ]) ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/settings.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "page-content"
        }, [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: !_vm.metaObj && !_vm.error,
                expression: "!metaObj && !error"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%",
                position: "absolute",
                top: "0"
            },
            attrs: {
                id: "loadOverview"
            }
        }), _vm._v(" "), _vm.error ? _c("span", {
            staticClass: "mdl-chip mdl-chip--deletable",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            staticClass: "mdl-chip__text"
        }, [ _vm._v("Error") ]), _vm._v(" "), _c("button", {
            staticClass: "mdl-chip__action",
            attrs: {
                type: "button"
            },
            on: {
                click: function($event) {
                    return _vm.clickRender();
                }
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("refresh") ]) ]) ]) : _vm._e(), _vm._v(" "), _vm.objError ? _c("span", {
            staticClass: "mdl-chip mdl-chip--deletable",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.objError,
                expression: "objError"
            } ],
            staticClass: "mdl-chip__text"
        }), _vm._v(" "), _c("button", {
            staticClass: "mdl-chip__action",
            attrs: {
                type: "button"
            },
            on: {
                click: function($event) {
                    return _vm.reload();
                }
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("refresh") ]) ]) ]) : _vm._e(), _vm._v(" "), _vm.metaObj ? _c("div", {
            staticClass: "mdl-grid"
        }, [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.statistics.length,
                expression: "statistics.length"
            } ],
            staticClass: "mdl-cell bg-cell mdl-cell--1-col mdl-cell--8-col-tablet mdl-cell--6-col-phone mdl-shadow--4dp stats-block malClear",
            staticStyle: {
                "min-width": "120px"
            }
        }, [ _c("ul", {
            staticClass: "mdl-list mdl-grid mdl-grid--no-spacing mdl-cell mdl-cell--12-col",
            staticStyle: {
                display: "flex",
                "justify-content": "space-around"
            }
        }, _vm._l(_vm.statistics, (function(stat) {
            return _c("li", {
                key: stat.title,
                staticClass: "mdl-list__item mdl-list__item--two-line",
                staticStyle: {
                    padding: "0",
                    "padding-left": "10px",
                    "padding-right": "3px",
                    "min-width": "18%"
                }
            }, [ _c("span", {
                staticClass: "mdl-list__item-primary-content"
            }, [ _c("span", [ _vm._v("\n              " + _vm._s(stat.title) + "\n            ") ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-sub-title"
            }, [ _vm._v(_vm._s(stat.body)) ]) ]) ]);
        })), 0) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid mdl-cell bg-cell mdl-shadow--4dp coverinfo malClear",
            staticStyle: {
                display: "block",
                "flex-grow": "100",
                "min-width": "70%"
            }
        }, [ _c("div", {
            staticClass: "mdl-card__media mdl-cell mdl-cell--2-col",
            staticStyle: {
                "background-color": "transparent",
                float: "left",
                "padding-right": "16px"
            }
        }, [ _c("clazy-load", {
            staticClass: "malImage malClear",
            staticStyle: {
                width: "100%",
                height: "auto"
            },
            attrs: {
                src: _vm.image
            },
            on: {
                error: _vm.setQuestionmark
            }
        }, [ _c("img", {
            staticStyle: {
                height: "auto",
                width: "100%"
            },
            attrs: {
                src: _vm.image
            },
            on: {
                error: _vm.setQuestionmark
            }
        }) ]) ], 1), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell mdl-cell--12-col"
        }, [ _c("a", {
            staticClass: "mdl-button mdl-button--icon mdl-js-button mdl-js-ripple-effect malClear malLink",
            staticStyle: {
                float: "right"
            },
            attrs: {
                href: _vm.displayUrl,
                target: "_blank"
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("open_in_new") ]) ]), _vm._v(" "), _c("h1", {
            staticClass: "malTitle mdl-card__title-text malClear",
            staticStyle: {
                "padding-left": "0",
                overflow: "visible"
            }
        }, [ _vm._v(_vm._s(_vm.title)) ]), _vm._v(" "), _c("div", {
            staticClass: "malAltTitle mdl-card__supporting-text malClear",
            staticStyle: {
                padding: "10px 0 0 0",
                overflow: "visible"
            }
        }, _vm._l(_vm.altTitle, (function(altTitl) {
            return _c("div", {
                key: altTitl,
                staticClass: "mdl-chip",
                staticStyle: {
                    "margin-right": "5px"
                }
            }, [ _c("span", {
                staticClass: "mdl-chip__text"
            }, [ _vm._v(_vm._s(altTitl)) ]) ]);
        })), 0) ]), _vm._v(" "), _c("div", {
            staticClass: "malDescription malClear mdl-cell mdl-cell--10-col",
            staticStyle: {
                overflow: "hidden"
            }
        }, [ _c("p", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.description,
                expression: "description"
            } ],
            staticStyle: {
                color: "black"
            }
        }), _vm._v(" "), _vm.renderObj && _vm.renderObj.isAuthenticated() ? _c("div", {
            staticClass: "mdl-card__actions mdl-card--border",
            staticStyle: {
                "padding-left": "0"
            }
        }, [ _vm.renderObj.getStreamingUrl() ? _c("div", {
            staticClass: "data title progress",
            staticStyle: {
                display: "inline-block",
                position: "relative",
                top: "2px",
                "margin-left": "-2px"
            }
        }, [ _c("a", {
            staticClass: "stream mdl-button mdl-button--colored mdl-js-button mdl-button--raised",
            staticStyle: {
                margin: "10px 5px 0 0",
                color: "white"
            },
            attrs: {
                title: _vm.renderObj.getStreamingUrl().split("/")[2],
                target: "_blank",
                href: _vm.renderObj.getStreamingUrl()
            }
        }, [ _c("img", {
            staticStyle: {
                "padding-bottom": "3px",
                "padding-right": "6px",
                "margin-left": "-3px"
            },
            attrs: {
                src: _vm.utils.favicon(_vm.renderObj.getStreamingUrl().split("/")[2])
            }
        }), _vm._v("\n              " + _vm._s(_vm.lang("overview_Continue_" + _vm.renderObj.getType())) + "\n            ") ]), _vm._v(" "), _vm.mal.continueUrl && _vm.mal.continueUrl.ep === _vm.renderObj.getEpisode() + 1 ? _c("a", {
            staticClass: "nextStream mdl-button mdl-button--colored mdl-js-button mdl-button--raised",
            staticStyle: {
                margin: "10px 5px 0 0",
                color: "white"
            },
            attrs: {
                title: _vm.lang("overview_Next_Episode_" + _vm.renderObj.getType()),
                target: "_blank",
                href: _vm.mal.continueUrl.url
            }
        }, [ _c("img", {
            staticStyle: {
                "padding-bottom": "3px",
                "padding-right": "6px",
                "margin-left": "-3px"
            },
            attrs: {
                src: _vm.assetUrl("double-arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }), _vm._v(_vm._s(_vm.lang("overview_Next_Episode_" + _vm.renderObj.getType())) + "\n            ") ]) : _vm.mal.resumeUrl && _vm.mal.resumeUrl.ep === _vm.renderObj.getEpisode() ? _c("a", {
            staticClass: "resumeStream mdl-button mdl-button--colored mdl-js-button mdl-button--raised",
            staticStyle: {
                margin: "10px 5px 0 0",
                color: "white"
            },
            attrs: {
                title: _vm.lang("overview_Resume_Episode_" + _vm.renderObj.getType()),
                target: "_blank",
                href: _vm.mal.resumeUrl.url
            }
        }, [ _c("img", {
            staticStyle: {
                "padding-bottom": "3px",
                "padding-right": "6px",
                "margin-left": "-3px"
            },
            attrs: {
                src: _vm.assetUrl("arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }), _vm._v(_vm._s(_vm.lang("overview_Resume_Episode_" + _vm.renderObj.getType())) + "\n            ") ]) : _vm._e() ]) : _vm._e() ]) : _vm._e() ]) ]), _vm._v(" "), _vm.renderObj.getProgress() && _vm.renderObj.getProgress().isAiring() && _vm.renderObj.getProgress().getPredictionText() ? _c("div", {
            staticClass: "mdl-grid mdl-cell bg-cell mdl-shadow--4dp malClear",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("div", {
            staticClass: "mdl-cell",
            staticStyle: {
                width: "100%"
            }
        }, [ _vm._v("\n        " + _vm._s(_vm.renderObj.getProgress().getPredictionText()) + "\n      ") ]) ]) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--4-col mdl-cell--8-col-tablet mdl-shadow--4dp data-block mdl-grid mdl-grid--no-spacing malClear"
        }, [ _c("table", {
            attrs: {
                border: "0",
                cellpadding: "0",
                cellspacing: "0",
                width: "100%"
            }
        }, [ _c("tbody", [ _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("UI_Status")) + " ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.malStatus,
                expression: "malStatus"
            } ],
            staticClass: "inputtext js-anime-status-dropdown mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "myinfo_status",
                disabled: !this.renderObj || !this.renderObj.isAuthenticated(),
                name: "myinfo_status"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.malStatus = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                }
            }
        }, _vm._l(_vm.renderObj.getStatusCheckbox(), (function(el) {
            return _c("option", {
                key: el.value,
                domProps: {
                    value: el.value
                }
            }, [ _vm._v(_vm._s(el.label)) ]);
        })), 0) ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v(_vm._s(_vm.utils.episode(_vm.renderObj.getType()))) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.malEpisode,
                expression: "malEpisode"
            } ],
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                width: "35px",
                display: "inline-block"
            },
            attrs: {
                id: "myinfo_watchedeps",
                disabled: !this.renderObj || !this.renderObj.isAuthenticated(),
                type: "text",
                name: "myinfo_watchedeps",
                size: "3",
                value: "6"
            },
            domProps: {
                value: _vm.malEpisode
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.malEpisode = $event.target.value);
                }
            }
        }), _vm._v("\n                /\n                "), _vm.renderObj.getProgress() && _vm.renderObj.getProgress().isAiring() && _vm.renderObj.getProgress().getCurrentEpisode() ? _c("span", {
            attrs: {
                title: _vm.renderObj.getProgress().getAutoText()
            }
        }, [ _vm._v("\n                  [" + _vm._s(_vm.renderObj.getProgress().getCurrentEpisode()) + "]\n                ") ]) : _vm._e(), _vm._v(" "), _vm.renderObj && _vm.renderObj.getTotalEpisodes() ? _c("span", {
            attrs: {
                id: "curEps"
            }
        }, [ _vm._v(_vm._s(_vm.renderObj.getTotalEpisodes())) ]) : _c("span", [ _vm._v("?") ]), _vm._v(" "), !_vm.renderObj.getTotalEpisodes() || !_vm.renderObj.getEpisode() || _vm.renderObj.getEpisode() < _vm.renderObj.getTotalEpisodes() ? _c("span", {
            staticClass: "material-icons ep-increment",
            on: {
                click: function($event) {
                    return _vm.increaseEP("episode");
                }
            }
        }, [ _vm._v("add") ]) : _vm._e() ]) ]) ]), _vm._v(" "), _c("li", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "manga" == _vm.renderObj.getType(),
                expression: "renderObj.getType() == 'manga'"
            } ],
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("UI_Volume"))) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.malVolume,
                expression: "malVolume"
            } ],
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                width: "35px",
                display: "inline-block"
            },
            attrs: {
                id: "myinfo_volumes",
                disabled: !this.renderObj || !this.renderObj.isAuthenticated(),
                type: "text",
                name: "myinfo_volumes",
                size: "3",
                value: "6"
            },
            domProps: {
                value: _vm.malVolume
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.malVolume = $event.target.value);
                }
            }
        }), _vm._v("\n                /\n                "), _vm.renderObj && _vm.renderObj.getTotalVolumes() ? _c("span", {
            attrs: {
                id: "curVolumes"
            }
        }, [ _vm._v(_vm._s(_vm.renderObj.getTotalVolumes())) ]) : _c("span", [ _vm._v("?") ]), _vm._v(" "), !_vm.renderObj.getTotalVolumes() || !_vm.renderObj.getVolume() || _vm.renderObj.getVolume() < _vm.renderObj.getTotalVolumes() ? _c("span", {
            staticClass: "material-icons ep-increment",
            on: {
                click: function($event) {
                    return _vm.increaseEP("volume");
                }
            }
        }, [ _vm._v("add") ]) : _vm._e() ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("UI_Score")) + " ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.malScore,
                expression: "malScore"
            } ],
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "myinfo_score",
                disabled: !this.renderObj || !this.renderObj.isAuthenticated(),
                name: "myinfo_score"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.malScore = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                }
            }
        }, _vm._l(_vm.renderObj.getScoreCheckbox(), (function(el) {
            return _c("option", {
                key: el.value,
                domProps: {
                    value: el.value
                }
            }, [ _vm._v(_vm._s(el.label)) ]);
        })), 0) ]) ]) ]), _vm._v(" "), _vm.renderObj && _vm.renderObj.isAuthenticated() && _vm.renderObj.isOnList() && _vm.renderObj.getProgressOptions() && _vm.renderObj.getProgressOptions().length ? _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("settings_progress_dropdown"))) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.malProgressMode,
                expression: "malProgressMode"
            } ],
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                id: "myinfo_progressmode",
                name: "myinfo_progressmode"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.malProgressMode = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                }
            }
        }, [ _c("option", {
            attrs: {
                value: ""
            }
        }, [ _vm._v("\n                    " + _vm._s(_vm.lang("settings_progress_default")) + "\n                  ") ]), _vm._v(" "), _vm._l(_vm.renderObj.getProgressOptions(), (function(o) {
            return _c("option", {
                key: o.key,
                domProps: {
                    value: o.key
                }
            }, [ _vm._v(_vm._s(o.value)) ]);
        })), _vm._v(" "), _c("option", {
            attrs: {
                value: "off"
            }
        }, [ _vm._v("\n                    " + _vm._s(_vm.lang("settings_progress_disabled")) + "\n                  ") ]) ], 2) ]) ]) ]) : _vm._e(), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item",
            staticStyle: {
                width: "100%"
            }
        }, [ _vm.renderObj && !_vm.renderObj.isOnList() ? _c("input", {
            staticClass: "inputButton btn-middle flat js-anime-update-button mdl-button mdl-js-button mdl-button--raised mdl-button--accent",
            staticStyle: {
                "margin-right": "5px"
            },
            attrs: {
                type: "button",
                name: "myinfo_submit",
                value: _vm.lang("Add"),
                "data-upgraded": ",MaterialButton",
                disabled: !_vm.renderObj || !_vm.renderObj.isAuthenticated()
            },
            on: {
                click: function($event) {
                    return _vm.malSync();
                }
            }
        }) : _c("input", {
            staticClass: "inputButton btn-middle flat js-anime-update-button mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-right": "5px"
            },
            attrs: {
                type: "button",
                name: "myinfo_submit",
                value: _vm.lang("Update"),
                "data-upgraded": ",MaterialButton",
                disabled: !_vm.renderObj || !_vm.renderObj.isAuthenticated()
            },
            on: {
                click: function($event) {
                    return _vm.malSync();
                }
            }
        }), _vm._v(" "), _vm.editUrl && _vm.renderObj ? _c("small", [ _c("a", {
            attrs: {
                href: _vm.editUrl,
                target: "_blank"
            }
        }, [ _vm._v(_vm._s(_vm.lang("overview_EditDetails"))) ]) ]) : _vm._e(), _vm._v(" "), _vm.renderObj && !_vm.renderObj.isOnList() || void 0 === _vm.renderObj.delete ? _vm._e() : _c("input", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--accent",
            staticStyle: {
                "margin-left": "auto"
            },
            attrs: {
                type: "button",
                value: _vm.lang("Remove")
            },
            on: {
                click: function($event) {
                    return _vm.remove();
                }
            }
        }), _vm._v(" "), _c("i", {
            staticClass: "material-icons",
            staticStyle: {
                "margin-right": "0",
                "margin-left": "auto",
                cursor: "pointer"
            },
            on: {
                click: function($event) {
                    return _vm.reload();
                }
            }
        }, [ _vm._v("autorenew") ]) ]) ]) ]) ]), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.related.length,
                expression: "related.length"
            } ],
            staticClass: "mdl-grid mdl-grid--no-spacing mdl-cell bg-cell mdl-cell--4-col mdl-cell--8-col-tablet mdl-shadow--4dp related-block alternative-list mdl-grid malClear"
        }, [ _c("ul", {
            staticClass: "mdl-list"
        }, _vm._l(_vm.related, (function(relatedType) {
            return _c("li", {
                key: relatedType.url,
                staticClass: "mdl-list__item mdl-list__item--two-line"
            }, [ _c("span", {
                staticClass: "mdl-list__item-primary-content"
            }, [ _c("span", [ _vm._v("\n              " + _vm._s(relatedType.type) + "\n            ") ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-sub-title"
            }, _vm._l(relatedType.links, (function(link) {
                return _c("div", {
                    key: link.title
                }, [ _c("a", {
                    attrs: {
                        href: link.url
                    }
                }, [ _vm._v(_vm._s(link.title)) ]), _vm._v(" "), _c("span", {
                    directives: [ {
                        name: "dompurify-html",
                        rawName: "v-dompurify-html",
                        value: link.statusTag,
                        expression: "link.statusTag"
                    } ]
                }) ]);
            })), 0) ]) ]);
        })), 0) ]), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.kiss2mal && _vm.kiss2mal.length,
                expression: "kiss2mal && kiss2mal.length"
            } ],
            staticClass: "mdl-grid mdl-grid--no-spacing bg-cell mdl-cell mdl-cell--4-col mdl-cell--8-col-tablet mdl-shadow--4dp mdl-grid alternative-list stream-block malClear"
        }, [ _c("ul", {
            staticClass: "mdl-list stream-block-inner"
        }, _vm._l(_vm.kiss2mal, (function(page) {
            return _c("li", {
                key: page.name,
                staticClass: "mdl-list__item mdl-list__item--three-line"
            }, [ _c("span", {
                staticClass: "mdl-list__item-primary-content"
            }, [ _c("span", [ _c("img", {
                staticStyle: {
                    "padding-bottom": "3px"
                },
                attrs: {
                    src: _vm.getMal2KissFavicon(page.domain)
                }
            }), _vm._v("\n              " + _vm._s(page.name) + "\n            ") ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-text-body",
                attrs: {
                    id: "KissAnimeLinks"
                }
            }, _vm._l(page.links, (function(stream) {
                return _c("div", {
                    key: stream.url,
                    staticClass: "mal_links"
                }, [ _c("a", {
                    attrs: {
                        target: "_blank",
                        href: stream.url
                    }
                }, [ _vm._v(_vm._s(stream.name)) ]) ]);
            })), 0) ]) ]);
        })), 0) ]), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.characters.length > 0,
                expression: "characters.length > 0"
            } ],
            staticClass: "mdl-grid mdl-grid--no-spacing mdl-cell bg-cell mdl-cell--12-col mdl-shadow--4dp characters-block mdl-grid malClear"
        }, [ _c("div", {
            staticClass: "mdl-card__actions clicker"
        }, [ _c("h1", {
            staticClass: "mdl-card__title-text",
            staticStyle: {
                float: "left"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.lang("overview_Characters")) + "\n        ") ]) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid mdl-card__actions mdl-card--border",
            staticStyle: {
                "justify-content": "space-between"
            },
            attrs: {
                id: "characterList"
            }
        }, [ _vm._l(_vm.characters, (function(character) {
            return _c("div", {
                key: character.html
            }, [ _c("div", {
                staticClass: "mdl-grid",
                staticStyle: {
                    width: "126px"
                }
            }, [ _c("clazy-load", {
                staticStyle: {
                    width: "100%",
                    height: "auto"
                },
                attrs: {
                    src: character.img,
                    margin: "200px 0px",
                    threshold: .1,
                    ratio: .1
                }
            }, [ _c("img", {
                staticStyle: {
                    height: "auto",
                    width: "100%"
                },
                attrs: {
                    src: character.img
                }
            }) ]), _vm._v(" "), _c("div", [ _c("a", {
                attrs: {
                    href: character.url
                }
            }, [ _vm._v("\n                " + _vm._s(character.name) + "\n              ") ]), _vm._v(" "), _c("div", {
                staticClass: "spaceit_pad"
            }, [ _c("small", [ _vm._v(_vm._s(character.subtext)) ]) ]) ]) ], 1) ]);
        })), _vm._v(" "), _vm._l(10, (function(n) {
            return _c("div", {
                key: n,
                staticClass: "listPlaceholder",
                staticStyle: {
                    height: "0"
                }
            }, [ _c("div", {
                staticClass: "mdl-grid",
                staticStyle: {
                    width: "126px"
                }
            }) ]);
        })) ], 2) ]), _vm._v(" "), _vm.openingSongs.length || _vm.endingSongs.length ? _c("div", {
            staticClass: "mdl-grid mdl-cell bg-cell mdl-cell--12-col mdl-shadow--4dp info-block mdl-grid malClear"
        }, [ _vm.openingSongs.length ? _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line mdl-cell mdl-cell--6-col mdl-cell--12-col-tablet",
            staticStyle: {
                padding: "0",
                height: "auto"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content",
            staticStyle: {
                height: "auto"
            }
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("overview_OpeningTheme"))) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body",
            staticStyle: {
                height: "auto"
            }
        }, _vm._l(_vm.openingSongs, (function(openingSong) {
            return _c("span", {
                key: openingSong,
                staticStyle: {
                    display: "block",
                    color: "rgb(255,64,129)"
                }
            }, [ _vm._v("\n              " + _vm._s(openingSong) + "\n            ") ]);
        })), 0) ]) ]) : _vm._e(), _vm._v(" "), _vm.endingSongs.length ? _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line mdl-cell mdl-cell--6-col mdl-cell--12-col-tablet",
            staticStyle: {
                padding: "0",
                height: "auto"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content",
            staticStyle: {
                height: "auto"
            }
        }, [ _c("span", [ _vm._v(_vm._s(_vm.lang("overview_EndingTheme"))) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body",
            staticStyle: {
                height: "auto"
            }
        }, _vm._l(_vm.endingSongs, (function(endingSong) {
            return _c("span", {
                key: endingSong,
                staticStyle: {
                    display: "block",
                    color: "rgb(255,64,129)"
                }
            }, [ _vm._v("\n              " + _vm._s(endingSong) + "\n            ") ]);
        })), 0) ]) ]) : _vm._e() ]) : _vm._e(), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.info.length,
                expression: "info.length"
            } ],
            staticClass: "mdl-grid mdl-grid--no-spacing mdl-cell bg-cell mdl-cell--12-col mdl-shadow--4dp info-block mdl-grid malClear"
        }, [ _c("div", {
            staticClass: "mdl-grid mdl-grid--no-spacing mdl-cell mdl-cell--12-col mdl-shadow--4dp info-block mdl-grid malClear"
        }, [ _c("ul", {
            staticClass: "mdl-grid mdl-grid--no-spacing mdl-list mdl-cell mdl-cell--12-col"
        }, _vm._l(_vm.info, (function(inf) {
            return _c("li", {
                key: inf.title,
                staticClass: "mdl-list__item mdl-list__item--three-line mdl-cell mdl-cell--3-col mdl-cell--4-col-tablet",
                staticStyle: {
                    height: "auto"
                }
            }, [ _c("span", {
                staticClass: "mdl-list__item-primary-content",
                staticStyle: {
                    height: "auto"
                }
            }, [ _c("span", [ _vm._v("\n                " + _vm._s(inf.title) + "\n              ") ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-text-body"
            }, _vm._l(inf.body, (function(b, ind) {
                return _c("span", {
                    key: b.title
                }, [ ind > 0 ? [ _vm._v(", ") ] : _vm._e(), b.url ? [ _c("a", {
                    attrs: {
                        href: b.url
                    }
                }, [ _vm._v(_vm._s(b.text)) ]) ] : [ _vm._v(_vm._s(b.text)) ], b.subtext && b.subtext ? _c("small", [ _vm._v(" " + _vm._s(b.subtext)) ]) : _vm._e() ], 2);
            })), 0) ]) ]);
        })), 0) ]) ]), _vm._v(" "), _c("progressP", {
            attrs: {
                "api-cache-key": _vm.renderObj.getApiCacheKey(),
                type: _vm.renderObj.type,
                "total-eps": _vm.renderObj.getTotalEpisodes()
            }
        }) ], 1) : _vm._e() ]);
    };
    render._withStripped = !0;
    var minimalApp_overviewvue_type_script_lang_js_ = __webpack_require__(58).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_overviewvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/overview.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "page-content malClear",
            attrs: {
                id: "malRecommendations"
            }
        }, [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "" == _vm.xhr,
                expression: "xhr == ''"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%",
                position: "absolute"
            },
            attrs: {
                id: "loadOverview"
            }
        }), _vm._v(" "), _c("span", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "" != _vm.xhr && _vm.recommendations && 0 === _vm.recommendations.length,
                expression: "xhr != '' && recommendations && recommendations.length === 0"
            } ],
            staticClass: "mdl-chip",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            staticClass: "mdl-chip__text"
        }, [ _vm._v(_vm._s(_vm.lang("NothingFound"))) ]) ]), _vm._v(" "), "" != _vm.xhr ? _c("div", {
            staticClass: "mdl-grid"
        }, _vm._l(_vm.recommendations, (function(rec) {
            return _c("div", {
                key: rec.titleName,
                staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp mdl-grid"
            }, [ _c("div", {
                staticClass: "mdl-card__media",
                staticStyle: {
                    "background-color": "transparent",
                    margin: "8px"
                }
            }, [ _c("a", {
                attrs: {
                    href: rec.titleHref
                }
            }, [ _c("img", {
                attrs: {
                    src: rec.imageUrl,
                    width: "50"
                }
            }) ]) ]), _vm._v(" "), _c("div", {
                staticClass: "mdl-cell",
                staticStyle: {
                    "flex-grow": "100"
                }
            }, [ _c("div", [ _c("a", {
                attrs: {
                    href: rec.titleHref
                }
            }, [ _c("strong", [ _vm._v(_vm._s(rec.titleName)) ]) ]) ]), _vm._v(" "), _c("div", [ _c("div", {
                staticStyle: {
                    "white-space": "pre-wrap"
                }
            }, [ _vm._v(_vm._s(rec.user.text)) ]), _vm._v(" "), _c("div", [ _vm._v("\n            Recommended by "), _c("a", {
                attrs: {
                    href: rec.user.userHref
                }
            }, [ _vm._v(_vm._s(rec.user.username)) ]) ]) ]), _vm._v(" "), rec.children.length ? _c("div", [ _c("a", {
                staticClass: "nojs",
                attrs: {
                    href: "#"
                },
                on: {
                    click: function($event) {
                        return _vm.activeItems.push(rec.titleName);
                    }
                }
            }, [ _vm._v("Read recommendations by " + _vm._s(rec.children.length) + " more user") ]), _vm._v(" "), _c("div", {
                directives: [ {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.activeItems.includes(rec.titleName),
                    expression: "activeItems.includes(rec.titleName)"
                } ],
                staticClass: "more"
            }, _vm._l(rec.children, (function(child, index) {
                return _c("div", {
                    key: child.username,
                    staticStyle: {
                        padding: "3px",
                        margin: "4px 0"
                    }
                }, [ _c("div", {
                    staticStyle: {
                        "white-space": "pre-wrap"
                    }
                }, [ _c("span", [ _vm._v(_vm._s(child.text)) ]), child.readmore ? _c("span", [ _c("a", {
                    directives: [ {
                        name: "show",
                        rawName: "v-show",
                        value: !_vm.activeReadMores.includes(index),
                        expression: "!activeReadMores.includes(index)"
                    } ],
                    staticClass: "nojs",
                    attrs: {
                        href: "#"
                    },
                    on: {
                        click: function($event) {
                            return _vm.activeReadMores.push(index);
                        }
                    }
                }, [ _vm._v(" read more") ]), _vm._v(" "), _c("span", {
                    directives: [ {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.activeReadMores.includes(index),
                        expression: "activeReadMores.includes(index)"
                    } ]
                }, [ _vm._v(_vm._s(child.readmore)) ]) ]) : _vm._e() ]), _vm._v(" "), _c("div", [ _vm._v("\n                Recommended by "), _c("a", {
                    attrs: {
                        href: child.userHref
                    }
                }, [ _vm._v(_vm._s(child.username)) ]) ]) ]);
            })), 0) ]) : _vm._e() ]) ]);
        })), 0) : _vm._e() ]);
    };
    render._withStripped = !0;
    var minimalApp_recommendationsvue_type_script_lang_js_ = __webpack_require__(61).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_recommendationsvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/recommendations.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.loading,
                expression: "loading"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%",
                position: "fixed",
                "z-index": "30",
                "max-width": "1377px",
                "margin-left": "auto",
                "margin-right": "auto"
            },
            attrs: {
                id: "loadMalSearchPop"
            }
        }, [ _c("div", {
            staticClass: "progressbar bar bar1",
            staticStyle: {
                width: "0%"
            }
        }), _vm._v(" "), _c("div", {
            staticClass: "bufferbar bar bar2",
            staticStyle: {
                width: "100%"
            }
        }), _vm._v(" "), _c("div", {
            staticClass: "auxbar bar bar3",
            staticStyle: {
                width: "0%"
            }
        }) ]), _vm._v(" "), _vm._t("default", null, {
            sorting: _vm.listProvider ? _vm.listProvider.getSortingOptions(!0) : []
        }), _vm._v(" "), _vm.loading || _vm.items.length || _vm.errorText ? _vm._e() : _c("span", {
            staticClass: "mdl-chip",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            staticClass: "mdl-chip__text"
        }, [ _vm._v(_vm._s(_vm.lang("NoEntries"))) ]) ]), _vm._v(" "), _vm.listView ? _c("div", {
            staticStyle: {
                padding: "0 20px 20px 20px"
            }
        }, [ _vm.cache && _vm.errorText ? _vm._e() : _c("table", {
            staticClass: "mdl-data-table mdl-js-data-table mdl-data-table--selectable mdl-shadow--2dp bg-cell",
            staticStyle: {
                width: "100%"
            },
            attrs: {
                id: "malList"
            }
        }, [ _c("tbody", [ _vm._l(_vm.items, (function(item) {
            return [ _c("bookmarksItem", {
                key: item.uid,
                ref: item.uid,
                refInFor: !0,
                attrs: {
                    item: item,
                    "list-view": _vm.listView
                }
            }) ];
        })) ], 2) ]) ]) : [ _vm.cache && _vm.errorText ? _vm._e() : _c("div", {
            staticClass: "mdl-grid",
            staticStyle: {
                "justify-content": "space-around"
            },
            attrs: {
                id: "malList"
            }
        }, [ _vm._l(_vm.items, (function(item) {
            return [ _c("bookmarksItem", {
                key: item.uid,
                ref: item.uid,
                refInFor: !0,
                attrs: {
                    item: item
                }
            }) ];
        })), _vm._v(" "), _vm._l(10, (function(n) {
            return _c("div", {
                key: n,
                staticClass: "listPlaceholder mdl-cell mdl-cell--2-col mdl-cell--4-col-tablet mdl-cell--6-col-phone mdl-shadow--2dp mdl-grid ",
                staticStyle: {
                    cursor: "pointer",
                    padding: "0",
                    width: "210px",
                    height: "0",
                    "margin-top": "0",
                    "margin-bottom": "0",
                    visibility: "hidden"
                }
            });
        })) ], 2) ], _vm._v(" "), _vm.errorText ? _c("span", {
            staticClass: "mdl-chip",
            staticStyle: {
                margin: "16px auto 70px auto",
                display: "table",
                "padding-right": "5px",
                border: "2px solid red"
            },
            on: {
                click: function($event) {
                    !_vm.loading && _vm.load();
                }
            }
        }, [ _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.errorText,
                expression: "errorText"
            } ],
            staticClass: "mdl-chip__text"
        }), _vm._v(" "), _vm._m(0) ]) : _vm._e() ], 2);
    };
    render._withStripped = !0;
    var minimalApp_bookmarksvue_type_script_lang_js_ = __webpack_require__(62).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_bookmarksvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("button", {
            staticClass: "mdl-chip__action",
            attrs: {
                type: "button"
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ this._v("autorenew") ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/bookmarks.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: _vm.loading,
                expression: "loading"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%",
                position: "absolute"
            },
            attrs: {
                id: "loadMalSearchPop"
            }
        }), _vm._v(" "), _vm._t("default"), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid"
        }, [ _vm.loading || _vm.items.length ? _vm._e() : _c("span", {
            staticClass: "mdl-chip",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            staticClass: "mdl-chip__text"
        }, [ _vm._v(_vm._s(_vm.lang("NoEntries"))) ]) ]), _vm._v(" "), _vm._l(_vm.items, (function(item) {
            return _c("a", {
                key: item.id,
                staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--2dp mdl-grid searchItem nojs",
                staticStyle: {
                    cursor: "pointer"
                },
                attrs: {
                    href: item.url
                },
                on: {
                    click: function($event) {
                        return _vm.clickItem($event, item);
                    }
                }
            }, [ _c("img", {
                staticStyle: {
                    margin: "-8px 0 -8px -8px",
                    height: "100px",
                    width: "64px",
                    "background-color": "grey"
                },
                attrs: {
                    src: item.image
                }
            }), _vm._v(" "), _c("div", {
                staticClass: "mdl-cell",
                staticStyle: {
                    "flex-grow": "100",
                    cursor: "pointer",
                    "margin-top": "0",
                    "margin-bottom": "0"
                }
            }, [ _c("span", {
                staticStyle: {
                    "font-size": "20px",
                    "font-weight": "400",
                    "line-height": "1"
                }
            }, [ _vm._v(_vm._s(item.name)) ]), _vm._v(" "), _c("p", {
                staticStyle: {
                    "margin-bottom": "0",
                    "line-height": "20px",
                    "padding-top": "3px"
                }
            }, [ _vm._v("\n          " + _vm._s(_vm.lang("search_Type")) + " " + _vm._s(item.media_type) + "\n        ") ]), _vm._v(" "), _c("p", {
                staticStyle: {
                    "margin-bottom": "0",
                    "line-height": "20px"
                }
            }, [ _vm._v(_vm._s(_vm.lang("search_Score")) + " " + _vm._s(item.score)) ]), _vm._v(" "), _c("p", {
                staticStyle: {
                    "margin-bottom": "0",
                    "line-height": "20px"
                }
            }, [ _vm._v(_vm._s(_vm.lang("search_Year")) + " " + _vm._s(item.year)) ]) ]) ]);
        })) ], 2) ], 2);
    };
    render._withStripped = !0;
    var minimalApp_searchvue_type_script_lang_js_ = __webpack_require__(64).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_searchvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/search.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--primary refresh-updateCheck",
            on: {
                click: function($event) {
                    return _vm.load();
                }
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.lang("updateCheck_Refresh")) + "\n  ") ]), _vm._v(" "), _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--accent startCheck-updateCheck",
            on: {
                click: function($event) {
                    return _vm.startCheck();
                }
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.lang("updateCheck_StartCheck")) + "\n  ") ]), _vm._v(" "), _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--accent notification-updateCheck",
            on: {
                click: function($event) {
                    return _vm.notificationTest();
                }
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.lang("updateCheck_NotificationCheck")) + "\n  ") ]), _vm._v(" "), _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.listType,
                expression: "listType"
            } ],
            staticClass: "typeSelect-updateCheck",
            staticStyle: {
                float: "right"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.listType = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                }
            }
        }, [ _c("option", {
            attrs: {
                value: "anime"
            }
        }, [ _vm._v("Anime") ]), _vm._v(" "), _c("option", {
            attrs: {
                value: "manga"
            }
        }, [ _vm._v("Manga") ]) ]), _vm._v(" "), _c("table", {
            staticClass: "mdl-data-table mdl-js-data-table mdl-data-table__cell--non-numeric mdl-shadow--2dp",
            staticStyle: {
                "white-space": "normal"
            }
        }, [ _c("tr", [ _c("th", {
            staticClass: "mdl-data-table__cell--non-numeric"
        }), _vm._v(" "), _c("th", [ _vm._v(_vm._s(_vm.lang("updateCheck_Episode"))) ]), _vm._v(" "), _c("th", [ _vm._v(_vm._s(_vm.lang("updateCheck_Message"))) ]) ]), _vm._v(" "), _vm._l(_vm.items, (function(item) {
            return _c("tr", {
                key: item.uid,
                style: {
                    backgroundColor: item.trColor
                }
            }, [ _c("th", {
                staticClass: "mdl-data-table__cell--non-numeric"
            }, [ _c("button", {
                staticClass: "mdl-button mdl-js-button mdl-button--icon delete-updateCheck",
                on: {
                    click: function($event) {
                        return _vm.deleteItem(item);
                    }
                }
            }, [ _c("i", {
                staticClass: "material-icons"
            }, [ _vm._v("delete") ]) ]), _vm._v(" "), _c("a", {
                staticStyle: {
                    color: "black"
                },
                attrs: {
                    href: item.url
                }
            }, [ _vm._v("\n          " + _vm._s(item.title) + "\n        ") ]) ]), _vm._v(" "), _c("th", [ _vm._v(_vm._s(item.episode)) ]), _vm._v(" "), _c("th", [ _vm._v(_vm._s(item.error)) ]) ]);
        })) ], 2), _vm._v(" "), _c("div", {
            staticClass: "history"
        }, [ _c("h3", [ _vm._v(_vm._s(_vm.lang("updateCheck_NotificationHistory"))) ]), _vm._v(" "), _vm._l(_vm.history, (function(historyItem) {
            return _c("a", {
                key: historyItem.id,
                staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--2dp mdl-grid",
                staticStyle: {
                    "text-decoration": "none !important",
                    color: "black"
                },
                attrs: {
                    href: historyItem.url
                }
            }, [ _c("img", {
                staticStyle: {
                    margin: "-8px 0 -8px -8px",
                    height: "100px",
                    width: "64px",
                    "background-color": "grey"
                },
                attrs: {
                    src: historyItem.iconUrl
                }
            }), _vm._v(" "), _c("div", {
                staticClass: "mdl-cell",
                staticStyle: {
                    "flex-grow": "100",
                    cursor: "pointer",
                    "margin-top": "0",
                    "margin-bottom": "0"
                }
            }, [ _c("span", {
                staticStyle: {
                    "font-size": "20px",
                    "font-weight": "400",
                    "line-height": "1"
                }
            }, [ _vm._v(_vm._s(historyItem.title)) ]), _vm._v(" "), _c("p", {
                staticStyle: {
                    "margin-bottom": "0",
                    "line-height": "20px",
                    "padding-top": "3px"
                }
            }, [ _vm._v("\n          " + _vm._s(historyItem.message) + "\n        ") ]), _vm._v(" "), _c("p", {
                staticStyle: {
                    "margin-bottom": "0",
                    "line-height": "20px"
                }
            }, [ _vm._v("\n          " + _vm._s(historyItem.timeDiff) + "\n        ") ]) ]) ]);
        })) ], 2) ]);
    };
    render._withStripped = !0;
    var minimalApp_updateCheckvue_type_script_lang_js_ = __webpack_require__(65).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_updateCheckvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/updateCheck.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("backbutton"), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid bg-cell",
            staticStyle: {
                display: "block",
                margin: "10px"
            }
        }, [ _vm._m(0), _vm._v(" "), _c("div", [ _vm._t("default") ], 2), _vm._v(" "), _c("div", {
            staticStyle: {
                display: "inline-block",
                "margin-right": "40px",
                "padding-left": "10px",
                "margin-bottom": "20px"
            },
            style: _vm.getTypeColor(_vm.getType("myanimelist.net"))
        }, [ _vm._v("\n      MyAnimeList "), _vm.listProvider.mal.master ? _c("span", [ _vm._v("(Master)") ]) : _vm._e(), _c("br"), _vm._v(" "), _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.listProvider.mal.text,
                expression: "listProvider.mal.text"
            } ]
        }), _c("br"), _vm._v(" "), _vm.listProvider.mal.list ? _c("span", [ _vm._v("List: " + _vm._s(_vm.listProvider.mal.list.length)) ]) : _vm._e(), _c("br"), _vm._v(" "), _c("br") ]), _vm._v(" "), _c("div", {
            staticStyle: {
                display: "inline-block",
                "margin-right": "40px",
                "padding-left": "10px",
                "margin-bottom": "20px"
            },
            style: _vm.getTypeColor(_vm.getType("anilist.co"))
        }, [ _vm._v("\n      AniList "), _vm.listProvider.anilist.master ? _c("span", [ _vm._v("(Master)") ]) : _vm._e(), _c("br"), _vm._v(" "), _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.listProvider.anilist.text,
                expression: "listProvider.anilist.text"
            } ]
        }), _vm._v(" "), _c("br"), _vm._v(" "), _vm.listProvider.anilist.list ? _c("span", [ _vm._v("List: " + _vm._s(_vm.listProvider.anilist.list.length)) ]) : _vm._e(), _c("br"), _vm._v(" "), _c("br") ]), _vm._v(" "), _c("div", {
            staticStyle: {
                display: "inline-block",
                "margin-right": "40px",
                "padding-left": "10px",
                "margin-bottom": "20px"
            },
            style: _vm.getTypeColor(_vm.getType("kitsu.io"))
        }, [ _vm._v("\n      Kitsu "), _vm.listProvider.kitsu.master ? _c("span", [ _vm._v("(Master)") ]) : _vm._e(), _c("br"), _vm._v(" "), _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.listProvider.kitsu.text,
                expression: "listProvider.kitsu.text"
            } ]
        }), _c("br"), _vm._v(" "), _vm.listProvider.kitsu.list ? _c("span", [ _vm._v("List: " + _vm._s(_vm.listProvider.kitsu.list.length)) ]) : _vm._e(), _c("br"), _vm._v(" "), _c("br") ]), _vm._v(" "), _c("div", {
            staticStyle: {
                display: "inline-block",
                "margin-right": "40px",
                "padding-left": "10px",
                "margin-bottom": "20px"
            },
            style: _vm.getTypeColor(_vm.getType("simkl.com"))
        }, [ _vm._v("\n      Simkl "), _vm.listProvider.simkl.master ? _c("span", [ _vm._v("(Master)") ]) : _vm._e(), _c("br"), _vm._v(" "), _c("span", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.listProvider.simkl.text,
                expression: "listProvider.simkl.text"
            } ]
        }), _c("br"), _vm._v(" "), _vm.listProvider.simkl.list ? _c("span", [ _vm._v("List: " + _vm._s(_vm.listProvider.simkl.list.length)) ]) : _vm._e(), _c("br"), _vm._v(" "), _c("br") ]), _vm._v(" "), _c("br"), _vm._v(" "), _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-bottom": "20px"
            },
            attrs: {
                type: "button",
                disabled: !_vm.listReady
            },
            on: {
                click: function($event) {
                    return _vm.syncList();
                }
            }
        }, [ _vm._v("\n      Sync\n    ") ]), _vm._v(" "), "webextension" == _vm.apiType() ? _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-bottom": "20px",
                float: "right"
            },
            attrs: {
                type: "button"
            },
            on: {
                click: function($event) {
                    return _vm.backgroundClick();
                }
            }
        }, [ _vm.isBackgroundEnabled ? [ _vm._v("\n        Background Sync Enabled\n      ") ] : [ _vm._v("\n        Sync in Background\n      ") ] ], 2) : _vm._e(), _vm._v(" "), _vm.listLength ? _c("span", [ _vm._v(_vm._s(_vm.listLength - _vm.listSyncLength) + "/" + _vm._s(_vm.listLength)) ]) : _vm._e(), _vm._v(" "), _vm._l(_vm.listDiff, (function(item, index) {
            return _c("div", {
                key: index,
                staticStyle: {
                    border: "1px solid black",
                    display: "flex",
                    "flex-wrap": "wrap",
                    "margin-bottom": "10px"
                }
            }, [ _c("div", {
                staticStyle: {
                    width: "100%",
                    "border-bottom": "1px solid black",
                    padding: "0 5px"
                }
            }, [ _vm._v("\n        " + _vm._s(item.master.title) + "\n      ") ]), _vm._v(" "), _c("div", {
                staticStyle: {
                    width: "50px",
                    "border-right": "1px solid black",
                    padding: "5px"
                }
            }, [ _vm._v("\n        " + _vm._s(index) + "\n      ") ]), _vm._v(" "), item.master && item.master.uid ? _c("div", {
                staticClass: "master",
                staticStyle: {
                    "background-color": "#ffd5d5",
                    "border-right": "1px solid black",
                    padding: "5px 10px",
                    width: "70px"
                },
                style: _vm.getTypeColor(_vm.getType(item.master.url))
            }, [ _vm._v("\n        ID: "), _c("a", {
                attrs: {
                    target: "_blank",
                    href: item.master.url
                }
            }, [ _vm._v(_vm._s(item.master.uid)) ]), _c("br"), _vm._v("\n        EP: " + _vm._s(item.master.watchedEp)), _c("br"), _vm._v("\n        Status: " + _vm._s(item.master.status)), _c("br"), _vm._v("\n        Score: " + _vm._s(item.master.score) + "\n      ") ]) : _vm._e(), _vm._v(" "), _vm._l(item.slaves, (function(slave) {
                return _c("div", {
                    key: slave.uid,
                    staticClass: "slave",
                    staticStyle: {
                        "border-right": "1px solid black",
                        padding: "5px 10px",
                        width: "100px"
                    },
                    style: _vm.getTypeColor(_vm.getType(slave.url))
                }, [ _vm._v("\n        ID: "), _c("a", {
                    attrs: {
                        target: "_blank",
                        href: slave.url
                    }
                }, [ _vm._v(_vm._s(slave.uid)) ]), _c("br"), _vm._v("\n        EP: " + _vm._s(slave.watchedEp) + "\n        "), slave.diff && slave.diff.watchedEp ? _c("span", {
                    staticStyle: {
                        color: "green"
                    }
                }, [ _vm._v("â†’ " + _vm._s(slave.diff.watchedEp)) ]) : _vm._e(), _c("br"), _vm._v("\n        Status: " + _vm._s(slave.status) + "\n        "), slave.diff && slave.diff.status ? _c("span", {
                    staticStyle: {
                        color: "green"
                    }
                }, [ _vm._v("â†’ " + _vm._s(slave.diff.status)) ]) : _vm._e(), _c("br"), _vm._v("\n        Score: " + _vm._s(slave.score) + "\n        "), slave.diff && slave.diff.score ? _c("span", {
                    staticStyle: {
                        color: "green"
                    }
                }, [ _vm._v("â†’ " + _vm._s(slave.diff.score)) ]) : _vm._e() ]);
            })) ], 2);
        })), _vm._v(" "), _vm.missing.length ? _c("div", [ _c("h2", [ _vm._v("Missing") ]), _vm._v(" "), _vm._l(_vm.missing, (function(item) {
            return _c("div", {
                key: item.url,
                staticStyle: {
                    border: "1px solid black",
                    display: "flex",
                    "flex-wrap": "wrap",
                    "margin-bottom": "10px"
                }
            }, [ _c("div", {
                staticStyle: {
                    width: "50px",
                    "border-right": "1px solid black",
                    padding: "5px"
                }
            }, [ _c("a", {
                attrs: {
                    target: "_blank",
                    href: item.url
                }
            }, [ _vm._v(_vm._s(item.malId)) ]) ]), _vm._v(" "), _c("div", {
                staticStyle: {
                    padding: "5px 10px"
                },
                style: _vm.getTypeColor(item.syncType)
            }, [ _vm._v("\n          " + _vm._s(item.title)), _c("br"), _vm._v("\n          EP: " + _vm._s(item.watchedEp)), _c("br"), _vm._v("\n          Status: " + _vm._s(item.status)), _c("br"), _vm._v("\n          Score: " + _vm._s(item.score) + "\n        ") ]), _vm._v(" "), item.error ? _c("div", {
                staticStyle: {
                    color: "red",
                    width: "100%",
                    "border-top": "1px solid"
                }
            }, [ _vm._v("\n          " + _vm._s(item.error) + "\n        ") ]) : _vm._e() ]);
        })) ], 2) : _vm._e() ], 2) ], 1);
    };
    render._withStripped = !0;
    var listSync_listSyncvue_type_script_lang_js_ = __webpack_require__(66).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(listSync_listSyncvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticStyle: {
                "margin-bottom": "20px"
            }
        }, [ this._v("\n      This feature is still in beta. Use at your own risk. More info\n      "), _c("a", {
            attrs: {
                href: "https://github.com/MALSync/MALSync/wiki/List-Sync"
            }
        }, [ this._v("Here") ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/listSync/listSync.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "mdl-grid bg-cell",
            staticStyle: {
                display: "block"
            }
        }, [ _c("h5", [ _vm._v("This script removes all malsync::xxxxx:: from your list.") ]), _vm._v(" "), _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-bottom": "20px"
            },
            attrs: {
                type: "button",
                disabled: _vm.animeLoading
            },
            on: {
                click: function($event) {
                    return _vm.cleanTags();
                }
            }
        }, [ _vm._v("\n    Clean Up Mal-Sync Tags\n  ") ]), _vm._v(" "), _c("br"), _vm._v("\n  Anime:\n  "), _vm.animeLoading && !_vm.animelistLength ? _c("span", [ _vm._v("Loading") ]) : _vm._e(), _vm._v(" "), _vm.animelistLength ? _c("span", [ _vm._v(_vm._s(_vm.animelistLength - _vm.animelist.length) + "/" + _vm._s(_vm.animelistLength)) ]) : _vm._e(), _vm._v(" "), _c("br"), _vm._v("\n  Manga:\n  "), _vm.mangaLoading && !_vm.mangalistLength ? _c("span", [ _vm._v("Loading") ]) : _vm._e(), _vm._v(" "), _vm.mangalistLength ? _c("span", [ _vm._v(_vm._s(_vm.mangalistLength - _vm.mangalist.length) + "/" + _vm._s(_vm.mangalistLength)) ]) : _vm._e(), _c("br") ]);
    };
    render._withStripped = !0;
    var cleanTags_cleanTagsvue_type_script_lang_js_ = __webpack_require__(68).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(cleanTags_cleanTagsvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/cleanTags/cleanTags.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("backbutton"), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid",
            staticStyle: {
                display: "block"
            }
        }, [ _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--12-col"
        }, _vm._l(_vm.pages, (function(page) {
            return _c("div", {
                key: page.name
            }, [ _c("li", {
                staticClass: "mdl-list__item",
                staticStyle: {
                    "padding-top": "0",
                    "padding-bottom": "0"
                }
            }, [ _c("span", {
                staticClass: "mdl-list__item-primary-content"
            }, [ _c("a", {
                attrs: {
                    href: _vm.getDomain(page)
                }
            }, [ _c("img", {
                staticStyle: {
                    "margin-right": "5px"
                },
                attrs: {
                    src: _vm.favicon(_vm.getDomain(page)),
                    height: "16",
                    width: "16"
                }
            }), _vm._v("\n              " + _vm._s(page.name) + "\n            ") ]) ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-secondary-action"
            }, [ _c("label", {
                staticClass: "mdl-switch mdl-js-switch mdl-js-ripple-effect",
                attrs: {
                    for: page.name
                }
            }, [ _c("input", {
                staticClass: "mdl-switch__input",
                attrs: {
                    id: page.name,
                    type: "checkbox"
                },
                domProps: {
                    checked: _vm.getPageState(page)
                },
                on: {
                    change: function($event) {
                        return _vm.setPageState(page, $event.target.checked);
                    }
                }
            }) ]) ]) ]) ]);
        })), 0) ]) ], 1);
    };
    render._withStripped = !0;
    var minimalApp_allSitesvue_type_script_lang_js_ = __webpack_require__(69).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_allSitesvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/allSites.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "page-content malClear",
            attrs: {
                id: "malReviews"
            }
        }, [ _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "" == _vm.xhr,
                expression: "xhr == ''"
            } ],
            staticClass: "mdl-progress mdl-js-progress mdl-progress__indeterminate",
            staticStyle: {
                width: "100%",
                position: "absolute"
            },
            attrs: {
                id: "loadOverview"
            }
        }), _vm._v(" "), _c("span", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: "" != _vm.xhr && _vm.reviews && 0 === _vm.reviews.length,
                expression: "xhr != '' && reviews && reviews.length === 0"
            } ],
            staticClass: "mdl-chip",
            staticStyle: {
                margin: "auto",
                "margin-top": "16px",
                display: "table"
            }
        }, [ _c("span", {
            staticClass: "mdl-chip__text"
        }, [ _vm._v(_vm._s(_vm.lang("NothingFound"))) ]) ]), _vm._v(" "), "" != _vm.xhr ? _c("div", {
            staticClass: "mdl-grid"
        }, _vm._l(_vm.reviews, (function(review, index) {
            return _c("div", {
                key: review.username,
                staticClass: "mdl-cell bg-cell mdl-cell--12-col mdl-shadow--4dp"
            }, [ _c("div", {
                staticClass: "mdl-card__supporting-text mdl-card--border",
                staticStyle: {
                    color: "black"
                }
            }, [ _c("div", {
                staticStyle: {
                    float: "right",
                    "text-align": "right",
                    "max-width": "60%"
                }
            }, [ _c("div", [ _vm._v(_vm._s(review.rDate)) ]), _vm._v(" "), _c("div", [ _vm._v(_vm._s(review.rEpisodes)) ]), _vm._v(" "), _c("div", [ _vm._v("Overall Rating: " + _vm._s(review.rRating)) ]) ]), _vm._v(" "), _c("div", {
                staticStyle: {
                    float: "left",
                    "max-width": "60%"
                }
            }, [ _c("table", {
                attrs: {
                    border: "0",
                    cellpadding: "0",
                    cellspacing: "0",
                    width: "100%"
                }
            }, [ _c("tbody", [ _c("tr", [ _c("td", {
                attrs: {
                    valign: "top",
                    width: "60"
                }
            }, [ _c("div", [ _c("a", {
                attrs: {
                    href: review.userHref
                }
            }, [ _c("img", {
                attrs: {
                    src: review.userImage,
                    width: "48"
                }
            }) ]) ]) ]), _vm._v(" "), _c("td", {
                attrs: {
                    valign: "top"
                }
            }, [ _c("a", {
                attrs: {
                    href: review.userHref
                }
            }, [ _vm._v(_vm._s(review.username)) ]), _vm._v(" "), _c("small", [ _vm._v("("), _c("a", {
                attrs: {
                    href: review.userHref + "/reviews"
                }
            }, [ _vm._v("All reviews") ]), _vm._v(")") ]), _c("br"), _vm._v(" "), review.rPeople ? _c("div", [ _c("strong", [ _c("span", [ _vm._v(_vm._s(review.rPeople)) ]) ]), _vm._v("\n                    people found this review helpful\n                  ") ]) : _vm._e() ]) ]) ]) ]) ]) ]), _vm._v(" "), _c("div", {
                staticClass: "mdl-card__supporting-text",
                staticStyle: {
                    color: "black"
                }
            }, [ _c("div", _vm._l(review.rText, (function(line, index2) {
                return _c("p", {
                    key: index2
                }, [ _vm._v(_vm._s(line)) ]);
            })), 0), _vm._v(" "), review.rReadmore ? _c("div", [ _c("a", {
                directives: [ {
                    name: "show",
                    rawName: "v-show",
                    value: !_vm.activeReadMores.includes(index),
                    expression: "!activeReadMores.includes(index)"
                } ],
                staticClass: "nojs",
                attrs: {
                    href: "#"
                },
                on: {
                    click: function($event) {
                        return _vm.activeReadMores.push(index);
                    }
                }
            }, [ _vm._v("read more") ]), _vm._v(" "), _vm._l(review.rReadmore, (function(line, index3) {
                return _c("p", {
                    directives: [ {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.activeReadMores.includes(index),
                        expression: "activeReadMores.includes(index)"
                    } ],
                    key: index3
                }, [ _vm._v("\n            " + _vm._s(line) + "\n          ") ]);
            })) ], 2) : _vm._e() ]) ]);
        })), 0) : _vm._e() ]);
    };
    render._withStripped = !0;
    var minimalApp_reviewsvue_type_script_lang_js_ = __webpack_require__(70).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_reviewsvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/reviews.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", [ _c("backbutton"), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ _vm._v(_vm._s(_vm.lang("settings_custom_domains_button"))) ]) ]), _vm._v(" "), _vm._m(0) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _vm._l(_vm.permissions, (function(perm, index) {
            return _c("div", {
                key: index
            }, [ _c("li", {
                staticClass: "mdl-list__item",
                staticStyle: {
                    "padding-top": "0",
                    "padding-bottom": "0"
                }
            }, [ _c("div", {
                staticClass: "icon material-icons close-icon",
                on: {
                    click: function($event) {
                        return _vm.removePermission(index);
                    }
                }
            }, [ _vm._v("\n          close\n        ") ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-primary-content"
            }, [ _c("select", {
                directives: [ {
                    name: "model",
                    rawName: "v-model",
                    value: perm.page,
                    expression: "perm.page"
                } ],
                staticClass: "inputtext mdl-textfield__input",
                class: {
                    error: !_vm.pageCheck(perm.page)
                },
                staticStyle: {
                    outline: "none",
                    "margin-left": "10px",
                    "margin-right": "10px"
                },
                attrs: {
                    name: "myinfo_score"
                },
                on: {
                    change: function($event) {
                        var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                            return o.selected;
                        })).map((function(o) {
                            return "_value" in o ? o._value : o.value;
                        }));
                        _vm.$set(perm, "page", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                    }
                }
            }, [ _c("option", {
                attrs: {
                    value: "",
                    disabled: "",
                    selected: ""
                }
            }, [ _vm._v("Select Page") ]), _vm._v(" "), _c("option", {
                attrs: {
                    value: "iframe"
                }
            }, [ _vm._v("Video Iframe") ]), _vm._v(" "), _vm._l(_vm.pages, (function(page, pageKey) {
                return _c("option", {
                    key: pageKey,
                    domProps: {
                        value: pageKey
                    }
                }, [ _vm._v("\n              " + _vm._s(page.name) + "\n            ") ]);
            })) ], 2) ]), _vm._v(" "), _c("span", {
                staticClass: "mdl-list__item-secondary-action"
            }, [ _c("div", {
                staticClass: "mdl-textfield mdl-js-textfield"
            }, [ _c("input", {
                directives: [ {
                    name: "model",
                    rawName: "v-model",
                    value: perm.domain,
                    expression: "perm.domain"
                } ],
                staticClass: "mdl-textfield__input",
                class: {
                    error: !_vm.domainCheck(perm.domain)
                },
                staticStyle: {
                    outline: "none"
                },
                attrs: {
                    type: "text",
                    placeholder: "Domain"
                },
                domProps: {
                    value: perm.domain
                },
                on: {
                    input: function($event) {
                        $event.target.composing || _vm.$set(perm, "domain", $event.target.value);
                    }
                }
            }) ]) ]) ]) ]);
        })), _vm._v(" "), _c("div", [ _c("li", {
            staticClass: "mdl-list__item",
            staticStyle: {
                "padding-top": "0",
                "padding-bottom": "0"
            }
        }, [ _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab",
            on: {
                click: function($event) {
                    return _vm.addPermission();
                }
            }
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("add") ]) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }) ]) ]), _vm._v(" "), _vm.hasPermissions && JSON.stringify(_vm.option) === JSON.stringify(_vm.permissions) ? _vm._e() : _c("div", [ _c("li", {
            staticClass: "mdl-list__item",
            staticStyle: {
                "padding-top": "0",
                "padding-bottom": "0"
            }
        }, [ _c("input", {
            staticClass: "inputButton btn-middle flat js-anime-update-button mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                "margin-right": "5px"
            },
            attrs: {
                type: "button",
                value: _vm.lang("Update"),
                "data-upgraded": ",MaterialButton"
            },
            on: {
                click: function($event) {
                    return _vm.savePermissions();
                }
            }
        }), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }) ]) ]) ], 2) ], 1);
    };
    render._withStripped = !0;
    var minimalApp_customDomainsvue_type_script_lang_js_ = __webpack_require__(71).a, componentNormalizer = (__webpack_require__(575), 
    __webpack_require__(6)), component = Object(componentNormalizer.a)(minimalApp_customDomainsvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "mdl-card__supporting-text"
        }, [ this._v("\n      Please only use if you know what you are doing!"), _c("br"), this._v("\n      More info "), _c("a", {
            attrs: {
                href: "https://github.com/MALSync/MALSync/wiki/Custom-Domains"
            }
        }, [ this._v("here") ]) ]);
    } ], !1, null, "40f53714", null);
    component.options.__file = "src/minimal/minimalApp/customDomains.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            attrs: {
                id: "quicklinkedit"
            }
        }, [ _c("backbutton"), _vm._v(" "), _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--12-col",
            staticStyle: {
                padding: "10px 15px"
            }
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.search,
                expression: "search"
            } ],
            staticClass: "mdl-textfield__input",
            attrs: {
                type: "text",
                placeholder: "Search"
            },
            domProps: {
                value: _vm.search
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.search = $event.target.value);
                }
            }
        }) ]), _vm._v(" "), _c("div", {
            staticClass: "quicklinks mdl-cell bg-cell mdl-cell--12-col",
            staticStyle: {
                padding: "15px"
            }
        }, _vm._l(_vm.linksWithState, (function(link) {
            return _c("div", {
                key: link.name,
                staticClass: "mdl-chip quicklink",
                class: {
                    active: link.active,
                    custom: link.custom,
                    database: link.database,
                    search: link.search && !("home" === link.search.anime || "home" === link.search.manga),
                    home: link.search && ("home" === link.search.anime || "home" === link.search.manga)
                },
                on: {
                    click: function($event) {
                        return _vm.toggleLink(link);
                    }
                }
            }, [ _c("img", {
                staticStyle: {
                    "padding-bottom": "3px",
                    "margin-right": "5px"
                },
                attrs: {
                    src: _vm.favicon(link.domain),
                    height: "16",
                    width: "16"
                }
            }), _vm._v("\n      " + _vm._s(link.name) + "\n    ") ]);
        })), 0), _vm._v(" "), _c("div", {
            staticClass: "custom mdl-cell bg-cell mdl-cell--12-col"
        }, [ _vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v("Name: ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.custom_name,
                expression: "custom_name"
            } ],
            staticClass: "mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                type: "text"
            },
            domProps: {
                value: _vm.custom_name
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.custom_name = $event.target.value);
                }
            }
        }) ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v("Anime Search Url: ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.custom_anime,
                expression: "custom_anime"
            } ],
            staticClass: "mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                type: "text"
            },
            domProps: {
                value: _vm.custom_anime
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.custom_anime = $event.target.value);
                }
            }
        }) ]) ]) ]), _vm._v(" "), _c("li", {
            staticClass: "mdl-list__item mdl-list__item--three-line",
            staticStyle: {
                width: "100%"
            }
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _c("span", [ _vm._v("Manga Search Url: ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-text-body"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.custom_manga,
                expression: "custom_manga"
            } ],
            staticClass: "mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                type: "text"
            },
            domProps: {
                value: _vm.custom_manga
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.custom_manga = $event.target.value);
                }
            }
        }) ]) ]) ]), _vm._v(" "), _c("input", {
            staticClass: "inputButton btn-middle flat js-anime-update-button mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            staticStyle: {
                margin: "15px"
            },
            attrs: {
                disabled: !this.custom_name,
                type: "button",
                value: "Add"
            },
            on: {
                click: _vm.addCustom
            }
        }) ]) ], 1);
    };
    render._withStripped = !0;
    var components_quicklinksEditvue_type_script_lang_js_ = __webpack_require__(73).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_quicklinksEditvue_type_script_lang_js_, render, [ function() {
        var _h = this.$createElement, _c = this._self._c || _h;
        return _c("div", {
            staticClass: "mdl-card__title mdl-card--border"
        }, [ _c("h2", {
            staticClass: "mdl-card__title-text"
        }, [ this._v("Custom Searchlinks") ]) ]);
    }, function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("table", [ _c("tr", [ _c("td", [ _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("{searchterm}") ]) ]), _vm._v(" "), _c("td", [ _vm._v("=> "), _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("no%20game%20no%20life") ]) ]) ]), _vm._v(" "), _c("tr", [ _c("td", [ _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("{searchtermPlus}") ]) ]), _vm._v(" "), _c("td", [ _vm._v("=> "), _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("no+game+no+life") ]) ]) ]), _vm._v(" "), _c("tr", [ _c("td", [ _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("{searchtermRaw}") ]) ]), _vm._v(" "), _c("td", [ _vm._v("=> "), _c("span", {
            staticClass: "darkbox"
        }, [ _vm._v("no game no life") ]) ]) ]) ]) ]);
    } ], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/quicklinksEdit.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._t("default") ], 2), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("label", {
            staticClass: "mdl-switch mdl-js-switch mdl-js-ripple-effect",
            attrs: {
                for: _vm.option
            }
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.value,
                expression: "value"
            } ],
            staticClass: "mdl-switch__input",
            attrs: {
                id: _vm.option,
                type: "checkbox"
            },
            domProps: {
                checked: Array.isArray(_vm.value) ? _vm._i(_vm.value, null) > -1 : _vm.value
            },
            on: {
                change: function($event) {
                    var $$a = _vm.value, $$el = $event.target, $$c = !!$$el.checked;
                    if (Array.isArray($$a)) {
                        var $$i = _vm._i($$a, null);
                        $$el.checked ? $$i < 0 && (_vm.value = $$a.concat([ null ])) : $$i > -1 && (_vm.value = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
                    } else _vm.value = $$c;
                }
            }
        }) ]) ]) ]);
    };
    render._withStripped = !0;
    var components_settingsCheckboxvue_type_script_lang_js_ = __webpack_require__(47).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_settingsCheckboxvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/settingsCheckbox.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._t("default") ], 2), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("div", {
            staticClass: "mdl-textfield mdl-js-textfield",
            staticStyle: {
                "min-width": "35px",
                "max-width": "35px",
                width: "100%",
                padding: "0"
            }
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.value,
                expression: "value"
            } ],
            staticClass: "mdl-textfield__input",
            staticStyle: {
                "text-align": "center"
            },
            attrs: {
                id: _vm.option,
                type: "number",
                step: _vm.step,
                min: _vm.min,
                max: _vm.max
            },
            domProps: {
                value: _vm.value
            },
            on: {
                input: function($event) {
                    $event.target.composing || (_vm.value = $event.target.value);
                }
            }
        }) ]) ]) ]);
    };
    render._withStripped = !0;
    var components_settingsNumberInputvue_type_script_lang_js_ = __webpack_require__(48).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_settingsNumberInputvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/settingsNumberInput.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._v("\n    " + _vm._s(_vm.text) + "\n  ") ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _c("select", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.value,
                expression: "value"
            } ],
            staticClass: "inputtext mdl-textfield__input",
            staticStyle: {
                outline: "none"
            },
            attrs: {
                name: "myinfo_score"
            },
            on: {
                change: function($event) {
                    var $$selectedVal = Array.prototype.filter.call($event.target.options, (function(o) {
                        return o.selected;
                    })).map((function(o) {
                        return "_value" in o ? o._value : o.value;
                    }));
                    _vm.value = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                }
            }
        }, [ _vm._t("default") ], 2) ]) ]);
    };
    render._withStripped = !0;
    var components_settingsDropdownvue_type_script_lang_js_ = __webpack_require__(49).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_settingsDropdownvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/settingsDropdown.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("span", [ _vm.button ? _c("button", {
            staticClass: "mdl-button mdl-js-button mdl-button--raised mdl-button--colored",
            on: {
                click: function($event) {
                    return _vm.buttonClick();
                }
            }
        }, [ _vm._t("default") ], 2) : [ _c("input", {
            attrs: {
                type: "file"
            },
            on: {
                change: function($event) {
                    return _vm.handleFileUpload($event);
                }
            }
        }), _vm._v(" "), "webextension" == _vm.type() ? _c("p", {
            staticClass: "info"
        }, [ _vm._v("\n      If you have problems please retry in\n      "), _c("a", {
            attrs: {
                href: "#"
            },
            on: {
                click: function($event) {
                    return _vm.openWindow($event);
                }
            }
        }, [ _vm._v("this window") ]) ]) : _vm._e() ] ], 2);
    };
    render._withStripped = !0;
    var components_settingsFileUploadvue_type_script_lang_js_ = __webpack_require__(50).a, componentNormalizer = (__webpack_require__(315), 
    __webpack_require__(6)), component = Object(componentNormalizer.a)(components_settingsFileUploadvue_type_script_lang_js_, render, [], !1, null, "4b3e3631", null);
    component.options.__file = "src/minimal/minimalApp/components/settingsFileUpload.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content"
        }, [ _vm._t("default"), _vm._v(" "), _c("div", {
            directives: [ {
                name: "show",
                rawName: "v-show",
                value: 1 === Object.keys(_vm.value).length,
                expression: "Object.keys(value).length === 1"
            } ]
        }, [ _c("tooltip", {
            attrs: {
                "tag-style": "color: #8a1818; font-size: 20px; padding-bottom: 0;",
                "icon-text": "info"
            }
        }, [ _vm._v(_vm._s(_vm.lang("settings_shortcut_tooltip"))) ]) ], 1) ], 2), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ Object.keys(_vm.value).length ? _c("div", {
            staticClass: "icon material-icons close-icon",
            on: {
                click: function($event) {
                    _vm.value = {};
                }
            }
        }, [ _vm._v("\n      close\n    ") ]) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "mdl-textfield mdl-js-textfield"
        }, [ _c("input", {
            directives: [ {
                name: "model",
                rawName: "v-model",
                value: _vm.display,
                expression: "display"
            } ],
            staticClass: "mdl-textfield__input",
            class: {
                rec: _vm.rec,
                tempRec: _vm.tempRec
            },
            domProps: {
                value: _vm.display
            },
            on: {
                keydown: function($event) {
                    return $event.preventDefault(), _vm.keyDown($event);
                },
                keyup: function($event) {
                    return _vm.keyUp($event);
                },
                blur: function($event) {
                    return _vm.focusLost();
                },
                input: function($event) {
                    $event.target.composing || (_vm.display = $event.target.value);
                }
            }
        }) ]) ]) ]);
    };
    render._withStripped = !0;
    var components_settingsShortcutvue_type_script_lang_js_ = __webpack_require__(52).a, componentNormalizer = (__webpack_require__(317), 
    __webpack_require__(6)), component = Object(componentNormalizer.a)(components_settingsShortcutvue_type_script_lang_js_, render, [], !1, null, "29cae25a", null);
    component.options.__file = "src/minimal/minimalApp/components/settingsShortcut.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("li", {
            staticClass: "mdl-list__item"
        }, [ _c("span", {
            staticClass: "mdl-list__item-primary-content",
            on: {
                click: function($event) {
                    return _vm.init();
                }
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.pageName) + "\n    "), _vm.username ? _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("check_circle_outline") ]) : _c("i", {
            staticClass: "material-icons wrong"
        }, [ _vm._v("highlight_off") ]) ]), _vm._v(" "), _c("span", {
            staticClass: "mdl-list__item-secondary-action"
        }, [ _vm.username && _vm.listObj.deauth ? [ _c("i", {
            staticClass: "material-icons",
            staticStyle: {
                color: "black",
                cursor: "pointer",
                "vertical-align": "middle",
                "margin-top": "-4px"
            },
            on: {
                click: function($event) {
                    return _vm.deauth();
                }
            }
        }, [ _vm._v("\n        eject\n      ") ]) ] : _vm._e(), _vm._v(" "), _c("a", {
            attrs: {
                target: "_blank",
                href: _vm.pageAuth
            }
        }, [ _vm.username ? [ _vm._v("\n        " + _vm._s(_vm.username) + "\n      ") ] : [ _vm._v("\n        " + _vm._s(_vm.lang("settings_Authenticate")) + "\n      ") ] ], 2) ], 2) ]);
    };
    render._withStripped = !0;
    var components_settingsLoginvue_type_script_lang_js_ = __webpack_require__(54).a, componentNormalizer = (__webpack_require__(319), 
    __webpack_require__(6)), component = Object(componentNormalizer.a)(components_settingsLoginvue_type_script_lang_js_, render, [], !1, null, "50365ef6", null);
    component.options.__file = "src/minimal/minimalApp/components/settingsLogin.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--6-col mdl-cell--8-col-tablet mdl-shadow--4dp"
        }, [ _c("div", {
            staticClass: "mdl-cell",
            staticStyle: {
                width: "100%"
            }
        }, [ _vm._v("\n    The correction functionality was moved into a seperate popup for faster and better integeration. You can access it\n    "), _vm.keys ? [ _vm._v("with the shortcut '" + _vm._s(_vm.keys) + "' or") ] : _vm._e(), _vm._v(" by clicking\n    "), _c("a", {
            on: {
                click: function($event) {
                    return $event.stopPropagation(), _vm.openPopup($event);
                }
            }
        }, [ _vm._v("here") ]), _vm._v(".\n  ") ], 2) ]);
    };
    render._withStripped = !0;
    var minimalApp_correctionvue_type_script_lang_js_ = __webpack_require__(56).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_correctionvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/correction.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _c("div", {
            attrs: {
                id: "quicklinkoverview"
            }
        }, [ _vm.links && _vm.links.length ? _c("div", {
            staticClass: "quicklinks"
        }, _vm._l(_vm.links, (function(link) {
            return _c("div", {
                key: link.name,
                staticClass: "mdl-chip quicklink"
            }, [ _c("img", {
                staticStyle: {
                    "padding-bottom": "3px",
                    "margin-right": "5px"
                },
                attrs: {
                    src: _vm.favicon(link.domain),
                    height: "16",
                    width: "16"
                }
            }), _vm._v("\n      " + _vm._s(link.name) + "\n    ") ]);
        })), 0) : _c("div", [ _c("input", {
            staticClass: "inputButton btn-middle flat js-anime-update-button mdl-button mdl-js-button mdl-button--raised mdl-button--accent",
            attrs: {
                type: "button",
                value: _vm.lang("Add"),
                "data-upgraded": ",MaterialButton"
            }
        }) ]) ]);
    };
    render._withStripped = !0;
    var components_quicklinksOverviewvue_type_script_lang_js_ = __webpack_require__(57).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_quicklinksOverviewvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/quicklinksOverview.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _vm.apiCacheKey && _vm.elements && _vm.elements.length ? _c("div", {
            staticClass: "mdl-cell bg-cell mdl-cell--12-col mdl-shadow--4dp",
            staticStyle: {
                padding: "8px"
            }
        }, [ _vm.completed && _vm.completed.length ? [ _c("div", [ _vm._v(_vm._s(_vm.lang("prediction_complete"))) ]), _vm._v(" "), _vm._l(_vm.completed, (function(item, index) {
            return _c("span", {
                key: index
            }, [ item.item.top ? _c("span", {
                staticClass: "list-content"
            }, [ _c("country-flag", {
                attrs: {
                    country: _vm.correctFlag(item.language),
                    title: item.language.toUpperCase() + " " + item.index.toUpperCase(),
                    text: item.index.toUpperCase()
                }
            }) ], 1) : _vm._e() ]);
        })) ] : _vm._e(), _vm._v(" "), _vm.ongoing && _vm.ongoing.length ? [ _c("div", [ _vm._v(_vm._s(_vm.lang("prediction_ongoing"))) ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-grid mdl-grid--no-spacing"
        }, _vm._l(_vm.ongoing, (function(item, index) {
            return _c("div", {
                key: index,
                staticClass: "list-content mdl-cell--6-col mdl-cell--8-col-tablet",
                staticStyle: {
                    display: "flex",
                    "align-items": "center"
                }
            }, [ _c("country-flag", {
                attrs: {
                    country: _vm.correctFlag(item.language),
                    title: item.language.toUpperCase() + " " + item.index.toUpperCase(),
                    text: item.index.toUpperCase()
                }
            }), _vm._v(" "), item.item.top.state && "ongoing" !== item.item.top.state ? [ _c("span", {
                staticStyle: {
                    color: "red",
                    "padding-right": "5px"
                }
            }, [ _vm._v(_vm._s(_vm.lang("prediction_incomplete"))) ]) ] : _vm._e(), _vm._v(" "), item.item.top.lastEp && item.item.top.lastEp.total ? [ item.item.top.state && "ongoing" !== item.item.top.state && item.item.top.stateInfo ? [ _vm._v("\n            " + _vm._s(item.item.top.stateInfo) + "\n          ") ] : [ _vm._v("\n            " + _vm._s(_vm.utils.episode(_vm.type)) + " " + _vm._s(item.item.top.lastEp.total) + "\n            "), _vm.totalEps ? [ _vm._v("/ " + _vm._s(_vm.totalEps)) ] : _vm._e() ], _vm._v(" "), item.item.top.lastEp.timestamp ? [ _vm._v("\n            (" + _vm._s(_vm.releaseTime(item.item.top.lastEp.timestamp)) + ")\n          ") ] : _vm._e(), _vm._v(" "), item.item.top.predicition ? [ _vm._v("\n            [" + _vm._s(_vm.lang("prediction_next", [ _vm.releaseTime(item.item.top.predicition.timestamp).trim() ])) + "]\n          ") ] : _vm._e() ] : _vm._e() ], 2);
        })), 0) ] : _vm._e() ], 2) : _vm._e();
    };
    render._withStripped = !0;
    var components_overviewProgressvue_type_script_lang_js_ = __webpack_require__(59).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_overviewProgressvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/components/overviewProgress.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _vm.listView ? _c("tr", {
            staticStyle: {
                cursor: "pointer"
            },
            on: {
                click: function($event) {
                    return _vm.openLink(_vm.item.url);
                }
            }
        }, [ _c("td", {
            staticStyle: {
                width: "64px"
            }
        }, [ _c("div", {
            staticClass: "imageTd",
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                right: "0",
                bottom: "-1px",
                overflow: "hidden"
            }
        }, [ _c("clazy-load", {
            attrs: {
                src: _vm.imageHi,
                margin: "200px 0px",
                threshold: .1,
                ratio: .1
            },
            on: {
                error: _vm.setQuestionmark
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.imageHi,
                width: "100%"
            },
            on: {
                error: _vm.setQuestionmark
            }
        }) ]) ], 1) ]), _vm._v(" "), _c("td", {
            staticClass: "mdl-data-table__cell--non-numeric",
            staticStyle: {
                "white-space": "normal",
                position: "relative",
                "padding-left": "10px",
                "padding-right": "28px"
            }
        }, [ _vm.item.fn.progress && _vm.item.fn.progress.isAiring() ? _c("div", {
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                padding: "0 11px",
                margin: "0 0",
                "text-align": "center",
                "font-size": "10px"
            }
        }, [ _vm._v("\n      " + _vm._s(_vm.item.fn.progress.getAuto()) + "\n    ") ]) : _vm._e(), _vm._v(" "), _c("span", {
            staticStyle: {
                "font-weight": "bold"
            }
        }, [ _vm._v(_vm._s(_vm.item.title)) ]), _vm._v(" "), _vm.streamUrl ? _c("a", {
            staticClass: "mal-sync-stream",
            staticStyle: {
                margin: "0 5px",
                position: "absolute",
                right: "0",
                top: "0"
            },
            attrs: {
                title: _vm.streamUrl.split("/")[2],
                target: "_blank",
                href: _vm.streamUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.favicon(_vm.streamUrl.split("/")[2])
            }
        }) ]) : _vm._e(), _vm._v(" "), _vm.continueUrl ? _c("a", {
            staticClass: "nextStream",
            staticStyle: {
                margin: "0 5px 0 0",
                color: "#BABABA",
                position: "absolute",
                right: "0",
                top: "20px"
            },
            attrs: {
                title: _vm.lang("overview_Continue_" + _vm.item.type),
                target: "_blank",
                href: _vm.continueUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.assetUrl("double-arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }) ]) : _vm._e(), _vm._v(" "), _vm.resumeUrl ? _c("a", {
            staticClass: "resumeStream",
            staticStyle: {
                margin: "0 5px 0 0",
                color: "#BABABA",
                position: "absolute",
                right: "0",
                top: "20px"
            },
            attrs: {
                title: _vm.lang("overview_Resume_Episode_" + _vm.item.type),
                target: "_blank",
                href: _vm.resumeUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.assetUrl("arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }) ]) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "mdl-progress pr-bar",
            staticStyle: {
                position: "absolute",
                bottom: "0",
                left: "0",
                right: "0",
                width: "auto",
                opacity: "0.5"
            },
            attrs: {
                id: "p1"
            }
        }, [ _c("div", {
            staticClass: "progressbar bar bar1",
            style: _vm.progress
        }), _vm._v(" "), _vm.hasTotalEp ? _c("div", {
            staticClass: "bufferbar bar bar2",
            staticStyle: {
                width: "calc(100% + 1px)"
            }
        }) : _vm._e(), _vm._v(" "), _vm.item.fn.progress && _vm.item.fn.progress.isAiring() ? _c("div", {
            staticClass: "predictionbar bar kal-ep-pre",
            style: _vm.predictionBar
        }, [ _vm.barData.predWidth && "100" !== _vm.barData.predWidth && _vm.barData.predWidth <= _vm.barData.epWidth ? _c("div", {
            staticClass: "bar-tab"
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("arrow_drop_up") ]) ]) : _vm._e() ]) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "auxbar bar bar3",
            staticStyle: {
                width: "0%"
            }
        }) ]) ]), _vm._v(" "), _c("td", {
            staticStyle: {
                width: "70px"
            }
        }, [ _vm._v("\n    " + _vm._s(_vm.item.watchedEp) + "/"), _vm.item.totalEp ? [ _vm._v(_vm._s(_vm.item.totalEp)) ] : [ _vm._v("?") ] ], 2), _vm._v(" "), _c("td", {
            staticStyle: {
                width: "57px"
            }
        }, [ _vm.item.score ? [ _vm._v(_vm._s(_vm.item.score)) ] : [ _vm._v("-") ] ], 2) ]) : _c("div", {
            staticClass: "mdl-cell mdl-cell--2-col mdl-cell--4-col-tablet mdl-cell--6-col-phone mdl-shadow--2dp mdl-grid bookEntry",
            staticStyle: {
                position: "relative",
                padding: "0",
                width: "210px",
                height: "293px"
            },
            attrs: {
                title: _vm.item.fn.progress && _vm.item.fn.progress.getAutoText()
            }
        }, [ _c("div", {
            staticClass: "data title",
            staticStyle: {
                "background-color": "#cdcdcd",
                width: "100%",
                position: "relative",
                "padding-top": "5px"
            }
        }, [ _c("div", {
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                right: "0",
                bottom: "0",
                overflow: "hidden"
            }
        }, [ _c("clazy-load", {
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                right: "0",
                bottom: "0",
                overflow: "hidden"
            },
            attrs: {
                src: _vm.imageHi,
                margin: "200px 0px",
                threshold: .1,
                ratio: .1
            },
            on: {
                error: _vm.setQuestionmark
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.imageHi,
                width: "100%"
            },
            on: {
                error: _vm.setQuestionmark
            }
        }) ]) ], 1), _vm._v(" "), _vm.item.fn.progress && _vm.item.fn.progress.isAiring() ? _c("div", {
            staticClass: "mdl-shadow--2dp",
            staticStyle: {
                position: "absolute",
                top: "0",
                right: "0",
                "background-color": "rgba(255, 255, 255, 0.9)",
                padding: "0 5px",
                margin: "5px 0",
                "text-align": "center"
            }
        }, [ _vm._v("\n      " + _vm._s(_vm.item.fn.progress.getAuto()) + "\n    ") ]) : _vm._e(), _vm._v(" "), _vm.item.score ? _c("div", {
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                padding: "0 5px",
                margin: "5px 0",
                "text-align": "center"
            }
        }, [ _c("div", {
            staticStyle: {
                width: "38px",
                height: "38px",
                position: "relative"
            }
        }, [ _c("i", {
            staticClass: "material-icons",
            staticStyle: {
                color: "#3f51b5",
                position: "absolute",
                left: "0",
                top: "0",
                "font-size": "38px"
            }
        }, [ _vm._v("star") ]), _vm._v(" "), _c("div", {
            staticStyle: {
                color: "white",
                position: "absolute",
                left: "0",
                top: "0",
                right: "0",
                bottom: "0",
                "text-align": "center",
                "line-height": "38px",
                "padding-top": "1px"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.item.score) + "\n        ") ]) ]) ]) : _vm._e(), _vm._v(" "), _c("a", {
            staticStyle: {
                position: "absolute",
                top: "0",
                left: "0",
                right: "0",
                bottom: "0"
            },
            attrs: {
                href: _vm.item.url
            }
        }), _vm._v(" "), _c("span", {
            staticClass: "mdl-shadow--2dp",
            staticStyle: {
                position: "absolute",
                bottom: "0",
                display: "block",
                "background-color": "rgba(255, 255, 255, 0.9)",
                "padding-top": "5px",
                "align-items": "center",
                "justify-content": "space-between",
                left: "0",
                right: "0",
                "padding-right": "8px",
                "padding-left": "8px",
                "padding-bottom": "8px"
            }
        }, [ _c("a", {
            staticStyle: {
                color: "black",
                "text-decoration": "none"
            },
            attrs: {
                href: _vm.item.url
            }
        }, [ _vm._v("\n        " + _vm._s(_vm.item.title) + "\n      ") ]), _vm._v(" "), _c("div", {
            staticClass: "mdl-progress pr-bar",
            staticStyle: {
                position: "absolute",
                top: "-4px",
                left: "0"
            },
            attrs: {
                id: "p1"
            }
        }, [ _c("div", {
            staticClass: "progressbar bar bar1",
            style: _vm.progress
        }), _vm._v(" "), _vm.hasTotalEp ? _c("div", {
            staticClass: "bufferbar bar bar2",
            staticStyle: {
                width: "calc(100% + 1px)"
            }
        }) : _vm._e(), _vm._v(" "), _vm.item.fn.progress && _vm.item.fn.progress.isAiring() ? _c("div", {
            staticClass: "predictionbar bar kal-ep-pre",
            style: _vm.predictionBar
        }, [ _vm.barData.predWidth && 100 !== _vm.barData.predWidth && _vm.barData.predWidth <= _vm.barData.epWidth ? _c("div", {
            staticClass: "bar-tab"
        }, [ _c("i", {
            staticClass: "material-icons"
        }, [ _vm._v("arrow_drop_up") ]) ]) : _vm._e() ]) : _vm._e(), _vm._v(" "), _c("div", {
            staticClass: "auxbar bar bar3",
            staticStyle: {
                width: "0%"
            }
        }) ]), _vm._v(" "), _c("div", {
            staticClass: "data progress mdl-chip mdl-chip--contact mdl-color--indigo-100",
            staticStyle: {
                float: "right",
                "line-height": "20px",
                height: "20px",
                "padding-right": "4px",
                "margin-left": "5px"
            }
        }, [ _c("div", {
            staticClass: "link mdl-chip__contact mdl-color--primary mdl-color-text--white",
            staticStyle: {
                "line-height": "20px",
                height: "20px",
                "margin-right": "0"
            },
            attrs: {
                title: "[" + _vm.item.watchedEp + "/" + _vm.item.totalEp + "]"
            }
        }, [ _vm._v("\n          " + _vm._s(_vm.item.watchedEp) + "\n        ") ]), _vm._v(" "), _vm.streamUrl ? _c("a", {
            staticClass: "mal-sync-stream",
            staticStyle: {
                margin: "0 5px"
            },
            attrs: {
                title: _vm.streamUrl.split("/")[2],
                target: "_blank",
                href: _vm.streamUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.favicon(_vm.streamUrl.split("/")[2])
            }
        }) ]) : _vm._e(), _vm._v(" "), _vm.continueUrl ? _c("a", {
            staticClass: "nextStream",
            staticStyle: {
                margin: "0 5px 0 0",
                color: "#BABABA"
            },
            attrs: {
                title: _vm.lang("overview_Continue_" + _vm.item.type),
                target: "_blank",
                href: _vm.continueUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.assetUrl("double-arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }) ]) : _vm._e(), _vm._v(" "), _vm.resumeUrl ? _c("a", {
            staticClass: "resumeStream",
            staticStyle: {
                margin: "0 5px 0 0",
                color: "#BABABA"
            },
            attrs: {
                title: _vm.lang("overview_Resume_Episode_" + _vm.item.type),
                target: "_blank",
                href: _vm.resumeUrl
            }
        }, [ _c("img", {
            attrs: {
                src: _vm.assetUrl("arrow-16px.png"),
                width: "16",
                height: "16"
            }
        }) ]) : _vm._e() ]) ]) ]) ]);
    };
    render._withStripped = !0;
    var minimalApp_bookmarksItemvue_type_script_lang_js_ = __webpack_require__(63).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(minimalApp_bookmarksItemvue_type_script_lang_js_, render, [], !1, null, null, null);
    component.options.__file = "src/minimal/minimalApp/bookmarksItem.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var render = function() {
        var _vm = this, _h = _vm.$createElement, _c = _vm._self._c || _h;
        return _vm.country ? _c("div", {
            staticClass: "flagIcon mdl-shadow--2dp",
            attrs: {
                title: _vm.text
            }
        }, [ _vm.flagHtml ? _c("div", {
            directives: [ {
                name: "dompurify-html",
                rawName: "v-dompurify-html",
                value: _vm.flagHtml,
                expression: "flagHtml"
            } ],
            staticClass: "flagflag"
        }) : _c("div", {
            staticClass: "flagCountry"
        }, [ _vm._v(_vm._s(_vm.country)) ]), _vm._v(" "), "SUB" !== _vm.text ? _c("div", {
            staticClass: "flagText"
        }, [ _vm._v(_vm._s(_vm.text)) ]) : _vm._e() ]) : _vm._e();
    };
    render._withStripped = !0;
    var components_overviewProgressCountryFlagvue_type_script_lang_js_ = __webpack_require__(60).a, componentNormalizer = __webpack_require__(6), component = Object(componentNormalizer.a)(components_overviewProgressCountryFlagvue_type_script_lang_js_, render, [], !1, null, "77e1b9bb", null);
    component.options.__file = "src/minimal/minimalApp/components/overviewProgressCountryFlag.vue";
    __webpack_exports__.a = component.exports;
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return getOverview;
    }));
    var helper = __webpack_require__(15), metaOverview = __webpack_require__(128);
    const MetaOverview = __webpack_require__(129).a;
    var MyAnimeList_api_metaOverview = __webpack_require__(130), AniList_metaOverview = __webpack_require__(131), Kitsu_metaOverview = __webpack_require__(132), Simkl_metaOverview = __webpack_require__(133);
    function getOverview(url, type, syncMode = "") {
        if (syncMode || (syncMode = helper.a(type)), /^local:\/\//i.test(url)) return new metaOverview.a(url);
        if ("ANILIST" === syncMode) return new AniList_metaOverview.a(url);
        if ("KITSU" === syncMode) return new Kitsu_metaOverview.a(url);
        if ("SIMKL" === syncMode) return new Simkl_metaOverview.a(url);
        if ("MAL" === syncMode) return new MetaOverview(url);
        if ("MALAPI" === syncMode) return new MyAnimeList_api_metaOverview.a(url);
        throw "Unknown sync mode";
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), function(con, api) {
        var _pages_syncPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100), _anilist_anilistClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(114), _kitsu_kitsuClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115), _simkl_simklClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116), _utils_player__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37), _pages_adult_pages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(117), _utils_oauth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(79), _floatbutton_userscript__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(124), __awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : function(value) {
                        return value instanceof P ? value : new P((function(resolve) {
                            resolve(value);
                        }));
                    }(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        function main() {
            if (window.location.href.indexOf("myanimelist.net") > -1) ; else if (window.location.href.indexOf("anilist.co") > -1) {
                new _anilist_anilistClass__WEBPACK_IMPORTED_MODULE_1__.a(window.location.href);
            } else if (window.location.href.indexOf("kitsu.io") > -1) {
                new _kitsu_kitsuClass__WEBPACK_IMPORTED_MODULE_2__.a(window.location.href);
            } else if (window.location.href.indexOf("simkl.com") > -1) {
                new _simkl_simklClass__WEBPACK_IMPORTED_MODULE_3__.a(window.location.href);
            } else if (window.location.href.indexOf("malsync.moe/mal/oauth") > -1) Object(_utils_oauth__WEBPACK_IMPORTED_MODULE_6__.b)(); else {
                let page;
                try {
                    if (function() {
                        try {
                            return window.self !== window.top;
                        } catch (e) {
                            return !0;
                        }
                    }()) throw "iframe";
                    page = new _pages_syncPage__WEBPACK_IMPORTED_MODULE_0__.a(window.location.href, _pages_adult_pages__WEBPACK_IMPORTED_MODULE_5__.a, _floatbutton_userscript__WEBPACK_IMPORTED_MODULE_7__.a);
                } catch (e) {
                    return con.info(e), void Object(_utils_player__WEBPACK_IMPORTED_MODULE_4__.b)((function(item) {
                        api.storage.set("iframePlayer", item);
                    }));
                }
                page.init(), api.storage.set("iframePlayer", "null"), setInterval((function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const item = yield api.storage.get("iframePlayer");
                        void 0 !== item && "null" !== item && (page.setVideoTime(item, (function(time) {})), 
                        api.storage.set("iframePlayer", "null"));
                    }));
                }), 2e3);
            }
        }
        console.log("%cMAL-Sync Adult", "font-size: 40px; padding-bottom: 3px; color: white; text-shadow: -1px -1px #2e51a2, 1px -1px #2e51a2, -1px 1px #2e51a2, 1px 1px #2e51a2, 2px 2px #2e51a2, 3px 3px #2e51a2;", "Version: " + api.storage.version()), 
        api.settings.init().then(() => {
            main();
        });
    }.call(this, __webpack_require__(4), __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        !function(global, undefined) {
            "use strict";
            if (!global.setImmediate) {
                var registerImmediate, html, channel, messagePrefix, onGlobalMessage, nextHandle = 1, tasksByHandle = {}, currentlyRunningATask = !1, doc = global.document, attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                attachTo = attachTo && attachTo.setTimeout ? attachTo : global, "[object process]" === {}.toString.call(global.process) ? registerImmediate = function(handle) {
                    process.nextTick((function() {
                        runIfPresent(handle);
                    }));
                } : !function() {
                    if (global.postMessage && !global.importScripts) {
                        var postMessageIsAsynchronous = !0, oldOnMessage = global.onmessage;
                        return global.onmessage = function() {
                            postMessageIsAsynchronous = !1;
                        }, global.postMessage("", "*"), global.onmessage = oldOnMessage, postMessageIsAsynchronous;
                    }
                }() ? global.MessageChannel ? ((channel = new MessageChannel).port1.onmessage = function(event) {
                    runIfPresent(event.data);
                }, registerImmediate = function(handle) {
                    channel.port2.postMessage(handle);
                }) : doc && "onreadystatechange" in doc.createElement("script") ? (html = doc.documentElement, 
                registerImmediate = function(handle) {
                    var script = doc.createElement("script");
                    script.onreadystatechange = function() {
                        runIfPresent(handle), script.onreadystatechange = null, html.removeChild(script), 
                        script = null;
                    }, html.appendChild(script);
                }) : registerImmediate = function(handle) {
                    setTimeout(runIfPresent, 0, handle);
                } : (messagePrefix = "setImmediate$" + Math.random() + "$", onGlobalMessage = function(event) {
                    event.source === global && "string" == typeof event.data && 0 === event.data.indexOf(messagePrefix) && runIfPresent(+event.data.slice(messagePrefix.length));
                }, global.addEventListener ? global.addEventListener("message", onGlobalMessage, !1) : global.attachEvent("onmessage", onGlobalMessage), 
                registerImmediate = function(handle) {
                    global.postMessage(messagePrefix + handle, "*");
                }), attachTo.setImmediate = function(callback) {
                    "function" != typeof callback && (callback = new Function("" + callback));
                    for (var args = new Array(arguments.length - 1), i = 0; i < args.length; i++) args[i] = arguments[i + 1];
                    var task = {
                        callback: callback,
                        args: args
                    };
                    return tasksByHandle[nextHandle] = task, registerImmediate(nextHandle), nextHandle++;
                }, attachTo.clearImmediate = clearImmediate;
            }
            function clearImmediate(handle) {
                delete tasksByHandle[handle];
            }
            function runIfPresent(handle) {
                if (currentlyRunningATask) setTimeout(runIfPresent, 0, handle); else {
                    var task = tasksByHandle[handle];
                    if (task) {
                        currentlyRunningATask = !0;
                        try {
                            !function(task) {
                                var callback = task.callback, args = task.args;
                                switch (args.length) {
                                  case 0:
                                    callback();
                                    break;

                                  case 1:
                                    callback(args[0]);
                                    break;

                                  case 2:
                                    callback(args[0], args[1]);
                                    break;

                                  case 3:
                                    callback(args[0], args[1], args[2]);
                                    break;

                                  default:
                                    callback.apply(void 0, args);
                                }
                            }(task);
                        } finally {
                            clearImmediate(handle), currentlyRunningATask = !1;
                        }
                    }
                }
            }
        }("undefined" == typeof self ? void 0 === global ? this : global : self);
    }).call(this, __webpack_require__(87), __webpack_require__(94));
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(293);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "::-webkit-scrollbar {\n  display: none;\n}\n#material {\n  all: initial;\n  color: white;\n  font-family: 'Helvetica', 'Arial', sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 20px;\n}\n#material * {\n  box-sizing: border-box;\n}\n#material .scroll {\n  overflow-y: auto;\n  max-height: 80vh;\n  scrollbar-width: none;\n}\n#material .close {\n  display: block;\n  margin-top: 15px;\n  text-align: center;\n  cursor: pointer;\n}\n#material .mdl-color--primary {\n  background-color: #3f51b5;\n}\n#material p {\n  font-weight: 400;\n  line-height: 24px;\n  font-size: 14px;\n  letter-spacing: 0;\n  margin: 0 0 16px;\n}\n#material a {\n  color: #f43b7a;\n  text-decoration: none !important;\n}\n#material .search .input {\n  width: 100%;\n}\n#material .result {\n  cursor: pointer;\n  display: flex;\n  margin-bottom: 15px;\n  background-color: #484848;\n  max-width: 400px;\n}\n#material .result.active {\n  border: 1px solid #f43b7a;\n  border-style: dashed;\n}\n#material .result .image {\n  height: 100px;\n  width: 64px;\n  min-width: 64px;\n  background-color: grey;\n}\n#material .result .image img {\n  height: 100%;\n  width: 100%;\n  object-fit: cover;\n}\n#material .result .right {\n  flex-grow: 100;\n  cursor: pointer;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding: 5px 10px;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n#material .result .right .title {\n  font-size: 20px;\n  font-weight: 400;\n  line-height: 1;\n  margin-bottom: 3px;\n}\n#material .result .right p {\n  margin-bottom: 0;\n  line-height: 20px;\n  color: white;\n}\n#material .rules .title {\n  color: #f43b7a;\n}\n#material .rules .rule {\n  margin-bottom: 15px;\n  background-color: #484848;\n  max-width: 400px;\n}\n#material .rules .rule .header {\n  padding: 5px 10px;\n  border-bottom: 1px solid white;\n}\n#material .rules .rule.active {\n  border: 1px solid #f43b7a;\n}\n#material .rules .rule .content {\n  padding: 5px 10px;\n}\n#material .rules .rule .hover {\n  display: none;\n}\n#material .rules .rule:hover .hover {\n  display: block;\n}\n#material .rules .rule:hover .noHover {\n  display: none;\n}\n#material .inputButton {\n  display: flex;\n  align-items: center;\n}\n#material .inputButton .group {\n  width: 100%;\n}\n#material .group {\n  position: relative;\n  margin-bottom: 15px;\n  margin-top: 25px;\n}\n#material .group input {\n  font-size: 18px;\n  padding: 10px 10px 10px 5px;\n  display: block;\n  color: white;\n  width: 100%;\n  border: none;\n  background-color: #484848;\n  border-bottom: 1px solid white;\n}\n#material .group input:focus {\n  outline: none;\n}\n#material .group label {\n  color: #999;\n  font-size: 18px;\n  font-weight: normal;\n  position: absolute;\n  pointer-events: none;\n  left: 5px;\n  top: 10px;\n  transition: 0.2s ease all;\n  -moz-transition: 0.2s ease all;\n  -webkit-transition: 0.2s ease all;\n}\n#material .group input:focus ~ label,\n#material .group input:valid ~ label {\n  left: 0;\n  top: -20px;\n  font-size: 14px;\n  color: #f43b7a;\n}\n#material .group .bar {\n  position: relative;\n  display: block;\n}\n#material .group .bar::before,\n#material .group .bar::after {\n  content: '';\n  height: 2px;\n  width: 0;\n  bottom: 0;\n  position: absolute;\n  background: #f43b7a;\n  transition: 0.2s ease all;\n  -moz-transition: 0.2s ease all;\n  -webkit-transition: 0.2s ease all;\n}\n#material .group .bar::before {\n  left: 50%;\n}\n#material .group .bar::after {\n  right: 50%;\n}\n#material .group input:focus ~ .bar::before,\n#material .group input:focus ~ .bar::after {\n  width: 50%;\n}\n#material .mdl-progress {\n  display: block;\n  position: relative;\n  height: 3px;\n  width: 500px;\n  max-width: 100%;\n}\n#material .mdl-progress > .bar {\n  display: block;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 0%;\n  transition: width 0.2s linear;\n}\n#material .mdl-progress > .bar1 {\n  background-color: #3f51b5;\n  animation-name: indeterminate1;\n  animation-duration: 2s;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n}\n@keyframes indeterminate1 {\n  0% {\n    left: 0%;\n    width: 0%;\n  }\n  50% {\n    left: 25%;\n    width: 75%;\n  }\n  75% {\n    left: 100%;\n    width: 0%;\n  }\n}\n#material .loadingBar {\n  position: relative;\n}\n#material .loadingBar .mdl-progress {\n  position: absolute;\n  top: -9px;\n}\n#material button {\n  margin-top: 10px;\n  margin-left: 10px;\n  background-color: #3f51b5;\n  color: white;\n  border: none;\n  border-radius: 2px;\n  position: relative;\n  height: 42px;\n  padding: 0 16px;\n  display: inline-block;\n  font-size: 14px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0;\n  cursor: pointer;\n  text-decoration: none;\n  text-align: center;\n  line-height: 36px;\n  vertical-align: middle;\n}\n#material #offsetUi {\n  display: flex;\n  justify-content: space-around;\n}\n#material #offsetUi .offsetBox {\n  text-align: center;\n  min-width: 40px;\n  margin-left: 5px;\n  margin-right: 5px;\n}\n#material #offsetUi .offsetBox .top {\n  padding: 5px 10px;\n}\n#material #offsetUi .offsetBox .bottom {\n  padding: 5px 10px;\n}\n#material #offsetUi .offsetBox .bottom.active {\n  border: 1px solid #f43b7a;\n  border-top: 0;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(295);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".site-theme-dark .nextStream img,\n.entry-card .nextStream img,\n.site-theme-dark .resumeStream img,\n.entry-card .resumeStream img {\n  filter: invert(100%);\n}\n.entry-card .mal-sync-stream {\n  position: absolute;\n  max-height: 17px !important;\n  left: 7px;\n  top: -17px;\n  background: rgba(var(--color-overlay), 0.8);\n  border-radius: 100% 100% 0 0;\n}\n.entry-card .mal-sync-stream img {\n  padding: 5px;\n  padding-top: 7px;\n}\n.entry-card .nextStream,\n.entry-card .resumeStream {\n  position: absolute;\n  max-height: 17px !important;\n  right: 7px;\n  top: -15px;\n  margin-right: 0 !important;\n  background: rgba(var(--color-overlay), 0.8);\n  border-radius: 100% 100% 0 0;\n}\n.entry-card .nextStream img,\n.entry-card .resumeStream img {\n  margin: 5px;\n  margin-top: 7px;\n}\n.mal-sync-ep-pre {\n  display: inline-block;\n  width: 0;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(297);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "", "" ]);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_malkiss_vue_vue_type_style_index_0_id_55d18076_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
    __webpack_require__.n(_node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_malkiss_vue_vue_type_style_index_0_id_55d18076_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__).a;
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".Sources[data-v-55d18076] {\n  min-width: 178px;\n}\n.simkltvdetailonlineheadbuttonstream[data-v-55d18076] {\n  width: auto;\n  min-width: auto;\n}\n#malkiss[data-v-55d18076] {\n  position: relative;\n}\n.malsync-page-relation[data-v-55d18076] {\n  display: flex;\n  position: absolute;\n  bottom: -1px;\n  right: -1px;\n}\n.malsync-page-relation > a[data-v-55d18076] {\n  margin-left: 5px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(301);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".nextStream img,\n.resumeStream img {\n  filter: invert(100%);\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(303);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(305);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: black !important;\n}\n#malp span,\nselect,\ninput,\na {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(307);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(309);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #f62ed3;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #f62ed3;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(311);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(313);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp #MalData > * {\n  width: 100%;\n  text-align: left;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.buildDirective = void 0;
    var dompurify_1 = __webpack_require__(88);
    exports.buildDirective = function(config) {
        void 0 === config && (config = {}), function(config) {
            var hookName, hooks = config.hooks;
            for (hookName in hooks) dompurify_1.addHook(hookName, hooks[hookName]);
        }(config);
        var updateComponent = function(el, binding) {
            if (binding.oldValue !== binding.value) {
                var arg = binding.arg, namedConfigurations = config.namedConfigurations;
                namedConfigurations && void 0 !== namedConfigurations[arg] ? el.innerHTML = dompurify_1.sanitize(binding.value, namedConfigurations[arg]) : el.innerHTML = dompurify_1.sanitize(binding.value, config.default);
            }
        };
        return {
            inserted: updateComponent,
            update: updateComponent
        };
    };
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsFileUpload_vue_vue_type_style_index_0_id_4b3e3631_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
    __webpack_require__.n(_node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsFileUpload_vue_vue_type_style_index_0_id_4b3e3631_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__).a;
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".info[data-v-4b3e3631] {\n  height: 0;\n  padding: 0;\n  margin: 0;\n}\n", "" ]);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsShortcut_vue_vue_type_style_index_0_id_29cae25a_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
    __webpack_require__.n(_node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsShortcut_vue_vue_type_style_index_0_id_29cae25a_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__).a;
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".mdl-textfield__input[data-v-29cae25a] {\n  text-align: right;\n}\n.mdl-textfield__input[data-v-29cae25a]:focus {\n  border-bottom: 1px solid green;\n}\n.mdl-textfield__input.rec[data-v-29cae25a] {\n  border-bottom: 1px solid red;\n}\n.mdl-textfield__input.tempRec[data-v-29cae25a] {\n  border-bottom: 1px solid orange;\n}\n.mdl-textfield[data-v-29cae25a] {\n  width: auto;\n  padding: 0;\n}\n.close-icon[data-v-29cae25a] {\n  vertical-align: middle;\n  margin-bottom: 3px;\n  cursor: pointer;\n}\n.mdl-list__item-secondary-action[data-v-29cae25a] {\n  display: flex;\n  align-items: center;\n}\n", "" ]);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsLogin_vue_vue_type_style_index_0_id_50365ef6_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
    __webpack_require__.n(_node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_settingsLogin_vue_vue_type_style_index_0_id_50365ef6_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__).a;
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".material-icons[data-v-50365ef6] {\n  margin-left: 5px;\n}\n.material-icons.wrong[data-v-50365ef6] {\n  color: red;\n  cursor: pointer;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(322);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #694ba1;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #694ba1;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData select option {\n  background-color: white;\n}\nbody.dark #MalData select option {\n  background-color: #1c1b26 !important;\n}\n#malp {\n  margin: 0;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(324);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: transparent !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active .c-playable-thumbnail {\n  border: 4px solid #2e51a2;\n}\n#malp {\n  margin-bottom: 10px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(326);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #b2d1ff !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  background-color: #555;\n  padding: 10px 7px 5px 7px;\n}\n#malp span {\n  color: white;\n}\n#malp select > * {\n  background-color: #555 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(328);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malp {\n  all: initial;\n  font-size: inherit;\n  font-family: inherit;\n  margin-bottom: 8px;\n  min-height: 50px;\n  display: block;\n}\n#malp .info {\n  all: initial !important;\n  font-size: inherit !important;\n  font-family: inherit !important;\n}\n#malp select {\n  appearance: auto;\n}\n#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: white;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: black !important;\n}\n#malp #MalData {\n  justify-content: flex-start !important;\n  align-items: center !important;\n  gap: 10px;\n}\n#malp #MalData select,\n#malp #MalData > * > *:last-child,\n#malp #MalData > * > a {\n  background-color: #f5f6f7 !important;\n  border-radius: 4px;\n  padding: 4px 8px !important;\n}\n#malp #MalData option {\n  background-color: #f5f6f7 !important;\n}\n#malp #MalData > * > span {\n  display: block !important;\n}\n#malp #MalData .info {\n  display: block !important;\n  font-size: 12px !important;\n}\n#malp #MalData #AddMalDiv {\n  margin-left: 10px;\n  display: inline-block !important;\n  font-size: 0;\n}\n#malp #MalData #AddMalDiv #AddMal {\n  font-size: 16px;\n}\n.theme--dark #malp * {\n  color: white !important;\n}\n.theme--dark #malp #MalData {\n  justify-content: flex-start !important;\n  align-items: center !important;\n  gap: 10px;\n}\n.theme--dark #malp #MalData select,\n.theme--dark #malp #MalData > * > *:last-child,\n.theme--dark #malp #MalData > * > a {\n  background-color: #272727 !important;\n  border-radius: 4px;\n  padding: 4px 8px !important;\n}\n.theme--dark #malp #MalData option {\n  background-color: #272727 !important;\n}\n.theme--dark #malp #MalData > * > span {\n  display: block !important;\n}\n.theme--dark #malp #MalData .info {\n  display: block !important;\n  font-size: 12px !important;\n}\n.theme--dark #malp #MalData #AddMalDiv {\n  margin-left: 10px;\n  display: inline-block !important;\n  font-size: 0;\n}\n.theme--dark #malp #MalData #AddMalDiv #AddMal {\n  font-size: 16px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(330);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #ffc119;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #ffc119;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  font-size: 13px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(332);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #bbbbbb;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  color: white;\n}\n#flash-div-top button,\n#flash-div-bottom button,\n#flashinfo-div button {\n  background: none;\n  box-shadow: none;\n  -moz-box-shadow: none;\n  -webkit-box-shadow: none;\n}\n#flash-div-top .undoButton,\n#flash-div-bottom .undoButton,\n#flashinfo-div .undoButton {\n  margin-left: auto;\n  margin-right: auto;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(334);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #0066ff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(336);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-top: 1rem;\n  border-top: 0 solid hsla(0, 0%, 100%, 0.05);\n  border-width: 1px 0;\n  font-size: 14px;\n  padding: 10px 5px 0;\n  padding-top: 1rem;\n}\n#malp select {\n  display: inline-block;\n  width: auto;\n}\n#malp input {\n  display: inline-block;\n}\n.my-float.open-info-popup {\n  height: 100%;\n  width: 100%;\n  margin: 0 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(338);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n#malp {\n  max-width: 700px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(340);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n#malp {\n  max-width: 700px;\n  margin: 0;\n}\n.noApiKey [data-qa-id='moreButton'] {\n  background-color: red;\n}\n#flashinfo-div {\n  z-index: 200000 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(342);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(344);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nsection.main .content-wrapper .theatre .theatre-info {\n  margin-bottom: 1rem;\n}\n#flashinfo-div {\n  z-index: 99999 !important;\n}\n#malp,\n#malTotal,\n#AddMalDiv,\n#AddMal {\n  color: #999 !important;\n}\n#malStatus,\n#malUserRating,\n#malEpisodes {\n  background: transparent !important;\n  color: #d5015b !important;\n}\n#malStatus option,\n#malUserRating option,\n#malEpisodes option {\n  background: black !important;\n  color: #d5015b !important;\n}\n#malRating {\n  color: #d5015b !important;\n}\n.mal-sync-active .episode-label-wrap {\n  background-color: #002966;\n  background-color: #002966ba;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(346);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #694ba1;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #694ba1;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData select option {\n  background-color: white;\n}\nbody.dark #MalData select option {\n  background-color: #1c1b26 !important;\n}\n#malp {\n  margin: 0;\n}\n#malp .info {\n  display: block;\n}\n#malp #malEpisodes {\n  display: inline-block;\n  border: 0;\n  padding: 0;\n  margin-bottom: 4px;\n}\n#malp select {\n  margin-left: -3px !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(348);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  background-color: white;\n}\n.mal-sync-active > div {\n  border: 4px solid #72abff;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(350);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(352);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active {\n  border: 2px solid #002966 !important;\n}\n#malp {\n  margin: 10px;\n  max-width: 1000px;\n}\n#malp select option {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(354);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #a21e2d !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select,\na,\ninput,\nspan {\n  color: #bbb !important;\n}\n#malp select option {\n  color: #bbb !important;\n  background-color: #161616 !important;\n}\n#servers .server ul.episodes li a.active {\n  background-color: #47040c !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(356);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nhtml #malp select option {\n  color: black !important;\n  background-color: white !important;\n}\nhtml.dark #malp select,\nhtml.dark a,\nhtml.dark input,\nhtml.dark span {\n  color: #ccc !important;\n}\nhtml.dark #malp select option {\n  color: #ccc !important;\n  background-color: #111 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(358);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\ndiv#app.dark-theme a,\ndiv#app.dark-theme span,\ndiv#app.dark-theme input,\ndiv#app.dark-theme select {\n  color: white !important;\n}\ndiv#app.dark-theme #malp select option {\n  color: white !important;\n  background-color: black !important;\n}\ndiv#app.light-theme select option {\n  color: black !important;\n  background-color: white !important;\n}\n#malp {\n  margin: 20px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(360);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp a,\nselect,\ninput,\n#malTotal {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(362);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #b2d1ff !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  background-color: #555;\n  padding: 10px 7px 5px 7px;\n}\n#malp span {\n  color: white;\n}\n#malp select > * {\n  background-color: #555 !important;\n}\n#flashinfo-div {\n  z-index: 99999999 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(364);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nbody:not(.dark) .mal-sync-active {\n  background-color: lightblue;\n}\nbody:not(.dark) #malp select option {\n  color: black !important;\n  background-color: #e7dba3 !important;\n}\nbody.dark .mal-sync-active {\n  background-color: blue;\n}\nbody.dark #malp * {\n  color: white !important;\n}\nbody.dark #malp select option {\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(366);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  font-family: arial, helvetica, sans-serif;\n  max-width: 90%;\n  margin-left: 10px;\n  color: white !important;\n}\n#malp a,\n#malp select,\n#malp input,\n#malp span {\n  color: white !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: black !important;\n}\n#MalData > * {\n  white-space: nowrap;\n}\n#malp select,\n#malp input,\n#malp a,\n#malp #malTotalVol,\n#malp #malTotalCha {\n  display: inline-block !important;\n}\n.mal-sync-active .infoept {\n  background-color: #002966;\n}\n.mal-sync-active div {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(368);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-bottom: 10px;\n}\n#malp a:hover {\n  color: #e3474b;\n}\n#MalData > * {\n  white-space: nowrap;\n}\n#malp select,\n#malp input,\n#malp a,\n#malp #malTotalVol,\n#malp #malTotalCha {\n  display: inline-block !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(370);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: black !important;\n}\n#malp a,\nselect,\ninput,\nspan {\n  color: white !important;\n}\n.mal-sync-active {\n  border-top: 2px solid #002966 !important;\n  border-bottom: 2px solid #002966 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(372);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp span,\nselect,\ninput,\na {\n  color: white !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: rgba(0, 41, 102, 0.8) !important;\n}\n#malp {\n  margin: 10px;\n  padding: 4px 10px;\n  background-color: rgba(0, 41, 102, 0.8);\n  border: 2px solid #428bca !important;\n}\n#malp .info {\n  background-color: transparent;\n  border: none;\n}\n.mal-sync-active {\n  background-color: #428bca !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(374);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#flashinfo-div {\n  z-index: 100 !important;\n}\n#malp #malVolumes,\n#malp #malEpisodes,\n#malp span {\n  float: none;\n  display: inline-block;\n  border-radius: 0;\n  margin-top: 0;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(376);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #00bcd4;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n.mal-sync-active {\n  background-color: inherit !important;\n}\n.mal-sync-active .da-video-tbl {\n  border: solid 5px #00bcd4 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(378);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #98cff0;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin: 10px;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(380);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #204279;\n}\n#malp select option {\n  background-color: inherit;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  background: inherit !important;\n}\n#malp span.MalLogin {\n  background: inherit;\n}\n#malp span#MalData {\n  background: inherit;\n}\n#malp {\n  background: inherit;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(382);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-bottom: 10px;\n}\n#malp a:hover {\n  color: #e3474b;\n}\n#MalData > * {\n  white-space: nowrap;\n}\n#malp select,\n#malp input,\n#malp a,\n#malp #malTotalVol,\n#malp #malTotalCha {\n  display: inline-block !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(384);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #428bca !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  color: #ffffff !important;\n  border-top: 1px solid #ffffff;\n  margin-top: 10px;\n  padding-top: 10px;\n}\n#MalData,\n#MalInfo {\n  border-radius: 6px;\n  padding: 5px;\n  background-color: rgba(0, 41, 102, 0.8) !important;\n}\n#MalData {\n  border: 1px blue solid;\n}\n#MalInfo:empty {\n  padding: 0 !important;\n}\n#malStatus,\n#malEpisodes,\n#malUserRating,\n#malVolumes,\n#AddMal {\n  color: wheat !important;\n  font-size: 13px;\n}\n#malTotalVol,\n#malTotalCha,\n#malRating,\n#malTotal,\n#malp .info {\n  font-size: 13px;\n  color: #ffffff !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: rgba(0, 41, 102, 0.8) !important;\n}\n.mal-sync-active {\n  border: 2px solid #428bca !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(386);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  padding: 0 10px;\n  color: #ffffff !important;\n}\n#MalData,\n#MalInfo {\n  border-radius: 6px;\n  padding: 5px;\n  background-color: rgba(0, 41, 102, 0.8) !important;\n}\n#MalData {\n  border: 1px blue solid;\n}\n#MalInfo:empty {\n  padding: 0 !important;\n}\n#malStatus,\n#malEpisodes,\n#malUserRating,\n#malVolumes,\n#AddMal {\n  color: wheat !important;\n  font-size: 13px;\n}\n#malTotalVol,\n#malTotalCha,\n#malRating,\n#malTotal,\n#malp .info {\n  font-size: 13px;\n  color: #ffffff !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: rgba(0, 41, 102, 0.8) !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(388);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n#malp span {\n  background: none !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(390);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(392);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(394);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #c2382b;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: white;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #c2382b;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nbody:not(.dark) .mal-sync-active {\n  border: 2px solid red !important;\n  background-color: inherit !important;\n}\nbody.dark .mal-sync-active {\n  border: 2px solid white !important;\n  background-color: inherit !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(396);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  font-size: 15px;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(398);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nbody:not(.dark-mode) #malp select option {\n  color: black !important;\n  background-color: white !important;\n}\nbody.dark-mode #malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(400);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(402);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  padding-top: 10px;\n}\n#malp select option {\n  color: white !important;\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(404);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData select option {\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(406);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  padding: 0 22px 0;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(408);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(410);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n#flashinfo-div {\n  z-index: 20000 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(412);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: transparent !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin: 10px;\n}\n#MalData {\n  justify-content: space-evenly !important;\n}\n#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n#malp select option {\n  color: white !important;\n  background-color: #222325 !important;\n}\n.mal-sync-active {\n  box-shadow: 0 5px 0 #0183b5;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(414);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(416);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n#flashinfo-div {\n  z-index: 20000 !important;\n}\n#malp span {\n  margin-right: 5px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(418);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nhtml#dark #malp * {\n  color: white !important;\n}\nhtml#dark #malp select option {\n  background-color: black !important;\n}\nhtml:not(#dark) #malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(420);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(422);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(424);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black;\n  background-color: white;\n}\nbody.dark #malp select option {\n  color: white !important;\n  background-color: #1f1f1f !important;\n}\n#malRating,\n#malStatus,\n#malEpisodes,\n#malTotal,\n#malUserRating,\n#AddMal {\n  color: #1291bc !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(426);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(428);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(430);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active * {\n  color: white;\n}\nbody.lightmode #malp select option {\n  color: black !important;\n  background-color: white !important;\n}\nbody.darkmode #malp * {\n  color: white;\n}\nbody.darkmode #malp select option {\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(432);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: white;\n}\n#malp select option {\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(434);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(436);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-bottom: 10px;\n}\n#malp a:hover {\n  color: #e3474b;\n}\n#MalData > * {\n  white-space: nowrap;\n}\n#malp select,\n#malp input,\n#malp a,\n#malp #malTotalVol,\n#malp #malTotalCha {\n  display: inline-block !important;\n}\n#flash-div-top,\n#flashinfo-div {\n  background-color: inherit !important;\n}\n#flash-div-top *,\n#flashinfo-div * {\n  background-color: inherit !important;\n}\n#flash-div-top .flash > *,\n#flashinfo-div .flash > * {\n  background: #323232 !important;\n}\n#malSyncProgress .ms-progress {\n  background-color: #2980b9 !important;\n}\n.mal-sync-active {\n  box-shadow: 0 0 0 1px red !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(438);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  background-color: white;\n}\nbody.darkmode #malp * {\n  color: white;\n}\nbody.darkmode #malp select option {\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(440);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #e4e4e4;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #e4e4e4;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  max-width: 1000px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(442);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #98cff0;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(444);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #fff;\n}\n.mal-sync-active {\n  background-color: rgba(0, 137, 255, 0.3);\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #fff;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.open-info-popup.floatbutton {\n  left: 40px;\n  right: unset;\n  background: rgba(255, 255, 255, 0.7);\n}\n#malp {\n  margin: 10px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(446);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-top: 5px;\n}\n#malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(448);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(450);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #cee1ff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp span {\n  color: inherit;\n}\n#malp select > * {\n  background-color: white !important;\n}\n#malp #MalData {\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n#malp #MalData .info {\n  font-weight: bold;\n}\n#malp #MalData #malStatus,\n#malp #MalData #malUserRating {\n  width: initial !important;\n}\n@media only screen and (max-width: 850px) {\n  #malp .MalLogin {\n    width: 100%;\n  }\n}\n#MalData select option {\n  background-color: rgba(20, 25, 31, 0.98) !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(452);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n@media (max-width: 767px) {\n  #malp {\n    font-size: 14px;\n  }\n}\n#malp span {\n  color: white;\n}\n#malp select > * {\n  background-color: #f8971d !important;\n  color: white;\n}\n#malp #MalData {\n  flex-direction: row;\n  flex-wrap: wrap;\n}\n#malp #MalData .info {\n  font-weight: bold;\n  color: #f8971d;\n  margin-right: 4px;\n}\n#malp #MalData #malStatus,\n#malp #MalData #malUserRating {\n  width: initial !important;\n}\n.mal-sync-active {\n  background-color: #f8971d !important;\n}\n.mal-sync-active * {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(454);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(456);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: white;\n}\n#malp {\n  margin: 0;\n  padding-top: 10px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(458);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(460);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".mal-sync-active {\n  background-color: #00d5ff !important;\n}\nbody.dark .mal-sync-active {\n  color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(462);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  color: white;\n}\nhtml.theme-light #malp * {\n  color: black;\n}\nhtml.theme-light #malp * select option {\n  color: black;\n  background-color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(464);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: transparent !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  padding: 0 30px 0 40px;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n.mal-sync-active {\n  box-shadow: 0 5px 0 #0183b5;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(466);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(468);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-left: 3px;\n  margin-top: 5px;\n}\n#malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(470);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active * {\n  color: white;\n}\nbody.lightmode #malp select option {\n  color: black !important;\n  background-color: white !important;\n}\nbody.darkmode #malp * {\n  color: white;\n}\nbody.darkmode #malp select option {\n  background-color: black !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(472);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#flashinfo-div {\n  z-index: 200000 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(474);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: transparent;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active button,\nbutton.mal-sync-active {\n  background-color: blue !important;\n}\n#malp * {\n  color: white;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(476);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active * {\n  color: white !important;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp select option {\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(478);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(480);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #838aa0;\n}\n.mal-sync-active {\n  background-color: initial;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #838aa0;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  background-color: #1b1b1b;\n  margin-top: 10px;\n  width: 100%;\n  padding: 24px;\n  margin-bottom: 0;\n  height: auto !important;\n}\n#MalData > span > span.info {\n  color: #fff !important;\n}\n#malp select option {\n  color: #838aa0 !important;\n  background-color: #171717 !important;\n}\n#malp {\n  margin-block-end: 0 !important;\n  margin-bottom: 0 !important;\n}\n#MALSyncheading {\n  margin-top: 10px;\n}\n.mal-sync-active {\n  box-shadow: inset 0 0 0 1px #98cff0 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(482);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(484);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(486);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #ccc !important;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #ccc !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData span span.info {\n  font-weight: bold;\n}\n#malp select option {\n  background-color: #333;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(488);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #333 !important;\n}\n.mal-sync-active {\n  background-color: #98cff0;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #333 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData span span.info {\n  font-weight: bold;\n}\n#malp select option {\n  background-color: #dfdfdf;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(490);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #333 !important;\n}\n.mal-sync-active {\n  background-color: #98cff0;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #333 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#MalData span span.info {\n  font-weight: bold;\n}\n#malp select option {\n  background-color: #dfdfdf;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(492);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #98cff0;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(494);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin-top: 10px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(496);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active * {\n  color: var(--light) !important;\n}\n.mal-sync-active:hover {\n  background-color: #002966a6 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(498);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malp input {\n  padding-left: 0;\n  padding-right: 0;\n  text-align: center;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(500);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #b8daff;\n}\n#malp select option {\n  background-color: #ffffff;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  display: inline !important;\n  margin-left: 5px;\n}\n#malp #MalData {\n  display: inline !important;\n}\n#malp .MalLogin {\n  margin-left: 10px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(502);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp > span > span {\n  margin-right: 5px;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n#malp {\n  margin-bottom: 5px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(504);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#flashinfo-div,\n#flash-div-bottom,\n#flash-div-top,\n#malp > span {\n  direction: ltr;\n}\n#MalData {\n  flex-direction: row-reverse;\n}\n.MalLogin option {\n  background: inherit !important;\n}\n.mal-sync-active {\n  background-color: inherit !important;\n}\n.mal-sync-active .video-item {\n  background-color: #002966;\n  border-radius: 5px;\n  padding: 3px 3px 5px 3px;\n}\n.mal-sync-active .video-item .video-subtitle {\n  color: white;\n}\n.mal-sync-active ~ a .video-item {\n  background-color: #429cc6;\n  border-radius: 5px;\n  padding: 3px 3px 5px 3px;\n}\n.mal-sync-active ~ a .video-item .video-subtitle {\n  color: white;\n}\n.translated-box #malp #MalData span.info ~ * {\n  color: #a4a3a3 !important;\n}\n.translated-box #malp #MalData span.info ~ * > * {\n  color: #a4a3a3 !important;\n}\n.mal-sync-active.result-item.episode {\n  background-color: #0056b3 !important;\n  border-radius: 5px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(506);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #000000;\n}\n.mal-sync-active {\n  background-color: #b2d1ff !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #000000;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  background-color: white;\n}\n#malp span {\n  color: #000000;\n}\n#malp select > * {\n  background-color: white !important;\n}\n#malp input[type='password'],\n#malp input[type='text'] {\n  min-width: 50px;\n}\n#malStatus {\n  min-width: 155px;\n  flex-grow: 3;\n}\n#malUserRating {\n  min-width: 140px;\n  flex-grow: 3;\n}\n.MalLogin {\n  display: flex !important;\n  align-items: center;\n}\n.MalLogin span {\n  display: flex !important;\n  align-items: center;\n}\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(508);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp * {\n  display: inline-block;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(510);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #9b9b9b;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #9b9b9b;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active a {\n  background-color: #72abff !important;\n}\n#flashinfo-div {\n  z-index: 100 !important;\n}\n#malp {\n  color: white;\n}\n#malp #malVolumes,\n#malp #malEpisodes {\n  float: none;\n  display: inline-block;\n  border-radius: 0 !important;\n  padding: 0 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(512);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #b8b8b8;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #222;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #b8b8b8;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  padding: 10px 15px;\n}\n#malp {\n  margin: 0;\n}\n#malp span span.info {\n  color: #d9d9d9 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(514);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #98cff0 !important;\n}\n#malp select option {\n  background-color: #fff;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(516);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #98cff0 !important;\n}\n#malp select option {\n  background-color: white;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  border: 2px solid black;\n  border-radius: 10px;\n  margin: 0 10px 10px;\n  padding: unset;\n}\n#malthing #MALSync {\n  padding: 10px 0 10px 10px;\n}\n#malthing #malp {\n  display: inline-block;\n  padding: 10px;\n  margin: 0;\n}\n#malthing .MalLogin {\n  margin-left: 10px;\n}\n#malthing #malStatus,\n#malthing #malTotal,\n#malthing #malEpisodes,\n#malthing #malUserRating,\n#malthing #malRating,\n#malthing #malVolumes,\n#malthing #malTotalVol,\n#malthing #malTotalCha,\n#malthing #AddMal {\n  min-width: 10px !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(518);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.miniMAL-Fullscreen .open-info-popup.floatbutton,\n.miniMAL-hide .open-info-popup.floatbutton,\n.miniMAL-Fullscreen #flashinfo-div,\n.miniMAL-hide #flashinfo-div,\n.miniMAL-Fullscreen #flash-div-bottom,\n.miniMAL-hide #flash-div-bottom,\n.miniMAL-Fullscreen #flash-div-top,\n.miniMAL-hide #flash-div-top {\n  display: none !important;\n}\n#malp {\n  max-width: 700px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(520);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #ccc !important;\n}\n.mal-sync-active {\n  background-color: #694ba1;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #ccc !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: none;\n  display: inline-block;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n#malRating:hover {\n  color: #694ba1 !important;\n}\n#malStatus:hover {\n  color: #694ba1 !important;\n}\n#malUserRating:hover {\n  color: #694ba1 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(522);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #3498db !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\nbody:not(.dark) #malp * {\n  color: black !important;\n}\nbody:not(.dark) #malp option {\n  background-color: white !important;\n}\nbody.dark #malp * {\n  color: white !important;\n}\nbody.dark #malp input {\n  background-color: black !important;\n}\n.mal-sync-active {\n  background-color: #3498db !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(524);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #1292c9;\n}\n#malp select option {\n  background-color: white !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n}\n#malp * {\n  color: inherit;\n}\n.mal-sync-active > div {\n  border: 4px solid #1292c9 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(526);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: transparent;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active div:last-child {\n  border-left: 5px solid #b021b1;\n  background-color: #b021b10f;\n  padding-left: 5px;\n}\n#malp select,\na,\ninput,\nspan {\n  color: #bbb !important;\n}\n#malp {\n  max-width: 800px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(528);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active > * {\n  background-color: var(--v-info-base) !important;\n}\n#malp {\n  max-width: 900px;\n  margin-top: 16px;\n  margin-bottom: 0;\n}\n#malp span {\n  background-color: transparent !important;\n}\n#malp select {\n  -webkit-appearance: auto;\n  -moz-appearance: auto;\n}\n#malp select option {\n  background-color: var(--v-base-base);\n}\n#malp input {\n  border-bottom: 1px solid;\n}\n@media only screen and (max-width: 1150px) {\n  #malp .MalLogin {\n    width: 100%;\n  }\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(530);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(532);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #f70000;\n}\n.mal-sync-active {\n  background-color: #f70000 !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #f70000;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active {\n  color: white !important;\n}\n#MalData select option {\n  background-color: #1c1b26 !important;\n}\n#malp {\n  margin: 0;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(534);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".MalLogin:nth-child(3),\n.MalLogin:nth-child(4) {\n  width: 115px;\n}\n.MalLogin:nth-child(3) span:nth-child(2),\n.MalLogin:nth-child(4) span:nth-child(2) {\n  line-height: 2.8;\n}\n.MalLogin:nth-child(3) span:nth-child(2) input,\n.MalLogin:nth-child(4) span:nth-child(2) input {\n  width: 70px !important;\n  float: left;\n  margin-right: 5px;\n}\n.MalLogin .info {\n  width: 100%;\n  display: block;\n}\n.mal-sync-active {\n  border: 3px solid blue !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(536);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp span,\nselect,\ninput,\na {\n  color: white !important;\n}\n#malp select option {\n  color: white !important;\n  background-color: black !important;\n}\n#malp {\n  padding: 4px 10px;\n  border: 2px solid #667ac1 !important;\n  background-color: #23262e;\n}\n#malp .info {\n  background-color: transparent;\n  border: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(538);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #b8b8b8;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #222;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #b8b8b8;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  padding: 10px 15px;\n}\n#malp {\n  margin: 0;\n}\n#malp span span.info {\n  color: #d9d9d9 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(540);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #ffffff;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #ffffff;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp span,\nselect,\ninput,\na {\n  color: #ffffff !important;\n}\n#malp select option {\n  color: #ffffff !important;\n  background-color: var(--fs-episodes-series-desc-background) !important;\n}\n#malp {\n  width: 100%;\n  padding: 4px 10px;\n  border: 2px solid var(--fs-episodes-border-color) !important;\n  border-radius: 11px;\n  background-color: var(--fs-episodes-series-desc-background) !important;\n}\n#malp .info {\n  background-color: transparent;\n  border: none;\n}\n.mal-sync-active {\n  background-color: var(--fs-malsync-watched-bg) !important;\n  border-color: var(--fs-malsync-watched) !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(542);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white !important;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  padding: 1em 1.3em;\n}\n.open-info-popup.floatbutton {\n  bottom: 100px !important;\n}\n.mal-sync-active {\n  background-color: transparent;\n  border-left: 5px solid #002966;\n  padding-left: 5px;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(544);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: initial;\n}\n#malp select option {\n  background-color: inherit;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  background-color: inherit;\n  margin: 0;\n}\n#malp #malStatus,\n#malp #malTotal,\n#malp #malEpisodes,\n#malp #malUserRating,\n#malp #malRating,\n#malp #malVolumes,\n#malp #malTotalVol,\n#malp #malTotalCha,\n#malp #AddMal {\n  background-color: inherit !important;\n}\n#malp span#MalData {\n  background-color: inherit;\n}\n#malp span.MalLogin {\n  background-color: inherit;\n}\n.mal-sync-active {\n  box-shadow: inset 0 0 0 2px #98cff0 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(546);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(548);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active * {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(550);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp .MalLogin span:last-child,\n#malp .MalLogin select:last-child {\n  color: white;\n}\n#MalData .info {\n  color: white;\n}\n#MalData select option {\n  background-color: #121420 !important;\n}\n.mal-sync-active {\n  background-color: #cc2a52 !important;\n}\n#malStatus,\n#malUserRating,\n#malRating,\n#AddMal {\n  color: white;\n}\n.rounded {\n  border-radius: 4px;\n}\n#malp {\n  margin: 0;\n}\n#malp .MalLogin span:last-child,\n#malp .MalLogin select:last-child {\n  margin-left: 2rem;\n}\n#malp select > * {\n  background-color: white !important;\n}\n#malp #MalData {\n  flex-flow: column;\n  flex-direction: row !important;\n}\n#malp #MalData .info {\n  font-weight: bold;\n  float: left;\n  clear: left;\n  text-align: right;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n#malp #MalData #malStatus,\n#malp #MalData #malUserRating,\n#malp #MalData #malRating {\n  width: initial !important;\n  margin-left: 2rem;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(552);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: inherit;\n}\n.mal-sync-active {\n  background-color: #cee1ff;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: inherit;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp {\n  margin: 0;\n}\n#malp span {\n  color: inherit;\n}\n#malp select > * {\n  background-color: white !important;\n}\n.strong {\n  font-weight: bold;\n}\n@media only screen and (max-width: 1440px) {\n  #malp .MalLogin {\n    width: 100%;\n  }\n}\n#MalData select option {\n  background-color: white !important;\n}\n.mal-sync-active {\n  background-color: #82af42;\n}\n.mal-sync-active * {\n  color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(554);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  background-color: var(--color-000) !important;\n}\n#malp {\n  margin-top: 2.4rem;\n}\n#malp * {\n  color: var(--color-900) !important;\n}\n.mal-sync-active * {\n  color: white !important;\n  background-color: #002966 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(556);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(558);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(560);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(562);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(564);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #b8b8b8;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n#malp select option {\n  background-color: #222;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #b8b8b8;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  padding: 10px 15px;\n}\n#malp {\n  margin: 0;\n}\n#malp span span.info {\n  color: #d9d9d9 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(566);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: #888 !important;\n}\n.mal-sync-active {\n  background-color: #0e1d35;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: #888 !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malthing {\n  margin-bottom: 38px;\n}\n#malp * {\n  float: left;\n  margin-right: 5px;\n}\n#malp #MalInfo {\n  float: none;\n  display: flex;\n}\n#malp #MalData {\n  float: none;\n}\n#malp select option {\n  background-color: #fff !important;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  line-height: normal;\n  inline-size: auto;\n}\n#malp #malTotalVol,\n#malp #malTotalCha {\n  float: none;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(568);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n.mal-sync-active {\n  background-color: #002966 !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(570);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: lightblue !important;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  color: black !important;\n  background-color: white !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(572);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: white !important;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: white !important;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(574);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "#malStatus,\n#malTotal,\n#malEpisodes,\n#malUserRating,\n#malRating,\n#malVolumes,\n#malTotalVol,\n#malTotalCha,\n#AddMal {\n  color: black;\n}\n.mal-sync-active {\n  background-color: #002966;\n}\n#malp select option {\n  background-color: #111111;\n}\n#malp #malStatus,\n#malp #malUserRating,\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  font-size: inherit;\n  font-family: inherit;\n  background: transparent;\n  border-color: grey;\n  text-decoration: none;\n  outline: medium none;\n  border-width: 0;\n  height: auto;\n  padding: 0;\n  margin: 0;\n  line-height: 1;\n}\n#malp #malEpisodes,\n#malp #malVolumes,\n#malp #malEpisodes {\n  text-align: center;\n  border-bottom-width: 1px;\n}\n#malp #malEpisodes:focus,\n#malp #malVolumes:focus,\n#malp #malEpisodes:focus {\n  border-color: black;\n}\n#malSyncProgress.ms-loading {\n  height: 4px;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  background-color: #ddd;\n}\n#malSyncProgress.ms-loading::before {\n  display: block;\n  position: absolute;\n  content: '';\n  left: -200px;\n  width: 200px;\n  height: 4px;\n  background-color: #2980b9;\n  animation: loading 2s linear infinite;\n}\n@keyframes loading {\n  from {\n    left: -200px;\n    width: 30%;\n  }\n  50% {\n    width: 30%;\n  }\n  70% {\n    width: 70%;\n  }\n  80% {\n    left: 50%;\n  }\n  95% {\n    left: 120%;\n  }\n  to {\n    left: 100%;\n  }\n}\n#malSyncProgress.ms-done .ms-progress {\n  width: 100% !important;\n  background-color: #ff4081 !important;\n  transition: background-color 1s !important;\n}\n#malp select option {\n  background-color: #fff;\n}\n", "" ]);
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_customDomains_vue_vue_type_style_index_0_id_40f53714_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);
    __webpack_require__.n(_node_modules_to_string_loader_src_to_string_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_less_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_customDomains_vue_vue_type_style_index_0_id_40f53714_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__).a;
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, ".mdl-textfield__input[data-v-40f53714]:focus {\n  border-bottom: 1px solid green;\n}\n.mdl-textfield__input.error[data-v-40f53714] {\n  border-bottom: 1px solid red;\n}\n.mdl-textfield__input.tempRec[data-v-40f53714] {\n  border-bottom: 1px solid orange;\n}\n", "" ]);
}, function(module, exports, __webpack_require__) {
    var result = __webpack_require__(578);
    module.exports = "string" == typeof result ? result : result.toString();
}, function(module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(3)(!1)).push([ module.i, "body::-webkit-scrollbar {\n  display: none !important;\n}\n#material .mdl-card__supporting-text {\n  width: initial;\n}\n.mdl-layout__header .mdl-textfield__label::after {\n  background-color: red !important;\n}\n#fixed-tab-1 .loading,\n#fixed-tab-1 .loaded {\n  -o-transition: opacity 0.3s linear;\n  -moz-transition: opacity 0.3s linear;\n  -webkit-transition: opacity 0.3s linear;\n  transition: opacity 0.3s linear;\n}\n#fixed-tab-1 .loading {\n  opacity: 0.5;\n}\n#fixed-tab-1 .loaded {\n  opacity: 1;\n}\n@media (min-width: 840px) {\n  #fixed-tab-1 .stats-block > ul {\n    justify-content: left !important;\n  }\n}\n.alternative-list .mdl-list {\n  max-width: 100%;\n  margin: 0;\n  padding: 0;\n}\n.alternative-list .mdl-list__item {\n  height: auto;\n}\n.alternative-list .mdl-list__item-primary-content {\n  height: auto !important;\n}\n.alternative-list .mdl-list__item-primary-content a {\n  display: inline-block;\n}\n.alternative-list .mdl-list__item-text-body {\n  height: auto !important;\n}\n.coverinfo .mdl-chip {\n  height: auto;\n}\n.coverinfo .mdl-chip .mdl-chip__text {\n  white-space: normal;\n  line-height: 24px;\n}\n.ep-increment {\n  vertical-align: middle;\n  font-size: 16px;\n  background-color: #3f51b5;\n  border-radius: 50%;\n  margin-left: 5px;\n  margin-bottom: 3px;\n  cursor: pointer;\n  user-select: none;\n}\n.mdl-layout__container {\n  background-color: white;\n}\n.mdl-layout {\n  max-width: 1385px;\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  background-color: #f9f9f9;\n}\n.mdl-layout__content {\n  scrollbar-width: thin;\n}\n.mdl-layout__content::-webkit-scrollbar {\n  width: 10px !important;\n  background-color: #f5f5f5;\n}\n.mdl-layout__content::-webkit-scrollbar-thumb {\n  background-color: #c1c1c1 !important;\n}\na {\n  text-decoration: none;\n}\n.mdl-layout__tab-panel a:hover {\n  text-decoration: underline;\n}\n.bg-cell {\n  background-color: #fefefe;\n}\n#material.simple-header .mdl-layout__header .mdl-layout__tab-bar-container {\n  display: none;\n}\n.newEp {\n  position: absolute;\n  background-color: #dedede;\n  height: 25px;\n  width: 29px;\n  top: 3px;\n  right: -4px;\n  background-repeat: no-repeat;\n  background-position: 4px 3px;\n  background-image: url(https://github.com/google/material-design-icons/blob/master/social/1x_web/ic_notifications_none_black_18dp.png?raw=true);\n}\n.searchItem {\n  text-decoration: none !important;\n  color: black;\n}\n#material .mdl-layout__drawer-button {\n  background-color: transparent;\n}\n#material .mdl-layout__drawer-button:hover {\n  background-color: rgba(158, 158, 158, 0.2);\n}\n#material .mdl-layout__tab-bar {\n  background-color: transparent;\n}\n#material .mdl-layout__tab {\n  cursor: pointer;\n}\n#material.settings-only .mdl-layout__header .mdl-layout__tab-bar-container,\n#material.pop-over .mdl-layout__header .mdl-layout__tab-bar-container {\n  display: none;\n}\n#material.settings-only #fixed-tab-5.mdl-layout__tab-panel {\n  display: block !important;\n}\n#characterList .loading {\n  background-color: #cdcdcd;\n  min-height: 196px;\n}\n.malImage.loading {\n  background-color: #cdcdcd;\n  padding-bottom: 133.33%;\n}\n[mode='window'] body {\n  overflow: hidden;\n}\n#Mal-Sync-Popup #material-fullscreen {\n  display: none !important;\n}\n#Mal-Sync-Popup .settings-only #book.open .bookIcon {\n  display: none;\n}\n#Mal-Sync-Popup .settings-only #book.open .settingsIcon {\n  display: block !important;\n}\n#material a.button_edit {\n  text-decoration: none;\n  background-color: #efefef;\n  border-bottom: 1px solid #ebebeb;\n  font-size: 10px;\n  line-height: 1em;\n  margin: 0;\n  opacity: 1;\n  padding: 2px 4px;\n  -webkit-transition-duration: 0.3s;\n  transition-duration: 0.3s;\n  -webkit-transition-property: all;\n  transition-property: all;\n  -webkit-transition-timing-function: ease-in-out;\n  transition-timing-function: ease-in-out;\n  display: inline-block;\n  font-family: Avenir, lucida grande, tahoma, verdana, arial, sans-serif;\n  height: 9px;\n}\n#material a.button_edit.reading,\n#material a.button_edit.watching {\n  background-color: #2db039;\n  color: #fff;\n}\n#material a.button_edit.reading:hover,\n#material a.button_edit.watching:hover {\n  opacity: 0.7;\n}\n#material a.button_edit.plantoread,\n#material a.button_edit.plantowatch {\n  background-color: #c3c3c3;\n  color: #fff;\n}\n#material a.button_edit.plantoread:hover,\n#material a.button_edit.plantowatch:hover {\n  opacity: 0.7;\n}\n#material a.button_edit.completed {\n  background-color: #26448f;\n  color: #fff;\n}\n#material a.button_edit.completed:hover {\n  opacity: 0.7;\n}\n#material a.button_edit.on-hold {\n  background-color: #f1c83e;\n  color: #fff;\n}\n#material a.button_edit.dropped {\n  background-color: #a12f31;\n  color: #fff;\n}\n#material a.button_edit.dropped:hover {\n  opacity: 0.7;\n}\n#material #contributer {\n  padding: 15px;\n  padding-bottom: 0;\n}\n#material #contributer .group {\n  display: none;\n  text-transform: uppercase;\n  font-size: 12px;\n  padding: 5px 0;\n  font-weight: bold;\n  color: #707070;\n  opacity: 0;\n  -webkit-transition: 1s;\n  -o-transition: 1s;\n  transition: 1s;\n}\n#material #contributer .user {\n  height: 40px;\n  display: inline-block;\n  white-space: nowrap;\n  overflow: hidden;\n}\n#material #contributer .user .image {\n  position: relative;\n  vertical-align: middle !important;\n  display: inline-block;\n  height: 32px;\n  width: 32px;\n  margin-right: 10px;\n  border-radius: 50%;\n  overflow: hidden;\n  border: 1px solid #e0e0e0;\n}\n#material #contributer .user .image .gif {\n  position: absolute;\n  display: none;\n}\n#material #contributer .user .text {\n  vertical-align: middle !important;\n  display: none;\n  line-height: 100%;\n}\n#material #contributer .user.pop .image {\n  background-color: #3f51b5;\n}\n#material #contributer .discord {\n  display: none;\n}\n#material #contributer .inline-block {\n  display: inline-block;\n}\n#material #contributer.open {\n  padding-bottom: 15px;\n}\n#material #contributer.open .group {\n  opacity: 1;\n  display: block;\n}\n#material #contributer.open .user {\n  display: block;\n}\n#material #contributer.open .user .image .gif {\n  display: block;\n}\n#material #contributer.open .user .text {\n  display: inline-block;\n}\n#material #contributer.open .user.pop {\n  display: none;\n}\n#material #contributer.open .discord {\n  display: block;\n}\n#material #contributer.open .inline-block {\n  display: block;\n}\n.pr-bar .bar-tab {\n  position: absolute;\n  right: -12px;\n  bottom: -22px;\n  color: inherit;\n}\n#offsetUi {\n  display: flex;\n  justify-content: space-around;\n}\n#offsetUi .offsetBox {\n  text-align: center;\n  min-width: 40px;\n}\n#offsetUi .offsetBox .top {\n  padding: 5px 10px;\n}\n#offsetUi .offsetBox .bottom {\n  padding: 5px 10px;\n}\n#malList .mdl-menu__container {\n  margin-right: 16px;\n}\n#malList .mdl-menu__container .mdl-menu__item.active {\n  color: #3f51b5;\n}\ntable#malList {\n  margin-bottom: 50px;\n}\ntable#malList tr .imageTd .loaded::after {\n  content: '';\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.67) 100%);\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\ntable#malList tr:hover .imageTd {\n  overflow: visible !important;\n  z-index: 2;\n  left: -8px !important;\n  right: -8px !important;\n}\ntable#malList tr:hover .imageTd .loaded::after {\n  display: none;\n}\n.flagIcon {\n  height: 30px;\n  width: 40px;\n  margin: 5px;\n  background-color: #cdcdcd;\n  position: relative;\n  display: inline-block;\n  overflow: hidden;\n}\n.flagIcon .flagCountry {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  text-align: center;\n}\n.flagIcon .flagText {\n  position: absolute;\n  top: auto;\n  left: 0;\n  padding: 3px;\n  background-color: #3f51b5;\n  font-size: 10px;\n  bottom: 0;\n  line-height: 1;\n  color: white;\n}\n.flagIcon .flagflag {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n}\n.mdl-chip__contact {\n  width: auto;\n  min-width: 22px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n#quicklinkedit .quicklinks {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n  gap: 15px;\n}\n#quicklinkedit .quicklinks .quicklink {\n  opacity: 0.5;\n  font-size: 13px;\n  cursor: pointer;\n}\n#quicklinkedit .quicklinks .quicklink.active {\n  opacity: 1;\n}\n#quicklinkedit .quicklinks .quicklink.home {\n  background-color: #ff6767;\n}\n#quicklinkedit .quicklinks .quicklink.search {\n  background-color: #eeee9c;\n}\n#quicklinkedit .quicklinks .quicklink.database {\n  background-color: #90e963;\n}\n#quicklinkedit .quicklinks .quicklink.custom {\n  background-color: white;\n}\n#quicklinkedit .darkbox {\n  background-color: #0000002b;\n  padding: 5px;\n}\n#quicklinkedit td {\n  padding: 7px 2px;\n}\n#quicklinkoverview {\n  cursor: pointer;\n}\n#quicklinkoverview .quicklinks {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n  gap: 5px;\n}\n#quicklinkoverview .quicklinks .quicklink {\n  font-size: 13px;\n  background-color: #dedede40;\n}\n.backbutton-settings {\n  padding: 15px 20px;\n  display: flex;\n  align-items: center;\n  font-size: 20px;\n  cursor: pointer;\n}\n.backbutton-settings .material-icons {\n  margin-right: 10px;\n}\n#material.dark p,\n#material.serial p {\n  color: #ffffff !important;\n}\n#material.dark .mdl-layout__header,\n#material.serial .mdl-layout__header {\n  background-color: #212121;\n}\n#material.dark .mdl-layout__container,\n#material.serial .mdl-layout__container {\n  background-color: #2b2b2b;\n}\n#material.dark .mdl-layout__content,\n#material.serial .mdl-layout__content {\n  background-color: #212121;\n}\n#material.dark .mdl-layout__content a,\n#material.serial .mdl-layout__content a {\n  color: #f43b7a;\n}\n#material.dark #malList .mdl-cell div.mdl-shadow--2dp,\n#material.serial #malList .mdl-cell div.mdl-shadow--2dp {\n  background-color: #3b3b3be6 !important;\n}\n#material.dark #malList .mdl-cell div span,\n#material.serial #malList .mdl-cell div span {\n  background-color: #3b3b3be6 !important;\n}\n#material.dark #malList .mdl-cell div span a,\n#material.serial #malList .mdl-cell div span a {\n  color: #ffffff !important;\n}\n#material.dark #malList .mdl-menu__container .mdl-menu,\n#material.serial #malList .mdl-menu__container .mdl-menu {\n  background-color: #3b3b3b;\n  color: white;\n}\n#material.dark #malList .mdl-menu__container .mdl-menu .mdl-menu__item,\n#material.serial #malList .mdl-menu__container .mdl-menu .mdl-menu__item {\n  color: white;\n}\n#material.dark #malList .mdl-menu__container .mdl-menu .mdl-menu__item:active,\n#material.serial #malList .mdl-menu__container .mdl-menu .mdl-menu__item:active,\n#material.dark #malList .mdl-menu__container .mdl-menu .mdl-menu__item:hover,\n#material.serial #malList .mdl-menu__container .mdl-menu .mdl-menu__item:hover {\n  background-color: #212121;\n}\n#material.dark #malList .mdl-menu__container .mdl-menu .mdl-menu__item.active,\n#material.serial #malList .mdl-menu__container .mdl-menu .mdl-menu__item.active {\n  color: #f43b7a;\n}\n#material.dark #malReviews .lightLink,\n#material.serial #malReviews .lightLink {\n  color: white;\n}\n#material.dark .bg-cell,\n#material.serial .bg-cell {\n  background-color: #3b3b3b;\n}\n#material.dark .bg-cell .mdl-chip__text,\n#material.serial .bg-cell .mdl-chip__text {\n  background-color: #dedede !important;\n}\n#material.dark .bg-cell .mdl-card__supporting-text,\n#material.serial .bg-cell .mdl-card__supporting-text {\n  color: #ffffff !important;\n}\n#material.dark .bg-cell .mdl-card__title-text,\n#material.serial .bg-cell .mdl-card__title-text {\n  color: #ffffff !important;\n}\n#material.dark .bg-cell.mdl-data-table,\n#material.serial .bg-cell.mdl-data-table {\n  color: #ffffff !important;\n}\n#material.dark .bg-cell.mdl-data-table tbody tr:hover,\n#material.serial .bg-cell.mdl-data-table tbody tr:hover {\n  background-color: #393939;\n}\n#material.dark .bg-cell.mdl-data-table .mdl-progress,\n#material.serial .bg-cell.mdl-data-table .mdl-progress {\n  opacity: 1 !important;\n}\n#material.dark .bg-cell li,\n#material.serial .bg-cell li {\n  color: #ffffff !important;\n}\n#material.dark .bg-cell li span,\n#material.serial .bg-cell li span {\n  color: #ffffff !important;\n}\n#material.dark .bg-cell div.data.title,\n#material.serial .bg-cell div.data.title {\n  background-color: #3b3b3b !important;\n}\n#material.dark div.mdl-grid,\n#material.serial div.mdl-grid {\n  color: #ffffff;\n}\n#material.dark div.mdl-grid #updateCheckAgo,\n#material.serial div.mdl-grid #updateCheckAgo {\n  color: #ffffff !important;\n}\n#material.dark #malNotOnMal,\n#material.serial #malNotOnMal {\n  background-color: #ffffff;\n}\n#material.dark .mdl-textfield__input,\n#material.serial .mdl-textfield__input {\n  background-color: #3b3b3b !important;\n}\n#material.dark .mdl-layout__content::-webkit-scrollbar,\n#material.serial .mdl-layout__content::-webkit-scrollbar {\n  background-color: #3b3b3b;\n}\n#material.dark .mdl-layout__content::-webkit-scrollbar-thumb,\n#material.serial .mdl-layout__content::-webkit-scrollbar-thumb {\n  background-color: #ffffff !important;\n}\n#material.dark .mdl-layout__content,\n#material.serial .mdl-layout__content {\n  scrollbar-color: #ffffff #3b3b3b;\n}\n#material.dark .mdl-progress .bufferbar,\n#material.serial .mdl-progress .bufferbar {\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), linear-gradient(to right, #4c61d6, #4c61d6);\n}\n#material.dark .mdl-progress .auxbar,\n#material.serial .mdl-progress .auxbar {\n  visibility: hidden !important;\n}\n#material.dark .mdl-switch.is-checked .mdl-switch__thumb,\n#material.serial .mdl-switch.is-checked .mdl-switch__thumb {\n  background-color: #4c61d6;\n}\n#material.dark .mdl-switch.is-checked .mdl-switch__track,\n#material.serial .mdl-switch.is-checked .mdl-switch__track {\n  background-color: #6e7fdd;\n}\n#material.dark .mdl-layout.is-upgraded .mdl-layout__tab.is-active::after,\n#material.serial .mdl-layout.is-upgraded .mdl-layout__tab.is-active::after {\n  background-color: #f43b7a !important;\n}\n#material.dark .mdl-layout__content a:not(table .mdl-data-table),\n#material.serial .mdl-layout__content a:not(table .mdl-data-table) {\n  color: #f43b7a !important;\n}\n#material.dark .mdl-textfield__label,\n#material.serial .mdl-textfield__label {\n  color: #f43b7a;\n}\n#material.dark .mdl-textfield,\n#material.serial .mdl-textfield {\n  color: #ffffff;\n}\n#material.dark .mdl-textfield .mdl-textfield__label,\n#material.serial .mdl-textfield .mdl-textfield__label {\n  color: #f43b7a !important;\n}\n#material.dark .mdl-textfield .mdl-textfield__label::after,\n#material.serial .mdl-textfield .mdl-textfield__label::after {\n  background-color: #f43b7a;\n}\n#material.dark #characterList .loading,\n#material.serial #characterList .loading {\n  background-color: #212121;\n}\n#material.dark .malImage.loading,\n#material.serial .malImage.loading {\n  background-color: #212121;\n}\n#material.dark .searchItem,\n#material.serial .searchItem {\n  color: #ffffff;\n}\n#material.dark .discord div:not(.loaded),\n#material.serial .discord div:not(.loaded) {\n  background-image: -webkit-linear-gradient(top, #3b3b3b 0%, #738bd7 74%) !important;\n}\n#material.dark div .history h3,\n#material.serial div .history h3 {\n  color: #ffffff;\n}\n#material.dark div .history a,\n#material.serial div .history a {\n  color: #f43b7a !important;\n}\n@keyframes flicker {\n  0% {\n    opacity: 0.27861;\n  }\n  5% {\n    opacity: 0.34769;\n  }\n  10% {\n    opacity: 0.23604;\n  }\n  15% {\n    opacity: 0.90626;\n  }\n  20% {\n    opacity: 0.18128;\n  }\n  25% {\n    opacity: 0.83891;\n  }\n  30% {\n    opacity: 0.65583;\n  }\n  35% {\n    opacity: 0.67807;\n  }\n  40% {\n    opacity: 0.26559;\n  }\n  45% {\n    opacity: 0.84693;\n  }\n  50% {\n    opacity: 0.96019;\n  }\n  55% {\n    opacity: 0.08594;\n  }\n  60% {\n    opacity: 0.20313;\n  }\n  65% {\n    opacity: 0.71988;\n  }\n  70% {\n    opacity: 0.53455;\n  }\n  75% {\n    opacity: 0.37288;\n  }\n  80% {\n    opacity: 0.71428;\n  }\n  85% {\n    opacity: 0.70419;\n  }\n  90% {\n    opacity: 0.7003;\n  }\n  95% {\n    opacity: 0.36108;\n  }\n  100% {\n    opacity: 0.24387;\n  }\n}\n@keyframes fadein {\n  0% {\n    box-shadow: 0 0 2px 0 #bddbe040;\n    filter: brightness(30);\n    opacity: 0.1;\n  }\n  2% {\n    -webkit-filter: contrast(0) brightness(0);\n    filter: contrast(0) brightness(0);\n    opacity: 0;\n  }\n  40% {\n    filter: contrast(1) brightness(1.1) saturate(1.1);\n    opacity: 1;\n  }\n  100% {\n    filter: contrast(1) brightness(1) saturate(1);\n    opacity: 1;\n  }\n}\n#material.serial .mdl-layout__header {\n  box-shadow: 0 0 10px 0 #bddbe04f;\n}\n#material.serial .bg-cell,\n#material.serial .bookEntry,\n#material.serial #malList select {\n  position: relative;\n  border-radius: 7px;\n  overflow: hidden;\n  box-shadow: 0 0 10px 0 #bddbe040;\n  animation: fadein 2s;\n}\n#material.serial .bg-cell::after,\n#material.serial .bookEntry::after,\n#material.serial #malList select::after {\n  content: ' ';\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background: rgba(18, 16, 16, 0.03);\n  opacity: 0;\n  z-index: 99;\n  pointer-events: none;\n  animation: flicker 1.15s infinite;\n}\n#material.serial .mdl-layout {\n  filter: contrast(130%);\n}\n#material.serial .mdl-layout__content::-webkit-scrollbar-thumb {\n  box-shadow: 0 0 31px 24px #feffff;\n}\n#material.serial .mdl-layout__content::-webkit-scrollbar {\n  background-color: transparent !important;\n}\n#material.serial img {\n  filter: contrast(130%);\n  background-blend-mode: screen, difference, lighten;\n}\n#material.serial .mdl-layout__header {\n  position: relative;\n  border-radius: 0;\n}\n#material.serial .mdl-layout__header::before {\n  filter: saturate(2);\n  content: '';\n  position: absolute;\n  background-image: url(https://i.imgur.com/U1DCaLV.gif);\n  background-size: cover;\n  top: -209px;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n#material.serial::after {\n  content: ' ';\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.5) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.12), rgba(0, 255, 0, 0.04), rgba(0, 0, 255, 0.12));\n  z-index: 99;\n  background-size: 100% 3px, 3px 100%;\n  pointer-events: none;\n  opacity: 0.4;\n}\n@keyframes turn-off {\n  100% {\n    transform: scale(1, 1) translate3d(0, 0, 0);\n    -webkit-filter: brightness(1);\n    filter: brightness(1);\n    opacity: 1;\n  }\n  80% {\n    transform: scale(1, 1.3) translate3d(0, 0, 0);\n    -webkit-filter: brightness(1);\n    filter: brightness(1);\n    opacity: 1;\n  }\n  40% {\n    transform: scale(1.3, 0.001) translate3d(0, 0, 0);\n    -webkit-filter: brightness(10);\n    filter: brightness(10);\n  }\n  0% {\n    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n    transform: scale(0, 0.0001) translate3d(0, 0, 0);\n    -webkit-filter: brightness(50);\n    filter: brightness(50);\n  }\n}\n#cr #material.serial .mdl-layout__container {\n  background-color: black;\n}\n#cr #material.serial .mdl-layout__container .mdl-layout {\n  animation: turn-off 1s linear;\n  animation-fill-mode: backwards;\n}\n", "" ]);
} ]);