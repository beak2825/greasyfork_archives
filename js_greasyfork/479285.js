// ==UserScript==
// @name         自动答题脚本
// @namespace    https://greasyfork.org/zh-CN/users/1213198-cfaha
// @version      1.0
// @description  自动回答题目
// @author       Cfaha
// @match        *://*.wjx.top/*
// @match        *://*.wjx.cn/*
// @grant        none
// @downloadURL https://update.greasyfork.org/scripts/479285/%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98%E8%84%9A%E6%9C%AC.user.js
// @updateURL https://update.greasyfork.org/scripts/479285/%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98%E8%84%9A%E6%9C%AC.meta.js
// ==/UserScript==
(function() {
    'use strict';

    // 定义题目和正确答案的映射
    const rightAnswers = {
        "软件架构是从什么上说明一套软件系统的组成与特性":"宏观",
        "什么是软件架构设计中所有设计的依据":"业务需求",
        "从业务需求到技术实现都必须要关注的架构师是什么类型的架构师":"业务需求",
        "站在更高的层面来为企业规划未来的技术路线和发展方向是什么类型的架构师":"企业架构师",
        "以下哪个不属于5视图法架构设计的内容：":"企业架构",
        "在5视图法架构设计中，将业务需求落实成数据结构的是哪个架构设计：":"数据架构",
        "在5视图法架构设计中，根据业务对系统进行整体的规划，是哪个架构设计：":"开发架构",
        "在5视图法架构设计中，对业务需求中的非功能性需求进行分析，是哪个架构设计：":"运行架构",
        "逻辑架构的设计包括哪些内容：【多选题】":"['用例模型设计', '界面原型设计', '领域模型设计']",
        "开发架构的设计包括哪些内容：【多选题】":"['系统规划', '技术选型']",
        "以下哪个在用例图中可以不用绘制：":"系统边界",
        "以下哪些可以是用例模型的参与者：【多选题】":"['用户角色', '自动触发的时间', '外部系统']",
        "在用例描述中，用例可以分为哪些类型：【多选题】":"['业务操作', '查询报表', '展示图表']",
        "用例描述中的事件流可以分为哪些部分：【多选题】":"['基流', '分支流', '异常流']",
        "关于架构师与技术大牛不正确的是：":"只要成为技术大牛就能做好一个架构师",
        "关于架构师的本质正确的描述是：【多选题】":"['架构师要能够将业务转换为技术', '架构师能合理运用技术支撑业务']",
        "当我们发现用户需求不可行时，应当采用的步骤不包含以下哪个：":"站在全局的角度去规划系统架构",
        "贫血模型和充血模型的差别在于：【多选题】":"['贫血模型的业务是在BUS层的Service中实现的', '充血模型的业务是在领域对象中实现的']",
        "领域驱动设计的思想是如何将真实世界与软件世界对应：【多选题】":"['真实世界有什么事物，软件世界就有什么对象', '真实世界的事物有什么行为，软件世界的对象就有什么方法', '真实世界的事物间有什么关系，软件世界的对象间就有什么关联']",
        "按照领域驱动的思想，当需求变更到来时应当：":"根据需求先在领域模式中进行设计",
        "单一职责原则中对于“职责”正确的描述：":"一个职责是软件变化的一个原因",
        "领域驱动设计在什么场景中最能发挥作用：":"维护老项目",
        "事件风暴中的“风暴”指的是：":"头脑风暴",
        "关于“一个职责就是软件变化的一个原因”正确理解的是：【多选题】":"['（全部）']",
        "关于“识别领域事件”理解正确的是：【多选题】":"['领域事件是那些过去已经发生的历史事件', '只有那些非常重要', '需要记录下来的才是领域事件']",
        "在事件风暴中，关于“命令”与“触发者”描述正确的是：【多选题】":"['每个领域事件可以有多个命令', '每个命令只能有一个触发者']",
        "在领域建模时，关于“聚合”关系描述不正确的是：":"领域对象之间的一对多关系就是聚合关系",
        "“订单”与“订单明细”是整体与部分的关系，在领域建模时应当设计成：":"聚合关系",
        "一个“订单”只能有一次“付款”，在领域建模时应当设计成：":"一对一关系",
        "一个“订单”只能有一个“用户”，但一个“用户”可以下多个“订单”，在领域建模时应当设计成：":"多对一关系",
        "一个“用户”可以申请多个“权限”，而一个“权限”也可以分配给多个“用户”，在领域建模时应当设计成：":"多对多关系",
        "在领域建模时，“订单”与“订单明细”是一对多关系，设计正确的是：【多选题】":"['订单对象中有一个订单明细的集合属性变量', '订单明细表通过外键引用订单表']",
        "在领域建模时，“VIP会员”通过继承分为“金卡会员”和“银卡会员”，并且子类的个性化字段不多，设计正确的是：":"将父类和子类的数据都写入到一张表中",
        "在领域建模时，“供应商”通过继承分为“分销商”与“零售商”，各子类个性化字段较多并且经常要同时查询所有子类的数据，设计正确的是：":"父类一张表，每个子类各自一张表",
        "在领域建模时，“打折”通过继承分为各种类型的打折，每种类型的打折都各不相同但每次只查询一种打折，设计正确的是：":"每个子类各自一张表，父类的字段在各子类表中",
        "将领域模型中的继承关系存储到NoSQL数据库中，通常采用哪个方案：":"将父类和子类的数据都写入到一张表中",
        "将领域模型落地到软件设计时，负责接收用户请求，并执行相应操作的是：":"服务",
        "将领域模型落地到软件设计时，那些代表客观本质，做只读操作的领域对象是：":"值对象",
        "将领域模型落地到软件设计时，底层封装领域对象对数据库的持久化操作的是：":"仓库",
        "将领域模型落地到软件设计时，负责从数据库中读取数据，然后拼装成领域对象的是：":"工厂",
        "在架构师的思维习惯中，从整体触发，拥有大局观的是哪种思维：":"宏观思维",
        "在架构师的思维习惯中，从数据架构到开发架构运用的是哪种思维：":"抽象思维",
        "在架构师的思维习惯中，能从平时的一些小事中看到未来的战略意义的是哪种思维：":"战略思维",
        "在架构师的思维习惯中，总能不断地关注与学习未来的新技术、新趋势的是哪种思维：":"前瞻思维",
        "在开发架构设计中，通过限界上下文进行系统模块划分的原则包括：【多选题】":"['业务相关度', '业务复杂度', '主题域/支撑域']",
        "基于领域驱动的架构设计中，数据持久化层包含哪些组件：【多选题】":"['仓库', '工厂', '缓存']",
        "在整洁架构中，核心的业务对象及其关系应当设计在哪个层次：":"黄色的业务实体层",
        "在整洁架构中，与用户的业务交互应当设计在哪个层次：":"红色的User Case层",
        "在整洁架构中，将业务与技术的解耦应当设计在哪个层次：":"绿色的适配器层",
        "在整洁架构中，底层的具体技术与框架应当设计在哪个层次：":"蓝色的技术框架层",
        "整洁架构的灵魂与设计思想集中体现在哪个层次：":"绿色的适配器层",
        "在整洁架构的设计实现中，将业务与技术解耦的适配器层，具体体现在哪些层次的设计：【多选题】":"['连接前后端的数据接入层', '连接数据库的数据访问层', '封装底层技术的平台接口层']",
        "架构设计在应对日后的技术更迭与市场变化时，正确的思路应当是：【多选题】":"['系统架构应当随着不同时期的技术与市场变化而不断演变', '架构设计应当按照整洁架构分离技术与业务，让架构演变更容易']",
        "关于“架构跑道”这个隐喻，理解正确的是：":"架构设计就像机场设计跑道一样，刚刚好满足飞机的起飞",
        "关于“意图架构”设计思想，理解正确的是：":"基于不同时期的需求，对系统架构进行不断调整的设计",
        "在项目迭代的开发任务中，哪些属于“使能故事”的任务范畴：【多选题】":"['改进原有的功能设计', '抽象通用设计，沉淀技术中台', '调整原有的技术架构']",
        "在解决高并发性能问题的架构设计时，首先应当考虑的是什么：":"了解业务需求，即未来一段时间最大会达到多少的并发量",
        "在项目初期，采用All-in-One架构的设计要点是：【多选题】":"['在系统压力不大的情况下，采用单体应用的设计就可以', '通过整洁架构的进行系统分层，为日后架构演进做准备']",
        "面对高并发时，短事务高并发的写操作，是什么类型的操作：":"业务操作",
        "面对高并发时，大量用户对海量数据的明细数据查询，是什么类型的操作：":"随机查询",
        "面对高并发时，少量用户对海量数据的大范围统计查询，是什么类型的操作：":"统计分析",
        "海量短事务高并发的写操作，采取的优化措施应当是：":"尽量减少索引",
        "面对数据库磁盘I/O的瓶颈，推荐采用的设计方案是：【多选题】":"['选用分布式数据库将数据分散存储', '将数据库进行横向与纵向的拆分', '采用缓存来减小系统对数据库的压力']",
        "采用读写分离的设计，对于数据量不大的模块，读与写都采用什么数据库：":"关系型数据库",
        "采用读写分离的设计，对于数据量很大的模块，生产库采用什么数据库：":"NewSQL数据库",
        "采用读写分离的设计，对于数据量很大的模块，查询库采用什么数据库：":"NoSQL数据库",
        "在中台建设中，将各业务系统共性的业务抽取出来建立的能力中心，是：":"业务中台",
        "在中台建设中，将各系统都需要的技术框架封装起来建立的技术平台，是：":"技术中台",
        "在中台建设中，将各业务系统的数据整合以后建立的数据共享中心，是：":"数据中台",
        "在给客户绘制总体架构时，总体架构设计的思路应当包括：【多选题】":"['主要是将用户最关注的内容绘制出来', '设计应当逻辑清晰，让客户一眼就看明白我们的设计']",
        "架构师是介于需求和研发中间的人，他首先深入地理解业务需求，然后将业务落实到技术，形成设计方案":"对",
        "架构师在遇到问题时，应当首先从全局去思考问题，具有大局观，然后再逐步落实到细节中":"对",
        "只要在技术上足够厉害，掌握足够多的技术框架，就能成为一个优秀的架构师":"错",
        "架构师要更加深入地理解业务，甚至比需求分析人员（对）业务的理解还要深，才能成为优秀的架构师":"对",
        "架构师在进行技术架构设计时，主要是通过以往的项目经验进行决策:":"错",
        "在5视图法架构设计中，首先开展的架构设计是开发架构的设计":"错",
        "用例模型设计，就是自顶向下地绘制各种用例图就可以了":"错",
        "在编写用例描述时，如果某个用例的流程特别复杂，就应当将该用例的流程划分成多个子用例予以描述":"对",
        "软件设计质量越来越差的根源在于需求一次一次的变更":"错",
        "按照单一职责原则，当“商品信息”发生变更时，应当通过重构，将各个模块（对）“商品信息”读取的代码都抽取到同一模块中":"对",
        "按照单一职责原则，只有在日后变更的过程中，“折扣”的业务越来越复杂，才通过重构将“折扣”从“支付”模块中分离出来":"对",
        "随着软件的不断变更，业务逻辑变得越来越复杂，带来了软件规模的复杂度，需要通过小而专的微服务设计予以拆分":"对",
        "随着软件技术的不断发展，使得软件系统需要频繁更迭技术架构跟上时代的发展，从而在层次上增加了软件的复杂度":"对",
        "只要将复杂的系统按照微服务进行拆分，就能解决软件规模化带来的问题，降低系统维护成本":"错",
        "软件规模化的解决之道，就是将软件首先从业务角度进行分析，划分成多个限界上下文，然后以此划分微服务，解决复杂度的问题":"对",
        "统一语言建模的核心，是要求开发人员要通过跟客户的沟通学习业务，并且逐步学会用客户所在行业的语言与客户沟通业务":"对",
        "从逻辑架构到数据架构的分析设计过程，本质上是将业务需求由细到粗进行抽象，抽取共性，保留个性的一个过程":"错",
        "从数据架构到开发架构的分析设计过程，本质上是（对）业务需求由粗到细逐步细化的一个过程":"错",
        "“订单”与“支付”是一（对）一关系，因此在数据库设计时，支付表通过外键引用订单表的主键，并将该字段作为支付表的主键":"对",
        "在领域建模时，可以将领域（对）象的多（对）多关系通过一个关联类转换成两个多（对）一关系或一（对）多关系":"对",
        "基于DDD的开发架构设计，就是应当站在全局的角度去规划业务需求，将其划分为子系统、限界上下文与每个领域模型，最后落实到微服务的设计":"对",
        "小而专的微服务设计，就是应当按照单一职责划分微服务，数据库中的每个表按照职责可以有多个微服务能够（对）其访问":"错",
        "领域驱动设计主要适合（对）那些增删改的功能进行分析设计，查询功能其实并不适合领域驱动设计":"对",
        "开发架构设计就是要像城市规划师一样地去规划一套系统":"对",
        "按照整洁架构的设计思想，只有业务逻辑层与实体（对）象层才拥有业务代码，其它各个层次的代码都应当与业务无关":"对",
        "运行架构关注的不再是全局，而是局部的那些关键点与技术难点":"对",
        "在运行架构中，通过属性→场景→决策的步骤，将系统的所有功能性需求，最终落实到架构设计中":"错",
        "从运行架构到物理架构的分析设计过程，本质上是将非功能性需求由粗到细逐步细化到系统的安装部署的过程":"对",
        "物理架构设计要解决的问题是系统要部署在什么样的物理设备及网络拓扑上":"对",
        "要将一个业务系统部署到互联网上运营，可以通过物理架构的设计，将系统划分为互联网区域、DMZ区、内网区域和外网区域":"对"
    };

    // 获取所有包含题目的元素
    const questionElements = document.querySelectorAll('.field[topic]');
    // 循环处理每个题目
    questionElements.forEach((questionElement) => {
        // 获取题目文本
        const questionText = questionElement.querySelector('.topichtml').textContent.trim();
        const correctAnswer = rightAnswers[questionText];
        if (correctAnswer) {
            if (hasMultipleElements(correctAnswer)) {
                // 处理多选题
                const answerOptions = questionElement.querySelectorAll('input[type="checkbox"]');
                const answerLabels = questionElement.querySelectorAll('.label');
                answerOptions.forEach((input, index) => {
                    const optionText = answerLabels[index].textContent;
                    if (correctAnswer.includes(optionText)) {
                        const label = answerLabels[index];
                        label.click();
                    }
                });
            } else {
                // 处理单选题
                const answerOptions = questionElement.querySelectorAll('input[type="radio"]');
                const answerLabels = questionElement.querySelectorAll('.label');
                answerOptions.forEach((input, index) => {
                    const optionText = answerLabels[index].textContent;
                    if (optionText === correctAnswer) {
                        const label = answerLabels[index];
                        label.click();
                    }
                });
            }
        }
    });

    // 点击提交按钮
    // 你需要根据网页结构找到提交按钮并模拟点击

    function hasMultipleElements(str) {
        // 使用正则表达式匹配包含至少两个元素的字符串
        const regex = /\[[^\]]+,[^\]]+\]/;
        return regex.test(str);
      }
})();
