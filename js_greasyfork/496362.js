// ==UserScript==
// @name         Symfony 翻译文档 controller/error_pages.html
// @namespace    fireloong
// @version      0.1.3
// @description  翻译文档 controller/error_pages.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/controller/error_pages.html
// @match        https://symfony.com/doc/6.4/controller/error_pages.html
// @match        https://symfony.com/doc/7.1/controller/error_pages.html
// @match        https://symfony.com/doc/7.2/controller/error_pages.html
// @match        https://symfony.com/doc/current/controller/error_pages.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496362/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20controllererror_pageshtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496362/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20controllererror_pageshtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    How to Customize Error Pages\n        \n            ': '如何自定义错误页面',
        'In Symfony applications, all errors are treated as exceptions, no matter if they\nare a 404 Not Found error or a fatal error triggered by throwing some exception\nin your code.': '在 Symfony 应用程序中，无论它们是由你的代码中抛出异常导致的 404 未找到错误还是致命错误，所有错误都被视为异常。',
        'In the development environment,\nSymfony catches all the exceptions and displays a special exception page\nwith lots of debug information to help you discover the root problem:': '在<a href="../configuration.html#configuration-environments" class="reference internal">开发环境</a>中，Symfony 会捕获所有异常并显示一个带有大量调试信息的特殊<strong>异常页面</strong>，以帮助您发现问题的根源：',
        "Since these pages contain a lot of sensitive internal information, Symfony won't\ndisplay them in the production environment. Instead, it'll show a minimal and\ngeneric error page:": '由于这些页面包含大量敏感的内部信息，因此 Symfony 不会在生产环境中显示它们。相反，它将显示一个最小化和通用的<strong>错误页面</strong>：',
        'Error pages for the production environment can be customized in different ways\ndepending on your needs:': '生产环境的错误页面可以根据您的需求以不同方式进行定制：',
        'If you only want to change the contents and styles of the error pages to match\nthe rest of your application, override the default error templates;': '如果您只想更改错误页面的内容和样式以使其与应用程序的其余部分相匹配，请<a href="error_pages.html#use-default-error-controller" class="reference internal">覆盖默认的错误模板</a>；',
        'If you want to change the contents of non-HTML error output,\ncreate a new normalizer;': '如果您想更改非 HTML 错误输出的内容，请<a href="error_pages.html#overriding-non-html-error-output" class="reference internal">创建一个新的规范化器</a>；',
        'If you also want to tweak the logic used by Symfony to generate error pages,\noverride the default error controller;': '如果您还想调整 Symfony 用于生成错误页面的逻辑，请<a href="error_pages.html#custom-error-controller" class="reference internal">覆盖默认的错误控制器</a>；',
        'If you need total control of exception handling to run your own logic\nuse the kernel.exception event.': '如果您需要完全控制异常处理以运行自己的逻辑，请<a href="error_pages.html#use-kernel-exception-event" class="reference internal">使用 kernel.exception 事件</a>。',

        'Overriding the Default Error Templates': '覆盖默认的错误模板',
        'You can use the built-in Twig error renderer to override the default error\ntemplates. Both the TwigBundle and TwigBridge need to be installed for this. Run\nthis command to ensure both are installed:': '您可以使用内置的 Twig 错误渲染器来覆盖默认的错误模板。为此，需要安装 TwigBundle 和 TwigBridge。运行以下命令以确保两者都已安装：',
        'When the error page loads, TwigErrorRenderer\nis used to render a Twig template to show the user.': '当错误页面加载时， <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bridge/Twig/ErrorRenderer/TwigErrorRenderer.php" class="reference external" title="Symfony\Bridge\Twig\ErrorRenderer\TwigErrorRenderer" rel="external noopener noreferrer" target="_blank">TwigErrorRenderer</a> 用于渲染 Twig 模板以显示给用户。',
        'This renderer uses the HTTP status code and the following\nlogic to determine the template filename:': '这个渲染器使用 HTTP 状态码和以下逻辑来确定模板文件名：',
        'Look for a template for the given status code (like error500.html.twig);': '为给定的状态码（如 <code translate="no" class="notranslate">error500.html.twig</code>）查找模板；',
        "If the previous template doesn't exist, discard the status code and look for\na generic error template (error.html.twig).": '如果之前的模板不存在，则丢弃状态码并查找一个通用的错误模板（<code translate="no" class="notranslate">error.html.twig</code>）。',
        'To override these templates, rely on the standard Symfony method for\noverriding templates that live inside a bundle and\nput them in the templates/bundles/TwigBundle/Exception/ directory.': '要覆盖这些模板，请依赖 Symfony 的标准方法来<a href="../bundles/override.html#override-templates" class="reference internal">覆盖位于包内的模板</a>，并将它们放在 <code translate="no" class="notranslate">templates/bundles/TwigBundle/Exception/</code> 目录下。',
        'A typical project that returns HTML pages might look like this:': '一个返回 HTML 页面的典型项目可能如下所示：',

        'Example 404 Error Template': '示例 404 错误模板',
        'To override the 404 error template for HTML pages, create a new\nerror404.html.twig template located at templates/bundles/TwigBundle/Exception/:': '要覆盖 HTML 页面的 404 错误模板，请在 <code translate="no" class="notranslate">templates/bundles/TwigBundle/Exception/</code> 目录下创建一个新的 <code translate="no" class="notranslate">error404.html.twig</code> 模板：',
        'In case you need them, the TwigErrorRenderer passes some information to\nthe error template via the status_code and status_text variables that\nstore the HTTP status code and message respectively.': '如果您需要这些信息，<code translate="no" class="notranslate">TwigErrorRenderer</code> 会通过 <code translate="no" class="notranslate">status_code</code> 和 <code translate="no" class="notranslate">status_text</code> 变量将一些信息传递给错误模板，这些变量分别存储 HTTP 状态码和消息。',
        'You can customize the status code of an exception by implementing\nHttpExceptionInterface\nand its required getStatusCode() method. Otherwise, the status_code\nwill default to 500.': '您可以通过实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Exception/HttpExceptionInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Exception\HttpExceptionInterface" rel="external noopener noreferrer" target="_blank">HttpExceptionInterface</a> 及其必需的 <code translate="no" class="notranslate">getStatusCode()</code> 方法来自定义异常的状态码。否则，<code translate="no" class="notranslate">status_code</code> 的默认值将为 <code translate="no" class="notranslate">500</code>。',
        "Additionally you have access to the HttpException\nobject via the exception Twig variable. For example, if the exception sets a\nmessage (e.g. using throw $this->createNotFoundException('The product does not exist')),\nuse {{ exception.message }} to print that message. You can also output the\nstack trace using {{ exception.traceAsString }}, but don't do that for end\nusers because the trace contains sensitive data.": '此外，您还可以通过 Twig 变量 <code translate="no" class="notranslate">exception</code> 访问 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Exception/HttpException.php" class="reference external" title="Symfony\Component\HttpKernel\Exception\HttpException" rel="external noopener noreferrer" target="_blank">HttpException</a> 对象。例如，如果异常设置了消息（例如，使用 <code translate="no" class="notranslate">throw $this-&gt;createNotFoundException(\'The product does not exist\')</code>），则可以使用 <code translate="no" class="notranslate">{{ exception.message }}</code> 来打印该消息。您还可以使用 <code translate="no" class="notranslate">{{ exception.traceAsString }}</code> 输出堆栈跟踪，但不要为最终用户这样做，因为跟踪包含敏感数据。',
        'PHP errors are turned into exceptions as well by default, so you can also\naccess these error details using exception.': '默认情况下，PHP 错误也会被转换为异常，因此您也可以使用 <code translate="no" class="notranslate">exception</code> 来访问这些错误的详细信息。',

        'Security & 404 Pages': '安全 & 404 页面',
        'Due to the order of how routing and security are loaded, security information will\nnot be available on your 404 pages. This means that it will appear as if your\nuser is logged out on the 404 page (it will work while testing, but not on production).': '由于路由和安全性的加载顺序，您的 404 页面上将无法获得安全信息。这意味着在 404 页面上，您的用户将显示为已注销（在测试时有效，但在生产环境中无效）。',

        'Testing Error Pages during Development': '开发期间测试错误页面',
        "While you're in the development environment, Symfony shows the big exception\npage instead of your shiny new customized error page. So, how can you see\nwhat it looks like and debug it?": '当您处于开发环境时，Symfony 会显示大型异常页面，而不是您闪亮的新定制错误页面。那么，您如何查看它的外观并进行调试呢？',
        'Fortunately, the default ErrorController allows you to preview your\nerror pages during development.': '幸运的是，默认的 <code translate="no" class="notranslate">ErrorController</code> 允许您在开发期间预览错误页面。',
        'To use this feature, you need to load some special routes provided by FrameworkBundle\n(if the application uses Symfony Flex they are loaded\nautomatically when installing symfony/framework-bundle):': '要使用此功能，您需要加载 FrameworkBundle 提供的一些特殊路由（如果应用程序使用 <a href="../setup.html#symfony-flex" class="reference internal">Symfony Flex</a>，则在安装 <code translate="no" class="notranslate">symfony/framework-bundle</code> 时会自动加载它们）：',
        'With this route added, you can use URLs like these to preview the error page\nfor a given status code as HTML or for a given status code and format (you might\nneed to replace http://localhost/ by the host used in your local setup):': '添加此路由后，您可以使用类似这样的 URL 来预览给定状态码的错误页面（作为 HTML）或给定状态码和格式（您可能需要将 <code translate="no" class="notranslate">http://localhost/</code> 替换为您在本地设置中使用的主机）：',

        'Overriding Error output for non-HTML formats': '对于非 HTML 格式的错误输出进行重写',
        'To override non-HTML error output, the Serializer component needs to be installed.': '要重写非 HTML 的错误输出，需要安装序列化（Serializer）组件。',
        'The Serializer component has a built-in FlattenException normalizer\n(ProblemNormalizer) and\nJSON/XML/CSV/YAML encoders. When your application throws an exception, Symfony\ncan output it in one of those formats. If you want to change the output\ncontents, create a new Normalizer that supports the FlattenException input:': '序列化（Serializer）组件内置了一个 <code translate="no" class="notranslate">FlattenException</code> 归一化器（<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Serializer/Normalizer/ProblemNormalizer.php" class="reference external" title="Symfony\Component\Serializer\Normalizer\ProblemNormalizer" rel="external noopener noreferrer" target="_blank">ProblemNormalizer</a>）以及 JSON/XML/CSV/YAML 编码器。当您的应用程序抛出异常时，Symfony 可以以这些格式之一来输出它。如果您想要更改输出内容，可以创建一个支持 <code translate="no" class="notranslate">FlattenException</code> 输入的新归一化器：',

        'Overriding the Default ErrorController': '重写默认的 ErrorController',
        'If you need a little more flexibility beyond just overriding the template,\nthen you can change the controller that renders the error page. For example,\nyou might need to pass some additional variables into your template.': '如果你需要比仅仅覆盖模板更多的灵活性，那么你可以更改渲染错误页面的控制器。例如，你可能需要将一些额外的变量传递到你的模板中。',
        'To do this, create a new controller anywhere in your application and set\nthe framework.error_controller\nconfiguration option to point to it:': '要这样做，在您的应用程序中的任何位置创建一个新的控制器，并将 <a href="../reference/configuration/framework.html#config-framework-error_controller" class="reference internal">framework.error_controller</a> 配置选项设置为指向该控制器：',
        'The ErrorListener\nclass used by the FrameworkBundle as a listener of the kernel.exception event creates\nthe request that will be dispatched to your controller. In addition, your controller\nwill be passed two parameters:': 'FrameworkBundle 作为 <code translate="no" class="notranslate">kernel.exception</code> 事件的监听器所使用的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/EventListener/ErrorListener.php" class="reference external" title="Symfony\Component\HttpKernel\EventListener\ErrorListener" rel="external noopener noreferrer" target="_blank">ErrorListener</a> 类会创建一个请求，该请求将被分派到您的控制器。此外，您的控制器将接收两个参数：',
        '\n                            The original Throwable instance being handled.\n                    ': '正在处理的原始 <a href="https://secure.php.net/manual/zh/class.throwable.php" class="reference external" title="Throwable" rel="external noopener noreferrer" target="_blank">Throwable</a> 实例。',
        '\n                            A DebugLoggerInterface\ninstance which may be null in some circumstances.\n                    ': '一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src//Symfony/Component/HttpKernel/Log/DebugLoggerInterface.php" class="reference external" title="\Symfony\Component\HttpKernel\Log\DebugLoggerInterface" rel="external noopener noreferrer" target="_blank">DebugLoggerInterface</a> 实例，在某些情况下可能为 <code translate="no" class="notranslate">null</code>。',
        'The error page preview also works for\nyour own controllers set up this way.': '<a href="error_pages.html#testing-error-pages" class="reference internal">错误页面预览</a>也适用于以这种方式设置的您自己的控制器。',
        'Working with the kernel.exception Event': '处理 <code translate="no" class="notranslate">kernel.exception</code> 事件',
        'When an exception is thrown, the HttpKernel\nclass catches it and dispatches a kernel.exception event. This gives you the\npower to convert the exception into a Response in a few different ways.': '当发生异常时，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernel.php" class="reference external" title="Symfony\Component\HttpKernel\HttpKernel" rel="external noopener noreferrer" target="_blank">HttpKernel</a> 类会捕获它并分派一个 <code translate="no" class="notranslate">kernel.exception</code> 事件。这赋予了您以几种不同的方式将异常转换为 <code translate="no" class="notranslate">Response</code> 的能力。',
        'Working with this event is actually much more powerful than what has been explained\nbefore, but also requires a thorough understanding of Symfony internals. Suppose\nthat your code throws specialized exceptions with a particular meaning to your\napplication domain.': '处理这个事件实际上比前面解释的要强大得多，但也需要对 Symfony 内部机制有深入的了解。假设您的代码抛出了具有特定应用程序域含义的专用异常。',
        'Writing your own event listener\nfor the kernel.exception event allows you to have a closer look at the exception\nand take different actions depending on it. Those actions might include logging\nthe exception, redirecting the user to another page or rendering specialized\nerror pages.': '为您自己的 <code translate="no" class="notranslate">kernel.exception</code> 事件<a href="../event_dispatcher.html" class="reference internal">编写事件监听器</a>可以让您更仔细地查看异常，并根据异常采取不同的操作。这些操作可能包括记录异常、将用户重定向到另一个页面或呈现特定的错误页面。',
        'If your listener calls setThrowable() on the\nExceptionEvent\nevent, propagation will be stopped and the response will be sent to\nthe client.': '如果监听器在 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/ExceptionEvent.php" class="reference external" title="Symfony\Component\HttpKernel\Event\ExceptionEvent" rel="external noopener noreferrer" target="_blank">ExceptionEvent</a> 事件上调用 <code translate="no" class="notranslate">setThrowable()</code>，则传播将被停止，响应将被发送到客户端。',
        'This approach allows you to create centralized and layered error handling:\ninstead of catching (and handling) the same exceptions in various controllers\ntime and again, you can have just one (or several) listeners deal with them.': '这种方法允许您创建集中式和分层的错误处理：您无需在各种控制器中反复捕获（和处理）相同的异常，而只需使用一个（或多个）监听器来处理它们。',
        'See ExceptionListener\nclass code for a real example of an advanced listener of this type. This\nlistener handles various security-related exceptions that are thrown in\nyour application (like AccessDeniedException)\nand takes measures like redirecting the user to the login page, logging them\nout and other things.': '请参阅 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Firewall/ExceptionListener.php" class="reference external" title="Symfony\Component\Security\Http\Firewall\ExceptionListener" rel="external noopener noreferrer" target="_blank">ExceptionListener</a> 类的代码，以获取此类高级监听器的实际示例。此监听器处理在您的应用程序中抛出的各种与安全相关的异常（如 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Exception/AccessDeniedException.php" class="reference external" title="Symfony\Component\Security\Core\Exception\AccessDeniedException" rel="external noopener noreferrer" target="_blank">AccessDeniedException</a>），并采取措施，如将用户重定向到登录页面、注销用户等。',
    };

    fanyi(translates, 1);
})($);
