// ==UserScript==
// @name         iFAST Global Bank Helper (Partner)
// @namespace    https://www.ifastgb.com/
// @version      0.6.0
// @author       iFAST Group
// @description  帮助中国用户快速完成 iFAST 环球银行账户开户申请
// @icon         https://www.ifastgb.com/favicon.ico
// @match        https://www.ifastgb.com/*
// @require      https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js
// @grant        GM_openInTab
// @grant        window.onurlchange
// @downloadURL https://update.greasyfork.org/scripts/470102/iFAST%20Global%20Bank%20Helper%20%28Partner%29.user.js
// @updateURL https://update.greasyfork.org/scripts/470102/iFAST%20Global%20Bank%20Helper%20%28Partner%29.meta.js
// ==/UserScript==

(o=>{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.textContent=o,document.head.append(e)})(" .helper-fixed-box{position:fixed;right:0;top:335px;z-index:2147483647}.side_btn{user-select:none;text-align:center;color:#fff;padding:6px;margin:6px 0;width:32px;font-size:18px;cursor:pointer;border-radius:3px;text-shadow:1px 1px 3px #676767}.side_btn:hover{box-shadow:0 0 15px #3fe5d2}#blue-helper{background-color:#00e0cb;border:1px solid rgb(0,224,203)}#fill-button{background-color:#000c1f;border:1px solid #000c1f}.igb-form-tips{padding:8px 16px;color:#000;font-size:14px}.igb-form-tips.success{background-color:#f6ffed;border:1px solid #b7eb8f}.igb-form-tips.error{background-color:#fff2f0;border:1px solid #ffccc7} ");

(function (React, ReactDOM__default) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
  const ReactDOM__default__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM__default);

  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_main_001 = __commonJS({
    "main-72f94ff0.js"(exports, module) {
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      function getAugmentedNamespace(n2) {
        if (n2.__esModule)
          return n2;
        var f2 = n2.default;
        if (typeof f2 == "function") {
          var a = function a2() {
            if (this instanceof a2) {
              var args = [null];
              args.push.apply(args, arguments);
              var Ctor = Function.bind.apply(f2, args);
              return new Ctor();
            }
            return f2.apply(this, arguments);
          };
          a.prototype = f2.prototype;
        } else
          a = {};
        Object.defineProperty(a, "__esModule", { value: true });
        Object.keys(n2).forEach(function(k2) {
          var d2 = Object.getOwnPropertyDescriptor(n2, k2);
          Object.defineProperty(a, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return n2[k2];
            }
          });
        });
        return a;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var f$2 = React, k$3 = Symbol.for("react.element"), l$3 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$3 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
      function q$2(c2, a, g2) {
        var b2, d2 = {}, e2 = null, h2 = null;
        void 0 !== g2 && (e2 = "" + g2);
        void 0 !== a.key && (e2 = "" + a.key);
        void 0 !== a.ref && (h2 = a.ref);
        for (b2 in a)
          m$3.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
        if (c2 && c2.defaultProps)
          for (b2 in a = c2.defaultProps, a)
            void 0 === d2[b2] && (d2[b2] = a[b2]);
        return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$3.current };
      }
      reactJsxRuntime_production_min.Fragment = l$3;
      reactJsxRuntime_production_min.jsx = q$2;
      reactJsxRuntime_production_min.jsxs = q$2;
      {
        jsxRuntime.exports = reactJsxRuntime_production_min;
      }
      var jsxRuntimeExports = jsxRuntime.exports;
      var client = {};
      var m$2 = ReactDOM__default;
      {
        client.createRoot = m$2.createRoot;
        client.hydrateRoot = m$2.hydrateRoot;
      }
      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _typeof$3(obj) {
        "@babel/helpers - typeof";
        return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$3(obj);
      }
      function _toPrimitive$2(input2, hint) {
        if (_typeof$3(input2) !== "object" || input2 === null)
          return input2;
        var prim = input2[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input2, hint || "default");
          if (_typeof$3(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input2);
      }
      function _toPropertyKey$2(arg) {
        var key2 = _toPrimitive$2(arg, "string");
        return _typeof$3(key2) === "symbol" ? key2 : String(key2);
      }
      function _defineProperties$1(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
        }
      }
      function _createClass$1(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties$1(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties$1(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _setPrototypeOf$1(o2, p2) {
        _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf$1(o2, p2);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass)
          _setPrototypeOf$1(subClass, superClass);
      }
      function _getPrototypeOf$1(o2) {
        _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf$1(o2);
      }
      function _isNativeReflectConstruct$1() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _possibleConstructorReturn(self2, call2) {
        if (call2 && (_typeof$3(call2) === "object" || typeof call2 === "function")) {
          return call2;
        } else if (call2 !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf$1(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      var classnames = { exports: {} };
      /*!
      	Copyright (c) 2018 Jed Watson.
      	Licensed under the MIT License (MIT), see
      	http://jedwatson.github.io/classnames
      */
      (function(module2) {
        (function() {
          var hasOwn2 = {}.hasOwnProperty;
          function classNames2() {
            var classes = [];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              var arg = arguments[i2];
              if (!arg)
                continue;
              var argType = typeof arg;
              if (argType === "string" || argType === "number") {
                classes.push(arg);
              } else if (Array.isArray(arg)) {
                if (arg.length) {
                  var inner = classNames2.apply(null, arg);
                  if (inner) {
                    classes.push(inner);
                  }
                }
              } else if (argType === "object") {
                if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                  classes.push(arg.toString());
                  continue;
                }
                for (var key2 in arg) {
                  if (hasOwn2.call(arg, key2) && arg[key2]) {
                    classes.push(key2);
                  }
                }
              }
            }
            return classes.join(" ");
          }
          if (module2.exports) {
            classNames2.default = classNames2;
            module2.exports = classNames2;
          } else {
            window.classNames = classNames2;
          }
        })();
      })(classnames);
      var classnamesExports = classnames.exports;
      const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
      function _extends$1() {
        _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key2 in source) {
              if (Object.prototype.hasOwnProperty.call(source, key2)) {
                target[key2] = source[key2];
              }
            }
          }
          return target;
        };
        return _extends$1.apply(this, arguments);
      }
      var reactIs$1 = { exports: {} };
      var reactIs_production_min$1 = {};
      /** @license React v16.13.1
       * react-is.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$4 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$2 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
      function z$1(a) {
        if ("object" === typeof a && null !== a) {
          var u2 = a.$$typeof;
          switch (u2) {
            case c$1:
              switch (a = a.type, a) {
                case l$2:
                case m$1:
                case e$2:
                case g$4:
                case f$1:
                case p$1:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case k$2:
                    case n$2:
                    case t$2:
                    case r$1:
                    case h$1:
                      return a;
                    default:
                      return u2;
                  }
              }
            case d$1:
              return u2;
          }
        }
      }
      function A$1(a) {
        return z$1(a) === m$1;
      }
      reactIs_production_min$1.AsyncMode = l$2;
      reactIs_production_min$1.ConcurrentMode = m$1;
      reactIs_production_min$1.ContextConsumer = k$2;
      reactIs_production_min$1.ContextProvider = h$1;
      reactIs_production_min$1.Element = c$1;
      reactIs_production_min$1.ForwardRef = n$2;
      reactIs_production_min$1.Fragment = e$2;
      reactIs_production_min$1.Lazy = t$2;
      reactIs_production_min$1.Memo = r$1;
      reactIs_production_min$1.Portal = d$1;
      reactIs_production_min$1.Profiler = g$4;
      reactIs_production_min$1.StrictMode = f$1;
      reactIs_production_min$1.Suspense = p$1;
      reactIs_production_min$1.isAsyncMode = function(a) {
        return A$1(a) || z$1(a) === l$2;
      };
      reactIs_production_min$1.isConcurrentMode = A$1;
      reactIs_production_min$1.isContextConsumer = function(a) {
        return z$1(a) === k$2;
      };
      reactIs_production_min$1.isContextProvider = function(a) {
        return z$1(a) === h$1;
      };
      reactIs_production_min$1.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === c$1;
      };
      reactIs_production_min$1.isForwardRef = function(a) {
        return z$1(a) === n$2;
      };
      reactIs_production_min$1.isFragment = function(a) {
        return z$1(a) === e$2;
      };
      reactIs_production_min$1.isLazy = function(a) {
        return z$1(a) === t$2;
      };
      reactIs_production_min$1.isMemo = function(a) {
        return z$1(a) === r$1;
      };
      reactIs_production_min$1.isPortal = function(a) {
        return z$1(a) === d$1;
      };
      reactIs_production_min$1.isProfiler = function(a) {
        return z$1(a) === g$4;
      };
      reactIs_production_min$1.isStrictMode = function(a) {
        return z$1(a) === f$1;
      };
      reactIs_production_min$1.isSuspense = function(a) {
        return z$1(a) === p$1;
      };
      reactIs_production_min$1.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === e$2 || a === m$1 || a === g$4 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$2 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k$2 || a.$$typeof === n$2 || a.$$typeof === w$1 || a.$$typeof === x$1 || a.$$typeof === y$1 || a.$$typeof === v$1);
      };
      reactIs_production_min$1.typeOf = z$1;
      {
        reactIs$1.exports = reactIs_production_min$1;
      }
      var reactIsExports$1 = reactIs$1.exports;
      function toArray$5(children) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var ret = [];
        React.Children.forEach(children, function(child) {
          if ((child === void 0 || child === null) && !option.keepEmpty) {
            return;
          }
          if (Array.isArray(child)) {
            ret = ret.concat(toArray$5(child));
          } else if (reactIsExports$1.isFragment(child) && child.props) {
            ret = ret.concat(toArray$5(child.props.children, option));
          } else {
            ret.push(child);
          }
        });
        return ret;
      }
      var warned = {};
      var preMessage = function preMessage2(fn) {
      };
      function warning$2(valid, message) {
      }
      function note(valid, message) {
      }
      function resetWarned() {
        warned = {};
      }
      function call(method2, valid, message) {
        if (!valid && !warned[message]) {
          method2(false, message);
          warned[message] = true;
        }
      }
      function warningOnce(valid, message) {
        call(warning$2, valid, message);
      }
      function noteOnce(valid, message) {
        call(note, valid, message);
      }
      warningOnce.preMessage = preMessage;
      warningOnce.resetWarned = resetWarned;
      warningOnce.noteOnce = noteOnce;
      function _defineProperty$3(obj, key2, value) {
        key2 = _toPropertyKey$2(key2);
        if (key2 in obj) {
          Object.defineProperty(obj, key2, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key2] = value;
        }
        return obj;
      }
      function ownKeys$1(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread2(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
            _defineProperty$3(target, key2, source[key2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
        return target;
      }
      function useMemo(getValue2, condition, shouldUpdate) {
        var cacheRef = React__namespace.useRef({});
        if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
          cacheRef.current.value = getValue2();
          cacheRef.current.condition = condition;
        }
        return cacheRef.current.value;
      }
      function fillRef(ref, node2) {
        if (typeof ref === "function") {
          ref(node2);
        } else if (_typeof$3(ref) === "object" && ref && "current" in ref) {
          ref.current = node2;
        }
      }
      function composeRef() {
        for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
          refs[_key] = arguments[_key];
        }
        var refList = refs.filter(function(ref) {
          return ref;
        });
        if (refList.length <= 1) {
          return refList[0];
        }
        return function(node2) {
          refs.forEach(function(ref) {
            fillRef(ref, node2);
          });
        };
      }
      function useComposeRef() {
        for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          refs[_key2] = arguments[_key2];
        }
        return useMemo(function() {
          return composeRef.apply(void 0, refs);
        }, refs, function(prev2, next2) {
          return prev2.length === next2.length && prev2.every(function(ref, i2) {
            return ref === next2[i2];
          });
        });
      }
      function supportRef(nodeOrComponent) {
        var _type$prototype, _nodeOrComponent$prot;
        var type2 = reactIsExports$1.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
        if (typeof type2 === "function" && !((_type$prototype = type2.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
          return false;
        }
        if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
          return false;
        }
        return true;
      }
      function isDOM(node2) {
        return node2 instanceof HTMLElement || node2 instanceof SVGElement;
      }
      function findDOMNode(node2) {
        if (isDOM(node2)) {
          return node2;
        }
        if (node2 instanceof React.Component) {
          return ReactDOM__default.findDOMNode(node2);
        }
        return null;
      }
      var MapShim = function() {
        if (typeof Map !== "undefined") {
          return Map;
        }
        function getIndex(arr, key2) {
          var result = -1;
          arr.some(function(entry, index2) {
            if (entry[0] === key2) {
              result = index2;
              return true;
            }
            return false;
          });
          return result;
        }
        return (
          /** @class */
          function() {
            function class_1() {
              this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            class_1.prototype.get = function(key2) {
              var index2 = getIndex(this.__entries__, key2);
              var entry = this.__entries__[index2];
              return entry && entry[1];
            };
            class_1.prototype.set = function(key2, value) {
              var index2 = getIndex(this.__entries__, key2);
              if (~index2) {
                this.__entries__[index2][1] = value;
              } else {
                this.__entries__.push([key2, value]);
              }
            };
            class_1.prototype.delete = function(key2) {
              var entries = this.__entries__;
              var index2 = getIndex(entries, key2);
              if (~index2) {
                entries.splice(index2, 1);
              }
            };
            class_1.prototype.has = function(key2) {
              return !!~getIndex(this.__entries__, key2);
            };
            class_1.prototype.clear = function() {
              this.__entries__.splice(0);
            };
            class_1.prototype.forEach = function(callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };
            return class_1;
          }()
        );
      }();
      var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
      var global$1$1 = function() {
        if (typeof global !== "undefined" && global.Math === Math) {
          return global;
        }
        if (typeof self !== "undefined" && self.Math === Math) {
          return self;
        }
        if (typeof window !== "undefined" && window.Math === Math) {
          return window;
        }
        return Function("return this")();
      }();
      var requestAnimationFrame$1 = function() {
        if (typeof requestAnimationFrame === "function") {
          return requestAnimationFrame.bind(global$1$1);
        }
        return function(callback) {
          return setTimeout(function() {
            return callback(Date.now());
          }, 1e3 / 60);
        };
      }();
      var trailingTimeout = 2;
      function throttle(callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }
          if (trailingCall) {
            proxy();
          }
        }
        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            }
            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
        }
        return proxy;
      }
      var REFRESH_DELAY = 20;
      var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
      var mutationObserverSupported = typeof MutationObserver !== "undefined";
      var ResizeObserverController = (
        /** @class */
        function() {
          function ResizeObserverController2() {
            this.connected_ = false;
            this.mutationEventsAdded_ = false;
            this.mutationsObserver_ = null;
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
          }
          ResizeObserverController2.prototype.addObserver = function(observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            if (!this.connected_) {
              this.connect_();
            }
          };
          ResizeObserverController2.prototype.removeObserver = function(observer) {
            var observers2 = this.observers_;
            var index2 = observers2.indexOf(observer);
            if (~index2) {
              observers2.splice(index2, 1);
            }
            if (!observers2.length && this.connected_) {
              this.disconnect_();
            }
          };
          ResizeObserverController2.prototype.refresh = function() {
            var changesDetected = this.updateObservers_();
            if (changesDetected) {
              this.refresh();
            }
          };
          ResizeObserverController2.prototype.updateObservers_ = function() {
            var activeObservers = this.observers_.filter(function(observer) {
              return observer.gatherActive(), observer.hasActive();
            });
            activeObservers.forEach(function(observer) {
              return observer.broadcastActive();
            });
            return activeObservers.length > 0;
          };
          ResizeObserverController2.prototype.connect_ = function() {
            if (!isBrowser || this.connected_) {
              return;
            }
            document.addEventListener("transitionend", this.onTransitionEnd_);
            window.addEventListener("resize", this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
              });
            } else {
              document.addEventListener("DOMSubtreeModified", this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          ResizeObserverController2.prototype.disconnect_ = function() {
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener("transitionend", this.onTransitionEnd_);
            window.removeEventListener("resize", this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener("DOMSubtreeModified", this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
            var isReflowProperty = transitionKeys.some(function(key2) {
              return !!~propertyName.indexOf(key2);
            });
            if (isReflowProperty) {
              this.refresh();
            }
          };
          ResizeObserverController2.getInstance = function() {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController2();
            }
            return this.instance_;
          };
          ResizeObserverController2.instance_ = null;
          return ResizeObserverController2;
        }()
      );
      var defineConfigurable = function(target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key2 = _a[_i];
          Object.defineProperty(target, key2, {
            value: props[key2],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }
        return target;
      };
      var getWindowOf = function(target) {
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        return ownerGlobal || global$1$1;
      };
      var emptyRect = createRectInit(0, 0, 0, 0);
      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function(size, position2) {
          var value = styles["border-" + position2 + "-width"];
          return size + toFloat(value);
        }, 0);
      }
      function getPaddings(styles) {
        var positions = ["top", "right", "bottom", "left"];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position2 = positions_1[_i];
          var value = styles["padding-" + position2];
          paddings[position2] = toFloat(value);
        }
        return paddings;
      }
      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      function getHTMLElementContentRect(target) {
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        var width = toFloat(styles.width), height = toFloat(styles.height);
        if (styles.boxSizing === "border-box") {
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, "left", "right") + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, "top", "bottom") + vertPad;
          }
        }
        if (!isDocumentElement(target)) {
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
      }
      var isSVGGraphicsElement = function() {
        if (typeof SVGGraphicsElement !== "undefined") {
          return function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        }
        return function(target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
        };
      }();
      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
      }
      function createReadOnlyRect(_a) {
        var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
        var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        defineConfigurable(rect, {
          x: x2,
          y: y2,
          width,
          height,
          top: y2,
          right: x2 + width,
          bottom: height + y2,
          left: x2
        });
        return rect;
      }
      function createRectInit(x2, y2, width, height) {
        return { x: x2, y: y2, width, height };
      }
      var ResizeObservation = (
        /** @class */
        function() {
          function ResizeObservation2(target) {
            this.broadcastWidth = 0;
            this.broadcastHeight = 0;
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          ResizeObservation2.prototype.isActive = function() {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
          };
          ResizeObservation2.prototype.broadcastRect = function() {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation2;
        }()
      );
      var ResizeObserverEntry = (
        /** @class */
        function() {
          function ResizeObserverEntry2(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            defineConfigurable(this, { target, contentRect });
          }
          return ResizeObserverEntry2;
        }()
      );
      var ResizeObserverSPI = (
        /** @class */
        function() {
          function ResizeObserverSPI2(callback, controller, callbackCtx) {
            this.activeObservations_ = [];
            this.observations_ = new MapShim();
            if (typeof callback !== "function") {
              throw new TypeError("The callback provided as parameter 1 is not a function.");
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          ResizeObserverSPI2.prototype.observe = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            this.controller_.refresh();
          };
          ResizeObserverSPI2.prototype.unobserve = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          ResizeObserverSPI2.prototype.disconnect = function() {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          ResizeObserverSPI2.prototype.gatherActive = function() {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function(observation) {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          ResizeObserverSPI2.prototype.broadcastActive = function() {
            if (!this.hasActive()) {
              return;
            }
            var ctx = this.callbackCtx_;
            var entries = this.activeObservations_.map(function(observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          ResizeObserverSPI2.prototype.clearActive = function() {
            this.activeObservations_.splice(0);
          };
          ResizeObserverSPI2.prototype.hasActive = function() {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI2;
        }()
      );
      var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
      var ResizeObserver$2 = (
        /** @class */
        function() {
          function ResizeObserver2(callback) {
            if (!(this instanceof ResizeObserver2)) {
              throw new TypeError("Cannot call a class as a function.");
            }
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver2;
        }()
      );
      [
        "observe",
        "unobserve",
        "disconnect"
      ].forEach(function(method2) {
        ResizeObserver$2.prototype[method2] = function() {
          var _a;
          return (_a = observers.get(this))[method2].apply(_a, arguments);
        };
      });
      var index = function() {
        if (typeof global$1$1.ResizeObserver !== "undefined") {
          return global$1$1.ResizeObserver;
        }
        return ResizeObserver$2;
      }();
      var elementListeners = /* @__PURE__ */ new Map();
      function onResize(entities) {
        entities.forEach(function(entity) {
          var _elementListeners$get;
          var target = entity.target;
          (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
            return listener(target);
          });
        });
      }
      var resizeObserver = new index(onResize);
      function observe(element, callback) {
        if (!elementListeners.has(element)) {
          elementListeners.set(element, /* @__PURE__ */ new Set());
          resizeObserver.observe(element);
        }
        elementListeners.get(element).add(callback);
      }
      function unobserve(element, callback) {
        if (elementListeners.has(element)) {
          elementListeners.get(element).delete(callback);
          if (!elementListeners.get(element).size) {
            resizeObserver.unobserve(element);
            elementListeners.delete(element);
          }
        }
      }
      var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
        _inherits(DomWrapper2, _React$Component);
        var _super = _createSuper(DomWrapper2);
        function DomWrapper2() {
          _classCallCheck$1(this, DomWrapper2);
          return _super.apply(this, arguments);
        }
        _createClass$1(DomWrapper2, [{
          key: "render",
          value: function render2() {
            return this.props.children;
          }
        }]);
        return DomWrapper2;
      }(React__namespace.Component);
      var CollectionContext = /* @__PURE__ */ React__namespace.createContext(null);
      function Collection(_ref) {
        var children = _ref.children, onBatchResize = _ref.onBatchResize;
        var resizeIdRef = React__namespace.useRef(0);
        var resizeInfosRef = React__namespace.useRef([]);
        var onCollectionResize = React__namespace.useContext(CollectionContext);
        var onResize2 = React__namespace.useCallback(function(size, element, data) {
          resizeIdRef.current += 1;
          var currentId = resizeIdRef.current;
          resizeInfosRef.current.push({
            size,
            element,
            data
          });
          Promise.resolve().then(function() {
            if (currentId === resizeIdRef.current) {
              onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
              resizeInfosRef.current = [];
            }
          });
          onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
        }, [onBatchResize, onCollectionResize]);
        return /* @__PURE__ */ React__namespace.createElement(CollectionContext.Provider, {
          value: onResize2
        }, children);
      }
      function SingleObserver(props, ref) {
        var children = props.children, disabled = props.disabled;
        var elementRef = React__namespace.useRef(null);
        var wrapperRef = React__namespace.useRef(null);
        var onCollectionResize = React__namespace.useContext(CollectionContext);
        var isRenderProps = typeof children === "function";
        var mergedChildren = isRenderProps ? children(elementRef) : children;
        var sizeRef = React__namespace.useRef({
          width: -1,
          height: -1,
          offsetWidth: -1,
          offsetHeight: -1
        });
        var canRef = !isRenderProps && /* @__PURE__ */ React__namespace.isValidElement(mergedChildren) && supportRef(mergedChildren);
        var originRef = canRef ? mergedChildren.ref : null;
        var mergedRef = React__namespace.useMemo(function() {
          return composeRef(originRef, elementRef);
        }, [originRef, elementRef]);
        var getDom = function getDom2() {
          return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
        };
        React__namespace.useImperativeHandle(ref, function() {
          return getDom();
        });
        var propsRef = React__namespace.useRef(props);
        propsRef.current = props;
        var onInternalResize = React__namespace.useCallback(function(target) {
          var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
          var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
          var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
          var fixedWidth = Math.floor(width);
          var fixedHeight = Math.floor(height);
          if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
            var size = {
              width: fixedWidth,
              height: fixedHeight,
              offsetWidth,
              offsetHeight
            };
            sizeRef.current = size;
            var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
            var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
            var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
              offsetWidth: mergedOffsetWidth,
              offsetHeight: mergedOffsetHeight
            });
            onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
            if (onResize2) {
              Promise.resolve().then(function() {
                onResize2(sizeInfo, target);
              });
            }
          }
        }, []);
        React__namespace.useEffect(function() {
          var currentElement = getDom();
          if (currentElement && !disabled) {
            observe(currentElement, onInternalResize);
          }
          return function() {
            return unobserve(currentElement, onInternalResize);
          };
        }, [elementRef.current, disabled]);
        return /* @__PURE__ */ React__namespace.createElement(DomWrapper$1, {
          ref: wrapperRef
        }, canRef ? /* @__PURE__ */ React__namespace.cloneElement(mergedChildren, {
          ref: mergedRef
        }) : mergedChildren);
      }
      var RefSingleObserver = /* @__PURE__ */ React__namespace.forwardRef(SingleObserver);
      var INTERNAL_PREFIX_KEY = "rc-observer-key";
      function ResizeObserver$1(props, ref) {
        var children = props.children;
        var childNodes = typeof children === "function" ? [children] : toArray$5(children);
        return childNodes.map(function(child, index2) {
          var key2 = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
          return /* @__PURE__ */ React__namespace.createElement(RefSingleObserver, _extends$1({}, props, {
            key: key2,
            ref: index2 === 0 ? ref : void 0
          }), child);
        });
      }
      var RefResizeObserver = /* @__PURE__ */ React__namespace.forwardRef(ResizeObserver$1);
      RefResizeObserver.Collection = Collection;
      function omit(obj, fields) {
        var clone = _objectSpread2({}, obj);
        if (Array.isArray(fields)) {
          fields.forEach(function(key2) {
            delete clone[key2];
          });
        }
        return clone;
      }
      function _arrayLikeToArray$5(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray$5(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray$5(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$5(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$5(o2, minLen);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread();
      }
      var raf = function raf2(callback) {
        return +setTimeout(callback, 16);
      };
      var caf = function caf2(num) {
        return clearTimeout(num);
      };
      if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
        raf = function raf2(callback) {
          return window.requestAnimationFrame(callback);
        };
        caf = function caf2(handle) {
          return window.cancelAnimationFrame(handle);
        };
      }
      var rafUUID = 0;
      var rafIds = /* @__PURE__ */ new Map();
      function cleanup(id) {
        rafIds.delete(id);
      }
      var wrapperRaf = function wrapperRaf2(callback) {
        var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        rafUUID += 1;
        var id = rafUUID;
        function callRef(leftTimes) {
          if (leftTimes === 0) {
            cleanup(id);
            callback();
          } else {
            var realId = raf(function() {
              callRef(leftTimes - 1);
            });
            rafIds.set(id, realId);
          }
        }
        callRef(times);
        return id;
      };
      wrapperRaf.cancel = function(id) {
        var realId = rafIds.get(id);
        cleanup(realId);
        return caf(realId);
      };
      function murmur2(str) {
        var h2 = 0;
        var k2, i2 = 0, len = str.length;
        for (; len >= 4; ++i2, len -= 4) {
          k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
          k2 = /* Math.imul(k, m): */
          (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
          k2 ^= /* k >>> r: */
          k2 >>> 24;
          h2 = /* Math.imul(k, m): */
          (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        switch (len) {
          case 3:
            h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
          case 2:
            h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
          case 1:
            h2 ^= str.charCodeAt(i2) & 255;
            h2 = /* Math.imul(h, m): */
            (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        h2 ^= h2 >>> 13;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key2, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key2 = sourceKeys[i2];
          if (excluded.indexOf(key2) >= 0)
            continue;
          target[key2] = source[key2];
        }
        return target;
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key2, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key2 = sourceSymbolKeys[i2];
            if (excluded.indexOf(key2) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key2))
              continue;
            target[key2] = source[key2];
          }
        }
        return target;
      }
      function isEqual$1(obj1, obj2) {
        var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var refSet = /* @__PURE__ */ new Set();
        function deepEqual2(a, b2) {
          var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          var circular = refSet.has(a);
          warningOnce(!circular, "Warning: There may be circular references");
          if (circular) {
            return false;
          }
          if (a === b2) {
            return true;
          }
          if (shallow && level > 1) {
            return false;
          }
          refSet.add(a);
          var newLevel = level + 1;
          if (Array.isArray(a)) {
            if (!Array.isArray(b2) || a.length !== b2.length) {
              return false;
            }
            for (var i2 = 0; i2 < a.length; i2++) {
              if (!deepEqual2(a[i2], b2[i2], newLevel)) {
                return false;
              }
            }
            return true;
          }
          if (a && b2 && _typeof$3(a) === "object" && _typeof$3(b2) === "object") {
            var keys2 = Object.keys(a);
            if (keys2.length !== Object.keys(b2).length) {
              return false;
            }
            return keys2.every(function(key2) {
              return deepEqual2(a[key2], b2[key2], newLevel);
            });
          }
          return false;
        }
        return deepEqual2(obj1, obj2);
      }
      var Entity = /* @__PURE__ */ function() {
        function Entity2(instanceId) {
          _classCallCheck$1(this, Entity2);
          _defineProperty$3(this, "instanceId", void 0);
          _defineProperty$3(this, "cache", /* @__PURE__ */ new Map());
          this.instanceId = instanceId;
        }
        _createClass$1(Entity2, [{
          key: "get",
          value: function get2(keys2) {
            return this.cache.get(keys2.join("%")) || null;
          }
        }, {
          key: "update",
          value: function update(keys2, valueFn) {
            var path = keys2.join("%");
            var prevValue = this.cache.get(path);
            var nextValue = valueFn(prevValue);
            if (nextValue === null) {
              this.cache.delete(path);
            } else {
              this.cache.set(path, nextValue);
            }
          }
        }]);
        return Entity2;
      }();
      var ATTR_TOKEN = "data-token-hash";
      var ATTR_MARK = "data-css-hash";
      var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
      function createCache() {
        var cssinjsInstanceId = Math.random().toString(12).slice(2);
        if (typeof document !== "undefined" && document.head && document.body) {
          var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
          var firstChild = document.head.firstChild;
          Array.from(styles).forEach(function(style2) {
            style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
            if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
              document.head.insertBefore(style2, firstChild);
            }
          });
          var styleHash = {};
          Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
            var hash = style2.getAttribute(ATTR_MARK);
            if (styleHash[hash]) {
              if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
                var _style$parentNode;
                (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
              }
            } else {
              styleHash[hash] = true;
            }
          });
        }
        return new Entity(cssinjsInstanceId);
      }
      var StyleContext = /* @__PURE__ */ React__namespace.createContext({
        hashPriority: "low",
        cache: createCache(),
        defaultCache: true
      });
      function canUseDom() {
        return !!(typeof window !== "undefined" && window.document && window.document.createElement);
      }
      function contains(root, n2) {
        if (!root) {
          return false;
        }
        if (root.contains) {
          return root.contains(n2);
        }
        var node2 = n2;
        while (node2) {
          if (node2 === root) {
            return true;
          }
          node2 = node2.parentNode;
        }
        return false;
      }
      var APPEND_ORDER = "data-rc-order";
      var MARK_KEY = "rc-util-key";
      var containerCache = /* @__PURE__ */ new Map();
      function getMark() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
        if (mark) {
          return mark.startsWith("data-") ? mark : "data-".concat(mark);
        }
        return MARK_KEY;
      }
      function getContainer(option) {
        if (option.attachTo) {
          return option.attachTo;
        }
        var head = document.querySelector("head");
        return head || document.body;
      }
      function getOrder(prepend) {
        if (prepend === "queue") {
          return "prependQueue";
        }
        return prepend ? "prepend" : "append";
      }
      function findStyles(container) {
        return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
          return node2.tagName === "STYLE";
        });
      }
      function injectCSS(css) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!canUseDom()) {
          return null;
        }
        var csp = option.csp, prepend = option.prepend;
        var styleNode = document.createElement("style");
        styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
        if (csp !== null && csp !== void 0 && csp.nonce) {
          styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
        }
        styleNode.innerHTML = css;
        var container = getContainer(option);
        var firstChild = container.firstChild;
        if (prepend) {
          if (prepend === "queue") {
            var existStyle = findStyles(container).filter(function(node2) {
              return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
            });
            if (existStyle.length) {
              container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
              return styleNode;
            }
          }
          container.insertBefore(styleNode, firstChild);
        } else {
          container.appendChild(styleNode);
        }
        return styleNode;
      }
      function findExistNode(key2) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var container = getContainer(option);
        return findStyles(container).find(function(node2) {
          return node2.getAttribute(getMark(option)) === key2;
        });
      }
      function removeCSS(key2) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var existNode = findExistNode(key2, option);
        if (existNode) {
          var container = getContainer(option);
          container.removeChild(existNode);
        }
      }
      function syncRealContainer(container, option) {
        var cachedRealContainer = containerCache.get(container);
        if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
          var placeholderStyle = injectCSS("", option);
          var parentNode = placeholderStyle.parentNode;
          containerCache.set(container, parentNode);
          container.removeChild(placeholderStyle);
        }
      }
      function updateCSS(css, key2) {
        var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var container = getContainer(option);
        syncRealContainer(container, option);
        var existNode = findExistNode(key2, option);
        if (existNode) {
          var _option$csp, _option$csp2;
          if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
            var _option$csp3;
            existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
          }
          if (existNode.innerHTML !== css) {
            existNode.innerHTML = css;
          }
          return existNode;
        }
        var newNode = injectCSS(css, option);
        newNode.setAttribute(getMark(option), key2);
        return newNode;
      }
      function flattenToken(token2) {
        var str = "";
        Object.keys(token2).forEach(function(key2) {
          var value = token2[key2];
          str += key2;
          if (value && _typeof$3(value) === "object") {
            str += flattenToken(value);
          } else {
            str += value;
          }
        });
        return str;
      }
      function token2key(token2, salt) {
        return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
      }
      var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
      var layerWidth = "903px";
      function supportSelector(styleStr, handleElement) {
        if (canUseDom()) {
          var _ele$parentNode;
          updateCSS(styleStr, layerKey);
          var _ele = document.createElement("div");
          _ele.style.position = "fixed";
          _ele.style.left = "0";
          _ele.style.top = "0";
          handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
          document.body.appendChild(_ele);
          var support = getComputedStyle(_ele).width === layerWidth;
          (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
          removeCSS(layerKey);
          return support;
        }
        return false;
      }
      var canLayer = void 0;
      function supportLayer() {
        if (canLayer === void 0) {
          canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
            ele.className = layerKey;
          });
        }
        return canLayer;
      }
      function _arrayWithHoles$5(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _iterableToArrayLimit$5(arr, i2) {
        var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
        if (null != _i) {
          var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
          try {
            if (_x = (_i = _i.call(arr)).next, 0 === i2) {
              if (Object(_i) !== _i)
                return;
              _n = false;
            } else
              for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
                ;
          } catch (err) {
            _d = true, _e = err;
          } finally {
            try {
              if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
                return;
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
      }
      function _nonIterableRest$5() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _slicedToArray$5(arr, i2) {
        return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i2) || _unsupportedIterableToArray$5(arr, i2) || _nonIterableRest$5();
      }
      function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
        var _React$useContext = React__namespace.useContext(StyleContext), globalCache = _React$useContext.cache;
        var fullPath = [prefix].concat(_toConsumableArray(keyPath));
        React__namespace.useMemo(
          function() {
            globalCache.update(fullPath, function(prevCache) {
              var _ref = prevCache || [], _ref2 = _slicedToArray$5(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
              var tmpCache = cache;
              var mergedCache = tmpCache || cacheFn();
              return [times + 1, mergedCache];
            });
          },
          /* eslint-disable react-hooks/exhaustive-deps */
          [fullPath.join("_")]
          /* eslint-enable */
        );
        React__namespace.useEffect(function() {
          return function() {
            globalCache.update(fullPath, function(prevCache) {
              var _ref3 = prevCache || [], _ref4 = _slicedToArray$5(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache = _ref4[1];
              var nextCount = times - 1;
              if (nextCount === 0) {
                onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
                return null;
              }
              return [times - 1, cache];
            });
          };
        }, fullPath);
        return globalCache.get(fullPath)[1];
      }
      var EMPTY_OVERRIDE = {};
      var hashPrefix = "css";
      var tokenKeys = /* @__PURE__ */ new Map();
      function recordCleanToken(tokenKey) {
        tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
      }
      function removeStyleTags(key2, instanceId) {
        if (typeof document !== "undefined") {
          var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key2, '"]'));
          styles.forEach(function(style2) {
            if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
              var _style$parentNode;
              (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
            }
          });
        }
      }
      function cleanTokenStyle(tokenKey, instanceId) {
        tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
        var tokenKeyList = Array.from(tokenKeys.keys());
        var cleanableKeyList = tokenKeyList.filter(function(key2) {
          var count = tokenKeys.get(key2) || 0;
          return count <= 0;
        });
        if (cleanableKeyList.length < tokenKeyList.length) {
          cleanableKeyList.forEach(function(key2) {
            removeStyleTags(key2, instanceId);
            tokenKeys.delete(key2);
          });
        }
      }
      var getComputedToken = function getComputedToken2(originToken, overrideToken, theme2, format2) {
        var derivativeToken = theme2.getDerivativeToken(originToken);
        var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
        if (format2) {
          mergedDerivativeToken = format2(mergedDerivativeToken);
        }
        return mergedDerivativeToken;
      };
      function useCacheToken(theme2, tokens) {
        var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var _useContext = React.useContext(StyleContext), instanceId = _useContext.cache.instanceId;
        var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
        var mergedToken = React__namespace.useMemo(function() {
          return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
        }, [tokens]);
        var tokenStr = React__namespace.useMemo(function() {
          return flattenToken(mergedToken);
        }, [mergedToken]);
        var overrideTokenStr = React__namespace.useMemo(function() {
          return flattenToken(override);
        }, [override]);
        var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
          var mergedDerivativeToken = getComputedToken(mergedToken, override, theme2, formatToken2);
          var tokenKey = token2key(mergedDerivativeToken, salt);
          mergedDerivativeToken._tokenKey = tokenKey;
          recordCleanToken(tokenKey);
          var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
          mergedDerivativeToken._hashId = hashId;
          return [mergedDerivativeToken, hashId];
        }, function(cache) {
          cleanTokenStyle(cache[0]._tokenKey, instanceId);
        });
        return cachedToken;
      }
      var unitlessKeys = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        // SVG-related properties
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
      var COMMENT = "comm";
      var RULESET = "rule";
      var DECLARATION = "decl";
      var IMPORT = "@import";
      var KEYFRAMES = "@keyframes";
      var LAYER = "@layer";
      var abs = Math.abs;
      var from = String.fromCharCode;
      function trim(value) {
        return value.trim();
      }
      function replace(value, pattern2, replacement) {
        return value.replace(pattern2, replacement);
      }
      function indexof(value, search) {
        return value.indexOf(search);
      }
      function charat(value, index2) {
        return value.charCodeAt(index2) | 0;
      }
      function substr(value, begin, end) {
        return value.slice(begin, end);
      }
      function strlen(value) {
        return value.length;
      }
      function sizeof(value) {
        return value.length;
      }
      function append(value, array2) {
        return array2.push(value), value;
      }
      var line = 1;
      var column = 1;
      var length = 0;
      var position = 0;
      var character = 0;
      var characters = "";
      function node(value, root, parent, type2, props, children, length2, siblings) {
        return { value, root, parent, type: type2, props, children, line, column, length: length2, return: "", siblings };
      }
      function char() {
        return character;
      }
      function prev() {
        character = position > 0 ? charat(characters, --position) : 0;
        if (column--, character === 10)
          column = 1, line--;
        return character;
      }
      function next() {
        character = position < length ? charat(characters, position++) : 0;
        if (column++, character === 10)
          column = 1, line++;
        return character;
      }
      function peek() {
        return charat(characters, position);
      }
      function caret() {
        return position;
      }
      function slice$2(begin, end) {
        return substr(characters, begin, end);
      }
      function token(type2) {
        switch (type2) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function alloc(value) {
        return line = column = 1, length = strlen(characters = value), position = 0, [];
      }
      function dealloc(value) {
        return characters = "", value;
      }
      function delimit(type2) {
        return trim(slice$2(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
      }
      function whitespace$1(type2) {
        while (character = peek())
          if (character < 33)
            next();
          else
            break;
        return token(type2) > 2 || token(character) > 3 ? "" : " ";
      }
      function escaping(index2, count) {
        while (--count && next())
          if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
            break;
        return slice$2(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
      }
      function delimiter(type2) {
        while (next())
          switch (character) {
            case type2:
              return position;
            case 34:
            case 39:
              if (type2 !== 34 && type2 !== 39)
                delimiter(character);
              break;
            case 40:
              if (type2 === 41)
                delimiter(type2);
              break;
            case 92:
              next();
              break;
          }
        return position;
      }
      function commenter(type2, index2) {
        while (next())
          if (type2 + character === 47 + 10)
            break;
          else if (type2 + character === 42 + 42 && peek() === 47)
            break;
        return "/*" + slice$2(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
      }
      function identifier(index2) {
        while (!token(peek()))
          next();
        return slice$2(index2, position);
      }
      function compile(value) {
        return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
      }
      function parse(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
        var index2 = 0;
        var offset2 = 0;
        var length2 = pseudo;
        var atrule = 0;
        var property = 0;
        var previous = 0;
        var variable = 1;
        var scanning = 1;
        var ampersand = 1;
        var character2 = 0;
        var type2 = "";
        var props = rules2;
        var children = rulesets;
        var reference = rule;
        var characters2 = type2;
        while (scanning)
          switch (previous = character2, character2 = next()) {
            case 40:
              if (previous != 108 && charat(characters2, length2 - 1) == 58) {
                if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                  ampersand = -1;
                break;
              }
            case 34:
            case 39:
            case 91:
              characters2 += delimit(character2);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              characters2 += whitespace$1(previous);
              break;
            case 92:
              characters2 += escaping(caret() - 1, 7);
              continue;
            case 47:
              switch (peek()) {
                case 42:
                case 47:
                  append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
                  break;
                default:
                  characters2 += "/";
              }
              break;
            case 123 * variable:
              points[index2++] = strlen(characters2) * ampersand;
            case 125 * variable:
            case 59:
            case 0:
              switch (character2) {
                case 0:
                case 125:
                  scanning = 0;
                case 59 + offset2:
                  if (ampersand == -1)
                    characters2 = replace(characters2, /\f/g, "");
                  if (property > 0 && strlen(characters2) - length2)
                    append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                  break;
                case 59:
                  characters2 += ";";
                default:
                  append(reference = ruleset(characters2, root, parent, index2, offset2, rules2, points, type2, props = [], children = [], length2, rulesets), rulesets);
                  if (character2 === 123)
                    if (offset2 === 0)
                      parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                    else
                      switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type2, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                          break;
                        default:
                          parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                      }
              }
              index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
              break;
            case 58:
              length2 = 1 + strlen(characters2), property = previous;
            default:
              if (variable < 1) {
                if (character2 == 123)
                  --variable;
                else if (character2 == 125 && variable++ == 0 && prev() == 125)
                  continue;
              }
              switch (characters2 += from(character2), character2 * variable) {
                case 38:
                  ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                  break;
                case 44:
                  points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                  break;
                case 64:
                  if (peek() === 45)
                    characters2 += delimit(next());
                  atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
                  break;
                case 45:
                  if (previous === 45 && strlen(characters2) == 2)
                    variable = 0;
              }
          }
        return rulesets;
      }
      function ruleset(value, root, parent, index2, offset2, rules2, points, type2, props, children, length2, siblings) {
        var post = offset2 - 1;
        var rule = offset2 === 0 ? rules2 : [""];
        var size = sizeof(rule);
        for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
          for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size; ++x2)
            if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
              props[k2++] = z2;
        return node(value, root, parent, offset2 === 0 ? RULESET : type2, props, children, length2, siblings);
      }
      function comment(value, root, parent, siblings) {
        return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
      }
      function declaration(value, root, parent, length2, siblings) {
        return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
      }
      function serialize$7(children, callback) {
        var output = "";
        for (var i2 = 0; i2 < children.length; i2++)
          output += callback(children[i2], i2, children, callback) || "";
        return output;
      }
      function stringify$1(element, index2, children, callback) {
        switch (element.type) {
          case LAYER:
            if (element.children.length)
              break;
          case IMPORT:
          case DECLARATION:
            return element.return = element.return || element.value;
          case COMMENT:
            return "";
          case KEYFRAMES:
            return element.return = element.value + "{" + serialize$7(element.children, callback) + "}";
          case RULESET:
            if (!strlen(element.value = element.props.join(",")))
              return "";
        }
        return strlen(children = serialize$7(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
      }
      var isClientSide = canUseDom();
      var SKIP_CHECK = "_skip_check_";
      var MULTI_VALUE = "_multi_value_";
      function normalizeStyle(styleStr) {
        var serialized = serialize$7(compile(styleStr), stringify$1);
        return serialized.replace(/\{%%%\:[^;];}/g, ";");
      }
      function isCompoundCSSProperty(value) {
        return _typeof$3(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
      }
      function injectSelectorHash(key2, hashId, hashPriority) {
        if (!hashId) {
          return key2;
        }
        var hashClassName = ".".concat(hashId);
        var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
        var keys2 = key2.split(",").map(function(k2) {
          var _firstPath$match;
          var fullPath = k2.trim().split(/\s+/);
          var firstPath = fullPath[0] || "";
          var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
          firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
          return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
        });
        return keys2.join(",");
      }
      var parseStyle = function parseStyle2(interpolation) {
        var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          root: true,
          parentSelectors: []
        }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
        var hashId = config2.hashId, layer = config2.layer;
        config2.path;
        var hashPriority = config2.hashPriority, _config$transformers = config2.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
        config2.linters;
        var styleStr = "";
        var effectStyle = {};
        function parseKeyframes(keyframes) {
          var animationName = keyframes.getName(hashId);
          if (!effectStyle[animationName]) {
            var _parseStyle = parseStyle2(keyframes.style, config2, {
              root: false,
              parentSelectors
            }), _parseStyle2 = _slicedToArray$5(_parseStyle, 1), _parsedStr = _parseStyle2[0];
            effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
          }
        }
        function flattenList(list) {
          var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          list.forEach(function(item) {
            if (Array.isArray(item)) {
              flattenList(item, fullList);
            } else if (item) {
              fullList.push(item);
            }
          });
          return fullList;
        }
        var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
        flattenStyleList.forEach(function(originStyle) {
          var style2 = typeof originStyle === "string" && !root ? {} : originStyle;
          if (typeof style2 === "string") {
            styleStr += "".concat(style2, "\n");
          } else if (style2._keyframe) {
            parseKeyframes(style2);
          } else {
            var mergedStyle = transformers.reduce(function(prev2, trans) {
              var _trans$visit;
              return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
            }, style2);
            Object.keys(mergedStyle).forEach(function(key2) {
              var value = mergedStyle[key2];
              if (_typeof$3(value) === "object" && value && (key2 !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
                var subInjectHash = false;
                var mergedKey = key2.trim();
                var nextRoot = false;
                if ((root || injectHash) && hashId) {
                  if (mergedKey.startsWith("@")) {
                    subInjectHash = true;
                  } else {
                    mergedKey = injectSelectorHash(key2, hashId, hashPriority);
                  }
                } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
                  mergedKey = "";
                  nextRoot = true;
                }
                var _parseStyle3 = parseStyle2(value, config2, {
                  root: nextRoot,
                  injectHash: subInjectHash,
                  parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
                }), _parseStyle4 = _slicedToArray$5(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
                effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
                styleStr += "".concat(mergedKey).concat(_parsedStr2);
              } else {
                let appendStyle = function(cssKey, cssValue) {
                  var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
                    return "-".concat(match2.toLowerCase());
                  });
                  var formatValue2 = cssValue;
                  if (!unitlessKeys[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
                    formatValue2 = "".concat(formatValue2, "px");
                  }
                  if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                    parseKeyframes(cssValue);
                    formatValue2 = cssValue.getName(hashId);
                  }
                  styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
                };
                var _value;
                var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
                if (_typeof$3(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
                  actualValue.forEach(function(item) {
                    appendStyle(key2, item);
                  });
                } else {
                  appendStyle(key2, actualValue);
                }
              }
            });
          }
        });
        if (!root) {
          styleStr = "{".concat(styleStr, "}");
        } else if (layer && supportLayer()) {
          var layerCells = layer.split(",");
          var layerName = layerCells[layerCells.length - 1].trim();
          styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
          if (layerCells.length > 1) {
            styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
          }
        }
        return [styleStr, effectStyle];
      };
      function uniqueHash(path, styleStr) {
        return murmur2("".concat(path.join("%")).concat(styleStr));
      }
      function Empty() {
        return null;
      }
      function useStyleRegister(info, styleFn) {
        var token2 = info.token, path = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce;
        var _React$useContext = React__namespace.useContext(StyleContext), autoClear = _React$useContext.autoClear;
        _React$useContext.mock;
        var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache;
        var tokenKey = token2._tokenKey;
        var fullPath = [tokenKey].concat(_toConsumableArray(path));
        var isMergedClientSide = isClientSide;
        var _useGlobalCache = useClientCache(
          "style",
          fullPath,
          // Create cache if needed
          function() {
            var styleObj = styleFn();
            var _parseStyle5 = parseStyle(styleObj, {
              hashId,
              hashPriority,
              layer,
              path: path.join("-"),
              transformers,
              linters
            }), _parseStyle6 = _slicedToArray$5(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
            var styleStr = normalizeStyle(parsedStyle);
            var styleId = uniqueHash(fullPath, styleStr);
            if (isMergedClientSide) {
              var mergedCSSConfig = {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: container
              };
              var nonceStr = typeof nonce === "function" ? nonce() : nonce;
              if (nonceStr) {
                mergedCSSConfig.csp = {
                  nonce: nonceStr
                };
              }
              var style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
              style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
              style2.setAttribute(ATTR_TOKEN, tokenKey);
              Object.keys(effectStyle).forEach(function(effectKey) {
                updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
              });
            }
            return [styleStr, tokenKey, styleId];
          },
          // Remove cache if no need
          function(_ref2, fromHMR) {
            var _ref3 = _slicedToArray$5(_ref2, 3), styleId = _ref3[2];
            if ((fromHMR || autoClear) && isClientSide) {
              removeCSS(styleId, {
                mark: ATTR_MARK
              });
            }
          }
        ), _useGlobalCache2 = _slicedToArray$5(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
        return function(node2) {
          var styleNode;
          if (!ssrInline || isMergedClientSide || !defaultCache) {
            styleNode = /* @__PURE__ */ React__namespace.createElement(Empty, null);
          } else {
            var _ref4;
            styleNode = /* @__PURE__ */ React__namespace.createElement("style", _extends$1({}, (_ref4 = {}, _defineProperty$3(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty$3(_ref4, ATTR_MARK, cachedStyleId), _ref4), {
              dangerouslySetInnerHTML: {
                __html: cachedStyleStr
              }
            }));
          }
          return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, styleNode, node2);
        };
      }
      var Keyframe = /* @__PURE__ */ function() {
        function Keyframe2(name, style2) {
          _classCallCheck$1(this, Keyframe2);
          _defineProperty$3(this, "name", void 0);
          _defineProperty$3(this, "style", void 0);
          _defineProperty$3(this, "_keyframe", true);
          this.name = name;
          this.style = style2;
        }
        _createClass$1(Keyframe2, [{
          key: "getName",
          value: function getName() {
            var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
          }
        }]);
        return Keyframe2;
      }();
      function sameDerivativeOption(left, right) {
        if (left.length !== right.length) {
          return false;
        }
        for (var i2 = 0; i2 < left.length; i2++) {
          if (left[i2] !== right[i2]) {
            return false;
          }
        }
        return true;
      }
      var ThemeCache = /* @__PURE__ */ function() {
        function ThemeCache2() {
          _classCallCheck$1(this, ThemeCache2);
          _defineProperty$3(this, "cache", void 0);
          _defineProperty$3(this, "keys", void 0);
          _defineProperty$3(this, "cacheCallTimes", void 0);
          this.cache = /* @__PURE__ */ new Map();
          this.keys = [];
          this.cacheCallTimes = 0;
        }
        _createClass$1(ThemeCache2, [{
          key: "size",
          value: function size() {
            return this.keys.length;
          }
        }, {
          key: "internalGet",
          value: function internalGet(derivativeOption) {
            var _cache2, _cache3;
            var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var cache = {
              map: this.cache
            };
            derivativeOption.forEach(function(derivative2) {
              if (!cache) {
                cache = void 0;
              } else {
                var _cache, _cache$map;
                cache = (_cache = cache) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
              }
            });
            if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
              cache.value[1] = this.cacheCallTimes++;
            }
            return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
          }
        }, {
          key: "get",
          value: function get2(derivativeOption) {
            var _this$internalGet;
            return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
          }
        }, {
          key: "has",
          value: function has2(derivativeOption) {
            return !!this.internalGet(derivativeOption);
          }
        }, {
          key: "set",
          value: function set2(derivativeOption, value) {
            var _this = this;
            if (!this.has(derivativeOption)) {
              if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
                var _this$keys$reduce = this.keys.reduce(function(result, key2) {
                  var _result = _slicedToArray$5(result, 2), callTimes = _result[1];
                  if (_this.internalGet(key2)[1] < callTimes) {
                    return [key2, _this.internalGet(key2)[1]];
                  }
                  return result;
                }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray$5(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
                this.delete(targetKey);
              }
              this.keys.push(derivativeOption);
            }
            var cache = this.cache;
            derivativeOption.forEach(function(derivative2, index2) {
              if (index2 === derivativeOption.length - 1) {
                cache.set(derivative2, {
                  value: [value, _this.cacheCallTimes++]
                });
              } else {
                var cacheValue = cache.get(derivative2);
                if (!cacheValue) {
                  cache.set(derivative2, {
                    map: /* @__PURE__ */ new Map()
                  });
                } else if (!cacheValue.map) {
                  cacheValue.map = /* @__PURE__ */ new Map();
                }
                cache = cache.get(derivative2).map;
              }
            });
          }
        }, {
          key: "deleteByPath",
          value: function deleteByPath(currentCache, derivatives) {
            var cache = currentCache.get(derivatives[0]);
            if (derivatives.length === 1) {
              var _cache$value;
              if (!cache.map) {
                currentCache.delete(derivatives[0]);
              } else {
                currentCache.set(derivatives[0], {
                  map: cache.map
                });
              }
              return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
            }
            var result = this.deleteByPath(cache.map, derivatives.slice(1));
            if ((!cache.map || cache.map.size === 0) && !cache.value) {
              currentCache.delete(derivatives[0]);
            }
            return result;
          }
        }, {
          key: "delete",
          value: function _delete(derivativeOption) {
            if (this.has(derivativeOption)) {
              this.keys = this.keys.filter(function(item) {
                return !sameDerivativeOption(item, derivativeOption);
              });
              return this.deleteByPath(this.cache, derivativeOption);
            }
            return void 0;
          }
        }]);
        return ThemeCache2;
      }();
      _defineProperty$3(ThemeCache, "MAX_CACHE_SIZE", 20);
      _defineProperty$3(ThemeCache, "MAX_CACHE_OFFSET", 5);
      var uuid$3 = 0;
      var Theme = /* @__PURE__ */ function() {
        function Theme2(derivatives) {
          _classCallCheck$1(this, Theme2);
          _defineProperty$3(this, "derivatives", void 0);
          _defineProperty$3(this, "id", void 0);
          this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
          this.id = uuid$3;
          if (derivatives.length === 0) {
            warning$2(derivatives.length > 0);
          }
          uuid$3 += 1;
        }
        _createClass$1(Theme2, [{
          key: "getDerivativeToken",
          value: function getDerivativeToken(token2) {
            return this.derivatives.reduce(function(result, derivative2) {
              return derivative2(token2, result);
            }, void 0);
          }
        }]);
        return Theme2;
      }();
      var cacheThemes = new ThemeCache();
      function createTheme(derivatives) {
        var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
        if (!cacheThemes.has(derivativeArr)) {
          cacheThemes.set(derivativeArr, new Theme(derivativeArr));
        }
        return cacheThemes.get(derivativeArr);
      }
      function noSplit(list) {
        list.notSplit = true;
        return list;
      }
      ({
        // Inset
        inset: ["top", "right", "bottom", "left"],
        insetBlock: ["top", "bottom"],
        insetBlockStart: ["top"],
        insetBlockEnd: ["bottom"],
        insetInline: ["left", "right"],
        insetInlineStart: ["left"],
        insetInlineEnd: ["right"],
        // Margin
        marginBlock: ["marginTop", "marginBottom"],
        marginBlockStart: ["marginTop"],
        marginBlockEnd: ["marginBottom"],
        marginInline: ["marginLeft", "marginRight"],
        marginInlineStart: ["marginLeft"],
        marginInlineEnd: ["marginRight"],
        // Padding
        paddingBlock: ["paddingTop", "paddingBottom"],
        paddingBlockStart: ["paddingTop"],
        paddingBlockEnd: ["paddingBottom"],
        paddingInline: ["paddingLeft", "paddingRight"],
        paddingInlineStart: ["paddingLeft"],
        paddingInlineEnd: ["paddingRight"],
        // Border
        borderBlock: noSplit(["borderTop", "borderBottom"]),
        borderBlockStart: noSplit(["borderTop"]),
        borderBlockEnd: noSplit(["borderBottom"]),
        borderInline: noSplit(["borderLeft", "borderRight"]),
        borderInlineStart: noSplit(["borderLeft"]),
        borderInlineEnd: noSplit(["borderRight"]),
        // Border width
        borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
        borderBlockStartWidth: ["borderTopWidth"],
        borderBlockEndWidth: ["borderBottomWidth"],
        borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
        borderInlineStartWidth: ["borderLeftWidth"],
        borderInlineEndWidth: ["borderRightWidth"],
        // Border style
        borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
        borderBlockStartStyle: ["borderTopStyle"],
        borderBlockEndStyle: ["borderBottomStyle"],
        borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
        borderInlineStartStyle: ["borderLeftStyle"],
        borderInlineEndStyle: ["borderRightStyle"],
        // Border color
        borderBlockColor: ["borderTopColor", "borderBottomColor"],
        borderBlockStartColor: ["borderTopColor"],
        borderBlockEndColor: ["borderBottomColor"],
        borderInlineColor: ["borderLeftColor", "borderRightColor"],
        borderInlineStartColor: ["borderLeftColor"],
        borderInlineEndColor: ["borderRightColor"],
        // Border radius
        borderStartStartRadius: ["borderTopLeftRadius"],
        borderStartEndRadius: ["borderTopRightRadius"],
        borderEndStartRadius: ["borderBottomLeftRadius"],
        borderEndEndRadius: ["borderBottomRightRadius"]
      });
      var IconContext = /* @__PURE__ */ React.createContext({});
      const Context$2 = IconContext;
      function _toArray(arr) {
        return _arrayWithHoles$5(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableRest$5();
      }
      function get(entity, path) {
        var current = entity;
        for (var i2 = 0; i2 < path.length; i2 += 1) {
          if (current === null || current === void 0) {
            return void 0;
          }
          current = current[path[i2]];
        }
        return current;
      }
      function internalSet(entity, paths, value, removeIfUndefined) {
        if (!paths.length) {
          return value;
        }
        var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
        var clone;
        if (!entity && typeof path === "number") {
          clone = [];
        } else if (Array.isArray(entity)) {
          clone = _toConsumableArray(entity);
        } else {
          clone = _objectSpread2({}, entity);
        }
        if (removeIfUndefined && value === void 0 && restPath.length === 1) {
          delete clone[path][restPath[0]];
        } else {
          clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
        }
        return clone;
      }
      function set(entity, paths, value) {
        var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
          return entity;
        }
        return internalSet(entity, paths, value, removeIfUndefined);
      }
      function isObject(obj) {
        return _typeof$3(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
      }
      function createEmpty(source) {
        return Array.isArray(source) ? [] : {};
      }
      var keys$3 = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
      function merge$1() {
        for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        var clone = createEmpty(sources[0]);
        sources.forEach(function(src2) {
          function internalMerge(path, parentLoopSet) {
            var loopSet = new Set(parentLoopSet);
            var value = get(src2, path);
            var isArr = Array.isArray(value);
            if (isArr || isObject(value)) {
              if (!loopSet.has(value)) {
                loopSet.add(value);
                var originValue = get(clone, path);
                if (isArr) {
                  clone = set(clone, path, []);
                } else if (!originValue || _typeof$3(originValue) !== "object") {
                  clone = set(clone, path, createEmpty(value));
                }
                keys$3(value).forEach(function(key2) {
                  internalMerge([].concat(_toConsumableArray(path), [key2]), loopSet);
                });
              }
            } else {
              clone = set(clone, path, value);
            }
          }
          internalMerge([]);
        });
        return clone;
      }
      const ValidateMessagesContext = /* @__PURE__ */ React.createContext(void 0);
      const enUS$1 = {
        // Options.jsx
        items_per_page: "/ page",
        jump_to: "Go to",
        jump_to_confirm: "confirm",
        page: "Page",
        // Pagination.jsx
        prev_page: "Previous Page",
        next_page: "Next Page",
        prev_5: "Previous 5 Pages",
        next_5: "Next 5 Pages",
        prev_3: "Previous 3 Pages",
        next_3: "Next 3 Pages",
        page_size: "Page Size"
      };
      var locale$2 = {
        locale: "en_US",
        today: "Today",
        now: "Now",
        backToToday: "Back to today",
        ok: "OK",
        clear: "Clear",
        month: "Month",
        year: "Year",
        timeSelect: "select time",
        dateSelect: "select date",
        weekSelect: "Choose a week",
        monthSelect: "Choose a month",
        yearSelect: "Choose a year",
        decadeSelect: "Choose a decade",
        yearFormat: "YYYY",
        dateFormat: "M/D/YYYY",
        dayFormat: "D",
        dateTimeFormat: "M/D/YYYY HH:mm:ss",
        monthBeforeYear: true,
        previousMonth: "Previous month (PageUp)",
        nextMonth: "Next month (PageDown)",
        previousYear: "Last year (Control + left)",
        nextYear: "Next year (Control + right)",
        previousDecade: "Last decade",
        nextDecade: "Next decade",
        previousCentury: "Last century",
        nextCentury: "Next century"
      };
      const locale$1 = {
        placeholder: "Select time",
        rangePlaceholder: ["Start time", "End time"]
      };
      const TimePicker = locale$1;
      const locale = {
        lang: Object.assign({
          placeholder: "Select date",
          yearPlaceholder: "Select year",
          quarterPlaceholder: "Select quarter",
          monthPlaceholder: "Select month",
          weekPlaceholder: "Select week",
          rangePlaceholder: ["Start date", "End date"],
          rangeYearPlaceholder: ["Start year", "End year"],
          rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
          rangeMonthPlaceholder: ["Start month", "End month"],
          rangeWeekPlaceholder: ["Start week", "End week"]
        }, locale$2),
        timePickerLocale: Object.assign({}, TimePicker)
      };
      const enUS = locale;
      const typeTemplate$1 = "${label} is not a valid ${type}";
      const localeValues = {
        locale: "en",
        Pagination: enUS$1,
        DatePicker: enUS,
        TimePicker,
        Calendar: enUS,
        global: {
          placeholder: "Please select"
        },
        Table: {
          filterTitle: "Filter menu",
          filterConfirm: "OK",
          filterReset: "Reset",
          filterEmptyText: "No filters",
          filterCheckall: "Select all items",
          filterSearchPlaceholder: "Search in filters",
          emptyText: "No data",
          selectAll: "Select current page",
          selectInvert: "Invert current page",
          selectNone: "Clear all data",
          selectionAll: "Select all data",
          sortTitle: "Sort",
          expand: "Expand row",
          collapse: "Collapse row",
          triggerDesc: "Click to sort descending",
          triggerAsc: "Click to sort ascending",
          cancelSort: "Click to cancel sorting"
        },
        Tour: {
          Next: "Next",
          Previous: "Previous",
          Finish: "Finish"
        },
        Modal: {
          okText: "OK",
          cancelText: "Cancel",
          justOkText: "OK"
        },
        Popconfirm: {
          okText: "OK",
          cancelText: "Cancel"
        },
        Transfer: {
          titles: ["", ""],
          searchPlaceholder: "Search here",
          itemUnit: "item",
          itemsUnit: "items",
          remove: "Remove",
          selectCurrent: "Select current page",
          removeCurrent: "Remove current page",
          selectAll: "Select all data",
          removeAll: "Remove all data",
          selectInvert: "Invert current page"
        },
        Upload: {
          uploading: "Uploading...",
          removeFile: "Remove file",
          uploadError: "Upload error",
          previewFile: "Preview file",
          downloadFile: "Download file"
        },
        Empty: {
          description: "No data"
        },
        Icon: {
          icon: "icon"
        },
        Text: {
          edit: "Edit",
          copy: "Copy",
          copied: "Copied",
          expand: "Expand"
        },
        PageHeader: {
          back: "Back"
        },
        Form: {
          optional: "(optional)",
          defaultValidateMessages: {
            default: "Field validation error for ${label}",
            required: "Please enter ${label}",
            enum: "${label} must be one of [${enum}]",
            whitespace: "${label} cannot be a blank character",
            date: {
              format: "${label} date format is invalid",
              parse: "${label} cannot be converted to a date",
              invalid: "${label} is an invalid date"
            },
            types: {
              string: typeTemplate$1,
              method: typeTemplate$1,
              array: typeTemplate$1,
              object: typeTemplate$1,
              number: typeTemplate$1,
              date: typeTemplate$1,
              boolean: typeTemplate$1,
              integer: typeTemplate$1,
              float: typeTemplate$1,
              regexp: typeTemplate$1,
              email: typeTemplate$1,
              url: typeTemplate$1,
              hex: typeTemplate$1
            },
            string: {
              len: "${label} must be ${len} characters",
              min: "${label} must be at least ${min} characters",
              max: "${label} must be up to ${max} characters",
              range: "${label} must be between ${min}-${max} characters"
            },
            number: {
              len: "${label} must be equal to ${len}",
              min: "${label} must be minimum ${min}",
              max: "${label} must be maximum ${max}",
              range: "${label} must be between ${min}-${max}"
            },
            array: {
              len: "Must be ${len} ${label}",
              min: "At least ${min} ${label}",
              max: "At most ${max} ${label}",
              range: "The amount of ${label} must be between ${min}-${max}"
            },
            pattern: {
              mismatch: "${label} does not match the pattern ${pattern}"
            }
          }
        },
        Image: {
          preview: "Preview"
        },
        QRCode: {
          expired: "QR code expired",
          refresh: "Refresh"
        },
        ColorPicker: {
          presetEmpty: "Empty"
        }
      };
      const defaultLocale = localeValues;
      let runtimeLocale = Object.assign({}, defaultLocale.Modal);
      function changeConfirmLocale(newLocale) {
        if (newLocale) {
          runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
        } else {
          runtimeLocale = Object.assign({}, defaultLocale.Modal);
        }
      }
      function getConfirmLocale() {
        return runtimeLocale;
      }
      const LocaleContext = /* @__PURE__ */ React.createContext(void 0);
      const LocaleContext$1 = LocaleContext;
      const useLocale = (componentName, defaultLocale$1) => {
        const fullLocale = React__namespace.useContext(LocaleContext$1);
        const getLocale = React__namespace.useMemo(() => {
          var _a;
          const locale2 = defaultLocale$1 || defaultLocale[componentName];
          const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
          return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
        }, [componentName, defaultLocale$1, fullLocale]);
        const getLocaleCode = React__namespace.useMemo(() => {
          const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
          if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
            return defaultLocale.locale;
          }
          return localeCode;
        }, [fullLocale]);
        return [getLocale, getLocaleCode];
      };
      const useLocale$1 = useLocale;
      const ANT_MARK = "internalMark";
      const LocaleProvider = (props) => {
        const {
          locale: locale2 = {},
          children,
          _ANT_MARK__
        } = props;
        React__namespace.useEffect(() => {
          changeConfirmLocale(locale2 && locale2.Modal);
          return () => {
            changeConfirmLocale();
          };
        }, [locale2]);
        const getMemoizedContextValue = React__namespace.useMemo(() => Object.assign(Object.assign({}, locale2), {
          exist: true
        }), [locale2]);
        return /* @__PURE__ */ React__namespace.createElement(LocaleContext$1.Provider, {
          value: getMemoizedContextValue
        }, children);
      };
      const LocaleProvider$1 = LocaleProvider;
      const version$1 = "5.6.3";
      const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
      function bound01(n2, max) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var isPercent = isPercentage(n2);
        n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
        if (isPercent) {
          n2 = parseInt(String(n2 * max), 10) / 100;
        }
        if (Math.abs(n2 - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
        } else {
          n2 = n2 % max / parseFloat(String(max));
        }
        return n2;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n2) {
        return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          return "".concat(Number(n2) * 100, "%");
        }
        return n2;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r2, g2, b2) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g2, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var s = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s = 0;
          h2 = 0;
        } else {
          var d2 = max - min;
          s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, l: l2 };
      }
      function hue2rgb(p2, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s, l2) {
        var r2;
        var g2;
        var b2;
        h2 = bound01(h2, 360);
        s = bound01(s, 100);
        l2 = bound01(l2, 100);
        if (s === 0) {
          g2 = l2;
          b2 = l2;
          r2 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
          var p2 = 2 * l2 - q2;
          r2 = hue2rgb(p2, q2, h2 + 1 / 3);
          g2 = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHsv(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var v2 = max;
        var d2 = max - min;
        var s = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, v: v2 };
      }
      function hsvToRgb(h2, s, v2) {
        h2 = bound01(h2, 360) * 6;
        s = bound01(s, 100);
        v2 = bound01(v2, 100);
        var i2 = Math.floor(h2);
        var f2 = h2 - i2;
        var p2 = v2 * (1 - s);
        var q2 = v2 * (1 - f2 * s);
        var t2 = v2 * (1 - (1 - f2) * s);
        var mod = i2 % 6;
        var r2 = [v2, q2, p2, p2, t2, v2][mod];
        var g2 = [t2, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t2, v2, v2, q2][mod];
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHex(r2, g2, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r2, g2, b2, a, allow4Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match2 = matchers.rgb.exec(color);
        if (match2) {
          return { r: match2[1], g: match2[2], b: match2[3] };
        }
        match2 = matchers.rgba.exec(color);
        if (match2) {
          return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
        }
        match2 = matchers.hsl.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], l: match2[3] };
        }
        match2 = matchers.hsla.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
        }
        match2 = matchers.hsv.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], v: match2[3] };
        }
        match2 = matchers.hsva.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
        }
        match2 = matchers.hex8.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            a: convertHexToDecimal(match2[4]),
            format: named ? "name" : "hex8"
          };
        }
        match2 = matchers.hex6.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            format: named ? "name" : "hex"
          };
        }
        match2 = matchers.hex4.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1] + match2[1]),
            g: parseIntFromHex(match2[2] + match2[2]),
            b: parseIntFromHex(match2[3] + match2[3]),
            a: convertHexToDecimal(match2[4] + match2[4]),
            format: named ? "name" : "hex8"
          };
        }
        match2 = matchers.hex3.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1] + match2[1]),
            g: parseIntFromHex(match2[2] + match2[2]),
            b: parseIntFromHex(match2[3] + match2[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s = this.toHsl().s;
            return s === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r2 = Math.round(this.r);
            var g2 = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
              var _b = _a[_i], key2 = _b[0], value = _b[1];
              if (hex === value) {
                return key2;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n2) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n2;
            for (var i2 = 1; i2 < n2; i2++) {
              result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      var hueStep = 2;
      var saturationStep = 0.16;
      var saturationStep2 = 0.05;
      var brightnessStep1 = 0.05;
      var brightnessStep2 = 0.15;
      var lightColorCount = 5;
      var darkColorCount = 4;
      var darkColorMap = [{
        index: 7,
        opacity: 0.15
      }, {
        index: 6,
        opacity: 0.25
      }, {
        index: 5,
        opacity: 0.3
      }, {
        index: 5,
        opacity: 0.45
      }, {
        index: 5,
        opacity: 0.65
      }, {
        index: 5,
        opacity: 0.85
      }, {
        index: 4,
        opacity: 0.9
      }, {
        index: 3,
        opacity: 0.95
      }, {
        index: 2,
        opacity: 0.97
      }, {
        index: 1,
        opacity: 0.98
      }];
      function toHsv(_ref) {
        var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
        var hsv = rgbToHsv(r2, g2, b2);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v
        };
      }
      function toHex(_ref2) {
        var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
        return "#".concat(rgbToHex(r2, g2, b2, false));
      }
      function mix(rgb1, rgb2, amount) {
        var p2 = amount / 100;
        var rgb = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b
        };
        return rgb;
      }
      function getHue(hsv, i2, light) {
        var hue;
        if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
          hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
        } else {
          hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
        }
        if (hue < 0) {
          hue += 360;
        } else if (hue >= 360) {
          hue -= 360;
        }
        return hue;
      }
      function getSaturation(hsv, i2, light) {
        if (hsv.h === 0 && hsv.s === 0) {
          return hsv.s;
        }
        var saturation;
        if (light) {
          saturation = hsv.s - saturationStep * i2;
        } else if (i2 === darkColorCount) {
          saturation = hsv.s + saturationStep;
        } else {
          saturation = hsv.s + saturationStep2 * i2;
        }
        if (saturation > 1) {
          saturation = 1;
        }
        if (light && i2 === lightColorCount && saturation > 0.1) {
          saturation = 0.1;
        }
        if (saturation < 0.06) {
          saturation = 0.06;
        }
        return Number(saturation.toFixed(2));
      }
      function getValue$2(hsv, i2, light) {
        var value;
        if (light) {
          value = hsv.v + brightnessStep1 * i2;
        } else {
          value = hsv.v - brightnessStep2 * i2;
        }
        if (value > 1) {
          value = 1;
        }
        return Number(value.toFixed(2));
      }
      function generate$1(color) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var patterns = [];
        var pColor = inputToRGB(color);
        for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
          var hsv = toHsv(pColor);
          var colorString = toHex(inputToRGB({
            h: getHue(hsv, i2, true),
            s: getSaturation(hsv, i2, true),
            v: getValue$2(hsv, i2, true)
          }));
          patterns.push(colorString);
        }
        patterns.push(toHex(pColor));
        for (var _i = 1; _i <= darkColorCount; _i += 1) {
          var _hsv = toHsv(pColor);
          var _colorString = toHex(inputToRGB({
            h: getHue(_hsv, _i),
            s: getSaturation(_hsv, _i),
            v: getValue$2(_hsv, _i)
          }));
          patterns.push(_colorString);
        }
        if (opts.theme === "dark") {
          return darkColorMap.map(function(_ref3) {
            var index2 = _ref3.index, opacity = _ref3.opacity;
            var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
            return darkColorString;
          });
        }
        return patterns;
      }
      var presetPrimaryColors = {
        red: "#F5222D",
        volcano: "#FA541C",
        orange: "#FA8C16",
        gold: "#FAAD14",
        yellow: "#FADB14",
        lime: "#A0D911",
        green: "#52C41A",
        cyan: "#13C2C2",
        blue: "#1677FF",
        geekblue: "#2F54EB",
        purple: "#722ED1",
        magenta: "#EB2F96",
        grey: "#666666"
      };
      var presetPalettes = {};
      var presetDarkPalettes = {};
      Object.keys(presetPrimaryColors).forEach(function(key2) {
        presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
        presetPalettes[key2].primary = presetPalettes[key2][5];
        presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
          theme: "dark",
          backgroundColor: "#141414"
        });
        presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
      });
      var blue = presetPalettes.blue;
      const genControlHeight = (token2) => {
        const {
          controlHeight
        } = token2;
        return {
          controlHeightSM: controlHeight * 0.75,
          controlHeightXS: controlHeight * 0.5,
          controlHeightLG: controlHeight * 1.25
        };
      };
      const genControlHeight$1 = genControlHeight;
      function genSizeMapToken$1(token2) {
        const {
          sizeUnit,
          sizeStep
        } = token2;
        return {
          sizeXXL: sizeUnit * (sizeStep + 8),
          sizeXL: sizeUnit * (sizeStep + 4),
          sizeLG: sizeUnit * (sizeStep + 2),
          sizeMD: sizeUnit * (sizeStep + 1),
          sizeMS: sizeUnit * sizeStep,
          size: sizeUnit * sizeStep,
          sizeSM: sizeUnit * (sizeStep - 1),
          sizeXS: sizeUnit * (sizeStep - 2),
          sizeXXS: sizeUnit * (sizeStep - 3)
          // 4
        };
      }
      const defaultPresetColors = {
        blue: "#1677ff",
        purple: "#722ED1",
        cyan: "#13C2C2",
        green: "#52C41A",
        magenta: "#EB2F96",
        pink: "#eb2f96",
        red: "#F5222D",
        orange: "#FA8C16",
        yellow: "#FADB14",
        volcano: "#FA541C",
        geekblue: "#2F54EB",
        gold: "#FAAD14",
        lime: "#A0D911"
      };
      const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
        // Color
        colorPrimary: "#1677ff",
        colorSuccess: "#52c41a",
        colorWarning: "#faad14",
        colorError: "#ff4d4f",
        colorInfo: "#1677ff",
        colorTextBase: "",
        colorBgBase: "",
        // Font
        fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
        fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
        fontSize: 14,
        // Line
        lineWidth: 1,
        lineType: "solid",
        // Motion
        motionUnit: 0.1,
        motionBase: 0,
        motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
        motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
        motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
        motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
        motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
        motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
        motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
        motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
        // Radius
        borderRadius: 6,
        // Size
        sizeUnit: 4,
        sizeStep: 4,
        sizePopupArrow: 16,
        // Control Base
        controlHeight: 32,
        // zIndex
        zIndexBase: 0,
        zIndexPopupBase: 1e3,
        // Image
        opacityImage: 1,
        // Wireframe
        wireframe: false,
        // Motion
        motion: true
      });
      const seedToken$1 = seedToken;
      function genColorMapToken(seed, _ref) {
        let {
          generateColorPalettes: generateColorPalettes2,
          generateNeutralColorPalettes: generateNeutralColorPalettes2
        } = _ref;
        const {
          colorSuccess: colorSuccessBase,
          colorWarning: colorWarningBase,
          colorError: colorErrorBase,
          colorInfo: colorInfoBase,
          colorPrimary: colorPrimaryBase,
          colorBgBase,
          colorTextBase
        } = seed;
        const primaryColors = generateColorPalettes2(colorPrimaryBase);
        const successColors = generateColorPalettes2(colorSuccessBase);
        const warningColors = generateColorPalettes2(colorWarningBase);
        const errorColors = generateColorPalettes2(colorErrorBase);
        const infoColors = generateColorPalettes2(colorInfoBase);
        const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
        return Object.assign(Object.assign({}, neutralColors), {
          colorPrimaryBg: primaryColors[1],
          colorPrimaryBgHover: primaryColors[2],
          colorPrimaryBorder: primaryColors[3],
          colorPrimaryBorderHover: primaryColors[4],
          colorPrimaryHover: primaryColors[5],
          colorPrimary: primaryColors[6],
          colorPrimaryActive: primaryColors[7],
          colorPrimaryTextHover: primaryColors[8],
          colorPrimaryText: primaryColors[9],
          colorPrimaryTextActive: primaryColors[10],
          colorSuccessBg: successColors[1],
          colorSuccessBgHover: successColors[2],
          colorSuccessBorder: successColors[3],
          colorSuccessBorderHover: successColors[4],
          colorSuccessHover: successColors[4],
          colorSuccess: successColors[6],
          colorSuccessActive: successColors[7],
          colorSuccessTextHover: successColors[8],
          colorSuccessText: successColors[9],
          colorSuccessTextActive: successColors[10],
          colorErrorBg: errorColors[1],
          colorErrorBgHover: errorColors[2],
          colorErrorBorder: errorColors[3],
          colorErrorBorderHover: errorColors[4],
          colorErrorHover: errorColors[5],
          colorError: errorColors[6],
          colorErrorActive: errorColors[7],
          colorErrorTextHover: errorColors[8],
          colorErrorText: errorColors[9],
          colorErrorTextActive: errorColors[10],
          colorWarningBg: warningColors[1],
          colorWarningBgHover: warningColors[2],
          colorWarningBorder: warningColors[3],
          colorWarningBorderHover: warningColors[4],
          colorWarningHover: warningColors[4],
          colorWarning: warningColors[6],
          colorWarningActive: warningColors[7],
          colorWarningTextHover: warningColors[8],
          colorWarningText: warningColors[9],
          colorWarningTextActive: warningColors[10],
          colorInfoBg: infoColors[1],
          colorInfoBgHover: infoColors[2],
          colorInfoBorder: infoColors[3],
          colorInfoBorderHover: infoColors[4],
          colorInfoHover: infoColors[4],
          colorInfo: infoColors[6],
          colorInfoActive: infoColors[7],
          colorInfoTextHover: infoColors[8],
          colorInfoText: infoColors[9],
          colorInfoTextActive: infoColors[10],
          colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
          colorWhite: "#fff"
        });
      }
      const genRadius = (radiusBase) => {
        let radiusLG = radiusBase;
        let radiusSM = radiusBase;
        let radiusXS = radiusBase;
        let radiusOuter = radiusBase;
        if (radiusBase < 6 && radiusBase >= 5) {
          radiusLG = radiusBase + 1;
        } else if (radiusBase < 16 && radiusBase >= 6) {
          radiusLG = radiusBase + 2;
        } else if (radiusBase >= 16) {
          radiusLG = 16;
        }
        if (radiusBase < 7 && radiusBase >= 5) {
          radiusSM = 4;
        } else if (radiusBase < 8 && radiusBase >= 7) {
          radiusSM = 5;
        } else if (radiusBase < 14 && radiusBase >= 8) {
          radiusSM = 6;
        } else if (radiusBase < 16 && radiusBase >= 14) {
          radiusSM = 7;
        } else if (radiusBase >= 16) {
          radiusSM = 8;
        }
        if (radiusBase < 6 && radiusBase >= 2) {
          radiusXS = 1;
        } else if (radiusBase >= 6) {
          radiusXS = 2;
        }
        if (radiusBase > 4 && radiusBase < 8) {
          radiusOuter = 4;
        } else if (radiusBase >= 8) {
          radiusOuter = 6;
        }
        return {
          borderRadius: radiusBase > 16 ? 16 : radiusBase,
          borderRadiusXS: radiusXS,
          borderRadiusSM: radiusSM,
          borderRadiusLG: radiusLG,
          borderRadiusOuter: radiusOuter
        };
      };
      const genRadius$1 = genRadius;
      function genCommonMapToken(token2) {
        const {
          motionUnit,
          motionBase,
          borderRadius,
          lineWidth
        } = token2;
        return Object.assign({
          // motion
          motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
          motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
          motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
          // line
          lineWidthBold: lineWidth + 1
        }, genRadius$1(borderRadius));
      }
      const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
      const getSolidColor$1 = (baseColor, brightness) => {
        const instance = new TinyColor(baseColor);
        return instance.darken(brightness).toHexString();
      };
      const generateColorPalettes$1 = (baseColor) => {
        const colors = generate$1(baseColor);
        return {
          1: colors[0],
          2: colors[1],
          3: colors[2],
          4: colors[3],
          5: colors[4],
          6: colors[5],
          7: colors[6],
          8: colors[4],
          9: colors[5],
          10: colors[6]
          // 8: colors[7],
          // 9: colors[8],
          // 10: colors[9],
        };
      };
      const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
        const colorBgBase = bgBaseColor || "#fff";
        const colorTextBase = textBaseColor || "#000";
        return {
          colorBgBase,
          colorTextBase,
          colorText: getAlphaColor$2(colorTextBase, 0.88),
          colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
          colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
          colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
          colorFill: getAlphaColor$2(colorTextBase, 0.15),
          colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
          colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
          colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
          colorBgLayout: getSolidColor$1(colorBgBase, 4),
          colorBgContainer: getSolidColor$1(colorBgBase, 0),
          colorBgElevated: getSolidColor$1(colorBgBase, 0),
          colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
          colorBorder: getSolidColor$1(colorBgBase, 15),
          colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
        };
      };
      function getFontSizes(base) {
        const fontSizes = new Array(10).fill(null).map((_, index2) => {
          const i2 = index2 - 1;
          const baseSize = base * Math.pow(2.71828, i2 / 5);
          const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
          return Math.floor(intSize / 2) * 2;
        });
        fontSizes[1] = base;
        return fontSizes.map((size) => {
          const height = size + 8;
          return {
            size,
            lineHeight: height / size
          };
        });
      }
      const genFontMapToken = (fontSize) => {
        const fontSizePairs = getFontSizes(fontSize);
        const fontSizes = fontSizePairs.map((pair) => pair.size);
        const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
        return {
          fontSizeSM: fontSizes[0],
          fontSize: fontSizes[1],
          fontSizeLG: fontSizes[2],
          fontSizeXL: fontSizes[3],
          fontSizeHeading1: fontSizes[6],
          fontSizeHeading2: fontSizes[5],
          fontSizeHeading3: fontSizes[4],
          fontSizeHeading4: fontSizes[3],
          fontSizeHeading5: fontSizes[2],
          lineHeight: lineHeights[1],
          lineHeightLG: lineHeights[2],
          lineHeightSM: lineHeights[0],
          lineHeightHeading1: lineHeights[6],
          lineHeightHeading2: lineHeights[5],
          lineHeightHeading3: lineHeights[4],
          lineHeightHeading4: lineHeights[3],
          lineHeightHeading5: lineHeights[2]
        };
      };
      const genFontMapToken$1 = genFontMapToken;
      function derivative$2(token2) {
        const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
          const colors = generate$1(token2[colorKey]);
          return new Array(10).fill(1).reduce((prev2, _, i2) => {
            prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
            prev2[`${colorKey}${i2 + 1}`] = colors[i2];
            return prev2;
          }, {});
        }).reduce((prev2, cur) => {
          prev2 = Object.assign(Object.assign({}, prev2), cur);
          return prev2;
        }, {});
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
          generateColorPalettes: generateColorPalettes$1,
          generateNeutralColorPalettes: generateNeutralColorPalettes$1
        })), genFontMapToken$1(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
      }
      function isStableColor(color) {
        return color >= 0 && color <= 255;
      }
      function getAlphaColor$1(frontColor, backgroundColor) {
        const {
          r: fR,
          g: fG,
          b: fB,
          a: originAlpha
        } = new TinyColor(frontColor).toRgb();
        if (originAlpha < 1) {
          return frontColor;
        }
        const {
          r: bR,
          g: bG,
          b: bB
        } = new TinyColor(backgroundColor).toRgb();
        for (let fA = 0.01; fA <= 1; fA += 0.01) {
          const r2 = Math.round((fR - bR * (1 - fA)) / fA);
          const g2 = Math.round((fG - bG * (1 - fA)) / fA);
          const b2 = Math.round((fB - bB * (1 - fA)) / fA);
          if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
            return new TinyColor({
              r: r2,
              g: g2,
              b: b2,
              a: Math.round(fA * 100) / 100
            }).toRgbString();
          }
        }
        return new TinyColor({
          r: fR,
          g: fG,
          b: fB,
          a: 1
        }).toRgbString();
      }
      var __rest$j = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function formatToken(derivativeToken) {
        const {
          override
        } = derivativeToken, restToken = __rest$j(derivativeToken, ["override"]);
        const overrideTokens = Object.assign({}, override);
        Object.keys(seedToken$1).forEach((token2) => {
          delete overrideTokens[token2];
        });
        const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
        const screenXS = 480;
        const screenSM = 576;
        const screenMD = 768;
        const screenLG = 992;
        const screenXL = 1200;
        const screenXXL = 1600;
        if (mergedToken.motion === false) {
          const fastDuration = "0s";
          mergedToken.motionDurationFast = fastDuration;
          mergedToken.motionDurationMid = fastDuration;
          mergedToken.motionDurationSlow = fastDuration;
        }
        const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
          colorLink: mergedToken.colorInfoText,
          colorLinkHover: mergedToken.colorInfoHover,
          colorLinkActive: mergedToken.colorInfoActive,
          // ============== Background ============== //
          colorFillContent: mergedToken.colorFillSecondary,
          colorFillContentHover: mergedToken.colorFill,
          colorFillAlter: mergedToken.colorFillQuaternary,
          colorBgContainerDisabled: mergedToken.colorFillTertiary,
          // ============== Split ============== //
          colorBorderBg: mergedToken.colorBgContainer,
          colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
          // ============== Text ============== //
          colorTextPlaceholder: mergedToken.colorTextQuaternary,
          colorTextDisabled: mergedToken.colorTextQuaternary,
          colorTextHeading: mergedToken.colorText,
          colorTextLabel: mergedToken.colorTextSecondary,
          colorTextDescription: mergedToken.colorTextTertiary,
          colorTextLightSolid: mergedToken.colorWhite,
          colorHighlight: mergedToken.colorError,
          colorBgTextHover: mergedToken.colorFillSecondary,
          colorBgTextActive: mergedToken.colorFill,
          colorIcon: mergedToken.colorTextTertiary,
          colorIconHover: mergedToken.colorText,
          colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
          colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
          // Font
          fontSizeIcon: mergedToken.fontSizeSM,
          // Line
          lineWidthFocus: mergedToken.lineWidth * 4,
          // Control
          lineWidth: mergedToken.lineWidth,
          controlOutlineWidth: mergedToken.lineWidth * 2,
          // Checkbox size and expand icon size
          controlInteractiveSize: mergedToken.controlHeight / 2,
          controlItemBgHover: mergedToken.colorFillTertiary,
          controlItemBgActive: mergedToken.colorPrimaryBg,
          controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
          controlItemBgActiveDisabled: mergedToken.colorFill,
          controlTmpOutline: mergedToken.colorFillQuaternary,
          controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
          lineType: mergedToken.lineType,
          borderRadius: mergedToken.borderRadius,
          borderRadiusXS: mergedToken.borderRadiusXS,
          borderRadiusSM: mergedToken.borderRadiusSM,
          borderRadiusLG: mergedToken.borderRadiusLG,
          fontWeightStrong: 600,
          opacityLoading: 0.65,
          linkDecoration: "none",
          linkHoverDecoration: "none",
          linkFocusDecoration: "none",
          controlPaddingHorizontal: 12,
          controlPaddingHorizontalSM: 8,
          paddingXXS: mergedToken.sizeXXS,
          paddingXS: mergedToken.sizeXS,
          paddingSM: mergedToken.sizeSM,
          padding: mergedToken.size,
          paddingMD: mergedToken.sizeMD,
          paddingLG: mergedToken.sizeLG,
          paddingXL: mergedToken.sizeXL,
          paddingContentHorizontalLG: mergedToken.sizeLG,
          paddingContentVerticalLG: mergedToken.sizeMS,
          paddingContentHorizontal: mergedToken.sizeMS,
          paddingContentVertical: mergedToken.sizeSM,
          paddingContentHorizontalSM: mergedToken.size,
          paddingContentVerticalSM: mergedToken.sizeXS,
          marginXXS: mergedToken.sizeXXS,
          marginXS: mergedToken.sizeXS,
          marginSM: mergedToken.sizeSM,
          margin: mergedToken.size,
          marginMD: mergedToken.sizeMD,
          marginLG: mergedToken.sizeLG,
          marginXL: mergedToken.sizeXL,
          marginXXL: mergedToken.sizeXXL,
          boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
          screenXS,
          screenXSMin: screenXS,
          screenXSMax: screenSM - 1,
          screenSM,
          screenSMMin: screenSM,
          screenSMMax: screenMD - 1,
          screenMD,
          screenMDMin: screenMD,
          screenMDMax: screenLG - 1,
          screenLG,
          screenLGMin: screenLG,
          screenLGMax: screenXL - 1,
          screenXL,
          screenXLMin: screenXL,
          screenXLMax: screenXXL - 1,
          screenXXL,
          screenXXLMin: screenXXL,
          boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
          boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
          boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
        }), overrideTokens);
        return aliasToken;
      }
      function useEvent(callback) {
        var fnRef = React__namespace.useRef();
        fnRef.current = callback;
        var memoFn = React__namespace.useCallback(function() {
          var _fnRef$current;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
        }, []);
        return memoFn;
      }
      var useInternalLayoutEffect = canUseDom() ? React__namespace.useLayoutEffect : React__namespace.useEffect;
      var useLayoutEffect = function useLayoutEffect2(callback, deps) {
        var firstMountRef = React__namespace.useRef(true);
        useInternalLayoutEffect(function() {
          return callback(firstMountRef.current);
        }, deps);
        useInternalLayoutEffect(function() {
          firstMountRef.current = false;
          return function() {
            firstMountRef.current = true;
          };
        }, []);
      };
      var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
        useLayoutEffect(function(firstMount) {
          if (!firstMount) {
            return callback();
          }
        }, deps);
      };
      function useSafeState(defaultValue) {
        var destroyRef = React__namespace.useRef(false);
        var _React$useState = React__namespace.useState(defaultValue), _React$useState2 = _slicedToArray$5(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
        React__namespace.useEffect(function() {
          destroyRef.current = false;
          return function() {
            destroyRef.current = true;
          };
        }, []);
        function safeSetState(updater, ignoreDestroy) {
          if (ignoreDestroy && destroyRef.current) {
            return;
          }
          setValue(updater);
        }
        return [value, safeSetState];
      }
      function hasValue(value) {
        return value !== void 0;
      }
      function useMergedState(defaultStateValue, option) {
        var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
        var _useState = useSafeState(function() {
          if (hasValue(value)) {
            return value;
          } else if (hasValue(defaultValue)) {
            return typeof defaultValue === "function" ? defaultValue() : defaultValue;
          } else {
            return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
          }
        }), _useState2 = _slicedToArray$5(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
        var mergedValue = value !== void 0 ? value : innerValue;
        var postMergedValue = postState ? postState(mergedValue) : mergedValue;
        var onChangeFn = useEvent(onChange);
        var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray$5(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
        useLayoutUpdateEffect(function() {
          var prev2 = prevValue[0];
          if (innerValue !== prev2) {
            onChangeFn(innerValue, prev2);
          }
        }, [prevValue]);
        useLayoutUpdateEffect(function() {
          if (!hasValue(value)) {
            setInnerValue(value);
          }
        }, [value]);
        var triggerChange = useEvent(function(updater, ignoreDestroy) {
          setInnerValue(updater, ignoreDestroy);
          setPrevValue([mergedValue], ignoreDestroy);
        });
        return [postMergedValue, triggerChange];
      }
      const defaultIconPrefixCls = "anticon";
      const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
        if (customizePrefixCls)
          return customizePrefixCls;
        return suffixCls ? `ant-${suffixCls}` : "ant";
      };
      const ConfigContext = /* @__PURE__ */ React__namespace.createContext({
        // We provide a default function for Context without provider
        getPrefixCls: defaultGetPrefixCls,
        iconPrefixCls: defaultIconPrefixCls
      });
      const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
        const unitWidth = width / 2;
        const ax = 0;
        const ay = unitWidth;
        const bx = outerRadius * 1 / Math.sqrt(2);
        const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
        const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
        const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
        const dx = 2 * unitWidth - cx;
        const dy = cy;
        const ex = 2 * unitWidth - bx;
        const ey = by;
        const fx = 2 * unitWidth - ax;
        const fy = ay;
        const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
        const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
        return {
          pointerEvents: "none",
          width,
          height: width,
          overflow: "hidden",
          "&::before": {
            position: "absolute",
            bottom: 0,
            insetInlineStart: 0,
            width,
            height: width / 2,
            background: bgColor,
            clipPath: {
              _multi_value_: true,
              value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
            },
            content: '""'
          },
          "&::after": {
            content: '""',
            position: "absolute",
            width: shadowWidth,
            height: shadowWidth,
            bottom: 0,
            insetInline: 0,
            margin: "auto",
            borderRadius: {
              _skip_check_: true,
              value: `0 0 ${innerRadius}px 0`
            },
            transform: "translateY(50%) rotate(-135deg)",
            boxShadow,
            zIndex: 0,
            background: "transparent"
          }
        };
      };
      const textEllipsis = {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis"
      };
      const resetComponent = (token2) => ({
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        fontSize: token2.fontSize,
        // font-variant: @font-variant-base;
        lineHeight: token2.lineHeight,
        listStyle: "none",
        // font-feature-settings: @font-feature-settings-base;
        fontFamily: token2.fontFamily
      });
      const resetIcon = () => ({
        display: "inline-flex",
        alignItems: "center",
        color: "inherit",
        fontStyle: "normal",
        lineHeight: 0,
        textAlign: "center",
        textTransform: "none",
        // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
        verticalAlign: "-0.125em",
        textRendering: "optimizeLegibility",
        "-webkit-font-smoothing": "antialiased",
        "-moz-osx-font-smoothing": "grayscale",
        "> *": {
          lineHeight: 1
        },
        svg: {
          display: "inline-block"
        }
      });
      const clearFix = () => ({
        // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
        "&::before": {
          display: "table",
          content: '""'
        },
        "&::after": {
          // https://github.com/ant-design/ant-design/issues/21864
          display: "table",
          clear: "both",
          content: '""'
        }
      });
      const genLinkStyle = (token2) => ({
        a: {
          color: token2.colorLink,
          textDecoration: token2.linkDecoration,
          backgroundColor: "transparent",
          outline: "none",
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          "-webkit-text-decoration-skip": "objects",
          "&:hover": {
            color: token2.colorLinkHover
          },
          "&:active": {
            color: token2.colorLinkActive
          },
          [`&:active,
  &:hover`]: {
            textDecoration: token2.linkHoverDecoration,
            outline: 0
          },
          // https://github.com/ant-design/ant-design/issues/22503
          "&:focus": {
            textDecoration: token2.linkFocusDecoration,
            outline: 0
          },
          "&[disabled]": {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        }
      });
      const genCommonStyle = (token2, componentPrefixCls) => {
        const {
          fontFamily,
          fontSize
        } = token2;
        const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
        return {
          [rootPrefixSelector]: {
            fontFamily,
            fontSize,
            boxSizing: "border-box",
            "&::before, &::after": {
              boxSizing: "border-box"
            },
            [rootPrefixSelector]: {
              boxSizing: "border-box",
              "&::before, &::after": {
                boxSizing: "border-box"
              }
            }
          }
        };
      };
      const genFocusOutline = (token2) => ({
        outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
        outlineOffset: 1,
        transition: "outline-offset 0s, outline 0s"
      });
      const genFocusStyle = (token2) => ({
        "&:focus-visible": Object.assign({}, genFocusOutline(token2))
      });
      function genComponentStyleHook(component, styleFn, getDefaultToken, options) {
        return (prefixCls) => {
          const [theme2, token2, hashId] = useToken$2();
          const {
            getPrefixCls,
            iconPrefixCls,
            csp
          } = React.useContext(ConfigContext);
          const rootPrefixCls = getPrefixCls();
          const sharedConfig = {
            theme: theme2,
            token: token2,
            hashId,
            nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
          };
          useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
            path: ["Shared", rootPrefixCls]
          }), () => [{
            // Link
            "&": genLinkStyle(token2)
          }]);
          return [useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
            path: [component, prefixCls, iconPrefixCls]
          }), () => {
            const {
              token: proxyToken,
              flush
            } = statisticToken(token2);
            const customComponentToken = Object.assign({}, token2[component]);
            if (options === null || options === void 0 ? void 0 : options.deprecatedTokens) {
              const {
                deprecatedTokens
              } = options;
              deprecatedTokens.forEach((_ref) => {
                let [oldTokenKey, newTokenKey] = _ref;
                var _a;
                if ((customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey]) || (customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[newTokenKey])) {
                  (_a = customComponentToken[newTokenKey]) !== null && _a !== void 0 ? _a : customComponentToken[newTokenKey] = customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey];
                }
              });
            }
            const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(merge(proxyToken, customComponentToken !== null && customComponentToken !== void 0 ? customComponentToken : {})) : getDefaultToken;
            const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), customComponentToken);
            const componentCls = `.${prefixCls}`;
            const mergedToken = merge(proxyToken, {
              componentCls,
              prefixCls,
              iconCls: `.${iconPrefixCls}`,
              antCls: `.${rootPrefixCls}`
            }, mergedComponentToken);
            const styleInterpolation = styleFn(mergedToken, {
              hashId,
              prefixCls,
              rootPrefixCls,
              iconPrefixCls,
              overrideComponentToken: customComponentToken
            });
            flush(component, mergedComponentToken);
            return [(options === null || options === void 0 ? void 0 : options.resetStyle) === false ? null : genCommonStyle(token2, prefixCls), styleInterpolation];
          }), hashId];
        };
      }
      const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
      let recording = true;
      function merge() {
        for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
          objs[_key] = arguments[_key];
        }
        if (!enableStatistic) {
          return Object.assign.apply(Object, [{}].concat(objs));
        }
        recording = false;
        const ret = {};
        objs.forEach((obj) => {
          const keys2 = Object.keys(obj);
          keys2.forEach((key2) => {
            Object.defineProperty(ret, key2, {
              configurable: true,
              enumerable: true,
              get: () => obj[key2]
            });
          });
        });
        recording = true;
        return ret;
      }
      function noop() {
      }
      function statisticToken(token2) {
        let tokenKeys2;
        let proxy = token2;
        let flush = noop;
        if (enableStatistic) {
          tokenKeys2 = /* @__PURE__ */ new Set();
          proxy = new Proxy(token2, {
            get(obj, prop) {
              if (recording) {
                tokenKeys2.add(prop);
              }
              return obj[prop];
            }
          });
          flush = (componentName, componentToken) => {
            ({
              global: Array.from(tokenKeys2),
              component: componentToken
            });
          };
        }
        return {
          token: proxy,
          keys: tokenKeys2,
          flush
        };
      }
      function genPresetColor(token2, genCss) {
        return PresetColors.reduce((prev2, colorKey) => {
          const lightColor = token2[`${colorKey}1`];
          const lightBorderColor = token2[`${colorKey}3`];
          const darkColor = token2[`${colorKey}6`];
          const textColor = token2[`${colorKey}7`];
          return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
            lightColor,
            lightBorderColor,
            darkColor,
            textColor
          }));
        }, {});
      }
      const defaultTheme = createTheme(derivative$2);
      const defaultConfig = {
        token: seedToken$1,
        hashed: true
      };
      const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
      function useToken$2() {
        const {
          token: rootDesignToken,
          hashed,
          theme: theme2,
          components
        } = React.useContext(DesignTokenContext);
        const salt = `${version$1}-${hashed || ""}`;
        const mergedTheme = theme2 || defaultTheme;
        const [token2, hashId] = useCacheToken(mergedTheme, [seedToken$1, rootDesignToken], {
          salt,
          override: Object.assign({
            override: rootDesignToken
          }, components),
          formatToken
        });
        return [mergedTheme, token2, hashed ? hashId : ""];
      }
      const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
      function getStyle(globalPrefixCls2, theme2) {
        const variables = {};
        const formatColor = (color, updater) => {
          let clone = color.clone();
          clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
          return clone.toRgbString();
        };
        const fillColor = (colorVal, type2) => {
          const baseColor = new TinyColor(colorVal);
          const colorPalettes = generate$1(baseColor.toRgbString());
          variables[`${type2}-color`] = formatColor(baseColor);
          variables[`${type2}-color-disabled`] = colorPalettes[1];
          variables[`${type2}-color-hover`] = colorPalettes[4];
          variables[`${type2}-color-active`] = colorPalettes[6];
          variables[`${type2}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
          variables[`${type2}-color-deprecated-bg`] = colorPalettes[0];
          variables[`${type2}-color-deprecated-border`] = colorPalettes[2];
        };
        if (theme2.primaryColor) {
          fillColor(theme2.primaryColor, "primary");
          const primaryColor = new TinyColor(theme2.primaryColor);
          const primaryColors = generate$1(primaryColor.toRgbString());
          primaryColors.forEach((color, index2) => {
            variables[`primary-${index2 + 1}`] = color;
          });
          variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
          variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
          variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
          variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
          variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
          const primaryActiveColor = new TinyColor(primaryColors[0]);
          variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
          variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
        }
        if (theme2.successColor) {
          fillColor(theme2.successColor, "success");
        }
        if (theme2.warningColor) {
          fillColor(theme2.warningColor, "warning");
        }
        if (theme2.errorColor) {
          fillColor(theme2.errorColor, "error");
        }
        if (theme2.infoColor) {
          fillColor(theme2.infoColor, "info");
        }
        const cssList = Object.keys(variables).map((key2) => `--${globalPrefixCls2}-${key2}: ${variables[key2]};`);
        return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
      }
      function registerTheme(globalPrefixCls2, theme2) {
        const style2 = getStyle(globalPrefixCls2, theme2);
        if (canUseDom()) {
          updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
        }
      }
      const DisabledContext = /* @__PURE__ */ React__namespace.createContext(false);
      const DisabledContextProvider = (_ref) => {
        let {
          children,
          disabled
        } = _ref;
        const originDisabled = React__namespace.useContext(DisabledContext);
        return /* @__PURE__ */ React__namespace.createElement(DisabledContext.Provider, {
          value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
        }, children);
      };
      const DisabledContext$1 = DisabledContext;
      const useSize = (customSize) => {
        const size = React.useContext(SizeContext$1);
        const mergedSize = React.useMemo(() => {
          if (!customSize) {
            return size;
          }
          if (typeof customSize === "string") {
            return customSize !== null && customSize !== void 0 ? customSize : size;
          }
          if (customSize instanceof Function) {
            return customSize(size);
          }
          return size;
        }, [customSize, size]);
        return mergedSize;
      };
      const useSize$1 = useSize;
      const SizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
      const SizeContextProvider = (_ref) => {
        let {
          children,
          size
        } = _ref;
        const mergedSize = useSize$1(size);
        return /* @__PURE__ */ React__namespace.createElement(SizeContext.Provider, {
          value: mergedSize
        }, children);
      };
      const SizeContext$1 = SizeContext;
      function useConfig() {
        const componentDisabled = React.useContext(DisabledContext$1);
        const componentSize = React.useContext(SizeContext$1);
        return {
          componentDisabled,
          componentSize
        };
      }
      function useTheme(theme2, parentTheme) {
        const themeConfig = theme2 || {};
        const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
        const mergedTheme = useMemo(() => {
          if (!theme2) {
            return parentTheme;
          }
          const mergedComponents = Object.assign({}, parentThemeConfig.components);
          Object.keys(theme2.components || {}).forEach((componentName) => {
            mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
          });
          return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
            token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
            components: mergedComponents
          });
        }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
          const nextTheme = next2[index2];
          return !isEqual$1(prevTheme, nextTheme, true);
        }));
        return mergedTheme;
      }
      var _excluded$b = ["children"];
      var Context$1 = /* @__PURE__ */ React__namespace.createContext({});
      function MotionProvider(_ref) {
        var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$b);
        return /* @__PURE__ */ React__namespace.createElement(Context$1.Provider, {
          value: props
        }, children);
      }
      var DomWrapper = /* @__PURE__ */ function(_React$Component) {
        _inherits(DomWrapper2, _React$Component);
        var _super = _createSuper(DomWrapper2);
        function DomWrapper2() {
          _classCallCheck$1(this, DomWrapper2);
          return _super.apply(this, arguments);
        }
        _createClass$1(DomWrapper2, [{
          key: "render",
          value: function render2() {
            return this.props.children;
          }
        }]);
        return DomWrapper2;
      }(React__namespace.Component);
      var STATUS_NONE = "none";
      var STATUS_APPEAR = "appear";
      var STATUS_ENTER = "enter";
      var STATUS_LEAVE = "leave";
      var STEP_NONE = "none";
      var STEP_PREPARE = "prepare";
      var STEP_START = "start";
      var STEP_ACTIVE = "active";
      var STEP_ACTIVATED = "end";
      var STEP_PREPARED = "prepared";
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
        prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
        prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
        prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
        return prefixes;
      }
      function getVendorPrefixes(domSupport, win) {
        var prefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        if (domSupport) {
          if (!("AnimationEvent" in win)) {
            delete prefixes.animationend.animation;
          }
          if (!("TransitionEvent" in win)) {
            delete prefixes.transitionend.transition;
          }
        }
        return prefixes;
      }
      var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
      var style = {};
      if (canUseDom()) {
        var _document$createEleme = document.createElement("div");
        style = _document$createEleme.style;
      }
      var prefixedEventNames = {};
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
          return prefixedEventNames[eventName];
        }
        var prefixMap = vendorPrefixes[eventName];
        if (prefixMap) {
          var stylePropList = Object.keys(prefixMap);
          var len = stylePropList.length;
          for (var i2 = 0; i2 < len; i2 += 1) {
            var styleProp = stylePropList[i2];
            if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
              prefixedEventNames[eventName] = prefixMap[styleProp];
              return prefixedEventNames[eventName];
            }
          }
        }
        return "";
      }
      var internalAnimationEndName = getVendorPrefixedEventName("animationend");
      var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
      var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
      var animationEndName = internalAnimationEndName || "animationend";
      var transitionEndName = internalTransitionEndName || "transitionend";
      function getTransitionName$1(transitionName, transitionType) {
        if (!transitionName)
          return null;
        if (_typeof$3(transitionName) === "object") {
          var type2 = transitionType.replace(/-\w/g, function(match2) {
            return match2[1].toUpperCase();
          });
          return transitionName[type2];
        }
        return "".concat(transitionName, "-").concat(transitionType);
      }
      const useDomMotionEvents = function(callback) {
        var cacheElementRef = React.useRef();
        var callbackRef = React.useRef(callback);
        callbackRef.current = callback;
        var onInternalMotionEnd = React__namespace.useCallback(function(event) {
          callbackRef.current(event);
        }, []);
        function removeMotionEvents(element) {
          if (element) {
            element.removeEventListener(transitionEndName, onInternalMotionEnd);
            element.removeEventListener(animationEndName, onInternalMotionEnd);
          }
        }
        function patchMotionEvents(element) {
          if (cacheElementRef.current && cacheElementRef.current !== element) {
            removeMotionEvents(cacheElementRef.current);
          }
          if (element && element !== cacheElementRef.current) {
            element.addEventListener(transitionEndName, onInternalMotionEnd);
            element.addEventListener(animationEndName, onInternalMotionEnd);
            cacheElementRef.current = element;
          }
        }
        React__namespace.useEffect(function() {
          return function() {
            removeMotionEvents(cacheElementRef.current);
          };
        }, []);
        return [patchMotionEvents, removeMotionEvents];
      };
      var useIsomorphicLayoutEffect = canUseDom() ? React.useLayoutEffect : React.useEffect;
      const useNextFrame = function() {
        var nextFrameRef = React__namespace.useRef(null);
        function cancelNextFrame() {
          wrapperRaf.cancel(nextFrameRef.current);
        }
        function nextFrame(callback) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
          cancelNextFrame();
          var nextFrameId = wrapperRaf(function() {
            if (delay <= 1) {
              callback({
                isCanceled: function isCanceled() {
                  return nextFrameId !== nextFrameRef.current;
                }
              });
            } else {
              nextFrame(callback, delay - 1);
            }
          });
          nextFrameRef.current = nextFrameId;
        }
        React__namespace.useEffect(function() {
          return function() {
            cancelNextFrame();
          };
        }, []);
        return [nextFrame, cancelNextFrame];
      };
      var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
      var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
      var SkipStep = false;
      var DoStep = true;
      function isActive(step) {
        return step === STEP_ACTIVE || step === STEP_ACTIVATED;
      }
      const useStepQueue = function(status, prepareOnly, callback) {
        var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray$5(_useState, 2), step = _useState2[0], setStep = _useState2[1];
        var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray$5(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
        function startQueue() {
          setStep(STEP_PREPARE, true);
        }
        var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
        useIsomorphicLayoutEffect(function() {
          if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
            var index2 = STEP_QUEUE.indexOf(step);
            var nextStep = STEP_QUEUE[index2 + 1];
            var result = callback(step);
            if (result === SkipStep) {
              setStep(nextStep, true);
            } else if (nextStep) {
              nextFrame(function(info) {
                function doNext() {
                  if (info.isCanceled())
                    return;
                  setStep(nextStep, true);
                }
                if (result === true) {
                  doNext();
                } else {
                  Promise.resolve(result).then(doNext);
                }
              });
            }
          }
        }, [status, step]);
        React__namespace.useEffect(function() {
          return function() {
            cancelNextFrame();
          };
        }, []);
        return [startQueue, step];
      };
      function useStatus(supportMotion, visible, getElement2, _ref) {
        var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
        var _useState = useSafeState(), _useState2 = _slicedToArray$5(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
        var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray$5(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
        var _useState5 = useSafeState(null), _useState6 = _slicedToArray$5(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
        var mountedRef = React.useRef(false);
        var deadlineRef = React.useRef(null);
        function getDomElement() {
          return getElement2();
        }
        var activeRef = React.useRef(false);
        function updateMotionEndStatus() {
          setStatus(STATUS_NONE, true);
          setStyle(null, true);
        }
        function onInternalMotionEnd(event) {
          var element = getDomElement();
          if (event && !event.deadline && event.target !== element) {
            return;
          }
          var currentActive = activeRef.current;
          var canEnd;
          if (status === STATUS_APPEAR && currentActive) {
            canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
          } else if (status === STATUS_ENTER && currentActive) {
            canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
          } else if (status === STATUS_LEAVE && currentActive) {
            canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
          }
          if (status !== STATUS_NONE && currentActive && canEnd !== false) {
            updateMotionEndStatus();
          }
        }
        var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray$5(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
        var getEventHandlers = function getEventHandlers2(targetStatus) {
          var _ref2, _ref3, _ref4;
          switch (targetStatus) {
            case STATUS_APPEAR:
              return _ref2 = {}, _defineProperty$3(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$3(_ref2, STEP_START, onAppearStart), _defineProperty$3(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
            case STATUS_ENTER:
              return _ref3 = {}, _defineProperty$3(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$3(_ref3, STEP_START, onEnterStart), _defineProperty$3(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
            case STATUS_LEAVE:
              return _ref4 = {}, _defineProperty$3(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$3(_ref4, STEP_START, onLeaveStart), _defineProperty$3(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
            default:
              return {};
          }
        };
        var eventHandlers = React__namespace.useMemo(function() {
          return getEventHandlers(status);
        }, [status]);
        var _useStepQueue = useStepQueue(status, !supportMotion, function(newStep) {
          if (newStep === STEP_PREPARE) {
            var onPrepare = eventHandlers[STEP_PREPARE];
            if (!onPrepare) {
              return SkipStep;
            }
            return onPrepare(getDomElement());
          }
          if (step in eventHandlers) {
            var _eventHandlers$step;
            setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
          }
          if (step === STEP_ACTIVE) {
            patchMotionEvents(getDomElement());
            if (motionDeadline > 0) {
              clearTimeout(deadlineRef.current);
              deadlineRef.current = setTimeout(function() {
                onInternalMotionEnd({
                  deadline: true
                });
              }, motionDeadline);
            }
          }
          if (step === STEP_PREPARED) {
            updateMotionEndStatus();
          }
          return DoStep;
        }), _useStepQueue2 = _slicedToArray$5(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
        var active = isActive(step);
        activeRef.current = active;
        useIsomorphicLayoutEffect(function() {
          setAsyncVisible(visible);
          var isMounted = mountedRef.current;
          mountedRef.current = true;
          var nextStatus;
          if (!isMounted && visible && motionAppear) {
            nextStatus = STATUS_APPEAR;
          }
          if (isMounted && visible && motionEnter) {
            nextStatus = STATUS_ENTER;
          }
          if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
            nextStatus = STATUS_LEAVE;
          }
          var nextEventHandlers = getEventHandlers(nextStatus);
          if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
            setStatus(nextStatus);
            startStep();
          } else {
            setStatus(STATUS_NONE);
          }
        }, [visible]);
        React.useEffect(function() {
          if (
            // Cancel appear
            status === STATUS_APPEAR && !motionAppear || // Cancel enter
            status === STATUS_ENTER && !motionEnter || // Cancel leave
            status === STATUS_LEAVE && !motionLeave
          ) {
            setStatus(STATUS_NONE);
          }
        }, [motionAppear, motionEnter, motionLeave]);
        React.useEffect(function() {
          return function() {
            mountedRef.current = false;
            clearTimeout(deadlineRef.current);
          };
        }, []);
        var firstMountChangeRef = React__namespace.useRef(false);
        React.useEffect(function() {
          if (asyncVisible) {
            firstMountChangeRef.current = true;
          }
          if (asyncVisible !== void 0 && status === STATUS_NONE) {
            if (firstMountChangeRef.current || asyncVisible) {
              onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
            }
            firstMountChangeRef.current = true;
          }
        }, [asyncVisible, status]);
        var mergedStyle = style2;
        if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
          mergedStyle = _objectSpread2({
            transition: "none"
          }, mergedStyle);
        }
        return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
      }
      function genCSSMotion(config2) {
        var transitionSupport = config2;
        if (_typeof$3(config2) === "object") {
          transitionSupport = config2.transitionSupport;
        }
        function isSupportTransition(props, contextMotion) {
          return !!(props.motionName && transitionSupport && contextMotion !== false);
        }
        var CSSMotion2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
          var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
          var _React$useContext = React__namespace.useContext(Context$1), contextMotion = _React$useContext.motion;
          var supportMotion = isSupportTransition(props, contextMotion);
          var nodeRef = React.useRef();
          var wrapperNodeRef = React.useRef();
          function getDomElement() {
            try {
              return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
            } catch (e2) {
              return null;
            }
          }
          var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray$5(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
          var renderedRef = React__namespace.useRef(mergedVisible);
          if (mergedVisible) {
            renderedRef.current = true;
          }
          var setNodeRef = React__namespace.useCallback(function(node2) {
            nodeRef.current = node2;
            fillRef(ref, node2);
          }, [ref]);
          var motionChildren;
          var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
            visible
          });
          if (!children) {
            motionChildren = null;
          } else if (status === STATUS_NONE) {
            if (mergedVisible) {
              motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
            } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
              motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
                className: leavedClassName
              }), setNodeRef);
            } else if (forceRender || !removeOnLeave && !leavedClassName) {
              motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
                style: {
                  display: "none"
                }
              }), setNodeRef);
            } else {
              motionChildren = null;
            }
          } else {
            var _classNames;
            var statusSuffix;
            if (statusStep === STEP_PREPARE) {
              statusSuffix = "prepare";
            } else if (isActive(statusStep)) {
              statusSuffix = "active";
            } else if (statusStep === STEP_START) {
              statusSuffix = "start";
            }
            var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              className: classNames(getTransitionName$1(motionName, status), (_classNames = {}, _defineProperty$3(_classNames, motionCls, motionCls && statusSuffix), _defineProperty$3(_classNames, motionName, typeof motionName === "string"), _classNames)),
              style: statusStyle
            }), setNodeRef);
          }
          if (/* @__PURE__ */ React__namespace.isValidElement(motionChildren) && supportRef(motionChildren)) {
            var _ref = motionChildren, originNodeRef = _ref.ref;
            if (!originNodeRef) {
              motionChildren = /* @__PURE__ */ React__namespace.cloneElement(motionChildren, {
                ref: setNodeRef
              });
            }
          }
          return /* @__PURE__ */ React__namespace.createElement(DomWrapper, {
            ref: wrapperNodeRef
          }, motionChildren);
        });
        CSSMotion2.displayName = "CSSMotion";
        return CSSMotion2;
      }
      const CSSMotion = genCSSMotion(supportTransition);
      var STATUS_ADD = "add";
      var STATUS_KEEP = "keep";
      var STATUS_REMOVE = "remove";
      var STATUS_REMOVED = "removed";
      function wrapKeyToObject(key2) {
        var keyObj;
        if (key2 && _typeof$3(key2) === "object" && "key" in key2) {
          keyObj = key2;
        } else {
          keyObj = {
            key: key2
          };
        }
        return _objectSpread2(_objectSpread2({}, keyObj), {}, {
          key: String(keyObj.key)
        });
      }
      function parseKeys() {
        var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        return keys2.map(wrapKeyToObject);
      }
      function diffKeys() {
        var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var list = [];
        var currentIndex = 0;
        var currentLen = currentKeys.length;
        var prevKeyObjects = parseKeys(prevKeys);
        var currentKeyObjects = parseKeys(currentKeys);
        prevKeyObjects.forEach(function(keyObj) {
          var hit = false;
          for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
            var currentKeyObj = currentKeyObjects[i2];
            if (currentKeyObj.key === keyObj.key) {
              if (currentIndex < i2) {
                list = list.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
                  return _objectSpread2(_objectSpread2({}, obj), {}, {
                    status: STATUS_ADD
                  });
                }));
                currentIndex = i2;
              }
              list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
                status: STATUS_KEEP
              }));
              currentIndex += 1;
              hit = true;
              break;
            }
          }
          if (!hit) {
            list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
              status: STATUS_REMOVE
            }));
          }
        });
        if (currentIndex < currentLen) {
          list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
            return _objectSpread2(_objectSpread2({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
        }
        var keys2 = {};
        list.forEach(function(_ref) {
          var key2 = _ref.key;
          keys2[key2] = (keys2[key2] || 0) + 1;
        });
        var duplicatedKeys = Object.keys(keys2).filter(function(key2) {
          return keys2[key2] > 1;
        });
        duplicatedKeys.forEach(function(matchKey) {
          list = list.filter(function(_ref2) {
            var key2 = _ref2.key, status = _ref2.status;
            return key2 !== matchKey || status !== STATUS_REMOVE;
          });
          list.forEach(function(node2) {
            if (node2.key === matchKey) {
              node2.status = STATUS_KEEP;
            }
          });
        });
        return list;
      }
      var _excluded$a = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2 = ["status"];
      var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
      function genCSSMotionList(transitionSupport) {
        var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
        var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
          _inherits(CSSMotionList3, _React$Component);
          var _super = _createSuper(CSSMotionList3);
          function CSSMotionList3() {
            var _this;
            _classCallCheck$1(this, CSSMotionList3);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _super.call.apply(_super, [this].concat(args));
            _defineProperty$3(_assertThisInitialized(_this), "state", {
              keyEntities: []
            });
            _defineProperty$3(_assertThisInitialized(_this), "removeKey", function(removeKey) {
              var keyEntities = _this.state.keyEntities;
              var nextKeyEntities = keyEntities.map(function(entity) {
                if (entity.key !== removeKey)
                  return entity;
                return _objectSpread2(_objectSpread2({}, entity), {}, {
                  status: STATUS_REMOVED
                });
              });
              _this.setState({
                keyEntities: nextKeyEntities
              });
              return nextKeyEntities.filter(function(_ref) {
                var status = _ref.status;
                return status !== STATUS_REMOVED;
              }).length;
            });
            return _this;
          }
          _createClass$1(CSSMotionList3, [{
            key: "render",
            value: function render2() {
              var _this2 = this;
              var keyEntities = this.state.keyEntities;
              var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties(_this$props, _excluded$a);
              var Component = component || React__namespace.Fragment;
              var motionProps = {};
              MOTION_PROP_NAMES.forEach(function(prop) {
                motionProps[prop] = restProps[prop];
                delete restProps[prop];
              });
              delete restProps.keys;
              return /* @__PURE__ */ React__namespace.createElement(Component, restProps, keyEntities.map(function(_ref2) {
                var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2);
                var visible = status === STATUS_ADD || status === STATUS_KEEP;
                return /* @__PURE__ */ React__namespace.createElement(CSSMotion$1, _extends$1({}, motionProps, {
                  key: eventProps.key,
                  visible,
                  eventProps,
                  onVisibleChanged: function onVisibleChanged(changedVisible) {
                    _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                      key: eventProps.key
                    });
                    if (!changedVisible) {
                      var restKeysCount = _this2.removeKey(eventProps.key);
                      if (restKeysCount === 0 && onAllRemoved) {
                        onAllRemoved();
                      }
                    }
                  }
                }), children);
              }));
            }
          }], [{
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(_ref3, _ref4) {
              var keys2 = _ref3.keys;
              var keyEntities = _ref4.keyEntities;
              var parsedKeyObjects = parseKeys(keys2);
              var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
              return {
                keyEntities: mixedKeyEntities.filter(function(entity) {
                  var prevEntity = keyEntities.find(function(_ref5) {
                    var key2 = _ref5.key;
                    return entity.key === key2;
                  });
                  if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                    return false;
                  }
                  return true;
                })
              };
            }
            // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
          }]);
          return CSSMotionList3;
        }(React__namespace.Component);
        _defineProperty$3(CSSMotionList2, "defaultProps", {
          component: "div"
        });
        return CSSMotionList2;
      }
      const CSSMotionList = genCSSMotionList(supportTransition);
      function MotionWrapper(props) {
        const {
          children
        } = props;
        const [, token2] = useToken$2();
        const {
          motion
        } = token2;
        const needWrapMotionProviderRef = React__namespace.useRef(false);
        needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion === false;
        if (needWrapMotionProviderRef.current) {
          return /* @__PURE__ */ React__namespace.createElement(MotionProvider, {
            motion
          }, children);
        }
        return children;
      }
      const useStyle$7 = (iconPrefixCls, csp) => {
        const [theme2, token2] = useToken$2();
        return useStyleRegister({
          theme: theme2,
          token: token2,
          hashId: "",
          path: ["ant-design-icons", iconPrefixCls],
          nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
        }, () => [{
          [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
            [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
              display: "block"
            }
          })
        }]);
      };
      const useStyle$8 = useStyle$7;
      var __rest$i = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button"];
      const defaultPrefixCls = "ant";
      let globalPrefixCls;
      let globalIconPrefixCls;
      let globalTheme;
      function getGlobalPrefixCls() {
        return globalPrefixCls || defaultPrefixCls;
      }
      function getGlobalIconPrefixCls() {
        return globalIconPrefixCls || defaultIconPrefixCls;
      }
      function isLegacyTheme(theme2) {
        return Object.keys(theme2).some((key2) => key2.endsWith("Color"));
      }
      const setGlobalConfig = (_ref) => {
        let {
          prefixCls,
          iconPrefixCls,
          theme: theme2
        } = _ref;
        if (prefixCls !== void 0) {
          globalPrefixCls = prefixCls;
        }
        if (iconPrefixCls !== void 0) {
          globalIconPrefixCls = iconPrefixCls;
        }
        if (theme2) {
          if (isLegacyTheme(theme2)) {
            registerTheme(getGlobalPrefixCls(), theme2);
          } else {
            globalTheme = theme2;
          }
        }
      };
      const globalConfig = () => ({
        getPrefixCls: (suffixCls, customizePrefixCls) => {
          if (customizePrefixCls)
            return customizePrefixCls;
          return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
        },
        getIconPrefixCls: getGlobalIconPrefixCls,
        getRootPrefixCls: () => {
          if (globalPrefixCls) {
            return globalPrefixCls;
          }
          return getGlobalPrefixCls();
        },
        getTheme: () => globalTheme
      });
      const ProviderChildren = (props) => {
        const {
          children,
          csp: customCsp,
          autoInsertSpaceInButton,
          form,
          locale: locale2,
          componentSize,
          direction,
          space,
          virtual,
          dropdownMatchSelectWidth,
          popupMatchSelectWidth,
          popupOverflow,
          legacyLocale,
          parentContext,
          iconPrefixCls: customIconPrefixCls,
          theme: theme2,
          componentDisabled
        } = props;
        const getPrefixCls = React__namespace.useCallback((suffixCls, customizePrefixCls) => {
          const {
            prefixCls
          } = props;
          if (customizePrefixCls)
            return customizePrefixCls;
          const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
          return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
        }, [parentContext.getPrefixCls, props.prefixCls]);
        const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
        const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
        const csp = customCsp || parentContext.csp;
        const wrapSSR = useStyle$8(iconPrefixCls, csp);
        const mergedTheme = useTheme(theme2, parentContext.theme);
        const baseConfig = {
          csp,
          autoInsertSpaceInButton,
          locale: locale2 || legacyLocale,
          direction,
          space,
          virtual,
          popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
          popupOverflow,
          getPrefixCls,
          iconPrefixCls,
          theme: mergedTheme
        };
        const config2 = Object.assign({}, parentContext);
        Object.keys(baseConfig).forEach((key2) => {
          if (baseConfig[key2] !== void 0) {
            config2[key2] = baseConfig[key2];
          }
        });
        PASSED_PROPS.forEach((propName) => {
          const propValue = props[propName];
          if (propValue) {
            config2[propName] = propValue;
          }
        });
        const memoedConfig = useMemo(() => config2, config2, (prevConfig, currentConfig) => {
          const prevKeys = Object.keys(prevConfig);
          const currentKeys = Object.keys(currentConfig);
          return prevKeys.length !== currentKeys.length || prevKeys.some((key2) => prevConfig[key2] !== currentConfig[key2]);
        });
        const memoIconContextValue = React__namespace.useMemo(() => ({
          prefixCls: iconPrefixCls,
          csp
        }), [iconPrefixCls, csp]);
        let childNode = shouldWrapSSR ? wrapSSR(children) : children;
        const validateMessages = React__namespace.useMemo(() => {
          var _a, _b, _c;
          return merge$1(((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
        }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
        if (Object.keys(validateMessages).length > 0) {
          childNode = /* @__PURE__ */ React__namespace.createElement(ValidateMessagesContext.Provider, {
            value: validateMessages
          }, children);
        }
        if (locale2) {
          childNode = /* @__PURE__ */ React__namespace.createElement(LocaleProvider$1, {
            locale: locale2,
            _ANT_MARK__: ANT_MARK
          }, childNode);
        }
        if (iconPrefixCls || csp) {
          childNode = /* @__PURE__ */ React__namespace.createElement(Context$2.Provider, {
            value: memoIconContextValue
          }, childNode);
        }
        if (componentSize) {
          childNode = /* @__PURE__ */ React__namespace.createElement(SizeContextProvider, {
            size: componentSize
          }, childNode);
        }
        childNode = /* @__PURE__ */ React__namespace.createElement(MotionWrapper, null, childNode);
        const memoTheme = React__namespace.useMemo(() => {
          const _a = mergedTheme || {}, {
            algorithm,
            token: token2
          } = _a, rest = __rest$i(_a, ["algorithm", "token"]);
          const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
          return Object.assign(Object.assign({}, rest), {
            theme: themeObj,
            token: Object.assign(Object.assign({}, seedToken$1), token2)
          });
        }, [mergedTheme]);
        if (theme2) {
          childNode = /* @__PURE__ */ React__namespace.createElement(DesignTokenContext.Provider, {
            value: memoTheme
          }, childNode);
        }
        if (componentDisabled !== void 0) {
          childNode = /* @__PURE__ */ React__namespace.createElement(DisabledContextProvider, {
            disabled: componentDisabled
          }, childNode);
        }
        return /* @__PURE__ */ React__namespace.createElement(ConfigContext.Provider, {
          value: memoedConfig
        }, childNode);
      };
      const ConfigProvider = (props) => {
        const context = React__namespace.useContext(ConfigContext);
        const antLocale = React__namespace.useContext(LocaleContext$1);
        return /* @__PURE__ */ React__namespace.createElement(ProviderChildren, Object.assign({
          parentContext: context,
          legacyLocale: antLocale
        }, props));
      };
      ConfigProvider.ConfigContext = ConfigContext;
      ConfigProvider.SizeContext = SizeContext$1;
      ConfigProvider.config = setGlobalConfig;
      ConfigProvider.useConfig = useConfig;
      Object.defineProperty(ConfigProvider, "SizeContext", {
        get: () => {
          return SizeContext$1;
        }
      });
      const ConfigProvider$1 = ConfigProvider;
      var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
      const CheckCircleFilledSvg = CheckCircleFilled$2;
      function getRoot(ele) {
        var _ele$getRootNode;
        return ele === null || ele === void 0 ? void 0 : (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
      }
      function inShadow(ele) {
        return getRoot(ele) !== (ele === null || ele === void 0 ? void 0 : ele.ownerDocument);
      }
      function getShadowRoot(ele) {
        return inShadow(ele) ? getRoot(ele) : null;
      }
      function warning$1(valid, message) {
        warningOnce(valid, "[@ant-design/icons] ".concat(message));
      }
      function isIconDefinition(target) {
        return _typeof$3(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$3(target.icon) === "object" || typeof target.icon === "function");
      }
      function normalizeAttrs() {
        var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return Object.keys(attrs).reduce(function(acc, key2) {
          var val = attrs[key2];
          switch (key2) {
            case "class":
              acc.className = val;
              delete acc.class;
              break;
            default:
              acc[key2] = val;
          }
          return acc;
        }, {});
      }
      function generate(node2, key2, rootProps) {
        if (!rootProps) {
          return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2({
            key: key2
          }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
            return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
          }));
        }
        return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2(_objectSpread2({
          key: key2
        }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      function getSecondaryColor(primaryColor) {
        return generate$1(primaryColor)[0];
      }
      function normalizeTwoToneColors(twoToneColor) {
        if (!twoToneColor) {
          return [];
        }
        return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
      }
      var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
      var useInsertStyles = function useInsertStyles2(eleRef) {
        var _useContext = React.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
        var mergedStyleStr = iconStyles;
        if (prefixCls) {
          mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
        }
        React.useEffect(function() {
          var ele = eleRef.current;
          var shadowRoot = getShadowRoot(ele);
          updateCSS(mergedStyleStr, "@ant-design-icons", {
            prepend: true,
            csp,
            attachTo: shadowRoot
          });
        }, []);
      };
      var _excluded$9 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
      var twoToneColorPalette = {
        primaryColor: "#333",
        secondaryColor: "#E6E6E6",
        calculated: false
      };
      function setTwoToneColors(_ref) {
        var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
        twoToneColorPalette.primaryColor = primaryColor;
        twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
        twoToneColorPalette.calculated = !!secondaryColor;
      }
      function getTwoToneColors() {
        return _objectSpread2({}, twoToneColorPalette);
      }
      var IconBase = function IconBase2(props) {
        var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$9);
        var svgRef = React__namespace.useRef();
        var colors = twoToneColorPalette;
        if (primaryColor) {
          colors = {
            primaryColor,
            secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
          };
        }
        useInsertStyles(svgRef);
        warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
        if (!isIconDefinition(icon)) {
          return null;
        }
        var target = icon;
        if (target && typeof target.icon === "function") {
          target = _objectSpread2(_objectSpread2({}, target), {}, {
            icon: target.icon(colors.primaryColor, colors.secondaryColor)
          });
        }
        return generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
          className,
          onClick,
          style: style2,
          "data-icon": target.name,
          width: "1em",
          height: "1em",
          fill: "currentColor",
          "aria-hidden": "true"
        }, restProps), {}, {
          ref: svgRef
        }));
      };
      IconBase.displayName = "IconReact";
      IconBase.getTwoToneColors = getTwoToneColors;
      IconBase.setTwoToneColors = setTwoToneColors;
      const ReactIcon = IconBase;
      function setTwoToneColor(twoToneColor) {
        var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$5(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return ReactIcon.setTwoToneColors({
          primaryColor,
          secondaryColor
        });
      }
      function getTwoToneColor() {
        var colors = ReactIcon.getTwoToneColors();
        if (!colors.calculated) {
          return colors.primaryColor;
        }
        return [colors.primaryColor, colors.secondaryColor];
      }
      var _excluded$8 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
      setTwoToneColor(blue.primary);
      var Icon = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var _classNames;
        var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$8);
        var _React$useContext = React__namespace.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
        var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$3(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
        var iconTabIndex = tabIndex;
        if (iconTabIndex === void 0 && onClick) {
          iconTabIndex = -1;
        }
        var svgStyle = rotate ? {
          msTransform: "rotate(".concat(rotate, "deg)"),
          transform: "rotate(".concat(rotate, "deg)")
        } : void 0;
        var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$5(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return /* @__PURE__ */ React__namespace.createElement("span", _extends$1({
          role: "img",
          "aria-label": icon.name
        }, restProps, {
          ref,
          tabIndex: iconTabIndex,
          onClick,
          className: classString
        }), /* @__PURE__ */ React__namespace.createElement(ReactIcon, {
          icon,
          primaryColor,
          secondaryColor,
          style: svgStyle
        }));
      });
      Icon.displayName = "AntdIcon";
      Icon.getTwoToneColor = getTwoToneColor;
      Icon.setTwoToneColor = setTwoToneColor;
      const AntdIcon = Icon;
      var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: CheckCircleFilledSvg
        }));
      };
      const CheckCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CheckCircleFilled);
      var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
      const CloseCircleFilledSvg = CloseCircleFilled$2;
      var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: CloseCircleFilledSvg
        }));
      };
      const CloseCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseCircleFilled);
      var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
      const CloseOutlinedSvg = CloseOutlined$2;
      var CloseOutlined = function CloseOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: CloseOutlinedSvg
        }));
      };
      const CloseOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseOutlined);
      var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
      const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
      var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: ExclamationCircleFilledSvg
        }));
      };
      const ExclamationCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(ExclamationCircleFilled);
      var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
      const InfoCircleFilledSvg = InfoCircleFilled$2;
      var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: InfoCircleFilledSvg
        }));
      };
      const InfoCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(InfoCircleFilled);
      var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
      var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
      var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
      var ariaPrefix = "aria-";
      var dataPrefix = "data-";
      function match(key2, prefix) {
        return key2.indexOf(prefix) === 0;
      }
      function pickAttrs(props) {
        var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var mergedConfig;
        if (ariaOnly === false) {
          mergedConfig = {
            aria: true,
            data: true,
            attr: true
          };
        } else if (ariaOnly === true) {
          mergedConfig = {
            aria: true
          };
        } else {
          mergedConfig = _objectSpread2({}, ariaOnly);
        }
        var attrs = {};
        Object.keys(props).forEach(function(key2) {
          if (
            // Aria
            mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || // Data
            mergedConfig.data && match(key2, dataPrefix) || // Attr
            mergedConfig.attr && propList.includes(key2)
          ) {
            attrs[key2] = props[key2];
          }
        });
        return attrs;
      }
      const {
        isValidElement
      } = React__namespace;
      function isFragment(child) {
        return child && isValidElement(child) && child.type === React__namespace.Fragment;
      }
      function replaceElement(element, replacement, props) {
        if (!isValidElement(element)) {
          return replacement;
        }
        return /* @__PURE__ */ React__namespace.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
      }
      function cloneElement(element, props) {
        return replaceElement(element, element, props);
      }
      const t$1 = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$1 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n$1 = (t2, n2) => {
        if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
          const o2 = getComputedStyle(t2, null);
          return e$1(o2.overflowY, n2) || e$1(o2.overflowX, n2) || ((t3) => {
            const e2 = ((t4) => {
              if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
                return null;
              try {
                return t4.ownerDocument.defaultView.frameElement;
              } catch (t5) {
                return null;
              }
            })(t3);
            return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
          })(t2);
        }
        return false;
      }, o$1 = (t2, e2, n2, o2, i2, l2, r2, d2) => l2 < t2 && r2 > e2 || l2 > t2 && r2 < e2 ? 0 : l2 <= t2 && d2 <= n2 || r2 >= e2 && d2 >= n2 ? l2 - t2 - o2 : r2 > e2 && d2 < n2 || l2 < t2 && d2 > n2 ? r2 - e2 + i2 : 0, i$2 = (t2) => {
        const e2 = t2.parentElement;
        return null == e2 ? t2.getRootNode().host || null : e2;
      }, l$1 = (e2, l2) => {
        var r2, d2, s, h2;
        if ("undefined" == typeof document)
          return [];
        const { scrollMode: c2, block: f2, inline: u2, boundary: a, skipOverflowHiddenElements: g2 } = l2, m2 = "function" == typeof a ? a : (t2) => t2 !== a;
        if (!t$1(e2))
          throw new TypeError("Invalid target");
        const p2 = document.scrollingElement || document.documentElement, w2 = [];
        let W = e2;
        for (; t$1(W) && m2(W); ) {
          if (W = i$2(W), W === p2) {
            w2.push(W);
            break;
          }
          null != W && W === document.body && n$1(W) && !n$1(document.documentElement) || null != W && n$1(W, g2) && w2.push(W);
        }
        const H2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth, b2 = null != (h2 = null == (s = window.visualViewport) ? void 0 : s.height) ? h2 : innerHeight, { scrollX: v2, scrollY: y2 } = window, { height: E2, width: M, top: x2, right: I2, bottom: C2, left: R } = e2.getBoundingClientRect();
        let T = "start" === f2 || "nearest" === f2 ? x2 : "end" === f2 ? C2 : x2 + E2 / 2, V = "center" === u2 ? R + M / 2 : "end" === u2 ? I2 : R;
        const k2 = [];
        for (let t2 = 0; t2 < w2.length; t2++) {
          const e3 = w2[t2], { height: n2, width: i2, top: l3, right: r3, bottom: d3, left: s2 } = e3.getBoundingClientRect();
          if ("if-needed" === c2 && x2 >= 0 && R >= 0 && C2 <= b2 && I2 <= H2 && x2 >= l3 && C2 <= d3 && R >= s2 && I2 <= r3)
            return k2;
          const h3 = getComputedStyle(e3), a2 = parseInt(h3.borderLeftWidth, 10), g3 = parseInt(h3.borderTopWidth, 10), m3 = parseInt(h3.borderRightWidth, 10), W2 = parseInt(h3.borderBottomWidth, 10);
          let B2 = 0, D2 = 0;
          const L = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - a2 - m3 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - g3 - W2 : 0, X = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : i2 / e3.offsetWidth : 0, Y = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;
          if (p2 === e3)
            B2 = "start" === f2 ? T : "end" === f2 ? T - b2 : "nearest" === f2 ? o$1(y2, y2 + b2, b2, g3, W2, y2 + T, y2 + T + E2, E2) : T - b2 / 2, D2 = "start" === u2 ? V : "center" === u2 ? V - H2 / 2 : "end" === u2 ? V - H2 : o$1(v2, v2 + H2, H2, a2, m3, v2 + V, v2 + V + M, M), B2 = Math.max(0, B2 + y2), D2 = Math.max(0, D2 + v2);
          else {
            B2 = "start" === f2 ? T - l3 - g3 : "end" === f2 ? T - d3 + W2 + S : "nearest" === f2 ? o$1(l3, d3, n2, g3, W2 + S, T, T + E2, E2) : T - (l3 + n2 / 2) + S / 2, D2 = "start" === u2 ? V - s2 - a2 : "center" === u2 ? V - (s2 + i2 / 2) + L / 2 : "end" === u2 ? V - r3 + m3 + L : o$1(s2, r3, i2, a2, m3 + L, V, V + M, M);
            const { scrollLeft: t3, scrollTop: h4 } = e3;
            B2 = Math.max(0, Math.min(h4 + B2 / Y, e3.scrollHeight - n2 / Y + S)), D2 = Math.max(0, Math.min(t3 + D2 / X, e3.scrollWidth - i2 / X + L)), T += h4 - B2, V += t3 - D2;
          }
          k2.push({ el: e3, top: B2, left: D2 });
        }
        return k2;
      };
      const o = (e2) => false === e2 ? { block: "end", inline: "nearest" } : ((e3) => e3 === Object(e3) && 0 !== Object.keys(e3).length)(e2) ? e2 : { block: "start", inline: "nearest" };
      function t(t2, n2) {
        if (!t2.isConnected || !((e2) => {
          let o2 = e2;
          for (; o2 && o2.parentNode; ) {
            if (o2.parentNode === document)
              return true;
            o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
          }
          return false;
        })(t2))
          return;
        if (((e2) => "object" == typeof e2 && "function" == typeof e2.behavior)(n2))
          return n2.behavior(l$1(t2, n2));
        const r2 = "boolean" == typeof n2 || null == n2 ? void 0 : n2.behavior;
        for (const { el: i2, top: a, left: l2 } of l$1(t2, o(n2)))
          i2.scroll({ top: a, left: l2, behavior: r2 });
      }
      var KeyCode = {
        /**
         * MAC_ENTER
         */
        MAC_ENTER: 3,
        /**
         * BACKSPACE
         */
        BACKSPACE: 8,
        /**
         * TAB
         */
        TAB: 9,
        /**
         * NUMLOCK on FF/Safari Mac
         */
        NUM_CENTER: 12,
        // NUMLOCK on FF/Safari Mac
        /**
         * ENTER
         */
        ENTER: 13,
        /**
         * SHIFT
         */
        SHIFT: 16,
        /**
         * CTRL
         */
        CTRL: 17,
        /**
         * ALT
         */
        ALT: 18,
        /**
         * PAUSE
         */
        PAUSE: 19,
        /**
         * CAPS_LOCK
         */
        CAPS_LOCK: 20,
        /**
         * ESC
         */
        ESC: 27,
        /**
         * SPACE
         */
        SPACE: 32,
        /**
         * PAGE_UP
         */
        PAGE_UP: 33,
        // also NUM_NORTH_EAST
        /**
         * PAGE_DOWN
         */
        PAGE_DOWN: 34,
        // also NUM_SOUTH_EAST
        /**
         * END
         */
        END: 35,
        // also NUM_SOUTH_WEST
        /**
         * HOME
         */
        HOME: 36,
        // also NUM_NORTH_WEST
        /**
         * LEFT
         */
        LEFT: 37,
        // also NUM_WEST
        /**
         * UP
         */
        UP: 38,
        // also NUM_NORTH
        /**
         * RIGHT
         */
        RIGHT: 39,
        // also NUM_EAST
        /**
         * DOWN
         */
        DOWN: 40,
        // also NUM_SOUTH
        /**
         * PRINT_SCREEN
         */
        PRINT_SCREEN: 44,
        /**
         * INSERT
         */
        INSERT: 45,
        // also NUM_INSERT
        /**
         * DELETE
         */
        DELETE: 46,
        // also NUM_DELETE
        /**
         * ZERO
         */
        ZERO: 48,
        /**
         * ONE
         */
        ONE: 49,
        /**
         * TWO
         */
        TWO: 50,
        /**
         * THREE
         */
        THREE: 51,
        /**
         * FOUR
         */
        FOUR: 52,
        /**
         * FIVE
         */
        FIVE: 53,
        /**
         * SIX
         */
        SIX: 54,
        /**
         * SEVEN
         */
        SEVEN: 55,
        /**
         * EIGHT
         */
        EIGHT: 56,
        /**
         * NINE
         */
        NINE: 57,
        /**
         * QUESTION_MARK
         */
        QUESTION_MARK: 63,
        // needs localization
        /**
         * A
         */
        A: 65,
        /**
         * B
         */
        B: 66,
        /**
         * C
         */
        C: 67,
        /**
         * D
         */
        D: 68,
        /**
         * E
         */
        E: 69,
        /**
         * F
         */
        F: 70,
        /**
         * G
         */
        G: 71,
        /**
         * H
         */
        H: 72,
        /**
         * I
         */
        I: 73,
        /**
         * J
         */
        J: 74,
        /**
         * K
         */
        K: 75,
        /**
         * L
         */
        L: 76,
        /**
         * M
         */
        M: 77,
        /**
         * N
         */
        N: 78,
        /**
         * O
         */
        O: 79,
        /**
         * P
         */
        P: 80,
        /**
         * Q
         */
        Q: 81,
        /**
         * R
         */
        R: 82,
        /**
         * S
         */
        S: 83,
        /**
         * T
         */
        T: 84,
        /**
         * U
         */
        U: 85,
        /**
         * V
         */
        V: 86,
        /**
         * W
         */
        W: 87,
        /**
         * X
         */
        X: 88,
        /**
         * Y
         */
        Y: 89,
        /**
         * Z
         */
        Z: 90,
        /**
         * META
         */
        META: 91,
        // WIN_KEY_LEFT
        /**
         * WIN_KEY_RIGHT
         */
        WIN_KEY_RIGHT: 92,
        /**
         * CONTEXT_MENU
         */
        CONTEXT_MENU: 93,
        /**
         * NUM_ZERO
         */
        NUM_ZERO: 96,
        /**
         * NUM_ONE
         */
        NUM_ONE: 97,
        /**
         * NUM_TWO
         */
        NUM_TWO: 98,
        /**
         * NUM_THREE
         */
        NUM_THREE: 99,
        /**
         * NUM_FOUR
         */
        NUM_FOUR: 100,
        /**
         * NUM_FIVE
         */
        NUM_FIVE: 101,
        /**
         * NUM_SIX
         */
        NUM_SIX: 102,
        /**
         * NUM_SEVEN
         */
        NUM_SEVEN: 103,
        /**
         * NUM_EIGHT
         */
        NUM_EIGHT: 104,
        /**
         * NUM_NINE
         */
        NUM_NINE: 105,
        /**
         * NUM_MULTIPLY
         */
        NUM_MULTIPLY: 106,
        /**
         * NUM_PLUS
         */
        NUM_PLUS: 107,
        /**
         * NUM_MINUS
         */
        NUM_MINUS: 109,
        /**
         * NUM_PERIOD
         */
        NUM_PERIOD: 110,
        /**
         * NUM_DIVISION
         */
        NUM_DIVISION: 111,
        /**
         * F1
         */
        F1: 112,
        /**
         * F2
         */
        F2: 113,
        /**
         * F3
         */
        F3: 114,
        /**
         * F4
         */
        F4: 115,
        /**
         * F5
         */
        F5: 116,
        /**
         * F6
         */
        F6: 117,
        /**
         * F7
         */
        F7: 118,
        /**
         * F8
         */
        F8: 119,
        /**
         * F9
         */
        F9: 120,
        /**
         * F10
         */
        F10: 121,
        /**
         * F11
         */
        F11: 122,
        /**
         * F12
         */
        F12: 123,
        /**
         * NUMLOCK
         */
        NUMLOCK: 144,
        /**
         * SEMICOLON
         */
        SEMICOLON: 186,
        // needs localization
        /**
         * DASH
         */
        DASH: 189,
        // needs localization
        /**
         * EQUALS
         */
        EQUALS: 187,
        // needs localization
        /**
         * COMMA
         */
        COMMA: 188,
        // needs localization
        /**
         * PERIOD
         */
        PERIOD: 190,
        // needs localization
        /**
         * SLASH
         */
        SLASH: 191,
        // needs localization
        /**
         * APOSTROPHE
         */
        APOSTROPHE: 192,
        // needs localization
        /**
         * SINGLE_QUOTE
         */
        SINGLE_QUOTE: 222,
        // needs localization
        /**
         * OPEN_SQUARE_BRACKET
         */
        OPEN_SQUARE_BRACKET: 219,
        // needs localization
        /**
         * BACKSLASH
         */
        BACKSLASH: 220,
        // needs localization
        /**
         * CLOSE_SQUARE_BRACKET
         */
        CLOSE_SQUARE_BRACKET: 221,
        // needs localization
        /**
         * WIN_KEY
         */
        WIN_KEY: 224,
        /**
         * MAC_FF_META
         */
        MAC_FF_META: 224,
        // Firefox (Gecko) fires this for the meta key instead of 91
        /**
         * WIN_IME
         */
        WIN_IME: 229,
        // ======================== Function ========================
        /**
         * whether text and modified key is entered at the same time.
         */
        isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
          var keyCode = e2.keyCode;
          if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
          keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
            return false;
          }
          switch (keyCode) {
            case KeyCode.ALT:
            case KeyCode.CAPS_LOCK:
            case KeyCode.CONTEXT_MENU:
            case KeyCode.CTRL:
            case KeyCode.DOWN:
            case KeyCode.END:
            case KeyCode.ESC:
            case KeyCode.HOME:
            case KeyCode.INSERT:
            case KeyCode.LEFT:
            case KeyCode.MAC_FF_META:
            case KeyCode.META:
            case KeyCode.NUMLOCK:
            case KeyCode.NUM_CENTER:
            case KeyCode.PAGE_DOWN:
            case KeyCode.PAGE_UP:
            case KeyCode.PAUSE:
            case KeyCode.PRINT_SCREEN:
            case KeyCode.RIGHT:
            case KeyCode.SHIFT:
            case KeyCode.UP:
            case KeyCode.WIN_KEY:
            case KeyCode.WIN_KEY_RIGHT:
              return false;
            default:
              return true;
          }
        },
        /**
         * whether character is entered.
         */
        isCharacterKey: function isCharacterKey(keyCode) {
          if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
            return true;
          }
          if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
            return true;
          }
          if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
            return true;
          }
          if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
            return true;
          }
          switch (keyCode) {
            case KeyCode.SPACE:
            case KeyCode.QUESTION_MARK:
            case KeyCode.NUM_PLUS:
            case KeyCode.NUM_MINUS:
            case KeyCode.NUM_PERIOD:
            case KeyCode.NUM_DIVISION:
            case KeyCode.SEMICOLON:
            case KeyCode.DASH:
            case KeyCode.EQUALS:
            case KeyCode.COMMA:
            case KeyCode.PERIOD:
            case KeyCode.SLASH:
            case KeyCode.APOSTROPHE:
            case KeyCode.SINGLE_QUOTE:
            case KeyCode.OPEN_SQUARE_BRACKET:
            case KeyCode.BACKSLASH:
            case KeyCode.CLOSE_SQUARE_BRACKET:
              return true;
            default:
              return false;
          }
        }
      };
      var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
      const LoadingOutlinedSvg = LoadingOutlined$2;
      var LoadingOutlined = function LoadingOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: LoadingOutlinedSvg
        }));
      };
      const LoadingOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(LoadingOutlined);
      function usePatchElement() {
        const [elements, setElements] = React__namespace.useState([]);
        const patchElement = React__namespace.useCallback((element) => {
          setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
          return () => {
            setElements((originElements) => originElements.filter((ele) => ele !== element));
          };
        }, []);
        return [elements, patchElement];
      }
      function _regeneratorRuntime() {
        _regeneratorRuntime = function _regeneratorRuntime2() {
          return exports2;
        };
        var exports2 = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key2, desc) {
          obj[key2] = desc.value;
        }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key2, value) {
          return Object.defineProperty(obj, key2, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          }), obj[key2];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function define3(obj, key2, value) {
            return obj[key2] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
          return defineProperty2(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self2, context)
          }), generator;
        }
        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }
        exports2.wrap = wrap;
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define2(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto2 = Object.getPrototypeOf, NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method2) {
            define2(prototype, method2, function(arg) {
              return this._invoke(method2, arg);
            });
          });
        }
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method2, arg, resolve, reject) {
            var record = tryCatch(generator[method2], generator, arg);
            if ("throw" !== record.type) {
              var result = record.arg, value = result.value;
              return value && "object" == _typeof$3(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
            reject(record.arg);
          }
          var previousPromise;
          defineProperty2(this, "_invoke", {
            value: function value(method2, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method2, arg, resolve, reject);
                });
              }
              return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
          });
        }
        function makeInvokeMethod(innerFn, self2, context) {
          var state = "suspendedStart";
          return function(method2, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method2)
                throw arg;
              return doneResult();
            }
            for (context.method = method2, context.arg = arg; ; ) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context.method)
                context.sent = context._sent = context.arg;
              else if ("throw" === context.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else
                "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self2, context);
              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                  continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }
              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method, method2 = delegate.iterator[methodName];
          if (void 0 === method2)
            return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
          var record = tryCatch(method2, delegate.iterator, context.arg);
          if ("throw" === record.type)
            return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
          var info = record.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal", delete record.arg, entry.completion = record;
        }
        function Context2(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
        }
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod)
              return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next)
              return iterable;
            if (!isNaN(iterable.length)) {
              var i2 = -1, next2 = function next3() {
                for (; ++i2 < iterable.length; )
                  if (hasOwn2.call(iterable, i2))
                    return next3.value = iterable[i2], next3.done = false, next3;
                return next3.value = void 0, next3.done = true, next3;
              };
              return next2.next = next2;
            }
          }
          return {
            next: doneResult
          };
        }
        function doneResult() {
          return {
            value: void 0,
            done: true
          };
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: true
        }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: true
        }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports2.mark = function(genFun) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
        }, exports2.awrap = function(arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
          return this;
        }), define2(Gp, "toString", function() {
          return "[object Generator]";
        }), exports2.keys = function(val) {
          var object2 = Object(val), keys2 = [];
          for (var key2 in object2)
            keys2.push(key2);
          return keys2.reverse(), function next2() {
            for (; keys2.length; ) {
              var key3 = keys2.pop();
              if (key3 in object2)
                return next2.value = key3, next2.done = false, next2;
            }
            return next2.done = true, next2;
          };
        }, exports2.values = values, Context2.prototype = {
          constructor: Context2,
          reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
              for (var name in this)
                "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          },
          stop: function stop() {
            this.done = true;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type)
              throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done)
              throw exception;
            var context = this;
            function handle(loc, caught) {
              return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
            }
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2], record = entry.completion;
              if ("root" === entry.tryLoc)
                return handle("end");
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                } else {
                  if (!hasFinally)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(type2, arg) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
          },
          complete: function complete(record, afterLoc) {
            if ("throw" === record.type)
              throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.finallyLoc === finallyLoc)
                return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if ("throw" === record.type) {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
          }
        }, exports2;
      }
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
        try {
          var info = gen[key2](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var fullClone = _objectSpread2({}, ReactDOM__default__namespace);
      var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
      var createRoot;
      try {
        var mainVersion = Number((version || "").split(".")[0]);
        if (mainVersion >= 18) {
          createRoot = fullClone.createRoot;
        }
      } catch (e2) {
      }
      function toggleWarning(skip) {
        var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$3(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
          __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
        }
      }
      var MARK = "__rc_react_root__";
      function modernRender(node2, container) {
        toggleWarning(true);
        var root = container[MARK] || createRoot(container);
        toggleWarning(false);
        root.render(node2);
        container[MARK] = root;
      }
      function legacyRender(node2, container) {
        reactRender(node2, container);
      }
      function render(node2, container) {
        if (createRoot) {
          modernRender(node2, container);
          return;
        }
        legacyRender(node2, container);
      }
      function modernUnmount(_x) {
        return _modernUnmount.apply(this, arguments);
      }
      function _modernUnmount() {
        _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", Promise.resolve().then(function() {
                    var _container$MARK;
                    (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
                    delete container[MARK];
                  }));
                case 1:
                case "end":
                  return _context.stop();
              }
          }, _callee);
        }));
        return _modernUnmount.apply(this, arguments);
      }
      function legacyUnmount(container) {
        unmountComponentAtNode(container);
      }
      function unmount(_x2) {
        return _unmount.apply(this, arguments);
      }
      function _unmount() {
        _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1)
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(createRoot !== void 0)) {
                    _context2.next = 2;
                    break;
                  }
                  return _context2.abrupt("return", modernUnmount(container));
                case 2:
                  legacyUnmount(container);
                case 3:
                case "end":
                  return _context2.stop();
              }
          }, _callee2);
        }));
        return _unmount.apply(this, arguments);
      }
      const isVisible$1 = function(element) {
        if (!element) {
          return false;
        }
        if (element instanceof Element) {
          if (element.offsetParent) {
            return true;
          }
          if (element.getBBox) {
            var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
            if (width || height) {
              return true;
            }
          }
          if (element.getBoundingClientRect) {
            var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
            if (_width || _height) {
              return true;
            }
          }
        }
        return false;
      };
      const genWaveStyle = (token2) => {
        const {
          componentCls,
          colorPrimary
        } = token2;
        return {
          [componentCls]: {
            position: "absolute",
            background: "transparent",
            pointerEvents: "none",
            boxSizing: "border-box",
            color: `var(--wave-color, ${colorPrimary})`,
            boxShadow: `0 0 0 0 currentcolor`,
            opacity: 0.2,
            // =================== Motion ===================
            "&.wave-motion-appear": {
              transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
              "&-active": {
                boxShadow: `0 0 0 6px currentcolor`,
                opacity: 0
              }
            }
          }
        };
      };
      const useStyle$6 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
      function isNotGrey(color) {
        const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
        if (match2 && match2[1] && match2[2] && match2[3]) {
          return !(match2[1] === match2[2] && match2[2] === match2[3]);
        }
        return true;
      }
      function isValidWaveColor(color) {
        return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
        color !== "transparent";
      }
      function getTargetWaveColor(node2) {
        const {
          borderTopColor,
          borderColor,
          backgroundColor
        } = getComputedStyle(node2);
        if (isValidWaveColor(borderTopColor)) {
          return borderTopColor;
        }
        if (isValidWaveColor(borderColor)) {
          return borderColor;
        }
        if (isValidWaveColor(backgroundColor)) {
          return backgroundColor;
        }
        return null;
      }
      function validateNum(value) {
        return Number.isNaN(value) ? 0 : value;
      }
      const WaveEffect = (props) => {
        const {
          className,
          target
        } = props;
        const divRef = React__namespace.useRef(null);
        const [color, setWaveColor] = React__namespace.useState(null);
        const [borderRadius, setBorderRadius] = React__namespace.useState([]);
        const [left, setLeft] = React__namespace.useState(0);
        const [top, setTop] = React__namespace.useState(0);
        const [width, setWidth] = React__namespace.useState(0);
        const [height, setHeight] = React__namespace.useState(0);
        const [enabled, setEnabled] = React__namespace.useState(false);
        const waveStyle = {
          left,
          top,
          width,
          height,
          borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
        };
        if (color) {
          waveStyle["--wave-color"] = color;
        }
        function syncPos() {
          const nodeStyle = getComputedStyle(target);
          setWaveColor(getTargetWaveColor(target));
          const isStatic = nodeStyle.position === "static";
          const {
            borderLeftWidth,
            borderTopWidth
          } = nodeStyle;
          setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
          setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
          setWidth(target.offsetWidth);
          setHeight(target.offsetHeight);
          const {
            borderTopLeftRadius,
            borderTopRightRadius,
            borderBottomLeftRadius,
            borderBottomRightRadius
          } = nodeStyle;
          setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
        }
        React__namespace.useEffect(() => {
          if (target) {
            const id = wrapperRaf(() => {
              syncPos();
              setEnabled(true);
            });
            let resizeObserver2;
            if (typeof ResizeObserver !== "undefined") {
              resizeObserver2 = new ResizeObserver(syncPos);
              resizeObserver2.observe(target);
            }
            return () => {
              wrapperRaf.cancel(id);
              resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
            };
          }
        }, []);
        if (!enabled) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
          visible: true,
          motionAppear: true,
          motionName: "wave-motion",
          motionDeadline: 5e3,
          onAppearEnd: (_, event) => {
            var _a;
            if (event.deadline || event.propertyName === "opacity") {
              const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
              unmount(holder).then(() => {
                holder === null || holder === void 0 ? void 0 : holder.remove();
              });
            }
            return false;
          }
        }, (_ref) => {
          let {
            className: motionClassName
          } = _ref;
          return /* @__PURE__ */ React__namespace.createElement("div", {
            ref: divRef,
            className: classNames(className, motionClassName),
            style: waveStyle
          });
        });
      };
      function showWaveEffect(node2, className) {
        const holder = document.createElement("div");
        holder.style.position = "absolute";
        holder.style.left = `0px`;
        holder.style.top = `0px`;
        node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
        render(/* @__PURE__ */ React__namespace.createElement(WaveEffect, {
          target: node2,
          className
        }), holder);
      }
      function useWave(nodeRef, className) {
        function showWave() {
          const node2 = nodeRef.current;
          showWaveEffect(node2, className);
        }
        return showWave;
      }
      const Wave = (props) => {
        const {
          children,
          disabled
        } = props;
        const {
          getPrefixCls
        } = React.useContext(ConfigContext);
        const containerRef = React.useRef(null);
        const prefixCls = getPrefixCls("wave");
        const [, hashId] = useStyle$6(prefixCls);
        const showWave = useWave(containerRef, classNames(prefixCls, hashId));
        React.useEffect(() => {
          const node2 = containerRef.current;
          if (!node2 || node2.nodeType !== 1 || disabled) {
            return;
          }
          const onClick = (e2) => {
            if (e2.target.tagName === "INPUT" || !isVisible$1(e2.target) || // No need wave
            !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
              return;
            }
            showWave();
          };
          node2.addEventListener("click", onClick, true);
          return () => {
            node2.removeEventListener("click", onClick, true);
          };
        }, [disabled]);
        if (!/* @__PURE__ */ React.isValidElement(children)) {
          return children !== null && children !== void 0 ? children : null;
        }
        const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
        return cloneElement(children, {
          ref
        });
      };
      const Wave$1 = Wave;
      const SpaceCompactItemContext = /* @__PURE__ */ React__namespace.createContext(null);
      const useCompactItemContext = (prefixCls, direction) => {
        const compactItemContext = React__namespace.useContext(SpaceCompactItemContext);
        const compactItemClassnames = React__namespace.useMemo(() => {
          if (!compactItemContext) {
            return "";
          }
          const {
            compactDirection,
            isFirstItem,
            isLastItem
          } = compactItemContext;
          const separator = compactDirection === "vertical" ? "-vertical-" : "-";
          return classNames({
            [`${prefixCls}-compact${separator}item`]: true,
            [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
            [`${prefixCls}-compact${separator}last-item`]: isLastItem,
            [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
          });
        }, [prefixCls, direction, compactItemContext]);
        return {
          compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
          compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
          compactItemClassnames
        };
      };
      const NoCompactStyle = (_ref) => {
        let {
          children
        } = _ref;
        return /* @__PURE__ */ React__namespace.createElement(SpaceCompactItemContext.Provider, {
          value: null
        }, children);
      };
      const IconWrapper = /* @__PURE__ */ React.forwardRef((props, ref) => {
        const {
          className,
          style: style2,
          children,
          prefixCls
        } = props;
        const iconWrapperCls = classNames(`${prefixCls}-icon`, className);
        return /* @__PURE__ */ React.createElement("span", {
          ref,
          className: iconWrapperCls,
          style: style2
        }, children);
      });
      const IconWrapper$1 = IconWrapper;
      const InnerLoadingIcon = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
        let {
          prefixCls,
          className,
          style: style2,
          iconClassName
        } = _ref;
        const mergedIconCls = classNames(`${prefixCls}-loading-icon`, className);
        return /* @__PURE__ */ React.createElement(IconWrapper$1, {
          prefixCls,
          className: mergedIconCls,
          style: style2,
          ref
        }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, {
          className: iconClassName
        }));
      });
      const getCollapsedWidth = () => ({
        width: 0,
        opacity: 0,
        transform: "scale(0)"
      });
      const getRealWidth = (node2) => ({
        width: node2.scrollWidth,
        opacity: 1,
        transform: "scale(1)"
      });
      const LoadingIcon = (_ref2) => {
        let {
          prefixCls,
          loading,
          existIcon,
          className,
          style: style2
        } = _ref2;
        const visible = !!loading;
        if (existIcon) {
          return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
            prefixCls,
            className,
            style: style2
          });
        }
        return /* @__PURE__ */ React.createElement(CSSMotion, {
          visible,
          // We do not really use this motionName
          motionName: `${prefixCls}-loading-icon-motion`,
          removeOnLeave: true,
          onAppearStart: getCollapsedWidth,
          onAppearActive: getRealWidth,
          onEnterStart: getCollapsedWidth,
          onEnterActive: getRealWidth,
          onLeaveStart: getRealWidth,
          onLeaveActive: getCollapsedWidth
        }, (_ref3, ref) => {
          let {
            className: motionCls,
            style: motionStyle
          } = _ref3;
          return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
            prefixCls,
            className,
            style: Object.assign(Object.assign({}, style2), motionStyle),
            ref,
            iconClassName: motionCls
          });
        });
      };
      const LoadingIcon$1 = LoadingIcon;
      var __rest$h = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const GroupSizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
      const ButtonGroup = (props) => {
        const {
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const {
          prefixCls: customizePrefixCls,
          size,
          className
        } = props, others = __rest$h(props, ["prefixCls", "size", "className"]);
        const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
        const [, , hashId] = useToken$2();
        let sizeCls = "";
        switch (size) {
          case "large":
            sizeCls = "lg";
            break;
          case "small":
            sizeCls = "sm";
            break;
        }
        const classes = classNames(prefixCls, {
          [`${prefixCls}-${sizeCls}`]: sizeCls,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, hashId);
        return /* @__PURE__ */ React__namespace.createElement(GroupSizeContext.Provider, {
          value: size
        }, /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, others, {
          className: classes
        })));
      };
      const Group$2 = ButtonGroup;
      const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
      const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
      function isString$4(str) {
        return typeof str === "string";
      }
      function isUnBorderedButtonType(type2) {
        return type2 === "text" || type2 === "link";
      }
      function splitCNCharsBySpace(child, needInserted) {
        if (child === null || child === void 0) {
          return;
        }
        const SPACE2 = needInserted ? " " : "";
        if (typeof child !== "string" && typeof child !== "number" && isString$4(child.type) && isTwoCNChar(child.props.children)) {
          return cloneElement(child, {
            children: child.props.children.split("").join(SPACE2)
          });
        }
        if (typeof child === "string") {
          return isTwoCNChar(child) ? /* @__PURE__ */ React.createElement("span", null, child.split("").join(SPACE2)) : /* @__PURE__ */ React.createElement("span", null, child);
        }
        if (isFragment(child)) {
          return /* @__PURE__ */ React.createElement("span", null, child);
        }
        return child;
      }
      function spaceChildren(children, needInserted) {
        let isPrevChildPure = false;
        const childList = [];
        React.Children.forEach(children, (child) => {
          const type2 = typeof child;
          const isCurrentChildPure = type2 === "string" || type2 === "number";
          if (isPrevChildPure && isCurrentChildPure) {
            const lastIndex = childList.length - 1;
            const lastChild = childList[lastIndex];
            childList[lastIndex] = `${lastChild}${child}`;
          } else {
            childList.push(child);
          }
          isPrevChildPure = isCurrentChildPure;
        });
        return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
      }
      function compactItemBorder(token2, parentCls, options) {
        const {
          focusElCls,
          focus,
          borderElCls
        } = options;
        const childCombinator = borderElCls ? "> *" : "";
        const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
        return {
          [`&-item:not(${parentCls}-last-item)`]: {
            marginInlineEnd: -token2.lineWidth
          },
          "&-item": Object.assign(Object.assign({
            [hoverEffects]: {
              zIndex: 2
            }
          }, focusElCls ? {
            [`&${focusElCls}`]: {
              zIndex: 2
            }
          } : {}), {
            [`&[disabled] ${childCombinator}`]: {
              zIndex: 0
            }
          })
        };
      }
      function compactItemBorderRadius(prefixCls, parentCls, options) {
        const {
          borderElCls
        } = options;
        const childCombinator = borderElCls ? `> ${borderElCls}` : "";
        return {
          [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
            borderRadius: 0
          },
          [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
            [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
            [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        };
      }
      function genCompactItemStyle(token2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          focus: true
        };
        const {
          componentCls
        } = token2;
        const compactCls = `${componentCls}-compact`;
        return {
          [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
        };
      }
      function compactItemVerticalBorder(token2, parentCls) {
        return {
          // border collapse
          [`&-item:not(${parentCls}-last-item)`]: {
            marginBottom: -token2.lineWidth
          },
          "&-item": {
            "&:hover,&:focus,&:active": {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          }
        };
      }
      function compactItemBorderVerticalRadius(prefixCls, parentCls) {
        return {
          [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
            borderRadius: 0
          },
          [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
            [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
              borderEndEndRadius: 0,
              borderEndStartRadius: 0
            }
          },
          [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
            [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0
            }
          }
        };
      }
      function genCompactItemVerticalStyle(token2) {
        const compactCls = `${token2.componentCls}-compact-vertical`;
        return {
          [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
        };
      }
      const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
        // Border
        [`> span, > ${buttonTypeCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${buttonTypeCls}`]: {
              "&:not(:disabled)": {
                borderInlineEndColor: borderColor
              }
            }
          },
          "&:not(:first-child)": {
            [`&, & > ${buttonTypeCls}`]: {
              "&:not(:disabled)": {
                borderInlineStartColor: borderColor
              }
            }
          }
        }
      });
      const genGroupStyle$1 = (token2) => {
        const {
          componentCls,
          fontSize,
          lineWidth,
          colorPrimaryHover,
          colorErrorHover
        } = token2;
        return {
          [`${componentCls}-group`]: [
            {
              position: "relative",
              display: "inline-flex",
              // Border
              [`> span, > ${componentCls}`]: {
                "&:not(:last-child)": {
                  [`&, & > ${componentCls}`]: {
                    borderStartEndRadius: 0,
                    borderEndEndRadius: 0
                  }
                },
                "&:not(:first-child)": {
                  marginInlineStart: -lineWidth,
                  [`&, & > ${componentCls}`]: {
                    borderStartStartRadius: 0,
                    borderEndStartRadius: 0
                  }
                }
              },
              [componentCls]: {
                position: "relative",
                zIndex: 1,
                [`&:hover,
          &:focus,
          &:active`]: {
                  zIndex: 2
                },
                "&[disabled]": {
                  zIndex: 0
                }
              },
              [`${componentCls}-icon-only`]: {
                fontSize
              }
            },
            // Border Color
            genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
            genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
          ]
        };
      };
      const genGroupStyle$2 = genGroupStyle$1;
      const genSharedButtonStyle = (token2) => {
        const {
          componentCls,
          iconCls,
          buttonFontWeight
        } = token2;
        return {
          [componentCls]: {
            outline: "none",
            position: "relative",
            display: "inline-block",
            fontWeight: buttonFontWeight,
            whiteSpace: "nowrap",
            textAlign: "center",
            backgroundImage: "none",
            backgroundColor: "transparent",
            border: `${token2.lineWidth}px ${token2.lineType} transparent`,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
            userSelect: "none",
            touchAction: "manipulation",
            lineHeight: token2.lineHeight,
            color: token2.colorText,
            "&:disabled > *": {
              pointerEvents: "none"
            },
            "> span": {
              display: "inline-block"
            },
            [`${componentCls}-icon`]: {
              lineHeight: 0
            },
            // Leave a space between icon and text.
            [`> ${iconCls} + span, > span + ${iconCls}`]: {
              marginInlineStart: token2.marginXS
            },
            [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
              [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
                marginInlineEnd: token2.marginXS
              }
            },
            "> a": {
              color: "currentColor"
            },
            "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
            // make `btn-icon-only` not too narrow
            [`&-icon-only${componentCls}-compact-item`]: {
              flex: "none"
            },
            // Special styles for Primary Button
            [`&-compact-item${componentCls}-primary`]: {
              [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: -token2.lineWidth,
                  insetInlineStart: -token2.lineWidth,
                  display: "inline-block",
                  width: token2.lineWidth,
                  height: `calc(100% + ${token2.lineWidth * 2}px)`,
                  backgroundColor: token2.colorPrimaryHover,
                  content: '""'
                }
              }
            },
            // Special styles for Primary Button
            "&-compact-vertical-item": {
              [`&${componentCls}-primary`]: {
                [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                  position: "relative",
                  "&:before": {
                    position: "absolute",
                    top: -token2.lineWidth,
                    insetInlineStart: -token2.lineWidth,
                    display: "inline-block",
                    width: `calc(100% + ${token2.lineWidth * 2}px)`,
                    height: token2.lineWidth,
                    backgroundColor: token2.colorPrimaryHover,
                    content: '""'
                  }
                }
              }
            }
          }
        };
      };
      const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
        "&:not(:disabled)": {
          "&:hover": hoverStyle,
          "&:active": activeStyle
        }
      });
      const genCircleButtonStyle = (token2) => ({
        minWidth: token2.controlHeight,
        paddingInlineStart: 0,
        paddingInlineEnd: 0,
        borderRadius: "50%"
      });
      const genRoundButtonStyle = (token2) => ({
        borderRadius: token2.controlHeight,
        paddingInlineStart: token2.controlHeight / 2,
        paddingInlineEnd: token2.controlHeight / 2
      });
      const genDisabledStyle$1 = (token2) => ({
        cursor: "not-allowed",
        borderColor: token2.colorBorder,
        color: token2.colorTextDisabled,
        backgroundColor: token2.colorBgContainerDisabled,
        boxShadow: "none"
      });
      const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
        [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
          color: textColor || void 0,
          backgroundColor: "transparent",
          borderColor: borderColor || void 0,
          boxShadow: "none"
        }, genHoverActiveButtonStyle(Object.assign({
          backgroundColor: "transparent"
        }, hoverStyle), Object.assign({
          backgroundColor: "transparent"
        }, activeStyle))), {
          "&:disabled": {
            cursor: "not-allowed",
            color: textColorDisabled || void 0,
            borderColor: borderColorDisabled || void 0
          }
        })
      });
      const genSolidDisabledButtonStyle = (token2) => ({
        "&:disabled": Object.assign({}, genDisabledStyle$1(token2))
      });
      const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
      const genPureDisabledButtonStyle = (token2) => ({
        "&:disabled": {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        }
      });
      const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
        backgroundColor: token2.colorBgContainer,
        borderColor: token2.colorBorder,
        boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
      }), genHoverActiveButtonStyle({
        color: token2.colorPrimaryHover,
        borderColor: token2.colorPrimaryHover
      }, {
        color: token2.colorPrimaryActive,
        borderColor: token2.colorPrimaryActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
        [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
          color: token2.colorError,
          borderColor: token2.colorError
        }, genHoverActiveButtonStyle({
          color: token2.colorErrorHover,
          borderColor: token2.colorErrorBorderHover
        }, {
          color: token2.colorErrorActive,
          borderColor: token2.colorErrorActive
        })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
      });
      const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
        color: token2.colorTextLightSolid,
        backgroundColor: token2.colorPrimary,
        boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
      }), genHoverActiveButtonStyle({
        color: token2.colorTextLightSolid,
        backgroundColor: token2.colorPrimaryHover
      }, {
        color: token2.colorTextLightSolid,
        backgroundColor: token2.colorPrimaryActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
        color: token2.colorPrimaryHover,
        borderColor: token2.colorPrimaryHover
      }, {
        color: token2.colorPrimaryActive,
        borderColor: token2.colorPrimaryActive
      })), {
        [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
          backgroundColor: token2.colorError,
          boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
        }, genHoverActiveButtonStyle({
          backgroundColor: token2.colorErrorHover
        }, {
          backgroundColor: token2.colorErrorActive
        })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
          color: token2.colorErrorHover,
          borderColor: token2.colorErrorHover
        }, {
          color: token2.colorErrorActive,
          borderColor: token2.colorErrorActive
        })), genSolidDisabledButtonStyle(token2))
      });
      const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
        borderStyle: "dashed"
      });
      const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
        color: token2.colorLink
      }, genHoverActiveButtonStyle({
        color: token2.colorLinkHover
      }, {
        color: token2.colorLinkActive
      })), genPureDisabledButtonStyle(token2)), {
        [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
          color: token2.colorError
        }, genHoverActiveButtonStyle({
          color: token2.colorErrorHover
        }, {
          color: token2.colorErrorActive
        })), genPureDisabledButtonStyle(token2))
      });
      const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
        color: token2.colorText,
        backgroundColor: token2.colorBgTextHover
      }, {
        color: token2.colorText,
        backgroundColor: token2.colorBgTextActive
      })), genPureDisabledButtonStyle(token2)), {
        [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
          color: token2.colorError
        }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
          color: token2.colorErrorHover,
          backgroundColor: token2.colorErrorBg
        }, {
          color: token2.colorErrorHover,
          backgroundColor: token2.colorErrorBg
        }))
      });
      const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle$1(token2)), {
        [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$1(token2))
      });
      const genTypeButtonStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          [`${componentCls}-default`]: genDefaultButtonStyle(token2),
          [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
          [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
          [`${componentCls}-link`]: genLinkButtonStyle(token2),
          [`${componentCls}-text`]: genTextButtonStyle(token2),
          [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
        };
      };
      const genSizeButtonStyle = function(token2) {
        let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const {
          componentCls,
          controlHeight,
          fontSize,
          lineHeight,
          lineWidth,
          borderRadius,
          buttonPaddingHorizontal,
          iconCls
        } = token2;
        const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
        const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
        const iconOnlyCls = `${componentCls}-icon-only`;
        return [
          // Size
          {
            [`${componentCls}${sizePrefixCls}`]: {
              fontSize,
              height: controlHeight,
              padding: `${paddingVertical}px ${paddingHorizontal}px`,
              borderRadius,
              [`&${iconOnlyCls}`]: {
                width: controlHeight,
                paddingInlineStart: 0,
                paddingInlineEnd: 0,
                [`&${componentCls}-round`]: {
                  width: "auto"
                },
                [iconCls]: {
                  fontSize: token2.buttonIconOnlyFontSize
                }
              },
              // Loading
              [`&${componentCls}-loading`]: {
                opacity: token2.opacityLoading,
                cursor: "default"
              },
              [`${componentCls}-loading-icon`]: {
                transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
              }
            }
          },
          // Shape - patch prefixCls again to override solid border radius style
          {
            [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
          },
          {
            [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
          }
        ];
      };
      const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
      const genSizeSmallButtonStyle = (token2) => {
        const smallToken = merge(token2, {
          controlHeight: token2.controlHeightSM,
          padding: token2.paddingXS,
          buttonPaddingHorizontal: 8,
          borderRadius: token2.borderRadiusSM,
          buttonIconOnlyFontSize: token2.fontSizeLG - 2
        });
        return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
      };
      const genSizeLargeButtonStyle = (token2) => {
        const largeToken = merge(token2, {
          controlHeight: token2.controlHeightLG,
          fontSize: token2.fontSizeLG,
          borderRadius: token2.borderRadiusLG,
          buttonIconOnlyFontSize: token2.fontSizeLG + 2
        });
        return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
      };
      const genBlockButtonStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          [componentCls]: {
            [`&${componentCls}-block`]: {
              width: "100%"
            }
          }
        };
      };
      const useStyle$5 = genComponentStyleHook("Button", (token2) => {
        const {
          controlTmpOutline,
          paddingContentHorizontal
        } = token2;
        const buttonToken = merge(token2, {
          colorOutlineDefault: controlTmpOutline,
          buttonPaddingHorizontal: paddingContentHorizontal,
          buttonIconOnlyFontSize: token2.fontSizeLG,
          buttonFontWeight: 400
        });
        return [
          // Shared
          genSharedButtonStyle(buttonToken),
          // Size
          genSizeSmallButtonStyle(buttonToken),
          genSizeBaseButtonStyle(buttonToken),
          genSizeLargeButtonStyle(buttonToken),
          // Block
          genBlockButtonStyle(buttonToken),
          // Group (type, ghost, danger, disabled, loading)
          genTypeButtonStyle(buttonToken),
          // Button Group
          genGroupStyle$2(buttonToken),
          // Space Compact
          genCompactItemStyle(token2),
          genCompactItemVerticalStyle(token2)
        ];
      });
      var __rest$g = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function convertLegacyProps(type2) {
        if (type2 === "danger") {
          return {
            danger: true
          };
        }
        return {
          type: type2
        };
      }
      function getLoadingConfig(loading) {
        if (typeof loading === "object" && loading) {
          const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
          const isDelay = !Number.isNaN(delay) && typeof delay === "number";
          return {
            loading: false,
            delay: isDelay ? delay : 0
          };
        }
        return {
          loading: !!loading,
          delay: 0
        };
      }
      const InternalButton = (props, ref) => {
        var _a, _b;
        const {
          loading = false,
          prefixCls: customizePrefixCls,
          type: type2 = "default",
          danger,
          shape = "default",
          size: customizeSize,
          styles,
          disabled: customDisabled,
          className,
          rootClassName,
          children,
          icon,
          ghost = false,
          block = false,
          // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
          htmlType = "button",
          classNames: customClassNames,
          style: customStyle = {}
        } = props, rest = __rest$g(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style"]);
        const {
          getPrefixCls,
          autoInsertSpaceInButton,
          direction,
          button
        } = React.useContext(ConfigContext);
        const prefixCls = getPrefixCls("btn", customizePrefixCls);
        const [wrapSSR, hashId] = useStyle$5(prefixCls);
        const disabled = React.useContext(DisabledContext$1);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const groupSize = React.useContext(GroupSizeContext);
        const loadingOrDelay = React.useMemo(() => getLoadingConfig(loading), [loading]);
        const [innerLoading, setLoading] = React.useState(loadingOrDelay.loading);
        const [hasTwoCNChar, setHasTwoCNChar] = React.useState(false);
        const internalRef = /* @__PURE__ */ React.createRef();
        const buttonRef = composeRef(ref, internalRef);
        const needInserted = React.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type2);
        React.useEffect(() => {
          let delayTimer = null;
          if (loadingOrDelay.delay > 0) {
            delayTimer = setTimeout(() => {
              delayTimer = null;
              setLoading(true);
            }, loadingOrDelay.delay);
          } else {
            setLoading(loadingOrDelay.loading);
          }
          function cleanupTimer() {
            if (delayTimer) {
              clearTimeout(delayTimer);
              delayTimer = null;
            }
          }
          return cleanupTimer;
        }, [loadingOrDelay]);
        React.useEffect(() => {
          if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
            return;
          }
          const buttonText = buttonRef.current.textContent;
          if (needInserted && isTwoCNChar(buttonText)) {
            if (!hasTwoCNChar) {
              setHasTwoCNChar(true);
            }
          } else if (hasTwoCNChar) {
            setHasTwoCNChar(false);
          }
        }, [buttonRef]);
        const handleClick = (e2) => {
          const {
            onClick
          } = props;
          if (innerLoading || mergedDisabled) {
            e2.preventDefault();
            return;
          }
          onClick === null || onClick === void 0 ? void 0 : onClick(e2);
        };
        const autoInsertSpace = autoInsertSpaceInButton !== false;
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const sizeClassNameMap = {
          large: "lg",
          small: "sm",
          middle: void 0
        };
        const sizeFullName = useSize$1((ctxSize) => {
          var _a2, _b2;
          return (_b2 = (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
        });
        const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] || "" : "";
        const iconType = innerLoading ? "loading" : icon;
        const linkButtonRestProps = omit(rest, ["navigate"]);
        const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
        const classes = classNames(prefixCls, hashId, {
          [`${prefixCls}-${shape}`]: shape !== "default" && shape,
          [`${prefixCls}-${type2}`]: type2,
          [`${prefixCls}-${sizeCls}`]: sizeCls,
          [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
          [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type2),
          [`${prefixCls}-loading`]: innerLoading,
          [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
          [`${prefixCls}-block`]: block,
          [`${prefixCls}-dangerous`]: !!danger,
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-disabled`]: hrefAndDisabled
        }, compactItemClassnames, className, rootClassName, button === null || button === void 0 ? void 0 : button.className);
        const fullStyle = Object.assign(Object.assign({}, button === null || button === void 0 ? void 0 : button.style), customStyle);
        const iconClasses = classNames(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, (_a = button === null || button === void 0 ? void 0 : button.classNames) === null || _a === void 0 ? void 0 : _a.icon);
        const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), ((_b = button === null || button === void 0 ? void 0 : button.styles) === null || _b === void 0 ? void 0 : _b.icon) || {});
        const iconNode = icon && !innerLoading ? /* @__PURE__ */ React.createElement(IconWrapper$1, {
          prefixCls,
          className: iconClasses,
          style: iconStyle
        }, icon) : /* @__PURE__ */ React.createElement(LoadingIcon$1, {
          existIcon: !!icon,
          prefixCls,
          loading: !!innerLoading
        });
        const kids = children || children === 0 ? spaceChildren(children, needInserted && autoInsertSpace) : null;
        if (linkButtonRestProps.href !== void 0) {
          return wrapSSR(/* @__PURE__ */ React.createElement("a", Object.assign({}, linkButtonRestProps, {
            className: classes,
            style: fullStyle,
            onClick: handleClick,
            ref: buttonRef
          }), iconNode, kids));
        }
        let buttonNode = /* @__PURE__ */ React.createElement("button", Object.assign({}, rest, {
          type: htmlType,
          className: classes,
          style: fullStyle,
          onClick: handleClick,
          disabled: mergedDisabled,
          ref: buttonRef
        }), iconNode, kids);
        if (!isUnBorderedButtonType(type2)) {
          buttonNode = /* @__PURE__ */ React.createElement(Wave$1, {
            disabled: !!innerLoading
          }, buttonNode);
        }
        return wrapSSR(buttonNode);
      };
      const Button = /* @__PURE__ */ React.forwardRef(InternalButton);
      Button.Group = Group$2;
      Button.__ANT_BUTTON = true;
      const Button$1 = Button;
      function isThenable(thing) {
        return !!(thing && thing.then);
      }
      const ActionButton = (props) => {
        const {
          type: type2,
          children,
          prefixCls,
          buttonProps,
          close,
          autoFocus,
          emitEvent,
          quitOnNullishReturnValue,
          actionFn
        } = props;
        const clickedRef = React__namespace.useRef(false);
        const buttonRef = React__namespace.useRef(null);
        const [loading, setLoading] = useSafeState(false);
        const onInternalClose = function() {
          close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
        };
        React__namespace.useEffect(() => {
          let timeoutId = null;
          if (autoFocus) {
            timeoutId = setTimeout(() => {
              var _a;
              (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            });
          }
          return () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
          };
        }, []);
        const handlePromiseOnOk = (returnValueOfOnOk) => {
          if (!isThenable(returnValueOfOnOk)) {
            return;
          }
          setLoading(true);
          returnValueOfOnOk.then(function() {
            setLoading(false, true);
            onInternalClose.apply(void 0, arguments);
            clickedRef.current = false;
          }, (e2) => {
            setLoading(false, true);
            clickedRef.current = false;
            return Promise.reject(e2);
          });
        };
        const onClick = (e2) => {
          if (clickedRef.current) {
            return;
          }
          clickedRef.current = true;
          if (!actionFn) {
            onInternalClose();
            return;
          }
          let returnValueOfOnOk;
          if (emitEvent) {
            returnValueOfOnOk = actionFn(e2);
            if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
              clickedRef.current = false;
              onInternalClose(e2);
              return;
            }
          } else if (actionFn.length) {
            returnValueOfOnOk = actionFn(close);
            clickedRef.current = false;
          } else {
            returnValueOfOnOk = actionFn();
            if (!returnValueOfOnOk) {
              onInternalClose();
              return;
            }
          }
          handlePromiseOnOk(returnValueOfOnOk);
        };
        return /* @__PURE__ */ React__namespace.createElement(Button$1, Object.assign({}, convertLegacyProps(type2), {
          onClick,
          loading,
          prefixCls
        }, buttonProps, {
          ref: buttonRef
        }), children);
      };
      const ActionButton$1 = ActionButton;
      const getCollapsedHeight = () => ({
        height: 0,
        opacity: 0
      });
      const getRealHeight = (node2) => {
        const {
          scrollHeight
        } = node2;
        return {
          height: scrollHeight,
          opacity: 1
        };
      };
      const getCurrentHeight = (node2) => ({
        height: node2 ? node2.offsetHeight : 0
      });
      const skipOpacityTransition = (_, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
      const initCollapseMotion = function() {
        let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant";
        return {
          motionName: `${rootCls}-motion-collapse`,
          onAppearStart: getCollapsedHeight,
          onEnterStart: getCollapsedHeight,
          onAppearActive: getRealHeight,
          onEnterActive: getRealHeight,
          onLeaveStart: getCurrentHeight,
          onLeaveActive: getCollapsedHeight,
          onAppearEnd: skipOpacityTransition,
          onEnterEnd: skipOpacityTransition,
          onLeaveEnd: skipOpacityTransition,
          motionDeadline: 500
        };
      };
      const getTransitionName = (rootPrefixCls, motion, transitionName) => {
        if (transitionName !== void 0) {
          return transitionName;
        }
        return `${rootPrefixCls}-${motion}`;
      };
      const initCollapseMotion$1 = initCollapseMotion;
      var OrderContext = /* @__PURE__ */ React__namespace.createContext(null);
      var EMPTY_LIST$1 = [];
      function useDom(render2, debug2) {
        var _React$useState = React__namespace.useState(function() {
          if (!canUseDom()) {
            return null;
          }
          var defaultEle = document.createElement("div");
          return defaultEle;
        }), _React$useState2 = _slicedToArray$5(_React$useState, 1), ele = _React$useState2[0];
        var appendedRef = React__namespace.useRef(false);
        var queueCreate = React__namespace.useContext(OrderContext);
        var _React$useState3 = React__namespace.useState(EMPTY_LIST$1), _React$useState4 = _slicedToArray$5(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
        var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
          setQueue(function(origin) {
            var newQueue = [appendFn].concat(_toConsumableArray(origin));
            return newQueue;
          });
        });
        function append2() {
          if (!ele.parentElement) {
            document.body.appendChild(ele);
          }
          appendedRef.current = true;
        }
        function cleanup2() {
          var _ele$parentElement;
          (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
          appendedRef.current = false;
        }
        useLayoutEffect(function() {
          if (render2) {
            if (queueCreate) {
              queueCreate(append2);
            } else {
              append2();
            }
          } else {
            cleanup2();
          }
          return cleanup2;
        }, [render2]);
        useLayoutEffect(function() {
          if (queue.length) {
            queue.forEach(function(appendFn) {
              return appendFn();
            });
            setQueue(EMPTY_LIST$1);
          }
        }, [queue]);
        return [ele, mergedQueueCreate];
      }
      var cached;
      function getScrollBarSize(fresh) {
        if (typeof document === "undefined") {
          return 0;
        }
        if (fresh || cached === void 0) {
          var inner = document.createElement("div");
          inner.style.width = "100%";
          inner.style.height = "200px";
          var outer = document.createElement("div");
          var outerStyle = outer.style;
          outerStyle.position = "absolute";
          outerStyle.top = "0";
          outerStyle.left = "0";
          outerStyle.pointerEvents = "none";
          outerStyle.visibility = "hidden";
          outerStyle.width = "200px";
          outerStyle.height = "150px";
          outerStyle.overflow = "hidden";
          outer.appendChild(inner);
          document.body.appendChild(outer);
          var widthContained = inner.offsetWidth;
          outer.style.overflow = "scroll";
          var widthScroll = inner.offsetWidth;
          if (widthContained === widthScroll) {
            widthScroll = outer.clientWidth;
          }
          document.body.removeChild(outer);
          cached = widthContained - widthScroll;
        }
        return cached;
      }
      function isBodyOverflowing() {
        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
      }
      var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
      var uuid$2 = 0;
      function useScrollLocker(lock) {
        var mergedLock = !!lock;
        var _React$useState = React__namespace.useState(function() {
          uuid$2 += 1;
          return "".concat(UNIQUE_ID, "_").concat(uuid$2);
        }), _React$useState2 = _slicedToArray$5(_React$useState, 1), id = _React$useState2[0];
        useLayoutEffect(function() {
          if (mergedLock) {
            var scrollbarSize = getScrollBarSize();
            var isOverflow = isBodyOverflowing();
            updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
          } else {
            removeCSS(id);
          }
          return function() {
            removeCSS(id);
          };
        }, [mergedLock, id]);
      }
      var inline = false;
      function inlineMock(nextInline) {
        if (typeof nextInline === "boolean") {
          inline = nextInline;
        }
        return inline;
      }
      var getPortalContainer = function getPortalContainer2(getContainer2) {
        if (getContainer2 === false) {
          return false;
        }
        if (!canUseDom() || !getContainer2) {
          return null;
        }
        if (typeof getContainer2 === "string") {
          return document.querySelector(getContainer2);
        }
        if (typeof getContainer2 === "function") {
          return getContainer2();
        }
        return getContainer2;
      };
      var Portal = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
        props.debug;
        var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
        var _React$useState = React__namespace.useState(open), _React$useState2 = _slicedToArray$5(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
        var mergedRender = shouldRender || open;
        React__namespace.useEffect(function() {
          if (autoDestroy || open) {
            setShouldRender(open);
          }
        }, [open, autoDestroy]);
        var _React$useState3 = React__namespace.useState(function() {
          return getPortalContainer(getContainer2);
        }), _React$useState4 = _slicedToArray$5(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
        React__namespace.useEffect(function() {
          var customizeContainer = getPortalContainer(getContainer2);
          setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
        });
        var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray$5(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
        var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
        useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
        var childRef = null;
        if (children && supportRef(children) && ref) {
          var _ref = children;
          childRef = _ref.ref;
        }
        var mergedRef = useComposeRef(childRef, ref);
        if (!mergedRender || !canUseDom() || innerContainer === void 0) {
          return null;
        }
        var renderInline = mergedContainer === false || inlineMock();
        var reffedChildren = children;
        if (ref) {
          reffedChildren = /* @__PURE__ */ React__namespace.cloneElement(children, {
            ref: mergedRef
          });
        }
        return /* @__PURE__ */ React__namespace.createElement(OrderContext.Provider, {
          value: queueCreate
        }, renderInline ? reffedChildren : /* @__PURE__ */ ReactDOM__default.createPortal(reffedChildren, mergedContainer));
      });
      function getUseId() {
        var fullClone2 = _objectSpread2({}, React__namespace);
        return fullClone2.useId;
      }
      var uuid$1 = 0;
      function useId(id) {
        var _React$useState = React__namespace.useState("ssr-id"), _React$useState2 = _slicedToArray$5(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
        var useOriginId = getUseId();
        var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
        React__namespace.useEffect(function() {
          if (!useOriginId) {
            var nextId = uuid$1;
            uuid$1 += 1;
            setInnerId("rc_unique_".concat(nextId));
          }
        }, []);
        if (id) {
          return id;
        }
        return reactNativeId || innerId;
      }
      function getMotionName(prefixCls, transitionName, animationName) {
        var motionName = transitionName;
        if (!motionName && animationName) {
          motionName = "".concat(prefixCls, "-").concat(animationName);
        }
        return motionName;
      }
      function getScroll(w2, top) {
        var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
        var method2 = "scroll".concat(top ? "Top" : "Left");
        if (typeof ret !== "number") {
          var d2 = w2.document;
          ret = d2.documentElement[method2];
          if (typeof ret !== "number") {
            ret = d2.body[method2];
          }
        }
        return ret;
      }
      function offset(el) {
        var rect = el.getBoundingClientRect();
        var pos = {
          left: rect.left,
          top: rect.top
        };
        var doc = el.ownerDocument;
        var w2 = doc.defaultView || doc.parentWindow;
        pos.left += getScroll(w2);
        pos.top += getScroll(w2, true);
        return pos;
      }
      const MemoChildren = /* @__PURE__ */ React__namespace.memo(function(_ref) {
        var children = _ref.children;
        return children;
      }, function(_, _ref2) {
        var shouldUpdate = _ref2.shouldUpdate;
        return !shouldUpdate;
      });
      var sentinelStyle = {
        width: 0,
        height: 0,
        overflow: "hidden",
        outline: "none"
      };
      var Panel = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
        var sentinelStartRef = React.useRef();
        var sentinelEndRef = React.useRef();
        React.useImperativeHandle(ref, function() {
          return {
            focus: function focus() {
              var _sentinelStartRef$cur;
              (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
            },
            changeActive: function changeActive(next2) {
              var _document = document, activeElement = _document.activeElement;
              if (next2 && activeElement === sentinelEndRef.current) {
                sentinelStartRef.current.focus();
              } else if (!next2 && activeElement === sentinelStartRef.current) {
                sentinelEndRef.current.focus();
              }
            }
          };
        });
        var contentStyle = {};
        if (width !== void 0) {
          contentStyle.width = width;
        }
        if (height !== void 0) {
          contentStyle.height = height;
        }
        var footerNode;
        if (footer) {
          footerNode = /* @__PURE__ */ React.createElement("div", {
            className: "".concat(prefixCls, "-footer")
          }, footer);
        }
        var headerNode;
        if (title) {
          headerNode = /* @__PURE__ */ React.createElement("div", {
            className: "".concat(prefixCls, "-header")
          }, /* @__PURE__ */ React.createElement("div", {
            className: "".concat(prefixCls, "-title"),
            id: ariaId
          }, title));
        }
        var closer;
        if (closable) {
          closer = /* @__PURE__ */ React.createElement("button", {
            type: "button",
            onClick: onClose,
            "aria-label": "Close",
            className: "".concat(prefixCls, "-close")
          }, closeIcon || /* @__PURE__ */ React.createElement("span", {
            className: "".concat(prefixCls, "-close-x")
          }));
        }
        var content = /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-content")
        }, closer, headerNode, /* @__PURE__ */ React.createElement("div", _extends$1({
          className: "".concat(prefixCls, "-body"),
          style: bodyStyle
        }, bodyProps), children), footerNode);
        return /* @__PURE__ */ React.createElement("div", {
          key: "dialog-element",
          role: "dialog",
          "aria-labelledby": title ? ariaId : null,
          "aria-modal": "true",
          ref: holderRef,
          style: _objectSpread2(_objectSpread2({}, style2), contentStyle),
          className: classNames(prefixCls, className),
          onMouseDown,
          onMouseUp
        }, /* @__PURE__ */ React.createElement("div", {
          tabIndex: 0,
          ref: sentinelStartRef,
          style: sentinelStyle,
          "aria-hidden": "true"
        }), /* @__PURE__ */ React.createElement(MemoChildren, {
          shouldUpdate: visible || forceRender
        }, modalRender ? modalRender(content) : content), /* @__PURE__ */ React.createElement("div", {
          tabIndex: 0,
          ref: sentinelEndRef,
          style: sentinelStyle,
          "aria-hidden": "true"
        }));
      });
      var Content = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
        var dialogRef = React.useRef();
        var _React$useState = React__namespace.useState(), _React$useState2 = _slicedToArray$5(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
        var contentStyle = {};
        if (transformOrigin) {
          contentStyle.transformOrigin = transformOrigin;
        }
        function onPrepare() {
          var elementOffset = offset(dialogRef.current);
          setTransformOrigin(mousePosition2 ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
        }
        return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
          visible,
          onVisibleChanged,
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          forceRender,
          motionName,
          removeOnLeave: destroyOnClose,
          ref: dialogRef
        }, function(_ref, motionRef) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          return /* @__PURE__ */ React__namespace.createElement(Panel, _extends$1({}, props, {
            ref,
            title,
            ariaId,
            prefixCls,
            holderRef: motionRef,
            style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), style2), contentStyle),
            className: classNames(className, motionClassName)
          }));
        });
      });
      Content.displayName = "Content";
      function Mask$1(props) {
        var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
        return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
          key: "mask",
          visible,
          motionName,
          leavedClassName: "".concat(prefixCls, "-mask-hidden")
        }, function(_ref, ref) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          return /* @__PURE__ */ React__namespace.createElement("div", _extends$1({
            ref,
            style: _objectSpread2(_objectSpread2({}, motionStyle), style2),
            className: classNames("".concat(prefixCls, "-mask"), motionClassName)
          }, maskProps));
        });
      }
      function Dialog(props) {
        var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard2 = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
        var lastOutSideActiveElementRef = React.useRef();
        var wrapperRef = React.useRef();
        var contentRef = React.useRef();
        var _React$useState = React__namespace.useState(visible), _React$useState2 = _slicedToArray$5(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
        var ariaId = useId();
        function saveLastOutSideActiveElementRef() {
          if (!contains(wrapperRef.current, document.activeElement)) {
            lastOutSideActiveElementRef.current = document.activeElement;
          }
        }
        function focusDialogContent() {
          if (!contains(wrapperRef.current, document.activeElement)) {
            var _contentRef$current;
            (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
          }
        }
        function onDialogVisibleChanged(newVisible) {
          if (newVisible) {
            focusDialogContent();
          } else {
            setAnimatedVisible(false);
            if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
              try {
                lastOutSideActiveElementRef.current.focus({
                  preventScroll: true
                });
              } catch (e2) {
              }
              lastOutSideActiveElementRef.current = null;
            }
            if (animatedVisible) {
              afterClose === null || afterClose === void 0 ? void 0 : afterClose();
            }
          }
          afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(newVisible);
        }
        function onInternalClose(e2) {
          onClose === null || onClose === void 0 ? void 0 : onClose(e2);
        }
        var contentClickRef = React.useRef(false);
        var contentTimeoutRef = React.useRef();
        var onContentMouseDown = function onContentMouseDown2() {
          clearTimeout(contentTimeoutRef.current);
          contentClickRef.current = true;
        };
        var onContentMouseUp = function onContentMouseUp2() {
          contentTimeoutRef.current = setTimeout(function() {
            contentClickRef.current = false;
          });
        };
        var onWrapperClick = null;
        if (maskClosable) {
          onWrapperClick = function onWrapperClick2(e2) {
            if (contentClickRef.current) {
              contentClickRef.current = false;
            } else if (wrapperRef.current === e2.target) {
              onInternalClose(e2);
            }
          };
        }
        function onWrapperKeyDown(e2) {
          if (keyboard2 && e2.keyCode === KeyCode.ESC) {
            e2.stopPropagation();
            onInternalClose(e2);
            return;
          }
          if (visible) {
            if (e2.keyCode === KeyCode.TAB) {
              contentRef.current.changeActive(!e2.shiftKey);
            }
          }
        }
        React.useEffect(function() {
          if (visible) {
            setAnimatedVisible(true);
            saveLastOutSideActiveElementRef();
          }
        }, [visible]);
        React.useEffect(function() {
          return function() {
            clearTimeout(contentTimeoutRef.current);
          };
        }, []);
        return /* @__PURE__ */ React__namespace.createElement("div", _extends$1({
          className: classNames("".concat(prefixCls, "-root"), rootClassName)
        }, pickAttrs(props, {
          data: true
        })), /* @__PURE__ */ React__namespace.createElement(Mask$1, {
          prefixCls,
          visible: mask && visible,
          motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
          style: _objectSpread2({
            zIndex
          }, maskStyle),
          maskProps
        }), /* @__PURE__ */ React__namespace.createElement("div", _extends$1({
          tabIndex: -1,
          onKeyDown: onWrapperKeyDown,
          className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
          ref: wrapperRef,
          onClick: onWrapperClick,
          style: _objectSpread2(_objectSpread2({
            zIndex
          }, wrapStyle), {}, {
            display: !animatedVisible ? "none" : null
          })
        }, wrapProps), /* @__PURE__ */ React__namespace.createElement(Content, _extends$1({}, props, {
          onMouseDown: onContentMouseDown,
          onMouseUp: onContentMouseUp,
          ref: contentRef,
          closable,
          ariaId,
          prefixCls,
          visible: visible && animatedVisible,
          onClose: onInternalClose,
          onVisibleChanged: onDialogVisibleChanged,
          motionName: getMotionName(prefixCls, transitionName, animation)
        }))));
      }
      var DialogWrap = function DialogWrap2(props) {
        var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
        var _React$useState = React__namespace.useState(visible), _React$useState2 = _slicedToArray$5(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
        React__namespace.useEffect(function() {
          if (visible) {
            setAnimatedVisible(true);
          }
        }, [visible]);
        if (!forceRender && destroyOnClose && !animatedVisible) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement(Portal, {
          open: visible || forceRender || animatedVisible,
          autoDestroy: false,
          getContainer: getContainer2,
          autoLock: visible || animatedVisible
        }, /* @__PURE__ */ React__namespace.createElement(Dialog, _extends$1({}, props, {
          destroyOnClose,
          afterClose: function afterClose() {
            _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
            setAnimatedVisible(false);
          }
        })));
      };
      DialogWrap.displayName = "Dialog";
      const canUseDocElement = () => canUseDom() && window.document.documentElement;
      let flexGapSupported;
      const detectFlexGapSupported = () => {
        if (!canUseDocElement()) {
          return false;
        }
        if (flexGapSupported !== void 0) {
          return flexGapSupported;
        }
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        flexGapSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return flexGapSupported;
      };
      var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
      var warningFunc = function warningFunc2() {
        warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
      };
      var Context = /* @__PURE__ */ React__namespace.createContext({
        getFieldValue: warningFunc,
        getFieldsValue: warningFunc,
        getFieldError: warningFunc,
        getFieldWarning: warningFunc,
        getFieldsError: warningFunc,
        isFieldsTouched: warningFunc,
        isFieldTouched: warningFunc,
        isFieldValidating: warningFunc,
        isFieldsValidating: warningFunc,
        resetFields: warningFunc,
        setFields: warningFunc,
        setFieldValue: warningFunc,
        setFieldsValue: warningFunc,
        validateFields: warningFunc,
        submit: warningFunc,
        getInternalHooks: function getInternalHooks() {
          warningFunc();
          return {
            dispatch: warningFunc,
            initEntityValue: warningFunc,
            registerField: warningFunc,
            useSubscribe: warningFunc,
            setInitialValues: warningFunc,
            destroyForm: warningFunc,
            setCallbacks: warningFunc,
            registerWatch: warningFunc,
            getFields: warningFunc,
            setValidateMessages: warningFunc,
            setPreserve: warningFunc,
            getInitialValue: warningFunc
          };
        }
      });
      var ListContext = /* @__PURE__ */ React__namespace.createContext(null);
      function toArray$4(value) {
        if (value === void 0 || value === null) {
          return [];
        }
        return Array.isArray(value) ? value : [value];
      }
      function isFormInstance(form) {
        return form && !!form._init;
      }
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key2 in source) {
              if (Object.prototype.hasOwnProperty.call(source, key2)) {
                target[key2] = source[key2];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning2(type2, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e2) {
              return typeof e2 === "string";
            })) {
              console.warn(type2, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format$1(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i2 = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i2 >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i2++]);
              case "%d":
                return Number(args[i2++]);
              case "%j":
                try {
                  return JSON.stringify(args[i2++]);
                } catch (_) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type2) {
        return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
      }
      function isEmptyValue(value, type2) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type2 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type2) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a) {
          func(a, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index2 = 0;
        var arrLength = arr.length;
        function next2(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index2;
          index2 = index2 + 1;
          if (original < arrLength) {
            func(arr[original], next2);
          } else {
            callback([]);
          }
        }
        next2([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k2) {
          ret.push.apply(ret, objArr[k2] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next2 = function next3(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next2);
          });
          _pending["catch"](function(e2) {
            return e2;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next2 = function next3(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key2) {
            var arr = objArr[key2];
            if (firstFields.indexOf(key2) !== -1) {
              asyncSerialArray(arr, func, next2);
            } else {
              asyncParallelArray(arr, func, next2);
            }
          });
        });
        pending["catch"](function(e2) {
          return e2;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue$1(value, path) {
        var v2 = value;
        for (var i2 = 0; i2 < path.length; i2++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i2]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue$1(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s in source) {
            if (source.hasOwnProperty(s)) {
              var value = source[s];
              if (typeof value === "object" && typeof target[s] === "object") {
                target[s] = _extends({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required2(rule, value, source, errors, options, type2) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
          errors.push(format$1(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format$1(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b3(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex2 = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex2 + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer2(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array2(value) {
          return Array.isArray(value);
        },
        regexp: function regexp2(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e2) {
            return false;
          }
        },
        date: function date2(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number2(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object2(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method2(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1$1 = function type2(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key2 = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key2 = "number";
        } else if (str) {
          key2 = "string";
        } else if (arr) {
          key2 = "array";
        }
        if (!key2) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format$1(options.messages[key2].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format$1(options.messages[key2].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format$1(options.messages[key2].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format$1(options.messages[key2].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern2(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method = function method2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number = function number2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp = function regexp2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer = function integer2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array = function array2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object = function object2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable = function enumerable2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern = function pattern2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date = function date2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required = function required2(rule, value, callback, source, options) {
        var errors = [];
        var type2 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type2);
        callback(errors);
      };
      var type$2 = function type2(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method,
        number,
        "boolean": _boolean,
        regexp,
        integer,
        "float": floatFn,
        array,
        object,
        "enum": enumerable,
        pattern,
        date,
        url: type$2,
        hex: type$2,
        email: type$2,
        required,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define2(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e2) {
              if (Array.isArray(e2)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e2);
              } else {
                errors.push(e2);
              }
            }
            for (var i2 = 0; i2 < results.length; i2++) {
              add(results[i2]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z2) {
            var arr = _this2.rules[z2];
            var value = source[z2];
            arr.forEach(function(r2) {
              var rule = r2;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z2] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z2;
              rule.fullField = rule.fullField || z2;
              rule.type = _this2.getType(rule);
              series[z2] = series[z2] || [];
              series[z2].push({
                rule,
                value,
                source,
                field: z2
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key2, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key2,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
              });
            }
            function cb(e2) {
              if (e2 === void 0) {
                e2 = [];
              }
              var errorList = Array.isArray(e2) ? e2 : [e2];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key2) {
                    fieldsSchema[key2] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e2) {
                return cb(e2);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType2(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format$1("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type2, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type2] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      var typeTemplate = "'${name}' is not a valid ${type}";
      var defaultValidateMessages = {
        default: "Validation error on field '${name}'",
        required: "'${name}' is required",
        enum: "'${name}' must be one of [${enum}]",
        whitespace: "'${name}' cannot be empty",
        date: {
          format: "'${name}' is invalid for format date",
          parse: "'${name}' could not be parsed as date",
          invalid: "'${name}' is invalid date"
        },
        types: {
          string: typeTemplate,
          method: typeTemplate,
          array: typeTemplate,
          object: typeTemplate,
          number: typeTemplate,
          date: typeTemplate,
          boolean: typeTemplate,
          integer: typeTemplate,
          float: typeTemplate,
          regexp: typeTemplate,
          email: typeTemplate,
          url: typeTemplate,
          hex: typeTemplate
        },
        string: {
          len: "'${name}' must be exactly ${len} characters",
          min: "'${name}' must be at least ${min} characters",
          max: "'${name}' cannot be longer than ${max} characters",
          range: "'${name}' must be between ${min} and ${max} characters"
        },
        number: {
          len: "'${name}' must equal ${len}",
          min: "'${name}' cannot be less than ${min}",
          max: "'${name}' cannot be greater than ${max}",
          range: "'${name}' must be between ${min} and ${max}"
        },
        array: {
          len: "'${name}' must be exactly ${len} in length",
          min: "'${name}' cannot be less than ${min} in length",
          max: "'${name}' cannot be greater than ${max} in length",
          range: "'${name}' must be between ${min} and ${max} in length"
        },
        pattern: {
          mismatch: "'${name}' does not match pattern ${pattern}"
        }
      };
      var AsyncValidator = Schema;
      function replaceMessage(template, kv) {
        return template.replace(/\$\{\w+\}/g, function(str) {
          var key2 = str.slice(2, -1);
          return kv[key2];
        });
      }
      var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
      function validateRule(_x, _x2, _x3, _x4, _x5) {
        return _validateRule.apply(this, arguments);
      }
      function _validateRule() {
        _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
          var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1)
              switch (_context2.prev = _context2.next) {
                case 0:
                  cloneRule = _objectSpread2({}, rule);
                  delete cloneRule.ruleIndex;
                  AsyncValidator.warning = function() {
                    return void 0;
                  };
                  if (cloneRule.validator) {
                    originValidator = cloneRule.validator;
                    cloneRule.validator = function() {
                      try {
                        return originValidator.apply(void 0, arguments);
                      } catch (error) {
                        console.error(error);
                        return Promise.reject(CODE_LOGIC_ERROR);
                      }
                    };
                  }
                  subRuleField = null;
                  if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                    subRuleField = cloneRule.defaultField;
                    delete cloneRule.defaultField;
                  }
                  validator = new AsyncValidator(_defineProperty$3({}, name, [cloneRule]));
                  messages2 = merge$1(defaultValidateMessages, options.validateMessages);
                  validator.messages(messages2);
                  result = [];
                  _context2.prev = 10;
                  _context2.next = 13;
                  return Promise.resolve(validator.validate(_defineProperty$3({}, name, value), _objectSpread2({}, options)));
                case 13:
                  _context2.next = 18;
                  break;
                case 15:
                  _context2.prev = 15;
                  _context2.t0 = _context2["catch"](10);
                  if (_context2.t0.errors) {
                    result = _context2.t0.errors.map(function(_ref4, index2) {
                      var message = _ref4.message;
                      var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                      return /* @__PURE__ */ React__namespace.isValidElement(mergedMessage) ? (
                        // Wrap ReactNode with `key`
                        /* @__PURE__ */ React__namespace.cloneElement(mergedMessage, {
                          key: "error_".concat(index2)
                        })
                      ) : mergedMessage;
                    });
                  }
                case 18:
                  if (!(!result.length && subRuleField)) {
                    _context2.next = 23;
                    break;
                  }
                  _context2.next = 21;
                  return Promise.all(value.map(function(subValue, i2) {
                    return validateRule("".concat(name, ".").concat(i2), subValue, subRuleField, options, messageVariables);
                  }));
                case 21:
                  subResults = _context2.sent;
                  return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                    return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
                  }, []));
                case 23:
                  kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                    name,
                    enum: (rule.enum || []).join(", ")
                  }, messageVariables);
                  fillVariableResult = result.map(function(error) {
                    if (typeof error === "string") {
                      return replaceMessage(error, kv);
                    }
                    return error;
                  });
                  return _context2.abrupt("return", fillVariableResult);
                case 26:
                case "end":
                  return _context2.stop();
              }
          }, _callee2, null, [[10, 15]]);
        }));
        return _validateRule.apply(this, arguments);
      }
      function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
        var name = namePath.join(".");
        var filledRules = rules2.map(function(currentRule, ruleIndex) {
          var originValidatorFunc = currentRule.validator;
          var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
            ruleIndex
          });
          if (originValidatorFunc) {
            cloneRule.validator = function(rule, val, callback) {
              var hasPromise = false;
              var wrappedCallback = function wrappedCallback2() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                Promise.resolve().then(function() {
                  warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
                  if (!hasPromise) {
                    callback.apply(void 0, args);
                  }
                });
              };
              var promise = originValidatorFunc(rule, val, wrappedCallback);
              hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
              warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
              if (hasPromise) {
                promise.then(function() {
                  callback();
                }).catch(function(err) {
                  callback(err || " ");
                });
              }
            };
          }
          return cloneRule;
        }).sort(function(_ref, _ref2) {
          var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
          var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
          if (!!w1 === !!w2) {
            return i1 - i2;
          }
          if (w1) {
            return 1;
          }
          return -1;
        });
        var summaryPromise;
        if (validateFirst === true) {
          summaryPromise = new Promise(/* @__PURE__ */ function() {
            var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
              var i2, rule, errors;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1)
                  switch (_context.prev = _context.next) {
                    case 0:
                      i2 = 0;
                    case 1:
                      if (!(i2 < filledRules.length)) {
                        _context.next = 12;
                        break;
                      }
                      rule = filledRules[i2];
                      _context.next = 5;
                      return validateRule(name, value, rule, options, messageVariables);
                    case 5:
                      errors = _context.sent;
                      if (!errors.length) {
                        _context.next = 9;
                        break;
                      }
                      reject([{
                        errors,
                        rule
                      }]);
                      return _context.abrupt("return");
                    case 9:
                      i2 += 1;
                      _context.next = 1;
                      break;
                    case 12:
                      resolve([]);
                    case 13:
                    case "end":
                      return _context.stop();
                  }
              }, _callee);
            }));
            return function(_x6, _x7) {
              return _ref3.apply(this, arguments);
            };
          }());
        } else {
          var rulePromises = filledRules.map(function(rule) {
            return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
              return {
                errors,
                rule
              };
            });
          });
          summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
            return Promise.reject(errors);
          });
        }
        summaryPromise.catch(function(e2) {
          return e2;
        });
        return summaryPromise;
      }
      function finishOnAllFailed(_x8) {
        return _finishOnAllFailed.apply(this, arguments);
      }
      function _finishOnAllFailed() {
        _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1)
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                    var _ref5;
                    var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                    return errors;
                  }));
                case 1:
                case "end":
                  return _context3.stop();
              }
          }, _callee3);
        }));
        return _finishOnAllFailed.apply(this, arguments);
      }
      function finishOnFirstFailed(_x9) {
        return _finishOnFirstFailed.apply(this, arguments);
      }
      function _finishOnFirstFailed() {
        _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
          var count;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1)
              switch (_context4.prev = _context4.next) {
                case 0:
                  count = 0;
                  return _context4.abrupt("return", new Promise(function(resolve) {
                    rulePromises.forEach(function(promise) {
                      promise.then(function(ruleError) {
                        if (ruleError.errors.length) {
                          resolve([ruleError]);
                        }
                        count += 1;
                        if (count === rulePromises.length) {
                          resolve([]);
                        }
                      });
                    });
                  }));
                case 2:
                case "end":
                  return _context4.stop();
              }
          }, _callee4);
        }));
        return _finishOnFirstFailed.apply(this, arguments);
      }
      function getNamePath(path) {
        return toArray$4(path);
      }
      function cloneByNamePathList(store, namePathList) {
        var newStore = {};
        namePathList.forEach(function(namePath) {
          var value = get(store, namePath);
          newStore = set(newStore, namePath, value);
        });
        return newStore;
      }
      function containsNamePath(namePathList, namePath) {
        return namePathList && namePathList.some(function(path) {
          return matchNamePath(path, namePath);
        });
      }
      function matchNamePath(namePath, changedNamePath) {
        if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
          return false;
        }
        return namePath.every(function(nameUnit, i2) {
          return changedNamePath[i2] === nameUnit;
        });
      }
      function isSimilar(source, target) {
        if (source === target) {
          return true;
        }
        if (!source && target || source && !target) {
          return false;
        }
        if (!source || !target || _typeof$3(source) !== "object" || _typeof$3(target) !== "object") {
          return false;
        }
        var sourceKeys = Object.keys(source);
        var targetKeys = Object.keys(target);
        var keys2 = new Set([].concat(sourceKeys, targetKeys));
        return _toConsumableArray(keys2).every(function(key2) {
          var sourceValue = source[key2];
          var targetValue = target[key2];
          if (typeof sourceValue === "function" && typeof targetValue === "function") {
            return true;
          }
          return sourceValue === targetValue;
        });
      }
      function defaultGetValueFromEvent(valuePropName) {
        var event = arguments.length <= 1 ? void 0 : arguments[1];
        if (event && event.target && _typeof$3(event.target) === "object" && valuePropName in event.target) {
          return event.target[valuePropName];
        }
        return event;
      }
      function move(array2, moveIndex, toIndex) {
        var length2 = array2.length;
        if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
          return array2;
        }
        var item = array2[moveIndex];
        var diff = moveIndex - toIndex;
        if (diff > 0) {
          return [].concat(_toConsumableArray(array2.slice(0, toIndex)), [item], _toConsumableArray(array2.slice(toIndex, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, length2)));
        }
        if (diff < 0) {
          return [].concat(_toConsumableArray(array2.slice(0, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array2.slice(toIndex + 1, length2)));
        }
        return array2;
      }
      var _excluded$7 = ["name"];
      var EMPTY_ERRORS = [];
      function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
        if (typeof shouldUpdate === "function") {
          return shouldUpdate(prev2, next2, "source" in info ? {
            source: info.source
          } : {});
        }
        return prevValue !== nextValue;
      }
      var Field = /* @__PURE__ */ function(_React$Component) {
        _inherits(Field2, _React$Component);
        var _super = _createSuper(Field2);
        function Field2(props) {
          var _this;
          _classCallCheck$1(this, Field2);
          _this = _super.call(this, props);
          _this.state = {
            resetCount: 0
          };
          _this.cancelRegisterFunc = null;
          _this.mounted = false;
          _this.touched = false;
          _this.dirty = false;
          _this.validatePromise = void 0;
          _this.prevValidating = void 0;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.cancelRegister = function() {
            var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
            if (_this.cancelRegisterFunc) {
              _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
            }
            _this.cancelRegisterFunc = null;
          };
          _this.getNamePath = function() {
            var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
            var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
            return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
          };
          _this.getRules = function() {
            var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
            return rules2.map(function(rule) {
              if (typeof rule === "function") {
                return rule(fieldContext);
              }
              return rule;
            });
          };
          _this.refresh = function() {
            if (!_this.mounted)
              return;
            _this.setState(function(_ref) {
              var resetCount = _ref.resetCount;
              return {
                resetCount: resetCount + 1
              };
            });
          };
          _this.triggerMetaEvent = function(destroy) {
            var onMetaChange = _this.props.onMetaChange;
            onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
              destroy
            }));
          };
          _this.onStoreChange = function(prevStore, namePathList, info) {
            var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
            var store = info.store;
            var namePath = _this.getNamePath();
            var prevValue = _this.getValue(prevStore);
            var curValue = _this.getValue(store);
            var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
            if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
              _this.touched = true;
              _this.dirty = true;
              _this.validatePromise = null;
              _this.errors = EMPTY_ERRORS;
              _this.warnings = EMPTY_ERRORS;
              _this.triggerMetaEvent();
            }
            switch (info.type) {
              case "reset":
                if (!namePathList || namePathMatch) {
                  _this.touched = false;
                  _this.dirty = false;
                  _this.validatePromise = void 0;
                  _this.errors = EMPTY_ERRORS;
                  _this.warnings = EMPTY_ERRORS;
                  _this.triggerMetaEvent();
                  onReset === null || onReset === void 0 ? void 0 : onReset();
                  _this.refresh();
                  return;
                }
                break;
              case "remove": {
                if (shouldUpdate) {
                  _this.reRender();
                  return;
                }
                break;
              }
              case "setField": {
                if (namePathMatch) {
                  var data = info.data;
                  if ("touched" in data) {
                    _this.touched = data.touched;
                  }
                  if ("validating" in data && !("originRCField" in data)) {
                    _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                  }
                  if ("errors" in data) {
                    _this.errors = data.errors || EMPTY_ERRORS;
                  }
                  if ("warnings" in data) {
                    _this.warnings = data.warnings || EMPTY_ERRORS;
                  }
                  _this.dirty = true;
                  _this.triggerMetaEvent();
                  _this.reRender();
                  return;
                }
                if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                  _this.reRender();
                  return;
                }
                break;
              }
              case "dependenciesUpdate": {
                var dependencyList = dependencies.map(getNamePath);
                if (dependencyList.some(function(dependency) {
                  return containsNamePath(info.relatedFields, dependency);
                })) {
                  _this.reRender();
                  return;
                }
                break;
              }
              default:
                if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                  _this.reRender();
                  return;
                }
                break;
            }
            if (shouldUpdate === true) {
              _this.reRender();
            }
          };
          _this.validateRules = function(options) {
            var namePath = _this.getNamePath();
            var currentValue = _this.getValue();
            var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
            var rootPromise = Promise.resolve().then(function() {
              if (!_this.mounted) {
                return [];
              }
              var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
              var filteredRules = _this.getRules();
              if (triggerName) {
                filteredRules = filteredRules.filter(function(rule) {
                  return rule;
                }).filter(function(rule) {
                  var validateTrigger = rule.validateTrigger;
                  if (!validateTrigger) {
                    return true;
                  }
                  var triggerList = toArray$4(validateTrigger);
                  return triggerList.includes(triggerName);
                });
              }
              var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
              promise.catch(function(e2) {
                return e2;
              }).then(function() {
                var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                if (_this.validatePromise === rootPromise) {
                  var _ruleErrors$forEach;
                  _this.validatePromise = null;
                  var nextErrors = [];
                  var nextWarnings = [];
                  (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
                    var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
                    if (warningOnly) {
                      nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                    } else {
                      nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                    }
                  });
                  _this.errors = nextErrors;
                  _this.warnings = nextWarnings;
                  _this.triggerMetaEvent();
                  _this.reRender();
                }
              });
              return promise;
            });
            if (validateOnly) {
              return rootPromise;
            }
            _this.validatePromise = rootPromise;
            _this.dirty = true;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
            _this.reRender();
            return rootPromise;
          };
          _this.isFieldValidating = function() {
            return !!_this.validatePromise;
          };
          _this.isFieldTouched = function() {
            return _this.touched;
          };
          _this.isFieldDirty = function() {
            if (_this.dirty || _this.props.initialValue !== void 0) {
              return true;
            }
            var fieldContext = _this.props.fieldContext;
            var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue2 = _fieldContext$getInte.getInitialValue;
            if (getInitialValue2(_this.getNamePath()) !== void 0) {
              return true;
            }
            return false;
          };
          _this.getErrors = function() {
            return _this.errors;
          };
          _this.getWarnings = function() {
            return _this.warnings;
          };
          _this.isListField = function() {
            return _this.props.isListField;
          };
          _this.isList = function() {
            return _this.props.isList;
          };
          _this.isPreserve = function() {
            return _this.props.preserve;
          };
          _this.getMeta = function() {
            _this.prevValidating = _this.isFieldValidating();
            var meta = {
              touched: _this.isFieldTouched(),
              validating: _this.prevValidating,
              errors: _this.errors,
              warnings: _this.warnings,
              name: _this.getNamePath(),
              validated: _this.validatePromise === null
            };
            return meta;
          };
          _this.getOnlyChild = function(children) {
            if (typeof children === "function") {
              var meta = _this.getMeta();
              return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
                isFunction: true
              });
            }
            var childList = toArray$5(children);
            if (childList.length !== 1 || !/* @__PURE__ */ React__namespace.isValidElement(childList[0])) {
              return {
                child: childList,
                isFunction: false
              };
            }
            return {
              child: childList[0],
              isFunction: false
            };
          };
          _this.getValue = function(store) {
            var getFieldsValue = _this.props.fieldContext.getFieldsValue;
            var namePath = _this.getNamePath();
            return get(store || getFieldsValue(true), namePath);
          };
          _this.getControlled = function() {
            var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
            var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
            var namePath = _this.getNamePath();
            var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
            var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
            var value = _this.getValue();
            var mergedGetValueProps = getValueProps || function(val) {
              return _defineProperty$3({}, valuePropName, val);
            };
            var originTriggerFunc = childProps[trigger];
            var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
            control[trigger] = function() {
              _this.touched = true;
              _this.dirty = true;
              _this.triggerMetaEvent();
              var newValue;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (getValueFromEvent) {
                newValue = getValueFromEvent.apply(void 0, args);
              } else {
                newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
              }
              if (normalize2) {
                newValue = normalize2(newValue, value, getFieldsValue(true));
              }
              dispatch({
                type: "updateValue",
                namePath,
                value: newValue
              });
              if (originTriggerFunc) {
                originTriggerFunc.apply(void 0, args);
              }
            };
            var validateTriggerList = toArray$4(mergedValidateTrigger || []);
            validateTriggerList.forEach(function(triggerName) {
              var originTrigger = control[triggerName];
              control[triggerName] = function() {
                if (originTrigger) {
                  originTrigger.apply(void 0, arguments);
                }
                var rules2 = _this.props.rules;
                if (rules2 && rules2.length) {
                  dispatch({
                    type: "validateField",
                    namePath,
                    triggerName
                  });
                }
              };
            });
            return control;
          };
          if (props.fieldContext) {
            var getInternalHooks = props.fieldContext.getInternalHooks;
            var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
            initEntityValue(_assertThisInitialized(_this));
          }
          return _this;
        }
        _createClass$1(Field2, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
            this.mounted = true;
            if (fieldContext) {
              var getInternalHooks = fieldContext.getInternalHooks;
              var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
              this.cancelRegisterFunc = registerField(this);
            }
            if (shouldUpdate === true) {
              this.reRender();
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.cancelRegister();
            this.triggerMetaEvent(true);
            this.mounted = false;
          }
        }, {
          key: "reRender",
          value: function reRender() {
            if (!this.mounted)
              return;
            this.forceUpdate();
          }
        }, {
          key: "render",
          value: function render2() {
            var resetCount = this.state.resetCount;
            var children = this.props.children;
            var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
            var returnChildNode;
            if (isFunction2) {
              returnChildNode = child;
            } else if (/* @__PURE__ */ React__namespace.isValidElement(child)) {
              returnChildNode = /* @__PURE__ */ React__namespace.cloneElement(child, this.getControlled(child.props));
            } else {
              warningOnce(!child, "`children` of Field is not validate ReactElement.");
              returnChildNode = child;
            }
            return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
              key: resetCount
            }, returnChildNode);
          }
        }]);
        return Field2;
      }(React__namespace.Component);
      Field.contextType = Context;
      Field.defaultProps = {
        trigger: "onChange",
        valuePropName: "value"
      };
      function WrapperField(_ref5) {
        var name = _ref5.name, restProps = _objectWithoutProperties(_ref5, _excluded$7);
        var fieldContext = React__namespace.useContext(Context);
        var listContext = React__namespace.useContext(ListContext);
        var namePath = name !== void 0 ? getNamePath(name) : void 0;
        var key2 = "keep";
        if (!restProps.isListField) {
          key2 = "_".concat((namePath || []).join("_"));
        }
        return /* @__PURE__ */ React__namespace.createElement(Field, _extends$1({
          key: key2,
          name: namePath,
          isListField: !!listContext
        }, restProps, {
          fieldContext
        }));
      }
      var List$1 = function List2(_ref) {
        var name = _ref.name, initialValue2 = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
        var context = React__namespace.useContext(Context);
        var wrapperListContext = React__namespace.useContext(ListContext);
        var keyRef = React__namespace.useRef({
          keys: [],
          id: 0
        });
        var keyManager = keyRef.current;
        var prefixName = React__namespace.useMemo(function() {
          var parentPrefixName = getNamePath(context.prefixName) || [];
          return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
        }, [context.prefixName, name]);
        var fieldContext = React__namespace.useMemo(function() {
          return _objectSpread2(_objectSpread2({}, context), {}, {
            prefixName
          });
        }, [context, prefixName]);
        var listContext = React__namespace.useMemo(function() {
          return {
            getKey: function getKey(namePath) {
              var len = prefixName.length;
              var pathName = namePath[len];
              return [keyManager.keys[pathName], namePath.slice(len + 1)];
            }
          };
        }, [prefixName]);
        if (typeof children !== "function") {
          warningOnce(false, "Form.List only accepts function as children.");
          return null;
        }
        var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
          var source = _ref2.source;
          if (source === "internal") {
            return false;
          }
          return prevValue !== nextValue;
        };
        return /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
          value: listContext
        }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
          value: fieldContext
        }, /* @__PURE__ */ React__namespace.createElement(WrapperField, {
          name: [],
          shouldUpdate,
          rules: rules2,
          validateTrigger,
          initialValue: initialValue2,
          isList: true,
          isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
        }, function(_ref3, meta) {
          var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
          var getFieldValue = context.getFieldValue;
          var getNewValue = function getNewValue2() {
            var values = getFieldValue(prefixName || []);
            return values || [];
          };
          var operations = {
            add: function add(defaultValue, index2) {
              var newValue = getNewValue();
              if (index2 >= 0 && index2 <= newValue.length) {
                keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
                onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
              } else {
                keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
                onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
              }
              keyManager.id += 1;
            },
            remove: function remove(index2) {
              var newValue = getNewValue();
              var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
              if (indexSet.size <= 0) {
                return;
              }
              keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
                return !indexSet.has(keysIndex);
              });
              onChange(newValue.filter(function(_, valueIndex) {
                return !indexSet.has(valueIndex);
              }));
            },
            move: function move$1(from2, to) {
              if (from2 === to) {
                return;
              }
              var newValue = getNewValue();
              if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
                return;
              }
              keyManager.keys = move(keyManager.keys, from2, to);
              onChange(move(newValue, from2, to));
            }
          };
          var listValue = value || [];
          if (!Array.isArray(listValue)) {
            listValue = [];
          }
          return children(listValue.map(function(__, index2) {
            var key2 = keyManager.keys[index2];
            if (key2 === void 0) {
              keyManager.keys[index2] = keyManager.id;
              key2 = keyManager.keys[index2];
              keyManager.id += 1;
            }
            return {
              name: index2,
              key: key2,
              isListField: true
            };
          }), operations, meta);
        })));
      };
      function allPromiseFinish(promiseList) {
        var hasError = false;
        var count = promiseList.length;
        var results = [];
        if (!promiseList.length) {
          return Promise.resolve([]);
        }
        return new Promise(function(resolve, reject) {
          promiseList.forEach(function(promise, index2) {
            promise.catch(function(e2) {
              hasError = true;
              return e2;
            }).then(function(result) {
              count -= 1;
              results[index2] = result;
              if (count > 0) {
                return;
              }
              if (hasError) {
                reject(results);
              }
              resolve(results);
            });
          });
        });
      }
      var SPLIT = "__@field_split__";
      function normalize$1(namePath) {
        return namePath.map(function(cell) {
          return "".concat(_typeof$3(cell), ":").concat(cell);
        }).join(SPLIT);
      }
      var NameMap = /* @__PURE__ */ function() {
        function NameMap2() {
          _classCallCheck$1(this, NameMap2);
          this.kvs = /* @__PURE__ */ new Map();
        }
        _createClass$1(NameMap2, [{
          key: "set",
          value: function set2(key2, value) {
            this.kvs.set(normalize$1(key2), value);
          }
        }, {
          key: "get",
          value: function get2(key2) {
            return this.kvs.get(normalize$1(key2));
          }
        }, {
          key: "update",
          value: function update(key2, updater) {
            var origin = this.get(key2);
            var next2 = updater(origin);
            if (!next2) {
              this.delete(key2);
            } else {
              this.set(key2, next2);
            }
          }
        }, {
          key: "delete",
          value: function _delete(key2) {
            this.kvs.delete(normalize$1(key2));
          }
          // Since we only use this in test, let simply realize this
        }, {
          key: "map",
          value: function map(callback) {
            return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
              var _ref2 = _slicedToArray$5(_ref, 2), key2 = _ref2[0], value = _ref2[1];
              var cells = key2.split(SPLIT);
              return callback({
                key: cells.map(function(cell) {
                  var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray$5(_cell$match, 3), type2 = _cell$match2[1], unit = _cell$match2[2];
                  return type2 === "number" ? Number(unit) : unit;
                }),
                value
              });
            });
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            var json = {};
            this.map(function(_ref3) {
              var key2 = _ref3.key, value = _ref3.value;
              json[key2.join(".")] = value;
              return null;
            });
            return json;
          }
        }]);
        return NameMap2;
      }();
      var _excluded$6 = ["name"];
      var FormStore = /* @__PURE__ */ _createClass$1(function FormStore2(forceRootUpdate) {
        var _this = this;
        _classCallCheck$1(this, FormStore2);
        this.formHooked = false;
        this.forceRootUpdate = void 0;
        this.subscribable = true;
        this.store = {};
        this.fieldEntities = [];
        this.initialValues = {};
        this.callbacks = {};
        this.validateMessages = null;
        this.preserve = null;
        this.lastValidatePromise = null;
        this.getForm = function() {
          return {
            getFieldValue: _this.getFieldValue,
            getFieldsValue: _this.getFieldsValue,
            getFieldError: _this.getFieldError,
            getFieldWarning: _this.getFieldWarning,
            getFieldsError: _this.getFieldsError,
            isFieldsTouched: _this.isFieldsTouched,
            isFieldTouched: _this.isFieldTouched,
            isFieldValidating: _this.isFieldValidating,
            isFieldsValidating: _this.isFieldsValidating,
            resetFields: _this.resetFields,
            setFields: _this.setFields,
            setFieldValue: _this.setFieldValue,
            setFieldsValue: _this.setFieldsValue,
            validateFields: _this.validateFields,
            submit: _this.submit,
            _init: true,
            getInternalHooks: _this.getInternalHooks
          };
        };
        this.getInternalHooks = function(key2) {
          if (key2 === HOOK_MARK) {
            _this.formHooked = true;
            return {
              dispatch: _this.dispatch,
              initEntityValue: _this.initEntityValue,
              registerField: _this.registerField,
              useSubscribe: _this.useSubscribe,
              setInitialValues: _this.setInitialValues,
              destroyForm: _this.destroyForm,
              setCallbacks: _this.setCallbacks,
              setValidateMessages: _this.setValidateMessages,
              getFields: _this.getFields,
              setPreserve: _this.setPreserve,
              getInitialValue: _this.getInitialValue,
              registerWatch: _this.registerWatch
            };
          }
          warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
          return null;
        };
        this.useSubscribe = function(subscribable) {
          _this.subscribable = subscribable;
        };
        this.prevWithoutPreserves = null;
        this.setInitialValues = function(initialValues, init) {
          _this.initialValues = initialValues || {};
          if (init) {
            var _this$prevWithoutPres;
            var nextStore = merge$1(initialValues, _this.store);
            (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
              var namePath = _ref.key;
              nextStore = set(nextStore, namePath, get(initialValues, namePath));
            });
            _this.prevWithoutPreserves = null;
            _this.updateStore(nextStore);
          }
        };
        this.destroyForm = function() {
          var prevWithoutPreserves = new NameMap();
          _this.getFieldEntities(true).forEach(function(entity) {
            if (!_this.isMergedPreserve(entity.isPreserve())) {
              prevWithoutPreserves.set(entity.getNamePath(), true);
            }
          });
          _this.prevWithoutPreserves = prevWithoutPreserves;
        };
        this.getInitialValue = function(namePath) {
          var initValue = get(_this.initialValues, namePath);
          return namePath.length ? merge$1(initValue) : initValue;
        };
        this.setCallbacks = function(callbacks) {
          _this.callbacks = callbacks;
        };
        this.setValidateMessages = function(validateMessages) {
          _this.validateMessages = validateMessages;
        };
        this.setPreserve = function(preserve) {
          _this.preserve = preserve;
        };
        this.watchList = [];
        this.registerWatch = function(callback) {
          _this.watchList.push(callback);
          return function() {
            _this.watchList = _this.watchList.filter(function(fn) {
              return fn !== callback;
            });
          };
        };
        this.notifyWatch = function() {
          var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          if (_this.watchList.length) {
            var values = _this.getFieldsValue();
            var allValues = _this.getFieldsValue(true);
            _this.watchList.forEach(function(callback) {
              callback(values, allValues, namePath);
            });
          }
        };
        this.timeoutId = null;
        this.warningUnhooked = function() {
        };
        this.updateStore = function(nextStore) {
          _this.store = nextStore;
        };
        this.getFieldEntities = function() {
          var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          if (!pure) {
            return _this.fieldEntities;
          }
          return _this.fieldEntities.filter(function(field) {
            return field.getNamePath().length;
          });
        };
        this.getFieldsMap = function() {
          var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var cache = new NameMap();
          _this.getFieldEntities(pure).forEach(function(field) {
            var namePath = field.getNamePath();
            cache.set(namePath, field);
          });
          return cache;
        };
        this.getFieldEntitiesForNamePathList = function(nameList) {
          if (!nameList) {
            return _this.getFieldEntities(true);
          }
          var cache = _this.getFieldsMap(true);
          return nameList.map(function(name) {
            var namePath = getNamePath(name);
            return cache.get(namePath) || {
              INVALIDATE_NAME_PATH: getNamePath(name)
            };
          });
        };
        this.getFieldsValue = function(nameList, filterFunc) {
          _this.warningUnhooked();
          if (nameList === true && !filterFunc) {
            return _this.store;
          }
          var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
          var filteredNameList = [];
          fieldEntities.forEach(function(entity) {
            var _entity$isListField;
            var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
            if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
              return;
            }
            if (!filterFunc) {
              filteredNameList.push(namePath);
            } else {
              var meta = "getMeta" in entity ? entity.getMeta() : null;
              if (filterFunc(meta)) {
                filteredNameList.push(namePath);
              }
            }
          });
          return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
        };
        this.getFieldValue = function(name) {
          _this.warningUnhooked();
          var namePath = getNamePath(name);
          return get(_this.store, namePath);
        };
        this.getFieldsError = function(nameList) {
          _this.warningUnhooked();
          var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
          return fieldEntities.map(function(entity, index2) {
            if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
              return {
                name: entity.getNamePath(),
                errors: entity.getErrors(),
                warnings: entity.getWarnings()
              };
            }
            return {
              name: getNamePath(nameList[index2]),
              errors: [],
              warnings: []
            };
          });
        };
        this.getFieldError = function(name) {
          _this.warningUnhooked();
          var namePath = getNamePath(name);
          var fieldError = _this.getFieldsError([namePath])[0];
          return fieldError.errors;
        };
        this.getFieldWarning = function(name) {
          _this.warningUnhooked();
          var namePath = getNamePath(name);
          var fieldError = _this.getFieldsError([namePath])[0];
          return fieldError.warnings;
        };
        this.isFieldsTouched = function() {
          _this.warningUnhooked();
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var arg0 = args[0], arg1 = args[1];
          var namePathList;
          var isAllFieldsTouched = false;
          if (args.length === 0) {
            namePathList = null;
          } else if (args.length === 1) {
            if (Array.isArray(arg0)) {
              namePathList = arg0.map(getNamePath);
              isAllFieldsTouched = false;
            } else {
              namePathList = null;
              isAllFieldsTouched = arg0;
            }
          } else {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = arg1;
          }
          var fieldEntities = _this.getFieldEntities(true);
          var isFieldTouched = function isFieldTouched2(field) {
            return field.isFieldTouched();
          };
          if (!namePathList) {
            return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
          }
          var map = new NameMap();
          namePathList.forEach(function(shortNamePath) {
            map.set(shortNamePath, []);
          });
          fieldEntities.forEach(function(field) {
            var fieldNamePath = field.getNamePath();
            namePathList.forEach(function(shortNamePath) {
              if (shortNamePath.every(function(nameUnit, i2) {
                return fieldNamePath[i2] === nameUnit;
              })) {
                map.update(shortNamePath, function(list) {
                  return [].concat(_toConsumableArray(list), [field]);
                });
              }
            });
          });
          var isNamePathListTouched = function isNamePathListTouched2(entities) {
            return entities.some(isFieldTouched);
          };
          var namePathListEntities = map.map(function(_ref2) {
            var value = _ref2.value;
            return value;
          });
          return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
        };
        this.isFieldTouched = function(name) {
          _this.warningUnhooked();
          return _this.isFieldsTouched([name]);
        };
        this.isFieldsValidating = function(nameList) {
          _this.warningUnhooked();
          var fieldEntities = _this.getFieldEntities();
          if (!nameList) {
            return fieldEntities.some(function(testField) {
              return testField.isFieldValidating();
            });
          }
          var namePathList = nameList.map(getNamePath);
          return fieldEntities.some(function(testField) {
            var fieldNamePath = testField.getNamePath();
            return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
          });
        };
        this.isFieldValidating = function(name) {
          _this.warningUnhooked();
          return _this.isFieldsValidating([name]);
        };
        this.resetWithFieldInitialValue = function() {
          var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var cache = new NameMap();
          var fieldEntities = _this.getFieldEntities(true);
          fieldEntities.forEach(function(field) {
            var initialValue2 = field.props.initialValue;
            var namePath = field.getNamePath();
            if (initialValue2 !== void 0) {
              var records = cache.get(namePath) || /* @__PURE__ */ new Set();
              records.add({
                entity: field,
                value: initialValue2
              });
              cache.set(namePath, records);
            }
          });
          var resetWithFields = function resetWithFields2(entities) {
            entities.forEach(function(field) {
              var initialValue2 = field.props.initialValue;
              if (initialValue2 !== void 0) {
                var namePath = field.getNamePath();
                var formInitialValue = _this.getInitialValue(namePath);
                if (formInitialValue !== void 0) {
                  warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
                } else {
                  var records = cache.get(namePath);
                  if (records && records.size > 1) {
                    warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                  } else if (records) {
                    var originValue = _this.getFieldValue(namePath);
                    if (!info.skipExist || originValue === void 0) {
                      _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                    }
                  }
                }
              }
            });
          };
          var requiredFieldEntities;
          if (info.entities) {
            requiredFieldEntities = info.entities;
          } else if (info.namePathList) {
            requiredFieldEntities = [];
            info.namePathList.forEach(function(namePath) {
              var records = cache.get(namePath);
              if (records) {
                var _requiredFieldEntitie;
                (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
                  return r2.entity;
                })));
              }
            });
          } else {
            requiredFieldEntities = fieldEntities;
          }
          resetWithFields(requiredFieldEntities);
        };
        this.resetFields = function(nameList) {
          _this.warningUnhooked();
          var prevStore = _this.store;
          if (!nameList) {
            _this.updateStore(merge$1(_this.initialValues));
            _this.resetWithFieldInitialValue();
            _this.notifyObservers(prevStore, null, {
              type: "reset"
            });
            _this.notifyWatch();
            return;
          }
          var namePathList = nameList.map(getNamePath);
          namePathList.forEach(function(namePath) {
            var initialValue2 = _this.getInitialValue(namePath);
            _this.updateStore(set(_this.store, namePath, initialValue2));
          });
          _this.resetWithFieldInitialValue({
            namePathList
          });
          _this.notifyObservers(prevStore, namePathList, {
            type: "reset"
          });
          _this.notifyWatch(namePathList);
        };
        this.setFields = function(fields) {
          _this.warningUnhooked();
          var prevStore = _this.store;
          var namePathList = [];
          fields.forEach(function(fieldData) {
            var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$6);
            var namePath = getNamePath(name);
            namePathList.push(namePath);
            if ("value" in data) {
              _this.updateStore(set(_this.store, namePath, data.value));
            }
            _this.notifyObservers(prevStore, [namePath], {
              type: "setField",
              data: fieldData
            });
          });
          _this.notifyWatch(namePathList);
        };
        this.getFields = function() {
          var entities = _this.getFieldEntities(true);
          var fields = entities.map(function(field) {
            var namePath = field.getNamePath();
            var meta = field.getMeta();
            var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
              name: namePath,
              value: _this.getFieldValue(namePath)
            });
            Object.defineProperty(fieldData, "originRCField", {
              value: true
            });
            return fieldData;
          });
          return fields;
        };
        this.initEntityValue = function(entity) {
          var initialValue2 = entity.props.initialValue;
          if (initialValue2 !== void 0) {
            var namePath = entity.getNamePath();
            var prevValue = get(_this.store, namePath);
            if (prevValue === void 0) {
              _this.updateStore(set(_this.store, namePath, initialValue2));
            }
          }
        };
        this.isMergedPreserve = function(fieldPreserve) {
          var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
          return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
        };
        this.registerField = function(entity) {
          _this.fieldEntities.push(entity);
          var namePath = entity.getNamePath();
          _this.notifyWatch([namePath]);
          if (entity.props.initialValue !== void 0) {
            var prevStore = _this.store;
            _this.resetWithFieldInitialValue({
              entities: [entity],
              skipExist: true
            });
            _this.notifyObservers(prevStore, [entity.getNamePath()], {
              type: "valueUpdate",
              source: "internal"
            });
          }
          return function(isListField, preserve) {
            var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            _this.fieldEntities = _this.fieldEntities.filter(function(item) {
              return item !== entity;
            });
            if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
              var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
              if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
                return (
                  // Only reset when no namePath exist
                  !matchNamePath(field.getNamePath(), namePath)
                );
              })) {
                var _prevStore = _this.store;
                _this.updateStore(set(_prevStore, namePath, defaultValue, true));
                _this.notifyObservers(_prevStore, [namePath], {
                  type: "remove"
                });
                _this.triggerDependenciesUpdate(_prevStore, namePath);
              }
            }
            _this.notifyWatch([namePath]);
          };
        };
        this.dispatch = function(action) {
          switch (action.type) {
            case "updateValue": {
              var namePath = action.namePath, value = action.value;
              _this.updateValue(namePath, value);
              break;
            }
            case "validateField": {
              var _namePath = action.namePath, triggerName = action.triggerName;
              _this.validateFields([_namePath], {
                triggerName
              });
              break;
            }
          }
        };
        this.notifyObservers = function(prevStore, namePathList, info) {
          if (_this.subscribable) {
            var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
              store: _this.getFieldsValue(true)
            });
            _this.getFieldEntities().forEach(function(_ref3) {
              var onStoreChange = _ref3.onStoreChange;
              onStoreChange(prevStore, namePathList, mergedInfo);
            });
          } else {
            _this.forceRootUpdate();
          }
        };
        this.triggerDependenciesUpdate = function(prevStore, namePath) {
          var childrenFields = _this.getDependencyChildrenFields(namePath);
          if (childrenFields.length) {
            _this.validateFields(childrenFields);
          }
          _this.notifyObservers(prevStore, childrenFields, {
            type: "dependenciesUpdate",
            relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
          });
          return childrenFields;
        };
        this.updateValue = function(name, value) {
          var namePath = getNamePath(name);
          var prevStore = _this.store;
          _this.updateStore(set(_this.store, namePath, value));
          _this.notifyObservers(prevStore, [namePath], {
            type: "valueUpdate",
            source: "internal"
          });
          _this.notifyWatch([namePath]);
          var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
          var onValuesChange = _this.callbacks.onValuesChange;
          if (onValuesChange) {
            var changedValues = cloneByNamePathList(_this.store, [namePath]);
            onValuesChange(changedValues, _this.getFieldsValue());
          }
          _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
        };
        this.setFieldsValue = function(store) {
          _this.warningUnhooked();
          var prevStore = _this.store;
          if (store) {
            var nextStore = merge$1(_this.store, store);
            _this.updateStore(nextStore);
          }
          _this.notifyObservers(prevStore, null, {
            type: "valueUpdate",
            source: "external"
          });
          _this.notifyWatch();
        };
        this.setFieldValue = function(name, value) {
          _this.setFields([{
            name,
            value
          }]);
        };
        this.getDependencyChildrenFields = function(rootNamePath) {
          var children = /* @__PURE__ */ new Set();
          var childrenFields = [];
          var dependencies2fields = new NameMap();
          _this.getFieldEntities().forEach(function(field) {
            var dependencies = field.props.dependencies;
            (dependencies || []).forEach(function(dependency) {
              var dependencyNamePath = getNamePath(dependency);
              dependencies2fields.update(dependencyNamePath, function() {
                var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
                fields.add(field);
                return fields;
              });
            });
          });
          var fillChildren = function fillChildren2(namePath) {
            var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
            fields.forEach(function(field) {
              if (!children.has(field)) {
                children.add(field);
                var fieldNamePath = field.getNamePath();
                if (field.isFieldDirty() && fieldNamePath.length) {
                  childrenFields.push(fieldNamePath);
                  fillChildren2(fieldNamePath);
                }
              }
            });
          };
          fillChildren(rootNamePath);
          return childrenFields;
        };
        this.triggerOnFieldsChange = function(namePathList, filedErrors) {
          var onFieldsChange = _this.callbacks.onFieldsChange;
          if (onFieldsChange) {
            var fields = _this.getFields();
            if (filedErrors) {
              var cache = new NameMap();
              filedErrors.forEach(function(_ref4) {
                var name = _ref4.name, errors = _ref4.errors;
                cache.set(name, errors);
              });
              fields.forEach(function(field) {
                field.errors = cache.get(field.name) || field.errors;
              });
            }
            var changedFields = fields.filter(function(_ref5) {
              var fieldName = _ref5.name;
              return containsNamePath(namePathList, fieldName);
            });
            onFieldsChange(changedFields, fields);
          }
        };
        this.validateFields = function(arg1, arg2) {
          _this.warningUnhooked();
          var nameList;
          var options;
          if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
            nameList = arg1;
            options = arg2;
          } else {
            options = arg1;
          }
          var provideNameList = !!nameList;
          var namePathList = provideNameList ? nameList.map(getNamePath) : [];
          var promiseList = [];
          _this.getFieldEntities(true).forEach(function(field) {
            var _options;
            if (!provideNameList) {
              namePathList.push(field.getNamePath());
            }
            if (((_options = options) === null || _options === void 0 ? void 0 : _options.recursive) && provideNameList) {
              var namePath = field.getNamePath();
              if (
                // nameList[i] === undefined 说明是以 nameList 开头的
                // ['name'] -> ['name','list']
                namePath.every(function(nameUnit, i2) {
                  return nameList[i2] === nameUnit || nameList[i2] === void 0;
                })
              ) {
                namePathList.push(namePath);
              }
            }
            if (!field.props.rules || !field.props.rules.length) {
              return;
            }
            var fieldNamePath = field.getNamePath();
            if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
              var promise = field.validateRules(_objectSpread2({
                validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
              }, options));
              promiseList.push(promise.then(function() {
                return {
                  name: fieldNamePath,
                  errors: [],
                  warnings: []
                };
              }).catch(function(ruleErrors) {
                var _ruleErrors$forEach;
                var mergedErrors = [];
                var mergedWarnings = [];
                (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
                  var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
                  if (warningOnly) {
                    mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
                  } else {
                    mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                  }
                });
                if (mergedErrors.length) {
                  return Promise.reject({
                    name: fieldNamePath,
                    errors: mergedErrors,
                    warnings: mergedWarnings
                  });
                }
                return {
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                };
              }));
            }
          });
          var summaryPromise = allPromiseFinish(promiseList);
          _this.lastValidatePromise = summaryPromise;
          summaryPromise.catch(function(results) {
            return results;
          }).then(function(results) {
            var resultNamePathList = results.map(function(_ref7) {
              var name = _ref7.name;
              return name;
            });
            _this.notifyObservers(_this.store, resultNamePathList, {
              type: "validateFinish"
            });
            _this.triggerOnFieldsChange(resultNamePathList, results);
          });
          var returnPromise = summaryPromise.then(function() {
            if (_this.lastValidatePromise === summaryPromise) {
              return Promise.resolve(_this.getFieldsValue(namePathList));
            }
            return Promise.reject([]);
          }).catch(function(results) {
            var errorList = results.filter(function(result) {
              return result && result.errors.length;
            });
            return Promise.reject({
              values: _this.getFieldsValue(namePathList),
              errorFields: errorList,
              outOfDate: _this.lastValidatePromise !== summaryPromise
            });
          });
          returnPromise.catch(function(e2) {
            return e2;
          });
          _this.triggerOnFieldsChange(namePathList);
          return returnPromise;
        };
        this.submit = function() {
          _this.warningUnhooked();
          _this.validateFields().then(function(values) {
            var onFinish = _this.callbacks.onFinish;
            if (onFinish) {
              try {
                onFinish(values);
              } catch (err) {
                console.error(err);
              }
            }
          }).catch(function(e2) {
            var onFinishFailed = _this.callbacks.onFinishFailed;
            if (onFinishFailed) {
              onFinishFailed(e2);
            }
          });
        };
        this.forceRootUpdate = forceRootUpdate;
      });
      function useForm$1(form) {
        var formRef = React__namespace.useRef();
        var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray$5(_React$useState, 2), forceUpdate = _React$useState2[1];
        if (!formRef.current) {
          if (form) {
            formRef.current = form;
          } else {
            var forceReRender = function forceReRender2() {
              forceUpdate({});
            };
            var formStore = new FormStore(forceReRender);
            formRef.current = formStore.getForm();
          }
        }
        return [formRef.current];
      }
      var FormContext$1 = /* @__PURE__ */ React__namespace.createContext({
        triggerFormChange: function triggerFormChange() {
        },
        triggerFormFinish: function triggerFormFinish() {
        },
        registerForm: function registerForm() {
        },
        unregisterForm: function unregisterForm() {
        }
      });
      var FormProvider$1 = function FormProvider2(_ref) {
        var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
        var formContext = React__namespace.useContext(FormContext$1);
        var formsRef = React__namespace.useRef({});
        return /* @__PURE__ */ React__namespace.createElement(FormContext$1.Provider, {
          value: _objectSpread2(_objectSpread2({}, formContext), {}, {
            validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
            // =========================================================
            // =                  Global Form Control                  =
            // =========================================================
            triggerFormChange: function triggerFormChange(name, changedFields) {
              if (onFormChange) {
                onFormChange(name, {
                  changedFields,
                  forms: formsRef.current
                });
              }
              formContext.triggerFormChange(name, changedFields);
            },
            triggerFormFinish: function triggerFormFinish(name, values) {
              if (onFormFinish) {
                onFormFinish(name, {
                  values,
                  forms: formsRef.current
                });
              }
              formContext.triggerFormFinish(name, values);
            },
            registerForm: function registerForm(name, form) {
              if (name) {
                formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty$3({}, name, form));
              }
              formContext.registerForm(name, form);
            },
            unregisterForm: function unregisterForm(name) {
              var newForms = _objectSpread2({}, formsRef.current);
              delete newForms[name];
              formsRef.current = newForms;
              formContext.unregisterForm(name);
            }
          })
        }, children);
      };
      var _excluded$5 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
      var Form$3 = function Form2(_ref, ref) {
        var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded$5);
        var formContext = React__namespace.useContext(FormContext$1);
        var _useForm = useForm$1(form), _useForm2 = _slicedToArray$5(_useForm, 1), formInstance = _useForm2[0];
        var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
        React__namespace.useImperativeHandle(ref, function() {
          return formInstance;
        });
        React__namespace.useEffect(function() {
          formContext.registerForm(name, formInstance);
          return function() {
            formContext.unregisterForm(name);
          };
        }, [formContext, formInstance, name]);
        setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
        setCallbacks({
          onValuesChange,
          onFieldsChange: function onFieldsChange(changedFields) {
            formContext.triggerFormChange(name, changedFields);
            if (_onFieldsChange) {
              for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                rest[_key - 1] = arguments[_key];
              }
              _onFieldsChange.apply(void 0, [changedFields].concat(rest));
            }
          },
          onFinish: function onFinish(values2) {
            formContext.triggerFormFinish(name, values2);
            if (_onFinish) {
              _onFinish(values2);
            }
          },
          onFinishFailed
        });
        setPreserve(preserve);
        var mountRef = React__namespace.useRef(null);
        setInitialValues(initialValues, !mountRef.current);
        if (!mountRef.current) {
          mountRef.current = true;
        }
        React__namespace.useEffect(
          function() {
            return destroyForm;
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          []
        );
        var childrenNode;
        var childrenRenderProps = typeof children === "function";
        if (childrenRenderProps) {
          var values = formInstance.getFieldsValue(true);
          childrenNode = children(values, formInstance);
        } else {
          childrenNode = children;
        }
        useSubscribe(!childrenRenderProps);
        var prevFieldsRef = React__namespace.useRef();
        React__namespace.useEffect(function() {
          if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
            formInstance.setFields(fields || []);
          }
          prevFieldsRef.current = fields;
        }, [fields, formInstance]);
        var formContextValue = React__namespace.useMemo(function() {
          return _objectSpread2(_objectSpread2({}, formInstance), {}, {
            validateTrigger
          });
        }, [formInstance, validateTrigger]);
        var wrapperNode = /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
          value: null
        }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
          value: formContextValue
        }, childrenNode));
        if (Component === false) {
          return wrapperNode;
        }
        return /* @__PURE__ */ React__namespace.createElement(Component, _extends$1({}, restProps, {
          onSubmit: function onSubmit(event) {
            event.preventDefault();
            event.stopPropagation();
            formInstance.submit();
          },
          onReset: function onReset(event) {
            var _restProps$onReset;
            event.preventDefault();
            formInstance.resetFields();
            (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
          }
        }), wrapperNode);
      };
      function stringify(value) {
        try {
          return JSON.stringify(value);
        } catch (err) {
          return Math.random();
        }
      }
      function useWatch$1() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, _args$2 = args[1], _form = _args$2 === void 0 ? {} : _args$2;
        var options = isFormInstance(_form) ? {
          form: _form
        } : _form;
        var form = options.form;
        var _useState = React.useState(), _useState2 = _slicedToArray$5(_useState, 2), value = _useState2[0], setValue = _useState2[1];
        var valueStr = React.useMemo(function() {
          return stringify(value);
        }, [value]);
        var valueStrRef = React.useRef(valueStr);
        valueStrRef.current = valueStr;
        var fieldContext = React.useContext(Context);
        var formInstance = form || fieldContext;
        var isValidForm = formInstance && formInstance._init;
        var namePath = getNamePath(dependencies);
        var namePathRef = React.useRef(namePath);
        namePathRef.current = namePath;
        React.useEffect(
          function() {
            if (!isValidForm) {
              return;
            }
            var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
            var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
            var cancelRegister = registerWatch(function(values, allValues) {
              var newValue = get(options.preserve ? allValues : values, namePathRef.current);
              var nextValueStr = stringify(newValue);
              if (valueStrRef.current !== nextValueStr) {
                valueStrRef.current = nextValueStr;
                setValue(newValue);
              }
            });
            var initialValue2 = get(options.preserve ? getFieldsValue(true) : getFieldsValue(), namePathRef.current);
            setValue(initialValue2);
            return cancelRegister;
          },
          // We do not need re-register since namePath content is the same
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [isValidForm]
        );
        return value;
      }
      var InternalForm$2 = /* @__PURE__ */ React__namespace.forwardRef(Form$3);
      var RefForm = InternalForm$2;
      RefForm.FormProvider = FormProvider$1;
      RefForm.Field = WrapperField;
      RefForm.List = List$1;
      RefForm.useForm = useForm$1;
      RefForm.useWatch = useWatch$1;
      const FormContext = /* @__PURE__ */ React__namespace.createContext({
        labelAlign: "right",
        vertical: false,
        itemRef: () => {
        }
      });
      const NoStyleItemContext = /* @__PURE__ */ React__namespace.createContext(null);
      const FormProvider = (props) => {
        const providerProps = omit(props, ["prefixCls"]);
        return /* @__PURE__ */ React__namespace.createElement(FormProvider$1, Object.assign({}, providerProps));
      };
      const FormItemPrefixContext = /* @__PURE__ */ React__namespace.createContext({
        prefixCls: ""
      });
      const FormItemInputContext = /* @__PURE__ */ React__namespace.createContext({});
      const NoFormStyle = (_ref) => {
        let {
          children,
          status,
          override
        } = _ref;
        const formItemInputContext = React.useContext(FormItemInputContext);
        const newFormItemInputContext = React.useMemo(() => {
          const newContext = Object.assign({}, formItemInputContext);
          if (override) {
            delete newContext.isFormItemInput;
          }
          if (status) {
            delete newContext.status;
            delete newContext.hasFeedback;
            delete newContext.feedbackIcon;
          }
          return newContext;
        }, [status, override, formItemInputContext]);
        return /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
          value: newFormItemInputContext
        }, children);
      };
      function renderCloseIcon(prefixCls, closeIcon) {
        return /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-close-x`
        }, closeIcon || /* @__PURE__ */ React.createElement(CloseOutlined$1, {
          className: `${prefixCls}-close-icon`
        }));
      }
      const Footer = (props) => {
        const {
          okText,
          okType = "primary",
          cancelText,
          confirmLoading,
          onOk,
          onCancel,
          okButtonProps,
          cancelButtonProps
        } = props;
        const [locale2] = useLocale$1("Modal", getConfirmLocale());
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Button$1, Object.assign({
          onClick: onCancel
        }, cancelButtonProps), cancelText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.cancelText)), /* @__PURE__ */ React.createElement(Button$1, Object.assign({}, convertLegacyProps(okType), {
          loading: confirmLoading,
          onClick: onOk
        }, okButtonProps), okText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.okText)));
      };
      const initMotionCommon = (duration) => ({
        animationDuration: duration,
        animationFillMode: "both"
      });
      const initMotionCommonLeave = (duration) => ({
        animationDuration: duration,
        animationFillMode: "both"
      });
      const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
        let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        const sameLevelPrefix = sameLevel ? "&" : "";
        return {
          [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
            animationPlayState: "paused"
          }),
          [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
            animationPlayState: "paused"
          }),
          [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
            animationName: inKeyframes,
            animationPlayState: "running"
          },
          [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
            animationName: outKeyframes,
            animationPlayState: "running",
            pointerEvents: "none"
          }
        };
      };
      const fadeIn = new Keyframe("antFadeIn", {
        "0%": {
          opacity: 0
        },
        "100%": {
          opacity: 1
        }
      });
      const fadeOut = new Keyframe("antFadeOut", {
        "0%": {
          opacity: 1
        },
        "100%": {
          opacity: 0
        }
      });
      const initFadeMotion = function(token2) {
        let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-fade`;
        const sameLevelPrefix = sameLevel ? "&" : "";
        return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
          [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
            opacity: 0,
            animationTimingFunction: "linear"
          },
          [`${sameLevelPrefix}${motionCls}-leave`]: {
            animationTimingFunction: "linear"
          }
        }];
      };
      const moveDownIn = new Keyframe("antMoveDownIn", {
        "0%": {
          transform: "translate3d(0, 100%, 0)",
          transformOrigin: "0 0",
          opacity: 0
        },
        "100%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        }
      });
      const moveDownOut = new Keyframe("antMoveDownOut", {
        "0%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        },
        "100%": {
          transform: "translate3d(0, 100%, 0)",
          transformOrigin: "0 0",
          opacity: 0
        }
      });
      const moveLeftIn = new Keyframe("antMoveLeftIn", {
        "0%": {
          transform: "translate3d(-100%, 0, 0)",
          transformOrigin: "0 0",
          opacity: 0
        },
        "100%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        }
      });
      const moveLeftOut = new Keyframe("antMoveLeftOut", {
        "0%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        },
        "100%": {
          transform: "translate3d(-100%, 0, 0)",
          transformOrigin: "0 0",
          opacity: 0
        }
      });
      const moveRightIn = new Keyframe("antMoveRightIn", {
        "0%": {
          transform: "translate3d(100%, 0, 0)",
          transformOrigin: "0 0",
          opacity: 0
        },
        "100%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        }
      });
      const moveRightOut = new Keyframe("antMoveRightOut", {
        "0%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        },
        "100%": {
          transform: "translate3d(100%, 0, 0)",
          transformOrigin: "0 0",
          opacity: 0
        }
      });
      const moveUpIn = new Keyframe("antMoveUpIn", {
        "0%": {
          transform: "translate3d(0, -100%, 0)",
          transformOrigin: "0 0",
          opacity: 0
        },
        "100%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        }
      });
      const moveUpOut = new Keyframe("antMoveUpOut", {
        "0%": {
          transform: "translate3d(0, 0, 0)",
          transformOrigin: "0 0",
          opacity: 1
        },
        "100%": {
          transform: "translate3d(0, -100%, 0)",
          transformOrigin: "0 0",
          opacity: 0
        }
      });
      const moveMotion = {
        "move-up": {
          inKeyframes: moveUpIn,
          outKeyframes: moveUpOut
        },
        "move-down": {
          inKeyframes: moveDownIn,
          outKeyframes: moveDownOut
        },
        "move-left": {
          inKeyframes: moveLeftIn,
          outKeyframes: moveLeftOut
        },
        "move-right": {
          inKeyframes: moveRightIn,
          outKeyframes: moveRightOut
        }
      };
      const initMoveMotion = (token2, motionName) => {
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-${motionName}`;
        const {
          inKeyframes,
          outKeyframes
        } = moveMotion[motionName];
        return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
          [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
            opacity: 0,
            animationTimingFunction: token2.motionEaseOutCirc
          },
          [`${motionCls}-leave`]: {
            animationTimingFunction: token2.motionEaseInOutCirc
          }
        }];
      };
      const slideUpIn = new Keyframe("antSlideUpIn", {
        "0%": {
          transform: "scaleY(0.8)",
          transformOrigin: "0% 0%",
          opacity: 0
        },
        "100%": {
          transform: "scaleY(1)",
          transformOrigin: "0% 0%",
          opacity: 1
        }
      });
      const slideUpOut = new Keyframe("antSlideUpOut", {
        "0%": {
          transform: "scaleY(1)",
          transformOrigin: "0% 0%",
          opacity: 1
        },
        "100%": {
          transform: "scaleY(0.8)",
          transformOrigin: "0% 0%",
          opacity: 0
        }
      });
      const slideDownIn = new Keyframe("antSlideDownIn", {
        "0%": {
          transform: "scaleY(0.8)",
          transformOrigin: "100% 100%",
          opacity: 0
        },
        "100%": {
          transform: "scaleY(1)",
          transformOrigin: "100% 100%",
          opacity: 1
        }
      });
      const slideDownOut = new Keyframe("antSlideDownOut", {
        "0%": {
          transform: "scaleY(1)",
          transformOrigin: "100% 100%",
          opacity: 1
        },
        "100%": {
          transform: "scaleY(0.8)",
          transformOrigin: "100% 100%",
          opacity: 0
        }
      });
      const slideLeftIn = new Keyframe("antSlideLeftIn", {
        "0%": {
          transform: "scaleX(0.8)",
          transformOrigin: "0% 0%",
          opacity: 0
        },
        "100%": {
          transform: "scaleX(1)",
          transformOrigin: "0% 0%",
          opacity: 1
        }
      });
      const slideLeftOut = new Keyframe("antSlideLeftOut", {
        "0%": {
          transform: "scaleX(1)",
          transformOrigin: "0% 0%",
          opacity: 1
        },
        "100%": {
          transform: "scaleX(0.8)",
          transformOrigin: "0% 0%",
          opacity: 0
        }
      });
      const slideRightIn = new Keyframe("antSlideRightIn", {
        "0%": {
          transform: "scaleX(0.8)",
          transformOrigin: "100% 0%",
          opacity: 0
        },
        "100%": {
          transform: "scaleX(1)",
          transformOrigin: "100% 0%",
          opacity: 1
        }
      });
      const slideRightOut = new Keyframe("antSlideRightOut", {
        "0%": {
          transform: "scaleX(1)",
          transformOrigin: "100% 0%",
          opacity: 1
        },
        "100%": {
          transform: "scaleX(0.8)",
          transformOrigin: "100% 0%",
          opacity: 0
        }
      });
      const slideMotion = {
        "slide-up": {
          inKeyframes: slideUpIn,
          outKeyframes: slideUpOut
        },
        "slide-down": {
          inKeyframes: slideDownIn,
          outKeyframes: slideDownOut
        },
        "slide-left": {
          inKeyframes: slideLeftIn,
          outKeyframes: slideLeftOut
        },
        "slide-right": {
          inKeyframes: slideRightIn,
          outKeyframes: slideRightOut
        }
      };
      const initSlideMotion = (token2, motionName) => {
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-${motionName}`;
        const {
          inKeyframes,
          outKeyframes
        } = slideMotion[motionName];
        return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
          [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
            transform: "scale(0)",
            transformOrigin: "0% 0%",
            opacity: 0,
            animationTimingFunction: token2.motionEaseOutQuint,
            [`&-prepare`]: {
              transform: "scale(1)"
            }
          },
          [`${motionCls}-leave`]: {
            animationTimingFunction: token2.motionEaseInQuint
          }
        }];
      };
      const zoomIn = new Keyframe("antZoomIn", {
        "0%": {
          transform: "scale(0.2)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          opacity: 1
        }
      });
      const zoomOut = new Keyframe("antZoomOut", {
        "0%": {
          transform: "scale(1)"
        },
        "100%": {
          transform: "scale(0.2)",
          opacity: 0
        }
      });
      const zoomBigIn = new Keyframe("antZoomBigIn", {
        "0%": {
          transform: "scale(0.8)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          opacity: 1
        }
      });
      const zoomBigOut = new Keyframe("antZoomBigOut", {
        "0%": {
          transform: "scale(1)"
        },
        "100%": {
          transform: "scale(0.8)",
          opacity: 0
        }
      });
      const zoomUpIn = new Keyframe("antZoomUpIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 0%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "50% 0%"
        }
      });
      const zoomUpOut = new Keyframe("antZoomUpOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "50% 0%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 0%",
          opacity: 0
        }
      });
      const zoomLeftIn = new Keyframe("antZoomLeftIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "0% 50%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "0% 50%"
        }
      });
      const zoomLeftOut = new Keyframe("antZoomLeftOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "0% 50%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "0% 50%",
          opacity: 0
        }
      });
      const zoomRightIn = new Keyframe("antZoomRightIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "100% 50%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "100% 50%"
        }
      });
      const zoomRightOut = new Keyframe("antZoomRightOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "100% 50%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "100% 50%",
          opacity: 0
        }
      });
      const zoomDownIn = new Keyframe("antZoomDownIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 100%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "50% 100%"
        }
      });
      const zoomDownOut = new Keyframe("antZoomDownOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "50% 100%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 100%",
          opacity: 0
        }
      });
      const zoomMotion = {
        zoom: {
          inKeyframes: zoomIn,
          outKeyframes: zoomOut
        },
        "zoom-big": {
          inKeyframes: zoomBigIn,
          outKeyframes: zoomBigOut
        },
        "zoom-big-fast": {
          inKeyframes: zoomBigIn,
          outKeyframes: zoomBigOut
        },
        "zoom-left": {
          inKeyframes: zoomLeftIn,
          outKeyframes: zoomLeftOut
        },
        "zoom-right": {
          inKeyframes: zoomRightIn,
          outKeyframes: zoomRightOut
        },
        "zoom-up": {
          inKeyframes: zoomUpIn,
          outKeyframes: zoomUpOut
        },
        "zoom-down": {
          inKeyframes: zoomDownIn,
          outKeyframes: zoomDownOut
        }
      };
      const initZoomMotion = (token2, motionName) => {
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-${motionName}`;
        const {
          inKeyframes,
          outKeyframes
        } = zoomMotion[motionName];
        return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
          [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
            transform: "scale(0)",
            opacity: 0,
            animationTimingFunction: token2.motionEaseOutCirc,
            "&-prepare": {
              transform: "none"
            }
          },
          [`${motionCls}-leave`]: {
            animationTimingFunction: token2.motionEaseInOutCirc
          }
        }];
      };
      const genCollapseMotion = (token2) => ({
        [token2.componentCls]: {
          // For common/openAnimation
          [`${token2.antCls}-motion-collapse-legacy`]: {
            overflow: "hidden",
            "&-active": {
              transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
            }
          },
          [`${token2.antCls}-motion-collapse`]: {
            overflow: "hidden",
            transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
          }
        }
      });
      const genCollapseMotion$1 = genCollapseMotion;
      function box(position2) {
        return {
          position: position2,
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0
        };
      }
      const genModalMaskStyle = (token2) => {
        const {
          componentCls,
          antCls
        } = token2;
        return [{
          [`${componentCls}-root`]: {
            [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
              // reset scale avoid mousePosition bug
              transform: "none",
              opacity: 0,
              animationDuration: token2.motionDurationSlow,
              // https://github.com/ant-design/ant-design/issues/11777
              userSelect: "none"
            },
            // https://github.com/ant-design/ant-design/issues/37329
            // https://github.com/ant-design/ant-design/issues/40272
            [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
              pointerEvents: "none"
            },
            [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
              zIndex: token2.zIndexPopupBase,
              height: "100%",
              backgroundColor: token2.colorBgMask,
              [`${componentCls}-hidden`]: {
                display: "none"
              }
            }),
            [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
              overflow: "auto",
              outline: 0,
              WebkitOverflowScrolling: "touch"
            })
          }
        }, {
          [`${componentCls}-root`]: initFadeMotion(token2)
        }];
      };
      const genModalStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return [
          // ======================== Root =========================
          {
            [`${componentCls}-root`]: {
              [`${componentCls}-wrap`]: {
                zIndex: token2.zIndexPopupBase,
                position: "fixed",
                inset: 0,
                overflow: "auto",
                outline: 0,
                WebkitOverflowScrolling: "touch"
              },
              [`${componentCls}-wrap-rtl`]: {
                direction: "rtl"
              },
              [`${componentCls}-centered`]: {
                textAlign: "center",
                "&::before": {
                  display: "inline-block",
                  width: 0,
                  height: "100%",
                  verticalAlign: "middle",
                  content: '""'
                },
                [componentCls]: {
                  top: 0,
                  display: "inline-block",
                  paddingBottom: 0,
                  textAlign: "start",
                  verticalAlign: "middle"
                }
              },
              [`@media (max-width: ${token2.screenSMMax})`]: {
                [componentCls]: {
                  maxWidth: "calc(100vw - 16px)",
                  margin: `${token2.marginXS} auto`
                },
                [`${componentCls}-centered`]: {
                  [componentCls]: {
                    flex: 1
                  }
                }
              }
            }
          },
          // ======================== Modal ========================
          {
            [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
              pointerEvents: "none",
              position: "relative",
              top: 100,
              width: "auto",
              maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
              margin: "0 auto",
              paddingBottom: token2.paddingLG,
              [`${componentCls}-title`]: {
                margin: 0,
                color: token2.titleColor,
                fontWeight: token2.fontWeightStrong,
                fontSize: token2.titleFontSize,
                lineHeight: token2.titleLineHeight,
                wordWrap: "break-word"
              },
              [`${componentCls}-content`]: {
                position: "relative",
                backgroundColor: token2.contentBg,
                backgroundClip: "padding-box",
                border: 0,
                borderRadius: token2.borderRadiusLG,
                boxShadow: token2.boxShadow,
                pointerEvents: "auto",
                padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
              },
              [`${componentCls}-close`]: Object.assign({
                position: "absolute",
                top: (token2.modalHeaderHeight - token2.modalCloseBtnSize) / 2,
                insetInlineEnd: (token2.modalHeaderHeight - token2.modalCloseBtnSize) / 2,
                zIndex: token2.zIndexPopupBase + 10,
                padding: 0,
                color: token2.modalCloseIconColor,
                fontWeight: token2.fontWeightStrong,
                lineHeight: 1,
                textDecoration: "none",
                background: "transparent",
                borderRadius: token2.borderRadiusSM,
                width: token2.modalCloseBtnSize,
                height: token2.modalCloseBtnSize,
                border: 0,
                outline: 0,
                cursor: "pointer",
                transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
                "&-x": {
                  display: "flex",
                  fontSize: token2.fontSizeLG,
                  fontStyle: "normal",
                  lineHeight: `${token2.modalCloseBtnSize}px`,
                  justifyContent: "center",
                  textTransform: "none",
                  textRendering: "auto"
                },
                "&:hover": {
                  color: token2.modalIconHoverColor,
                  backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
                  textDecoration: "none"
                },
                "&:active": {
                  backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
                }
              }, genFocusStyle(token2)),
              [`${componentCls}-header`]: {
                color: token2.colorText,
                background: token2.headerBg,
                borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
                marginBottom: token2.marginXS
              },
              [`${componentCls}-body`]: {
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight,
                wordWrap: "break-word"
              },
              [`${componentCls}-footer`]: {
                textAlign: "end",
                background: token2.footerBg,
                marginTop: token2.marginSM,
                [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
                  marginBottom: 0,
                  marginInlineStart: token2.marginXS
                }
              },
              [`${componentCls}-open`]: {
                overflow: "hidden"
              }
            })
          },
          // ======================== Pure =========================
          {
            [`${componentCls}-pure-panel`]: {
              top: "auto",
              padding: 0,
              display: "flex",
              flexDirection: "column",
              [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
                display: "flex",
                flexDirection: "column",
                flex: "auto"
              },
              [`${componentCls}-confirm-body`]: {
                marginBottom: "auto"
              }
            }
          }
        ];
      };
      const genModalConfirmStyle = (token2) => {
        const {
          componentCls
        } = token2;
        const confirmComponentCls = `${componentCls}-confirm`;
        return {
          [confirmComponentCls]: {
            "&-rtl": {
              direction: "rtl"
            },
            [`${token2.antCls}-modal-header`]: {
              display: "none"
            },
            [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
            [`${confirmComponentCls}-body`]: {
              display: "flex",
              flexWrap: "wrap",
              alignItems: "center",
              [`${confirmComponentCls}-title`]: {
                flex: "0 0 100%",
                display: "block",
                // create BFC to avoid
                // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
                overflow: "hidden",
                color: token2.colorTextHeading,
                fontWeight: token2.fontWeightStrong,
                fontSize: token2.titleFontSize,
                lineHeight: token2.titleLineHeight,
                [`+ ${confirmComponentCls}-content`]: {
                  marginBlockStart: token2.marginXS,
                  flexBasis: "100%",
                  maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
                }
              },
              [`${confirmComponentCls}-content`]: {
                color: token2.colorText,
                fontSize: token2.fontSize
              },
              [`> ${token2.iconCls}`]: {
                flex: "none",
                marginInlineEnd: token2.marginSM,
                fontSize: token2.modalConfirmIconSize,
                [`+ ${confirmComponentCls}-title`]: {
                  flex: 1
                },
                // `content` after `icon` should set marginLeft
                [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
                  marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
                }
              }
            },
            [`${confirmComponentCls}-btns`]: {
              textAlign: "end",
              marginTop: token2.marginSM,
              [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
                marginBottom: 0,
                marginInlineStart: token2.marginXS
              }
            }
          },
          [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
            color: token2.colorError
          },
          [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
            color: token2.colorWarning
          },
          [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
            color: token2.colorInfo
          },
          [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
            color: token2.colorSuccess
          }
        };
      };
      const genRTLStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          [`${componentCls}-root`]: {
            [`${componentCls}-wrap-rtl`]: {
              direction: "rtl",
              [`${componentCls}-confirm-body`]: {
                direction: "rtl"
              }
            }
          }
        };
      };
      const genWireframeStyle = (token2) => {
        const {
          componentCls,
          antCls
        } = token2;
        const confirmComponentCls = `${componentCls}-confirm`;
        return {
          [componentCls]: {
            [`${componentCls}-content`]: {
              padding: 0
            },
            [`${componentCls}-header`]: {
              padding: token2.modalHeaderPadding,
              borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
              marginBottom: 0
            },
            [`${componentCls}-body`]: {
              padding: token2.modalBodyPadding
            },
            [`${componentCls}-footer`]: {
              padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
              borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
              borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
              marginTop: 0
            }
          },
          [confirmComponentCls]: {
            [`${antCls}-modal-body`]: {
              padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
            },
            [`${confirmComponentCls}-body`]: {
              [`> ${token2.iconCls}`]: {
                marginInlineEnd: token2.margin,
                // `content` after `icon` should set marginLeft
                [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
                  marginInlineStart: token2.modalConfirmIconSize + token2.margin
                }
              }
            },
            [`${confirmComponentCls}-btns`]: {
              marginTop: token2.marginLG
            }
          }
        };
      };
      const useStyle$4 = genComponentStyleHook("Modal", (token2) => {
        const headerPaddingVertical = token2.padding;
        const headerFontSize = token2.fontSizeHeading5;
        const headerLineHeight = token2.lineHeightHeading5;
        const modalToken = merge(token2, {
          modalBodyPadding: token2.paddingLG,
          modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
          modalHeaderBorderWidth: token2.lineWidth,
          modalHeaderBorderStyle: token2.lineType,
          modalHeaderBorderColorSplit: token2.colorSplit,
          modalHeaderHeight: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
          modalFooterBorderColorSplit: token2.colorSplit,
          modalFooterBorderStyle: token2.lineType,
          modalFooterPaddingVertical: token2.paddingXS,
          modalFooterPaddingHorizontal: token2.padding,
          modalFooterBorderWidth: token2.lineWidth,
          modalIconHoverColor: token2.colorIconHover,
          modalCloseIconColor: token2.colorIcon,
          modalCloseBtnSize: token2.fontSize * token2.lineHeight,
          modalConfirmIconSize: token2.fontSize * token2.lineHeight
        });
        return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, "zoom")];
      }, (token2) => ({
        footerBg: "transparent",
        headerBg: token2.colorBgElevated,
        titleLineHeight: token2.lineHeightHeading5,
        titleFontSize: token2.fontSizeHeading5,
        contentBg: token2.colorBgElevated,
        titleColor: token2.colorTextHeading
      }));
      var __rest$f = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      let mousePosition;
      const getClickPosition = (e2) => {
        mousePosition = {
          x: e2.pageX,
          y: e2.pageY
        };
        setTimeout(() => {
          mousePosition = null;
        }, 100);
      };
      if (canUseDocElement()) {
        document.documentElement.addEventListener("click", getClickPosition, true);
      }
      const Modal$2 = (props) => {
        var _a;
        const {
          getPopupContainer: getContextPopupContainer,
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const handleCancel = (e2) => {
          const {
            onCancel
          } = props;
          onCancel === null || onCancel === void 0 ? void 0 : onCancel(e2);
        };
        const handleOk = (e2) => {
          const {
            onOk
          } = props;
          onOk === null || onOk === void 0 ? void 0 : onOk(e2);
        };
        const {
          prefixCls: customizePrefixCls,
          className,
          rootClassName,
          open,
          wrapClassName,
          centered,
          getContainer: getContainer2,
          closeIcon,
          focusTriggerAfterClose = true,
          // Deprecated
          visible,
          width = 520,
          footer
        } = props, restProps = __rest$f(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose", "visible", "width", "footer"]);
        const prefixCls = getPrefixCls("modal", customizePrefixCls);
        const rootPrefixCls = getPrefixCls();
        const [wrapSSR, hashId] = useStyle$4(prefixCls);
        const wrapClassNameExtended = classNames(wrapClassName, {
          [`${prefixCls}-centered`]: !!centered,
          [`${prefixCls}-wrap-rtl`]: direction === "rtl"
        });
        const dialogFooter = footer === void 0 ? /* @__PURE__ */ React__namespace.createElement(Footer, Object.assign({}, props, {
          onOk: handleOk,
          onCancel: handleCancel
        })) : footer;
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, /* @__PURE__ */ React__namespace.createElement(NoFormStyle, {
          status: true,
          override: true
        }, /* @__PURE__ */ React__namespace.createElement(DialogWrap, Object.assign({
          width
        }, restProps, {
          getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
          prefixCls,
          rootClassName: classNames(hashId, rootClassName),
          wrapClassName: wrapClassNameExtended,
          footer: dialogFooter,
          visible: open !== null && open !== void 0 ? open : visible,
          mousePosition: (_a = restProps.mousePosition) !== null && _a !== void 0 ? _a : mousePosition,
          onClose: handleCancel,
          closeIcon: renderCloseIcon(prefixCls, closeIcon),
          focusTriggerAfterClose,
          transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
          maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
          className: classNames(hashId, className)
        })))));
      };
      const OriginModal = Modal$2;
      function ConfirmContent(props) {
        const {
          icon,
          onCancel,
          onOk,
          close,
          okText,
          okButtonProps,
          cancelText,
          cancelButtonProps,
          confirmPrefixCls,
          rootPrefixCls,
          type: type2,
          okCancel,
          footer,
          // Legacy for static function usage
          locale: staticLocale
        } = props;
        let mergedIcon = icon;
        if (!icon && icon !== null) {
          switch (type2) {
            case "info":
              mergedIcon = /* @__PURE__ */ React__namespace.createElement(InfoCircleFilled$1, null);
              break;
            case "success":
              mergedIcon = /* @__PURE__ */ React__namespace.createElement(CheckCircleFilled$1, null);
              break;
            case "error":
              mergedIcon = /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null);
              break;
            default:
              mergedIcon = /* @__PURE__ */ React__namespace.createElement(ExclamationCircleFilled$1, null);
          }
        }
        const okType = props.okType || "primary";
        const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type2 === "confirm";
        const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
        const [locale2] = useLocale$1("Modal");
        const mergedLocale = staticLocale || locale2;
        const cancelButton = mergedOkCancel && /* @__PURE__ */ React__namespace.createElement(ActionButton$1, {
          actionFn: onCancel,
          close,
          autoFocus: autoFocusButton === "cancel",
          buttonProps: cancelButtonProps,
          prefixCls: `${rootPrefixCls}-btn`
        }, cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText));
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${confirmPrefixCls}-body-wrapper`
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${confirmPrefixCls}-body`
        }, mergedIcon, props.title === void 0 ? null : /* @__PURE__ */ React__namespace.createElement("span", {
          className: `${confirmPrefixCls}-title`
        }, props.title), /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${confirmPrefixCls}-content`
        }, props.content)), footer === void 0 ? /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${confirmPrefixCls}-btns`
        }, cancelButton, /* @__PURE__ */ React__namespace.createElement(ActionButton$1, {
          type: okType,
          actionFn: onOk,
          close,
          autoFocus: autoFocusButton === "ok",
          buttonProps: okButtonProps,
          prefixCls: `${rootPrefixCls}-btn`
        }, okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText))) : footer);
      }
      const ConfirmDialog = (props) => {
        const {
          close,
          zIndex,
          afterClose,
          visible,
          open,
          keyboard: keyboard2,
          centered,
          getContainer: getContainer2,
          maskStyle,
          direction,
          prefixCls,
          wrapClassName,
          rootPrefixCls,
          iconPrefixCls,
          theme: theme2,
          bodyStyle,
          closable = false,
          closeIcon,
          modalRender,
          focusTriggerAfterClose
        } = props;
        const confirmPrefixCls = `${prefixCls}-confirm`;
        const width = props.width || 416;
        const style2 = props.style || {};
        const mask = props.mask === void 0 ? true : props.mask;
        const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
        const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
          [`${confirmPrefixCls}-rtl`]: direction === "rtl"
        }, props.className);
        return /* @__PURE__ */ React__namespace.createElement(ConfigProvider$1, {
          prefixCls: rootPrefixCls,
          iconPrefixCls,
          direction,
          theme: theme2
        }, /* @__PURE__ */ React__namespace.createElement(OriginModal, {
          prefixCls,
          className: classString,
          wrapClassName: classNames({
            [`${confirmPrefixCls}-centered`]: !!props.centered
          }, wrapClassName),
          onCancel: () => close === null || close === void 0 ? void 0 : close({
            triggerCancel: true
          }),
          open,
          title: "",
          footer: null,
          transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
          maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
          mask,
          maskClosable,
          maskStyle,
          style: style2,
          bodyStyle,
          width,
          zIndex,
          afterClose,
          keyboard: keyboard2,
          centered,
          getContainer: getContainer2,
          closable,
          closeIcon,
          modalRender,
          focusTriggerAfterClose
        }, /* @__PURE__ */ React__namespace.createElement(ConfirmContent, Object.assign({}, props, {
          confirmPrefixCls
        }))));
      };
      const ConfirmDialog$1 = ConfirmDialog;
      const destroyFns = [];
      const destroyFns$1 = destroyFns;
      var __rest$e = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      let defaultRootPrefixCls = "";
      function getRootPrefixCls() {
        return defaultRootPrefixCls;
      }
      function confirm(config2) {
        const container = document.createDocumentFragment();
        let currentConfig = Object.assign(Object.assign({}, config2), {
          close,
          open: true
        });
        let timeoutId;
        function destroy() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const triggerCancel = args.some((param) => param && param.triggerCancel);
          if (config2.onCancel && triggerCancel) {
            config2.onCancel.apply(config2, [() => {
            }].concat(_toConsumableArray(args.slice(1))));
          }
          for (let i2 = 0; i2 < destroyFns$1.length; i2++) {
            const fn = destroyFns$1[i2];
            if (fn === close) {
              destroyFns$1.splice(i2, 1);
              break;
            }
          }
          unmount(container);
        }
        function render$1(_a) {
          var {
            okText,
            cancelText,
            prefixCls: customizePrefixCls,
            getContainer: getContainer2
          } = _a, props = __rest$e(_a, ["okText", "cancelText", "prefixCls", "getContainer"]);
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            const runtimeLocale2 = getConfirmLocale();
            const {
              getPrefixCls,
              getIconPrefixCls,
              getTheme
            } = globalConfig();
            const rootPrefixCls = getPrefixCls(void 0, getRootPrefixCls());
            const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
            const iconPrefixCls = getIconPrefixCls();
            const theme2 = getTheme();
            let mergedGetContainer = getContainer2;
            if (mergedGetContainer === false) {
              mergedGetContainer = void 0;
            }
            render(/* @__PURE__ */ React__namespace.createElement(ConfirmDialog$1, Object.assign({}, props, {
              getContainer: mergedGetContainer,
              prefixCls,
              rootPrefixCls,
              iconPrefixCls,
              okText,
              locale: runtimeLocale2,
              theme: theme2,
              cancelText: cancelText || runtimeLocale2.cancelText
            })), container);
          });
        }
        function close() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          currentConfig = Object.assign(Object.assign({}, currentConfig), {
            open: false,
            afterClose: () => {
              if (typeof config2.afterClose === "function") {
                config2.afterClose();
              }
              destroy.apply(this, args);
            }
          });
          if (currentConfig.visible) {
            delete currentConfig.visible;
          }
          render$1(currentConfig);
        }
        function update(configUpdate) {
          if (typeof configUpdate === "function") {
            currentConfig = configUpdate(currentConfig);
          } else {
            currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
          }
          render$1(currentConfig);
        }
        render$1(currentConfig);
        destroyFns$1.push(close);
        return {
          destroy: close,
          update
        };
      }
      function withWarn(props) {
        return Object.assign(Object.assign({}, props), {
          type: "warning"
        });
      }
      function withInfo(props) {
        return Object.assign(Object.assign({}, props), {
          type: "info"
        });
      }
      function withSuccess(props) {
        return Object.assign(Object.assign({}, props), {
          type: "success"
        });
      }
      function withError(props) {
        return Object.assign(Object.assign({}, props), {
          type: "error"
        });
      }
      function withConfirm(props) {
        return Object.assign(Object.assign({}, props), {
          type: "confirm"
        });
      }
      function modalGlobalConfig(_ref) {
        let {
          rootPrefixCls
        } = _ref;
        defaultRootPrefixCls = rootPrefixCls;
      }
      const HookModal = (_ref, ref) => {
        let {
          afterClose: hookAfterClose,
          config: config2
        } = _ref;
        var _a;
        const [open, setOpen] = React__namespace.useState(true);
        const [innerConfig, setInnerConfig] = React__namespace.useState(config2);
        const {
          direction,
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const prefixCls = getPrefixCls("modal");
        const rootPrefixCls = getPrefixCls();
        const afterClose = () => {
          var _a2;
          hookAfterClose();
          (_a2 = innerConfig.afterClose) === null || _a2 === void 0 ? void 0 : _a2.call(innerConfig);
        };
        const close = function() {
          setOpen(false);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const triggerCancel = args.some((param) => param && param.triggerCancel);
          if (innerConfig.onCancel && triggerCancel) {
            innerConfig.onCancel.apply(innerConfig, [() => {
            }].concat(_toConsumableArray(args.slice(1))));
          }
        };
        React__namespace.useImperativeHandle(ref, () => ({
          destroy: close,
          update: (newConfig) => {
            setInnerConfig((originConfig) => Object.assign(Object.assign({}, originConfig), newConfig));
          }
        }));
        const mergedOkCancel = (_a = innerConfig.okCancel) !== null && _a !== void 0 ? _a : innerConfig.type === "confirm";
        const [contextLocale] = useLocale$1("Modal", defaultLocale.Modal);
        return /* @__PURE__ */ React__namespace.createElement(ConfirmDialog$1, Object.assign({
          prefixCls,
          rootPrefixCls
        }, innerConfig, {
          close,
          open,
          afterClose,
          okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
          direction: innerConfig.direction || direction,
          cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
        }));
      };
      const HookModal$1 = /* @__PURE__ */ React__namespace.forwardRef(HookModal);
      let uuid = 0;
      const ElementsHolder = /* @__PURE__ */ React__namespace.memo(/* @__PURE__ */ React__namespace.forwardRef((_props, ref) => {
        const [elements, patchElement] = usePatchElement();
        React__namespace.useImperativeHandle(ref, () => ({
          patchElement
        }), []);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, elements);
      }));
      function useModal() {
        const holderRef = React__namespace.useRef(null);
        const [actionQueue, setActionQueue] = React__namespace.useState([]);
        React__namespace.useEffect(() => {
          if (actionQueue.length) {
            const cloneQueue = _toConsumableArray(actionQueue);
            cloneQueue.forEach((action) => {
              action();
            });
            setActionQueue([]);
          }
        }, [actionQueue]);
        const getConfirmFunc = React__namespace.useCallback((withFunc) => function hookConfirm(config2) {
          var _a;
          uuid += 1;
          const modalRef = /* @__PURE__ */ React__namespace.createRef();
          let closeFunc;
          const modal = /* @__PURE__ */ React__namespace.createElement(HookModal$1, {
            key: `modal-${uuid}`,
            config: withFunc(config2),
            ref: modalRef,
            afterClose: () => {
              closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
            }
          });
          closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
          if (closeFunc) {
            destroyFns$1.push(closeFunc);
          }
          return {
            destroy: () => {
              function destroyAction() {
                var _a2;
                (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
              }
              if (modalRef.current) {
                destroyAction();
              } else {
                setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
              }
            },
            update: (newConfig) => {
              function updateAction() {
                var _a2;
                (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.update(newConfig);
              }
              if (modalRef.current) {
                updateAction();
              } else {
                setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
              }
            }
          };
        }, []);
        const fns = React__namespace.useMemo(() => ({
          info: getConfirmFunc(withInfo),
          success: getConfirmFunc(withSuccess),
          error: getConfirmFunc(withError),
          warning: getConfirmFunc(withWarn),
          confirm: getConfirmFunc(withConfirm)
        }), []);
        return [fns, /* @__PURE__ */ React__namespace.createElement(ElementsHolder, {
          key: "modal-holder",
          ref: holderRef
        })];
      }
      function genPurePanel(Component, defaultPrefixCls2, getDropdownCls, postProps) {
        return function PurePanel2(props) {
          const {
            prefixCls: customizePrefixCls,
            style: style2
          } = props;
          const holderRef = React__namespace.useRef(null);
          const [popupHeight, setPopupHeight] = React__namespace.useState(0);
          const [popupWidth, setPopupWidth] = React__namespace.useState(0);
          const [open, setOpen] = useMergedState(false, {
            value: props.open
          });
          const {
            getPrefixCls
          } = React__namespace.useContext(ConfigContext);
          const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
          React__namespace.useEffect(() => {
            setOpen(true);
            if (typeof ResizeObserver !== "undefined") {
              const resizeObserver2 = new ResizeObserver((entries) => {
                const element = entries[0].target;
                setPopupHeight(element.offsetHeight + 8);
                setPopupWidth(element.offsetWidth);
              });
              const interval = setInterval(() => {
                var _a;
                const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
                const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
                if (popup) {
                  clearInterval(interval);
                  resizeObserver2.observe(popup);
                }
              }, 10);
              return () => {
                clearInterval(interval);
                resizeObserver2.disconnect();
              };
            }
          }, []);
          let mergedProps = Object.assign(Object.assign({}, props), {
            style: Object.assign(Object.assign({}, style2), {
              margin: 0
            }),
            open,
            visible: open,
            getPopupContainer: () => holderRef.current
          });
          if (postProps) {
            mergedProps = postProps(mergedProps);
          }
          return /* @__PURE__ */ React__namespace.createElement(ConfigProvider$1, {
            theme: {
              token: {
                motion: false
              }
            }
          }, /* @__PURE__ */ React__namespace.createElement("div", {
            ref: holderRef,
            style: {
              paddingBottom: popupHeight,
              position: "relative",
              minWidth: popupWidth
            }
          }, /* @__PURE__ */ React__namespace.createElement(Component, Object.assign({}, mergedProps))));
        };
      }
      const isMobile = function() {
        if (typeof navigator === "undefined" || typeof window === "undefined") {
          return false;
        }
        var agent = navigator.userAgent || navigator.vendor || window.opera;
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
      };
      var TriggerContext = /* @__PURE__ */ React__namespace.createContext(null);
      function toArray$3(val) {
        return val ? Array.isArray(val) ? val : [val] : [];
      }
      function useAction(mobile, action, showAction, hideAction) {
        return React__namespace.useMemo(function() {
          var mergedShowAction = toArray$3(showAction !== null && showAction !== void 0 ? showAction : action);
          var mergedHideAction = toArray$3(hideAction !== null && hideAction !== void 0 ? hideAction : action);
          var showActionSet = new Set(mergedShowAction);
          var hideActionSet = new Set(mergedHideAction);
          if (mobile) {
            if (showActionSet.has("hover")) {
              showActionSet.delete("hover");
              showActionSet.add("click");
            }
            if (hideActionSet.has("hover")) {
              hideActionSet.delete("hover");
              hideActionSet.add("click");
            }
          }
          return [showActionSet, hideActionSet];
        }, [mobile, action, showAction, hideAction]);
      }
      function isPointsEq() {
        var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
        if (isAlignPoint) {
          return a1[0] === a2[0];
        }
        return a1[0] === a2[0] && a1[1] === a2[1];
      }
      function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
        var points = align.points;
        var placements2 = Object.keys(builtinPlacements);
        for (var i2 = 0; i2 < placements2.length; i2 += 1) {
          var _builtinPlacements$pl;
          var placement = placements2[i2];
          if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
            return "".concat(prefixCls, "-placement-").concat(placement);
          }
        }
        return "";
      }
      function getMotion(prefixCls, motion, animation, transitionName) {
        if (motion) {
          return motion;
        }
        if (animation) {
          return {
            motionName: "".concat(prefixCls, "-").concat(animation)
          };
        }
        if (transitionName) {
          return {
            motionName: transitionName
          };
        }
        return null;
      }
      function getWin(ele) {
        return ele.ownerDocument.defaultView;
      }
      function collectScroller(ele) {
        var scrollerList = [];
        var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
        var scrollStyle = ["hidden", "scroll", "clip", "auto"];
        while (current) {
          var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
          if ([overflowX, overflowY, overflow].some(function(o2) {
            return scrollStyle.includes(o2);
          })) {
            scrollerList.push(current);
          }
          current = current.parentElement;
        }
        return scrollerList;
      }
      function toNum(num) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return Number.isNaN(num) ? defaultValue : num;
      }
      function getPxValue(val) {
        return toNum(parseFloat(val), 0);
      }
      function getVisibleArea(initArea, scrollerList) {
        var visibleArea = _objectSpread2({}, initArea);
        (scrollerList || []).forEach(function(ele) {
          if (ele instanceof HTMLBodyElement) {
            return;
          }
          var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
          var eleRect = ele.getBoundingClientRect();
          var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
          var borderTopNum = getPxValue(borderTopWidth);
          var borderBottomNum = getPxValue(borderBottomWidth);
          var borderLeftNum = getPxValue(borderLeftWidth);
          var borderRightNum = getPxValue(borderRightWidth);
          var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
          var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
          var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
          var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
          var scaledBorderTopWidth = borderTopNum * scaleY;
          var scaledBorderBottomWidth = borderBottomNum * scaleY;
          var scaledBorderLeftWidth = borderLeftNum * scaleX;
          var scaledBorderRightWidth = borderRightNum * scaleX;
          var clipMarginWidth = 0;
          var clipMarginHeight = 0;
          if (overflow === "clip") {
            var clipNum = getPxValue(overflowClipMargin);
            clipMarginWidth = clipNum * scaleX;
            clipMarginHeight = clipNum * scaleY;
          }
          var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
          var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
          var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
          var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
          visibleArea.left = Math.max(visibleArea.left, eleLeft);
          visibleArea.top = Math.max(visibleArea.top, eleTop);
          visibleArea.right = Math.min(visibleArea.right, eleRight);
          visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
        });
        return visibleArea;
      }
      function getUnitOffset(size) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var offsetStr = "".concat(offset2);
        var cells = offsetStr.match(/^(.*)\%$/);
        if (cells) {
          return size * (parseFloat(cells[1]) / 100);
        }
        return parseFloat(offsetStr);
      }
      function getNumberOffset(rect, offset2) {
        var _ref = offset2 || [], _ref2 = _slicedToArray$5(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
        return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
      }
      function splitPoints() {
        var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return [points[0], points[1]];
      }
      function getAlignPoint(rect, points) {
        var topBottom = points[0];
        var leftRight = points[1];
        var x2;
        var y2;
        if (topBottom === "t") {
          y2 = rect.y;
        } else if (topBottom === "b") {
          y2 = rect.y + rect.height;
        } else {
          y2 = rect.y + rect.height / 2;
        }
        if (leftRight === "l") {
          x2 = rect.x;
        } else if (leftRight === "r") {
          x2 = rect.x + rect.width;
        } else {
          x2 = rect.x + rect.width / 2;
        }
        return {
          x: x2,
          y: y2
        };
      }
      function reversePoints(points, index2) {
        var reverseMap = {
          t: "b",
          b: "t",
          l: "r",
          r: "l"
        };
        return points.map(function(point, i2) {
          if (i2 === index2) {
            return reverseMap[point] || "c";
          }
          return point;
        }).join("");
      }
      function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
        var _React$useState = React__namespace.useState({
          ready: false,
          offsetX: 0,
          offsetY: 0,
          offsetR: 0,
          offsetB: 0,
          arrowX: 0,
          arrowY: 0,
          scaleX: 1,
          scaleY: 1,
          align: builtinPlacements[placement] || {}
        }), _React$useState2 = _slicedToArray$5(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
        var alignCountRef = React__namespace.useRef(0);
        var scrollerList = React__namespace.useMemo(function() {
          if (!popupEle) {
            return [];
          }
          return collectScroller(popupEle);
        }, [popupEle]);
        var prevFlipRef = React__namespace.useRef({});
        var resetFlipCache = function resetFlipCache2() {
          prevFlipRef.current = {};
        };
        if (!open) {
          resetFlipCache();
        }
        var onAlign = useEvent(function() {
          if (popupEle && target && open) {
            let getIntersectionVisibleArea = function(offsetX, offsetY) {
              var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
              var l2 = popupRect.x + offsetX;
              var t2 = popupRect.y + offsetY;
              var r2 = l2 + popupWidth;
              var b2 = t2 + popupHeight;
              var visibleL = Math.max(l2, area.left);
              var visibleT = Math.max(t2, area.top);
              var visibleR = Math.min(r2, area.right);
              var visibleB = Math.min(b2, area.bottom);
              return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
            }, syncNextPopupPosition = function() {
              nextPopupY = popupRect.y + nextOffsetY;
              nextPopupBottom = nextPopupY + popupHeight;
              nextPopupX = popupRect.x + nextOffsetX;
              nextPopupRight = nextPopupX + popupWidth;
            };
            var popupElement = popupEle;
            var originLeft = popupElement.style.left;
            var originTop = popupElement.style.top;
            var originRight = popupElement.style.right;
            var originBottom = popupElement.style.bottom;
            var doc = popupElement.ownerDocument;
            var win = getWin(popupElement);
            var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
            popupElement.style.left = "0";
            popupElement.style.top = "0";
            popupElement.style.right = "auto";
            popupElement.style.bottom = "auto";
            var targetRect;
            if (Array.isArray(target)) {
              targetRect = {
                x: target[0],
                y: target[1],
                width: 0,
                height: 0
              };
            } else {
              var rect = target.getBoundingClientRect();
              targetRect = {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height
              };
            }
            var popupRect = popupElement.getBoundingClientRect();
            var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height;
            var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
            var popupHeight = popupRect.height;
            var popupWidth = popupRect.width;
            var targetHeight = targetRect.height;
            var targetWidth = targetRect.width;
            var visibleRegion = {
              left: 0,
              top: 0,
              right: clientWidth,
              bottom: clientHeight
            };
            var scrollRegion = {
              left: -scrollLeft,
              top: -scrollTop,
              right: scrollWidth - scrollLeft,
              bottom: scrollHeight - scrollTop
            };
            var htmlRegion = placementInfo.htmlRegion;
            var VISIBLE = "visible";
            var VISIBLE_FIRST = "visibleFirst";
            if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
              htmlRegion = VISIBLE;
            }
            var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
            var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
            var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
            var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
            var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
            popupElement.style.left = "auto";
            popupElement.style.top = "auto";
            popupElement.style.right = "0";
            popupElement.style.bottom = "0";
            var popupMirrorRect = popupElement.getBoundingClientRect();
            popupElement.style.left = originLeft;
            popupElement.style.top = originTop;
            popupElement.style.right = originRight;
            popupElement.style.bottom = originBottom;
            var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
            var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
            if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible$1(target)) {
              return;
            }
            var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
            var _getNumberOffset = getNumberOffset(popupRect, offset2), _getNumberOffset2 = _slicedToArray$5(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
            var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray$5(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
            targetRect.x -= targetOffsetX;
            targetRect.y -= targetOffsetY;
            var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray$5(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
            var targetPoints = splitPoints(targetPoint);
            var popupPoints = splitPoints(popupPoint);
            var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
            var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
            var nextAlignInfo = _objectSpread2({}, placementInfo);
            var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
            var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
            var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
            var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
            var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
            var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
            var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
            var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
            var overflow = placementInfo.overflow || {};
            var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
            var supportAdjust = function supportAdjust2(val) {
              if (typeof val === "boolean") {
                return val;
              }
              return val >= 0;
            };
            var nextPopupY;
            var nextPopupBottom;
            var nextPopupX;
            var nextPopupRight;
            syncNextPopupPosition();
            var needAdjustY = supportAdjust(adjustY);
            var sameTB = popupPoints[0] === targetPoints[0];
            if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
              var tmpNextOffsetY = nextOffsetY;
              if (sameTB) {
                tmpNextOffsetY -= popupHeight - targetHeight;
              } else {
                tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
              }
              var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
              var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
              if (
                // Of course use larger one
                newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                newVisibleRecommendArea >= originIntersectionRecommendArea)
              ) {
                prevFlipRef.current.bt = true;
                nextOffsetY = tmpNextOffsetY;
                nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
              } else {
                prevFlipRef.current.bt = false;
              }
            }
            if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
              var _tmpNextOffsetY = nextOffsetY;
              if (sameTB) {
                _tmpNextOffsetY += popupHeight - targetHeight;
              } else {
                _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
              }
              var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
              var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
              if (
                // Of course use larger one
                _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                _newVisibleRecommendArea >= originIntersectionRecommendArea)
              ) {
                prevFlipRef.current.tb = true;
                nextOffsetY = _tmpNextOffsetY;
                nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
              } else {
                prevFlipRef.current.tb = false;
              }
            }
            var needAdjustX = supportAdjust(adjustX);
            var sameLR = popupPoints[1] === targetPoints[1];
            if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
              var tmpNextOffsetX = nextOffsetX;
              if (sameLR) {
                tmpNextOffsetX -= popupWidth - targetWidth;
              } else {
                tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
              }
              var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
              var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
              if (
                // Of course use larger one
                _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
              ) {
                prevFlipRef.current.rl = true;
                nextOffsetX = tmpNextOffsetX;
                nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
              } else {
                prevFlipRef.current.rl = false;
              }
            }
            if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
              var _tmpNextOffsetX = nextOffsetX;
              if (sameLR) {
                _tmpNextOffsetX += popupWidth - targetWidth;
              } else {
                _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
              }
              var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
              var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
              if (
                // Of course use larger one
                _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
              ) {
                prevFlipRef.current.lr = true;
                nextOffsetX = _tmpNextOffsetX;
                nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
              } else {
                prevFlipRef.current.lr = false;
              }
            }
            syncNextPopupPosition();
            var numShiftX = shiftX === true ? 0 : shiftX;
            if (typeof numShiftX === "number") {
              if (nextPopupX < visibleRegionArea.left) {
                nextOffsetX -= nextPopupX - visibleRegionArea.left;
                if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
                  nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
                }
              }
              if (nextPopupRight > visibleRegionArea.right) {
                nextOffsetX -= nextPopupRight - visibleRegionArea.right;
                if (targetRect.x > visibleRegionArea.right - numShiftX) {
                  nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
                }
              }
            }
            var numShiftY = shiftY === true ? 0 : shiftY;
            if (typeof numShiftY === "number") {
              if (nextPopupY < visibleRegionArea.top) {
                nextOffsetY -= nextPopupY - visibleRegionArea.top;
                if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
                  nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
                }
              }
              if (nextPopupBottom > visibleRegionArea.bottom) {
                nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom;
                if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
                  nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
                }
              }
            }
            var popupLeft = popupRect.x + nextOffsetX;
            var popupRight = popupLeft + popupWidth;
            var popupTop = popupRect.y + nextOffsetY;
            var popupBottom = popupTop + popupHeight;
            var targetLeft = targetRect.x;
            var targetRight = targetLeft + targetWidth;
            var targetTop = targetRect.y;
            var targetBottom = targetTop + targetHeight;
            var maxLeft = Math.max(popupLeft, targetLeft);
            var minRight = Math.min(popupRight, targetRight);
            var xCenter = (maxLeft + minRight) / 2;
            var nextArrowX = xCenter - popupLeft;
            var maxTop = Math.max(popupTop, targetTop);
            var minBottom = Math.min(popupBottom, targetBottom);
            var yCenter = (maxTop + minBottom) / 2;
            var nextArrowY = yCenter - popupTop;
            onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
            var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
            var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
            setOffsetInfo({
              ready: true,
              offsetX: nextOffsetX / _scaleX,
              offsetY: nextOffsetY / _scaleY,
              offsetR: offsetX4Right / _scaleX,
              offsetB: offsetY4Bottom / _scaleY,
              arrowX: nextArrowX / _scaleX,
              arrowY: nextArrowY / _scaleY,
              scaleX: _scaleX,
              scaleY: _scaleY,
              align: nextAlignInfo
            });
          }
        });
        var triggerAlign = function triggerAlign2() {
          alignCountRef.current += 1;
          var id = alignCountRef.current;
          Promise.resolve().then(function() {
            if (alignCountRef.current === id) {
              onAlign();
            }
          });
        };
        var resetReady = function resetReady2() {
          setOffsetInfo(function(ori) {
            return _objectSpread2(_objectSpread2({}, ori), {}, {
              ready: false
            });
          });
        };
        useLayoutEffect(resetReady, [placement]);
        useLayoutEffect(function() {
          if (!open) {
            resetReady();
          }
        }, [open]);
        return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
      }
      function useWatch(open, target, popup, onAlign) {
        useLayoutEffect(function() {
          if (open && target && popup) {
            let notifyScroll = function() {
              onAlign();
            };
            var targetElement = target;
            var popupElement = popup;
            var targetScrollList = collectScroller(targetElement);
            var popupScrollList = collectScroller(popupElement);
            var win = getWin(popupElement);
            var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
            mergedList.forEach(function(scroller) {
              scroller.addEventListener("scroll", notifyScroll, {
                passive: true
              });
            });
            win.addEventListener("resize", notifyScroll, {
              passive: true
            });
            onAlign();
            return function() {
              mergedList.forEach(function(scroller) {
                scroller.removeEventListener("scroll", notifyScroll);
                win.removeEventListener("resize", notifyScroll);
              });
            };
          }
        }, [open, target, popup]);
      }
      function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
        var openRef = React__namespace.useRef(open);
        var lockRef = React__namespace.useRef(false);
        if (openRef.current !== open) {
          lockRef.current = true;
          openRef.current = open;
        }
        React__namespace.useEffect(function() {
          var id = wrapperRaf(function() {
            lockRef.current = false;
          });
          return function() {
            wrapperRaf.cancel(id);
          };
        }, [open]);
        React__namespace.useEffect(function() {
          if (clickToHide && popupEle && (!mask || maskClosable)) {
            var genClickEvents = function genClickEvents2() {
              var clickInside = false;
              var onWindowMouseDown = function onWindowMouseDown2(_ref) {
                var target = _ref.target;
                clickInside = inPopupOrChild(target);
              };
              var onWindowClick = function onWindowClick2(_ref2) {
                var target = _ref2.target;
                if (!lockRef.current && openRef.current && !clickInside && !inPopupOrChild(target)) {
                  triggerOpen(false);
                }
              };
              return [onWindowMouseDown, onWindowClick];
            };
            var _genClickEvents = genClickEvents(), _genClickEvents2 = _slicedToArray$5(_genClickEvents, 2), onWinMouseDown = _genClickEvents2[0], onWinClick = _genClickEvents2[1];
            var _genClickEvents3 = genClickEvents(), _genClickEvents4 = _slicedToArray$5(_genClickEvents3, 2), onShadowMouseDown = _genClickEvents4[0], onShadowClick = _genClickEvents4[1];
            var win = getWin(popupEle);
            win.addEventListener("mousedown", onWinMouseDown);
            win.addEventListener("click", onWinClick);
            win.addEventListener("contextmenu", onWinClick);
            var targetShadowRoot = getShadowRoot(targetEle);
            if (targetShadowRoot) {
              targetShadowRoot.addEventListener("mousedown", onShadowMouseDown);
              targetShadowRoot.addEventListener("click", onShadowClick);
              targetShadowRoot.addEventListener("contextmenu", onShadowClick);
            }
            return function() {
              win.removeEventListener("mousedown", onWinMouseDown);
              win.removeEventListener("click", onWinClick);
              win.removeEventListener("contextmenu", onWinClick);
              if (targetShadowRoot) {
                targetShadowRoot.removeEventListener("mousedown", onShadowMouseDown);
                targetShadowRoot.removeEventListener("click", onShadowClick);
                targetShadowRoot.removeEventListener("contextmenu", onShadowClick);
              }
            };
          }
        }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
      }
      function Arrow(props) {
        var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
        var _ref = arrow || {}, className = _ref.className, content = _ref.content;
        var _arrowPos$x = arrowPos.x, x2 = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y2 = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
        var arrowRef = React__namespace.useRef();
        if (!align || !align.points) {
          return null;
        }
        var alignStyle = {
          position: "absolute"
        };
        if (align.autoArrow !== false) {
          var popupPoints = align.points[0];
          var targetPoints = align.points[1];
          var popupTB = popupPoints[0];
          var popupLR = popupPoints[1];
          var targetTB = targetPoints[0];
          var targetLR = targetPoints[1];
          if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
            alignStyle.top = y2;
          } else if (popupTB === "t") {
            alignStyle.top = 0;
          } else {
            alignStyle.bottom = 0;
          }
          if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
            alignStyle.left = x2;
          } else if (popupLR === "l") {
            alignStyle.left = 0;
          } else {
            alignStyle.right = 0;
          }
        }
        return /* @__PURE__ */ React__namespace.createElement("div", {
          ref: arrowRef,
          className: classNames("".concat(prefixCls, "-arrow"), className),
          style: alignStyle
        }, content);
      }
      function Mask(props) {
        var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion = props.motion;
        if (!mask) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$1({}, motion, {
          motionAppear: true,
          visible: open,
          removeOnLeave: true
        }), function(_ref) {
          var className = _ref.className;
          return /* @__PURE__ */ React__namespace.createElement("div", {
            style: {
              zIndex
            },
            className: classNames("".concat(prefixCls, "-mask"), className)
          });
        });
      }
      var PopupContent = /* @__PURE__ */ React__namespace.memo(function(_ref) {
        var children = _ref.children;
        return children;
      }, function(_, next2) {
        return next2.cache;
      });
      var Popup$1 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
        var childNode = typeof popup === "function" ? popup() : popup;
        var isNodeVisible = open || keepDom;
        var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
        var _React$useState = React__namespace.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray$5(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
        useLayoutEffect(function() {
          if (!show && getPopupContainerNeedParams && target) {
            setShow(true);
          }
        }, [show, getPopupContainerNeedParams, target]);
        if (!show) {
          return null;
        }
        var AUTO = "auto";
        var offsetStyle = {
          left: "-1000vw",
          top: "-1000vh",
          right: AUTO,
          bottom: AUTO
        };
        if (ready || !open) {
          var points = align.points, _experimental = align._experimental;
          var dynamicInset = _experimental === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset;
          var alignRight = dynamicInset && points[0][1] === "r";
          var alignBottom = dynamicInset && points[0][0] === "b";
          if (alignRight) {
            offsetStyle.right = offsetR;
            offsetStyle.left = AUTO;
          } else {
            offsetStyle.left = offsetX;
            offsetStyle.right = AUTO;
          }
          if (alignBottom) {
            offsetStyle.bottom = offsetB;
            offsetStyle.top = AUTO;
          } else {
            offsetStyle.top = offsetY;
            offsetStyle.bottom = AUTO;
          }
        }
        var miscStyle = {};
        if (stretch) {
          if (stretch.includes("height") && targetHeight) {
            miscStyle.height = targetHeight;
          } else if (stretch.includes("minHeight") && targetHeight) {
            miscStyle.minHeight = targetHeight;
          }
          if (stretch.includes("width") && targetWidth) {
            miscStyle.width = targetWidth;
          } else if (stretch.includes("minWidth") && targetWidth) {
            miscStyle.minWidth = targetWidth;
          }
        }
        if (!open) {
          miscStyle.pointerEvents = "none";
        }
        return /* @__PURE__ */ React__namespace.createElement(Portal2, {
          open: forceRender || isNodeVisible,
          getContainer: getPopupContainer && function() {
            return getPopupContainer(target);
          },
          autoDestroy
        }, /* @__PURE__ */ React__namespace.createElement(Mask, {
          prefixCls,
          open,
          zIndex,
          mask,
          motion: maskMotion
        }), /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
          onResize: onAlign,
          disabled: !open
        }, function(resizeObserverRef) {
          return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$1({
            motionAppear: true,
            motionEnter: true,
            motionLeave: true,
            removeOnLeave: false,
            forceRender,
            leavedClassName: "".concat(prefixCls, "-hidden")
          }, motion, {
            onAppearPrepare: onPrepare,
            onEnterPrepare: onPrepare,
            visible: open,
            onVisibleChanged: function onVisibleChanged(nextVisible) {
              var _motion$onVisibleChan;
              motion === null || motion === void 0 ? void 0 : (_motion$onVisibleChan = motion.onVisibleChanged) === null || _motion$onVisibleChan === void 0 ? void 0 : _motion$onVisibleChan.call(motion, nextVisible);
              _onVisibleChanged(nextVisible);
            }
          }), function(_ref, motionRef) {
            var motionClassName = _ref.className, motionStyle = _ref.style;
            var cls = classNames(prefixCls, motionClassName, className);
            return /* @__PURE__ */ React__namespace.createElement("div", {
              ref: composeRef(resizeObserverRef, ref, motionRef),
              className: cls,
              style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
                "--arrow-x": "".concat(arrowPos.x || 0, "px"),
                "--arrow-y": "".concat(arrowPos.y || 0, "px")
              }, offsetStyle), miscStyle), motionStyle), {}, {
                boxSizing: "border-box",
                zIndex
              }, style2),
              onMouseEnter,
              onMouseLeave,
              onClick
            }, arrow && /* @__PURE__ */ React__namespace.createElement(Arrow, {
              prefixCls,
              arrow,
              arrowPos,
              align
            }), /* @__PURE__ */ React__namespace.createElement(PopupContent, {
              cache: !open
            }, childNode));
          });
        }));
      });
      var TriggerWrapper = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
        var canUseRef = supportRef(children);
        var setRef = React__namespace.useCallback(function(node2) {
          fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
        }, [getTriggerDOMNode]);
        var mergedRef = useComposeRef(setRef, children.ref);
        return canUseRef ? /* @__PURE__ */ React__namespace.cloneElement(children, {
          ref: mergedRef
        }) : children;
      });
      var _excluded$4 = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
      function generateTrigger() {
        var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
        var Trigger2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
          var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$4);
          var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
          var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray$5(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
          useLayoutEffect(function() {
            setMobile(isMobile());
          }, []);
          var subPopupElements = React__namespace.useRef({});
          var parentContext = React__namespace.useContext(TriggerContext);
          var context = React__namespace.useMemo(function() {
            return {
              registerSubPopup: function registerSubPopup(id2, subPopupEle) {
                subPopupElements.current[id2] = subPopupEle;
                parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id2, subPopupEle);
              }
            };
          }, [parentContext]);
          var id = useId();
          var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray$5(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
          var setPopupRef = useEvent(function(node2) {
            if (isDOM(node2) && popupEle !== node2) {
              setPopupEle(node2);
            }
            parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id, node2);
          });
          var _React$useState5 = React__namespace.useState(null), _React$useState6 = _slicedToArray$5(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
          var setTargetRef = useEvent(function(node2) {
            if (isDOM(node2) && targetEle !== node2) {
              setTargetEle(node2);
            }
          });
          var child = React__namespace.Children.only(children);
          var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
          var cloneProps = {};
          var inPopupOrChild = useEvent(function(ele) {
            var _getShadowRoot, _getShadowRoot2;
            var childDOM = targetEle;
            return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
              return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
            });
          });
          var mergePopupMotion = getMotion(prefixCls, popupMotion, popupAnimation, popupTransitionName);
          var mergeMaskMotion = getMotion(prefixCls, maskMotion, maskAnimation, maskTransitionName);
          var _React$useState7 = React__namespace.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray$5(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
          var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
          var setMergedOpen = useEvent(function(nextOpen) {
            if (popupVisible === void 0) {
              setInternalOpen(nextOpen);
            }
          });
          useLayoutEffect(function() {
            setInternalOpen(popupVisible || false);
          }, [popupVisible]);
          var openRef = React__namespace.useRef(mergedOpen);
          openRef.current = mergedOpen;
          var internalTriggerOpen = useEvent(function(nextOpen) {
            if (mergedOpen !== nextOpen) {
              setMergedOpen(nextOpen);
              onPopupVisibleChange === null || onPopupVisibleChange === void 0 ? void 0 : onPopupVisibleChange(nextOpen);
            }
          });
          var delayRef = React__namespace.useRef();
          var clearDelay = function clearDelay2() {
            clearTimeout(delayRef.current);
          };
          var triggerOpen = function triggerOpen2(nextOpen) {
            var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            clearDelay();
            if (delay === 0) {
              internalTriggerOpen(nextOpen);
            } else {
              delayRef.current = setTimeout(function() {
                internalTriggerOpen(nextOpen);
              }, delay * 1e3);
            }
          };
          React__namespace.useEffect(function() {
            return clearDelay;
          }, []);
          var _React$useState9 = React__namespace.useState(false), _React$useState10 = _slicedToArray$5(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
          useLayoutEffect(function(firstMount) {
            if (!firstMount || mergedOpen) {
              setInMotion(true);
            }
          }, [mergedOpen]);
          var _React$useState11 = React__namespace.useState(null), _React$useState12 = _slicedToArray$5(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
          var _React$useState13 = React__namespace.useState([0, 0]), _React$useState14 = _slicedToArray$5(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
          var setMousePosByEvent = function setMousePosByEvent2(event) {
            setMousePos([event.clientX, event.clientY]);
          };
          var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray$5(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
          var triggerAlign = useEvent(function() {
            if (!inMotion) {
              onAlign();
            }
          });
          useWatch(mergedOpen, targetEle, popupEle, triggerAlign);
          useLayoutEffect(function() {
            triggerAlign();
          }, [mousePos, popupPlacement]);
          useLayoutEffect(function() {
            if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
              triggerAlign();
            }
          }, [JSON.stringify(popupAlign)]);
          var alignedClassName = React__namespace.useMemo(function() {
            var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
            return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
          }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
          React__namespace.useImperativeHandle(ref, function() {
            return {
              forceAlign: triggerAlign
            };
          });
          var onVisibleChanged = function onVisibleChanged2(visible) {
            setInMotion(false);
            onAlign();
            afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 ? void 0 : afterPopupVisibleChange(visible);
          };
          var onPrepare = function onPrepare2() {
            return new Promise(function(resolve) {
              setMotionPrepareResolve(function() {
                return resolve;
              });
            });
          };
          useLayoutEffect(function() {
            if (motionPrepareResolve) {
              onAlign();
              motionPrepareResolve();
              setMotionPrepareResolve(null);
            }
          }, [motionPrepareResolve]);
          var _React$useState15 = React__namespace.useState(0), _React$useState16 = _slicedToArray$5(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
          var _React$useState17 = React__namespace.useState(0), _React$useState18 = _slicedToArray$5(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
          var onTargetResize = function onTargetResize2(_, ele) {
            triggerAlign();
            if (stretch) {
              var rect = ele.getBoundingClientRect();
              setTargetWidth(rect.width);
              setTargetHeight(rect.height);
            }
          };
          var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray$5(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
          var wrapperAction = function wrapperAction2(eventName, nextOpen, delay, preEvent) {
            cloneProps[eventName] = function(event) {
              var _originChildProps$eve;
              preEvent === null || preEvent === void 0 ? void 0 : preEvent(event);
              triggerOpen(nextOpen, delay);
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 ? void 0 : _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
            };
          };
          var clickToShow = showActions.has("click");
          var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
          if (clickToShow || clickToHide) {
            cloneProps.onClick = function(event) {
              var _originChildProps$onC;
              if (openRef.current && clickToHide) {
                triggerOpen(false);
              } else if (!openRef.current && clickToShow) {
                setMousePosByEvent(event);
                triggerOpen(true);
              }
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 ? void 0 : _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
            };
          }
          useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
          var hoverToShow = showActions.has("hover");
          var hoverToHide = hideActions.has("hover");
          var onPopupMouseEnter;
          var onPopupMouseLeave;
          if (hoverToShow) {
            wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
              setMousePosByEvent(event);
            });
            onPopupMouseEnter = function onPopupMouseEnter2() {
              triggerOpen(true, mouseEnterDelay);
            };
            if (alignPoint) {
              cloneProps.onMouseMove = function(event) {
                var _originChildProps$onM;
                (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 ? void 0 : _originChildProps$onM.call(originChildProps, event);
              };
            }
          }
          if (hoverToHide) {
            wrapperAction("onMouseLeave", false, mouseLeaveDelay);
            onPopupMouseLeave = function onPopupMouseLeave2() {
              triggerOpen(false, mouseLeaveDelay);
            };
          }
          if (showActions.has("focus")) {
            wrapperAction("onFocus", true, focusDelay);
          }
          if (hideActions.has("focus")) {
            wrapperAction("onBlur", false, blurDelay);
          }
          if (showActions.has("contextMenu")) {
            cloneProps.onContextMenu = function(event) {
              var _originChildProps$onC2;
              if (openRef.current && hideActions.has("contextMenu")) {
                triggerOpen(false);
              } else {
                setMousePosByEvent(event);
                triggerOpen(true);
              }
              event.preventDefault();
              for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                args[_key3 - 1] = arguments[_key3];
              }
              (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 ? void 0 : _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
            };
          }
          if (className) {
            cloneProps.className = classNames(originChildProps.className, className);
          }
          var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
          var passedProps = {};
          var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
          passedEventList.forEach(function(eventName) {
            if (restProps[eventName]) {
              passedProps[eventName] = function() {
                var _mergedChildrenProps$;
                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args[_key4] = arguments[_key4];
                }
                (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 ? void 0 : _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
                restProps[eventName].apply(restProps, args);
              };
            }
          });
          var triggerNode = /* @__PURE__ */ React__namespace.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
          var arrowPos = {
            x: arrowX,
            y: arrowY
          };
          var innerArrow = arrow ? _objectSpread2({}, arrow !== true ? arrow : {}) : null;
          return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
            disabled: !mergedOpen,
            ref: setTargetRef,
            onResize: onTargetResize
          }, /* @__PURE__ */ React__namespace.createElement(TriggerWrapper, {
            getTriggerDOMNode
          }, triggerNode)), /* @__PURE__ */ React__namespace.createElement(TriggerContext.Provider, {
            value: context
          }, /* @__PURE__ */ React__namespace.createElement(Popup$1, {
            portal: PortalComponent,
            ref: setPopupRef,
            prefixCls,
            popup,
            className: classNames(popupClassName, alignedClassName),
            style: popupStyle,
            target: targetEle,
            onMouseEnter: onPopupMouseEnter,
            onMouseLeave: onPopupMouseLeave,
            zIndex,
            open: mergedOpen,
            keepDom: inMotion,
            onClick: onPopupClick,
            mask,
            motion: mergePopupMotion,
            maskMotion: mergeMaskMotion,
            onVisibleChanged,
            onPrepare,
            forceRender,
            autoDestroy: mergedAutoDestroy,
            getPopupContainer,
            align: alignInfo,
            arrow: innerArrow,
            arrowPos,
            ready,
            offsetX,
            offsetY,
            offsetR,
            offsetB,
            onAlign: triggerAlign,
            stretch,
            targetWidth: targetWidth / scaleX,
            targetHeight: targetHeight / scaleY
          })));
        });
        return Trigger2;
      }
      const Trigger = generateTrigger(Portal);
      function getStatusClassNames(prefixCls, status, hasFeedback) {
        return classNames({
          [`${prefixCls}-status-success`]: status === "success",
          [`${prefixCls}-status-warning`]: status === "warning",
          [`${prefixCls}-status-error`]: status === "error",
          [`${prefixCls}-status-validating`]: status === "validating",
          [`${prefixCls}-has-feedback`]: hasFeedback
        });
      }
      const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
      var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
      const SearchOutlinedSvg = SearchOutlined$2;
      var SearchOutlined = function SearchOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: SearchOutlinedSvg
        }));
      };
      const SearchOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(SearchOutlined);
      const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
      const getResponsiveMap = (token2) => ({
        xs: `(max-width: ${token2.screenXSMax}px)`,
        sm: `(min-width: ${token2.screenSM}px)`,
        md: `(min-width: ${token2.screenMD}px)`,
        lg: `(min-width: ${token2.screenLG}px)`,
        xl: `(min-width: ${token2.screenXL}px)`,
        xxl: `(min-width: ${token2.screenXXL}px)`
      });
      const validateBreakpoints = (token2) => {
        const indexableToken = token2;
        const revBreakpoints = [].concat(responsiveArray).reverse();
        revBreakpoints.forEach((breakpoint, i2) => {
          const breakpointUpper = breakpoint.toUpperCase();
          const screenMin = `screen${breakpointUpper}Min`;
          const screen = `screen${breakpointUpper}`;
          if (!(indexableToken[screenMin] <= indexableToken[screen])) {
            throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
          }
          if (i2 < revBreakpoints.length - 1) {
            const screenMax = `screen${breakpointUpper}Max`;
            if (!(indexableToken[screen] <= indexableToken[screenMax])) {
              throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
            }
            const nextBreakpointUpperMin = revBreakpoints[i2 + 1].toUpperCase();
            const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
            if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
              throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
            }
          }
        });
        return token2;
      };
      function useResponsiveObserver() {
        const [, token2] = useToken$2();
        const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
        return React.useMemo(() => {
          const subscribers = /* @__PURE__ */ new Map();
          let subUid = -1;
          let screens = {};
          return {
            matchHandlers: {},
            dispatch(pointMap) {
              screens = pointMap;
              subscribers.forEach((func) => func(screens));
              return subscribers.size >= 1;
            },
            subscribe(func) {
              if (!subscribers.size)
                this.register();
              subUid += 1;
              subscribers.set(subUid, func);
              func(screens);
              return subUid;
            },
            unsubscribe(paramToken) {
              subscribers.delete(paramToken);
              if (!subscribers.size)
                this.unregister();
            },
            unregister() {
              Object.keys(responsiveMap).forEach((screen) => {
                const matchMediaQuery = responsiveMap[screen];
                const handler = this.matchHandlers[matchMediaQuery];
                handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
              });
              subscribers.clear();
            },
            register() {
              Object.keys(responsiveMap).forEach((screen) => {
                const matchMediaQuery = responsiveMap[screen];
                const listener = (_ref) => {
                  let {
                    matches: matches2
                  } = _ref;
                  this.dispatch(Object.assign(Object.assign({}, screens), {
                    [screen]: matches2
                  }));
                };
                const mql = window.matchMedia(matchMediaQuery);
                mql.addListener(listener);
                this.matchHandlers[matchMediaQuery] = {
                  mql,
                  listener
                };
                listener(mql);
              });
            },
            responsiveMap
          };
        }, [token2]);
      }
      var autoAdjustOverflowTopBottom = {
        shiftX: 64,
        adjustY: 1
      };
      var autoAdjustOverflowLeftRight = {
        adjustX: 1,
        shiftY: true
      };
      var targetOffset = [0, 0];
      var placements = {
        left: {
          points: ["cr", "cl"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [-4, 0],
          targetOffset
        },
        right: {
          points: ["cl", "cr"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [4, 0],
          targetOffset
        },
        top: {
          points: ["bc", "tc"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, -4],
          targetOffset
        },
        bottom: {
          points: ["tc", "bc"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, 4],
          targetOffset
        },
        topLeft: {
          points: ["bl", "tl"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, -4],
          targetOffset
        },
        leftTop: {
          points: ["tr", "tl"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [-4, 0],
          targetOffset
        },
        topRight: {
          points: ["br", "tr"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, -4],
          targetOffset
        },
        rightTop: {
          points: ["tl", "tr"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [4, 0],
          targetOffset
        },
        bottomRight: {
          points: ["tr", "br"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, 4],
          targetOffset
        },
        rightBottom: {
          points: ["bl", "br"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [4, 0],
          targetOffset
        },
        bottomLeft: {
          points: ["tl", "bl"],
          overflow: autoAdjustOverflowTopBottom,
          offset: [0, 4],
          targetOffset
        },
        leftBottom: {
          points: ["br", "bl"],
          overflow: autoAdjustOverflowLeftRight,
          offset: [-4, 0],
          targetOffset
        }
      };
      function Popup(props) {
        var children = props.children, prefixCls = props.prefixCls, id = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames("".concat(prefixCls, "-content"), className),
          style: style2
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-inner"),
          id,
          role: "tooltip",
          style: overlayInnerStyle
        }, typeof children === "function" ? children() : children));
      }
      var _excluded$3 = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
      var Tooltip$2 = function Tooltip2(props, ref) {
        var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
        props.arrowContent;
        var overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties(props, _excluded$3);
        var triggerRef = React.useRef(null);
        React.useImperativeHandle(ref, function() {
          return triggerRef.current;
        });
        var extraProps = _objectSpread2({}, restProps);
        if ("visible" in props) {
          extraProps.popupVisible = props.visible;
        }
        var getPopupElement = function getPopupElement2() {
          return /* @__PURE__ */ React__namespace.createElement(Popup, {
            key: "content",
            prefixCls,
            id,
            overlayInnerStyle
          }, overlay);
        };
        return /* @__PURE__ */ React__namespace.createElement(Trigger, _extends$1({
          popupClassName: overlayClassName,
          prefixCls,
          popup: getPopupElement,
          action: trigger,
          builtinPlacements: placements,
          popupPlacement: placement,
          ref: triggerRef,
          popupAlign: align,
          getPopupContainer: getTooltipContainer,
          onPopupVisibleChange: onVisibleChange,
          afterPopupVisibleChange: afterVisibleChange,
          popupTransitionName: transitionName,
          popupAnimation: animation,
          popupMotion: motion,
          defaultPopupVisible: defaultVisible,
          autoDestroy: destroyTooltipOnHide,
          mouseLeaveDelay,
          popupStyle: overlayStyle,
          mouseEnterDelay,
          arrow: showArrow
        }, extraProps), children);
      };
      const Tooltip$3 = /* @__PURE__ */ React.forwardRef(Tooltip$2);
      const MAX_VERTICAL_CONTENT_RADIUS = 8;
      function getArrowOffset(options) {
        const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
        const {
          contentRadius,
          limitVerticalRadius
        } = options;
        const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
        const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
        return {
          dropdownArrowOffset,
          dropdownArrowOffsetVertical
        };
      }
      function isInject(valid, code) {
        if (!valid)
          return {};
        return code;
      }
      function getArrowStyle(token2, options) {
        const {
          componentCls,
          sizePopupArrow,
          borderRadiusXS,
          borderRadiusOuter,
          boxShadowPopoverArrow
        } = token2;
        const {
          colorBg,
          contentRadius = token2.borderRadiusLG,
          limitVerticalRadius,
          arrowDistance = 0,
          arrowPlacement = {
            left: true,
            right: true,
            top: true,
            bottom: true
          }
        } = options;
        const {
          dropdownArrowOffsetVertical,
          dropdownArrowOffset
        } = getArrowOffset({
          contentRadius,
          limitVerticalRadius
        });
        return {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
            // ============================ Basic ============================
            [`${componentCls}-arrow`]: [Object.assign(Object.assign({
              position: "absolute",
              zIndex: 1,
              display: "block"
            }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
              "&:before": {
                background: colorBg
              }
            })]
          }, isInject(!!arrowPlacement.top, {
            [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
              bottom: arrowDistance,
              transform: "translateY(100%) rotate(180deg)"
            },
            [`&-placement-top ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateX(-50%) translateY(100%) rotate(180deg)"
            },
            [`&-placement-topLeft ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            [`&-placement-topRight ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            }
          })), isInject(!!arrowPlacement.bottom, {
            [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
              top: arrowDistance,
              transform: `translateY(-100%)`
            },
            [`&-placement-bottom ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: "50%"
              },
              transform: `translateX(-50%) translateY(-100%)`
            },
            [`&-placement-bottomLeft ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            [`&-placement-bottomRight ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            }
          })), isInject(!!arrowPlacement.left, {
            [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
              right: {
                _skip_check_: true,
                value: arrowDistance
              },
              transform: "translateX(100%) rotate(90deg)"
            },
            [`&-placement-left ${componentCls}-arrow`]: {
              top: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateY(-50%) translateX(100%) rotate(90deg)"
            },
            [`&-placement-leftTop ${componentCls}-arrow`]: {
              top: dropdownArrowOffsetVertical
            },
            [`&-placement-leftBottom ${componentCls}-arrow`]: {
              bottom: dropdownArrowOffsetVertical
            }
          })), isInject(!!arrowPlacement.right, {
            [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
              left: {
                _skip_check_: true,
                value: arrowDistance
              },
              transform: "translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-right ${componentCls}-arrow`]: {
              top: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-rightTop ${componentCls}-arrow`]: {
              top: dropdownArrowOffsetVertical
            },
            [`&-placement-rightBottom ${componentCls}-arrow`]: {
              bottom: dropdownArrowOffsetVertical
            }
          }))
        };
      }
      function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
        if (autoAdjustOverflow === false) {
          return {
            adjustX: false,
            adjustY: false
          };
        }
        const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === "object" ? autoAdjustOverflow : {};
        const baseOverflow = {};
        switch (placement) {
          case "top":
          case "bottom":
            baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
            break;
          case "left":
          case "right":
            baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
            break;
        }
        const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
        if (!mergedOverflow.shiftX) {
          mergedOverflow.adjustX = true;
        }
        if (!mergedOverflow.shiftY) {
          mergedOverflow.adjustY = true;
        }
        return mergedOverflow;
      }
      const PlacementAlignMap = {
        left: {
          points: ["cr", "cl"]
        },
        right: {
          points: ["cl", "cr"]
        },
        top: {
          points: ["bc", "tc"]
        },
        bottom: {
          points: ["tc", "bc"]
        },
        topLeft: {
          points: ["bl", "tl"]
        },
        leftTop: {
          points: ["tr", "tl"]
        },
        topRight: {
          points: ["br", "tr"]
        },
        rightTop: {
          points: ["tl", "tr"]
        },
        bottomRight: {
          points: ["tr", "br"]
        },
        rightBottom: {
          points: ["bl", "br"]
        },
        bottomLeft: {
          points: ["tl", "bl"]
        },
        leftBottom: {
          points: ["br", "bl"]
        }
      };
      const ArrowCenterPlacementAlignMap = {
        topLeft: {
          points: ["bl", "tc"]
        },
        leftTop: {
          points: ["tr", "cl"]
        },
        topRight: {
          points: ["br", "tc"]
        },
        rightTop: {
          points: ["tl", "cr"]
        },
        bottomRight: {
          points: ["tr", "bc"]
        },
        rightBottom: {
          points: ["bl", "cr"]
        },
        bottomLeft: {
          points: ["tl", "bc"]
        },
        leftBottom: {
          points: ["br", "cl"]
        }
      };
      const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
      function getPlacements(config2) {
        const {
          arrowWidth,
          autoAdjustOverflow,
          arrowPointAtCenter,
          offset: offset2,
          borderRadius,
          visibleFirst
        } = config2;
        const halfArrowWidth = arrowWidth / 2;
        const placementMap = {};
        Object.keys(PlacementAlignMap).forEach((key2) => {
          const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key2] || PlacementAlignMap[key2];
          const placementInfo = Object.assign(Object.assign({}, template), {
            offset: [0, 0]
          });
          placementMap[key2] = placementInfo;
          if (DisableAutoArrowList.has(key2)) {
            placementInfo.autoArrow = false;
          }
          switch (key2) {
            case "top":
            case "topLeft":
            case "topRight":
              placementInfo.offset[1] = -halfArrowWidth - offset2;
              break;
            case "bottom":
            case "bottomLeft":
            case "bottomRight":
              placementInfo.offset[1] = halfArrowWidth + offset2;
              break;
            case "left":
            case "leftTop":
            case "leftBottom":
              placementInfo.offset[0] = -halfArrowWidth - offset2;
              break;
            case "right":
            case "rightTop":
            case "rightBottom":
              placementInfo.offset[0] = halfArrowWidth + offset2;
              break;
          }
          const arrowOffset = getArrowOffset({
            contentRadius: borderRadius,
            limitVerticalRadius: true
          });
          if (arrowPointAtCenter) {
            switch (key2) {
              case "topLeft":
              case "bottomLeft":
                placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
                break;
              case "topRight":
              case "bottomRight":
                placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
                break;
              case "leftTop":
              case "rightTop":
                placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
                break;
              case "leftBottom":
              case "rightBottom":
                placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
                break;
            }
          }
          placementInfo.overflow = getOverflowOptions(key2, arrowOffset, arrowWidth, autoAdjustOverflow);
          if (visibleFirst) {
            placementInfo.htmlRegion = "visibleFirst";
          }
        });
        return placementMap;
      }
      const getDesignToken = (config2) => {
        const theme2 = (config2 === null || config2 === void 0 ? void 0 : config2.algorithm) ? createTheme(config2.algorithm) : createTheme(derivative$2);
        const mergedToken = Object.assign(Object.assign({}, seedToken$1), config2 === null || config2 === void 0 ? void 0 : config2.token);
        return getComputedToken(mergedToken, {
          override: config2 === null || config2 === void 0 ? void 0 : config2.token
        }, theme2, formatToken);
      };
      const getDesignToken$1 = getDesignToken;
      function genSizeMapToken(token2) {
        const {
          sizeUnit,
          sizeStep
        } = token2;
        const compactSizeStep = sizeStep - 2;
        return {
          sizeXXL: sizeUnit * (compactSizeStep + 10),
          sizeXL: sizeUnit * (compactSizeStep + 6),
          sizeLG: sizeUnit * (compactSizeStep + 2),
          sizeMD: sizeUnit * (compactSizeStep + 2),
          sizeMS: sizeUnit * (compactSizeStep + 1),
          size: sizeUnit * compactSizeStep,
          sizeSM: sizeUnit * compactSizeStep,
          sizeXS: sizeUnit * (compactSizeStep - 1),
          sizeXXS: sizeUnit * (compactSizeStep - 1)
        };
      }
      const derivative$1 = (token2, mapToken) => {
        const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
        const fontSize = mergedMapToken.fontSizeSM;
        const controlHeight = mergedMapToken.controlHeight - 4;
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$1(fontSize)), {
          // controlHeight
          controlHeight
        }), genControlHeight$1(Object.assign(Object.assign({}, mergedMapToken), {
          controlHeight
        })));
      };
      const compactAlgorithm = derivative$1;
      const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
      const getSolidColor = (baseColor, brightness) => {
        const instance = new TinyColor(baseColor);
        return instance.lighten(brightness).toHexString();
      };
      const generateColorPalettes = (baseColor) => {
        const colors = generate$1(baseColor, {
          theme: "dark"
        });
        return {
          1: colors[0],
          2: colors[1],
          3: colors[2],
          4: colors[3],
          5: colors[6],
          6: colors[5],
          7: colors[4],
          8: colors[6],
          9: colors[5],
          10: colors[4]
          // 8: colors[9],
          // 9: colors[8],
          // 10: colors[7],
        };
      };
      const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
        const colorBgBase = bgBaseColor || "#000";
        const colorTextBase = textBaseColor || "#fff";
        return {
          colorBgBase,
          colorTextBase,
          colorText: getAlphaColor(colorTextBase, 0.85),
          colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
          colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
          colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
          colorFill: getAlphaColor(colorTextBase, 0.18),
          colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
          colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
          colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
          colorBgElevated: getSolidColor(colorBgBase, 12),
          colorBgContainer: getSolidColor(colorBgBase, 8),
          colorBgLayout: getSolidColor(colorBgBase, 0),
          colorBgSpotlight: getSolidColor(colorBgBase, 26),
          colorBorder: getSolidColor(colorBgBase, 26),
          colorBorderSecondary: getSolidColor(colorBgBase, 19)
        };
      };
      const derivative = (token2, mapToken) => {
        const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
          const colors = generate$1(token2[colorKey], {
            theme: "dark"
          });
          return new Array(10).fill(1).reduce((prev2, _, i2) => {
            prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
            prev2[`${colorKey}${i2 + 1}`] = colors[i2];
            return prev2;
          }, {});
        }).reduce((prev2, cur) => {
          prev2 = Object.assign(Object.assign({}, prev2), cur);
          return prev2;
        }, {});
        const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
        return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
          generateColorPalettes,
          generateNeutralColorPalettes
        }));
      };
      const darkAlgorithm = derivative;
      function useToken$1() {
        const [theme2, token2, hashId] = useToken$2();
        return {
          theme: theme2,
          token: token2,
          hashId
        };
      }
      const theme = {
        /** @private Test Usage. Do not use in production. */
        defaultConfig,
        /** Default seedToken */
        defaultSeed: defaultConfig.token,
        useToken: useToken$1,
        defaultAlgorithm: derivative$2,
        darkAlgorithm,
        compactAlgorithm,
        getDesignToken: getDesignToken$1
      };
      const genTooltipStyle = (token2) => {
        const {
          componentCls,
          // ant-tooltip
          tooltipMaxWidth,
          tooltipColor,
          tooltipBg,
          tooltipBorderRadius,
          zIndexPopup,
          controlHeight,
          boxShadowSecondary,
          paddingSM,
          paddingXS,
          tooltipRadiusOuter
        } = token2;
        return [
          {
            [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
              position: "absolute",
              zIndex: zIndexPopup,
              display: "block",
              width: "max-content",
              maxWidth: tooltipMaxWidth,
              visibility: "visible",
              transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
              "&-hidden": {
                display: "none"
              },
              "--antd-arrow-background-color": tooltipBg,
              // Wrapper for the tooltip content
              [`${componentCls}-inner`]: {
                minWidth: controlHeight,
                minHeight: controlHeight,
                padding: `${paddingSM / 2}px ${paddingXS}px`,
                color: tooltipColor,
                textAlign: "start",
                textDecoration: "none",
                wordWrap: "break-word",
                backgroundColor: tooltipBg,
                borderRadius: tooltipBorderRadius,
                boxShadow: boxShadowSecondary,
                boxSizing: "border-box"
              },
              // Limit left and right placement radius
              [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
                [`${componentCls}-inner`]: {
                  borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
                }
              },
              [`${componentCls}-content`]: {
                position: "relative"
              }
            }), genPresetColor(token2, (colorKey, _ref) => {
              let {
                darkColor
              } = _ref;
              return {
                [`&${componentCls}-${colorKey}`]: {
                  [`${componentCls}-inner`]: {
                    backgroundColor: darkColor
                  },
                  [`${componentCls}-arrow`]: {
                    "--antd-arrow-background-color": darkColor
                  }
                }
              };
            })), {
              // RTL
              "&-rtl": {
                direction: "rtl"
              }
            })
          },
          // Arrow Style
          getArrowStyle(merge(token2, {
            borderRadiusOuter: tooltipRadiusOuter
          }), {
            colorBg: "var(--antd-arrow-background-color)",
            contentRadius: tooltipBorderRadius,
            limitVerticalRadius: true
          }),
          // Pure Render
          {
            [`${componentCls}-pure`]: {
              position: "relative",
              maxWidth: "none",
              margin: token2.sizePopupArrow
            }
          }
        ];
      };
      const useStyle$3 = (prefixCls, injectStyle) => {
        const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
          if (injectStyle === false) {
            return [];
          }
          const {
            borderRadius,
            colorTextLightSolid,
            colorBgDefault,
            borderRadiusOuter
          } = token2;
          const TooltipToken = merge(token2, {
            // default variables
            tooltipMaxWidth: 250,
            tooltipColor: colorTextLightSolid,
            tooltipBorderRadius: borderRadius,
            tooltipBg: colorBgDefault,
            tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
          });
          return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
        }, (_ref2) => {
          let {
            zIndexPopupBase,
            colorBgSpotlight
          } = _ref2;
          return {
            zIndexPopup: zIndexPopupBase + 70,
            colorBgDefault: colorBgSpotlight
          };
        }, {
          resetStyle: false
        });
        return useOriginHook(prefixCls);
      };
      const inverseColors = PresetColors.map((color) => `${color}-inverse`);
      function isPresetColor(color) {
        let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (includeInverse) {
          return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
        }
        return PresetColors.includes(color);
      }
      function parseColor(prefixCls, color) {
        const isInternalColor = isPresetColor(color);
        const className = classNames({
          [`${prefixCls}-${color}`]: color && isInternalColor
        });
        const overlayStyle = {};
        const arrowStyle = {};
        if (color && !isInternalColor) {
          overlayStyle.background = color;
          arrowStyle["--antd-arrow-background-color"] = color;
        }
        return {
          className,
          overlayStyle,
          arrowStyle
        };
      }
      function PurePanel$3(props) {
        const {
          prefixCls: customizePrefixCls,
          className,
          placement = "top",
          title,
          color,
          overlayInnerStyle
        } = props;
        const {
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
        const [wrapSSR, hashId] = useStyle$3(prefixCls, true);
        const colorInfo = parseColor(prefixCls, color);
        const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
        const arrowContentStyle = colorInfo.arrowStyle;
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
          style: arrowContentStyle
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${prefixCls}-arrow`
        }), /* @__PURE__ */ React__namespace.createElement(Popup, Object.assign({}, props, {
          className: hashId,
          prefixCls,
          overlayInnerStyle: formattedOverlayInnerStyle
        }), title)));
      }
      var __rest$d = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const {
        useToken
      } = theme;
      const splitObject = (obj, keys2) => {
        const picked = {};
        const omitted = Object.assign({}, obj);
        keys2.forEach((key2) => {
          if (obj && key2 in obj) {
            picked[key2] = obj[key2];
            delete omitted[key2];
          }
        });
        return {
          picked,
          omitted
        };
      };
      function getDisabledCompatibleChildren(element, prefixCls) {
        const elementType = element.type;
        if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
          const {
            picked,
            omitted
          } = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
          const spanStyle = Object.assign(Object.assign({
            display: "inline-block"
          }, picked), {
            cursor: "not-allowed",
            width: element.props.block ? "100%" : void 0
          });
          const buttonStyle = Object.assign(Object.assign({}, omitted), {
            pointerEvents: "none"
          });
          const child = cloneElement(element, {
            style: buttonStyle,
            className: null
          });
          return /* @__PURE__ */ React__namespace.createElement("span", {
            style: spanStyle,
            className: classNames(element.props.className, `${prefixCls}-disabled-compatible-wrapper`)
          }, child);
        }
        return element;
      }
      const Tooltip = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        var _a, _b;
        const {
          prefixCls: customizePrefixCls,
          openClassName,
          getTooltipContainer,
          overlayClassName,
          color,
          overlayInnerStyle,
          children,
          afterOpenChange,
          afterVisibleChange,
          destroyTooltipOnHide,
          arrow = true,
          title,
          overlay,
          builtinPlacements,
          arrowPointAtCenter = false,
          autoAdjustOverflow = true
        } = props;
        const mergedShowArrow = !!arrow;
        const {
          token: token2
        } = useToken();
        const {
          getPopupContainer: getContextPopupContainer,
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const tooltipRef = React__namespace.useRef(null);
        const forceAlign = () => {
          var _a2;
          (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
        };
        React__namespace.useImperativeHandle(ref, () => ({
          forceAlign,
          forcePopupAlign: () => {
            forceAlign();
          }
        }));
        const [open, setOpen] = useMergedState(false, {
          value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
          defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
        });
        const noTitle = !title && !overlay && title !== 0;
        const onOpenChange = (vis) => {
          var _a2, _b2;
          setOpen(noTitle ? false : vis);
          if (!noTitle) {
            (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
            (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
          }
        };
        const tooltipPlacements = React__namespace.useMemo(() => {
          var _a2, _b2;
          let mergedArrowPointAtCenter = arrowPointAtCenter;
          if (typeof arrow === "object") {
            mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
          }
          return builtinPlacements || getPlacements({
            arrowPointAtCenter: mergedArrowPointAtCenter,
            autoAdjustOverflow,
            arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
            borderRadius: token2.borderRadius,
            offset: token2.marginXXS,
            visibleFirst: true
          });
        }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
        const memoOverlay = React__namespace.useMemo(() => {
          if (title === 0) {
            return title;
          }
          return overlay || title || "";
        }, [overlay, title]);
        const memoOverlayWrapper = /* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
        const {
          getPopupContainer,
          placement = "top",
          mouseEnterDelay = 0.1,
          mouseLeaveDelay = 0.1,
          overlayStyle,
          rootClassName
        } = props, otherProps = __rest$d(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
        const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
        const rootPrefixCls = getPrefixCls();
        const injectFromPopover = props["data-popover-inject"];
        let tempOpen = open;
        if (!("open" in props) && !("visible" in props) && noTitle) {
          tempOpen = false;
        }
        const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ React__namespace.createElement("span", null, children), prefixCls);
        const childProps = child.props;
        const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
          [openClassName || `${prefixCls}-open`]: true
        }) : childProps.className;
        const [wrapSSR, hashId] = useStyle$3(prefixCls, !injectFromPopover);
        const colorInfo = parseColor(prefixCls, color);
        const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
        const arrowContentStyle = colorInfo.arrowStyle;
        const customOverlayClassName = classNames(overlayClassName, {
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, colorInfo.className, rootClassName, hashId);
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(Tooltip$3, Object.assign({}, otherProps, {
          showArrow: mergedShowArrow,
          placement,
          mouseEnterDelay,
          mouseLeaveDelay,
          prefixCls,
          overlayClassName: customOverlayClassName,
          overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
          getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
          ref: tooltipRef,
          builtinPlacements: tooltipPlacements,
          overlay: memoOverlayWrapper,
          visible: tempOpen,
          onVisibleChange: onOpenChange,
          afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
          overlayInnerStyle: formattedOverlayInnerStyle,
          arrowContent: /* @__PURE__ */ React__namespace.createElement("span", {
            className: `${prefixCls}-arrow-content`
          }),
          motion: {
            motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
            motionDeadline: 1e3
          },
          destroyTooltipOnHide: !!destroyTooltipOnHide
        }), tempOpen ? cloneElement(child, {
          className: childCls
        }) : child));
      });
      Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
      const Tooltip$1 = Tooltip;
      var dayjs_min = { exports: {} };
      (function(module2, exports2) {
        !function(t2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u2 = "hour", a = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
            var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
            return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
          } }, m2 = function(t3, e3, n3) {
            var r3 = String(t3);
            return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
          }, v2 = { s: m2, z: function(t3) {
            var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
            return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
          }, m: function t3(e3, n3) {
            if (e3.date() < n3.date())
              return -t3(n3, e3);
            var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s2 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
            return +(-(r3 + (n3 - i3) / (s2 ? i3 - u3 : u3 - i3)) || 0);
          }, a: function(t3) {
            return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
          }, p: function(t3) {
            return { M: c2, y: h2, w: o2, d: a, D: d2, h: u2, m: s, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t3) {
            return void 0 === t3;
          } }, g2 = "en", D2 = {};
          D2[g2] = M;
          var p2 = function(t3) {
            return t3 instanceof b2;
          }, S = function t3(e3, n3, r3) {
            var i3;
            if (!e3)
              return g2;
            if ("string" == typeof e3) {
              var s2 = e3.toLowerCase();
              D2[s2] && (i3 = s2), n3 && (D2[s2] = n3, i3 = s2);
              var u3 = e3.split("-");
              if (!i3 && u3.length > 1)
                return t3(u3[0]);
            } else {
              var a2 = e3.name;
              D2[a2] = e3, i3 = a2;
            }
            return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
          }, w2 = function(t3, e3) {
            if (p2(t3))
              return t3.clone();
            var n3 = "object" == typeof e3 ? e3 : {};
            return n3.date = t3, n3.args = arguments, new b2(n3);
          }, O = v2;
          O.l = S, O.i = p2, O.w = function(t3, e3) {
            return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
          };
          var b2 = function() {
            function M2(t3) {
              this.$L = S(t3.locale, null, true), this.parse(t3);
            }
            var m3 = M2.prototype;
            return m3.parse = function(t3) {
              this.$d = function(t4) {
                var e3 = t4.date, n3 = t4.utc;
                if (null === e3)
                  return /* @__PURE__ */ new Date(NaN);
                if (O.u(e3))
                  return /* @__PURE__ */ new Date();
                if (e3 instanceof Date)
                  return new Date(e3);
                if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                  var r3 = e3.match($);
                  if (r3) {
                    var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                    return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                  }
                }
                return new Date(e3);
              }(t3), this.$x = t3.x || {}, this.init();
            }, m3.init = function() {
              var t3 = this.$d;
              this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
            }, m3.$utils = function() {
              return O;
            }, m3.isValid = function() {
              return !(this.$d.toString() === l2);
            }, m3.isSame = function(t3, e3) {
              var n3 = w2(t3);
              return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
            }, m3.isAfter = function(t3, e3) {
              return w2(t3) < this.startOf(e3);
            }, m3.isBefore = function(t3, e3) {
              return this.endOf(e3) < w2(t3);
            }, m3.$g = function(t3, e3, n3) {
              return O.u(t3) ? this[e3] : this.set(n3, t3);
            }, m3.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m3.valueOf = function() {
              return this.$d.getTime();
            }, m3.startOf = function(t3, e3) {
              var n3 = this, r3 = !!O.u(e3) || e3, f3 = O.p(t3), l3 = function(t4, e4) {
                var i3 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
                return r3 ? i3 : i3.endOf(a);
              }, $2 = function(t4, e4) {
                return O.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
              }, y3 = this.$W, M3 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
              switch (f3) {
                case h2:
                  return r3 ? l3(1, 0) : l3(31, 11);
                case c2:
                  return r3 ? l3(1, M3) : l3(0, M3 + 1);
                case o2:
                  var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                  return l3(r3 ? m4 - D3 : m4 + (6 - D3), M3);
                case a:
                case d2:
                  return $2(v3 + "Hours", 0);
                case u2:
                  return $2(v3 + "Minutes", 1);
                case s:
                  return $2(v3 + "Seconds", 2);
                case i2:
                  return $2(v3 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m3.endOf = function(t3) {
              return this.startOf(t3, false);
            }, m3.$set = function(t3, e3) {
              var n3, o3 = O.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a ? this.$D + (e3 - this.$W) : e3;
              if (o3 === c2 || o3 === h2) {
                var y3 = this.clone().set(d2, 1);
                y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
              } else
                l3 && this.$d[l3]($2);
              return this.init(), this;
            }, m3.set = function(t3, e3) {
              return this.clone().$set(t3, e3);
            }, m3.get = function(t3) {
              return this[O.p(t3)]();
            }, m3.add = function(r3, f3) {
              var d3, l3 = this;
              r3 = Number(r3);
              var $2 = O.p(f3), y3 = function(t3) {
                var e3 = w2(l3);
                return O.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
              };
              if ($2 === c2)
                return this.set(c2, this.$M + r3);
              if ($2 === h2)
                return this.set(h2, this.$y + r3);
              if ($2 === a)
                return y3(1);
              if ($2 === o2)
                return y3(7);
              var M3 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
              return O.w(m4, this);
            }, m3.subtract = function(t3, e3) {
              return this.add(-1 * t3, e3);
            }, m3.format = function(t3) {
              var e3 = this, n3 = this.$locale();
              if (!this.isValid())
                return n3.invalidDate || l2;
              var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s3) {
                return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s3);
              }, d3 = function(t4) {
                return O.s(s2 % 12 || 12, t4, "0");
              }, $2 = f3 || function(t4, e4, n4) {
                var r4 = t4 < 12 ? "AM" : "PM";
                return n4 ? r4.toLowerCase() : r4;
              };
              return r3.replace(y2, function(t4, r4) {
                return r4 || function(t5) {
                  switch (t5) {
                    case "YY":
                      return String(e3.$y).slice(-2);
                    case "YYYY":
                      return O.s(e3.$y, 4, "0");
                    case "M":
                      return a2 + 1;
                    case "MM":
                      return O.s(a2 + 1, 2, "0");
                    case "MMM":
                      return h3(n3.monthsShort, a2, c3, 3);
                    case "MMMM":
                      return h3(c3, a2);
                    case "D":
                      return e3.$D;
                    case "DD":
                      return O.s(e3.$D, 2, "0");
                    case "d":
                      return String(e3.$W);
                    case "dd":
                      return h3(n3.weekdaysMin, e3.$W, o3, 2);
                    case "ddd":
                      return h3(n3.weekdaysShort, e3.$W, o3, 3);
                    case "dddd":
                      return o3[e3.$W];
                    case "H":
                      return String(s2);
                    case "HH":
                      return O.s(s2, 2, "0");
                    case "h":
                      return d3(1);
                    case "hh":
                      return d3(2);
                    case "a":
                      return $2(s2, u3, true);
                    case "A":
                      return $2(s2, u3, false);
                    case "m":
                      return String(u3);
                    case "mm":
                      return O.s(u3, 2, "0");
                    case "s":
                      return String(e3.$s);
                    case "ss":
                      return O.s(e3.$s, 2, "0");
                    case "SSS":
                      return O.s(e3.$ms, 3, "0");
                    case "Z":
                      return i3;
                  }
                  return null;
                }(t4) || i3.replace(":", "");
              });
            }, m3.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m3.diff = function(r3, d3, l3) {
              var $2, y3 = this, M3 = O.p(d3), m4 = w2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
                return O.m(y3, m4);
              };
              switch (M3) {
                case h2:
                  $2 = D3() / 12;
                  break;
                case c2:
                  $2 = D3();
                  break;
                case f2:
                  $2 = D3() / 3;
                  break;
                case o2:
                  $2 = (g3 - v3) / 6048e5;
                  break;
                case a:
                  $2 = (g3 - v3) / 864e5;
                  break;
                case u2:
                  $2 = g3 / n2;
                  break;
                case s:
                  $2 = g3 / e2;
                  break;
                case i2:
                  $2 = g3 / t2;
                  break;
                default:
                  $2 = g3;
              }
              return l3 ? $2 : O.a($2);
            }, m3.daysInMonth = function() {
              return this.endOf(c2).$D;
            }, m3.$locale = function() {
              return D2[this.$L];
            }, m3.locale = function(t3, e3) {
              if (!t3)
                return this.$L;
              var n3 = this.clone(), r3 = S(t3, e3, true);
              return r3 && (n3.$L = r3), n3;
            }, m3.clone = function() {
              return O.w(this.$d, this);
            }, m3.toDate = function() {
              return new Date(this.valueOf());
            }, m3.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m3.toISOString = function() {
              return this.$d.toISOString();
            }, m3.toString = function() {
              return this.$d.toUTCString();
            }, M2;
          }(), _ = b2.prototype;
          return w2.prototype = _, [["$ms", r2], ["$s", i2], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
            _[t3[1]] = function(e3) {
              return this.$g(e3, t3[0], t3[1]);
            };
          }), w2.extend = function(t3, e3) {
            return t3.$i || (t3(e3, b2, w2), t3.$i = true), w2;
          }, w2.locale = S, w2.isDayjs = p2, w2.unix = function(t3) {
            return w2(1e3 * t3);
          }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
        });
      })(dayjs_min);
      var dayjs_minExports = dayjs_min.exports;
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      var weekday$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            t2.prototype.weekday = function(e3) {
              var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
              return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
            };
          };
        });
      })(weekday$1);
      var weekdayExports = weekday$1.exports;
      const weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
      var localeData$1 = { exports: {} };
      (function(module2, exports2) {
        !function(n2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          return function(n2, e2, t2) {
            var r2 = e2.prototype, o2 = function(n3) {
              return n3 && (n3.indexOf ? n3 : n3.s);
            }, u2 = function(n3, e3, t3, r3, u3) {
              var i3 = n3.name ? n3 : n3.$locale(), a2 = o2(i3[e3]), s2 = o2(i3[t3]), f2 = a2 || s2.map(function(n4) {
                return n4.slice(0, r3);
              });
              if (!u3)
                return f2;
              var d2 = i3.weekStart;
              return f2.map(function(n4, e4) {
                return f2[(e4 + (d2 || 0)) % 7];
              });
            }, i2 = function() {
              return t2.Ls[t2.locale()];
            }, a = function(n3, e3) {
              return n3.formats[e3] || function(n4) {
                return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
                  return e4 || t3.slice(1);
                });
              }(n3.formats[e3.toUpperCase()]);
            }, s = function() {
              var n3 = this;
              return { months: function(e3) {
                return e3 ? e3.format("MMMM") : u2(n3, "months");
              }, monthsShort: function(e3) {
                return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
              }, firstDayOfWeek: function() {
                return n3.$locale().weekStart || 0;
              }, weekdays: function(e3) {
                return e3 ? e3.format("dddd") : u2(n3, "weekdays");
              }, weekdaysMin: function(e3) {
                return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
              }, weekdaysShort: function(e3) {
                return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
              }, longDateFormat: function(e3) {
                return a(n3.$locale(), e3);
              }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
            };
            r2.localeData = function() {
              return s.bind(this)();
            }, t2.localeData = function() {
              var n3 = i2();
              return { firstDayOfWeek: function() {
                return n3.weekStart || 0;
              }, weekdays: function() {
                return t2.weekdays();
              }, weekdaysShort: function() {
                return t2.weekdaysShort();
              }, weekdaysMin: function() {
                return t2.weekdaysMin();
              }, months: function() {
                return t2.months();
              }, monthsShort: function() {
                return t2.monthsShort();
              }, longDateFormat: function(e3) {
                return a(n3, e3);
              }, meridiem: n3.meridiem, ordinal: n3.ordinal };
            }, t2.months = function() {
              return u2(i2(), "months");
            }, t2.monthsShort = function() {
              return u2(i2(), "monthsShort", "months", 3);
            }, t2.weekdays = function(n3) {
              return u2(i2(), "weekdays", null, null, n3);
            }, t2.weekdaysShort = function(n3) {
              return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
            }, t2.weekdaysMin = function(n3) {
              return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
            };
          };
        });
      })(localeData$1);
      var localeDataExports = localeData$1.exports;
      const localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
      var weekOfYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          var e2 = "week", t2 = "year";
          return function(i2, n2, r2) {
            var f2 = n2.prototype;
            f2.week = function(i3) {
              if (void 0 === i3 && (i3 = null), null !== i3)
                return this.add(7 * (i3 - this.week()), "day");
              var n3 = this.$locale().yearStart || 1;
              if (11 === this.month() && this.date() > 25) {
                var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
                if (f3.isBefore(s))
                  return 1;
              }
              var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, true);
              return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
            }, f2.weeks = function(e3) {
              return void 0 === e3 && (e3 = null), this.week(e3);
            };
          };
        });
      })(weekOfYear$1);
      var weekOfYearExports = weekOfYear$1.exports;
      const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
      var weekYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            t2.prototype.weekYear = function() {
              var e3 = this.month(), t3 = this.week(), n2 = this.year();
              return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
            };
          };
        });
      })(weekYear$1);
      var weekYearExports = weekYear$1.exports;
      const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
      var advancedFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            var r2 = t2.prototype, n2 = r2.format;
            r2.format = function(e3) {
              var t3 = this, r3 = this.$locale();
              if (!this.isValid())
                return n2.bind(this)(e3);
              var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
                switch (e4) {
                  case "Q":
                    return Math.ceil((t3.$M + 1) / 3);
                  case "Do":
                    return r3.ordinal(t3.$D);
                  case "gggg":
                    return t3.weekYear();
                  case "GGGG":
                    return t3.isoWeekYear();
                  case "wo":
                    return r3.ordinal(t3.week(), "W");
                  case "w":
                  case "ww":
                    return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
                  case "W":
                  case "WW":
                    return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
                  case "k":
                  case "kk":
                    return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
                  case "X":
                    return Math.floor(t3.$d.getTime() / 1e3);
                  case "x":
                    return t3.$d.getTime();
                  case "z":
                    return "[" + t3.offsetName() + "]";
                  case "zzz":
                    return "[" + t3.offsetName("long") + "]";
                  default:
                    return e4;
                }
              });
              return n2.bind(this)(a);
            };
          };
        });
      })(advancedFormat$1);
      var advancedFormatExports = advancedFormat$1.exports;
      const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
      var customParseFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o2 = {}, s = function(e3) {
            return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
          };
          var a = function(e3) {
            return function(t3) {
              this[e3] = +t3;
            };
          }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
            (this.zone || (this.zone = {})).offset = function(e4) {
              if (!e4)
                return 0;
              if ("Z" === e4)
                return 0;
              var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
              return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
            }(e3);
          }], h2 = function(e3) {
            var t3 = o2[e3];
            return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
          }, u2 = function(e3, t3) {
            var n3, r3 = o2.meridiem;
            if (r3) {
              for (var i3 = 1; i3 <= 24; i3 += 1)
                if (e3.indexOf(r3(i3, 0, t3)) > -1) {
                  n3 = i3 > 12;
                  break;
                }
            } else
              n3 = e3 === (t3 ? "pm" : "PM");
            return n3;
          }, d2 = { A: [i2, function(e3) {
            this.afternoon = u2(e3, false);
          }], a: [i2, function(e3) {
            this.afternoon = u2(e3, true);
          }], S: [/\d/, function(e3) {
            this.milliseconds = 100 * +e3;
          }], SS: [n2, function(e3) {
            this.milliseconds = 10 * +e3;
          }], SSS: [/\d{3}/, function(e3) {
            this.milliseconds = +e3;
          }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i2, function(e3) {
            var t3 = o2.ordinal, n3 = e3.match(/\d+/);
            if (this.day = n3[0], t3)
              for (var r3 = 1; r3 <= 31; r3 += 1)
                t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
          }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i2, function(e3) {
            var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
              return e4.slice(0, 3);
            })).indexOf(e3) + 1;
            if (n3 < 1)
              throw new Error();
            this.month = n3 % 12 || n3;
          }], MMMM: [i2, function(e3) {
            var t3 = h2("months").indexOf(e3) + 1;
            if (t3 < 1)
              throw new Error();
            this.month = t3 % 12 || t3;
          }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
            this.year = s(e3);
          }], YYYY: [/\d{4}/, a("year")], Z: f2, ZZ: f2 };
          function c2(n3) {
            var r3, i3;
            r3 = n3, i3 = o2 && o2.formats;
            for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
              var o3 = r4 && r4.toUpperCase();
              return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
                return t4 || n5.slice(1);
              });
            })).match(t2), a2 = s2.length, f3 = 0; f3 < a2; f3 += 1) {
              var h3 = s2[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
              s2[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
            }
            return function(e3) {
              for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
                var i4 = s2[n4];
                if ("string" == typeof i4)
                  r4 += i4.length;
                else {
                  var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
                  f4.call(t3, u4), e3 = e3.replace(u4, "");
                }
              }
              return function(e4) {
                var t4 = e4.afternoon;
                if (void 0 !== t4) {
                  var n5 = e4.hours;
                  t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
                }
              }(t3), t3;
            };
          }
          return function(e3, t3, n3) {
            n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
            var r3 = t3.prototype, i3 = r3.parse;
            r3.parse = function(e4) {
              var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
              this.$u = r4;
              var a2 = s2[1];
              if ("string" == typeof a2) {
                var f3 = true === s2[2], h3 = true === s2[3], u3 = f3 || h3, d3 = s2[2];
                h3 && (d3 = s2[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
                  try {
                    if (["x", "X"].indexOf(t5) > -1)
                      return new Date(("X" === t5 ? 1e3 : 1) * e5);
                    var r5 = c2(t5)(e5), i4 = r5.year, o3 = r5.month, s3 = r5.day, a3 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s3 || (i4 || o3 ? 1 : l3.getDate()), M2 = i4 || l3.getFullYear(), Y = 0;
                    i4 && !o3 || (Y = o3 > 0 ? o3 - 1 : l3.getMonth());
                    var p2 = a3 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
                    return d4 ? new Date(Date.UTC(M2, Y, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M2, Y, m3, p2, v2, D2, g2)) : new Date(M2, Y, m3, p2, v2, D2, g2);
                  } catch (e6) {
                    return /* @__PURE__ */ new Date("");
                  }
                }(t4, a2, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
              } else if (a2 instanceof Array)
                for (var l2 = a2.length, m2 = 1; m2 <= l2; m2 += 1) {
                  s2[1] = a2[m2 - 1];
                  var M = n3.apply(this, s2);
                  if (M.isValid()) {
                    this.$d = M.$d, this.$L = M.$L, this.init();
                    break;
                  }
                  m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
                }
              else
                i3.call(this, e4);
            };
          };
        });
      })(customParseFormat$1);
      var customParseFormatExports = customParseFormat$1.exports;
      const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
      dayjs.extend(customParseFormat);
      dayjs.extend(advancedFormat);
      dayjs.extend(weekday);
      dayjs.extend(localeData);
      dayjs.extend(weekOfYear);
      dayjs.extend(weekYear);
      dayjs.extend(function(o2, c2) {
        var proto = c2.prototype;
        var oldFormat = proto.format;
        proto.format = function f2(formatStr) {
          var str = (formatStr || "").replace("Wo", "wo");
          return oldFormat.bind(this)(str);
        };
      });
      var localeMap = {
        // ar_EG:
        // az_AZ:
        // bg_BG:
        bn_BD: "bn-bd",
        by_BY: "be",
        // ca_ES:
        // cs_CZ:
        // da_DK:
        // de_DE:
        // el_GR:
        en_GB: "en-gb",
        en_US: "en",
        // es_ES:
        // et_EE:
        // fa_IR:
        // fi_FI:
        fr_BE: "fr",
        // todo: dayjs has no fr_BE locale, use fr at present
        fr_CA: "fr-ca",
        // fr_FR:
        // ga_IE:
        // gl_ES:
        // he_IL:
        // hi_IN:
        // hr_HR:
        // hu_HU:
        hy_AM: "hy-am",
        // id_ID:
        // is_IS:
        // it_IT:
        // ja_JP:
        // ka_GE:
        // kk_KZ:
        // km_KH:
        kmr_IQ: "ku",
        // kn_IN:
        // ko_KR:
        // ku_IQ: // previous ku in antd
        // lt_LT:
        // lv_LV:
        // mk_MK:
        // ml_IN:
        // mn_MN:
        // ms_MY:
        // nb_NO:
        // ne_NP:
        nl_BE: "nl-be",
        // nl_NL:
        // pl_PL:
        pt_BR: "pt-br",
        // pt_PT:
        // ro_RO:
        // ru_RU:
        // sk_SK:
        // sl_SI:
        // sr_RS:
        // sv_SE:
        // ta_IN:
        // th_TH:
        // tr_TR:
        // uk_UA:
        // ur_PK:
        // vi_VN:
        zh_CN: "zh-cn",
        zh_HK: "zh-hk",
        zh_TW: "zh-tw"
      };
      var parseLocale = function parseLocale2(locale2) {
        var mapLocale = localeMap[locale2];
        return mapLocale || locale2.split("_")[0];
      };
      var parseNoMatchNotice = function parseNoMatchNotice2() {
        noteOnce(false, "Not match any format. Please help to fire a issue about this.");
      };
      var generateConfig = {
        // get
        getNow: function getNow() {
          return dayjs();
        },
        getFixedDate: function getFixedDate(string2) {
          return dayjs(string2, ["YYYY-M-DD", "YYYY-MM-DD"]);
        },
        getEndDate: function getEndDate(date2) {
          return date2.endOf("month");
        },
        getWeekDay: function getWeekDay(date2) {
          var clone = date2.locale("en");
          return clone.weekday() + clone.localeData().firstDayOfWeek();
        },
        getYear: function getYear(date2) {
          return date2.year();
        },
        getMonth: function getMonth(date2) {
          return date2.month();
        },
        getDate: function getDate(date2) {
          return date2.date();
        },
        getHour: function getHour(date2) {
          return date2.hour();
        },
        getMinute: function getMinute(date2) {
          return date2.minute();
        },
        getSecond: function getSecond(date2) {
          return date2.second();
        },
        // set
        addYear: function addYear(date2, diff) {
          return date2.add(diff, "year");
        },
        addMonth: function addMonth(date2, diff) {
          return date2.add(diff, "month");
        },
        addDate: function addDate(date2, diff) {
          return date2.add(diff, "day");
        },
        setYear: function setYear(date2, year) {
          return date2.year(year);
        },
        setMonth: function setMonth(date2, month) {
          return date2.month(month);
        },
        setDate: function setDate(date2, num) {
          return date2.date(num);
        },
        setHour: function setHour(date2, hour) {
          return date2.hour(hour);
        },
        setMinute: function setMinute(date2, minute) {
          return date2.minute(minute);
        },
        setSecond: function setSecond(date2, second) {
          return date2.second(second);
        },
        // Compare
        isAfter: function isAfter(date1, date2) {
          return date1.isAfter(date2);
        },
        isValidate: function isValidate(date2) {
          return date2.isValid();
        },
        locale: {
          getWeekFirstDay: function getWeekFirstDay(locale2) {
            return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
          },
          getWeekFirstDate: function getWeekFirstDate(locale2, date2) {
            return date2.locale(parseLocale(locale2)).weekday(0);
          },
          getWeek: function getWeek(locale2, date2) {
            return date2.locale(parseLocale(locale2)).week();
          },
          getShortWeekDays: function getShortWeekDays(locale2) {
            return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
          },
          getShortMonths: function getShortMonths(locale2) {
            return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
          },
          format: function format2(locale2, date2, _format) {
            return date2.locale(parseLocale(locale2)).format(_format);
          },
          parse: function parse2(locale2, text, formats) {
            var localeStr = parseLocale(locale2);
            for (var i2 = 0; i2 < formats.length; i2 += 1) {
              var format2 = formats[i2];
              var formatText = text;
              if (format2.includes("wo") || format2.includes("Wo")) {
                var year = formatText.split("-")[0];
                var weekStr = formatText.split("-")[1];
                var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
                for (var j = 0; j <= 52; j += 1) {
                  var nextWeek = firstWeek.add(j, "week");
                  if (nextWeek.format("Wo") === weekStr) {
                    return nextWeek;
                  }
                }
                parseNoMatchNotice();
                return null;
              }
              var date2 = dayjs(formatText, format2, true).locale(localeStr);
              if (date2.isValid()) {
                return date2;
              }
            }
            if (text) {
              parseNoMatchNotice();
            }
            return null;
          }
        }
      };
      var PanelContext = /* @__PURE__ */ React__namespace.createContext({});
      var HIDDEN_STYLE = {
        visibility: "hidden"
      };
      function Header(_ref) {
        var prefixCls = _ref.prefixCls, _ref$prevIcon = _ref.prevIcon, prevIcon = _ref$prevIcon === void 0 ? "‹" : _ref$prevIcon, _ref$nextIcon = _ref.nextIcon, nextIcon = _ref$nextIcon === void 0 ? "›" : _ref$nextIcon, _ref$superPrevIcon = _ref.superPrevIcon, superPrevIcon = _ref$superPrevIcon === void 0 ? "«" : _ref$superPrevIcon, _ref$superNextIcon = _ref.superNextIcon, superNextIcon = _ref$superNextIcon === void 0 ? "»" : _ref$superNextIcon, onSuperPrev = _ref.onSuperPrev, onSuperNext = _ref.onSuperNext, onPrev = _ref.onPrev, onNext = _ref.onNext, children = _ref.children;
        var _React$useContext = React__namespace.useContext(PanelContext), hideNextBtn = _React$useContext.hideNextBtn, hidePrevBtn = _React$useContext.hidePrevBtn;
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: prefixCls
        }, onSuperPrev && /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onSuperPrev,
          tabIndex: -1,
          className: "".concat(prefixCls, "-super-prev-btn"),
          style: hidePrevBtn ? HIDDEN_STYLE : {}
        }, superPrevIcon), onPrev && /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onPrev,
          tabIndex: -1,
          className: "".concat(prefixCls, "-prev-btn"),
          style: hidePrevBtn ? HIDDEN_STYLE : {}
        }, prevIcon), /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-view")
        }, children), onNext && /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onNext,
          tabIndex: -1,
          className: "".concat(prefixCls, "-next-btn"),
          style: hideNextBtn ? HIDDEN_STYLE : {}
        }, nextIcon), onSuperNext && /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onSuperNext,
          tabIndex: -1,
          className: "".concat(prefixCls, "-super-next-btn"),
          style: hideNextBtn ? HIDDEN_STYLE : {}
        }, superNextIcon));
      }
      function DecadeHeader(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecades = props.onPrevDecades, onNextDecades = props.onNextDecades;
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var headerPrefixCls = "".concat(prefixCls, "-header");
        var yearNumber = generateConfig2.getYear(viewDate);
        var startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
        var endYear = startYear + DECADE_DISTANCE_COUNT - 1;
        return /* @__PURE__ */ React__namespace.createElement(Header, _extends$1({}, props, {
          prefixCls: headerPrefixCls,
          onSuperPrev: onPrevDecades,
          onSuperNext: onNextDecades
        }), startYear, "-", endYear);
      }
      function setTime(generateConfig2, date2, hour, minute, second) {
        var nextTime = generateConfig2.setHour(date2, hour);
        nextTime = generateConfig2.setMinute(nextTime, minute);
        nextTime = generateConfig2.setSecond(nextTime, second);
        return nextTime;
      }
      function setDateTime(generateConfig2, date2, defaultDate) {
        if (!defaultDate) {
          return date2;
        }
        var newDate = date2;
        newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
        newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
        newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
        return newDate;
      }
      function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
        var lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
        if (lowerBoundHour < hour) {
          return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
        }
        var lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
        if (lowerBoundMinute < minute) {
          return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
        }
        var lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
        return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
      }
      function getLastDay(generateConfig2, date2) {
        var year = generateConfig2.getYear(date2);
        var month = generateConfig2.getMonth(date2) + 1;
        var endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate("".concat(year, "-").concat(month, "-01")));
        var lastDay = generateConfig2.getDate(endDate);
        var monthShow = month < 10 ? "0".concat(month) : "".concat(month);
        return "".concat(year, "-").concat(monthShow, "-").concat(lastDay);
      }
      function PanelBody(_ref) {
        var prefixCls = _ref.prefixCls, disabledDate = _ref.disabledDate, onSelect = _ref.onSelect, picker = _ref.picker, rowNum = _ref.rowNum, colNum = _ref.colNum, prefixColumn = _ref.prefixColumn, rowClassName = _ref.rowClassName, baseDate = _ref.baseDate, getCellClassName = _ref.getCellClassName, getCellText = _ref.getCellText, getCellNode = _ref.getCellNode, getCellDate = _ref.getCellDate, generateConfig2 = _ref.generateConfig, titleCell = _ref.titleCell, headerCells = _ref.headerCells;
        var _React$useContext = React__namespace.useContext(PanelContext), onDateMouseEnter = _React$useContext.onDateMouseEnter, onDateMouseLeave = _React$useContext.onDateMouseLeave, mode = _React$useContext.mode;
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var rows = [];
        for (var i2 = 0; i2 < rowNum; i2 += 1) {
          var row = [];
          var rowStartDate = void 0;
          var _loop2 = function _loop3() {
            var _objectSpread2$1;
            var offset2 = i2 * colNum + j;
            var currentDate = getCellDate(baseDate, offset2);
            var disabled = getCellDateDisabled({
              cellDate: currentDate,
              mode,
              disabledDate,
              generateConfig: generateConfig2
            });
            if (j === 0) {
              rowStartDate = currentDate;
              if (prefixColumn) {
                row.push(prefixColumn(rowStartDate));
              }
            }
            var title = titleCell && titleCell(currentDate);
            var inner = /* @__PURE__ */ React__namespace.createElement("div", {
              className: "".concat(cellPrefixCls, "-inner")
            }, getCellText(currentDate));
            row.push(/* @__PURE__ */ React__namespace.createElement("td", {
              key: j,
              title,
              className: classNames(cellPrefixCls, _objectSpread2((_objectSpread2$1 = {}, _defineProperty$3(_objectSpread2$1, "".concat(cellPrefixCls, "-disabled"), disabled), _defineProperty$3(_objectSpread2$1, "".concat(cellPrefixCls, "-start"), getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0), _defineProperty$3(_objectSpread2$1, "".concat(cellPrefixCls, "-end"), title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9), _objectSpread2$1), getCellClassName(currentDate))),
              onClick: function onClick() {
                if (!disabled) {
                  onSelect(currentDate);
                }
              },
              onMouseEnter: function onMouseEnter() {
                if (!disabled && onDateMouseEnter) {
                  onDateMouseEnter(currentDate);
                }
              },
              onMouseLeave: function onMouseLeave() {
                if (!disabled && onDateMouseLeave) {
                  onDateMouseLeave(currentDate);
                }
              }
            }, getCellNode ? getCellNode(currentDate, inner) : inner));
          };
          for (var j = 0; j < colNum; j += 1) {
            _loop2();
          }
          rows.push(/* @__PURE__ */ React__namespace.createElement("tr", {
            key: i2,
            className: rowClassName && rowClassName(rowStartDate)
          }, row));
        }
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-body")
        }, /* @__PURE__ */ React__namespace.createElement("table", {
          className: "".concat(prefixCls, "-content")
        }, headerCells && /* @__PURE__ */ React__namespace.createElement("thead", null, /* @__PURE__ */ React__namespace.createElement("tr", null, headerCells)), /* @__PURE__ */ React__namespace.createElement("tbody", null, rows)));
      }
      var DECADE_COL_COUNT = 3;
      var DECADE_ROW_COUNT = 4;
      function DecadeBody(props) {
        var DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
        var prefixCls = props.prefixCls, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender, locale2 = props.locale;
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var yearNumber = generateConfig2.getYear(viewDate);
        var decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
        var startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
        var endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
        var baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
        var getCellClassName = function getCellClassName2(date2) {
          var _ref;
          var startDecadeNumber = generateConfig2.getYear(date2);
          var endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
          return _ref = {}, _defineProperty$3(_ref, "".concat(cellPrefixCls, "-in-view"), startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear), _defineProperty$3(_ref, "".concat(cellPrefixCls, "-selected"), startDecadeNumber === decadeYearNumber), _ref;
        };
        var getCellNode = cellRender ? function(date2, wrapperNode) {
          return cellRender(date2, {
            originNode: wrapperNode,
            today: generateConfig2.getNow(),
            type: "decade",
            locale: locale2
          });
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(PanelBody, _extends$1({}, props, {
          rowNum: DECADE_ROW_COUNT,
          colNum: DECADE_COL_COUNT,
          baseDate: baseDecadeYear,
          getCellNode,
          getCellText: function getCellText(date2) {
            var startDecadeNumber = generateConfig2.getYear(date2);
            return "".concat(startDecadeNumber, "-").concat(startDecadeNumber + DECADE_UNIT_DIFF_DES);
          },
          getCellClassName,
          getCellDate: function getCellDate(date2, offset2) {
            return generateConfig2.addYear(date2, offset2 * DECADE_UNIT_DIFF);
          }
        }));
      }
      var scrollIds = /* @__PURE__ */ new Map();
      function waitElementReady(element, callback) {
        var id;
        function tryOrNextFrame() {
          if (isVisible$1(element)) {
            callback();
          } else {
            id = wrapperRaf(function() {
              tryOrNextFrame();
            });
          }
        }
        tryOrNextFrame();
        return function() {
          wrapperRaf.cancel(id);
        };
      }
      function scrollTo(element, to, duration) {
        if (scrollIds.get(element)) {
          cancelAnimationFrame(scrollIds.get(element));
        }
        if (duration <= 0) {
          scrollIds.set(element, requestAnimationFrame(function() {
            element.scrollTop = to;
          }));
          return;
        }
        var difference = to - element.scrollTop;
        var perTick = difference / duration * 10;
        scrollIds.set(element, requestAnimationFrame(function() {
          element.scrollTop += perTick;
          if (element.scrollTop !== to) {
            scrollTo(element, to, duration - 10);
          }
        }));
      }
      function createKeyDownHandler(event, _ref) {
        var onLeftRight = _ref.onLeftRight, onCtrlLeftRight = _ref.onCtrlLeftRight, onUpDown = _ref.onUpDown, onPageUpDown = _ref.onPageUpDown, onEnter = _ref.onEnter;
        var which = event.which, ctrlKey = event.ctrlKey, metaKey = event.metaKey;
        switch (which) {
          case KeyCode.LEFT:
            if (ctrlKey || metaKey) {
              if (onCtrlLeftRight) {
                onCtrlLeftRight(-1);
                return true;
              }
            } else if (onLeftRight) {
              onLeftRight(-1);
              return true;
            }
            break;
          case KeyCode.RIGHT:
            if (ctrlKey || metaKey) {
              if (onCtrlLeftRight) {
                onCtrlLeftRight(1);
                return true;
              }
            } else if (onLeftRight) {
              onLeftRight(1);
              return true;
            }
            break;
          case KeyCode.UP:
            if (onUpDown) {
              onUpDown(-1);
              return true;
            }
            break;
          case KeyCode.DOWN:
            if (onUpDown) {
              onUpDown(1);
              return true;
            }
            break;
          case KeyCode.PAGE_UP:
            if (onPageUpDown) {
              onPageUpDown(-1);
              return true;
            }
            break;
          case KeyCode.PAGE_DOWN:
            if (onPageUpDown) {
              onPageUpDown(1);
              return true;
            }
            break;
          case KeyCode.ENTER:
            if (onEnter) {
              onEnter();
              return true;
            }
            break;
        }
        return false;
      }
      function getDefaultFormat(format2, picker, showTime, use12Hours) {
        var mergedFormat = format2;
        if (!mergedFormat) {
          switch (picker) {
            case "time":
              mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
              break;
            case "week":
              mergedFormat = "gggg-wo";
              break;
            case "month":
              mergedFormat = "YYYY-MM";
              break;
            case "quarter":
              mergedFormat = "YYYY-[Q]Q";
              break;
            case "year":
              mergedFormat = "YYYY";
              break;
            default:
              mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
          }
        }
        return mergedFormat;
      }
      function getInputSize(picker, format2, generateConfig2) {
        var defaultSize = picker === "time" ? 8 : 10;
        var length2 = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
        return Math.max(defaultSize, length2) + 2;
      }
      var globalClickFunc = null;
      var clickCallbacks = /* @__PURE__ */ new Set();
      function addGlobalMouseDownEvent(callback) {
        if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
          globalClickFunc = function globalClickFunc2(e2) {
            _toConsumableArray(clickCallbacks).forEach(function(queueFunc) {
              queueFunc(e2);
            });
          };
          window.addEventListener("mousedown", globalClickFunc);
        }
        clickCallbacks.add(callback);
        return function() {
          clickCallbacks.delete(callback);
          if (clickCallbacks.size === 0) {
            window.removeEventListener("mousedown", globalClickFunc);
            globalClickFunc = null;
          }
        };
      }
      function getTargetFromEvent(e2) {
        var target = e2.target;
        if (e2.composed && target.shadowRoot) {
          var _e$composedPath;
          return ((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath.call(e2)[0]) || target;
        }
        return target;
      }
      var getYearNextMode = function getYearNextMode2(next2) {
        if (next2 === "month" || next2 === "date") {
          return "year";
        }
        return next2;
      };
      var getMonthNextMode = function getMonthNextMode2(next2) {
        if (next2 === "date") {
          return "month";
        }
        return next2;
      };
      var getQuarterNextMode = function getQuarterNextMode2(next2) {
        if (next2 === "month" || next2 === "date") {
          return "quarter";
        }
        return next2;
      };
      var getWeekNextMode = function getWeekNextMode2(next2) {
        if (next2 === "date") {
          return "week";
        }
        return next2;
      };
      var PickerModeMap = {
        year: getYearNextMode,
        month: getMonthNextMode,
        quarter: getQuarterNextMode,
        week: getWeekNextMode,
        time: null,
        date: null
      };
      function elementsContains(elements, target) {
        return elements.some(function(ele) {
          return ele && ele.contains(target);
        });
      }
      var DECADE_UNIT_DIFF = 10;
      var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
      function DecadePanel(props) {
        var prefixCls = props.prefixCls, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, viewDate = props.viewDate, operationRef = props.operationRef, onSelect = props.onSelect, onPanelChange = props.onPanelChange;
        var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, {
              onLeftRight: function onLeftRight(diff) {
                onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF), "key");
              },
              onCtrlLeftRight: function onCtrlLeftRight(diff) {
                onSelect(generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT), "key");
              },
              onUpDown: function onUpDown(diff) {
                onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
              },
              onEnter: function onEnter() {
                onPanelChange("year", viewDate);
              }
            });
          }
        };
        var onDecadesChange = function onDecadesChange2(diff) {
          var newDate = generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        var onInternalSelect = function onInternalSelect2(date2) {
          onSelect(date2, "mouse");
          onPanelChange("year", date2);
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: panelPrefixCls
        }, /* @__PURE__ */ React__namespace.createElement(DecadeHeader, _extends$1({}, props, {
          prefixCls,
          onPrevDecades: function onPrevDecades() {
            onDecadesChange(-1);
          },
          onNextDecades: function onNextDecades() {
            onDecadesChange(1);
          }
        })), /* @__PURE__ */ React__namespace.createElement(DecadeBody, _extends$1({}, props, {
          prefixCls,
          onSelect: onInternalSelect
        })));
      }
      var WEEK_DAY_COUNT = 7;
      function isNullEqual(value1, value2) {
        if (!value1 && !value2) {
          return true;
        }
        if (!value1 || !value2) {
          return false;
        }
        return void 0;
      }
      function isSameDecade(generateConfig2, decade1, decade2) {
        var equal = isNullEqual(decade1, decade2);
        if (typeof equal === "boolean") {
          return equal;
        }
        var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
        var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
        return num1 === num2;
      }
      function isSameYear(generateConfig2, year1, year2) {
        var equal = isNullEqual(year1, year2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
      }
      function getQuarter(generateConfig2, date2) {
        var quota = Math.floor(generateConfig2.getMonth(date2) / 3);
        return quota + 1;
      }
      function isSameQuarter(generateConfig2, quarter1, quarter2) {
        var equal = isNullEqual(quarter1, quarter2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
      }
      function isSameMonth(generateConfig2, month1, month2) {
        var equal = isNullEqual(month1, month2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
      }
      function isSameDate(generateConfig2, date1, date2) {
        var equal = isNullEqual(date1, date2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return generateConfig2.getYear(date1) === generateConfig2.getYear(date2) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
      }
      function isSameTime(generateConfig2, time1, time2) {
        var equal = isNullEqual(time1, time2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
      }
      function isSameWeek(generateConfig2, locale2, date1, date2) {
        var equal = isNullEqual(date1, date2);
        if (typeof equal === "boolean") {
          return equal;
        }
        return generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date2);
      }
      function isEqual(generateConfig2, value1, value2) {
        return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
      }
      function isInRange(generateConfig2, startDate, endDate, current) {
        if (!startDate || !endDate || !current) {
          return false;
        }
        return !isSameDate(generateConfig2, startDate, current) && !isSameDate(generateConfig2, endDate, current) && generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
      }
      function getWeekStartDate(locale2, generateConfig2, value) {
        var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
        var monthStartDate = generateConfig2.setDate(value, 1);
        var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
        var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
        if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
          alignStartDate = generateConfig2.addDate(alignStartDate, -7);
        }
        return alignStartDate;
      }
      function getClosingViewDate(viewDate, picker, generateConfig2) {
        var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        switch (picker) {
          case "year":
            return generateConfig2.addYear(viewDate, offset2 * 10);
          case "quarter":
          case "month":
            return generateConfig2.addYear(viewDate, offset2);
          default:
            return generateConfig2.addMonth(viewDate, offset2);
        }
      }
      function formatValue(value, _ref) {
        var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
        return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
      }
      function parseValue(value, _ref2) {
        var generateConfig2 = _ref2.generateConfig, locale2 = _ref2.locale, formatList = _ref2.formatList;
        if (!value || typeof formatList[0] === "function") {
          return null;
        }
        return generateConfig2.locale.parse(locale2.locale, value, formatList);
      }
      function getCellDateDisabled(_ref3) {
        var cellDate = _ref3.cellDate, mode = _ref3.mode, disabledDate = _ref3.disabledDate, generateConfig2 = _ref3.generateConfig;
        if (!disabledDate)
          return false;
        var getDisabledFromRange = function getDisabledFromRange2(currentMode, start, end) {
          var current = start;
          while (current <= end) {
            var _date = void 0;
            switch (currentMode) {
              case "date": {
                _date = generateConfig2.setDate(cellDate, current);
                if (!disabledDate(_date)) {
                  return false;
                }
                break;
              }
              case "month": {
                _date = generateConfig2.setMonth(cellDate, current);
                if (!getCellDateDisabled({
                  cellDate: _date,
                  mode: "month",
                  generateConfig: generateConfig2,
                  disabledDate
                })) {
                  return false;
                }
                break;
              }
              case "year": {
                _date = generateConfig2.setYear(cellDate, current);
                if (!getCellDateDisabled({
                  cellDate: _date,
                  mode: "year",
                  generateConfig: generateConfig2,
                  disabledDate
                })) {
                  return false;
                }
                break;
              }
            }
            current += 1;
          }
          return true;
        };
        switch (mode) {
          case "date":
          case "week": {
            return disabledDate(cellDate);
          }
          case "month": {
            var startDate = 1;
            var endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
            return getDisabledFromRange("date", startDate, endDate);
          }
          case "quarter": {
            var startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
            var endMonth = startMonth + 2;
            return getDisabledFromRange("month", startMonth, endMonth);
          }
          case "year": {
            return getDisabledFromRange("month", 0, 11);
          }
          case "decade": {
            var year = generateConfig2.getYear(cellDate);
            var startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
            var endYear = startYear + DECADE_UNIT_DIFF - 1;
            return getDisabledFromRange("year", startYear, endYear);
          }
        }
      }
      function useValueTexts(value, _ref) {
        var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
        return useMemo(function() {
          if (!value) {
            return [[""], ""];
          }
          var firstValueText = "";
          var fullValueTexts = [];
          for (var i2 = 0; i2 < formatList.length; i2 += 1) {
            var format2 = formatList[i2];
            var formatStr = formatValue(value, {
              generateConfig: generateConfig2,
              locale: locale2,
              format: format2
            });
            fullValueTexts.push(formatStr);
            if (i2 === 0) {
              firstValueText = formatStr;
            }
          }
          return [fullValueTexts, firstValueText];
        }, [value, formatList], function(prev2, next2) {
          return (
            // Not Same Date
            !isEqual(generateConfig2, prev2[0], next2[0]) || // Not Same format
            !isEqual$1(prev2[1], next2[1], true)
          );
        });
      }
      function useHoverValue(valueText, _ref) {
        var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
        var _useState = React.useState(null), _useState2 = _slicedToArray$5(_useState, 2), value = _useState2[0], internalSetValue = _useState2[1];
        var raf2 = React.useRef(null);
        function setValue(val) {
          var immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          cancelAnimationFrame(raf2.current);
          if (immediately) {
            internalSetValue(val);
            return;
          }
          raf2.current = requestAnimationFrame(function() {
            internalSetValue(val);
          });
        }
        var _useValueTexts = useValueTexts(value, {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        }), _useValueTexts2 = _slicedToArray$5(_useValueTexts, 2), firstText = _useValueTexts2[1];
        function onEnter(date2) {
          setValue(date2);
        }
        function onLeave() {
          var immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          setValue(null, immediately);
        }
        React.useEffect(function() {
          onLeave(true);
        }, [valueText]);
        React.useEffect(function() {
          return function() {
            return cancelAnimationFrame(raf2.current);
          };
        }, []);
        return [firstText, onEnter, onLeave];
      }
      function usePickerInput(_ref) {
        var open = _ref.open, value = _ref.value, isClickOutside = _ref.isClickOutside, triggerOpen = _ref.triggerOpen, forwardKeyDown = _ref.forwardKeyDown, _onKeyDown = _ref.onKeyDown, blurToCancel = _ref.blurToCancel, onSubmit = _ref.onSubmit, onCancel = _ref.onCancel, _onFocus = _ref.onFocus, _onBlur = _ref.onBlur, changeOnBlur = _ref.changeOnBlur;
        var _useState = React.useState(false), _useState2 = _slicedToArray$5(_useState, 2), typing = _useState2[0], setTyping = _useState2[1];
        var _useState3 = React.useState(false), _useState4 = _slicedToArray$5(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
        var preventBlurRef = React.useRef(false);
        var valueChangedRef = React.useRef(false);
        var preventDefaultRef = React.useRef(false);
        var inputProps = {
          onMouseDown: function onMouseDown() {
            setTyping(true);
            triggerOpen(true);
          },
          onKeyDown: function onKeyDown(e2) {
            var preventDefault = function preventDefault2() {
              preventDefaultRef.current = true;
            };
            _onKeyDown(e2, preventDefault);
            if (preventDefaultRef.current)
              return;
            switch (e2.which) {
              case KeyCode.ENTER: {
                if (!open) {
                  triggerOpen(true);
                } else if (onSubmit() !== false) {
                  setTyping(true);
                }
                e2.preventDefault();
                return;
              }
              case KeyCode.TAB: {
                if (typing && open && !e2.shiftKey) {
                  setTyping(false);
                  e2.preventDefault();
                } else if (!typing && open) {
                  if (!forwardKeyDown(e2) && e2.shiftKey) {
                    setTyping(true);
                    e2.preventDefault();
                  }
                }
                return;
              }
              case KeyCode.ESC: {
                setTyping(true);
                onCancel();
                return;
              }
            }
            if (!open && ![KeyCode.SHIFT].includes(e2.which)) {
              triggerOpen(true);
            } else if (!typing) {
              forwardKeyDown(e2);
            }
          },
          onFocus: function onFocus(e2) {
            setTyping(true);
            setFocused(true);
            if (_onFocus) {
              _onFocus(e2);
            }
          },
          onBlur: function onBlur(e2) {
            if (preventBlurRef.current || !isClickOutside(document.activeElement)) {
              preventBlurRef.current = false;
              return;
            }
            if (blurToCancel) {
              setTimeout(function() {
                var _document = document, activeElement = _document.activeElement;
                while (activeElement && activeElement.shadowRoot) {
                  activeElement = activeElement.shadowRoot.activeElement;
                }
                if (isClickOutside(activeElement)) {
                  onCancel();
                }
              }, 0);
            } else if (open) {
              triggerOpen(false);
              if (valueChangedRef.current) {
                onSubmit();
              }
            }
            setFocused(false);
            _onBlur === null || _onBlur === void 0 ? void 0 : _onBlur(e2);
          }
        };
        React.useEffect(function() {
          valueChangedRef.current = false;
        }, [open]);
        React.useEffect(function() {
          valueChangedRef.current = true;
        }, [value]);
        React.useEffect(function() {
          return addGlobalMouseDownEvent(function(e2) {
            var target = getTargetFromEvent(e2);
            var clickedOutside = isClickOutside(target);
            if (open) {
              if (!clickedOutside) {
                preventBlurRef.current = true;
                wrapperRaf(function() {
                  preventBlurRef.current = false;
                });
              } else if (!changeOnBlur && (!focused || clickedOutside)) {
                triggerOpen(false);
              }
            }
          });
        });
        return [inputProps, {
          focused,
          typing
        }];
      }
      function usePresets(presets, legacyRanges) {
        return React__namespace.useMemo(function() {
          if (presets) {
            return presets;
          }
          if (legacyRanges) {
            warningOnce(false, "`ranges` is deprecated. Please use `presets` instead.");
            var rangeLabels = Object.keys(legacyRanges);
            return rangeLabels.map(function(label) {
              var range2 = legacyRanges[label];
              var newValues = typeof range2 === "function" ? range2() : range2;
              return {
                label,
                value: newValues
              };
            });
          }
          return [];
        }, [presets, legacyRanges]);
      }
      function useTextValueMapping(_ref) {
        var valueTexts = _ref.valueTexts, onTextChange = _ref.onTextChange;
        var _React$useState = React__namespace.useState(""), _React$useState2 = _slicedToArray$5(_React$useState, 2), text = _React$useState2[0], setInnerText = _React$useState2[1];
        var valueTextsRef = React__namespace.useRef([]);
        valueTextsRef.current = valueTexts;
        function triggerTextChange(value) {
          setInnerText(value);
          onTextChange(value);
        }
        function resetText() {
          setInnerText(valueTextsRef.current[0]);
        }
        useLayoutEffect(function() {
          if (valueTexts.every(function(valText) {
            return valText !== text;
          })) {
            resetText();
          }
        }, [valueTexts.join("||")]);
        return [text, triggerTextChange, resetText];
      }
      function leftPad(str, length2) {
        var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
        var current = String(str);
        while (current.length < length2) {
          current = "".concat(fill).concat(str);
        }
        return current;
      }
      var tuple = function tuple2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return args;
      };
      function toArray$2(val) {
        if (val === null || val === void 0) {
          return [];
        }
        return Array.isArray(val) ? val : [val];
      }
      function getValue(values, index2) {
        return values ? values[index2] : null;
      }
      function updateValues(values, value, index2) {
        var newValues = [getValue(values, 0), getValue(values, 1)];
        newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
        if (!newValues[0] && !newValues[1]) {
          return null;
        }
        return newValues;
      }
      function useCellClassName(_ref) {
        var cellPrefixCls = _ref.cellPrefixCls, generateConfig2 = _ref.generateConfig, rangedValue = _ref.rangedValue, hoverRangedValue = _ref.hoverRangedValue, isInView = _ref.isInView, isSameCell = _ref.isSameCell, offsetCell = _ref.offsetCell, today = _ref.today, value = _ref.value;
        function getClassName(currentDate) {
          var _ref2;
          var prevDate = offsetCell(currentDate, -1);
          var nextDate = offsetCell(currentDate, 1);
          var rangeStart = getValue(rangedValue, 0);
          var rangeEnd = getValue(rangedValue, 1);
          var hoverStart = getValue(hoverRangedValue, 0);
          var hoverEnd = getValue(hoverRangedValue, 1);
          var isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
          function isRangeStart(date2) {
            return isSameCell(rangeStart, date2);
          }
          function isRangeEnd(date2) {
            return isSameCell(rangeEnd, date2);
          }
          var isHoverStart = isSameCell(hoverStart, currentDate);
          var isHoverEnd = isSameCell(hoverEnd, currentDate);
          var isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
          var isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
          return _ref2 = {}, _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-in-view"), isInView(currentDate)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-in-range"), isInRange(generateConfig2, rangeStart, rangeEnd, currentDate)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-start"), isRangeStart(currentDate)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-end"), isRangeEnd(currentDate)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-start-single"), isRangeStart(currentDate) && !rangeEnd), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-end-single"), isRangeEnd(currentDate) && !rangeStart), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-start-near-hover"), isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate))), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-end-near-hover"), isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate))), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover"), isRangeHovered), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-start"), isHoverStart), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-end"), isHoverEnd), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start"), isHoverEdgeStart), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end"), isHoverEdgeEnd), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start-near-range"), isHoverEdgeStart && isSameCell(prevDate, rangeEnd)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end-near-range"), isHoverEdgeEnd && isSameCell(nextDate, rangeStart)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-today"), isSameCell(today, currentDate)), _defineProperty$3(_ref2, "".concat(cellPrefixCls, "-selected"), isSameCell(value, currentDate)), _ref2;
        }
        return getClassName;
      }
      var RangeContext = /* @__PURE__ */ React__namespace.createContext({});
      function DateBody(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, prefixColumn = props.prefixColumn, locale2 = props.locale, rowCount = props.rowCount, viewDate = props.viewDate, value = props.value, cellRender = props.cellRender, isSameCell = props.isSameCell;
        var _React$useContext = React__namespace.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
        var today = generateConfig2.getNow();
        var headerCells = [];
        var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
        if (prefixColumn) {
          headerCells.push(/* @__PURE__ */ React__namespace.createElement("th", {
            key: "empty",
            "aria-label": "empty cell"
          }));
        }
        for (var i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
          headerCells.push(/* @__PURE__ */ React__namespace.createElement("th", {
            key: i2
          }, weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]));
        }
        var getCellClassName = useCellClassName({
          cellPrefixCls,
          today,
          value,
          generateConfig: generateConfig2,
          rangedValue: prefixColumn ? null : rangedValue,
          hoverRangedValue: prefixColumn ? null : hoverRangedValue,
          isSameCell: isSameCell || function(current, target) {
            return isSameDate(generateConfig2, current, target);
          },
          isInView: function isInView(date2) {
            return isSameMonth(generateConfig2, date2, viewDate);
          },
          offsetCell: function offsetCell(date2, offset2) {
            return generateConfig2.addDate(date2, offset2);
          }
        });
        var getCellNode = cellRender ? function(date2, wrapperNode) {
          return cellRender(date2, {
            originNode: wrapperNode,
            today,
            type: "date",
            locale: locale2
          });
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(PanelBody, _extends$1({}, props, {
          rowNum: rowCount,
          colNum: WEEK_DAY_COUNT,
          baseDate,
          getCellNode,
          getCellText: generateConfig2.getDate,
          getCellClassName,
          getCellDate: generateConfig2.addDate,
          titleCell: function titleCell(date2) {
            return formatValue(date2, {
              locale: locale2,
              format: "YYYY-MM-DD",
              generateConfig: generateConfig2
            });
          },
          headerCells
        }));
      }
      function DateHeader(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextMonth = props.onNextMonth, onPrevMonth = props.onPrevMonth, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick, onMonthClick = props.onMonthClick;
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var headerPrefixCls = "".concat(prefixCls, "-header");
        var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
        var month = generateConfig2.getMonth(viewDate);
        var yearNode = /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          key: "year",
          onClick: onYearClick,
          tabIndex: -1,
          className: "".concat(prefixCls, "-year-btn")
        }, formatValue(viewDate, {
          locale: locale2,
          format: locale2.yearFormat,
          generateConfig: generateConfig2
        }));
        var monthNode = /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          key: "month",
          onClick: onMonthClick,
          tabIndex: -1,
          className: "".concat(prefixCls, "-month-btn")
        }, locale2.monthFormat ? formatValue(viewDate, {
          locale: locale2,
          format: locale2.monthFormat,
          generateConfig: generateConfig2
        }) : monthsLocale[month]);
        var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
        return /* @__PURE__ */ React__namespace.createElement(Header, _extends$1({}, props, {
          prefixCls: headerPrefixCls,
          onSuperPrev: onPrevYear,
          onPrev: onPrevMonth,
          onNext: onNextMonth,
          onSuperNext: onNextYear
        }), monthYearNodes);
      }
      var DATE_ROW_COUNT = 6;
      function DatePanel(props) {
        var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, keyboardConfig = props.keyboardConfig, active = props.active, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onViewDateChange = props.onViewDateChange, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
        var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, _objectSpread2({
              onLeftRight: function onLeftRight(diff) {
                _onSelect(generateConfig2.addDate(value || viewDate, diff), "key");
              },
              onCtrlLeftRight: function onCtrlLeftRight(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
              },
              onUpDown: function onUpDown(diff) {
                _onSelect(generateConfig2.addDate(value || viewDate, diff * WEEK_DAY_COUNT), "key");
              },
              onPageUpDown: function onPageUpDown(diff) {
                _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
              }
            }, keyboardConfig));
          }
        };
        var onYearChange = function onYearChange2(diff) {
          var newDate = generateConfig2.addYear(viewDate, diff);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        var onMonthChange = function onMonthChange2(diff) {
          var newDate = generateConfig2.addMonth(viewDate, diff);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames(panelPrefixCls, _defineProperty$3({}, "".concat(panelPrefixCls, "-active"), active))
        }, /* @__PURE__ */ React__namespace.createElement(DateHeader, _extends$1({}, props, {
          prefixCls,
          value,
          viewDate,
          onPrevYear: function onPrevYear() {
            onYearChange(-1);
          },
          onNextYear: function onNextYear() {
            onYearChange(1);
          },
          onPrevMonth: function onPrevMonth() {
            onMonthChange(-1);
          },
          onNextMonth: function onNextMonth() {
            onMonthChange(1);
          },
          onMonthClick: function onMonthClick() {
            onPanelChange("month", viewDate);
          },
          onYearClick: function onYearClick() {
            onPanelChange("year", viewDate);
          }
        })), /* @__PURE__ */ React__namespace.createElement(DateBody, _extends$1({}, props, {
          onSelect: function onSelect(date2) {
            return _onSelect(date2, "mouse");
          },
          prefixCls,
          value,
          viewDate,
          rowCount: DATE_ROW_COUNT
        })));
      }
      function TimeHeader(props) {
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, format2 = props.format;
        var headerPrefixCls = "".concat(prefixCls, "-header");
        return /* @__PURE__ */ React__namespace.createElement(Header, {
          prefixCls: headerPrefixCls
        }, value ? formatValue(value, {
          locale: locale2,
          format: format2,
          generateConfig: generateConfig2
        }) : " ");
      }
      function useTimeSelection(_ref) {
        var value = _ref.value, generateConfig2 = _ref.generateConfig, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, minutes = _ref.minutes, seconds = _ref.seconds, use12Hours = _ref.use12Hours;
        var setTime$1 = function setTime$12(isNewPM, newHour, newMinute, newSecond) {
          var newDate = value || generateConfig2.getNow();
          var mergedHour = Math.max(0, newHour);
          var mergedMinute = Math.max(0, newMinute);
          var mergedSecond = Math.max(0, newSecond);
          var newDisabledMinutes = disabledMinutes && disabledMinutes(mergedHour);
          if (newDisabledMinutes !== null && newDisabledMinutes !== void 0 && newDisabledMinutes.includes(mergedMinute)) {
            var availableMinute = minutes.find(function(i2) {
              return !newDisabledMinutes.includes(i2.value);
            });
            if (availableMinute) {
              mergedMinute = availableMinute.value;
            } else {
              return null;
            }
          }
          var newDisabledSeconds = disabledSeconds && disabledSeconds(mergedHour, mergedMinute);
          if (newDisabledSeconds !== null && newDisabledSeconds !== void 0 && newDisabledSeconds.includes(mergedSecond)) {
            var availableSecond = seconds.find(function(i2) {
              return !newDisabledSeconds.includes(i2.value);
            });
            if (availableSecond) {
              mergedSecond = availableSecond.value;
            } else {
              return null;
            }
          }
          newDate = setTime(generateConfig2, newDate, !use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
          return newDate;
        };
        return setTime$1;
      }
      function TimeUnitColumn(props) {
        var prefixCls = props.prefixCls, units = props.units, onSelect = props.onSelect, value = props.value, active = props.active, hideDisabledOptions = props.hideDisabledOptions, info = props.info, type2 = props.type;
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var _React$useContext = React__namespace.useContext(PanelContext), open = _React$useContext.open;
        var ulRef = React.useRef(null);
        var liRefs = React.useRef(/* @__PURE__ */ new Map());
        var scrollRef = React.useRef();
        React.useLayoutEffect(function() {
          var li = liRefs.current.get(value);
          if (li && open !== false) {
            scrollTo(ulRef.current, li.offsetTop, 120);
          }
        }, [value]);
        React.useLayoutEffect(function() {
          if (open) {
            var li = liRefs.current.get(value);
            if (li) {
              scrollRef.current = waitElementReady(li, function() {
                scrollTo(ulRef.current, li.offsetTop, 0);
              });
            }
          }
          return function() {
            var _scrollRef$current;
            (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.call(scrollRef);
          };
        }, [open]);
        return /* @__PURE__ */ React__namespace.createElement("ul", {
          className: classNames("".concat(prefixCls, "-column"), _defineProperty$3({}, "".concat(prefixCls, "-column-active"), active)),
          ref: ulRef,
          style: {
            position: "relative"
          }
        }, units.map(function(unit) {
          var _classNames2;
          if (hideDisabledOptions && unit.disabled) {
            return null;
          }
          return /* @__PURE__ */ React__namespace.createElement("li", {
            key: unit.value,
            ref: function ref(element) {
              liRefs.current.set(unit.value, element);
            },
            className: classNames(cellPrefixCls, (_classNames2 = {}, _defineProperty$3(_classNames2, "".concat(cellPrefixCls, "-disabled"), unit.disabled), _defineProperty$3(_classNames2, "".concat(cellPrefixCls, "-selected"), value === unit.value), _classNames2)),
            onClick: function onClick() {
              if (unit.disabled) {
                return;
              }
              onSelect(unit.value);
            }
          }, info.cellRender ? info.cellRender(unit.value, {
            today: info.today,
            locale: info.locale,
            originNode: /* @__PURE__ */ React__namespace.createElement("div", {
              className: "".concat(cellPrefixCls, "-inner")
            }, unit.label),
            type: "time",
            subType: type2
          }) : /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, unit.label));
        }));
      }
      function shouldUnitsUpdate(prevUnits, nextUnits) {
        if (prevUnits.length !== nextUnits.length)
          return true;
        for (var i2 = 0; i2 < prevUnits.length; i2 += 1) {
          if (prevUnits[i2].disabled !== nextUnits[i2].disabled)
            return true;
        }
        return false;
      }
      function generateUnits(start, end, step, disabledUnits) {
        var units = [];
        var integerStep = step >= 1 ? step | 0 : 1;
        for (var i2 = start; i2 <= end; i2 += integerStep) {
          units.push({
            label: leftPad(i2, 2),
            value: i2,
            disabled: (disabledUnits || []).includes(i2)
          });
        }
        return units;
      }
      function TimeBody(props) {
        var generateConfig2 = props.generateConfig, prefixCls = props.prefixCls, operationRef = props.operationRef, activeColumnIndex = props.activeColumnIndex, value = props.value, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, use12Hours = props.use12Hours, _props$hourStep = props.hourStep, hourStep = _props$hourStep === void 0 ? 1 : _props$hourStep, _props$minuteStep = props.minuteStep, minuteStep = _props$minuteStep === void 0 ? 1 : _props$minuteStep, _props$secondStep = props.secondStep, secondStep = _props$secondStep === void 0 ? 1 : _props$secondStep, disabledHours = props.disabledHours, disabledMinutes = props.disabledMinutes, disabledSeconds = props.disabledSeconds, disabledTime = props.disabledTime, hideDisabledOptions = props.hideDisabledOptions, onSelect = props.onSelect, cellRender = props.cellRender, locale2 = props.locale;
        var columns = [];
        var contentPrefixCls = "".concat(prefixCls, "-content");
        var columnPrefixCls = "".concat(prefixCls, "-time-panel");
        var isPM;
        var originHour = value ? generateConfig2.getHour(value) : -1;
        var hour = originHour;
        var minute = value ? generateConfig2.getMinute(value) : -1;
        var second = value ? generateConfig2.getSecond(value) : -1;
        var now = generateConfig2.getNow();
        var _React$useMemo = React__namespace.useMemo(function() {
          if (disabledTime) {
            var disabledConfig = disabledTime(now);
            return [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
          }
          return [disabledHours, disabledMinutes, disabledSeconds];
        }, [disabledHours, disabledMinutes, disabledSeconds, disabledTime, now]), _React$useMemo2 = _slicedToArray$5(_React$useMemo, 3), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2];
        var rawHours = generateUnits(0, 23, hourStep, mergedDisabledHours && mergedDisabledHours());
        var memorizedRawHours = useMemo(function() {
          return rawHours;
        }, rawHours, shouldUnitsUpdate);
        if (use12Hours) {
          isPM = hour >= 12;
          hour %= 12;
        }
        var _React$useMemo3 = React__namespace.useMemo(function() {
          if (!use12Hours) {
            return [false, false];
          }
          var AMPMDisabled = [true, true];
          memorizedRawHours.forEach(function(_ref) {
            var disabled = _ref.disabled, hourValue = _ref.value;
            if (disabled)
              return;
            if (hourValue >= 12) {
              AMPMDisabled[1] = false;
            } else {
              AMPMDisabled[0] = false;
            }
          });
          return AMPMDisabled;
        }, [use12Hours, memorizedRawHours]), _React$useMemo4 = _slicedToArray$5(_React$useMemo3, 2), AMDisabled = _React$useMemo4[0], PMDisabled = _React$useMemo4[1];
        var hours = React__namespace.useMemo(function() {
          if (!use12Hours)
            return memorizedRawHours;
          return memorizedRawHours.filter(isPM ? function(hourMeta) {
            return hourMeta.value >= 12;
          } : function(hourMeta) {
            return hourMeta.value < 12;
          }).map(function(hourMeta) {
            var hourValue = hourMeta.value % 12;
            var hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
            return _objectSpread2(_objectSpread2({}, hourMeta), {}, {
              label: hourLabel,
              value: hourValue
            });
          });
        }, [use12Hours, isPM, memorizedRawHours]);
        var minutes = generateUnits(0, 59, minuteStep, mergedDisabledMinutes && mergedDisabledMinutes(originHour));
        var seconds = generateUnits(0, 59, secondStep, mergedDisabledSeconds && mergedDisabledSeconds(originHour, minute));
        var setTime2 = useTimeSelection({
          value,
          generateConfig: generateConfig2,
          disabledMinutes: mergedDisabledMinutes,
          disabledSeconds: mergedDisabledSeconds,
          minutes,
          seconds,
          use12Hours
        });
        operationRef.current = {
          onUpDown: function onUpDown(diff) {
            var column2 = columns[activeColumnIndex];
            if (column2) {
              var valueIndex = column2.units.findIndex(function(unit) {
                return unit.value === column2.value;
              });
              var unitLen = column2.units.length;
              for (var i2 = 1; i2 < unitLen; i2 += 1) {
                var nextUnit = column2.units[(valueIndex + diff * i2 + unitLen) % unitLen];
                if (nextUnit.disabled !== true) {
                  column2.onSelect(nextUnit.value);
                  break;
                }
              }
            }
          }
        };
        function addColumnNode(condition, node2, columnValue, units, onColumnSelect) {
          if (condition !== false) {
            columns.push({
              node: /* @__PURE__ */ React__namespace.cloneElement(node2, {
                prefixCls: columnPrefixCls,
                value: columnValue,
                active: activeColumnIndex === columns.length,
                onSelect: onColumnSelect,
                units,
                hideDisabledOptions
              }),
              onSelect: onColumnSelect,
              value: columnValue,
              units
            });
          }
        }
        addColumnNode(showHour, /* @__PURE__ */ React__namespace.createElement(TimeUnitColumn, {
          key: "hour",
          type: "hour",
          info: {
            today: now,
            locale: locale2,
            cellRender
          }
        }), hour, hours, function(num) {
          onSelect(setTime2(isPM, num, minute, second), "mouse");
        });
        addColumnNode(showMinute, /* @__PURE__ */ React__namespace.createElement(TimeUnitColumn, {
          key: "minute",
          type: "minute",
          info: {
            today: now,
            locale: locale2,
            cellRender
          }
        }), minute, minutes, function(num) {
          onSelect(setTime2(isPM, hour, num, second), "mouse");
        });
        addColumnNode(showSecond, /* @__PURE__ */ React__namespace.createElement(TimeUnitColumn, {
          key: "second",
          type: "second",
          info: {
            today: now,
            locale: locale2,
            cellRender
          }
        }), second, seconds, function(num) {
          onSelect(setTime2(isPM, hour, minute, num), "mouse");
        });
        var PMIndex = -1;
        if (typeof isPM === "boolean") {
          PMIndex = isPM ? 1 : 0;
        }
        addColumnNode(use12Hours === true, /* @__PURE__ */ React__namespace.createElement(TimeUnitColumn, {
          key: "meridiem",
          type: "meridiem",
          info: {
            today: now,
            locale: locale2,
            cellRender
          }
        }), PMIndex, [{
          label: "AM",
          value: 0,
          disabled: AMDisabled
        }, {
          label: "PM",
          value: 1,
          disabled: PMDisabled
        }], function(num) {
          onSelect(setTime2(!!num, hour, minute, second), "mouse");
        });
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: contentPrefixCls
        }, columns.map(function(_ref2) {
          var node2 = _ref2.node;
          return node2;
        }));
      }
      var countBoolean = function countBoolean2(boolList) {
        return boolList.filter(function(bool) {
          return bool !== false;
        }).length;
      };
      function TimePanel(props) {
        var generateConfig2 = props.generateConfig, _props$format = props.format, format2 = _props$format === void 0 ? "HH:mm:ss" : _props$format, prefixCls = props.prefixCls, active = props.active, operationRef = props.operationRef, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, _props$use12Hours = props.use12Hours, use12Hours = _props$use12Hours === void 0 ? false : _props$use12Hours, onSelect = props.onSelect, value = props.value;
        var panelPrefixCls = "".concat(prefixCls, "-time-panel");
        var bodyOperationRef = React__namespace.useRef();
        var _React$useState = React__namespace.useState(-1), _React$useState2 = _slicedToArray$5(_React$useState, 2), activeColumnIndex = _React$useState2[0], setActiveColumnIndex = _React$useState2[1];
        var columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, {
              onLeftRight: function onLeftRight(diff) {
                setActiveColumnIndex((activeColumnIndex + diff + columnsCount) % columnsCount);
              },
              onUpDown: function onUpDown(diff) {
                if (activeColumnIndex === -1) {
                  setActiveColumnIndex(0);
                } else if (bodyOperationRef.current) {
                  bodyOperationRef.current.onUpDown(diff);
                }
              },
              onEnter: function onEnter() {
                onSelect(value || generateConfig2.getNow(), "key");
                setActiveColumnIndex(-1);
              }
            });
          },
          onBlur: function onBlur() {
            setActiveColumnIndex(-1);
          }
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames(panelPrefixCls, _defineProperty$3({}, "".concat(panelPrefixCls, "-active"), active))
        }, /* @__PURE__ */ React__namespace.createElement(TimeHeader, _extends$1({}, props, {
          format: format2,
          prefixCls
        })), /* @__PURE__ */ React__namespace.createElement(TimeBody, _extends$1({}, props, {
          prefixCls,
          activeColumnIndex,
          operationRef: bodyOperationRef
        })));
      }
      var ACTIVE_PANEL = tuple("date", "time");
      function DatetimePanel(props) {
        var prefixCls = props.prefixCls, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, defaultValue = props.defaultValue, disabledTime = props.disabledTime, showTime = props.showTime, onSelect = props.onSelect, cellRender = props.cellRender;
        var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
        var _React$useState = React__namespace.useState(null), _React$useState2 = _slicedToArray$5(_React$useState, 2), activePanel = _React$useState2[0], setActivePanel = _React$useState2[1];
        var dateOperationRef = React__namespace.useRef({});
        var timeOperationRef = React__namespace.useRef({});
        var timeProps = _typeof$3(showTime) === "object" ? _objectSpread2({}, showTime) : {};
        function getNextActive(offset2) {
          var activeIndex = ACTIVE_PANEL.indexOf(activePanel) + offset2;
          var nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
          return nextActivePanel;
        }
        var onBlur = function onBlur2(e2) {
          if (timeOperationRef.current.onBlur) {
            timeOperationRef.current.onBlur(e2);
          }
          setActivePanel(null);
        };
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            if (event.which === KeyCode.TAB) {
              var nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
              setActivePanel(nextActivePanel);
              if (nextActivePanel) {
                event.preventDefault();
              }
              return true;
            }
            if (activePanel) {
              var ref = activePanel === "date" ? dateOperationRef : timeOperationRef;
              if (ref.current && ref.current.onKeyDown) {
                ref.current.onKeyDown(event);
              }
              return true;
            }
            if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN].includes(event.which)) {
              setActivePanel("date");
              return true;
            }
            return false;
          },
          onBlur,
          onClose: onBlur
        };
        var onInternalSelect = function onInternalSelect2(date2, source) {
          var selectedDate = date2;
          if (source === "date" && !value && timeProps.defaultValue) {
            selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
            selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
            selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
          } else if (source === "time" && !value && defaultValue) {
            selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
            selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
            selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
          }
          if (onSelect) {
            onSelect(selectedDate, "mouse");
          }
        };
        var disabledTimes = disabledTime ? disabledTime(value || null) : {};
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames(panelPrefixCls, _defineProperty$3({}, "".concat(panelPrefixCls, "-active"), activePanel))
        }, /* @__PURE__ */ React__namespace.createElement(DatePanel, _extends$1({}, props, {
          cellRender,
          operationRef: dateOperationRef,
          active: activePanel === "date",
          onSelect: function onSelect2(date2) {
            onInternalSelect(setDateTime(generateConfig2, date2, !value && _typeof$3(showTime) === "object" ? showTime.defaultValue : null), "date");
          }
        })), /* @__PURE__ */ React__namespace.createElement(TimePanel, _extends$1({}, props, {
          cellRender: cellRender ? function(current, info) {
            return cellRender(current, _objectSpread2(_objectSpread2({}, info), {}, {
              type: "time"
            }));
          } : void 0,
          format: void 0
        }, timeProps, disabledTimes, {
          disabledTime: null,
          defaultValue: void 0,
          operationRef: timeOperationRef,
          active: activePanel === "time",
          onSelect: function onSelect2(date2) {
            onInternalSelect(date2, "time");
          }
        })));
      }
      function MonthHeader(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var headerPrefixCls = "".concat(prefixCls, "-header");
        return /* @__PURE__ */ React__namespace.createElement(Header, _extends$1({}, props, {
          prefixCls: headerPrefixCls,
          onSuperPrev: onPrevYear,
          onSuperNext: onNextYear
        }), /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onYearClick,
          className: "".concat(prefixCls, "-year-btn")
        }, formatValue(viewDate, {
          locale: locale2,
          format: locale2.yearFormat,
          generateConfig: generateConfig2
        })));
      }
      var MONTH_COL_COUNT = 3;
      var MONTH_ROW_COUNT = 4;
      function MonthBody(props) {
        var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
        var _React$useContext = React__namespace.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var getCellClassName = useCellClassName({
          cellPrefixCls,
          value,
          generateConfig: generateConfig2,
          rangedValue,
          hoverRangedValue,
          isSameCell: function isSameCell(current, target) {
            return isSameMonth(generateConfig2, current, target);
          },
          isInView: function isInView() {
            return true;
          },
          offsetCell: function offsetCell(date2, offset2) {
            return generateConfig2.addMonth(date2, offset2);
          }
        });
        var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
        var baseMonth = generateConfig2.setMonth(viewDate, 0);
        var getCellNode = cellRender ? function(date2, wrapperNode) {
          return cellRender(date2, {
            originNode: wrapperNode,
            locale: locale2,
            today: generateConfig2.getNow(),
            type: "month"
          });
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(PanelBody, _extends$1({}, props, {
          rowNum: MONTH_ROW_COUNT,
          colNum: MONTH_COL_COUNT,
          baseDate: baseMonth,
          getCellNode,
          getCellText: function getCellText(date2) {
            return locale2.monthFormat ? formatValue(date2, {
              locale: locale2,
              format: locale2.monthFormat,
              generateConfig: generateConfig2
            }) : monthsLocale[generateConfig2.getMonth(date2)];
          },
          getCellClassName,
          getCellDate: generateConfig2.addMonth,
          titleCell: function titleCell(date2) {
            return formatValue(date2, {
              locale: locale2,
              format: "YYYY-MM",
              generateConfig: generateConfig2
            });
          }
        }));
      }
      function MonthPanel(props) {
        var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
        var panelPrefixCls = "".concat(prefixCls, "-month-panel");
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, {
              onLeftRight: function onLeftRight(diff) {
                _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
              },
              onCtrlLeftRight: function onCtrlLeftRight(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
              },
              onUpDown: function onUpDown(diff) {
                _onSelect(generateConfig2.addMonth(value || viewDate, diff * MONTH_COL_COUNT), "key");
              },
              onEnter: function onEnter() {
                onPanelChange("date", value || viewDate);
              }
            });
          }
        };
        var onYearChange = function onYearChange2(diff) {
          var newDate = generateConfig2.addYear(viewDate, diff);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: panelPrefixCls
        }, /* @__PURE__ */ React__namespace.createElement(MonthHeader, _extends$1({}, props, {
          prefixCls,
          onPrevYear: function onPrevYear() {
            onYearChange(-1);
          },
          onNextYear: function onNextYear() {
            onYearChange(1);
          },
          onYearClick: function onYearClick() {
            onPanelChange("year", viewDate);
          }
        })), /* @__PURE__ */ React__namespace.createElement(MonthBody, _extends$1({}, props, {
          prefixCls,
          onSelect: function onSelect(date2) {
            _onSelect(date2, "mouse");
            onPanelChange("date", date2);
          }
        })));
      }
      function QuarterHeader(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var headerPrefixCls = "".concat(prefixCls, "-header");
        return /* @__PURE__ */ React__namespace.createElement(Header, _extends$1({}, props, {
          prefixCls: headerPrefixCls,
          onSuperPrev: onPrevYear,
          onSuperNext: onNextYear
        }), /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onYearClick,
          className: "".concat(prefixCls, "-year-btn")
        }, formatValue(viewDate, {
          locale: locale2,
          format: locale2.yearFormat,
          generateConfig: generateConfig2
        })));
      }
      var QUARTER_COL_COUNT = 4;
      var QUARTER_ROW_COUNT = 1;
      function QuarterBody(props) {
        var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
        var _React$useContext = React__namespace.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var getCellClassName = useCellClassName({
          cellPrefixCls,
          value,
          generateConfig: generateConfig2,
          rangedValue,
          hoverRangedValue,
          isSameCell: function isSameCell(current, target) {
            return isSameQuarter(generateConfig2, current, target);
          },
          isInView: function isInView() {
            return true;
          },
          offsetCell: function offsetCell(date2, offset2) {
            return generateConfig2.addMonth(date2, offset2 * 3);
          }
        });
        var baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
        var getCellNode = cellRender ? function(date2, wrapperNode) {
          return cellRender(date2, {
            originNode: wrapperNode,
            locale: locale2,
            today: generateConfig2.getNow(),
            type: "quarter"
          });
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(PanelBody, _extends$1({}, props, {
          rowNum: QUARTER_ROW_COUNT,
          colNum: QUARTER_COL_COUNT,
          baseDate: baseQuarter,
          getCellNode,
          getCellText: function getCellText(date2) {
            return formatValue(date2, {
              locale: locale2,
              format: locale2.quarterFormat || "[Q]Q",
              generateConfig: generateConfig2
            });
          },
          getCellClassName,
          getCellDate: function getCellDate(date2, offset2) {
            return generateConfig2.addMonth(date2, offset2 * 3);
          },
          titleCell: function titleCell(date2) {
            return formatValue(date2, {
              locale: locale2,
              format: "YYYY-[Q]Q",
              generateConfig: generateConfig2
            });
          }
        }));
      }
      function QuarterPanel(props) {
        var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
        var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, {
              onLeftRight: function onLeftRight(diff) {
                _onSelect(generateConfig2.addMonth(value || viewDate, diff * 3), "key");
              },
              onCtrlLeftRight: function onCtrlLeftRight(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
              },
              onUpDown: function onUpDown(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
              }
            });
          }
        };
        var onYearChange = function onYearChange2(diff) {
          var newDate = generateConfig2.addYear(viewDate, diff);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: panelPrefixCls
        }, /* @__PURE__ */ React__namespace.createElement(QuarterHeader, _extends$1({}, props, {
          prefixCls,
          onPrevYear: function onPrevYear() {
            onYearChange(-1);
          },
          onNextYear: function onNextYear() {
            onYearChange(1);
          },
          onYearClick: function onYearClick() {
            onPanelChange("year", viewDate);
          }
        })), /* @__PURE__ */ React__namespace.createElement(QuarterBody, _extends$1({}, props, {
          prefixCls,
          onSelect: function onSelect(date2) {
            _onSelect(date2, "mouse");
          }
        })));
      }
      function WeekPanel(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, disabledDate = props.disabledDate, onSelect = props.onSelect;
        var _React$useContext = React__namespace.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var _React$useContext2 = React__namespace.useContext(PanelContext), onDateMouseEnter = _React$useContext2.onDateMouseEnter, onDateMouseLeave = _React$useContext2.onDateMouseLeave;
        var rangeStart = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[0]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[0]);
        var rangeEnd = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[1]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[1]);
        var cellPrefixCls = "".concat(prefixCls, "-cell");
        var prefixColumn = function prefixColumn2(date2) {
          var disabled = getCellDateDisabled({
            cellDate: date2,
            mode: "week",
            disabledDate,
            generateConfig: generateConfig2
          });
          return /* @__PURE__ */ React__namespace.createElement("td", {
            key: "week",
            className: classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week")),
            onClick: function onClick() {
              if (!disabled) {
                onSelect(date2, "mouse");
              }
            },
            onMouseEnter: function onMouseEnter() {
              if (!disabled && onDateMouseEnter) {
                onDateMouseEnter(date2);
              }
            },
            onMouseLeave: function onMouseLeave() {
              if (!disabled && onDateMouseLeave) {
                onDateMouseLeave(date2);
              }
            }
          }, /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, generateConfig2.locale.getWeek(locale2.locale, date2)));
        };
        var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
        var rowClassName = function rowClassName2(date2) {
          var _classNames;
          var isRangeStart = isSameWeek(generateConfig2, locale2.locale, rangeStart, date2);
          var isRangeEnd = isSameWeek(generateConfig2, locale2.locale, rangeEnd, date2);
          return classNames(rowPrefixCls, (_classNames = {}, _defineProperty$3(_classNames, "".concat(rowPrefixCls, "-selected"), !rangedValue && isSameWeek(generateConfig2, locale2.locale, value, date2)), _defineProperty$3(_classNames, "".concat(rowPrefixCls, "-range-start"), isRangeStart), _defineProperty$3(_classNames, "".concat(rowPrefixCls, "-range-end"), isRangeEnd), _defineProperty$3(_classNames, "".concat(rowPrefixCls, "-range-hover"), !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, date2)), _classNames));
        };
        return /* @__PURE__ */ React__namespace.createElement(DatePanel, _extends$1({}, props, {
          panelName: "week",
          prefixColumn,
          rowClassName,
          keyboardConfig: {
            onLeftRight: null
          },
          isSameCell: function isSameCell() {
            return false;
          }
        }));
      }
      function YearHeader(props) {
        var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecade = props.onPrevDecade, onNextDecade = props.onNextDecade, onDecadeClick = props.onDecadeClick;
        var _React$useContext = React__namespace.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
        if (hideHeader) {
          return null;
        }
        var headerPrefixCls = "".concat(prefixCls, "-header");
        var yearNumber = generateConfig2.getYear(viewDate);
        var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
        var endYear = startYear + YEAR_DECADE_COUNT - 1;
        return /* @__PURE__ */ React__namespace.createElement(Header, _extends$1({}, props, {
          prefixCls: headerPrefixCls,
          onSuperPrev: onPrevDecade,
          onSuperNext: onNextDecade
        }), /* @__PURE__ */ React__namespace.createElement("button", {
          type: "button",
          onClick: onDecadeClick,
          className: "".concat(prefixCls, "-decade-btn")
        }, startYear, "-", endYear));
      }
      var YEAR_COL_COUNT = 3;
      var YEAR_ROW_COUNT = 4;
      function YearBody(props) {
        var prefixCls = props.prefixCls, value = props.value, viewDate = props.viewDate, locale2 = props.locale, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
        var _React$useContext = React__namespace.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var yearPrefixCls = "".concat(prefixCls, "-cell");
        var yearNumber = generateConfig2.getYear(viewDate);
        var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
        var endYear = startYear + YEAR_DECADE_COUNT - 1;
        var baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
        var today = generateConfig2.getNow();
        var isInView = function isInView2(date2) {
          var currentYearNumber = generateConfig2.getYear(date2);
          return startYear <= currentYearNumber && currentYearNumber <= endYear;
        };
        var getCellClassName = useCellClassName({
          cellPrefixCls: yearPrefixCls,
          value,
          generateConfig: generateConfig2,
          rangedValue,
          hoverRangedValue,
          isSameCell: function isSameCell(current, target) {
            return isSameYear(generateConfig2, current, target);
          },
          isInView,
          offsetCell: function offsetCell(date2, offset2) {
            return generateConfig2.addYear(date2, offset2);
          }
        });
        var getCellNode = cellRender ? function(date2, wrapperNode) {
          return cellRender(date2, {
            originNode: wrapperNode,
            today,
            type: "year",
            locale: locale2
          });
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(PanelBody, _extends$1({}, props, {
          rowNum: YEAR_ROW_COUNT,
          colNum: YEAR_COL_COUNT,
          baseDate: baseYear,
          getCellNode,
          getCellText: generateConfig2.getYear,
          getCellClassName,
          getCellDate: generateConfig2.addYear,
          titleCell: function titleCell(date2) {
            return formatValue(date2, {
              locale: locale2,
              format: "YYYY",
              generateConfig: generateConfig2
            });
          }
        }));
      }
      var YEAR_DECADE_COUNT = 10;
      function YearPanel(props) {
        var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, sourceMode = props.sourceMode, _onSelect = props.onSelect, onPanelChange = props.onPanelChange;
        var panelPrefixCls = "".concat(prefixCls, "-year-panel");
        operationRef.current = {
          onKeyDown: function onKeyDown(event) {
            return createKeyDownHandler(event, {
              onLeftRight: function onLeftRight(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
              },
              onCtrlLeftRight: function onCtrlLeftRight(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_DECADE_COUNT), "key");
              },
              onUpDown: function onUpDown(diff) {
                _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_COL_COUNT), "key");
              },
              onEnter: function onEnter() {
                onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
              }
            });
          }
        };
        var onDecadeChange = function onDecadeChange2(diff) {
          var newDate = generateConfig2.addYear(viewDate, diff * 10);
          onViewDateChange(newDate);
          onPanelChange(null, newDate);
        };
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: panelPrefixCls
        }, /* @__PURE__ */ React__namespace.createElement(YearHeader, _extends$1({}, props, {
          prefixCls,
          onPrevDecade: function onPrevDecade() {
            onDecadeChange(-1);
          },
          onNextDecade: function onNextDecade() {
            onDecadeChange(1);
          },
          onDecadeClick: function onDecadeClick() {
            onPanelChange("decade", viewDate);
          }
        })), /* @__PURE__ */ React__namespace.createElement(YearBody, _extends$1({}, props, {
          prefixCls,
          onSelect: function onSelect(date2) {
            onPanelChange(sourceMode === "date" ? "date" : "month", date2);
            _onSelect(date2, "mouse");
          }
        })));
      }
      function getExtraFooter(prefixCls, mode, renderExtraFooter) {
        if (!renderExtraFooter) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-footer-extra")
        }, renderExtraFooter(mode));
      }
      function getRanges(_ref) {
        var prefixCls = _ref.prefixCls, _ref$components = _ref.components, components = _ref$components === void 0 ? {} : _ref$components, needConfirmButton = _ref.needConfirmButton, onNow = _ref.onNow, onOk = _ref.onOk, okDisabled = _ref.okDisabled, showNow = _ref.showNow, locale2 = _ref.locale;
        var presetNode;
        var okNode;
        if (needConfirmButton) {
          var Button2 = components.button || "button";
          if (onNow && showNow !== false) {
            presetNode = /* @__PURE__ */ React__namespace.createElement("li", {
              className: "".concat(prefixCls, "-now")
            }, /* @__PURE__ */ React__namespace.createElement("a", {
              className: "".concat(prefixCls, "-now-btn"),
              onClick: onNow
            }, locale2.now));
          }
          okNode = needConfirmButton && /* @__PURE__ */ React__namespace.createElement("li", {
            className: "".concat(prefixCls, "-ok")
          }, /* @__PURE__ */ React__namespace.createElement(Button2, {
            disabled: okDisabled,
            onClick: onOk
          }, locale2.ok));
        }
        if (!presetNode && !okNode) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement("ul", {
          className: "".concat(prefixCls, "-ranges")
        }, presetNode, okNode);
      }
      function useCellRender(_ref) {
        var cellRender = _ref.cellRender, monthCellRender = _ref.monthCellRender, dateRender = _ref.dateRender;
        var mergedCellRender = React.useMemo(function() {
          if (cellRender)
            return cellRender;
          if (!monthCellRender && !dateRender)
            return void 0;
          return function(current, info) {
            var date2 = current;
            if (dateRender && info.type === "date") {
              return dateRender(date2, info.today);
            }
            if (monthCellRender && info.type === "month") {
              return monthCellRender(date2, info.locale);
            }
            return info.originNode;
          };
        }, [cellRender, monthCellRender, dateRender]);
        return mergedCellRender;
      }
      var CALENDAR_PANEL_MODE = ["date", "month"];
      function PickerPanel(props) {
        var _classNames;
        var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, className = _ref.className, style2 = _ref.style, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, value = _ref.value, defaultValue = _ref.defaultValue, pickerValue = _ref.pickerValue, defaultPickerValue = _ref.defaultPickerValue, disabledDate = _ref.disabledDate, mode = _ref.mode, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, showNow = _ref.showNow, showTime = _ref.showTime, showToday = _ref.showToday, renderExtraFooter = _ref.renderExtraFooter, hideHeader = _ref.hideHeader, onSelect = _ref.onSelect, onChange = _ref.onChange, onPanelChange = _ref.onPanelChange, onMouseDown = _ref.onMouseDown, onPickerValueChange = _ref.onPickerValueChange, _onOk = _ref.onOk, components = _ref.components, direction = _ref.direction, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, cellRender = _ref.cellRender;
        var needConfirmButton = picker === "date" && !!showTime || picker === "time";
        var isHourStepValid = 24 % hourStep === 0;
        var isMinuteStepValid = 60 % minuteStep === 0;
        var isSecondStepValid = 60 % secondStep === 0;
        var panelContext = React__namespace.useContext(PanelContext);
        var operationRef = panelContext.operationRef, onContextSelect = panelContext.onSelect, hideRanges = panelContext.hideRanges, defaultOpenValue = panelContext.defaultOpenValue;
        var _React$useContext = React__namespace.useContext(RangeContext), inRange = _React$useContext.inRange, panelPosition = _React$useContext.panelPosition, rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
        var panelRef = React__namespace.useRef({});
        var initRef = React__namespace.useRef(true);
        var _useMergedState = useMergedState(null, {
          value,
          defaultValue,
          postState: function postState(val) {
            if (!val && defaultOpenValue && picker === "time") {
              return defaultOpenValue;
            }
            return val;
          }
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
        var _useMergedState3 = useMergedState(null, {
          value: pickerValue,
          defaultValue: defaultPickerValue || mergedValue,
          postState: function postState(date2) {
            var now2 = generateConfig2.getNow();
            if (!date2) {
              return now2;
            }
            if (!mergedValue && showTime) {
              var defaultDateObject = _typeof$3(showTime) === "object" ? showTime.defaultValue : defaultValue;
              return setDateTime(generateConfig2, Array.isArray(date2) ? date2[0] : date2, defaultDateObject || now2);
            }
            return Array.isArray(date2) ? date2[0] : date2;
          }
        }), _useMergedState4 = _slicedToArray$5(_useMergedState3, 2), viewDate = _useMergedState4[0], setInnerViewDate = _useMergedState4[1];
        var setViewDate = function setViewDate2(date2) {
          setInnerViewDate(date2);
          if (onPickerValueChange) {
            onPickerValueChange(date2);
          }
        };
        var getInternalNextMode = function getInternalNextMode2(nextMode) {
          var getNextMode = PickerModeMap[picker];
          if (getNextMode) {
            return getNextMode(nextMode);
          }
          return nextMode;
        };
        var _useMergedState5 = useMergedState(function() {
          if (picker === "time") {
            return "time";
          }
          return getInternalNextMode("date");
        }, {
          value: mode
        }), _useMergedState6 = _slicedToArray$5(_useMergedState5, 2), mergedMode = _useMergedState6[0], setInnerMode = _useMergedState6[1];
        React__namespace.useEffect(function() {
          setInnerMode(picker);
        }, [picker]);
        var _React$useState = React__namespace.useState(function() {
          return mergedMode;
        }), _React$useState2 = _slicedToArray$5(_React$useState, 2), sourceMode = _React$useState2[0], setSourceMode = _React$useState2[1];
        var onInternalPanelChange = function onInternalPanelChange2(newMode, viewValue) {
          var nextMode = getInternalNextMode(newMode || mergedMode);
          setSourceMode(mergedMode);
          setInnerMode(nextMode);
          if (onPanelChange && (mergedMode !== nextMode || isEqual(generateConfig2, viewDate, viewDate))) {
            onPanelChange(viewValue, nextMode);
          }
        };
        var triggerSelect = function triggerSelect2(date2, type2) {
          var forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (mergedMode === picker || forceTriggerSelect) {
            setInnerValue(date2);
            if (onSelect) {
              onSelect(date2);
            }
            if (onContextSelect) {
              onContextSelect(date2, type2);
            }
            if (onChange && !isEqual(generateConfig2, date2, mergedValue) && !(disabledDate !== null && disabledDate !== void 0 && disabledDate(date2))) {
              onChange(date2);
            }
          }
        };
        var isSelectable = function isSelectable2(key2) {
          if (CALENDAR_PANEL_MODE.includes(mergedMode)) {
            var _date;
            var operationFnc;
            var isDateMode = mergedMode === "date";
            if (key2 === KeyCode.PAGE_UP || key2 === KeyCode.PAGE_DOWN) {
              operationFnc = isDateMode ? generateConfig2.addMonth : generateConfig2.addYear;
            } else {
              operationFnc = isDateMode ? generateConfig2.addDate : generateConfig2.addMonth;
            }
            switch (key2) {
              case KeyCode.LEFT:
              case KeyCode.PAGE_UP:
                _date = operationFnc(viewDate, -1);
                break;
              case KeyCode.RIGHT:
              case KeyCode.PAGE_DOWN:
                _date = operationFnc(viewDate, 1);
                break;
              case KeyCode.UP:
              case KeyCode.DOWN:
                _date = operationFnc(viewDate, Number("".concat(key2 === KeyCode.UP ? "-" : "").concat(isDateMode ? WEEK_DAY_COUNT : MONTH_COL_COUNT)));
                break;
            }
            if (_date) {
              return !(disabledDate !== null && disabledDate !== void 0 && disabledDate(_date));
            }
          }
          return true;
        };
        var onInternalKeyDown = function onInternalKeyDown2(e2) {
          if (panelRef.current && panelRef.current.onKeyDown) {
            var selectable = true;
            var which = e2.which;
            if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN, KeyCode.PAGE_UP, KeyCode.PAGE_DOWN, KeyCode.ENTER].includes(which)) {
              e2.preventDefault();
              if (which !== KeyCode.ENTER && tabIndex === 0) {
                selectable = isSelectable(which);
              }
            }
            if (selectable) {
              return panelRef.current.onKeyDown(e2);
            }
          }
          {
            warningOnce(false, "Panel not correct handle keyDown event. Please help to fire issue about this.");
            return false;
          }
        };
        var onInternalBlur = function onInternalBlur2(e2) {
          if (panelRef.current && panelRef.current.onBlur) {
            panelRef.current.onBlur(e2);
          }
        };
        if (operationRef && panelPosition !== "right") {
          operationRef.current = {
            onKeyDown: onInternalKeyDown,
            onClose: function onClose() {
              if (panelRef.current && panelRef.current.onClose) {
                panelRef.current.onClose();
              }
            }
          };
        }
        React__namespace.useEffect(function() {
          if (value && !initRef.current) {
            setInnerViewDate(value);
          }
        }, [value]);
        React__namespace.useEffect(function() {
          initRef.current = false;
        }, []);
        var panelNode;
        var mergedCellRender = useCellRender({
          cellRender,
          monthCellRender,
          dateRender
        });
        var pickerProps = _objectSpread2(_objectSpread2({}, props), {}, {
          cellRender: mergedCellRender,
          operationRef: panelRef,
          prefixCls,
          viewDate,
          value: mergedValue,
          onViewDateChange: setViewDate,
          sourceMode,
          onPanelChange: onInternalPanelChange,
          disabledDate
        });
        delete pickerProps.onChange;
        delete pickerProps.onSelect;
        switch (mergedMode) {
          case "decade":
            panelNode = /* @__PURE__ */ React__namespace.createElement(DecadePanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          case "year":
            panelNode = /* @__PURE__ */ React__namespace.createElement(YearPanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          case "month":
            panelNode = /* @__PURE__ */ React__namespace.createElement(MonthPanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          case "quarter":
            panelNode = /* @__PURE__ */ React__namespace.createElement(QuarterPanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          case "week":
            panelNode = /* @__PURE__ */ React__namespace.createElement(WeekPanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          case "time":
            delete pickerProps.showTime;
            panelNode = /* @__PURE__ */ React__namespace.createElement(TimePanel, _extends$1({}, pickerProps, _typeof$3(showTime) === "object" ? showTime : null, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
            break;
          default:
            if (showTime) {
              panelNode = /* @__PURE__ */ React__namespace.createElement(DatetimePanel, _extends$1({}, pickerProps, {
                onSelect: function onSelect2(date2, type2) {
                  setViewDate(date2);
                  triggerSelect(date2, type2);
                }
              }));
            } else {
              panelNode = /* @__PURE__ */ React__namespace.createElement(DatePanel, _extends$1({}, pickerProps, {
                onSelect: function onSelect2(date2, type2) {
                  setViewDate(date2);
                  triggerSelect(date2, type2);
                }
              }));
            }
        }
        var extraFooter;
        var rangesNode;
        var onNow = function onNow2() {
          var now2 = generateConfig2.getNow();
          var lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now2), generateConfig2.getMinute(now2), generateConfig2.getSecond(now2), isHourStepValid ? hourStep : 1, isMinuteStepValid ? minuteStep : 1, isSecondStepValid ? secondStep : 1);
          var adjustedNow = setTime(
            generateConfig2,
            now2,
            lowerBoundTime[0],
            // hour
            lowerBoundTime[1],
            // minute
            lowerBoundTime[2]
            // second
          );
          triggerSelect(adjustedNow, "submit");
        };
        if (!hideRanges) {
          extraFooter = getExtraFooter(prefixCls, mergedMode, renderExtraFooter);
          rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton,
            okDisabled: !mergedValue || disabledDate && disabledDate(mergedValue),
            locale: locale2,
            showNow,
            onNow: needConfirmButton && onNow,
            onOk: function onOk() {
              if (mergedValue) {
                triggerSelect(mergedValue, "submit", true);
                if (_onOk) {
                  _onOk(mergedValue);
                }
              }
            }
          });
        }
        var todayNode;
        if (showToday && mergedMode === "date" && picker === "date" && !showTime) {
          var now = generateConfig2.getNow();
          var todayCls = "".concat(prefixCls, "-today-btn");
          var disabled = disabledDate && disabledDate(now);
          todayNode = /* @__PURE__ */ React__namespace.createElement("a", {
            className: classNames(todayCls, disabled && "".concat(todayCls, "-disabled")),
            "aria-disabled": disabled,
            onClick: function onClick() {
              if (!disabled) {
                triggerSelect(now, "mouse", true);
              }
            }
          }, locale2.today);
        }
        return /* @__PURE__ */ React__namespace.createElement(PanelContext.Provider, {
          value: _objectSpread2(_objectSpread2({}, panelContext), {}, {
            mode: mergedMode,
            hideHeader: "hideHeader" in props ? hideHeader : panelContext.hideHeader,
            hidePrevBtn: inRange && panelPosition === "right",
            hideNextBtn: inRange && panelPosition === "left"
          })
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          tabIndex,
          className: classNames("".concat(prefixCls, "-panel"), className, (_classNames = {}, _defineProperty$3(_classNames, "".concat(prefixCls, "-panel-has-range"), rangedValue && rangedValue[0] && rangedValue[1]), _defineProperty$3(_classNames, "".concat(prefixCls, "-panel-has-range-hover"), hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1]), _defineProperty$3(_classNames, "".concat(prefixCls, "-panel-rtl"), direction === "rtl"), _classNames)),
          style: style2,
          onKeyDown: onInternalKeyDown,
          onBlur: onInternalBlur,
          onMouseDown
        }, panelNode, extraFooter || rangesNode || todayNode ? /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-footer")
        }, extraFooter, rangesNode, todayNode) : null));
      }
      var BUILT_IN_PLACEMENTS = {
        bottomLeft: {
          points: ["tl", "bl"],
          offset: [0, 4],
          overflow: {
            adjustX: 1,
            adjustY: 1
          }
        },
        bottomRight: {
          points: ["tr", "br"],
          offset: [0, 4],
          overflow: {
            adjustX: 1,
            adjustY: 1
          }
        },
        topLeft: {
          points: ["bl", "tl"],
          offset: [0, -4],
          overflow: {
            adjustX: 0,
            adjustY: 1
          }
        },
        topRight: {
          points: ["br", "tr"],
          offset: [0, -4],
          overflow: {
            adjustX: 0,
            adjustY: 1
          }
        }
      };
      function PickerTrigger(_ref) {
        var _classNames;
        var prefixCls = _ref.prefixCls, popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, visible = _ref.visible, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range2 = _ref.range, popupPlacement = _ref.popupPlacement, direction = _ref.direction;
        var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
        var getPopupPlacement = function getPopupPlacement2() {
          if (popupPlacement !== void 0) {
            return popupPlacement;
          }
          return direction === "rtl" ? "bottomRight" : "bottomLeft";
        };
        return /* @__PURE__ */ React__namespace.createElement(Trigger, {
          showAction: [],
          hideAction: [],
          popupPlacement: getPopupPlacement(),
          builtinPlacements: BUILT_IN_PLACEMENTS,
          prefixCls: dropdownPrefixCls,
          popupTransitionName: transitionName,
          popup: popupElement,
          popupAlign: dropdownAlign,
          popupVisible: visible,
          popupClassName: classNames(dropdownClassName, (_classNames = {}, _defineProperty$3(_classNames, "".concat(dropdownPrefixCls, "-range"), range2), _defineProperty$3(_classNames, "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl"), _classNames)),
          popupStyle,
          getPopupContainer
        }, children);
      }
      function PresetPanel(props) {
        var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
        if (!presets.length) {
          return null;
        }
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-presets")
        }, /* @__PURE__ */ React__namespace.createElement("ul", null, presets.map(function(_ref, index2) {
          var label = _ref.label, value = _ref.value;
          return /* @__PURE__ */ React__namespace.createElement("li", {
            key: index2,
            onClick: function onClick() {
              _onClick(value);
            },
            onMouseEnter: function onMouseEnter() {
              onHover === null || onHover === void 0 ? void 0 : onHover(value);
            },
            onMouseLeave: function onMouseLeave() {
              onHover === null || onHover === void 0 ? void 0 : onHover(null);
            }
          }, label);
        })));
      }
      function InnerPicker(props) {
        var _classNames2;
        var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id = _ref.id, name = _ref.name, tabIndex = _ref.tabIndex, style2 = _ref.style, className = _ref.className, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, popupStyle = _ref.popupStyle, transitionName = _ref.transitionName, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, inputReadOnly = _ref.inputReadOnly, allowClear = _ref.allowClear, autoFocus = _ref.autoFocus, showTime = _ref.showTime, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, format2 = _ref.format, use12Hours = _ref.use12Hours, value = _ref.value, defaultValue = _ref.defaultValue, presets = _ref.presets, open = _ref.open, defaultOpen = _ref.defaultOpen, defaultOpenValue = _ref.defaultOpenValue, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, disabled = _ref.disabled, disabledDate = _ref.disabledDate, placeholder = _ref.placeholder, getPopupContainer = _ref.getPopupContainer, pickerRef = _ref.pickerRef, panelRender = _ref.panelRender, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onContextMenu = _ref.onContextMenu, onClick = _ref.onClick, _onKeyDown = _ref.onKeyDown, _onSelect = _ref.onSelect, direction = _ref.direction, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete, inputRender = _ref.inputRender, changeOnBlur = _ref.changeOnBlur;
        var inputRef = React__namespace.useRef(null);
        var needConfirmButton = picker === "date" && !!showTime || picker === "time";
        var presetList = usePresets(presets);
        var formatList = toArray$2(getDefaultFormat(format2, picker, showTime, use12Hours));
        var panelDivRef = React__namespace.useRef(null);
        var inputDivRef = React__namespace.useRef(null);
        var containerRef = React__namespace.useRef(null);
        var _useMergedState = useMergedState(null, {
          value,
          defaultValue
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
        var _React$useState = React__namespace.useState(mergedValue), _React$useState2 = _slicedToArray$5(_React$useState, 2), selectedValue = _React$useState2[0], setSelectedValue = _React$useState2[1];
        var operationRef = React__namespace.useRef(null);
        var _useMergedState3 = useMergedState(false, {
          value: open,
          defaultValue: defaultOpen,
          postState: function postState(postOpen) {
            return disabled ? false : postOpen;
          },
          onChange: function onChange2(newOpen) {
            if (onOpenChange) {
              onOpenChange(newOpen);
            }
            if (!newOpen && operationRef.current && operationRef.current.onClose) {
              operationRef.current.onClose();
            }
          }
        }), _useMergedState4 = _slicedToArray$5(_useMergedState3, 2), mergedOpen = _useMergedState4[0], triggerInnerOpen = _useMergedState4[1];
        var _useValueTexts = useValueTexts(selectedValue, {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        }), _useValueTexts2 = _slicedToArray$5(_useValueTexts, 2), valueTexts = _useValueTexts2[0], firstValueText = _useValueTexts2[1];
        var _useTextValueMapping = useTextValueMapping({
          valueTexts,
          onTextChange: function onTextChange(newText) {
            var inputDate = parseValue(newText, {
              locale: locale2,
              formatList,
              generateConfig: generateConfig2
            });
            if (inputDate && (!disabledDate || !disabledDate(inputDate))) {
              setSelectedValue(inputDate);
            }
          }
        }), _useTextValueMapping2 = _slicedToArray$5(_useTextValueMapping, 3), text = _useTextValueMapping2[0], triggerTextChange = _useTextValueMapping2[1], resetText = _useTextValueMapping2[2];
        var triggerChange = function triggerChange2(newValue) {
          setSelectedValue(newValue);
          setInnerValue(newValue);
          if (onChange && !isEqual(generateConfig2, mergedValue, newValue)) {
            onChange(newValue, newValue ? formatValue(newValue, {
              generateConfig: generateConfig2,
              locale: locale2,
              format: formatList[0]
            }) : "");
          }
        };
        var triggerOpen = function triggerOpen2(newOpen) {
          if (disabled && newOpen) {
            return;
          }
          triggerInnerOpen(newOpen);
        };
        var forwardKeyDown = function forwardKeyDown2(e2) {
          if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
            return operationRef.current.onKeyDown(e2);
          }
          {
            warningOnce(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
            return false;
          }
        };
        var onInternalClick = function onInternalClick2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, args);
          if (inputRef.current) {
            inputRef.current.focus();
            triggerOpen(true);
          }
        };
        var onInternalBlur = function onInternalBlur2(e2) {
          if (changeOnBlur) {
            triggerChange(selectedValue);
          }
          onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
        };
        var _usePickerInput = usePickerInput({
          blurToCancel: needConfirmButton,
          open: mergedOpen,
          value: text,
          triggerOpen,
          forwardKeyDown,
          isClickOutside: function isClickOutside(target) {
            return !elementsContains([panelDivRef.current, inputDivRef.current, containerRef.current], target);
          },
          onSubmit: function onSubmit() {
            if (
              // When user typing disabledDate with keyboard and enter, this value will be empty
              !selectedValue || // Normal disabled check
              disabledDate && disabledDate(selectedValue)
            ) {
              return false;
            }
            triggerChange(selectedValue);
            triggerOpen(false);
            resetText();
            return true;
          },
          onCancel: function onCancel() {
            triggerOpen(false);
            setSelectedValue(mergedValue);
            resetText();
          },
          onKeyDown: function onKeyDown(e2, preventDefault) {
            _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(e2, preventDefault);
          },
          onFocus,
          onBlur: onInternalBlur,
          changeOnBlur
        }), _usePickerInput2 = _slicedToArray$5(_usePickerInput, 2), inputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], focused = _usePickerInput2$.focused, typing = _usePickerInput2$.typing;
        React__namespace.useEffect(function() {
          if (!mergedOpen) {
            setSelectedValue(mergedValue);
            if (!valueTexts.length || valueTexts[0] === "") {
              triggerTextChange("");
            } else if (firstValueText !== text) {
              resetText();
            }
          }
        }, [mergedOpen, valueTexts]);
        React__namespace.useEffect(function() {
          if (!mergedOpen) {
            resetText();
          }
        }, [picker]);
        React__namespace.useEffect(function() {
          setSelectedValue(mergedValue);
        }, [mergedValue]);
        if (pickerRef) {
          pickerRef.current = {
            focus: function focus() {
              var _inputRef$current;
              (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
            },
            blur: function blur() {
              var _inputRef$current2;
              (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
            }
          };
        }
        var _useHoverValue = useHoverValue(text, {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        }), _useHoverValue2 = _slicedToArray$5(_useHoverValue, 3), hoverValue = _useHoverValue2[0], onEnter = _useHoverValue2[1], onLeave = _useHoverValue2[2];
        var panelProps = _objectSpread2(_objectSpread2({}, props), {}, {
          className: void 0,
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        var panelNode = /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-panel-layout")
        }, /* @__PURE__ */ React__namespace.createElement(PresetPanel, {
          prefixCls,
          presets: presetList,
          onClick: function onClick2(nextValue) {
            triggerChange(nextValue);
            triggerOpen(false);
          }
        }), /* @__PURE__ */ React__namespace.createElement(PickerPanel, _extends$1({}, panelProps, {
          generateConfig: generateConfig2,
          className: classNames(_defineProperty$3({}, "".concat(prefixCls, "-panel-focused"), !typing)),
          value: selectedValue,
          locale: locale2,
          tabIndex: -1,
          onSelect: function onSelect(date2) {
            _onSelect === null || _onSelect === void 0 ? void 0 : _onSelect(date2);
            setSelectedValue(date2);
          },
          direction,
          onPanelChange: function onPanelChange(viewDate, mode) {
            var onPanelChange2 = props.onPanelChange;
            onLeave(true);
            onPanelChange2 === null || onPanelChange2 === void 0 ? void 0 : onPanelChange2(viewDate, mode);
          }
        })));
        if (panelRender) {
          panelNode = panelRender(panelNode);
        }
        var panel = /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-panel-container"),
          ref: panelDivRef,
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
          }
        }, panelNode);
        var suffixNode;
        if (suffixIcon) {
          suffixNode = /* @__PURE__ */ React__namespace.createElement("span", {
            className: "".concat(prefixCls, "-suffix"),
            onMouseDown: function onMouseDown2(e2) {
              e2.preventDefault();
            }
          }, suffixIcon);
        }
        var clearNode;
        if (allowClear && mergedValue && !disabled) {
          clearNode = /* @__PURE__ */ React__namespace.createElement("span", {
            onMouseDown: function onMouseDown2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            onMouseUp: function onMouseUp2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              triggerChange(null);
              triggerOpen(false);
            },
            className: "".concat(prefixCls, "-clear"),
            role: "button"
          }, clearIcon || /* @__PURE__ */ React__namespace.createElement("span", {
            className: "".concat(prefixCls, "-clear-btn")
          }));
        }
        var mergedInputProps = _objectSpread2(_objectSpread2(_objectSpread2({
          id,
          tabIndex,
          disabled,
          readOnly: inputReadOnly || typeof formatList[0] === "function" || !typing,
          value: hoverValue || text,
          onChange: function onChange2(e2) {
            triggerTextChange(e2.target.value);
          },
          autoFocus,
          placeholder,
          ref: inputRef,
          title: text
        }, inputProps), {}, {
          size: getInputSize(picker, formatList[0], generateConfig2),
          name
        }, pickAttrs(props, {
          aria: true,
          data: true
        })), {}, {
          autoComplete
        });
        var inputNode = inputRender ? inputRender(mergedInputProps) : /* @__PURE__ */ React__namespace.createElement("input", mergedInputProps);
        var onContextSelect = function onContextSelect2(date2, type2) {
          if (type2 === "submit" || type2 !== "key" && !needConfirmButton) {
            triggerChange(date2);
            triggerOpen(false);
          }
        };
        var popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
        return /* @__PURE__ */ React__namespace.createElement(PanelContext.Provider, {
          value: {
            operationRef,
            hideHeader: picker === "time",
            onSelect: onContextSelect,
            open: mergedOpen,
            defaultOpenValue,
            onDateMouseEnter: onEnter,
            onDateMouseLeave: onLeave
          }
        }, /* @__PURE__ */ React__namespace.createElement(PickerTrigger, {
          visible: mergedOpen,
          popupElement: panel,
          popupStyle,
          prefixCls,
          dropdownClassName,
          dropdownAlign,
          getPopupContainer,
          transitionName,
          popupPlacement,
          direction
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          ref: containerRef,
          className: classNames(prefixCls, className, (_classNames2 = {}, _defineProperty$3(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$3(_classNames2, "".concat(prefixCls, "-focused"), focused), _defineProperty$3(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
          style: style2,
          onMouseDown,
          onMouseUp,
          onMouseEnter,
          onMouseLeave,
          onContextMenu,
          onClick: onInternalClick
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames("".concat(prefixCls, "-input"), _defineProperty$3({}, "".concat(prefixCls, "-input-placeholder"), !!hoverValue)),
          ref: inputDivRef
        }, inputNode, suffixNode, clearNode))));
      }
      var Picker = /* @__PURE__ */ function(_React$Component) {
        _inherits(Picker2, _React$Component);
        var _super = _createSuper(Picker2);
        function Picker2() {
          var _this;
          _classCallCheck$1(this, Picker2);
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty$3(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ React__namespace.createRef());
          _defineProperty$3(_assertThisInitialized(_this), "focus", function() {
            if (_this.pickerRef.current) {
              _this.pickerRef.current.focus();
            }
          });
          _defineProperty$3(_assertThisInitialized(_this), "blur", function() {
            if (_this.pickerRef.current) {
              _this.pickerRef.current.blur();
            }
          });
          return _this;
        }
        _createClass$1(Picker2, [{
          key: "render",
          value: function render2() {
            return /* @__PURE__ */ React__namespace.createElement(InnerPicker, _extends$1({}, this.props, {
              pickerRef: this.pickerRef
            }));
          }
        }]);
        return Picker2;
      }(React__namespace.Component);
      function useRangeDisabled(_ref, firstTimeOpen) {
        var picker = _ref.picker, locale2 = _ref.locale, selectedValue = _ref.selectedValue, disabledDate = _ref.disabledDate, disabled = _ref.disabled, generateConfig2 = _ref.generateConfig;
        var startDate = getValue(selectedValue, 0);
        var endDate = getValue(selectedValue, 1);
        function weekFirstDate(date2) {
          return generateConfig2.locale.getWeekFirstDate(locale2.locale, date2);
        }
        function monthNumber(date2) {
          var year = generateConfig2.getYear(date2);
          var month = generateConfig2.getMonth(date2);
          return year * 100 + month;
        }
        function quarterNumber(date2) {
          var year = generateConfig2.getYear(date2);
          var quarter = getQuarter(generateConfig2, date2);
          return year * 10 + quarter;
        }
        var disabledStartDate = React__namespace.useCallback(function(date2) {
          if (disabled[0] || disabledDate && disabledDate(date2)) {
            return true;
          }
          if (disabled[1] && endDate) {
            return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(date2, endDate);
          }
          if (!firstTimeOpen && endDate) {
            switch (picker) {
              case "quarter":
                return quarterNumber(date2) > quarterNumber(endDate);
              case "month":
                return monthNumber(date2) > monthNumber(endDate);
              case "week":
                return weekFirstDate(date2) > weekFirstDate(endDate);
              default:
                return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(date2, endDate);
            }
          }
          return false;
        }, [disabledDate, disabled[1], endDate, firstTimeOpen]);
        var disabledEndDate = React__namespace.useCallback(function(date2) {
          if (disabled[1] || disabledDate && disabledDate(date2)) {
            return true;
          }
          if (disabled[0] && startDate) {
            return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(startDate, date2);
          }
          if (!firstTimeOpen && startDate) {
            switch (picker) {
              case "quarter":
                return quarterNumber(date2) < quarterNumber(startDate);
              case "month":
                return monthNumber(date2) < monthNumber(startDate);
              case "week":
                return weekFirstDate(date2) < weekFirstDate(startDate);
              default:
                return !isSameDate(generateConfig2, date2, startDate) && generateConfig2.isAfter(startDate, date2);
            }
          }
          return false;
        }, [disabledDate, disabled[0], startDate, firstTimeOpen]);
        return [disabledStartDate, disabledEndDate];
      }
      function useRangeOpen(defaultOpen, open, activePickerIndex, changeOnBlur, startInputRef, endInputRef, startSelectedValue, endSelectedValue, onOpenChange) {
        var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray$5(_React$useState, 2), firstTimeOpen = _React$useState2[0], setFirstTimeOpen = _React$useState2[1];
        var _useMergedState = useMergedState(defaultOpen || false, {
          value: open,
          onChange: function onChange(nextOpen) {
            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
          }
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), mergedOpen = _useMergedState2[0], setMergedOpen = _useMergedState2[1];
        var _useMergedState3 = useMergedState(0, {
          value: activePickerIndex
        }), _useMergedState4 = _slicedToArray$5(_useMergedState3, 2), mergedActivePickerIndex = _useMergedState4[0], setMergedActivePickerIndex = _useMergedState4[1];
        var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray$5(_React$useState3, 2), nextActiveIndex = _React$useState4[0], setNextActiveIndex = _React$useState4[1];
        React__namespace.useEffect(function() {
          if (mergedOpen) {
            setFirstTimeOpen(true);
          }
        }, [mergedOpen]);
        var triggerOpen = useEvent(function(nextOpen, index2, source) {
          if (index2 === false) {
            setMergedOpen(nextOpen);
          } else if (nextOpen) {
            setMergedActivePickerIndex(index2);
            setMergedOpen(nextOpen);
            var nextIndex = index2 === 0 ? 1 : 0;
            if (!mergedOpen || // Also set next index if next is empty
            ![startSelectedValue, endSelectedValue][nextIndex]) {
              setNextActiveIndex(nextIndex);
            } else {
              setFirstTimeOpen(false);
              if (nextActiveIndex !== null) {
                setNextActiveIndex(null);
              }
            }
          } else if (source === "confirm" || source === "blur" && changeOnBlur) {
            if (nextActiveIndex !== null) {
              setFirstTimeOpen(false);
              setMergedActivePickerIndex(nextActiveIndex);
            }
            setNextActiveIndex(null);
            if (nextActiveIndex !== null) {
              wrapperRaf(function() {
                var _ref$current;
                var ref = [startInputRef, endInputRef][nextActiveIndex];
                (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
              });
            } else {
              setMergedOpen(false);
            }
          } else {
            setMergedOpen(false);
          }
        });
        return [mergedOpen, mergedActivePickerIndex, firstTimeOpen, triggerOpen];
      }
      function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
        var startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
        function getDistance(compareFunc) {
          if (compareFunc(startDate, endDate)) {
            return "same";
          }
          if (compareFunc(startNext, endDate)) {
            return "closing";
          }
          return "far";
        }
        switch (picker) {
          case "year":
            return getDistance(function(start, end) {
              return isSameDecade(generateConfig2, start, end);
            });
          case "quarter":
          case "month":
            return getDistance(function(start, end) {
              return isSameYear(generateConfig2, start, end);
            });
          default:
            return getDistance(function(start, end) {
              return isSameMonth(generateConfig2, start, end);
            });
        }
      }
      function getRangeViewDate(values, index2, picker, generateConfig2) {
        var startDate = getValue(values, 0);
        var endDate = getValue(values, 1);
        if (index2 === 0) {
          return startDate;
        }
        if (startDate && endDate) {
          var distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
          switch (distance) {
            case "same":
              return startDate;
            case "closing":
              return startDate;
            default:
              return getClosingViewDate(endDate, picker, generateConfig2, -1);
          }
        }
        return startDate;
      }
      function useRangeViewDates(_ref) {
        var values = _ref.values, picker = _ref.picker, defaultDates = _ref.defaultDates, generateConfig2 = _ref.generateConfig;
        var _React$useState = React__namespace.useState(function() {
          return [getValue(defaultDates, 0), getValue(defaultDates, 1)];
        }), _React$useState2 = _slicedToArray$5(_React$useState, 2), defaultViewDates = _React$useState2[0], setDefaultViewDates = _React$useState2[1];
        var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray$5(_React$useState3, 2), viewDates = _React$useState4[0], setInternalViewDates = _React$useState4[1];
        var startDate = getValue(values, 0);
        var endDate = getValue(values, 1);
        function getViewDate(index2) {
          if (defaultViewDates[index2]) {
            return defaultViewDates[index2];
          }
          return getValue(viewDates, index2) || getRangeViewDate(values, index2, picker, generateConfig2) || startDate || endDate || generateConfig2.getNow();
        }
        function setViewDate(viewDate, index2) {
          if (viewDate) {
            var newViewDates = updateValues(viewDates, viewDate, index2);
            setDefaultViewDates(
              // Should always be an array
              updateValues(defaultViewDates, null, index2) || [null, null]
            );
            var anotherIndex = (index2 + 1) % 2;
            if (!getValue(values, anotherIndex)) {
              newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
            }
            setInternalViewDates(newViewDates);
          } else if (startDate || endDate) {
            setInternalViewDates(null);
          }
        }
        return [getViewDate, setViewDate];
      }
      function reorderValues(values, generateConfig2) {
        if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
          return [values[1], values[0]];
        }
        return values;
      }
      function canValueTrigger(value, index2, disabled, allowEmpty) {
        if (value) {
          return true;
        }
        if (allowEmpty && allowEmpty[index2]) {
          return true;
        }
        if (disabled[(index2 + 1) % 2]) {
          return true;
        }
        return false;
      }
      function InnerRangePicker(props) {
        var _classNames2, _classNames3, _classNames4;
        var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id = _ref.id, style2 = _ref.style, className = _ref.className, popupStyle = _ref.popupStyle, dropdownClassName = _ref.dropdownClassName, transitionName = _ref.transitionName, dropdownAlign = _ref.dropdownAlign, getPopupContainer = _ref.getPopupContainer, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, placeholder = _ref.placeholder, autoFocus = _ref.autoFocus, disabled = _ref.disabled, format2 = _ref.format, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, showTime = _ref.showTime, use12Hours = _ref.use12Hours, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "~" : _ref$separator, value = _ref.value, defaultValue = _ref.defaultValue, defaultPickerValue = _ref.defaultPickerValue, open = _ref.open, defaultOpen = _ref.defaultOpen, disabledDate = _ref.disabledDate, _disabledTime = _ref.disabledTime, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, cellRender = _ref.cellRender, panelRender = _ref.panelRender, presets = _ref.presets, ranges = _ref.ranges, allowEmpty = _ref.allowEmpty, allowClear = _ref.allowClear, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, pickerRef = _ref.pickerRef, inputReadOnly = _ref.inputReadOnly, mode = _ref.mode, renderExtraFooter = _ref.renderExtraFooter, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, _onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onClick = _ref.onClick, _onOk = _ref.onOk, _onKeyDown = _ref.onKeyDown, components = _ref.components, order = _ref.order, direction = _ref.direction, activePickerIndex = _ref.activePickerIndex, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete, changeOnBlur = _ref.changeOnBlur;
        var needConfirmButton = picker === "date" && !!showTime || picker === "time";
        var containerRef = React.useRef(null);
        var panelDivRef = React.useRef(null);
        var startInputDivRef = React.useRef(null);
        var endInputDivRef = React.useRef(null);
        var separatorRef = React.useRef(null);
        var startInputRef = React.useRef(null);
        var endInputRef = React.useRef(null);
        var arrowRef = React.useRef(null);
        var formatList = toArray$2(getDefaultFormat(format2, picker, showTime, use12Hours));
        var operationRef = React.useRef(null);
        var mergedDisabled = React__namespace.useMemo(function() {
          if (Array.isArray(disabled)) {
            return disabled;
          }
          return [disabled || false, disabled || false];
        }, [disabled]);
        var _useMergedState = useMergedState(null, {
          value,
          defaultValue,
          postState: function postState(values) {
            return picker === "time" && !order ? values : reorderValues(values, generateConfig2);
          }
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
        var _useRangeViewDates = useRangeViewDates({
          values: mergedValue,
          picker,
          defaultDates: defaultPickerValue,
          generateConfig: generateConfig2
        }), _useRangeViewDates2 = _slicedToArray$5(_useRangeViewDates, 2), getViewDate = _useRangeViewDates2[0], setViewDate = _useRangeViewDates2[1];
        var _useMergedState3 = useMergedState(mergedValue, {
          postState: function postState(values) {
            var postValues = values;
            if (mergedDisabled[0] && mergedDisabled[1]) {
              return postValues;
            }
            for (var i2 = 0; i2 < 2; i2 += 1) {
              if (mergedDisabled[i2] && !postValues && !getValue(postValues, i2) && !getValue(allowEmpty, i2)) {
                postValues = updateValues(postValues, generateConfig2.getNow(), i2);
              }
            }
            return postValues;
          }
        }), _useMergedState4 = _slicedToArray$5(_useMergedState3, 2), selectedValue = _useMergedState4[0], setSelectedValue = _useMergedState4[1];
        var _useMergedState5 = useMergedState([picker, picker], {
          value: mode
        }), _useMergedState6 = _slicedToArray$5(_useMergedState5, 2), mergedModes = _useMergedState6[0], setInnerModes = _useMergedState6[1];
        React.useEffect(function() {
          setInnerModes([picker, picker]);
        }, [picker]);
        var triggerModesChange = function triggerModesChange2(modes, values) {
          setInnerModes(modes);
          if (onPanelChange) {
            onPanelChange(values, modes);
          }
        };
        var _useRangeOpen = useRangeOpen(defaultOpen, open, activePickerIndex, changeOnBlur, startInputRef, endInputRef, getValue(selectedValue, 0), getValue(selectedValue, 1), onOpenChange), _useRangeOpen2 = _slicedToArray$5(_useRangeOpen, 4), mergedOpen = _useRangeOpen2[0], mergedActivePickerIndex = _useRangeOpen2[1], firstTimeOpen = _useRangeOpen2[2], _triggerOpen = _useRangeOpen2[3];
        var startOpen = mergedOpen && mergedActivePickerIndex === 0;
        var endOpen = mergedOpen && mergedActivePickerIndex === 1;
        var _useRangeDisabled = useRangeDisabled({
          picker,
          selectedValue,
          locale: locale2,
          disabled: mergedDisabled,
          disabledDate,
          generateConfig: generateConfig2
        }, !mergedOpen || firstTimeOpen), _useRangeDisabled2 = _slicedToArray$5(_useRangeDisabled, 2), disabledStartDate = _useRangeDisabled2[0], disabledEndDate = _useRangeDisabled2[1];
        var _useState = React.useState(0), _useState2 = _slicedToArray$5(_useState, 2), popupMinWidth = _useState2[0], setPopupMinWidth = _useState2[1];
        React.useEffect(function() {
          if (!mergedOpen && containerRef.current) {
            setPopupMinWidth(containerRef.current.offsetWidth);
          }
        }, [mergedOpen]);
        function triggerOpenAndFocus(index2) {
          _triggerOpen(true, index2, "open");
          wrapperRaf(function() {
            var _inputRef$current;
            var inputRef = [startInputRef, endInputRef][index2];
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          }, 0);
        }
        function triggerChange(newValue, sourceIndex) {
          var values = newValue;
          var startValue = getValue(values, 0);
          var endValue = getValue(values, 1);
          if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
            if (
              // WeekPicker only compare week
              picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || // QuotaPicker only compare week
              picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || // Other non-TimePicker compare date
              picker !== "week" && picker !== "quarter" && picker !== "time" && !isSameDate(generateConfig2, startValue, endValue)
            ) {
              if (sourceIndex === 0) {
                values = [startValue, null];
                endValue = null;
              } else {
                startValue = null;
                values = [null, endValue];
              }
            } else if (picker !== "time" || order !== false) {
              values = reorderValues(values, generateConfig2);
            }
          }
          setSelectedValue(values);
          var startStr2 = values && values[0] ? formatValue(values[0], {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList[0]
          }) : "";
          var endStr2 = values && values[1] ? formatValue(values[1], {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList[0]
          }) : "";
          if (onCalendarChange) {
            var _info = {
              range: sourceIndex === 0 ? "start" : "end"
            };
            onCalendarChange(values, [startStr2, endStr2], _info);
          }
          var canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled, allowEmpty);
          var canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled, allowEmpty);
          var canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
          if (canTrigger) {
            setInnerValue(values);
            if (onChange && (!isEqual(generateConfig2, getValue(mergedValue, 0), startValue) || !isEqual(generateConfig2, getValue(mergedValue, 1), endValue))) {
              onChange(values, [startStr2, endStr2]);
            }
          }
        }
        var forwardKeyDown = function forwardKeyDown2(e2) {
          if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
            return operationRef.current.onKeyDown(e2);
          }
          {
            warningOnce(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
            return false;
          }
        };
        var sharedTextHooksProps = {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        };
        var _useValueTexts = useValueTexts(getValue(selectedValue, 0), sharedTextHooksProps), _useValueTexts2 = _slicedToArray$5(_useValueTexts, 2), startValueTexts = _useValueTexts2[0], firstStartValueText = _useValueTexts2[1];
        var _useValueTexts3 = useValueTexts(getValue(selectedValue, 1), sharedTextHooksProps), _useValueTexts4 = _slicedToArray$5(_useValueTexts3, 2), endValueTexts = _useValueTexts4[0], firstEndValueText = _useValueTexts4[1];
        var _onTextChange = function onTextChange(newText, index2) {
          var inputDate = parseValue(newText, {
            locale: locale2,
            formatList,
            generateConfig: generateConfig2
          });
          var disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
          if (inputDate && !disabledFunc(inputDate)) {
            setSelectedValue(updateValues(selectedValue, inputDate, index2));
            setViewDate(inputDate, index2);
          }
        };
        var _useTextValueMapping = useTextValueMapping({
          valueTexts: startValueTexts,
          onTextChange: function onTextChange(newText) {
            return _onTextChange(newText, 0);
          }
        }), _useTextValueMapping2 = _slicedToArray$5(_useTextValueMapping, 3), startText = _useTextValueMapping2[0], triggerStartTextChange = _useTextValueMapping2[1], resetStartText = _useTextValueMapping2[2];
        var _useTextValueMapping3 = useTextValueMapping({
          valueTexts: endValueTexts,
          onTextChange: function onTextChange(newText) {
            return _onTextChange(newText, 1);
          }
        }), _useTextValueMapping4 = _slicedToArray$5(_useTextValueMapping3, 3), endText = _useTextValueMapping4[0], triggerEndTextChange = _useTextValueMapping4[1], resetEndText = _useTextValueMapping4[2];
        var _useState3 = React.useState(null), _useState4 = _slicedToArray$5(_useState3, 2), rangeHoverValue = _useState4[0], setRangeHoverValue = _useState4[1];
        var _useState5 = React.useState(null), _useState6 = _slicedToArray$5(_useState5, 2), hoverRangedValue = _useState6[0], setHoverRangedValue = _useState6[1];
        var _useHoverValue = useHoverValue(startText, {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        }), _useHoverValue2 = _slicedToArray$5(_useHoverValue, 3), startHoverValue = _useHoverValue2[0], onStartEnter = _useHoverValue2[1], onStartLeave = _useHoverValue2[2];
        var _useHoverValue3 = useHoverValue(endText, {
          formatList,
          generateConfig: generateConfig2,
          locale: locale2
        }), _useHoverValue4 = _slicedToArray$5(_useHoverValue3, 3), endHoverValue = _useHoverValue4[0], onEndEnter = _useHoverValue4[1], onEndLeave = _useHoverValue4[2];
        var onDateMouseEnter = function onDateMouseEnter2(date2) {
          setHoverRangedValue(updateValues(selectedValue, date2, mergedActivePickerIndex));
          if (mergedActivePickerIndex === 0) {
            onStartEnter(date2);
          } else {
            onEndEnter(date2);
          }
        };
        var onDateMouseLeave = function onDateMouseLeave2() {
          setHoverRangedValue(updateValues(selectedValue, null, mergedActivePickerIndex));
          if (mergedActivePickerIndex === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        };
        var _React$useState = React__namespace.useState(mergedOpen), _React$useState2 = _slicedToArray$5(_React$useState, 2), delayOpen = _React$useState2[0], setDelayOpen = _React$useState2[1];
        React__namespace.useEffect(function() {
          setDelayOpen(mergedOpen);
        }, [mergedOpen]);
        var onInternalBlur = function onInternalBlur2(e2) {
          if (changeOnBlur && delayOpen) {
            var selectedIndexValue = getValue(selectedValue, mergedActivePickerIndex);
            if (selectedIndexValue) {
              triggerChange(selectedValue, mergedActivePickerIndex);
            }
          }
          return onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
        };
        var getSharedInputHookProps = function getSharedInputHookProps2(index2, resetText) {
          return {
            blurToCancel: !changeOnBlur && needConfirmButton,
            forwardKeyDown,
            onBlur: onInternalBlur,
            isClickOutside: function isClickOutside(target) {
              return !elementsContains([panelDivRef.current, startInputDivRef.current, endInputDivRef.current, containerRef.current], target);
            },
            onFocus: function onFocus(e2) {
              if (_onFocus) {
                _onFocus(e2);
              }
            },
            triggerOpen: function triggerOpen(newOpen) {
              if (newOpen) {
                _triggerOpen(newOpen, index2, "open");
              } else {
                _triggerOpen(
                  newOpen,
                  // Close directly if no selected value provided
                  getValue(selectedValue, index2) ? index2 : false,
                  "blur"
                );
              }
            },
            onSubmit: function onSubmit() {
              if (
                // When user typing disabledDate with keyboard and enter, this value will be empty
                !selectedValue || // Normal disabled check
                disabledDate && disabledDate(selectedValue[index2])
              ) {
                return false;
              }
              triggerChange(selectedValue, index2);
              resetText();
              _triggerOpen(false, mergedActivePickerIndex, "confirm");
            },
            onCancel: function onCancel() {
              _triggerOpen(false, index2, "cancel");
              setSelectedValue(mergedValue);
              resetText();
            }
          };
        };
        var sharedPickerInput = {
          onKeyDown: function onKeyDown(e2, preventDefault) {
            _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(e2, preventDefault);
          },
          changeOnBlur
        };
        var _usePickerInput = usePickerInput(_objectSpread2(_objectSpread2({}, getSharedInputHookProps(0, resetStartText)), {}, {
          open: startOpen,
          value: startText
        }, sharedPickerInput)), _usePickerInput2 = _slicedToArray$5(_usePickerInput, 2), startInputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], startFocused = _usePickerInput2$.focused, startTyping = _usePickerInput2$.typing;
        var _usePickerInput3 = usePickerInput(_objectSpread2(_objectSpread2({}, getSharedInputHookProps(1, resetEndText)), {}, {
          open: endOpen,
          value: endText
        }, sharedPickerInput)), _usePickerInput4 = _slicedToArray$5(_usePickerInput3, 2), endInputProps = _usePickerInput4[0], _usePickerInput4$ = _usePickerInput4[1], endFocused = _usePickerInput4$.focused, endTyping = _usePickerInput4$.typing;
        var onPickerClick = function onPickerClick2(e2) {
          if (onClick) {
            onClick(e2);
          }
          if (!mergedOpen && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
            if (!mergedDisabled[0]) {
              triggerOpenAndFocus(0);
            } else if (!mergedDisabled[1]) {
              triggerOpenAndFocus(1);
            }
          }
        };
        var onPickerMouseDown = function onPickerMouseDown2(e2) {
          if (onMouseDown) {
            onMouseDown(e2);
          }
          if (mergedOpen && (startFocused || endFocused) && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
            e2.preventDefault();
          }
        };
        var startStr = mergedValue && mergedValue[0] ? formatValue(mergedValue[0], {
          locale: locale2,
          format: "YYYYMMDDHHmmss",
          generateConfig: generateConfig2
        }) : "";
        var endStr = mergedValue && mergedValue[1] ? formatValue(mergedValue[1], {
          locale: locale2,
          format: "YYYYMMDDHHmmss",
          generateConfig: generateConfig2
        }) : "";
        React.useEffect(function() {
          if (!mergedOpen) {
            setSelectedValue(mergedValue);
            if (!startValueTexts.length || startValueTexts[0] === "") {
              triggerStartTextChange("");
            } else if (firstStartValueText !== startText) {
              resetStartText();
            }
            if (!endValueTexts.length || endValueTexts[0] === "") {
              triggerEndTextChange("");
            } else if (firstEndValueText !== endText) {
              resetEndText();
            }
          }
        }, [mergedOpen, startValueTexts, endValueTexts]);
        React.useEffect(function() {
          setSelectedValue(mergedValue);
        }, [startStr, endStr]);
        var mergedCellRender = useCellRender({
          cellRender,
          monthCellRender,
          dateRender
        });
        var panelDateRender = React__namespace.useMemo(function() {
          if (!mergedCellRender)
            return void 0;
          return function(date2, info) {
            return mergedCellRender(date2, _objectSpread2(_objectSpread2({}, info), {}, {
              range: mergedActivePickerIndex ? "end" : "start"
            }));
          };
        }, [mergedActivePickerIndex, mergedCellRender]);
        if (pickerRef) {
          pickerRef.current = {
            focus: function focus() {
              if (startInputRef.current) {
                startInputRef.current.focus();
              }
            },
            blur: function blur() {
              if (startInputRef.current) {
                startInputRef.current.blur();
              }
              if (endInputRef.current) {
                endInputRef.current.blur();
              }
            }
          };
        }
        var presetList = usePresets(presets, ranges);
        function renderPanel() {
          var panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var panelHoverRangedValue = null;
          if (mergedOpen && hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1] && generateConfig2.isAfter(hoverRangedValue[1], hoverRangedValue[0])) {
            panelHoverRangedValue = hoverRangedValue;
          }
          var panelShowTime = showTime;
          if (showTime && _typeof$3(showTime) === "object" && showTime.defaultValue) {
            var timeDefaultValues = showTime.defaultValue;
            panelShowTime = _objectSpread2(_objectSpread2({}, showTime), {}, {
              defaultValue: getValue(timeDefaultValues, mergedActivePickerIndex) || void 0
            });
          }
          return /* @__PURE__ */ React__namespace.createElement(RangeContext.Provider, {
            value: {
              inRange: true,
              panelPosition,
              rangedValue: rangeHoverValue || selectedValue,
              hoverRangedValue: panelHoverRangedValue
            }
          }, /* @__PURE__ */ React__namespace.createElement(PickerPanel, _extends$1({}, props, panelProps, {
            cellRender: panelDateRender,
            showTime: panelShowTime,
            mode: mergedModes[mergedActivePickerIndex],
            generateConfig: generateConfig2,
            style: void 0,
            direction,
            disabledDate: mergedActivePickerIndex === 0 ? disabledStartDate : disabledEndDate,
            disabledTime: function disabledTime(date2) {
              if (_disabledTime) {
                return _disabledTime(date2, mergedActivePickerIndex === 0 ? "start" : "end");
              }
              return false;
            },
            className: classNames(_defineProperty$3({}, "".concat(prefixCls, "-panel-focused"), mergedActivePickerIndex === 0 ? !startTyping : !endTyping)),
            value: getValue(selectedValue, mergedActivePickerIndex),
            locale: locale2,
            tabIndex: -1,
            onPanelChange: function onPanelChange2(date2, newMode) {
              if (mergedActivePickerIndex === 0) {
                onStartLeave(true);
              }
              if (mergedActivePickerIndex === 1) {
                onEndLeave(true);
              }
              triggerModesChange(updateValues(mergedModes, newMode, mergedActivePickerIndex), updateValues(selectedValue, date2, mergedActivePickerIndex));
              var viewDate = date2;
              if (panelPosition === "right" && mergedModes[mergedActivePickerIndex] === newMode) {
                viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
              }
              setViewDate(viewDate, mergedActivePickerIndex);
            },
            onOk: null,
            onSelect: void 0,
            onChange: void 0,
            defaultValue: mergedActivePickerIndex === 0 ? getValue(selectedValue, 1) : getValue(selectedValue, 0)
            // defaultPickerValue={undefined}
          })));
        }
        var arrowLeft = 0;
        var panelLeft = 0;
        if (mergedActivePickerIndex && startInputDivRef.current && separatorRef.current && panelDivRef.current && arrowRef.current) {
          arrowLeft = startInputDivRef.current.offsetWidth + separatorRef.current.offsetWidth;
          var arrowMarginLeft = arrowRef.current.offsetLeft > arrowLeft ? arrowRef.current.offsetLeft - arrowLeft : arrowRef.current.offsetLeft;
          var panelWidth = panelDivRef.current.offsetWidth;
          var arrowWidth = arrowRef.current.offsetWidth;
          if (panelWidth && arrowWidth && arrowLeft > panelWidth - arrowWidth - (direction === "rtl" ? 0 : arrowMarginLeft)) {
            panelLeft = arrowLeft;
          }
        }
        var arrowPositionStyle = direction === "rtl" ? {
          right: arrowLeft
        } : {
          left: arrowLeft
        };
        function renderPanels() {
          var panels;
          var extraNode = getExtraFooter(prefixCls, mergedModes[mergedActivePickerIndex], renderExtraFooter);
          var rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton,
            okDisabled: !getValue(selectedValue, mergedActivePickerIndex) || disabledDate && disabledDate(selectedValue[mergedActivePickerIndex]),
            locale: locale2,
            // rangeList,
            onOk: function onOk() {
              var selectedIndexValue = getValue(selectedValue, mergedActivePickerIndex);
              if (selectedIndexValue) {
                triggerChange(selectedValue, mergedActivePickerIndex);
                _onOk === null || _onOk === void 0 ? void 0 : _onOk(selectedValue);
                _triggerOpen(false, mergedActivePickerIndex, "confirm");
              }
            }
          });
          if (picker !== "time" && !showTime) {
            var viewDate = getViewDate(mergedActivePickerIndex);
            var nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
            var currentMode = mergedModes[mergedActivePickerIndex];
            var showDoublePanel = currentMode === picker;
            var leftPanel = renderPanel(showDoublePanel ? "left" : false, {
              pickerValue: viewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(newViewDate, mergedActivePickerIndex);
              }
            });
            var rightPanel = renderPanel("right", {
              pickerValue: nextViewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex);
              }
            });
            if (direction === "rtl") {
              panels = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, rightPanel, showDoublePanel && leftPanel);
            } else {
              panels = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, leftPanel, showDoublePanel && rightPanel);
            }
          } else {
            panels = renderPanel();
          }
          var mergedNodes = /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(prefixCls, "-panel-layout")
          }, /* @__PURE__ */ React__namespace.createElement(PresetPanel, {
            prefixCls,
            presets: presetList,
            onClick: function onClick2(nextValue) {
              triggerChange(nextValue, null);
              _triggerOpen(false, mergedActivePickerIndex, "preset");
            },
            onHover: function onHover(hoverValue) {
              setRangeHoverValue(hoverValue);
            }
          }), /* @__PURE__ */ React__namespace.createElement("div", null, /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(prefixCls, "-panels")
          }, panels), (extraNode || rangesNode) && /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(prefixCls, "-footer")
          }, extraNode, rangesNode)));
          if (panelRender) {
            mergedNodes = panelRender(mergedNodes);
          }
          return /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(prefixCls, "-panel-container"),
            style: {
              marginLeft: panelLeft
            },
            ref: panelDivRef,
            onMouseDown: function onMouseDown2(e2) {
              e2.preventDefault();
            }
          }, mergedNodes);
        }
        var rangePanel = /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper")),
          style: {
            minWidth: popupMinWidth
          }
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          ref: arrowRef,
          className: "".concat(prefixCls, "-range-arrow"),
          style: arrowPositionStyle
        }), renderPanels());
        var suffixNode;
        if (suffixIcon) {
          suffixNode = /* @__PURE__ */ React__namespace.createElement("span", {
            className: "".concat(prefixCls, "-suffix"),
            onMouseDown: function onMouseDown2(e2) {
              e2.preventDefault();
            }
          }, suffixIcon);
        }
        var clearNode;
        if (allowClear && (getValue(mergedValue, 0) && !mergedDisabled[0] || getValue(mergedValue, 1) && !mergedDisabled[1])) {
          clearNode = /* @__PURE__ */ React__namespace.createElement("span", {
            onMouseDown: function onMouseDown2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            onMouseUp: function onMouseUp2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              var values = mergedValue;
              if (!mergedDisabled[0]) {
                values = updateValues(values, null, 0);
              }
              if (!mergedDisabled[1]) {
                values = updateValues(values, null, 1);
              }
              triggerChange(values, null);
              _triggerOpen(false, mergedActivePickerIndex, "clear");
            },
            className: "".concat(prefixCls, "-clear")
          }, clearIcon || /* @__PURE__ */ React__namespace.createElement("span", {
            className: "".concat(prefixCls, "-clear-btn")
          }));
        }
        var inputSharedProps = {
          size: getInputSize(picker, formatList[0], generateConfig2)
        };
        var activeBarLeft = 0;
        var activeBarWidth = 0;
        if (startInputDivRef.current && endInputDivRef.current && separatorRef.current) {
          if (mergedActivePickerIndex === 0) {
            activeBarWidth = startInputDivRef.current.offsetWidth;
          } else {
            activeBarLeft = arrowLeft;
            activeBarWidth = endInputDivRef.current.offsetWidth;
          }
        }
        var activeBarPositionStyle = direction === "rtl" ? {
          right: activeBarLeft
        } : {
          left: activeBarLeft
        };
        var onContextSelect = function onContextSelect2(date2, type2) {
          var values = updateValues(selectedValue, date2, mergedActivePickerIndex);
          if (type2 === "submit" || type2 !== "key" && !needConfirmButton) {
            triggerChange(values, mergedActivePickerIndex);
            if (mergedActivePickerIndex === 0) {
              onStartLeave();
            } else {
              onEndLeave();
            }
            var nextActivePickerIndex = mergedActivePickerIndex === 0 ? 1 : 0;
            if (mergedDisabled[nextActivePickerIndex]) {
              _triggerOpen(false, false, "confirm");
            } else {
              _triggerOpen(false, mergedActivePickerIndex, "confirm");
            }
          } else {
            setSelectedValue(values);
          }
        };
        return /* @__PURE__ */ React__namespace.createElement(PanelContext.Provider, {
          value: {
            operationRef,
            hideHeader: picker === "time",
            onDateMouseEnter,
            onDateMouseLeave,
            hideRanges: true,
            onSelect: onContextSelect,
            open: mergedOpen
          }
        }, /* @__PURE__ */ React__namespace.createElement(PickerTrigger, {
          visible: mergedOpen,
          popupElement: rangePanel,
          popupStyle,
          prefixCls,
          dropdownClassName,
          dropdownAlign,
          getPopupContainer,
          transitionName,
          range: true,
          direction
        }, /* @__PURE__ */ React__namespace.createElement("div", _extends$1({
          ref: containerRef,
          className: classNames(prefixCls, "".concat(prefixCls, "-range"), className, (_classNames2 = {}, _defineProperty$3(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled[0] && mergedDisabled[1]), _defineProperty$3(_classNames2, "".concat(prefixCls, "-focused"), mergedActivePickerIndex === 0 ? startFocused : endFocused), _defineProperty$3(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
          style: style2,
          onClick: onPickerClick,
          onMouseEnter,
          onMouseLeave,
          onMouseDown: onPickerMouseDown,
          onMouseUp
        }, pickAttrs(props, {
          aria: true,
          data: true
        })), /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames("".concat(prefixCls, "-input"), (_classNames3 = {}, _defineProperty$3(_classNames3, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 0), _defineProperty$3(_classNames3, "".concat(prefixCls, "-input-placeholder"), !!startHoverValue), _classNames3)),
          ref: startInputDivRef
        }, /* @__PURE__ */ React__namespace.createElement("input", _extends$1({
          id,
          disabled: mergedDisabled[0],
          readOnly: inputReadOnly || typeof formatList[0] === "function" || !startTyping,
          value: startHoverValue || startText,
          onChange: function onChange2(e2) {
            triggerStartTextChange(e2.target.value);
          },
          autoFocus,
          placeholder: getValue(placeholder, 0) || "",
          ref: startInputRef
        }, startInputProps, inputSharedProps, {
          autoComplete
        }))), /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-range-separator"),
          ref: separatorRef
        }, separator), /* @__PURE__ */ React__namespace.createElement("div", {
          className: classNames("".concat(prefixCls, "-input"), (_classNames4 = {}, _defineProperty$3(_classNames4, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 1), _defineProperty$3(_classNames4, "".concat(prefixCls, "-input-placeholder"), !!endHoverValue), _classNames4)),
          ref: endInputDivRef
        }, /* @__PURE__ */ React__namespace.createElement("input", _extends$1({
          disabled: mergedDisabled[1],
          readOnly: inputReadOnly || typeof formatList[0] === "function" || !endTyping,
          value: endHoverValue || endText,
          onChange: function onChange2(e2) {
            triggerEndTextChange(e2.target.value);
          },
          placeholder: getValue(placeholder, 1) || "",
          ref: endInputRef
        }, endInputProps, inputSharedProps, {
          autoComplete
        }))), /* @__PURE__ */ React__namespace.createElement("div", {
          className: "".concat(prefixCls, "-active-bar"),
          style: _objectSpread2(_objectSpread2({}, activeBarPositionStyle), {}, {
            width: activeBarWidth,
            position: "absolute"
          })
        }), suffixNode, clearNode)));
      }
      var RangePicker = /* @__PURE__ */ function(_React$Component) {
        _inherits(RangePicker2, _React$Component);
        var _super = _createSuper(RangePicker2);
        function RangePicker2() {
          var _this;
          _classCallCheck$1(this, RangePicker2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty$3(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ React__namespace.createRef());
          _defineProperty$3(_assertThisInitialized(_this), "focus", function() {
            if (_this.pickerRef.current) {
              _this.pickerRef.current.focus();
            }
          });
          _defineProperty$3(_assertThisInitialized(_this), "blur", function() {
            if (_this.pickerRef.current) {
              _this.pickerRef.current.blur();
            }
          });
          return _this;
        }
        _createClass$1(RangePicker2, [{
          key: "render",
          value: function render2() {
            return /* @__PURE__ */ React__namespace.createElement(InnerRangePicker, _extends$1({}, this.props, {
              pickerRef: this.pickerRef
            }));
          }
        }]);
        return RangePicker2;
      }(React__namespace.Component);
      const genPlaceholderStyle = (color) => ({
        // Firefox
        "&::-moz-placeholder": {
          opacity: 1
        },
        "&::placeholder": {
          color,
          userSelect: "none"
          // https://github.com/ant-design/ant-design/pull/32639
        },
        "&:placeholder-shown": {
          textOverflow: "ellipsis"
        }
      });
      const genHoverStyle = (token2) => ({
        borderColor: token2.inputBorderHoverColor,
        borderInlineEndWidth: token2.lineWidth
      });
      const genActiveStyle = (token2) => ({
        borderColor: token2.inputBorderHoverColor,
        boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
        borderInlineEndWidth: token2.lineWidth,
        outline: 0
      });
      const genDisabledStyle = (token2) => ({
        color: token2.colorTextDisabled,
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        boxShadow: "none",
        cursor: "not-allowed",
        opacity: 1,
        "&:hover": Object.assign({}, genHoverStyle(merge(token2, {
          inputBorderHoverColor: token2.colorBorder
        })))
      });
      const genInputLargeStyle = (token2) => {
        const {
          inputPaddingVerticalLG,
          fontSizeLG,
          lineHeightLG,
          borderRadiusLG,
          inputPaddingHorizontalLG
        } = token2;
        return {
          padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          borderRadius: borderRadiusLG
        };
      };
      const genInputSmallStyle = (token2) => ({
        padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
        borderRadius: token2.borderRadiusSM
      });
      const genStatusStyle = (token2, parentCls) => {
        const {
          componentCls,
          colorError,
          colorWarning,
          colorErrorOutline,
          colorWarningOutline,
          colorErrorBorderHover,
          colorWarningBorderHover
        } = token2;
        return {
          [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
            borderColor: colorError,
            "&:hover": {
              borderColor: colorErrorBorderHover
            },
            "&:focus, &-focused": Object.assign({}, genActiveStyle(merge(token2, {
              inputBorderActiveColor: colorError,
              inputBorderHoverColor: colorError,
              controlOutline: colorErrorOutline
            }))),
            [`${componentCls}-prefix, ${componentCls}-suffix`]: {
              color: colorError
            }
          },
          [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
            borderColor: colorWarning,
            "&:hover": {
              borderColor: colorWarningBorderHover
            },
            "&:focus, &-focused": Object.assign({}, genActiveStyle(merge(token2, {
              inputBorderActiveColor: colorWarning,
              inputBorderHoverColor: colorWarning,
              controlOutline: colorWarningOutline
            }))),
            [`${componentCls}-prefix, ${componentCls}-suffix`]: {
              color: colorWarning
            }
          }
        };
      };
      const genBasicInputStyle = (token2) => Object.assign(Object.assign({
        position: "relative",
        display: "inline-block",
        width: "100%",
        minWidth: 0,
        padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
        color: token2.colorText,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        backgroundColor: token2.colorBgContainer,
        backgroundImage: "none",
        borderWidth: token2.lineWidth,
        borderStyle: token2.lineType,
        borderColor: token2.colorBorder,
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationMid}`
      }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
        "&:hover": Object.assign({}, genHoverStyle(token2)),
        "&:focus, &-focused": Object.assign({}, genActiveStyle(token2)),
        "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
        "&-borderless": {
          "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
            backgroundColor: "transparent",
            border: "none",
            boxShadow: "none"
          }
        },
        // Reset height for `textarea`s
        "textarea&": {
          maxWidth: "100%",
          height: "auto",
          minHeight: token2.controlHeight,
          lineHeight: token2.lineHeight,
          verticalAlign: "bottom",
          transition: `all ${token2.motionDurationSlow}, height 0s`,
          resize: "vertical"
        },
        // Size
        "&-lg": Object.assign({}, genInputLargeStyle(token2)),
        "&-sm": Object.assign({}, genInputSmallStyle(token2)),
        // RTL
        "&-rtl": {
          direction: "rtl"
        },
        "&-textarea-rtl": {
          direction: "rtl"
        }
      });
      const genInputGroupStyle = (token2) => {
        const {
          componentCls,
          antCls
        } = token2;
        return {
          position: "relative",
          display: "table",
          width: "100%",
          borderCollapse: "separate",
          borderSpacing: 0,
          // Undo padding and float of grid classes
          [`&[class*='col-']`]: {
            paddingInlineEnd: token2.paddingXS,
            "&:last-child": {
              paddingInlineEnd: 0
            }
          },
          // Sizing options
          [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
          [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
          // Fix https://github.com/ant-design/ant-design/issues/5754
          [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
            height: token2.controlHeightLG
          },
          [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
            height: token2.controlHeightSM
          },
          [`> ${componentCls}`]: {
            display: "table-cell",
            "&:not(:first-child):not(:last-child)": {
              borderRadius: 0
            }
          },
          [`${componentCls}-group`]: {
            [`&-addon, &-wrap`]: {
              display: "table-cell",
              width: 1,
              whiteSpace: "nowrap",
              verticalAlign: "middle",
              "&:not(:first-child):not(:last-child)": {
                borderRadius: 0
              }
            },
            "&-wrap > *": {
              display: "block !important"
            },
            "&-addon": {
              position: "relative",
              padding: `0 ${token2.inputPaddingHorizontal}px`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize: token2.fontSize,
              textAlign: "center",
              backgroundColor: token2.colorFillAlter,
              border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadius,
              transition: `all ${token2.motionDurationSlow}`,
              lineHeight: 1,
              // Reset Select's style in addon
              [`${antCls}-select`]: {
                margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
                [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
                  [`${antCls}-select-selector`]: {
                    backgroundColor: "inherit",
                    border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                    boxShadow: "none"
                  }
                },
                "&-open, &-focused": {
                  [`${antCls}-select-selector`]: {
                    color: token2.colorPrimary
                  }
                }
              },
              // https://github.com/ant-design/ant-design/issues/31333
              [`${antCls}-cascader-picker`]: {
                margin: `-9px -${token2.inputPaddingHorizontal}px`,
                backgroundColor: "transparent",
                [`${antCls}-cascader-input`]: {
                  textAlign: "start",
                  border: 0,
                  boxShadow: "none"
                }
              }
            },
            "&-addon:first-child": {
              borderInlineEnd: 0
            },
            "&-addon:last-child": {
              borderInlineStart: 0
            }
          },
          [`${componentCls}`]: {
            width: "100%",
            marginBottom: 0,
            textAlign: "inherit",
            "&:focus": {
              zIndex: 1,
              borderInlineEndWidth: 1
            },
            "&:hover": {
              zIndex: 1,
              borderInlineEndWidth: 1,
              [`${componentCls}-search-with-button &`]: {
                zIndex: 0
              }
            }
          },
          // Reset rounded corners
          [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            // Reset Select's style in addon
            [`${antCls}-select ${antCls}-select-selector`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`> ${componentCls}-affix-wrapper`]: {
            [`&:not(:first-child) ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            },
            [`&:not(:last-child) ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0,
            // Reset Select's style in addon
            [`${antCls}-select ${antCls}-select-selector`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            "&:not(:last-child)": {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              [`${componentCls}-search &`]: {
                borderStartStartRadius: token2.borderRadius,
                borderEndStartRadius: token2.borderRadius
              }
            },
            [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          },
          [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
            display: "block"
          }, clearFix()), {
            [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
              "&:not(:first-child):not(:last-child)": {
                borderInlineEndWidth: token2.lineWidth,
                "&:hover": {
                  zIndex: 1
                },
                "&:focus": {
                  zIndex: 1
                }
              }
            },
            "& > *": {
              display: "inline-block",
              float: "none",
              verticalAlign: "top",
              borderRadius: 0
            },
            [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
              display: "inline-flex"
            },
            "& > *:not(:last-child)": {
              marginInlineEnd: -token2.lineWidth,
              borderInlineEndWidth: token2.lineWidth
            },
            // Undo float for .ant-input-group .ant-input
            [`${componentCls}`]: {
              float: "none"
            },
            // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
            [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
              borderInlineEndWidth: token2.lineWidth,
              borderRadius: 0,
              "&:hover": {
                zIndex: 1
              },
              "&:focus": {
                zIndex: 1
              }
            },
            [`& > ${antCls}-select-focused`]: {
              zIndex: 1
            },
            // update z-index for arrow icon
            [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
              zIndex: 1
              // https://github.com/ant-design/ant-design/issues/20371
            },
            [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
              borderStartStartRadius: token2.borderRadius,
              borderEndStartRadius: token2.borderRadius
            },
            [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
              borderInlineEndWidth: token2.lineWidth,
              borderStartEndRadius: token2.borderRadius,
              borderEndEndRadius: token2.borderRadius
            },
            // https://github.com/ant-design/ant-design/issues/12493
            [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
              verticalAlign: "top"
            },
            [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
              marginInlineStart: -token2.lineWidth,
              [`${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`${componentCls}-group-wrapper:not(:last-child)`]: {
              [`&${componentCls}-search > ${componentCls}-group`]: {
                [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                  borderRadius: 0
                },
                [`& > ${componentCls}`]: {
                  borderStartStartRadius: token2.borderRadius,
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                  borderEndStartRadius: token2.borderRadius
                }
              }
            }
          })
        };
      };
      const genInputStyle = (token2) => {
        const {
          componentCls,
          controlHeightSM,
          lineWidth
        } = token2;
        const FIXED_CHROME_COLOR_HEIGHT = 16;
        const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
        return {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
            '&[type="color"]': {
              height: token2.controlHeight,
              [`&${componentCls}-lg`]: {
                height: token2.controlHeightLG
              },
              [`&${componentCls}-sm`]: {
                height: controlHeightSM,
                paddingTop: colorSmallPadding,
                paddingBottom: colorSmallPadding
              }
            },
            '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
              "-webkit-appearance": "none"
            }
          })
        };
      };
      const genAllowClearStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          // ========================= Input =========================
          [`${componentCls}-clear-icon`]: {
            margin: 0,
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            verticalAlign: -1,
            // https://github.com/ant-design/ant-design/pull/18151
            // https://codesandbox.io/s/wizardly-sun-u10br
            cursor: "pointer",
            transition: `color ${token2.motionDurationSlow}`,
            "&:hover": {
              color: token2.colorTextTertiary
            },
            "&:active": {
              color: token2.colorText
            },
            "&-hidden": {
              visibility: "hidden"
            },
            "&-has-suffix": {
              margin: `0 ${token2.inputAffixPadding}px`
            }
          }
        };
      };
      const genAffixStyle = (token2) => {
        const {
          componentCls,
          inputAffixPadding,
          colorTextDescription,
          motionDurationSlow,
          colorIcon,
          colorIconHover,
          iconCls
        } = token2;
        return {
          [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
            display: "inline-flex",
            [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
              zIndex: 1,
              [`${componentCls}-search-with-button &`]: {
                zIndex: 0
              }
            }),
            "&-focused, &:focus": {
              zIndex: 1
            },
            "&-disabled": {
              [`${componentCls}[disabled]`]: {
                background: "transparent"
              }
            },
            [`> input${componentCls}`]: {
              padding: 0,
              fontSize: "inherit",
              border: "none",
              borderRadius: 0,
              outline: "none",
              "&::-ms-reveal": {
                display: "none"
              },
              "&:focus": {
                boxShadow: "none !important"
              }
            },
            "&::before": {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"'
            },
            [`${componentCls}`]: {
              "&-prefix, &-suffix": {
                display: "flex",
                flex: "none",
                alignItems: "center",
                "> *:not(:last-child)": {
                  marginInlineEnd: token2.paddingXS
                }
              },
              "&-show-count-suffix": {
                color: colorTextDescription
              },
              "&-show-count-has-suffix": {
                marginInlineEnd: token2.paddingXXS
              },
              "&-prefix": {
                marginInlineEnd: inputAffixPadding
              },
              "&-suffix": {
                marginInlineStart: inputAffixPadding
              }
            }
          }), genAllowClearStyle(token2)), {
            // password
            [`${iconCls}${componentCls}-password-icon`]: {
              color: colorIcon,
              cursor: "pointer",
              transition: `all ${motionDurationSlow}`,
              "&:hover": {
                color: colorIconHover
              }
            }
          }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
        };
      };
      const genGroupStyle = (token2) => {
        const {
          componentCls,
          colorError,
          colorWarning,
          borderRadiusLG,
          borderRadiusSM
        } = token2;
        return {
          [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
            "&-rtl": {
              direction: "rtl"
            },
            "&-wrapper": {
              display: "inline-block",
              width: "100%",
              textAlign: "start",
              verticalAlign: "top",
              "&-rtl": {
                direction: "rtl"
              },
              // Size
              "&-lg": {
                [`${componentCls}-group-addon`]: {
                  borderRadius: borderRadiusLG
                }
              },
              "&-sm": {
                [`${componentCls}-group-addon`]: {
                  borderRadius: borderRadiusSM
                }
              },
              // Status
              "&-status-error": {
                [`${componentCls}-group-addon`]: {
                  color: colorError,
                  borderColor: colorError
                }
              },
              "&-status-warning": {
                [`${componentCls}-group-addon`]: {
                  color: colorWarning,
                  borderColor: colorWarning
                }
              },
              "&-disabled": {
                [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
              },
              // Fix the issue of using icons in Space Compact mode
              // https://github.com/ant-design/ant-design/issues/42122
              [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
                [`${componentCls}, ${componentCls}-group-addon`]: {
                  borderRadius: 0
                }
              },
              [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
                [`${componentCls}, ${componentCls}-group-addon`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              },
              [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
                [`${componentCls}, ${componentCls}-group-addon`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0
                }
              }
            }
          })
        };
      };
      const genSearchInputStyle = (token2) => {
        const {
          componentCls,
          antCls
        } = token2;
        const searchPrefixCls = `${componentCls}-search`;
        return {
          [searchPrefixCls]: {
            [`${componentCls}`]: {
              "&:hover, &:focus": {
                borderColor: token2.colorPrimaryHover,
                [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                  borderInlineStartColor: token2.colorPrimaryHover
                }
              }
            },
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            },
            // fix slight height diff in Firefox:
            // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
            [`${componentCls}-lg`]: {
              lineHeight: token2.lineHeightLG - 2e-4
            },
            [`> ${componentCls}-group`]: {
              [`> ${componentCls}-group-addon:last-child`]: {
                insetInlineStart: -1,
                padding: 0,
                border: 0,
                [`${searchPrefixCls}-button`]: {
                  paddingTop: 0,
                  paddingBottom: 0,
                  borderStartStartRadius: 0,
                  borderStartEndRadius: token2.borderRadius,
                  borderEndEndRadius: token2.borderRadius,
                  borderEndStartRadius: 0
                },
                [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                  color: token2.colorTextDescription,
                  "&:hover": {
                    color: token2.colorPrimaryHover
                  },
                  "&:active": {
                    color: token2.colorPrimaryActive
                  },
                  [`&${antCls}-btn-loading::before`]: {
                    insetInlineStart: 0,
                    insetInlineEnd: 0,
                    insetBlockStart: 0,
                    insetBlockEnd: 0
                  }
                }
              }
            },
            [`${searchPrefixCls}-button`]: {
              height: token2.controlHeight,
              "&:hover, &:focus": {
                zIndex: 1
              }
            },
            [`&-large ${searchPrefixCls}-button`]: {
              height: token2.controlHeightLG
            },
            [`&-small ${searchPrefixCls}-button`]: {
              height: token2.controlHeightSM
            },
            "&-rtl": {
              direction: "rtl"
            },
            // ===================== Compact Item Customized Styles =====================
            [`&${componentCls}-compact-item`]: {
              [`&:not(${componentCls}-compact-last-item)`]: {
                [`${componentCls}-group-addon`]: {
                  [`${componentCls}-search-button`]: {
                    marginInlineEnd: -token2.lineWidth,
                    borderRadius: 0
                  }
                }
              },
              [`&:not(${componentCls}-compact-first-item)`]: {
                [`${componentCls},${componentCls}-affix-wrapper`]: {
                  borderRadius: 0
                }
              },
              [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
                "&:hover,&:focus,&:active": {
                  zIndex: 2
                }
              },
              [`> ${componentCls}-affix-wrapper-focused`]: {
                zIndex: 2
              }
            }
          }
        };
      };
      function initInputToken(token2) {
        return merge(token2, {
          inputAffixPadding: token2.paddingXXS,
          inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
          inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
          inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
          inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
          inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
          inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
          inputBorderHoverColor: token2.colorPrimaryHover,
          inputBorderActiveColor: token2.colorPrimaryHover
        });
      }
      const genTextAreaStyle = (token2) => {
        const {
          componentCls,
          paddingLG
        } = token2;
        const textareaPrefixCls = `${componentCls}-textarea`;
        return {
          [textareaPrefixCls]: {
            position: "relative",
            "&-show-count": {
              // https://github.com/ant-design/ant-design/issues/33049
              [`> ${componentCls}`]: {
                height: "100%"
              },
              [`${componentCls}-data-count`]: {
                position: "absolute",
                bottom: -token2.fontSize * token2.lineHeight,
                insetInlineEnd: 0,
                color: token2.colorTextDescription,
                whiteSpace: "nowrap",
                pointerEvents: "none"
              }
            },
            "&-allow-clear": {
              [`> ${componentCls}`]: {
                paddingInlineEnd: paddingLG
              }
            },
            [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
              [`${componentCls}`]: {
                paddingInlineEnd: paddingLG
              }
            },
            [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
              padding: 0,
              [`> textarea${componentCls}`]: {
                fontSize: "inherit",
                border: "none",
                outline: "none",
                "&:focus": {
                  boxShadow: "none !important"
                }
              },
              [`${componentCls}-suffix`]: {
                margin: 0,
                "> *:not(:last-child)": {
                  marginInline: 0
                },
                // Clear Icon
                [`${componentCls}-clear-icon`]: {
                  position: "absolute",
                  insetInlineEnd: token2.paddingXS,
                  insetBlockStart: token2.paddingXS
                },
                // Feedback Icon
                [`${textareaPrefixCls}-suffix`]: {
                  position: "absolute",
                  top: 0,
                  insetInlineEnd: token2.inputPaddingHorizontal,
                  bottom: 0,
                  zIndex: 1,
                  display: "inline-flex",
                  alignItems: "center",
                  margin: "auto",
                  pointerEvents: "none"
                }
              }
            }
          }
        };
      };
      const useStyle$2 = genComponentStyleHook("Input", (token2) => {
        const inputToken = initInputToken(token2);
        return [
          genInputStyle(inputToken),
          genTextAreaStyle(inputToken),
          genAffixStyle(inputToken),
          genGroupStyle(inputToken),
          genSearchInputStyle(inputToken),
          // =====================================================
          // ==             Space Compact                       ==
          // =====================================================
          genCompactItemStyle(inputToken)
        ];
      });
      const genPikerPadding = (token2, inputHeight, fontSize, paddingHorizontal) => {
        const {
          lineHeight
        } = token2;
        const fontHeight = Math.floor(fontSize * lineHeight) + 2;
        const paddingTop = Math.max((inputHeight - fontHeight) / 2, 0);
        const paddingBottom = Math.max(inputHeight - fontHeight - paddingTop, 0);
        return {
          padding: `${paddingTop}px ${paddingHorizontal}px ${paddingBottom}px`
        };
      };
      const genPickerCellInnerStyle = (token2) => {
        const {
          componentCls,
          pickerCellCls,
          pickerCellInnerCls,
          pickerPanelCellHeight,
          motionDurationSlow,
          borderRadiusSM,
          motionDurationMid,
          controlItemBgHover,
          lineWidth,
          lineType,
          colorPrimary,
          controlItemBgActive,
          colorTextLightSolid,
          controlHeightSM,
          pickerDateHoverRangeBorderColor,
          pickerCellBorderGap,
          pickerBasicCellHoverWithRangeColor,
          pickerPanelCellWidth,
          colorTextDisabled,
          colorBgContainerDisabled
        } = token2;
        return {
          "&::before": {
            position: "absolute",
            top: "50%",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            zIndex: 1,
            height: pickerPanelCellHeight,
            transform: "translateY(-50%)",
            transition: `all ${motionDurationSlow}`,
            content: '""'
          },
          // >>> Default
          [pickerCellInnerCls]: {
            position: "relative",
            zIndex: 2,
            display: "inline-block",
            minWidth: pickerPanelCellHeight,
            height: pickerPanelCellHeight,
            lineHeight: `${pickerPanelCellHeight}px`,
            borderRadius: borderRadiusSM,
            transition: `background ${motionDurationMid}, border ${motionDurationMid}`
          },
          // >>> Hover
          [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-range-hover-start):not(${pickerCellCls}-range-hover-end)`]: {
            [pickerCellInnerCls]: {
              background: controlItemBgHover
            }
          },
          // >>> Today
          [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              zIndex: 1,
              border: `${lineWidth}px ${lineType} ${colorPrimary}`,
              borderRadius: borderRadiusSM,
              content: '""'
            }
          },
          // >>> In Range
          [`&-in-view${pickerCellCls}-in-range`]: {
            position: "relative",
            "&::before": {
              background: controlItemBgActive
            }
          },
          // >>> Selected
          [`&-in-view${pickerCellCls}-selected ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-start ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-end ${pickerCellInnerCls}`]: {
            color: colorTextLightSolid,
            background: colorPrimary
          },
          [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single),
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)`]: {
            "&::before": {
              background: controlItemBgActive
            }
          },
          [`&-in-view${pickerCellCls}-range-start::before`]: {
            insetInlineStart: "50%"
          },
          [`&-in-view${pickerCellCls}-range-end::before`]: {
            insetInlineEnd: "50%"
          },
          // >>> Range Hover
          [`&-in-view${pickerCellCls}-range-hover-start:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-end:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start-single,
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-end-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-start-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-end-single,
      &-in-view${pickerCellCls}-range-hover:not(${pickerCellCls}-in-range)`]: {
            "&::after": {
              position: "absolute",
              top: "50%",
              zIndex: 0,
              height: controlHeightSM,
              borderTop: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              borderBottom: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              transform: "translateY(-50%)",
              transition: `all ${motionDurationSlow}`,
              content: '""'
            }
          },
          // Add space for stash
          [`&-range-hover-start::after,
      &-range-hover-end::after,
      &-range-hover::after`]: {
            insetInlineEnd: 0,
            insetInlineStart: pickerCellBorderGap
          },
          // Hover with in range
          [`&-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before,
      &-in-view${pickerCellCls}-range-start${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-end${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single)${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)${pickerCellCls}-range-hover-end::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before`]: {
            background: pickerBasicCellHoverWithRangeColor
          },
          // range start border-radius
          [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single):not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          },
          // range end border-radius
          [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single):not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0,
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          },
          [`&-range-hover${pickerCellCls}-range-end::after`]: {
            insetInlineStart: "50%"
          },
          // Edge start
          [`tr > &-in-view${pickerCellCls}-range-hover:first-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-end:first-child::after,
      &-in-view${pickerCellCls}-start${pickerCellCls}-range-hover-edge-start${pickerCellCls}-range-hover-edge-start-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-start:not(${pickerCellCls}-range-hover-edge-start-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-start::after`]: {
            insetInlineStart: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
            borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartStartRadius: lineWidth,
            borderEndStartRadius: lineWidth
          },
          // Edge end
          [`tr > &-in-view${pickerCellCls}-range-hover:last-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-start:last-child::after,
      &-in-view${pickerCellCls}-end${pickerCellCls}-range-hover-edge-end${pickerCellCls}-range-hover-edge-end-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-end:not(${pickerCellCls}-range-hover-edge-end-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-end::after`]: {
            insetInlineEnd: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
            borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartEndRadius: lineWidth,
            borderEndEndRadius: lineWidth
          },
          // >>> Disabled
          "&-disabled": {
            color: colorTextDisabled,
            pointerEvents: "none",
            [pickerCellInnerCls]: {
              background: "transparent"
            },
            "&::before": {
              background: colorBgContainerDisabled
            }
          },
          [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
            borderColor: colorTextDisabled
          }
        };
      };
      const genPanelStyle = (token2) => {
        const {
          componentCls,
          pickerCellCls,
          pickerCellInnerCls,
          pickerYearMonthCellWidth,
          pickerControlIconSize,
          pickerPanelCellWidth,
          paddingSM,
          paddingXS,
          paddingXXS,
          colorBgContainer,
          lineWidth,
          lineType,
          borderRadiusLG,
          colorPrimary,
          colorTextHeading,
          colorSplit,
          pickerControlIconBorderWidth,
          colorIcon,
          pickerTextHeight,
          motionDurationMid,
          colorIconHover,
          fontWeightStrong,
          pickerPanelCellHeight,
          pickerCellPaddingVertical,
          colorTextDisabled,
          colorText,
          fontSize,
          pickerBasicCellHoverWithRangeColor,
          motionDurationSlow,
          pickerPanelWithoutTimeCellHeight,
          pickerQuarterPanelContentHeight,
          colorLink,
          colorLinkActive,
          colorLinkHover,
          pickerDateHoverRangeBorderColor,
          borderRadiusSM,
          colorTextLightSolid,
          controlItemBgHover,
          pickerTimePanelColumnHeight,
          pickerTimePanelColumnWidth,
          pickerTimePanelCellHeight,
          controlItemBgActive,
          marginXXS,
          pickerDatePanelPaddingHorizontal
        } = token2;
        const pickerPanelWidth = pickerPanelCellWidth * 7 + pickerDatePanelPaddingHorizontal * 2;
        const commonHoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 3 - pickerYearMonthCellWidth - paddingSM;
        const quarterHoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 4 - pickerYearMonthCellWidth;
        return {
          [componentCls]: {
            "&-panel": {
              display: "inline-flex",
              flexDirection: "column",
              textAlign: "center",
              background: colorBgContainer,
              border: `${lineWidth}px ${lineType} ${colorSplit}`,
              borderRadius: borderRadiusLG,
              outline: "none",
              "&-focused": {
                borderColor: colorPrimary
              },
              "&-rtl": {
                direction: "rtl",
                [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
                  transform: "rotate(45deg)"
                },
                [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
                  transform: "rotate(-135deg)"
                }
              }
            },
            // ========================================================
            // =                     Shared Panel                     =
            // ========================================================
            [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
              display: "flex",
              flexDirection: "column",
              width: pickerPanelWidth
            },
            // ======================= Header =======================
            "&-header": {
              display: "flex",
              padding: `0 ${paddingXS}px`,
              color: colorTextHeading,
              borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
              "> *": {
                flex: "none"
              },
              button: {
                padding: 0,
                color: colorIcon,
                lineHeight: `${pickerTextHeight}px`,
                background: "transparent",
                border: 0,
                cursor: "pointer",
                transition: `color ${motionDurationMid}`,
                fontSize: "inherit"
              },
              "> button": {
                minWidth: "1.6em",
                fontSize,
                "&:hover": {
                  color: colorIconHover
                }
              },
              "&-view": {
                flex: "auto",
                fontWeight: fontWeightStrong,
                lineHeight: `${pickerTextHeight}px`,
                button: {
                  color: "inherit",
                  fontWeight: "inherit",
                  verticalAlign: "top",
                  "&:not(:first-child)": {
                    marginInlineStart: paddingXS
                  },
                  "&:hover": {
                    color: colorPrimary
                  }
                }
              }
            },
            // Arrow button
            [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
              position: "relative",
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              "&::before": {
                position: "absolute",
                top: 0,
                insetInlineStart: 0,
                display: "inline-block",
                width: pickerControlIconSize,
                height: pickerControlIconSize,
                border: `0 solid currentcolor`,
                borderBlockStartWidth: pickerControlIconBorderWidth,
                borderBlockEndWidth: 0,
                borderInlineStartWidth: pickerControlIconBorderWidth,
                borderInlineEndWidth: 0,
                content: '""'
              }
            },
            [`&-super-prev-icon,
        &-super-next-icon`]: {
              "&::after": {
                position: "absolute",
                top: Math.ceil(pickerControlIconSize / 2),
                insetInlineStart: Math.ceil(pickerControlIconSize / 2),
                display: "inline-block",
                width: pickerControlIconSize,
                height: pickerControlIconSize,
                border: "0 solid currentcolor",
                borderBlockStartWidth: pickerControlIconBorderWidth,
                borderBlockEndWidth: 0,
                borderInlineStartWidth: pickerControlIconBorderWidth,
                borderInlineEndWidth: 0,
                content: '""'
              }
            },
            [`&-prev-icon,
        &-super-prev-icon`]: {
              transform: "rotate(-45deg)"
            },
            [`&-next-icon,
        &-super-next-icon`]: {
              transform: "rotate(135deg)"
            },
            // ======================== Body ========================
            "&-content": {
              width: "100%",
              tableLayout: "fixed",
              borderCollapse: "collapse",
              "th, td": {
                position: "relative",
                minWidth: pickerPanelCellHeight,
                fontWeight: "normal"
              },
              th: {
                height: pickerPanelCellHeight + pickerCellPaddingVertical * 2,
                color: colorText,
                verticalAlign: "middle"
              }
            },
            "&-cell": Object.assign({
              padding: `${pickerCellPaddingVertical}px 0`,
              color: colorTextDisabled,
              cursor: "pointer",
              // In view
              "&-in-view": {
                color: colorText
              }
            }, genPickerCellInnerStyle(token2)),
            // DatePanel only
            [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start ${pickerCellInnerCls},
        &-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}`]: {
              "&::after": {
                position: "absolute",
                top: 0,
                bottom: 0,
                zIndex: -1,
                background: pickerBasicCellHoverWithRangeColor,
                transition: `all ${motionDurationSlow}`,
                content: '""'
              }
            },
            [`&-date-panel
        ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start
        ${pickerCellInnerCls}::after`]: {
              insetInlineEnd: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2,
              insetInlineStart: 0
            },
            [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}::after`]: {
              insetInlineEnd: 0,
              insetInlineStart: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2
            },
            // Hover with range start & end
            [`&-range-hover${componentCls}-range-start::after`]: {
              insetInlineEnd: "50%"
            },
            [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
              [`${componentCls}-content`]: {
                height: pickerPanelWithoutTimeCellHeight * 4
              },
              [pickerCellInnerCls]: {
                padding: `0 ${paddingXS}px`
              }
            },
            "&-quarter-panel": {
              [`${componentCls}-content`]: {
                height: pickerQuarterPanelContentHeight
              },
              // Quarter Panel Special Style
              [`${componentCls}-cell-range-hover-start::after`]: {
                insetInlineStart: quarterHoverCellFixedDistance,
                borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
                [`${componentCls}-panel-rtl &`]: {
                  insetInlineEnd: quarterHoverCellFixedDistance,
                  borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
                }
              },
              [`${componentCls}-cell-range-hover-end::after`]: {
                insetInlineEnd: quarterHoverCellFixedDistance,
                borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
                [`${componentCls}-panel-rtl &`]: {
                  insetInlineStart: quarterHoverCellFixedDistance,
                  borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
                }
              }
            },
            // ======================== Footer ========================
            [`&-panel ${componentCls}-footer`]: {
              borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
            },
            "&-footer": {
              width: "min-content",
              minWidth: "100%",
              lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
              textAlign: "center",
              "&-extra": {
                padding: `0 ${paddingSM}`,
                lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
                textAlign: "start",
                "&:not(:last-child)": {
                  borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
                }
              }
            },
            "&-now": {
              textAlign: "start"
            },
            "&-today-btn": {
              color: colorLink,
              "&:hover": {
                color: colorLinkHover
              },
              "&:active": {
                color: colorLinkActive
              },
              [`&${componentCls}-today-btn-disabled`]: {
                color: colorTextDisabled,
                cursor: "not-allowed"
              }
            },
            // ========================================================
            // =                       Special                        =
            // ========================================================
            // ===================== Decade Panel =====================
            "&-decade-panel": {
              [pickerCellInnerCls]: {
                padding: `0 ${paddingXS / 2}px`
              },
              [`${componentCls}-cell::before`]: {
                display: "none"
              }
            },
            // ============= Year & Quarter & Month Panel =============
            [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
              [`${componentCls}-body`]: {
                padding: `0 ${paddingXS}px`
              },
              [pickerCellInnerCls]: {
                width: pickerYearMonthCellWidth
              },
              [`${componentCls}-cell-range-hover-start::after`]: {
                borderStartStartRadius: borderRadiusSM,
                borderEndStartRadius: borderRadiusSM,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                [`${componentCls}-panel-rtl &`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                  borderStartEndRadius: borderRadiusSM,
                  borderEndEndRadius: borderRadiusSM
                }
              },
              [`${componentCls}-cell-range-hover-end::after`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
                borderStartEndRadius: borderRadiusSM,
                borderEndEndRadius: borderRadiusSM,
                [`${componentCls}-panel-rtl &`]: {
                  borderStartStartRadius: borderRadiusSM,
                  borderEndStartRadius: borderRadiusSM,
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              }
            },
            [`&-year-panel,
        &-month-panel`]: {
              [`${componentCls}-cell-range-hover-start::after`]: {
                insetInlineStart: commonHoverCellFixedDistance,
                borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
                [`${componentCls}-panel-rtl &`]: {
                  insetInlineEnd: commonHoverCellFixedDistance,
                  borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
                }
              },
              [`${componentCls}-cell-range-hover-end::after`]: {
                insetInlineEnd: commonHoverCellFixedDistance,
                borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
                [`${componentCls}-panel-rtl &`]: {
                  insetInlineStart: commonHoverCellFixedDistance,
                  borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
                }
              }
            },
            // ====================== Week Panel ======================
            "&-week-panel": {
              [`${componentCls}-body`]: {
                padding: `${paddingXS}px ${paddingSM}px`
              },
              // Clear cell style
              [`${componentCls}-cell`]: {
                [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
                  background: "transparent !important"
                }
              },
              "&-row": {
                td: {
                  "&:before": {
                    transition: `background ${motionDurationMid}`
                  },
                  "&:first-child:before": {
                    borderStartStartRadius: borderRadiusSM,
                    borderEndStartRadius: borderRadiusSM
                  },
                  "&:last-child:before": {
                    borderStartEndRadius: borderRadiusSM,
                    borderEndEndRadius: borderRadiusSM
                  }
                },
                [`&:hover td`]: {
                  "&:before": {
                    background: controlItemBgHover
                  }
                },
                [`&-range-start td,
            &-range-end td,
            &-selected td`]: {
                  // Rise priority to override hover style
                  [`&${pickerCellCls}`]: {
                    "&:before": {
                      background: colorPrimary
                    },
                    [`&${componentCls}-cell-week`]: {
                      color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
                    },
                    [pickerCellInnerCls]: {
                      color: colorTextLightSolid
                    }
                  }
                },
                [`&-range-hover td:before`]: {
                  background: controlItemBgActive
                }
              }
            },
            // ====================== Date Panel ======================
            "&-date-panel": {
              [`${componentCls}-body`]: {
                padding: `${paddingXS}px ${pickerDatePanelPaddingHorizontal}px`
              },
              [`${componentCls}-content`]: {
                width: pickerPanelCellWidth * 7,
                th: {
                  width: pickerPanelCellWidth
                }
              }
            },
            // ==================== Datetime Panel ====================
            "&-datetime-panel": {
              display: "flex",
              [`${componentCls}-time-panel`]: {
                borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
              },
              [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
                transition: `opacity ${motionDurationSlow}`
              },
              // Keyboard
              "&-active": {
                [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
                  opacity: 0.3,
                  "&-active": {
                    opacity: 1
                  }
                }
              }
            },
            // ====================== Time Panel ======================
            "&-time-panel": {
              width: "auto",
              minWidth: "auto",
              direction: "ltr",
              [`${componentCls}-content`]: {
                display: "flex",
                flex: "auto",
                height: pickerTimePanelColumnHeight
              },
              "&-column": {
                flex: "1 0 auto",
                width: pickerTimePanelColumnWidth,
                margin: `${paddingXXS}px 0`,
                padding: 0,
                overflowY: "hidden",
                textAlign: "start",
                listStyle: "none",
                transition: `background ${motionDurationMid}`,
                overflowX: "hidden",
                "&::after": {
                  display: "block",
                  height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight,
                  content: '""'
                },
                "&:not(:first-child)": {
                  borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
                },
                "&-active": {
                  background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
                },
                "&:hover": {
                  overflowY: "auto"
                },
                "> li": {
                  margin: 0,
                  padding: 0,
                  [`&${componentCls}-time-panel-cell`]: {
                    marginInline: marginXXS,
                    [`${componentCls}-time-panel-cell-inner`]: {
                      display: "block",
                      width: pickerTimePanelColumnWidth - 2 * marginXXS,
                      height: pickerTimePanelCellHeight,
                      margin: 0,
                      paddingBlock: 0,
                      paddingInlineEnd: 0,
                      paddingInlineStart: (pickerTimePanelColumnWidth - pickerTimePanelCellHeight) / 2,
                      color: colorText,
                      lineHeight: `${pickerTimePanelCellHeight}px`,
                      borderRadius: borderRadiusSM,
                      cursor: "pointer",
                      transition: `background ${motionDurationMid}`,
                      "&:hover": {
                        background: controlItemBgHover
                      }
                    },
                    "&-selected": {
                      [`${componentCls}-time-panel-cell-inner`]: {
                        background: controlItemBgActive
                      }
                    },
                    "&-disabled": {
                      [`${componentCls}-time-panel-cell-inner`]: {
                        color: colorTextDisabled,
                        background: "transparent",
                        cursor: "not-allowed"
                      }
                    }
                  }
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/39227
            [`&-datetime-panel ${componentCls}-time-panel-column:after`]: {
              height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight + paddingXXS * 2
            }
          }
        };
      };
      const genPickerStatusStyle = (token2) => {
        const {
          componentCls,
          colorBgContainer,
          colorError,
          colorErrorOutline,
          colorWarning,
          colorWarningOutline
        } = token2;
        return {
          [`${componentCls}:not(${componentCls}-disabled)`]: {
            [`&${componentCls}-status-error`]: {
              "&, &:not([disabled]):hover": {
                backgroundColor: colorBgContainer,
                borderColor: colorError
              },
              [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge(token2, {
                inputBorderActiveColor: colorError,
                inputBorderHoverColor: colorError,
                controlOutline: colorErrorOutline
              }))),
              [`${componentCls}-active-bar`]: {
                background: colorError
              }
            },
            [`&${componentCls}-status-warning`]: {
              "&, &:not([disabled]):hover": {
                backgroundColor: colorBgContainer,
                borderColor: colorWarning
              },
              [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge(token2, {
                inputBorderActiveColor: colorWarning,
                inputBorderHoverColor: colorWarning,
                controlOutline: colorWarningOutline
              }))),
              [`${componentCls}-active-bar`]: {
                background: colorWarning
              }
            }
          }
        };
      };
      const genPickerStyle = (token2) => {
        const {
          componentCls,
          antCls,
          controlHeight,
          fontSize,
          inputPaddingHorizontal,
          colorBgContainer,
          lineWidth,
          lineType,
          colorBorder,
          borderRadius,
          motionDurationMid,
          colorBgContainerDisabled,
          colorTextDisabled,
          colorTextPlaceholder,
          controlHeightLG,
          fontSizeLG,
          controlHeightSM,
          inputPaddingHorizontalSM,
          paddingXS,
          marginXS,
          colorTextDescription,
          lineWidthBold,
          lineHeight,
          colorPrimary,
          motionDurationSlow,
          zIndexPopup,
          paddingXXS,
          paddingSM,
          pickerTextHeight,
          controlItemBgActive,
          colorPrimaryBorder,
          sizePopupArrow,
          borderRadiusXS,
          borderRadiusOuter,
          colorBgElevated,
          borderRadiusLG,
          boxShadowSecondary,
          borderRadiusSM,
          colorSplit,
          controlItemBgHover,
          presetsWidth,
          presetsMaxWidth,
          boxShadowPopoverArrow
        } = token2;
        return [
          {
            [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPikerPadding(token2, controlHeight, fontSize, inputPaddingHorizontal)), {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              background: colorBgContainer,
              lineHeight: 1,
              border: `${lineWidth}px ${lineType} ${colorBorder}`,
              borderRadius,
              transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}`,
              "&:hover, &-focused": Object.assign({}, genHoverStyle(token2)),
              "&-focused": Object.assign({}, genActiveStyle(token2)),
              [`&${componentCls}-disabled`]: {
                background: colorBgContainerDisabled,
                borderColor: colorBorder,
                cursor: "not-allowed",
                [`${componentCls}-suffix`]: {
                  color: colorTextDisabled
                }
              },
              [`&${componentCls}-borderless`]: {
                backgroundColor: "transparent !important",
                borderColor: "transparent !important",
                boxShadow: "none !important"
              },
              // ======================== Input =========================
              [`${componentCls}-input`]: {
                position: "relative",
                display: "inline-flex",
                alignItems: "center",
                width: "100%",
                "> input": Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
                  flex: "auto",
                  // Fix Firefox flex not correct:
                  // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
                  minWidth: 1,
                  height: "auto",
                  padding: 0,
                  background: "transparent",
                  border: 0,
                  borderRadius: 0,
                  "&:focus": {
                    boxShadow: "none"
                  },
                  "&[disabled]": {
                    background: "transparent"
                  }
                }),
                "&:hover": {
                  [`${componentCls}-clear`]: {
                    opacity: 1
                  }
                },
                "&-placeholder": {
                  "> input": {
                    color: colorTextPlaceholder
                  }
                }
              },
              // Size
              "&-large": Object.assign(Object.assign({}, genPikerPadding(token2, controlHeightLG, fontSizeLG, inputPaddingHorizontal)), {
                [`${componentCls}-input > input`]: {
                  fontSize: fontSizeLG
                }
              }),
              "&-small": Object.assign({}, genPikerPadding(token2, controlHeightSM, fontSize, inputPaddingHorizontalSM)),
              [`${componentCls}-suffix`]: {
                display: "flex",
                flex: "none",
                alignSelf: "center",
                marginInlineStart: paddingXS / 2,
                color: colorTextDisabled,
                lineHeight: 1,
                pointerEvents: "none",
                "> *": {
                  verticalAlign: "top",
                  "&:not(:last-child)": {
                    marginInlineEnd: marginXS
                  }
                }
              },
              [`${componentCls}-clear`]: {
                position: "absolute",
                top: "50%",
                insetInlineEnd: 0,
                color: colorTextDisabled,
                lineHeight: 1,
                background: colorBgContainer,
                transform: "translateY(-50%)",
                cursor: "pointer",
                opacity: 0,
                transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
                "> *": {
                  verticalAlign: "top"
                },
                "&:hover": {
                  color: colorTextDescription
                }
              },
              [`${componentCls}-separator`]: {
                position: "relative",
                display: "inline-block",
                width: "1em",
                height: fontSizeLG,
                color: colorTextDisabled,
                fontSize: fontSizeLG,
                verticalAlign: "top",
                cursor: "default",
                [`${componentCls}-focused &`]: {
                  color: colorTextDescription
                },
                [`${componentCls}-range-separator &`]: {
                  [`${componentCls}-disabled &`]: {
                    cursor: "not-allowed"
                  }
                }
              },
              // ======================== Range =========================
              "&-range": {
                position: "relative",
                display: "inline-flex",
                // Clear
                [`${componentCls}-clear`]: {
                  insetInlineEnd: inputPaddingHorizontal
                },
                "&:hover": {
                  [`${componentCls}-clear`]: {
                    opacity: 1
                  }
                },
                // Active bar
                [`${componentCls}-active-bar`]: {
                  bottom: -lineWidth,
                  height: lineWidthBold,
                  marginInlineStart: inputPaddingHorizontal,
                  background: colorPrimary,
                  opacity: 0,
                  transition: `all ${motionDurationSlow} ease-out`,
                  pointerEvents: "none"
                },
                [`&${componentCls}-focused`]: {
                  [`${componentCls}-active-bar`]: {
                    opacity: 1
                  }
                },
                [`${componentCls}-range-separator`]: {
                  alignItems: "center",
                  padding: `0 ${paddingXS}px`,
                  lineHeight: 1
                },
                [`&${componentCls}-small`]: {
                  [`${componentCls}-clear`]: {
                    insetInlineEnd: inputPaddingHorizontalSM
                  },
                  [`${componentCls}-active-bar`]: {
                    marginInlineStart: inputPaddingHorizontalSM
                  }
                }
              },
              // ======================= Dropdown =======================
              "&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPanelStyle(token2)), {
                position: "absolute",
                // Fix incorrect position of picker popup
                // https://github.com/ant-design/ant-design/issues/35590
                top: -9999,
                left: {
                  _skip_check_: true,
                  value: -9999
                },
                zIndex: zIndexPopup,
                [`&${componentCls}-dropdown-hidden`]: {
                  display: "none"
                },
                [`&${componentCls}-dropdown-placement-bottomLeft`]: {
                  [`${componentCls}-range-arrow`]: {
                    top: 0,
                    display: "block",
                    transform: "translateY(-100%)"
                  }
                },
                [`&${componentCls}-dropdown-placement-topLeft`]: {
                  [`${componentCls}-range-arrow`]: {
                    bottom: 0,
                    display: "block",
                    transform: "translateY(100%) rotate(180deg)"
                  }
                },
                [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
                  animationName: slideDownIn
                },
                [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
                  animationName: slideUpIn
                },
                [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
                  animationName: slideDownOut
                },
                [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
                  animationName: slideUpOut
                },
                // Time picker with additional style
                [`${componentCls}-panel > ${componentCls}-time-panel`]: {
                  paddingTop: paddingXXS
                },
                // ======================== Ranges ========================
                [`${componentCls}-ranges`]: {
                  marginBottom: 0,
                  padding: `${paddingXXS}px ${paddingSM}px`,
                  overflow: "hidden",
                  lineHeight: `${pickerTextHeight - 2 * lineWidth - paddingXS / 2}px`,
                  textAlign: "start",
                  listStyle: "none",
                  display: "flex",
                  justifyContent: "space-between",
                  "> li": {
                    display: "inline-block"
                  },
                  // https://github.com/ant-design/ant-design/issues/23687
                  [`${componentCls}-preset > ${antCls}-tag-blue`]: {
                    color: colorPrimary,
                    background: controlItemBgActive,
                    borderColor: colorPrimaryBorder,
                    cursor: "pointer"
                  },
                  [`${componentCls}-ok`]: {
                    marginInlineStart: "auto"
                  }
                },
                [`${componentCls}-range-wrapper`]: {
                  display: "flex",
                  position: "relative"
                },
                [`${componentCls}-range-arrow`]: Object.assign({
                  position: "absolute",
                  zIndex: 1,
                  display: "none",
                  marginInlineStart: inputPaddingHorizontal * 1.5,
                  transition: `left ${motionDurationSlow} ease-out`
                }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
                [`${componentCls}-panel-container`]: {
                  overflow: "hidden",
                  verticalAlign: "top",
                  background: colorBgElevated,
                  borderRadius: borderRadiusLG,
                  boxShadow: boxShadowSecondary,
                  transition: `margin ${motionDurationSlow}`,
                  // ======================== Layout ========================
                  [`${componentCls}-panel-layout`]: {
                    display: "flex",
                    flexWrap: "nowrap",
                    alignItems: "stretch"
                  },
                  // ======================== Preset ========================
                  [`${componentCls}-presets`]: {
                    display: "flex",
                    flexDirection: "column",
                    minWidth: presetsWidth,
                    maxWidth: presetsMaxWidth,
                    ul: {
                      height: 0,
                      flex: "auto",
                      listStyle: "none",
                      overflow: "auto",
                      margin: 0,
                      padding: paddingXS,
                      borderInlineEnd: `${lineWidth}px ${lineType} ${colorSplit}`,
                      li: Object.assign(Object.assign({}, textEllipsis), {
                        borderRadius: borderRadiusSM,
                        paddingInline: paddingXS,
                        paddingBlock: (controlHeightSM - Math.round(fontSize * lineHeight)) / 2,
                        cursor: "pointer",
                        transition: `all ${motionDurationSlow}`,
                        "+ li": {
                          marginTop: marginXS
                        },
                        "&:hover": {
                          background: controlItemBgHover
                        }
                      })
                    }
                  },
                  // ======================== Panels ========================
                  [`${componentCls}-panels`]: {
                    display: "inline-flex",
                    flexWrap: "nowrap",
                    direction: "ltr",
                    [`${componentCls}-panel`]: {
                      borderWidth: `0 0 ${lineWidth}px`
                    },
                    "&:last-child": {
                      [`${componentCls}-panel`]: {
                        borderWidth: 0
                      }
                    }
                  },
                  [`${componentCls}-panel`]: {
                    verticalAlign: "top",
                    background: "transparent",
                    borderRadius: 0,
                    borderWidth: 0,
                    [`${componentCls}-content,
            table`]: {
                      textAlign: "center"
                    },
                    "&-focused": {
                      borderColor: colorBorder
                    }
                  }
                }
              }),
              "&-dropdown-range": {
                padding: `${sizePopupArrow * 2 / 3}px 0`,
                "&-hidden": {
                  display: "none"
                }
              },
              "&-rtl": {
                direction: "rtl",
                [`${componentCls}-separator`]: {
                  transform: "rotate(180deg)"
                },
                [`${componentCls}-footer`]: {
                  "&-extra": {
                    direction: "rtl"
                  }
                }
              }
            })
          },
          // Follow code may reuse in other components
          initSlideMotion(token2, "slide-up"),
          initSlideMotion(token2, "slide-down"),
          initMoveMotion(token2, "move-up"),
          initMoveMotion(token2, "move-down")
        ];
      };
      const initPickerPanelToken = (token2) => {
        const pickerTimePanelCellHeight = 28;
        const {
          componentCls,
          controlHeightLG,
          controlHeightSM,
          colorPrimary,
          paddingXXS,
          padding
        } = token2;
        return {
          pickerCellCls: `${componentCls}-cell`,
          pickerCellInnerCls: `${componentCls}-cell-inner`,
          pickerTextHeight: controlHeightLG,
          pickerPanelCellWidth: controlHeightSM * 1.5,
          pickerPanelCellHeight: controlHeightSM,
          pickerDateHoverRangeBorderColor: new TinyColor(colorPrimary).lighten(20).toHexString(),
          pickerBasicCellHoverWithRangeColor: new TinyColor(colorPrimary).lighten(35).toHexString(),
          pickerPanelWithoutTimeCellHeight: controlHeightLG * 1.65,
          pickerYearMonthCellWidth: controlHeightLG * 1.5,
          pickerTimePanelColumnHeight: pickerTimePanelCellHeight * 8,
          pickerTimePanelColumnWidth: controlHeightLG * 1.4,
          pickerTimePanelCellHeight,
          pickerQuarterPanelContentHeight: controlHeightLG * 1.4,
          pickerCellPaddingVertical: paddingXXS + paddingXXS / 2,
          pickerCellBorderGap: 2,
          pickerControlIconSize: 7,
          pickerControlIconBorderWidth: 1.5,
          pickerDatePanelPaddingHorizontal: padding + paddingXXS / 2
          // 18 in normal
        };
      };
      const useStyle$1 = genComponentStyleHook("DatePicker", (token2) => {
        const pickerToken = merge(initInputToken(token2), initPickerPanelToken(token2));
        return [
          genPickerStyle(pickerToken),
          genPickerStatusStyle(pickerToken),
          // =====================================================
          // ==             Space Compact                       ==
          // =====================================================
          genCompactItemStyle(token2, {
            focusElCls: `${token2.componentCls}-focused`
          })
        ];
      }, (token2) => ({
        presetsWidth: 120,
        presetsMaxWidth: 200,
        zIndexPopup: token2.zIndexPopupBase + 50
      }));
      const RowContext = /* @__PURE__ */ React.createContext({});
      const RowContext$1 = RowContext;
      const genGridRowStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          // Grid system
          [componentCls]: {
            display: "flex",
            flexFlow: "row wrap",
            minWidth: 0,
            "&::before, &::after": {
              display: "flex"
            },
            "&-no-wrap": {
              flexWrap: "nowrap"
            },
            // The origin of the X-axis
            "&-start": {
              justifyContent: "flex-start"
            },
            // The center of the X-axis
            "&-center": {
              justifyContent: "center"
            },
            // The opposite of the X-axis
            "&-end": {
              justifyContent: "flex-end"
            },
            "&-space-between": {
              justifyContent: "space-between"
            },
            "&-space-around": {
              justifyContent: "space-around"
            },
            "&-space-evenly": {
              justifyContent: "space-evenly"
            },
            // Align at the top
            "&-top": {
              alignItems: "flex-start"
            },
            // Align at the center
            "&-middle": {
              alignItems: "center"
            },
            "&-bottom": {
              alignItems: "flex-end"
            }
          }
        };
      };
      const genGridColStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          // Grid system
          [componentCls]: {
            position: "relative",
            maxWidth: "100%",
            // Prevent columns from collapsing when empty
            minHeight: 1
          }
        };
      };
      const genLoopGridColumnsStyle = (token2, sizeCls) => {
        const {
          componentCls,
          gridColumns
        } = token2;
        const gridColumnsStyle = {};
        for (let i2 = gridColumns; i2 >= 0; i2--) {
          if (i2 === 0) {
            gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
              display: "none"
            };
            gridColumnsStyle[`${componentCls}-push-${i2}`] = {
              insetInlineStart: "auto"
            };
            gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
              insetInlineEnd: "auto"
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
              insetInlineStart: "auto"
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
              insetInlineEnd: "auto"
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
              marginInlineStart: 0
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
              order: 0
            };
          } else {
            gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
              display: "block",
              flex: `0 0 ${i2 / gridColumns * 100}%`,
              maxWidth: `${i2 / gridColumns * 100}%`
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
              insetInlineStart: `${i2 / gridColumns * 100}%`
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
              insetInlineEnd: `${i2 / gridColumns * 100}%`
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
              marginInlineStart: `${i2 / gridColumns * 100}%`
            };
            gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
              order: i2
            };
          }
        }
        return gridColumnsStyle;
      };
      const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
      const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
        [`@media (min-width: ${screenSize}px)`]: Object.assign({}, genGridStyle(token2, sizeCls))
      });
      const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
      const useColStyle = genComponentStyleHook("Grid", (token2) => {
        const gridToken = merge(token2, {
          gridColumns: 24
          // Row is divided into 24 parts in Grid
        });
        const gridMediaSizesMap = {
          "-sm": gridToken.screenSMMin,
          "-md": gridToken.screenMDMin,
          "-lg": gridToken.screenLGMin,
          "-xl": gridToken.screenXLMin,
          "-xxl": gridToken.screenXXLMin
        };
        return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key2) => genGridMediaStyle(gridToken, gridMediaSizesMap[key2], key2)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
      });
      var __rest$c = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function parseFlex(flex) {
        if (typeof flex === "number") {
          return `${flex} ${flex} auto`;
        }
        if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
          return `0 0 ${flex}`;
        }
        return flex;
      }
      const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
      const Col = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        const {
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const {
          gutter,
          wrap,
          supportFlexGap
        } = React__namespace.useContext(RowContext$1);
        const {
          prefixCls: customizePrefixCls,
          span,
          order,
          offset: offset2,
          push,
          pull,
          className,
          children,
          flex,
          style: style2
        } = props, others = __rest$c(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
        const prefixCls = getPrefixCls("col", customizePrefixCls);
        const [wrapSSR, hashId] = useColStyle(prefixCls);
        let sizeClassObj = {};
        sizes.forEach((size) => {
          let sizeProps = {};
          const propSize = props[size];
          if (typeof propSize === "number") {
            sizeProps.span = propSize;
          } else if (typeof propSize === "object") {
            sizeProps = propSize || {};
          }
          delete others[size];
          sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
            [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
            [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
            [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
            [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
            [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
            [`${prefixCls}-${size}-flex-${sizeProps.flex}`]: sizeProps.flex || sizeProps.flex === "auto",
            [`${prefixCls}-rtl`]: direction === "rtl"
          });
        });
        const classes = classNames(prefixCls, {
          [`${prefixCls}-${span}`]: span !== void 0,
          [`${prefixCls}-order-${order}`]: order,
          [`${prefixCls}-offset-${offset2}`]: offset2,
          [`${prefixCls}-push-${push}`]: push,
          [`${prefixCls}-pull-${pull}`]: pull
        }, className, sizeClassObj, hashId);
        const mergedStyle = {};
        if (gutter && gutter[0] > 0) {
          const horizontalGutter = gutter[0] / 2;
          mergedStyle.paddingLeft = horizontalGutter;
          mergedStyle.paddingRight = horizontalGutter;
        }
        if (gutter && gutter[1] > 0 && !supportFlexGap) {
          const verticalGutter = gutter[1] / 2;
          mergedStyle.paddingTop = verticalGutter;
          mergedStyle.paddingBottom = verticalGutter;
        }
        if (flex) {
          mergedStyle.flex = parseFlex(flex);
          if (wrap === false && !mergedStyle.minWidth) {
            mergedStyle.minWidth = 0;
          }
        }
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, others, {
          style: Object.assign(Object.assign({}, mergedStyle), style2),
          className: classes,
          ref
        }), children));
      });
      const Col$1 = Col;
      const useFlexGapSupport = () => {
        const [flexible, setFlexible] = React__namespace.useState(false);
        React__namespace.useEffect(() => {
          setFlexible(detectFlexGapSupported());
        }, []);
        return flexible;
      };
      var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function useMergePropByScreen(oriProp, screen) {
        const [prop, setProp] = React__namespace.useState(typeof oriProp === "string" ? oriProp : "");
        const calcMergeAlignOrJustify = () => {
          if (typeof oriProp === "string") {
            setProp(oriProp);
          }
          if (typeof oriProp !== "object") {
            return;
          }
          for (let i2 = 0; i2 < responsiveArray.length; i2++) {
            const breakpoint = responsiveArray[i2];
            if (!screen[breakpoint])
              continue;
            const curVal = oriProp[breakpoint];
            if (curVal !== void 0) {
              setProp(curVal);
              return;
            }
          }
        };
        React__namespace.useEffect(() => {
          calcMergeAlignOrJustify();
        }, [JSON.stringify(oriProp), screen]);
        return prop;
      }
      const Row = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        const {
          prefixCls: customizePrefixCls,
          justify,
          align,
          className,
          style: style2,
          children,
          gutter = 0,
          wrap
        } = props, others = __rest$b(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
        const {
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const [screens, setScreens] = React__namespace.useState({
          xs: true,
          sm: true,
          md: true,
          lg: true,
          xl: true,
          xxl: true
        });
        const [curScreens, setCurScreens] = React__namespace.useState({
          xs: false,
          sm: false,
          md: false,
          lg: false,
          xl: false,
          xxl: false
        });
        const mergeAlign = useMergePropByScreen(align, curScreens);
        const mergeJustify = useMergePropByScreen(justify, curScreens);
        const supportFlexGap = useFlexGapSupport();
        const gutterRef = React__namespace.useRef(gutter);
        const responsiveObserver = useResponsiveObserver();
        React__namespace.useEffect(() => {
          const token2 = responsiveObserver.subscribe((screen) => {
            setCurScreens(screen);
            const currentGutter = gutterRef.current || 0;
            if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
              setScreens(screen);
            }
          });
          return () => responsiveObserver.unsubscribe(token2);
        }, []);
        const getGutter = () => {
          const results = [void 0, void 0];
          const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
          normalizedGutter.forEach((g2, index2) => {
            if (typeof g2 === "object") {
              for (let i2 = 0; i2 < responsiveArray.length; i2++) {
                const breakpoint = responsiveArray[i2];
                if (screens[breakpoint] && g2[breakpoint] !== void 0) {
                  results[index2] = g2[breakpoint];
                  break;
                }
              }
            } else {
              results[index2] = g2;
            }
          });
          return results;
        };
        const prefixCls = getPrefixCls("row", customizePrefixCls);
        const [wrapSSR, hashId] = useRowStyle(prefixCls);
        const gutters = getGutter();
        const classes = classNames(prefixCls, {
          [`${prefixCls}-no-wrap`]: wrap === false,
          [`${prefixCls}-${mergeJustify}`]: mergeJustify,
          [`${prefixCls}-${mergeAlign}`]: mergeAlign,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, hashId);
        const rowStyle = {};
        const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
        const verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
        if (horizontalGutter) {
          rowStyle.marginLeft = horizontalGutter;
          rowStyle.marginRight = horizontalGutter;
        }
        if (supportFlexGap) {
          [, rowStyle.rowGap] = gutters;
        } else if (verticalGutter) {
          rowStyle.marginTop = verticalGutter;
          rowStyle.marginBottom = verticalGutter;
        }
        const [gutterH, gutterV] = gutters;
        const rowContext = React__namespace.useMemo(() => ({
          gutter: [gutterH, gutterV],
          wrap,
          supportFlexGap
        }), [gutterH, gutterV, wrap, supportFlexGap]);
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(RowContext$1.Provider, {
          value: rowContext
        }, /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, others, {
          className: classes,
          style: Object.assign(Object.assign({}, rowStyle), style2),
          ref
        }), children)));
      });
      const Row$1 = Row;
      const Group = (props) => {
        const {
          getPrefixCls,
          direction
        } = React.useContext(ConfigContext);
        const {
          prefixCls: customizePrefixCls,
          className = ""
        } = props;
        const prefixCls = getPrefixCls("input-group", customizePrefixCls);
        const inputPrefixCls = getPrefixCls("input");
        const [wrapSSR, hashId] = useStyle$2(inputPrefixCls);
        const cls = classNames(prefixCls, {
          [`${prefixCls}-lg`]: props.size === "large",
          [`${prefixCls}-sm`]: props.size === "small",
          [`${prefixCls}-compact`]: props.compact,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, hashId, className);
        const formItemContext = React.useContext(FormItemInputContext);
        const groupFormItemContext = React.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
          isFormItemInput: false
        }), [formItemContext]);
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", {
          className: cls,
          style: props.style,
          onMouseEnter: props.onMouseEnter,
          onMouseLeave: props.onMouseLeave,
          onFocus: props.onFocus,
          onBlur: props.onBlur
        }, /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
          value: groupFormItemContext
        }, props.children)));
      };
      const Group$1 = Group;
      function hasAddon(props) {
        return !!(props.addonBefore || props.addonAfter);
      }
      function hasPrefixSuffix$1(props) {
        return !!(props.prefix || props.suffix || props.allowClear);
      }
      function resolveOnChange(target, e2, onChange, targetValue) {
        if (!onChange) {
          return;
        }
        var event = e2;
        if (e2.type === "click") {
          var currentTarget = target.cloneNode(true);
          event = Object.create(e2, {
            target: {
              value: currentTarget
            },
            currentTarget: {
              value: currentTarget
            }
          });
          currentTarget.value = "";
          onChange(event);
          return;
        }
        if (targetValue !== void 0) {
          event = Object.create(e2, {
            target: {
              value: target
            },
            currentTarget: {
              value: target
            }
          });
          target.value = targetValue;
          onChange(event);
          return;
        }
        onChange(event);
      }
      function triggerFocus$1(element, option) {
        if (!element)
          return;
        element.focus(option);
        var _ref = option || {}, cursor = _ref.cursor;
        if (cursor) {
          var len = element.value.length;
          switch (cursor) {
            case "start":
              element.setSelectionRange(0, 0);
              break;
            case "end":
              element.setSelectionRange(len, len);
              break;
            default:
              element.setSelectionRange(0, len);
          }
        }
      }
      function fixControlledValue(value) {
        if (typeof value === "undefined" || value === null) {
          return "";
        }
        return String(value);
      }
      var BaseInput = function BaseInput2(props) {
        var _inputElement$props, _inputElement$props2;
        var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames$1 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles;
        var containerRef = React.useRef(null);
        var onInputClick = function onInputClick2(e2) {
          var _containerRef$current;
          if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
            triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
          }
        };
        var getClearIcon = function getClearIcon2() {
          var _clsx;
          if (!allowClear) {
            return null;
          }
          var needClear = !disabled && !readOnly && value;
          var clearIconCls = "".concat(prefixCls, "-clear-icon");
          var iconNode = _typeof$3(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "✖";
          return /* @__PURE__ */ React.createElement("span", {
            onClick: handleReset,
            onMouseDown: function onMouseDown(e2) {
              return e2.preventDefault();
            },
            className: classNames(clearIconCls, (_clsx = {}, _defineProperty$3(_clsx, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$3(_clsx, "".concat(clearIconCls, "-has-suffix"), !!suffix), _clsx)),
            role: "button",
            tabIndex: -1
          }, iconNode);
        };
        var element = /* @__PURE__ */ React.cloneElement(inputElement, {
          value,
          hidden,
          className: classNames((_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.className, !hasPrefixSuffix$1(props) && !hasAddon(props) && className) || null,
          style: _objectSpread2(_objectSpread2({}, (_inputElement$props2 = inputElement.props) === null || _inputElement$props2 === void 0 ? void 0 : _inputElement$props2.style), !hasPrefixSuffix$1(props) && !hasAddon(props) ? style2 : {})
        });
        if (hasPrefixSuffix$1(props)) {
          var _clsx2;
          var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
          var affixWrapperCls = classNames(affixWrapperPrefixCls, (_clsx2 = {}, _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$3(_clsx2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _clsx2), !hasAddon(props) && className, classes === null || classes === void 0 ? void 0 : classes.affixWrapper);
          var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React.createElement("span", {
            className: classNames("".concat(prefixCls, "-suffix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.suffix),
            style: styles === null || styles === void 0 ? void 0 : styles.suffix
          }, getClearIcon(), suffix);
          element = /* @__PURE__ */ React.createElement("span", _extends$1({
            className: affixWrapperCls,
            style: !hasAddon(props) ? style2 : void 0,
            hidden: !hasAddon(props) && hidden,
            onClick: onInputClick
          }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
            ref: containerRef
          }), prefix && /* @__PURE__ */ React.createElement("span", {
            className: classNames("".concat(prefixCls, "-prefix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.prefix),
            style: styles === null || styles === void 0 ? void 0 : styles.prefix
          }, prefix), /* @__PURE__ */ React.cloneElement(inputElement, {
            value,
            hidden: null
          }), suffixNode);
        }
        if (hasAddon(props)) {
          var wrapperCls = "".concat(prefixCls, "-group");
          var addonCls = "".concat(wrapperCls, "-addon");
          var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper);
          var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, classes === null || classes === void 0 ? void 0 : classes.group);
          return /* @__PURE__ */ React.createElement("span", {
            className: mergedGroupClassName,
            style: style2,
            hidden
          }, /* @__PURE__ */ React.createElement("span", {
            className: mergedWrapperClassName
          }, addonBefore && /* @__PURE__ */ React.createElement("span", {
            className: addonCls
          }, addonBefore), /* @__PURE__ */ React.cloneElement(element, {
            hidden: null
          }), addonAfter && /* @__PURE__ */ React.createElement("span", {
            className: addonCls
          }, addonAfter)));
        }
        return element;
      };
      var _excluded$2 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "classes", "classNames", "styles"];
      var Input$3 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames$1 = props.classNames, styles = props.styles, rest = _objectWithoutProperties(props, _excluded$2);
        var _useMergedState = useMergedState(props.defaultValue, {
          value: props.value
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
        var _useState = React.useState(false), _useState2 = _slicedToArray$5(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
        var inputRef = React.useRef(null);
        var focus = function focus2(option) {
          if (inputRef.current) {
            triggerFocus$1(inputRef.current, option);
          }
        };
        React.useImperativeHandle(ref, function() {
          return {
            focus,
            blur: function blur() {
              var _inputRef$current;
              (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
            },
            setSelectionRange: function setSelectionRange2(start, end, direction) {
              var _inputRef$current2;
              (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
            },
            select: function select() {
              var _inputRef$current3;
              (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
            },
            input: inputRef.current
          };
        });
        React.useEffect(function() {
          setFocused(function(prev2) {
            return prev2 && disabled ? false : prev2;
          });
        }, [disabled]);
        var handleChange = function handleChange2(e2) {
          if (props.value === void 0) {
            setValue(e2.target.value);
          }
          if (inputRef.current) {
            resolveOnChange(inputRef.current, e2, onChange);
          }
        };
        var handleKeyDown = function handleKeyDown2(e2) {
          if (onPressEnter && e2.key === "Enter") {
            onPressEnter(e2);
          }
          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
        };
        var handleFocus = function handleFocus2(e2) {
          setFocused(true);
          onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
        };
        var handleBlur = function handleBlur2(e2) {
          setFocused(false);
          onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
        };
        var handleReset = function handleReset2(e2) {
          setValue("");
          focus();
          if (inputRef.current) {
            resolveOnChange(inputRef.current, e2, onChange);
          }
        };
        var getInputElement = function getInputElement2() {
          var otherProps = omit(props, [
            "prefixCls",
            "onPressEnter",
            "addonBefore",
            "addonAfter",
            "prefix",
            "suffix",
            "allowClear",
            // Input elements must be either controlled or uncontrolled,
            // specify either the value prop, or the defaultValue prop, but not both.
            "defaultValue",
            "showCount",
            "classes",
            "htmlSize",
            "styles",
            "classNames"
          ]);
          return /* @__PURE__ */ React.createElement("input", _extends$1({
            autoComplete
          }, otherProps, {
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onKeyDown: handleKeyDown,
            className: classNames(prefixCls, _defineProperty$3({}, "".concat(prefixCls, "-disabled"), disabled), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.input),
            style: styles === null || styles === void 0 ? void 0 : styles.input,
            ref: inputRef,
            size: htmlSize,
            type: type2
          }));
        };
        var getSuffix = function getSuffix2() {
          var hasMaxLength = Number(maxLength) > 0;
          if (suffix || showCount) {
            var val = fixControlledValue(value);
            var valueLength = _toConsumableArray(val).length;
            var dataCount = _typeof$3(showCount) === "object" ? showCount.formatter({
              value: val,
              count: valueLength,
              maxLength
            }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
            return /* @__PURE__ */ React.createElement(React.Fragment, null, !!showCount && /* @__PURE__ */ React.createElement("span", {
              className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty$3({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
              style: _objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.count)
            }, dataCount), suffix);
          }
          return null;
        };
        return /* @__PURE__ */ React.createElement(BaseInput, _extends$1({}, rest, {
          prefixCls,
          className,
          inputElement: getInputElement(),
          handleReset,
          value: fixControlledValue(value),
          focused,
          triggerFocus: focus,
          suffix: getSuffix(),
          disabled,
          classes,
          classNames: classNames$1,
          styles
        }));
      });
      function useRemovePasswordTimeout(inputRef, triggerOnMount) {
        const removePasswordTimeoutRef = React.useRef([]);
        const removePasswordTimeout = () => {
          removePasswordTimeoutRef.current.push(setTimeout(() => {
            var _a, _b, _c, _d;
            if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
              (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
            }
          }));
        };
        React.useEffect(() => {
          if (triggerOnMount) {
            removePasswordTimeout();
          }
          return () => removePasswordTimeoutRef.current.forEach((timer) => {
            if (timer) {
              clearTimeout(timer);
            }
          });
        }, []);
        return removePasswordTimeout;
      }
      function hasPrefixSuffix(props) {
        return !!(props.prefix || props.suffix || props.allowClear);
      }
      var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function triggerFocus(element, option) {
        if (!element) {
          return;
        }
        element.focus(option);
        const {
          cursor
        } = option || {};
        if (cursor) {
          const len = element.value.length;
          switch (cursor) {
            case "start":
              element.setSelectionRange(0, 0);
              break;
            case "end":
              element.setSelectionRange(len, len);
              break;
            default:
              element.setSelectionRange(0, len);
              break;
          }
        }
      }
      const Input$2 = /* @__PURE__ */ React.forwardRef((props, ref) => {
        const {
          prefixCls: customizePrefixCls,
          bordered = true,
          status: customStatus,
          size: customSize,
          disabled: customDisabled,
          onBlur,
          onFocus,
          suffix,
          allowClear,
          addonAfter,
          addonBefore,
          className,
          rootClassName,
          onChange,
          classNames: classes
        } = props, rest = __rest$a(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "rootClassName", "onChange", "classNames"]);
        const {
          getPrefixCls,
          direction,
          input: input2
        } = React.useContext(ConfigContext);
        const prefixCls = getPrefixCls("input", customizePrefixCls);
        const inputRef = React.useRef(null);
        const [wrapSSR, hashId] = useStyle$2(prefixCls);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const mergedSize = useSize$1((ctx) => {
          var _a;
          return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
        });
        const disabled = React.useContext(DisabledContext$1);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const {
          status: contextStatus,
          hasFeedback,
          feedbackIcon
        } = React.useContext(FormItemInputContext);
        const mergedStatus = getMergedStatus(contextStatus, customStatus);
        const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
        const prevHasPrefixSuffix = React.useRef(inputHasPrefixSuffix);
        React.useEffect(() => {
          if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
            ;
          prevHasPrefixSuffix.current = inputHasPrefixSuffix;
        }, [inputHasPrefixSuffix]);
        const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
        const handleBlur = (e2) => {
          removePasswordTimeout();
          onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
        };
        const handleFocus = (e2) => {
          removePasswordTimeout();
          onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
        };
        const handleChange = (e2) => {
          removePasswordTimeout();
          onChange === null || onChange === void 0 ? void 0 : onChange(e2);
        };
        const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon);
        let mergedAllowClear;
        if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
          mergedAllowClear = allowClear;
        } else if (allowClear) {
          mergedAllowClear = {
            clearIcon: /* @__PURE__ */ React.createElement(CloseCircleFilled$1, null)
          };
        }
        return wrapSSR(/* @__PURE__ */ React.createElement(Input$3, Object.assign({
          ref: composeRef(ref, inputRef),
          prefixCls,
          autoComplete: input2 === null || input2 === void 0 ? void 0 : input2.autoComplete
        }, rest, {
          disabled: mergedDisabled,
          onBlur: handleBlur,
          onFocus: handleFocus,
          suffix: suffixNode,
          allowClear: mergedAllowClear,
          className: classNames(className, rootClassName, compactItemClassnames),
          onChange: handleChange,
          addonAfter: addonAfter && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
            override: true,
            status: true
          }, addonAfter)),
          addonBefore: addonBefore && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
            override: true,
            status: true
          }, addonBefore)),
          classNames: Object.assign(Object.assign({}, classes), {
            input: classNames({
              [`${prefixCls}-sm`]: mergedSize === "small",
              [`${prefixCls}-lg`]: mergedSize === "large",
              [`${prefixCls}-rtl`]: direction === "rtl",
              [`${prefixCls}-borderless`]: !bordered
            }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), classes === null || classes === void 0 ? void 0 : classes.input, hashId)
          }),
          classes: {
            affixWrapper: classNames({
              [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
              [`${prefixCls}-affix-wrapper-borderless`]: !bordered
            }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
            wrapper: classNames({
              [`${prefixCls}-group-rtl`]: direction === "rtl"
            }, hashId),
            group: classNames({
              [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
              [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
            }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
          }
        })));
      });
      const InternalInput = Input$2;
      var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
      const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
      var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: EyeInvisibleOutlinedSvg
        }));
      };
      const EyeInvisibleOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(EyeInvisibleOutlined);
      var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
      const EyeOutlinedSvg = EyeOutlined$2;
      var EyeOutlined = function EyeOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: EyeOutlinedSvg
        }));
      };
      const EyeOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(EyeOutlined);
      var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const defaultIconRender = (visible) => visible ? /* @__PURE__ */ React__namespace.createElement(EyeOutlined$1, null) : /* @__PURE__ */ React__namespace.createElement(EyeInvisibleOutlined$1, null);
      const ActionMap = {
        click: "onClick",
        hover: "onMouseOver"
      };
      const Password = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        const {
          visibilityToggle = true
        } = props;
        const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
        const [visible, setVisible] = React.useState(() => visibilityControlled ? visibilityToggle.visible : false);
        const inputRef = React.useRef(null);
        React__namespace.useEffect(() => {
          if (visibilityControlled) {
            setVisible(visibilityToggle.visible);
          }
        }, [visibilityControlled, visibilityToggle]);
        const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
        const onVisibleChange = () => {
          const {
            disabled
          } = props;
          if (disabled) {
            return;
          }
          if (visible) {
            removePasswordTimeout();
          }
          setVisible((prevState) => {
            var _a;
            const newState = !prevState;
            if (typeof visibilityToggle === "object") {
              (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
            }
            return newState;
          });
        };
        const getIcon = (prefixCls2) => {
          const {
            action = "click",
            iconRender = defaultIconRender
          } = props;
          const iconTrigger = ActionMap[action] || "";
          const icon = iconRender(visible);
          const iconProps = {
            [iconTrigger]: onVisibleChange,
            className: `${prefixCls2}-icon`,
            key: "passwordIcon",
            onMouseDown: (e2) => {
              e2.preventDefault();
            },
            onMouseUp: (e2) => {
              e2.preventDefault();
            }
          };
          return /* @__PURE__ */ React__namespace.cloneElement(/* @__PURE__ */ React__namespace.isValidElement(icon) ? icon : /* @__PURE__ */ React__namespace.createElement("span", null, icon), iconProps);
        };
        const {
          className,
          prefixCls: customizePrefixCls,
          inputPrefixCls: customizeInputPrefixCls,
          size
        } = props, restProps = __rest$9(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
        const {
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
        const prefixCls = getPrefixCls("input-password", customizePrefixCls);
        const suffixIcon = visibilityToggle && getIcon(prefixCls);
        const inputClassName = classNames(prefixCls, className, {
          [`${prefixCls}-${size}`]: !!size
        });
        const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
          type: visible ? "text" : "password",
          className: inputClassName,
          prefixCls: inputPrefixCls,
          suffix: suffixIcon
        });
        if (size) {
          omittedProps.size = size;
        }
        return /* @__PURE__ */ React__namespace.createElement(InternalInput, Object.assign({
          ref: composeRef(ref, inputRef)
        }, omittedProps));
      });
      const Password$1 = Password;
      var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const Search = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
        const {
          prefixCls: customizePrefixCls,
          inputPrefixCls: customizeInputPrefixCls,
          className,
          size: customizeSize,
          suffix,
          enterButton = false,
          addonAfter,
          loading,
          disabled,
          onSearch: customOnSearch,
          onChange: customOnChange,
          onCompositionStart,
          onCompositionEnd
        } = props, restProps = __rest$8(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
        const {
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const composedRef = React__namespace.useRef(false);
        const prefixCls = getPrefixCls("input-search", customizePrefixCls);
        const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
        const {
          compactSize
        } = useCompactItemContext(prefixCls, direction);
        const size = useSize$1((ctx) => {
          var _a;
          return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
        });
        const inputRef = React__namespace.useRef(null);
        const onChange = (e2) => {
          if (e2 && e2.target && e2.type === "click" && customOnSearch) {
            customOnSearch(e2.target.value, e2);
          }
          if (customOnChange) {
            customOnChange(e2);
          }
        };
        const onMouseDown = (e2) => {
          var _a;
          if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
            e2.preventDefault();
          }
        };
        const onSearch = (e2) => {
          var _a, _b;
          if (customOnSearch) {
            customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2);
          }
        };
        const onPressEnter = (e2) => {
          if (composedRef.current || loading) {
            return;
          }
          onSearch(e2);
        };
        const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ React__namespace.createElement(SearchOutlined$1, null) : null;
        const btnClassName = `${prefixCls}-button`;
        let button;
        const enterButtonAsElement = enterButton || {};
        const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
        if (isAntdButton || enterButtonAsElement.type === "button") {
          button = cloneElement(enterButtonAsElement, Object.assign({
            onMouseDown,
            onClick: (e2) => {
              var _a, _b;
              (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
              onSearch(e2);
            },
            key: "enterButton"
          }, isAntdButton ? {
            className: btnClassName,
            size
          } : {}));
        } else {
          button = /* @__PURE__ */ React__namespace.createElement(Button$1, {
            className: btnClassName,
            type: enterButton ? "primary" : void 0,
            size,
            disabled,
            key: "enterButton",
            onMouseDown,
            onClick: onSearch,
            loading,
            icon: searchIcon
          }, enterButton);
        }
        if (addonAfter) {
          button = [button, cloneElement(addonAfter, {
            key: "addonAfter"
          })];
        }
        const cls = classNames(prefixCls, {
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-${size}`]: !!size,
          [`${prefixCls}-with-button`]: !!enterButton
        }, className);
        const handleOnCompositionStart = (e2) => {
          composedRef.current = true;
          onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
        };
        const handleOnCompositionEnd = (e2) => {
          composedRef.current = false;
          onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
        };
        return /* @__PURE__ */ React__namespace.createElement(InternalInput, Object.assign({
          ref: composeRef(inputRef, ref),
          onPressEnter
        }, restProps, {
          size,
          onCompositionStart: handleOnCompositionStart,
          onCompositionEnd: handleOnCompositionEnd,
          prefixCls: inputPrefixCls,
          addonAfter: button,
          suffix,
          onChange,
          className: cls,
          disabled
        }));
      });
      const Search$1 = Search;
      var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
      var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
      var computedStyleCache = {};
      var hiddenTextarea;
      function calculateNodeStyling(node2) {
        var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
        if (useCache && computedStyleCache[nodeRef]) {
          return computedStyleCache[nodeRef];
        }
        var style2 = window.getComputedStyle(node2);
        var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
        var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
        var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
        var sizingStyle = SIZING_STYLE.map(function(name) {
          return "".concat(name, ":").concat(style2.getPropertyValue(name));
        }).join(";");
        var nodeInfo = {
          sizingStyle,
          paddingSize,
          borderSize,
          boxSizing
        };
        if (useCache && nodeRef) {
          computedStyleCache[nodeRef] = nodeInfo;
        }
        return nodeInfo;
      }
      function calculateAutoSizeStyle(uiTextNode) {
        var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          hiddenTextarea.setAttribute("tab-index", "-1");
          hiddenTextarea.setAttribute("aria-hidden", "true");
          document.body.appendChild(hiddenTextarea);
        }
        if (uiTextNode.getAttribute("wrap")) {
          hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
        } else {
          hiddenTextarea.removeAttribute("wrap");
        }
        var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
        hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
        hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
        var minHeight = void 0;
        var maxHeight = void 0;
        var overflowY;
        var height = hiddenTextarea.scrollHeight;
        if (boxSizing === "border-box") {
          height += borderSize;
        } else if (boxSizing === "content-box") {
          height -= paddingSize;
        }
        if (minRows !== null || maxRows !== null) {
          hiddenTextarea.value = " ";
          var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
          if (minRows !== null) {
            minHeight = singleRowHeight * minRows;
            if (boxSizing === "border-box") {
              minHeight = minHeight + paddingSize + borderSize;
            }
            height = Math.max(minHeight, height);
          }
          if (maxRows !== null) {
            maxHeight = singleRowHeight * maxRows;
            if (boxSizing === "border-box") {
              maxHeight = maxHeight + paddingSize + borderSize;
            }
            overflowY = height > maxHeight ? "" : "hidden";
            height = Math.min(maxHeight, height);
          }
        }
        var style2 = {
          height,
          overflowY,
          resize: "none"
        };
        if (minHeight) {
          style2.minHeight = minHeight;
        }
        if (maxHeight) {
          style2.maxHeight = maxHeight;
        }
        return style2;
      }
      var _excluded$1 = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
      var RESIZE_START = 0;
      var RESIZE_MEASURING = 1;
      var RESIZE_STABLE = 2;
      var ResizableTextArea = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
        var _ref = props, prefixCls = _ref.prefixCls;
        _ref.onPressEnter;
        var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
        _ref.onInternalAutoSize;
        var restProps = _objectWithoutProperties(_ref, _excluded$1);
        var _useMergedState = useMergedState(defaultValue, {
          value,
          postState: function postState(val) {
            return val !== null && val !== void 0 ? val : "";
          }
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
        var onInternalChange = function onInternalChange2(event) {
          setMergedValue(event.target.value);
          onChange === null || onChange === void 0 ? void 0 : onChange(event);
        };
        var textareaRef = React__namespace.useRef();
        React__namespace.useImperativeHandle(ref, function() {
          return {
            textArea: textareaRef.current
          };
        });
        var _React$useMemo = React__namespace.useMemo(function() {
          if (autoSize && _typeof$3(autoSize) === "object") {
            return [autoSize.minRows, autoSize.maxRows];
          }
          return [];
        }, [autoSize]), _React$useMemo2 = _slicedToArray$5(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
        var needAutoSize = !!autoSize;
        var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
          try {
            if (document.activeElement === textareaRef.current) {
              var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
              textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
              textareaRef.current.scrollTop = scrollTop;
            }
          } catch (e2) {
          }
        };
        var _React$useState = React__namespace.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray$5(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
        var _React$useState3 = React__namespace.useState(), _React$useState4 = _slicedToArray$5(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
        var startResize = function startResize2() {
          setResizeState(RESIZE_START);
        };
        useLayoutEffect(function() {
          if (needAutoSize) {
            startResize();
          }
        }, [value, minRows, maxRows, needAutoSize]);
        useLayoutEffect(function() {
          if (resizeState === RESIZE_START) {
            setResizeState(RESIZE_MEASURING);
          } else if (resizeState === RESIZE_MEASURING) {
            var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
            setResizeState(RESIZE_STABLE);
            setAutoSizeStyle(textareaStyles);
          } else {
            fixFirefoxAutoScroll();
          }
        }, [resizeState]);
        var resizeRafRef = React__namespace.useRef();
        var cleanRaf = function cleanRaf2() {
          wrapperRaf.cancel(resizeRafRef.current);
        };
        var onInternalResize = function onInternalResize2(size) {
          if (resizeState === RESIZE_STABLE) {
            onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
            if (autoSize) {
              cleanRaf();
              resizeRafRef.current = wrapperRaf(function() {
                startResize();
              });
            }
          }
        };
        React__namespace.useEffect(function() {
          return cleanRaf;
        }, []);
        var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
        var mergedStyle = _objectSpread2(_objectSpread2({}, style2), mergedAutoSizeStyle);
        if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
          mergedStyle.overflowY = "hidden";
          mergedStyle.overflowX = "hidden";
        }
        return /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
          onResize: onInternalResize,
          disabled: !(autoSize || onResize2)
        }, /* @__PURE__ */ React__namespace.createElement("textarea", _extends$1({}, restProps, {
          ref: textareaRef,
          style: mergedStyle,
          className: classNames(prefixCls, className, _defineProperty$3({}, "".concat(prefixCls, "-disabled"), disabled)),
          disabled,
          value: mergedValue,
          onChange: onInternalChange
        })));
      });
      var _excluded = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize"];
      function fixEmojiLength(value, maxLength) {
        return _toConsumableArray(value || "").slice(0, maxLength).join("");
      }
      function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
        var newTriggerValue = triggerValue;
        if (isCursorInEnd) {
          newTriggerValue = fixEmojiLength(triggerValue, maxLength);
        } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
          newTriggerValue = preValue;
        }
        return newTriggerValue;
      }
      var TextArea$2 = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
        var _clsx;
        var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames$1 = _ref.classNames, styles = _ref.styles, onResize2 = _ref.onResize, rest = _objectWithoutProperties(_ref, _excluded);
        var _useMergedState = useMergedState(defaultValue, {
          value: customValue,
          defaultValue
        }), _useMergedState2 = _slicedToArray$5(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
        var resizableTextAreaRef = React.useRef(null);
        var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$5(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
        var _React$useState3 = React.useState(false), _React$useState4 = _slicedToArray$5(_React$useState3, 2), compositing = _React$useState4[0], setCompositing = _React$useState4[1];
        var oldCompositionValueRef = React.useRef();
        var oldSelectionStartRef = React.useRef(0);
        var _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray$5(_React$useState5, 2), resizeStatus = _React$useState6[0], setResizeStatus = _React$useState6[1];
        var focus = function focus2() {
          resizableTextAreaRef.current.textArea.focus();
        };
        React.useImperativeHandle(ref, function() {
          return {
            resizableTextArea: resizableTextAreaRef.current,
            focus,
            blur: function blur() {
              resizableTextAreaRef.current.textArea.blur();
            }
          };
        });
        React.useEffect(function() {
          setFocused(function(prev2) {
            return !disabled && prev2;
          });
        }, [disabled]);
        var hasMaxLength = Number(maxLength) > 0;
        var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
          setCompositing(true);
          oldCompositionValueRef.current = value;
          oldSelectionStartRef.current = e2.currentTarget.selectionStart;
          onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
        };
        var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
          setCompositing(false);
          var triggerValue = e2.currentTarget.value;
          if (hasMaxLength) {
            var _oldCompositionValueR;
            var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_oldCompositionValueR = oldCompositionValueRef.current) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
            triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
          }
          if (triggerValue !== value) {
            setValue(triggerValue);
            resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
          }
          onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
        };
        var handleChange = function handleChange2(e2) {
          var triggerValue = e2.target.value;
          if (!compositing && hasMaxLength) {
            var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
            triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
          }
          setValue(triggerValue);
          resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
        };
        var handleKeyDown = function handleKeyDown2(e2) {
          var onPressEnter = rest.onPressEnter, onKeyDown = rest.onKeyDown;
          if (e2.key === "Enter" && onPressEnter) {
            onPressEnter(e2);
          }
          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
        };
        var handleFocus = function handleFocus2(e2) {
          setFocused(true);
          onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
        };
        var handleBlur = function handleBlur2(e2) {
          setFocused(false);
          onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
        };
        var handleReset = function handleReset2(e2) {
          setValue("");
          focus();
          resolveOnChange(resizableTextAreaRef.current.textArea, e2, onChange);
        };
        var val = fixControlledValue(value);
        if (!compositing && hasMaxLength && (customValue === null || customValue === void 0)) {
          val = fixEmojiLength(val, maxLength);
        }
        var suffixNode = suffix;
        var dataCount;
        if (showCount) {
          var valueLength = _toConsumableArray(val).length;
          if (_typeof$3(showCount) === "object") {
            dataCount = showCount.formatter({
              value: val,
              count: valueLength,
              maxLength
            });
          } else {
            dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
          }
          suffixNode = /* @__PURE__ */ React.createElement(React.Fragment, null, suffixNode, /* @__PURE__ */ React.createElement("span", {
            className: classNames("".concat(prefixCls, "-data-count"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
            style: styles === null || styles === void 0 ? void 0 : styles.count
          }, dataCount));
        }
        var handleResize = function handleResize2(size) {
          onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
          if (resizeStatus === null) {
            setResizeStatus("mounted");
          } else if (resizeStatus === "mounted") {
            setResizeStatus("resized");
          }
        };
        var textarea = /* @__PURE__ */ React.createElement(BaseInput, {
          value: val,
          allowClear,
          handleReset,
          suffix: suffixNode,
          prefixCls,
          classes: {
            affixWrapper: classNames(classes === null || classes === void 0 ? void 0 : classes.affixWrapper, (_clsx = {}, _defineProperty$3(_clsx, "".concat(prefixCls, "-show-count"), showCount), _defineProperty$3(_clsx, "".concat(prefixCls, "-textarea-allow-clear"), allowClear), _clsx))
          },
          disabled,
          focused,
          className,
          style: _objectSpread2(_objectSpread2({}, style2), resizeStatus === "resized" ? {
            height: "auto"
          } : {}),
          dataAttrs: {
            affixWrapper: {
              "data-count": typeof dataCount === "string" ? dataCount : void 0
            }
          },
          hidden,
          inputElement: /* @__PURE__ */ React.createElement(ResizableTextArea, _extends$1({}, rest, {
            onKeyDown: handleKeyDown,
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onCompositionStart: onInternalCompositionStart,
            onCompositionEnd: onInternalCompositionEnd,
            className: classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.textarea,
            style: _objectSpread2(_objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
              resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
            }),
            disabled,
            prefixCls,
            onResize: handleResize,
            ref: resizableTextAreaRef
          }))
        });
        return textarea;
      });
      var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const TextArea = /* @__PURE__ */ React.forwardRef((_a, ref) => {
        var {
          prefixCls: customizePrefixCls,
          bordered = true,
          size: customizeSize,
          disabled: customDisabled,
          status: customStatus,
          allowClear,
          showCount,
          classNames: classes
        } = _a, rest = __rest$7(_a, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "showCount", "classNames"]);
        const {
          getPrefixCls,
          direction
        } = React__namespace.useContext(ConfigContext);
        const mergedSize = useSize$1(customizeSize);
        const disabled = React__namespace.useContext(DisabledContext$1);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const {
          status: contextStatus,
          hasFeedback,
          feedbackIcon
        } = React__namespace.useContext(FormItemInputContext);
        const mergedStatus = getMergedStatus(contextStatus, customStatus);
        const innerRef = React__namespace.useRef(null);
        React__namespace.useImperativeHandle(ref, () => {
          var _a2;
          return {
            resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
            focus: (option) => {
              var _a3, _b;
              triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
            },
            blur: () => {
              var _a3;
              return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
            }
          };
        });
        const prefixCls = getPrefixCls("input", customizePrefixCls);
        let mergedAllowClear;
        if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
          mergedAllowClear = allowClear;
        } else if (allowClear) {
          mergedAllowClear = {
            clearIcon: /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null)
          };
        }
        const [wrapSSR, hashId] = useStyle$2(prefixCls);
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(TextArea$2, Object.assign({}, rest, {
          disabled: mergedDisabled,
          allowClear: mergedAllowClear,
          classes: {
            affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
              [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
              [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
              [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-textarea-show-count`]: showCount
            }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId)
          },
          classNames: Object.assign(Object.assign({}, classes), {
            textarea: classNames({
              [`${prefixCls}-borderless`]: !bordered,
              [`${prefixCls}-sm`]: mergedSize === "small",
              [`${prefixCls}-lg`]: mergedSize === "large"
            }, getStatusClassNames(prefixCls, mergedStatus), hashId, classes === null || classes === void 0 ? void 0 : classes.textarea)
          }),
          prefixCls,
          suffix: hasFeedback && /* @__PURE__ */ React__namespace.createElement("span", {
            className: `${prefixCls}-textarea-suffix`
          }, feedbackIcon),
          showCount,
          ref: innerRef
        })));
      });
      const TextArea$1 = TextArea;
      const Input = InternalInput;
      Input.Group = Group$1;
      Input.Search = Search$1;
      Input.TextArea = TextArea$1;
      Input.Password = Password$1;
      const Input$1 = Input;
      function PickerButton(props) {
        return /* @__PURE__ */ React__namespace.createElement(Button$1, Object.assign({
          size: "small",
          type: "primary"
        }, props));
      }
      var CalendarOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
      const CalendarOutlinedSvg = CalendarOutlined$2;
      var CalendarOutlined = function CalendarOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: CalendarOutlinedSvg
        }));
      };
      const CalendarOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(CalendarOutlined);
      var ClockCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
      const ClockCircleOutlinedSvg = ClockCircleOutlined$2;
      var ClockCircleOutlined = function ClockCircleOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: ClockCircleOutlinedSvg
        }));
      };
      const ClockCircleOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(ClockCircleOutlined);
      var SwapRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
      const SwapRightOutlinedSvg = SwapRightOutlined$2;
      var SwapRightOutlined = function SwapRightOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: SwapRightOutlinedSvg
        }));
      };
      const SwapRightOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(SwapRightOutlined);
      function getPlaceholder(locale2, picker, customizePlaceholder) {
        if (customizePlaceholder !== void 0) {
          return customizePlaceholder;
        }
        if (picker === "year" && locale2.lang.yearPlaceholder) {
          return locale2.lang.yearPlaceholder;
        }
        if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
          return locale2.lang.quarterPlaceholder;
        }
        if (picker === "month" && locale2.lang.monthPlaceholder) {
          return locale2.lang.monthPlaceholder;
        }
        if (picker === "week" && locale2.lang.weekPlaceholder) {
          return locale2.lang.weekPlaceholder;
        }
        if (picker === "time" && locale2.timePickerLocale.placeholder) {
          return locale2.timePickerLocale.placeholder;
        }
        return locale2.lang.placeholder;
      }
      function getRangePlaceholder(locale2, picker, customizePlaceholder) {
        if (customizePlaceholder !== void 0) {
          return customizePlaceholder;
        }
        if (picker === "year" && locale2.lang.yearPlaceholder) {
          return locale2.lang.rangeYearPlaceholder;
        }
        if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
          return locale2.lang.rangeQuarterPlaceholder;
        }
        if (picker === "month" && locale2.lang.monthPlaceholder) {
          return locale2.lang.rangeMonthPlaceholder;
        }
        if (picker === "week" && locale2.lang.weekPlaceholder) {
          return locale2.lang.rangeWeekPlaceholder;
        }
        if (picker === "time" && locale2.timePickerLocale.placeholder) {
          return locale2.timePickerLocale.rangePlaceholder;
        }
        return locale2.lang.rangePlaceholder;
      }
      function transPlacement2DropdownAlign(direction, placement) {
        const overflow = {
          adjustX: 1,
          adjustY: 1
        };
        switch (placement) {
          case "bottomLeft": {
            return {
              points: ["tl", "bl"],
              offset: [0, 4],
              overflow
            };
          }
          case "bottomRight": {
            return {
              points: ["tr", "br"],
              offset: [0, 4],
              overflow
            };
          }
          case "topLeft": {
            return {
              points: ["bl", "tl"],
              offset: [0, -4],
              overflow
            };
          }
          case "topRight": {
            return {
              points: ["br", "tr"],
              offset: [0, -4],
              overflow
            };
          }
          default: {
            return {
              points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
              offset: [0, 4],
              overflow
            };
          }
        }
      }
      var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function generateRangePicker(generateConfig2) {
        const RangePicker$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
          const {
            prefixCls: customizePrefixCls,
            getPopupContainer: customGetPopupContainer,
            className,
            placement,
            size: customizeSize,
            disabled: customDisabled,
            bordered = true,
            placeholder,
            popupClassName,
            dropdownClassName,
            status: customStatus
          } = props, restProps = __rest$6(props, ["prefixCls", "getPopupContainer", "className", "placement", "size", "disabled", "bordered", "placeholder", "popupClassName", "dropdownClassName", "status"]);
          const innerRef = React__namespace.useRef(null);
          const {
            getPrefixCls,
            direction,
            getPopupContainer
          } = React.useContext(ConfigContext);
          const prefixCls = getPrefixCls("picker", customizePrefixCls);
          const {
            compactSize,
            compactItemClassnames
          } = useCompactItemContext(prefixCls, direction);
          const {
            format: format2,
            showTime,
            picker
          } = props;
          const rootPrefixCls = getPrefixCls();
          const [wrapSSR, hashId] = useStyle$1(prefixCls);
          let additionalOverrideProps = {};
          additionalOverrideProps = Object.assign(Object.assign(Object.assign({}, additionalOverrideProps), showTime ? getTimeProps(Object.assign({
            format: format2,
            picker
          }, showTime)) : {}), picker === "time" ? getTimeProps(Object.assign(Object.assign({
            format: format2
          }, props), {
            picker
          })) : {});
          const mergedSize = useSize$1((ctx) => {
            var _a;
            return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
          });
          const disabled = React__namespace.useContext(DisabledContext$1);
          const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
          const formItemContext = React.useContext(FormItemInputContext);
          const {
            hasFeedback,
            status: contextStatus,
            feedbackIcon
          } = formItemContext;
          const suffixNode = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, picker === "time" ? /* @__PURE__ */ React__namespace.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ React__namespace.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
          React.useImperativeHandle(ref, () => ({
            focus: () => {
              var _a;
              return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
            }
          }));
          const [contextLocale] = useLocale$1("Calendar", enUS);
          const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
          return wrapSSR(/* @__PURE__ */ React__namespace.createElement(RangePicker, Object.assign({
            separator: /* @__PURE__ */ React__namespace.createElement("span", {
              "aria-label": "to",
              className: `${prefixCls}-separator`
            }, /* @__PURE__ */ React__namespace.createElement(SwapRightOutlined$1, null)),
            disabled: mergedDisabled,
            ref: innerRef,
            dropdownAlign: transPlacement2DropdownAlign(direction, placement),
            placeholder: getRangePlaceholder(locale2, picker, placeholder),
            suffixIcon: suffixNode,
            clearIcon: /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null),
            prevIcon: /* @__PURE__ */ React__namespace.createElement("span", {
              className: `${prefixCls}-prev-icon`
            }),
            nextIcon: /* @__PURE__ */ React__namespace.createElement("span", {
              className: `${prefixCls}-next-icon`
            }),
            superPrevIcon: /* @__PURE__ */ React__namespace.createElement("span", {
              className: `${prefixCls}-super-prev-icon`
            }),
            superNextIcon: /* @__PURE__ */ React__namespace.createElement("span", {
              className: `${prefixCls}-super-next-icon`
            }),
            allowClear: true,
            transitionName: `${rootPrefixCls}-slide-up`
          }, restProps, additionalOverrideProps, {
            className: classNames({
              [`${prefixCls}-${mergedSize}`]: mergedSize,
              [`${prefixCls}-borderless`]: !bordered
            }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className),
            locale: locale2.lang,
            prefixCls,
            getPopupContainer: customGetPopupContainer || getPopupContainer,
            generateConfig: generateConfig2,
            components: Components,
            direction,
            dropdownClassName: classNames(hashId, popupClassName || dropdownClassName)
          })));
        });
        return RangePicker$1;
      }
      var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function generatePicker$1(generateConfig2) {
        function getPicker(picker, displayName) {
          const Picker$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
            const {
              prefixCls: customizePrefixCls,
              getPopupContainer: customizeGetPopupContainer,
              className,
              rootClassName,
              size: customizeSize,
              bordered = true,
              placement,
              placeholder,
              popupClassName,
              dropdownClassName,
              disabled: customDisabled,
              status: customStatus
            } = props, restProps = __rest$5(props, ["prefixCls", "getPopupContainer", "className", "rootClassName", "size", "bordered", "placement", "placeholder", "popupClassName", "dropdownClassName", "disabled", "status"]);
            const {
              getPrefixCls,
              direction,
              getPopupContainer
            } = React.useContext(ConfigContext);
            const prefixCls = getPrefixCls("picker", customizePrefixCls);
            const {
              compactSize,
              compactItemClassnames
            } = useCompactItemContext(prefixCls, direction);
            const innerRef = React__namespace.useRef(null);
            const {
              format: format2,
              showTime
            } = props;
            const [wrapSSR, hashId] = useStyle$1(prefixCls);
            React.useImperativeHandle(ref, () => ({
              focus: () => {
                var _a;
                return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                var _a;
                return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
              }
            }));
            const additionalProps = {
              showToday: true
            };
            let additionalOverrideProps = {};
            if (picker) {
              additionalOverrideProps.picker = picker;
            }
            const mergedPicker = picker || props.picker;
            additionalOverrideProps = Object.assign(Object.assign(Object.assign({}, additionalOverrideProps), showTime ? getTimeProps(Object.assign({
              format: format2,
              picker: mergedPicker
            }, showTime)) : {}), mergedPicker === "time" ? getTimeProps(Object.assign(Object.assign({
              format: format2
            }, props), {
              picker: mergedPicker
            })) : {});
            const rootPrefixCls = getPrefixCls();
            const mergedSize = useSize$1((ctx) => {
              var _a;
              return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
            });
            const disabled = React__namespace.useContext(DisabledContext$1);
            const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
            const formItemContext = React.useContext(FormItemInputContext);
            const {
              hasFeedback,
              status: contextStatus,
              feedbackIcon
            } = formItemContext;
            const suffixNode = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ React__namespace.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ React__namespace.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
            const [contextLocale] = useLocale$1("DatePicker", enUS);
            const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
            return wrapSSR(/* @__PURE__ */ React__namespace.createElement(Picker, Object.assign({
              ref: innerRef,
              placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
              suffixIcon: suffixNode,
              dropdownAlign: transPlacement2DropdownAlign(direction, placement),
              clearIcon: /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null),
              prevIcon: /* @__PURE__ */ React__namespace.createElement("span", {
                className: `${prefixCls}-prev-icon`
              }),
              nextIcon: /* @__PURE__ */ React__namespace.createElement("span", {
                className: `${prefixCls}-next-icon`
              }),
              superPrevIcon: /* @__PURE__ */ React__namespace.createElement("span", {
                className: `${prefixCls}-super-prev-icon`
              }),
              superNextIcon: /* @__PURE__ */ React__namespace.createElement("span", {
                className: `${prefixCls}-super-next-icon`
              }),
              allowClear: true,
              transitionName: `${rootPrefixCls}-slide-up`
            }, additionalProps, restProps, additionalOverrideProps, {
              locale: locale2.lang,
              className: classNames({
                [`${prefixCls}-${mergedSize}`]: mergedSize,
                [`${prefixCls}-borderless`]: !bordered
              }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rootClassName),
              prefixCls,
              getPopupContainer: customizeGetPopupContainer || getPopupContainer,
              generateConfig: generateConfig2,
              components: Components,
              direction,
              disabled: mergedDisabled,
              dropdownClassName: classNames(hashId, rootClassName, popupClassName || dropdownClassName)
            })));
          });
          if (displayName) {
            Picker$1.displayName = displayName;
          }
          return Picker$1;
        }
        const DatePicker2 = getPicker();
        const WeekPicker = getPicker("week", "WeekPicker");
        const MonthPicker = getPicker("month", "MonthPicker");
        const YearPicker = getPicker("year", "YearPicker");
        const TimePicker2 = getPicker("time", "TimePicker");
        const QuarterPicker = getPicker("quarter", "QuarterPicker");
        return {
          DatePicker: DatePicker2,
          WeekPicker,
          MonthPicker,
          YearPicker,
          TimePicker: TimePicker2,
          QuarterPicker
        };
      }
      const Components = {
        button: PickerButton
      };
      function toArray$1(list) {
        if (!list) {
          return [];
        }
        return Array.isArray(list) ? list : [list];
      }
      function getTimeProps(props) {
        const {
          format: format2,
          picker,
          showHour,
          showMinute,
          showSecond,
          use12Hours
        } = props;
        const firstFormat = toArray$1(format2)[0];
        const showTimeObj = Object.assign({}, props);
        if (firstFormat && typeof firstFormat === "string") {
          if (!firstFormat.includes("s") && showSecond === void 0) {
            showTimeObj.showSecond = false;
          }
          if (!firstFormat.includes("m") && showMinute === void 0) {
            showTimeObj.showMinute = false;
          }
          if (!firstFormat.includes("H") && !firstFormat.includes("h") && !firstFormat.includes("K") && !firstFormat.includes("k") && showHour === void 0) {
            showTimeObj.showHour = false;
          }
          if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
            showTimeObj.use12Hours = true;
          }
        }
        if (picker === "time") {
          return showTimeObj;
        }
        if (typeof firstFormat === "function") {
          delete showTimeObj.format;
        }
        return {
          showTime: showTimeObj
        };
      }
      function generatePicker(generateConfig2) {
        const {
          DatePicker: DatePicker2,
          WeekPicker,
          MonthPicker,
          YearPicker,
          TimePicker: TimePicker2,
          QuarterPicker
        } = generatePicker$1(generateConfig2);
        const RangePicker2 = generateRangePicker(generateConfig2);
        const MergedDatePicker = DatePicker2;
        MergedDatePicker.WeekPicker = WeekPicker;
        MergedDatePicker.MonthPicker = MonthPicker;
        MergedDatePicker.YearPicker = YearPicker;
        MergedDatePicker.RangePicker = RangePicker2;
        MergedDatePicker.TimePicker = TimePicker2;
        MergedDatePicker.QuarterPicker = QuarterPicker;
        return MergedDatePicker;
      }
      const DatePicker = generatePicker(generateConfig);
      function postPureProps(props) {
        const dropdownAlign = transPlacement2DropdownAlign(props.direction, props.placement);
        dropdownAlign.overflow.adjustY = false;
        dropdownAlign.overflow.adjustX = false;
        return Object.assign(Object.assign({}, props), {
          dropdownAlign
        });
      }
      const PurePanel$2 = genPurePanel(DatePicker, "picker", null, postPureProps);
      DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
      const PureRangePanel = genPurePanel(DatePicker.RangePicker, "picker", null, postPureProps);
      DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
      DatePicker.generatePicker = generatePicker;
      const DatePicker$1 = DatePicker;
      function useDebounce(value) {
        const [cacheValue, setCacheValue] = React__namespace.useState(value);
        React__namespace.useEffect(() => {
          const timeout = setTimeout(() => {
            setCacheValue(value);
          }, value.length ? 0 : 10);
          return () => {
            clearTimeout(timeout);
          };
        }, [value]);
        return cacheValue;
      }
      const genFormValidateMotionStyle = (token2) => {
        const {
          componentCls
        } = token2;
        const helpCls = `${componentCls}-show-help`;
        const helpItemCls = `${componentCls}-show-help-item`;
        return {
          [helpCls]: {
            // Explain holder
            transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
            "&-appear, &-enter": {
              opacity: 0,
              "&-active": {
                opacity: 1
              }
            },
            "&-leave": {
              opacity: 1,
              "&-active": {
                opacity: 0
              }
            },
            // Explain
            [helpItemCls]: {
              overflow: "hidden",
              transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
              [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
                transform: `translateY(-5px)`,
                opacity: 0,
                [`&-active`]: {
                  transform: "translateY(0)",
                  opacity: 1
                }
              },
              [`&${helpItemCls}-leave-active`]: {
                transform: `translateY(-5px)`
              }
            }
          }
        };
      };
      const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;
      const resetForm = (token2) => ({
        legend: {
          display: "block",
          width: "100%",
          marginBottom: token2.marginLG,
          padding: 0,
          color: token2.colorTextDescription,
          fontSize: token2.fontSizeLG,
          lineHeight: "inherit",
          border: 0,
          borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        label: {
          fontSize: token2.fontSize
        },
        'input[type="search"]': {
          boxSizing: "border-box"
        },
        // Position radios and checkboxes better
        'input[type="radio"], input[type="checkbox"]': {
          lineHeight: "normal"
        },
        'input[type="file"]': {
          display: "block"
        },
        // Make range inputs behave like textual form controls
        'input[type="range"]': {
          display: "block",
          width: "100%"
        },
        // Make multiple select elements height not fixed
        "select[multiple], select[size]": {
          height: "auto"
        },
        // Focus for file, radio, and checkbox
        [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
          outline: 0,
          boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
        },
        // Adjust output element
        output: {
          display: "block",
          paddingTop: 15,
          color: token2.colorText,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        }
      });
      const genFormSize = (token2, height) => {
        const {
          formItemCls
        } = token2;
        return {
          [formItemCls]: {
            [`${formItemCls}-label > label`]: {
              height
            },
            [`${formItemCls}-control-input`]: {
              minHeight: height
            }
          }
        };
      };
      const genFormStyle = (token2) => {
        const {
          componentCls
        } = token2;
        return {
          [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
            [`${componentCls}-text`]: {
              display: "inline-block",
              paddingInlineEnd: token2.paddingSM
            },
            // ================================================================
            // =                             Size                             =
            // ================================================================
            "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
            "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
          })
        };
      };
      const genFormItemStyle = (token2) => {
        const {
          formItemCls,
          iconCls,
          componentCls,
          rootPrefixCls
        } = token2;
        return {
          [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            marginBottom: token2.marginLG,
            verticalAlign: "top",
            "&-with-help": {
              transition: "none"
            },
            [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
              // https://github.com/ant-design/ant-design/issues/26141
              display: "none"
            },
            "&-has-warning": {
              [`${formItemCls}-split`]: {
                color: token2.colorError
              }
            },
            "&-has-error": {
              [`${formItemCls}-split`]: {
                color: token2.colorWarning
              }
            },
            // ==============================================================
            // =                            Label                           =
            // ==============================================================
            [`${formItemCls}-label`]: {
              display: "inline-block",
              flexGrow: 0,
              overflow: "hidden",
              whiteSpace: "nowrap",
              textAlign: "end",
              verticalAlign: "middle",
              "&-left": {
                textAlign: "start"
              },
              "&-wrap": {
                overflow: "unset",
                lineHeight: `${token2.lineHeight} - 0.25em`,
                whiteSpace: "unset"
              },
              "> label": {
                position: "relative",
                display: "inline-flex",
                alignItems: "center",
                maxWidth: "100%",
                height: token2.controlHeight,
                color: token2.colorTextHeading,
                fontSize: token2.fontSize,
                [`> ${iconCls}`]: {
                  fontSize: token2.fontSize,
                  verticalAlign: "top"
                },
                // Required mark
                [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
                  display: "inline-block",
                  marginInlineEnd: token2.marginXXS,
                  color: token2.colorError,
                  fontSize: token2.fontSize,
                  fontFamily: "SimSun, sans-serif",
                  lineHeight: 1,
                  content: '"*"',
                  [`${componentCls}-hide-required-mark &`]: {
                    display: "none"
                  }
                },
                // Optional mark
                [`${formItemCls}-optional`]: {
                  display: "inline-block",
                  marginInlineStart: token2.marginXXS,
                  color: token2.colorTextDescription,
                  [`${componentCls}-hide-required-mark &`]: {
                    display: "none"
                  }
                },
                // Optional mark
                [`${formItemCls}-tooltip`]: {
                  color: token2.colorTextDescription,
                  cursor: "help",
                  writingMode: "horizontal-tb",
                  marginInlineStart: token2.marginXXS
                },
                "&::after": {
                  content: '":"',
                  position: "relative",
                  marginBlock: 0,
                  marginInlineStart: token2.marginXXS / 2,
                  marginInlineEnd: token2.marginXS
                },
                [`&${formItemCls}-no-colon::after`]: {
                  content: '" "'
                }
              }
            },
            // ==============================================================
            // =                            Input                           =
            // ==============================================================
            [`${formItemCls}-control`]: {
              display: "flex",
              flexDirection: "column",
              flexGrow: 1,
              [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
                width: "100%"
              },
              "&-input": {
                position: "relative",
                display: "flex",
                alignItems: "center",
                minHeight: token2.controlHeight,
                "&-content": {
                  flex: "auto",
                  maxWidth: "100%"
                }
              }
            },
            // ==============================================================
            // =                           Explain                          =
            // ==============================================================
            [formItemCls]: {
              "&-explain, &-extra": {
                clear: "both",
                color: token2.colorTextDescription,
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight
              },
              "&-explain-connected": {
                width: "100%"
              },
              "&-extra": {
                minHeight: token2.controlHeightSM,
                transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
                // sync input color transition
              },
              "&-explain": {
                "&-error": {
                  color: token2.colorError
                },
                "&-warning": {
                  color: token2.colorWarning
                }
              }
            },
            [`&-with-help ${formItemCls}-explain`]: {
              height: "auto",
              opacity: 1
            },
            // ==============================================================
            // =                        Feedback Icon                       =
            // ==============================================================
            [`${formItemCls}-feedback-icon`]: {
              fontSize: token2.fontSize,
              textAlign: "center",
              visibility: "visible",
              animationName: zoomIn,
              animationDuration: token2.motionDurationMid,
              animationTimingFunction: token2.motionEaseOutBack,
              pointerEvents: "none",
              "&-success": {
                color: token2.colorSuccess
              },
              "&-error": {
                color: token2.colorError
              },
              "&-warning": {
                color: token2.colorWarning
              },
              "&-validating": {
                color: token2.colorPrimary
              }
            }
          })
        };
      };
      const genHorizontalStyle = (token2) => {
        const {
          componentCls,
          formItemCls,
          rootPrefixCls
        } = token2;
        return {
          [`${componentCls}-horizontal`]: {
            [`${formItemCls}-label`]: {
              flexGrow: 0
            },
            [`${formItemCls}-control`]: {
              flex: "1 1 0",
              // https://github.com/ant-design/ant-design/issues/32777
              // https://github.com/ant-design/ant-design/issues/33773
              minWidth: 0
            },
            // https://github.com/ant-design/ant-design/issues/32980
            [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
              minWidth: "unset"
            }
          }
        };
      };
      const genInlineStyle = (token2) => {
        const {
          componentCls,
          formItemCls
        } = token2;
        return {
          [`${componentCls}-inline`]: {
            display: "flex",
            flexWrap: "wrap",
            [formItemCls]: {
              flex: "none",
              marginInlineEnd: token2.margin,
              marginBottom: 0,
              "&-row": {
                flexWrap: "nowrap"
              },
              "&-with-help": {
                marginBottom: token2.marginLG
              },
              [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
                display: "inline-block",
                verticalAlign: "top"
              },
              [`> ${formItemCls}-label`]: {
                flex: "none"
              },
              [`${componentCls}-text`]: {
                display: "inline-block"
              },
              [`${formItemCls}-has-feedback`]: {
                display: "inline-block"
              }
            }
          }
        };
      };
      const makeVerticalLayoutLabel = (token2) => ({
        padding: `0 0 ${token2.paddingXS}px`,
        whiteSpace: "initial",
        textAlign: "start",
        "> label": {
          margin: 0,
          "&::after": {
            display: "none"
          }
        }
      });
      const makeVerticalLayout = (token2) => {
        const {
          componentCls,
          formItemCls
        } = token2;
        return {
          [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
          [componentCls]: {
            [formItemCls]: {
              flexWrap: "wrap",
              [`${formItemCls}-label,
          ${formItemCls}-control`]: {
                flex: "0 0 100%",
                maxWidth: "100%"
              }
            }
          }
        };
      };
      const genVerticalStyle = (token2) => {
        const {
          componentCls,
          formItemCls,
          rootPrefixCls
        } = token2;
        return {
          [`${componentCls}-vertical`]: {
            [formItemCls]: {
              "&-row": {
                flexDirection: "column"
              },
              "&-label > label": {
                height: "auto"
              },
              [`${componentCls}-item-control`]: {
                width: "100%"
              }
            }
          },
          [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
          [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
            [componentCls]: {
              [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }],
          [`@media (max-width: ${token2.screenSMMax}px)`]: {
            [componentCls]: {
              [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          },
          [`@media (max-width: ${token2.screenMDMax}px)`]: {
            [componentCls]: {
              [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          },
          [`@media (max-width: ${token2.screenLGMax}px)`]: {
            [componentCls]: {
              [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }
        };
      };
      const useStyle = genComponentStyleHook("Form", (token2, _ref) => {
        let {
          rootPrefixCls
        } = _ref;
        const formToken = merge(token2, {
          formItemCls: `${token2.componentCls}-item`,
          rootPrefixCls
        });
        return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
      });
      const EMPTY_LIST = [];
      function toErrorEntity(error, prefix, errorStatus) {
        let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        return {
          key: typeof error === "string" ? error : `${prefix}-${index2}`,
          error,
          errorStatus
        };
      }
      function ErrorList(_ref) {
        let {
          help,
          helpStatus,
          errors = EMPTY_LIST,
          warnings = EMPTY_LIST,
          className: rootClassName,
          fieldId,
          onVisibleChanged
        } = _ref;
        const {
          prefixCls
        } = React__namespace.useContext(FormItemPrefixContext);
        const baseClassName = `${prefixCls}-item-explain`;
        const [, hashId] = useStyle(prefixCls);
        const collapseMotion = React.useMemo(() => initCollapseMotion$1(prefixCls), [prefixCls]);
        const debounceErrors = useDebounce(errors);
        const debounceWarnings = useDebounce(warnings);
        const fullKeyList = React__namespace.useMemo(() => {
          if (help !== void 0 && help !== null) {
            return [toErrorEntity(help, "help", helpStatus)];
          }
          return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning2, index2) => toErrorEntity(warning2, "warning", "warning", index2))));
        }, [help, helpStatus, debounceErrors, debounceWarnings]);
        const helpProps = {};
        if (fieldId) {
          helpProps.id = `${fieldId}_help`;
        }
        return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
          motionDeadline: collapseMotion.motionDeadline,
          motionName: `${prefixCls}-show-help`,
          visible: !!fullKeyList.length,
          onVisibleChanged
        }, (holderProps) => {
          const {
            className: holderClassName,
            style: holderStyle
          } = holderProps;
          return /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, helpProps, {
            className: classNames(baseClassName, holderClassName, rootClassName, hashId),
            style: holderStyle,
            role: "alert"
          }), /* @__PURE__ */ React__namespace.createElement(CSSMotionList, Object.assign({
            keys: fullKeyList
          }, initCollapseMotion$1(prefixCls), {
            motionName: `${prefixCls}-show-help-item`,
            component: false
          }), (itemProps) => {
            const {
              key: key2,
              error,
              errorStatus,
              className: itemClassName,
              style: itemStyle
            } = itemProps;
            return /* @__PURE__ */ React__namespace.createElement("div", {
              key: key2,
              className: classNames(itemClassName, {
                [`${baseClassName}-${errorStatus}`]: errorStatus
              }),
              style: itemStyle
            }, error);
          }));
        });
      }
      const formItemNameBlackList = ["parentNode"];
      const defaultItemNamePrefixCls = "form_item";
      function toArray(candidate) {
        if (candidate === void 0 || candidate === false)
          return [];
        return Array.isArray(candidate) ? candidate : [candidate];
      }
      function getFieldId(namePath, formName) {
        if (!namePath.length) {
          return void 0;
        }
        const mergedId = namePath.join("_");
        if (formName) {
          return `${formName}_${mergedId}`;
        }
        const isIllegalName = formItemNameBlackList.includes(mergedId);
        return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
      }
      function toNamePathStr(name) {
        const namePath = toArray(name);
        return namePath.join("_");
      }
      function useForm(form) {
        const [rcForm] = useForm$1();
        const itemsRef = React__namespace.useRef({});
        const wrapForm = React__namespace.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
          __INTERNAL__: {
            itemRef: (name) => (node2) => {
              const namePathStr = toNamePathStr(name);
              if (node2) {
                itemsRef.current[namePathStr] = node2;
              } else {
                delete itemsRef.current[namePathStr];
              }
            }
          },
          scrollToField: function(name) {
            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const namePath = toArray(name);
            const fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
            const node2 = fieldId ? document.getElementById(fieldId) : null;
            if (node2) {
              t(node2, Object.assign({
                scrollMode: "if-needed",
                block: "nearest"
              }, options));
            }
          },
          getFieldInstance: (name) => {
            const namePathStr = toNamePathStr(name);
            return itemsRef.current[namePathStr];
          }
        }), [form, rcForm]);
        return [wrapForm];
      }
      var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const InternalForm = (props, ref) => {
        const contextDisabled = React__namespace.useContext(DisabledContext$1);
        const {
          getPrefixCls,
          direction,
          form: contextForm
        } = React__namespace.useContext(ConfigContext);
        const {
          prefixCls: customizePrefixCls,
          className,
          rootClassName,
          size,
          disabled = contextDisabled,
          form,
          colon,
          labelAlign,
          labelWrap,
          labelCol,
          wrapperCol,
          hideRequiredMark,
          layout = "horizontal",
          scrollToFirstError,
          requiredMark,
          onFinishFailed,
          name
        } = props, restFormProps = __rest$4(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name"]);
        const mergedSize = useSize$1(size);
        const contextValidateMessages = React__namespace.useContext(ValidateMessagesContext);
        const mergedRequiredMark = React.useMemo(() => {
          if (requiredMark !== void 0) {
            return requiredMark;
          }
          if (contextForm && contextForm.requiredMark !== void 0) {
            return contextForm.requiredMark;
          }
          if (hideRequiredMark) {
            return false;
          }
          return true;
        }, [hideRequiredMark, requiredMark, contextForm]);
        const mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
        const prefixCls = getPrefixCls("form", customizePrefixCls);
        const [wrapSSR, hashId] = useStyle(prefixCls);
        const formClassName = classNames(prefixCls, {
          [`${prefixCls}-${layout}`]: true,
          [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-${mergedSize}`]: mergedSize
        }, hashId, className, rootClassName);
        const [wrapForm] = useForm(form);
        const {
          __INTERNAL__
        } = wrapForm;
        __INTERNAL__.name = name;
        const formContextValue = React.useMemo(() => ({
          name,
          labelAlign,
          labelCol,
          labelWrap,
          wrapperCol,
          vertical: layout === "vertical",
          colon: mergedColon,
          requiredMark: mergedRequiredMark,
          itemRef: __INTERNAL__.itemRef,
          form: wrapForm
        }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm]);
        React__namespace.useImperativeHandle(ref, () => wrapForm);
        const scrollToField = (options, fieldName) => {
          if (options) {
            let defaultScrollToFirstError = {
              block: "nearest"
            };
            if (typeof options === "object") {
              defaultScrollToFirstError = options;
            }
            wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
          }
        };
        const onInternalFinishFailed = (errorInfo) => {
          onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
          if (errorInfo.errorFields.length) {
            const fieldName = errorInfo.errorFields[0].name;
            if (scrollToFirstError !== void 0) {
              scrollToField(scrollToFirstError, fieldName);
              return;
            }
            if (contextForm && contextForm.scrollToFirstError !== void 0) {
              scrollToField(contextForm.scrollToFirstError, fieldName);
            }
          }
        };
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(DisabledContextProvider, {
          disabled
        }, /* @__PURE__ */ React__namespace.createElement(SizeContextProvider, {
          size: mergedSize
        }, /* @__PURE__ */ React__namespace.createElement(FormProvider, {
          // This is not list in API, we pass with spread
          validateMessages: contextValidateMessages
        }, /* @__PURE__ */ React__namespace.createElement(FormContext.Provider, {
          value: formContextValue
        }, /* @__PURE__ */ React__namespace.createElement(RefForm, Object.assign({
          id: name
        }, restFormProps, {
          name,
          onFinishFailed: onInternalFinishFailed,
          form: wrapForm,
          className: formClassName
        })))))));
      };
      const Form$2 = /* @__PURE__ */ React__namespace.forwardRef(InternalForm);
      const InternalForm$1 = Form$2;
      const useFormItemStatus = () => {
        const {
          status,
          errors = [],
          warnings = []
        } = React.useContext(FormItemInputContext);
        return {
          status,
          errors,
          warnings
        };
      };
      useFormItemStatus.Context = FormItemInputContext;
      const useFormItemStatus$1 = useFormItemStatus;
      function useFrameState(defaultValue) {
        const [value, setValue] = React__namespace.useState(defaultValue);
        const frameRef = React.useRef(null);
        const batchRef = React.useRef([]);
        const destroyRef = React.useRef(false);
        React__namespace.useEffect(() => {
          destroyRef.current = false;
          return () => {
            destroyRef.current = true;
            wrapperRaf.cancel(frameRef.current);
            frameRef.current = null;
          };
        }, []);
        function setFrameValue(updater) {
          if (destroyRef.current) {
            return;
          }
          if (frameRef.current === null) {
            batchRef.current = [];
            frameRef.current = wrapperRaf(() => {
              frameRef.current = null;
              setValue((prevValue) => {
                let current = prevValue;
                batchRef.current.forEach((func) => {
                  current = func(current);
                });
                return current;
              });
            });
          }
          batchRef.current.push(updater);
        }
        return [value, setFrameValue];
      }
      function useItemRef() {
        const {
          itemRef
        } = React__namespace.useContext(FormContext);
        const cacheRef = React__namespace.useRef({});
        function getRef(name, children) {
          const childrenRef = children && typeof children === "object" && children.ref;
          const nameStr = name.join("_");
          if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
            cacheRef.current.name = nameStr;
            cacheRef.current.originRef = childrenRef;
            cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
          }
          return cacheRef.current.ref;
        }
        return getRef;
      }
      const FormItemInput = (props) => {
        const {
          prefixCls,
          status,
          wrapperCol,
          children,
          errors,
          warnings,
          _internalItemRender: formItemRender,
          extra,
          help,
          fieldId,
          marginBottom,
          onErrorVisibleChanged
        } = props;
        const baseClassName = `${prefixCls}-item`;
        const formContext = React__namespace.useContext(FormContext);
        const mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
        const className = classNames(`${baseClassName}-control`, mergedWrapperCol.className);
        const subFormContext = React__namespace.useMemo(() => Object.assign({}, formContext), [formContext]);
        delete subFormContext.labelCol;
        delete subFormContext.wrapperCol;
        const inputDom = /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${baseClassName}-control-input`
        }, /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${baseClassName}-control-input-content`
        }, children));
        const formItemContext = React__namespace.useMemo(() => ({
          prefixCls,
          status
        }), [prefixCls, status]);
        const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ React__namespace.createElement("div", {
          style: {
            display: "flex",
            flexWrap: "nowrap"
          }
        }, /* @__PURE__ */ React__namespace.createElement(FormItemPrefixContext.Provider, {
          value: formItemContext
        }, /* @__PURE__ */ React__namespace.createElement(ErrorList, {
          fieldId,
          errors,
          warnings,
          help,
          helpStatus: status,
          className: `${baseClassName}-explain-connected`,
          onVisibleChanged: onErrorVisibleChanged
        })), !!marginBottom && /* @__PURE__ */ React__namespace.createElement("div", {
          style: {
            width: 0,
            height: marginBottom
          }
        })) : null;
        const extraProps = {};
        if (fieldId) {
          extraProps.id = `${fieldId}_extra`;
        }
        const extraDom = extra ? /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, extraProps, {
          className: `${baseClassName}-extra`
        }), extra) : null;
        const dom2 = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
          input: inputDom,
          errorList: errorListDom,
          extra: extraDom
        }) : /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, inputDom, errorListDom, extraDom);
        return /* @__PURE__ */ React__namespace.createElement(FormContext.Provider, {
          value: subFormContext
        }, /* @__PURE__ */ React__namespace.createElement(Col$1, Object.assign({}, mergedWrapperCol, {
          className
        }), dom2));
      };
      const FormItemInput$1 = FormItemInput;
      var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
      const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
      var QuestionCircleOutlined = function QuestionCircleOutlined2(props, ref) {
        return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$1({}, props, {
          ref,
          icon: QuestionCircleOutlinedSvg
        }));
      };
      const QuestionCircleOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(QuestionCircleOutlined);
      var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      function toTooltipProps(tooltip) {
        if (!tooltip) {
          return null;
        }
        if (typeof tooltip === "object" && !/* @__PURE__ */ React__namespace.isValidElement(tooltip)) {
          return tooltip;
        }
        return {
          title: tooltip
        };
      }
      const FormItemLabel = (_ref) => {
        let {
          prefixCls,
          label,
          htmlFor,
          labelCol,
          labelAlign,
          colon,
          required: required2,
          requiredMark,
          tooltip
        } = _ref;
        var _a;
        const [formLocale] = useLocale$1("Form");
        const {
          vertical,
          labelAlign: contextLabelAlign,
          labelCol: contextLabelCol,
          labelWrap,
          colon: contextColon
        } = React__namespace.useContext(FormContext);
        if (!label) {
          return null;
        }
        const mergedLabelCol = labelCol || contextLabelCol || {};
        const mergedLabelAlign = labelAlign || contextLabelAlign;
        const labelClsBasic = `${prefixCls}-item-label`;
        const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
          [`${labelClsBasic}-wrap`]: !!labelWrap
        });
        let labelChildren = label;
        const computedColon = colon === true || contextColon !== false && colon !== false;
        const haveColon = computedColon && !vertical;
        if (haveColon && typeof label === "string" && label.trim() !== "") {
          labelChildren = label.replace(/[:|：]\s*$/, "");
        }
        const tooltipProps = toTooltipProps(tooltip);
        if (tooltipProps) {
          const {
            icon = /* @__PURE__ */ React__namespace.createElement(QuestionCircleOutlined$1, null)
          } = tooltipProps, restTooltipProps = __rest$3(tooltipProps, ["icon"]);
          const tooltipNode = /* @__PURE__ */ React__namespace.createElement(Tooltip$1, Object.assign({}, restTooltipProps), /* @__PURE__ */ React__namespace.cloneElement(icon, {
            className: `${prefixCls}-item-tooltip`,
            title: ""
          }));
          labelChildren = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, labelChildren, tooltipNode);
        }
        if (requiredMark === "optional" && !required2) {
          labelChildren = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, labelChildren, /* @__PURE__ */ React__namespace.createElement("span", {
            className: `${prefixCls}-item-optional`,
            title: ""
          }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)));
        }
        const labelClassName = classNames({
          [`${prefixCls}-item-required`]: required2,
          [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
          [`${prefixCls}-item-no-colon`]: !computedColon
        });
        return /* @__PURE__ */ React__namespace.createElement(Col$1, Object.assign({}, mergedLabelCol, {
          className: labelColClassName
        }), /* @__PURE__ */ React__namespace.createElement("label", {
          htmlFor,
          className: labelClassName,
          title: typeof label === "string" ? label : ""
        }, labelChildren));
      };
      const FormItemLabel$1 = FormItemLabel;
      var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const iconMap = {
        success: CheckCircleFilled$1,
        warning: ExclamationCircleFilled$1,
        error: CloseCircleFilled$1,
        validating: LoadingOutlined$1
      };
      function ItemHolder(props) {
        const {
          prefixCls,
          className,
          rootClassName,
          style: style2,
          help,
          errors,
          warnings,
          validateStatus,
          meta,
          hasFeedback,
          hidden,
          children,
          fieldId,
          required: required2,
          isRequired,
          onSubItemMetaChange
        } = props, restProps = __rest$2(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange"]);
        const itemPrefixCls = `${prefixCls}-item`;
        const {
          requiredMark
        } = React__namespace.useContext(FormContext);
        const itemRef = React__namespace.useRef(null);
        const debounceErrors = useDebounce(errors);
        const debounceWarnings = useDebounce(warnings);
        const hasHelp = help !== void 0 && help !== null;
        const hasError = !!(hasHelp || errors.length || warnings.length);
        const isOnScreen = !!itemRef.current && isVisible$1(itemRef.current);
        const [marginBottom, setMarginBottom] = React__namespace.useState(null);
        useLayoutEffect(() => {
          if (hasError && itemRef.current) {
            const itemStyle = getComputedStyle(itemRef.current);
            setMarginBottom(parseInt(itemStyle.marginBottom, 10));
          }
        }, [hasError, isOnScreen]);
        const onErrorVisibleChanged = (nextVisible) => {
          if (!nextVisible) {
            setMarginBottom(null);
          }
        };
        const getValidateState = function() {
          let isDebounce = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          let status = "";
          const _errors = isDebounce ? debounceErrors : meta.errors;
          const _warnings = isDebounce ? debounceWarnings : meta.warnings;
          if (validateStatus !== void 0) {
            status = validateStatus;
          } else if (meta.validating) {
            status = "validating";
          } else if (_errors.length) {
            status = "error";
          } else if (_warnings.length) {
            status = "warning";
          } else if (meta.touched || hasFeedback && meta.validated) {
            status = "success";
          }
          return status;
        };
        const mergedValidateStatus = getValidateState();
        const formItemStatusContext = React__namespace.useMemo(() => {
          let feedbackIcon;
          if (hasFeedback) {
            const IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
            feedbackIcon = IconNode ? /* @__PURE__ */ React__namespace.createElement("span", {
              className: classNames(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
            }, /* @__PURE__ */ React__namespace.createElement(IconNode, null)) : null;
          }
          return {
            status: mergedValidateStatus,
            errors,
            warnings,
            hasFeedback,
            feedbackIcon,
            isFormItemInput: true
          };
        }, [mergedValidateStatus, hasFeedback]);
        const itemClassName = classNames(itemPrefixCls, className, rootClassName, {
          [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
          // Status
          [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
          [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
          [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
          [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
          [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
          [`${itemPrefixCls}-hidden`]: hidden
        });
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: itemClassName,
          style: style2,
          ref: itemRef
        }, /* @__PURE__ */ React__namespace.createElement(Row$1, Object.assign({
          className: `${itemPrefixCls}-row`
        }, omit(restProps, ["_internalItemRender", "colon", "dependencies", "extra", "fieldKey", "getValueFromEvent", "getValueProps", "htmlFor", "id", "initialValue", "isListField", "label", "labelAlign", "labelCol", "labelWrap", "messageVariables", "name", "normalize", "noStyle", "preserve", "requiredMark", "rules", "shouldUpdate", "trigger", "tooltip", "validateFirst", "validateTrigger", "valuePropName", "wrapperCol"])), /* @__PURE__ */ React__namespace.createElement(FormItemLabel$1, Object.assign({
          htmlFor: fieldId
        }, props, {
          requiredMark,
          required: required2 !== null && required2 !== void 0 ? required2 : isRequired,
          prefixCls
        })), /* @__PURE__ */ React__namespace.createElement(FormItemInput$1, Object.assign({}, props, meta, {
          errors: debounceErrors,
          warnings: debounceWarnings,
          prefixCls,
          status: mergedValidateStatus,
          help,
          marginBottom,
          onErrorVisibleChanged
        }), /* @__PURE__ */ React__namespace.createElement(NoStyleItemContext.Provider, {
          value: onSubItemMetaChange
        }, /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
          value: formItemStatusContext
        }, children)))), !!marginBottom && /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${itemPrefixCls}-margin-offset`,
          style: {
            marginBottom: -marginBottom
          }
        }));
      }
      function useChildren(children) {
        if (typeof children === "function") {
          return children;
        }
        const childList = toArray$5(children);
        return childList.length <= 1 ? childList[0] : childList;
      }
      const NAME_SPLIT = "__SPLIT__";
      const MemoInput = /* @__PURE__ */ React__namespace.memo((_ref) => {
        let {
          children
        } = _ref;
        return children;
      }, (prev2, next2) => prev2.value === next2.value && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
      function hasValidName(name) {
        return !(name === void 0 || name === null);
      }
      function genEmptyMeta() {
        return {
          errors: [],
          warnings: [],
          touched: false,
          validating: false,
          name: [],
          validated: false
        };
      }
      function InternalFormItem(props) {
        const {
          name,
          noStyle,
          className,
          dependencies,
          prefixCls: customizePrefixCls,
          shouldUpdate,
          rules: rules2,
          children,
          required: required2,
          label,
          messageVariables,
          trigger = "onChange",
          validateTrigger,
          hidden,
          help
        } = props;
        const {
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const {
          name: formName
        } = React__namespace.useContext(FormContext);
        const mergedChildren = useChildren(children);
        const isRenderProps = typeof mergedChildren === "function";
        const notifyParentMetaChange = React__namespace.useContext(NoStyleItemContext);
        const {
          validateTrigger: contextValidateTrigger
        } = React__namespace.useContext(Context);
        const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
        const hasName = hasValidName(name);
        const prefixCls = getPrefixCls("form", customizePrefixCls);
        const [wrapSSR, hashId] = useStyle(prefixCls);
        const listContext = React__namespace.useContext(ListContext);
        const fieldKeyPathRef = React__namespace.useRef();
        const [subFieldErrors, setSubFieldErrors] = useFrameState({});
        const [meta, setMeta] = useSafeState(() => genEmptyMeta());
        const onMetaChange = (nextMeta) => {
          const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
          setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
          if (noStyle && help !== false && notifyParentMetaChange) {
            let namePath = nextMeta.name;
            if (!nextMeta.destroy) {
              if (keyInfo !== void 0) {
                const [fieldKey, restPath] = keyInfo;
                namePath = [fieldKey].concat(_toConsumableArray(restPath));
                fieldKeyPathRef.current = namePath;
              }
            } else {
              namePath = fieldKeyPathRef.current || namePath;
            }
            notifyParentMetaChange(nextMeta, namePath);
          }
        };
        const onSubItemMetaChange = (subMeta, uniqueKeys) => {
          setSubFieldErrors((prevSubFieldErrors) => {
            const clone = Object.assign({}, prevSubFieldErrors);
            const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
            const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
            if (subMeta.destroy) {
              delete clone[mergedNameKey];
            } else {
              clone[mergedNameKey] = subMeta;
            }
            return clone;
          });
        };
        const [mergedErrors, mergedWarnings] = React__namespace.useMemo(() => {
          const errorList = _toConsumableArray(meta.errors);
          const warningList = _toConsumableArray(meta.warnings);
          Object.values(subFieldErrors).forEach((subFieldError) => {
            errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
            warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
          });
          return [errorList, warningList];
        }, [subFieldErrors, meta.errors, meta.warnings]);
        const getItemRef = useItemRef();
        function renderLayout(baseChildren, fieldId, isRequired) {
          if (noStyle && !hidden) {
            return baseChildren;
          }
          return /* @__PURE__ */ React__namespace.createElement(ItemHolder, Object.assign({
            key: "row"
          }, props, {
            className: classNames(className, hashId),
            prefixCls,
            fieldId,
            isRequired,
            errors: mergedErrors,
            warnings: mergedWarnings,
            meta,
            onSubItemMetaChange
          }), baseChildren);
        }
        if (!hasName && !isRenderProps && !dependencies) {
          return wrapSSR(renderLayout(mergedChildren));
        }
        let variables = {};
        if (typeof label === "string") {
          variables.label = label;
        } else if (name) {
          variables.label = String(name);
        }
        if (messageVariables) {
          variables = Object.assign(Object.assign({}, variables), messageVariables);
        }
        return wrapSSR(/* @__PURE__ */ React__namespace.createElement(WrapperField, Object.assign({}, props, {
          messageVariables: variables,
          trigger,
          validateTrigger: mergedValidateTrigger,
          onMetaChange
        }), (control, renderMeta, context) => {
          const mergedName = toArray(name).length && renderMeta ? renderMeta.name : [];
          const fieldId = getFieldId(mergedName, formName);
          const isRequired = required2 !== void 0 ? required2 : !!(rules2 && rules2.some((rule) => {
            if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
              return true;
            }
            if (typeof rule === "function") {
              const ruleEntity = rule(context);
              return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
            }
            return false;
          }));
          const mergedControl = Object.assign({}, control);
          let childNode = null;
          if (Array.isArray(mergedChildren) && hasName) {
            childNode = mergedChildren;
          } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
            ;
          else if (dependencies && !isRenderProps && !hasName)
            ;
          else if (isValidElement(mergedChildren)) {
            const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
            if (!childProps.id) {
              childProps.id = fieldId;
            }
            if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
              const describedbyArr = [];
              if (help || mergedErrors.length > 0) {
                describedbyArr.push(`${fieldId}_help`);
              }
              if (props.extra) {
                describedbyArr.push(`${fieldId}_extra`);
              }
              childProps["aria-describedby"] = describedbyArr.join(" ");
            }
            if (mergedErrors.length > 0) {
              childProps["aria-invalid"] = "true";
            }
            if (isRequired) {
              childProps["aria-required"] = "true";
            }
            if (supportRef(mergedChildren)) {
              childProps.ref = getItemRef(mergedName, mergedChildren);
            }
            const triggers = new Set([].concat(_toConsumableArray(toArray(trigger)), _toConsumableArray(toArray(mergedValidateTrigger))));
            triggers.forEach((eventName) => {
              childProps[eventName] = function() {
                var _a2, _c2;
                var _a, _b, _c;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
                (_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
              };
            });
            const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
            childNode = /* @__PURE__ */ React__namespace.createElement(MemoInput, {
              value: mergedControl[props.valuePropName || "value"],
              update: mergedChildren,
              childProps: watchingChildProps
            }, cloneElement(mergedChildren, childProps));
          } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
            childNode = mergedChildren(context);
          } else {
            childNode = mergedChildren;
          }
          return renderLayout(childNode, fieldId, isRequired);
        }));
      }
      const FormItem = InternalFormItem;
      FormItem.useStatus = useFormItemStatus$1;
      const Item = FormItem;
      var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const FormList = (_a) => {
        var {
          prefixCls: customizePrefixCls,
          children
        } = _a, props = __rest$1(_a, ["prefixCls", "children"]);
        const {
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const prefixCls = getPrefixCls("form", customizePrefixCls);
        const contextValue = React__namespace.useMemo(() => ({
          prefixCls,
          status: "error"
        }), [prefixCls]);
        return /* @__PURE__ */ React__namespace.createElement(List$1, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ React__namespace.createElement(FormItemPrefixContext.Provider, {
          value: contextValue
        }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
          fieldKey: field.key
        })), operation, {
          errors: meta.errors,
          warnings: meta.warnings
        })));
      };
      const List = FormList;
      function useFormInstance() {
        const {
          form
        } = React.useContext(FormContext);
        return form;
      }
      const Form = InternalForm$1;
      Form.Item = Item;
      Form.List = List;
      Form.ErrorList = ErrorList;
      Form.useForm = useForm;
      Form.useFormInstance = useFormInstance;
      Form.useWatch = useWatch$1;
      Form.Provider = FormProvider;
      Form.create = () => {
      };
      const Form$1 = Form;
      var __rest = globalThis && globalThis.__rest || function(s, e2) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
              t2[p2[i2]] = s[p2[i2]];
          }
        return t2;
      };
      const PurePanel = (props) => {
        const {
          prefixCls: customizePrefixCls,
          className,
          closeIcon,
          closable,
          type: type2,
          title,
          children
        } = props, restProps = __rest(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children"]);
        const {
          getPrefixCls
        } = React__namespace.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        const prefixCls = customizePrefixCls || getPrefixCls("modal");
        const [, hashId] = useStyle$4(prefixCls);
        const confirmPrefixCls = `${prefixCls}-confirm`;
        let additionalProps = {};
        if (type2) {
          additionalProps = {
            closable: closable !== null && closable !== void 0 ? closable : false,
            title: "",
            footer: "",
            children: /* @__PURE__ */ React__namespace.createElement(ConfirmContent, Object.assign({}, props, {
              confirmPrefixCls,
              rootPrefixCls,
              content: children
            }))
          };
        } else {
          additionalProps = {
            closable: closable !== null && closable !== void 0 ? closable : true,
            title,
            footer: props.footer === void 0 ? /* @__PURE__ */ React__namespace.createElement(Footer, Object.assign({}, props)) : props.footer,
            children
          };
        }
        return /* @__PURE__ */ React__namespace.createElement(Panel, Object.assign({
          prefixCls,
          className: classNames(hashId, `${prefixCls}-pure-panel`, type2 && confirmPrefixCls, type2 && `${confirmPrefixCls}-${type2}`, className)
        }, restProps, {
          closeIcon: renderCloseIcon(prefixCls, closeIcon),
          closable
        }, additionalProps));
      };
      const PurePanel$1 = PurePanel;
      function modalWarn(props) {
        return confirm(withWarn(props));
      }
      const Modal = OriginModal;
      Modal.useModal = useModal;
      Modal.info = function infoFn(props) {
        return confirm(withInfo(props));
      };
      Modal.success = function successFn(props) {
        return confirm(withSuccess(props));
      };
      Modal.error = function errorFn(props) {
        return confirm(withError(props));
      };
      Modal.warning = modalWarn;
      Modal.warn = modalWarn;
      Modal.confirm = function confirmFn(props) {
        return confirm(withConfirm(props));
      };
      Modal.destroyAll = function destroyAllFn() {
        while (destroyFns$1.length) {
          const close = destroyFns$1.pop();
          if (close) {
            close();
          }
        }
      };
      Modal.config = modalGlobalConfig;
      Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
      const Modal$1 = Modal;
      function isElementType(element, tag, props) {
        if (element.namespaceURI && element.namespaceURI !== "http://www.w3.org/1999/xhtml") {
          return false;
        }
        tag = Array.isArray(tag) ? tag : [
          tag
        ];
        if (!tag.includes(element.tagName.toLowerCase())) {
          return false;
        }
        if (props) {
          return Object.entries(props).every(([k2, v2]) => element[k2] === v2);
        }
        return true;
      }
      var clickableInputTypes;
      (function(clickableInputTypes2) {
        clickableInputTypes2["button"] = "button";
        clickableInputTypes2["color"] = "color";
        clickableInputTypes2["file"] = "file";
        clickableInputTypes2["image"] = "image";
        clickableInputTypes2["reset"] = "reset";
        clickableInputTypes2["submit"] = "submit";
        clickableInputTypes2["checkbox"] = "checkbox";
        clickableInputTypes2["radio"] = "radio";
      })(clickableInputTypes || (clickableInputTypes = {}));
      function isClickableInput(element) {
        return isElementType(element, "button") || isElementType(element, "input") && element.type in clickableInputTypes;
      }
      var helpers = {};
      Object.defineProperty(helpers, "__esModule", {
        value: true
      });
      helpers.TEXT_NODE = void 0;
      helpers.checkContainerType = checkContainerType$1;
      helpers.getDocument = getDocument$2;
      var getWindowFromNode_1 = helpers.getWindowFromNode = getWindowFromNode$1;
      helpers.jestFakeTimersAreEnabled = jestFakeTimersAreEnabled$1;
      const TEXT_NODE$3 = 3;
      helpers.TEXT_NODE = TEXT_NODE$3;
      function jestFakeTimersAreEnabled$1() {
        if (typeof jest !== "undefined" && jest !== null) {
          return (
            // legacy timers
            setTimeout._isMockFunction === true || // modern timers
            // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
            Object.prototype.hasOwnProperty.call(setTimeout, "clock")
          );
        }
        return false;
      }
      function getDocument$2() {
        if (typeof window === "undefined") {
          throw new Error("Could not find default container");
        }
        return window.document;
      }
      function getWindowFromNode$1(node2) {
        if (node2.defaultView) {
          return node2.defaultView;
        } else if (node2.ownerDocument && node2.ownerDocument.defaultView) {
          return node2.ownerDocument.defaultView;
        } else if (node2.window) {
          return node2.window;
        } else if (node2.ownerDocument && node2.ownerDocument.defaultView === null) {
          throw new Error(`It looks like the window object is not available for the provided node.`);
        } else if (node2.then instanceof Function) {
          throw new Error(`It looks like you passed a Promise object instead of a DOM node. Did you do something like \`fireEvent.click(screen.findBy...\` when you meant to use a \`getBy\` query \`fireEvent.click(screen.getBy...\`, or await the findBy query \`fireEvent.click(await screen.findBy...\`?`);
        } else if (Array.isArray(node2)) {
          throw new Error(`It looks like you passed an Array instead of a DOM node. Did you do something like \`fireEvent.click(screen.getAllBy...\` when you meant to use a \`getBy\` query \`fireEvent.click(screen.getBy...\`?`);
        } else if (typeof node2.debug === "function" && typeof node2.logTestingPlaygroundURL === "function") {
          throw new Error(`It looks like you passed a \`screen\` object. Did you do something like \`fireEvent.click(screen, ...\` when you meant to use a query, e.g. \`fireEvent.click(screen.getBy..., \`?`);
        } else {
          throw new Error(`The given node is not an Element, the node type is: ${typeof node2}.`);
        }
      }
      function checkContainerType$1(container) {
        if (!container || !(typeof container.querySelector === "function") || !(typeof container.querySelectorAll === "function")) {
          throw new TypeError(`Expected container to be an Element, a Document or a DocumentFragment but got ${getTypeName(container)}.`);
        }
        function getTypeName(object2) {
          if (typeof object2 === "object") {
            return object2 === null ? "null" : object2.constructor.name;
          }
          return typeof object2;
        }
      }
      function getWindow(node2) {
        return getWindowFromNode_1(node2);
      }
      function readBlobText(blob, FileReader) {
        return new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onerror = rej;
          fr.onabort = rej;
          fr.onload = () => {
            res(String(fr.result));
          };
          fr.readAsText(blob);
        });
      }
      function createFileList(window2, files) {
        const list = {
          ...files,
          length: files.length,
          item: (index2) => list[index2],
          [Symbol.iterator]: function* nextFile() {
            for (let i2 = 0; i2 < list.length; i2++) {
              yield list[i2];
            }
          }
        };
        list.constructor = window2.FileList;
        if (window2.FileList) {
          Object.setPrototypeOf(list, window2.FileList.prototype);
        }
        Object.freeze(list);
        return list;
      }
      class DataTransferItemStub {
        getAsFile() {
          return this.file;
        }
        getAsString(callback) {
          if (typeof this.data === "string") {
            callback(this.data);
          }
        }
        /* istanbul ignore next */
        webkitGetAsEntry() {
          throw new Error("not implemented");
        }
        constructor(dataOrFile, type2) {
          this.file = null;
          this.data = void 0;
          if (typeof dataOrFile === "string") {
            this.kind = "string";
            this.type = String(type2);
            this.data = dataOrFile;
          } else {
            this.kind = "file";
            this.type = dataOrFile.type;
            this.file = dataOrFile;
          }
        }
      }
      class DataTransferItemListStub extends Array {
        add(...args) {
          const item = new DataTransferItemStub(args[0], args[1]);
          this.push(item);
          return item;
        }
        clear() {
          this.splice(0, this.length);
        }
        remove(index2) {
          this.splice(index2, 1);
        }
      }
      function getTypeMatcher(type2, exact) {
        const [group, sub] = type2.split("/");
        const isGroup = !sub || sub === "*";
        return (item) => {
          return exact ? item.type === (isGroup ? group : type2) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
        };
      }
      function createDataTransferStub(window2) {
        return new class DataTransferStub {
          getData(format2) {
            var ref;
            const match2 = (ref = this.items.find(getTypeMatcher(format2, true))) !== null && ref !== void 0 ? ref : this.items.find(getTypeMatcher(format2, false));
            let text = "";
            match2 === null || match2 === void 0 ? void 0 : match2.getAsString((t2) => {
              text = t2;
            });
            return text;
          }
          setData(format2, data) {
            const matchIndex = this.items.findIndex(getTypeMatcher(format2, true));
            const item = new DataTransferItemStub(data, format2);
            if (matchIndex >= 0) {
              this.items.splice(matchIndex, 1, item);
            } else {
              this.items.push(item);
            }
          }
          clearData(format2) {
            if (format2) {
              const matchIndex = this.items.findIndex(getTypeMatcher(format2, true));
              if (matchIndex >= 0) {
                this.items.remove(matchIndex);
              }
            } else {
              this.items.clear();
            }
          }
          get types() {
            const t2 = [];
            if (this.files.length) {
              t2.push("Files");
            }
            this.items.forEach((i2) => t2.push(i2.type));
            Object.freeze(t2);
            return t2;
          }
          /* istanbul ignore next */
          setDragImage() {
          }
          constructor() {
            this.dropEffect = "none";
            this.effectAllowed = "uninitialized";
            this.items = new DataTransferItemListStub();
            this.files = createFileList(window2, []);
          }
        }();
      }
      function createDataTransfer(window2, files = []) {
        const dt = typeof window2.DataTransfer === "undefined" ? createDataTransferStub(window2) : (
          /* istanbul ignore next */
          new window2.DataTransfer()
        );
        Object.defineProperty(dt, "files", {
          get: () => createFileList(window2, files)
        });
        return dt;
      }
      function getBlobFromDataTransferItem(window2, item) {
        if (item.kind === "file") {
          return item.getAsFile();
        }
        let data = "";
        item.getAsString((s) => {
          data = s;
        });
        return new window2.Blob([
          data
        ], {
          type: item.type
        });
      }
      function createClipboardItem(window2, ...blobs) {
        const dataMap = Object.fromEntries(blobs.map((b2) => [
          typeof b2 === "string" ? "text/plain" : b2.type,
          Promise.resolve(b2)
        ]));
        if (typeof window2.ClipboardItem !== "undefined") {
          return new window2.ClipboardItem(dataMap);
        }
        return new class ClipboardItem {
          get types() {
            return Array.from(Object.keys(this.data));
          }
          async getType(type2) {
            const value = await this.data[type2];
            if (!value) {
              throw new Error(`${type2} is not one of the available MIME types on this item.`);
            }
            return value instanceof window2.Blob ? value : new window2.Blob([
              value
            ], {
              type: type2
            });
          }
          constructor(d2) {
            this.data = d2;
          }
        }(dataMap);
      }
      const ClipboardStubControl = Symbol("Manage ClipboardSub");
      function createClipboardStub(window2, control) {
        return Object.assign(new class Clipboard extends window2.EventTarget {
          async read() {
            return Array.from(this.items);
          }
          async readText() {
            let text = "";
            for (const item of this.items) {
              const type2 = item.types.includes("text/plain") ? "text/plain" : item.types.find((t2) => t2.startsWith("text/"));
              if (type2) {
                text += await item.getType(type2).then((b2) => readBlobText(b2, window2.FileReader));
              }
            }
            return text;
          }
          async write(data) {
            this.items = data;
          }
          async writeText(text) {
            this.items = [
              createClipboardItem(window2, text)
            ];
          }
          constructor(...args) {
            super(...args);
            this.items = [];
          }
        }(), {
          [ClipboardStubControl]: control
        });
      }
      function isClipboardStub(clipboard) {
        var ref;
        return !!((ref = clipboard) === null || ref === void 0 ? void 0 : ref[ClipboardStubControl]);
      }
      function attachClipboardStubToView(window2) {
        if (isClipboardStub(window2.navigator.clipboard)) {
          return window2.navigator.clipboard[ClipboardStubControl];
        }
        const realClipboard = Object.getOwnPropertyDescriptor(window2.navigator, "clipboard");
        let stub;
        const control = {
          resetClipboardStub: () => {
            stub = createClipboardStub(window2, control);
          },
          detachClipboardStub: () => {
            if (realClipboard) {
              Object.defineProperty(window2.navigator, "clipboard", realClipboard);
            } else {
              Object.defineProperty(window2.navigator, "clipboard", {
                value: void 0,
                configurable: true
              });
            }
          }
        };
        stub = createClipboardStub(window2, control);
        Object.defineProperty(window2.navigator, "clipboard", {
          get: () => stub,
          configurable: true
        });
        return stub[ClipboardStubControl];
      }
      function resetClipboardStubOnView(window2) {
        if (isClipboardStub(window2.navigator.clipboard)) {
          window2.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
        }
      }
      function detachClipboardStubFromView(window2) {
        if (isClipboardStub(window2.navigator.clipboard)) {
          window2.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
        }
      }
      async function readDataTransferFromClipboard(document2) {
        const window2 = document2.defaultView;
        const clipboard = window2 === null || window2 === void 0 ? void 0 : window2.navigator.clipboard;
        const items = clipboard && await clipboard.read();
        if (!items) {
          throw new Error("The Clipboard API is unavailable.");
        }
        const dt = createDataTransfer(window2);
        for (const item of items) {
          for (const type2 of item.types) {
            dt.setData(type2, await item.getType(type2).then((b2) => readBlobText(b2, window2.FileReader)));
          }
        }
        return dt;
      }
      async function writeDataTransferToClipboard(document2, clipboardData) {
        const window2 = getWindow(document2);
        const clipboard = window2.navigator.clipboard;
        const items = [];
        for (let i2 = 0; i2 < clipboardData.items.length; i2++) {
          const dtItem = clipboardData.items[i2];
          const blob = getBlobFromDataTransferItem(window2, dtItem);
          items.push(createClipboardItem(window2, blob));
        }
        const written = clipboard && await clipboard.write(items).then(
          () => true,
          // Can happen with other implementations that e.g. require permissions
          /* istanbul ignore next */
          () => false
        );
        if (!written) {
          throw new Error("The Clipboard API is unavailable.");
        }
      }
      if (typeof globalThis.afterEach === "function") {
        globalThis.afterEach(() => resetClipboardStubOnView(globalThis.window));
      }
      if (typeof globalThis.afterAll === "function") {
        globalThis.afterAll(() => detachClipboardStubFromView(globalThis.window));
      }
      function isContentEditable(element) {
        return element.hasAttribute("contenteditable") && (element.getAttribute("contenteditable") == "true" || element.getAttribute("contenteditable") == "");
      }
      function getContentEditable(node2) {
        const element = getElement$1(node2);
        return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
      }
      function getElement$1(node2) {
        return node2.nodeType === 1 ? node2 : node2.parentElement;
      }
      function isEditable(element) {
        return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
      }
      var editableInputTypes;
      (function(editableInputTypes2) {
        editableInputTypes2["text"] = "text";
        editableInputTypes2["date"] = "date";
        editableInputTypes2["datetime-local"] = "datetime-local";
        editableInputTypes2["email"] = "email";
        editableInputTypes2["month"] = "month";
        editableInputTypes2["number"] = "number";
        editableInputTypes2["password"] = "password";
        editableInputTypes2["search"] = "search";
        editableInputTypes2["tel"] = "tel";
        editableInputTypes2["time"] = "time";
        editableInputTypes2["url"] = "url";
        editableInputTypes2["week"] = "week";
      })(editableInputTypes || (editableInputTypes = {}));
      function isEditableInputOrTextArea(element) {
        return isElementType(element, "textarea") || isElementType(element, "input") && element.type in editableInputTypes;
      }
      var maxLengthSupportedTypes;
      (function(maxLengthSupportedTypes2) {
        maxLengthSupportedTypes2["email"] = "email";
        maxLengthSupportedTypes2["password"] = "password";
        maxLengthSupportedTypes2["search"] = "search";
        maxLengthSupportedTypes2["telephone"] = "telephone";
        maxLengthSupportedTypes2["text"] = "text";
        maxLengthSupportedTypes2["url"] = "url";
      })(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));
      function getMaxLength(element) {
        var ref;
        const attr = (ref = element.getAttribute("maxlength")) !== null && ref !== void 0 ? ref : "";
        return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : void 0;
      }
      function supportsMaxLength(element) {
        return isElementType(element, "textarea") || isElementType(element, "input") && element.type in maxLengthSupportedTypes;
      }
      const FOCUSABLE_SELECTOR = [
        "input:not([type=hidden]):not([disabled])",
        "button:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        '[contenteditable=""]',
        '[contenteditable="true"]',
        "a[href]",
        "[tabindex]:not([disabled])"
      ].join(", ");
      function isFocusable(element) {
        return element.matches(FOCUSABLE_SELECTOR);
      }
      var bracketDict;
      (function(bracketDict2) {
        bracketDict2["{"] = "}";
        bracketDict2["["] = "]";
      })(bracketDict || (bracketDict = {}));
      function readNextDescriptor(text, context) {
        let pos = 0;
        const startBracket = text[pos] in bracketDict ? text[pos] : "";
        pos += startBracket.length;
        const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
        const type2 = isEscapedChar ? "" : startBracket;
        return {
          type: type2,
          ...type2 === "" ? readPrintableChar(text, pos, context) : readTag(text, pos, type2, context)
        };
      }
      function readPrintableChar(text, pos, context) {
        const descriptor = text[pos];
        assertDescriptor(descriptor, text, pos, context);
        pos += descriptor.length;
        return {
          consumedLength: pos,
          descriptor,
          releasePrevious: false,
          releaseSelf: true,
          repeat: 1
        };
      }
      function readTag(text, pos, startBracket, context) {
        var ref, ref1;
        const releasePreviousModifier = text[pos] === "/" ? "/" : "";
        pos += releasePreviousModifier.length;
        const escapedDescriptor = startBracket === "{" && text[pos] === "\\";
        pos += Number(escapedDescriptor);
        const descriptor = escapedDescriptor ? text[pos] : (ref = text.slice(pos).match(startBracket === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || ref === void 0 ? void 0 : ref[0];
        assertDescriptor(descriptor, text, pos, context);
        pos += descriptor.length;
        var ref2;
        const repeatModifier = (ref2 = (ref1 = text.slice(pos).match(/^>\d+/)) === null || ref1 === void 0 ? void 0 : ref1[0]) !== null && ref2 !== void 0 ? ref2 : "";
        pos += repeatModifier.length;
        const releaseSelfModifier = text[pos] === "/" || !repeatModifier && text[pos] === ">" ? text[pos] : "";
        pos += releaseSelfModifier.length;
        const expectedEndBracket = bracketDict[startBracket];
        const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : "";
        if (!endBracket) {
          throw new Error(getErrorMessage([
            !repeatModifier && "repeat modifier",
            !releaseSelfModifier && "release modifier",
            `"${expectedEndBracket}"`
          ].filter(Boolean).join(" or "), text[pos], text, context));
        }
        pos += endBracket.length;
        return {
          consumedLength: pos,
          descriptor,
          releasePrevious: !!releasePreviousModifier,
          repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
          releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
        };
      }
      function assertDescriptor(descriptor, text, pos, context) {
        if (!descriptor) {
          throw new Error(getErrorMessage("key descriptor", text[pos], text, context));
        }
      }
      function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
        if (releaseSelfModifier) {
          return releaseSelfModifier === "/";
        }
        if (repeatModifier) {
          return false;
        }
      }
      function getErrorMessage(expected, found, text, context) {
        return `Expected ${expected} but found "${found !== null && found !== void 0 ? found : ""}" in "${text}"
    See ${context === "pointer" ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
      }
      function cloneEvent(event) {
        return new event.constructor(event.type, event);
      }
      var ApiLevel;
      (function(ApiLevel2) {
        ApiLevel2[ApiLevel2["Trigger"] = 2] = "Trigger";
        ApiLevel2[ApiLevel2["Call"] = 1] = "Call";
      })(ApiLevel || (ApiLevel = {}));
      function setLevelRef(instance, level) {
        instance.levelRefs[level] = {};
      }
      function getLevelRef(instance, level) {
        return instance.levelRefs[level];
      }
      var PointerEventsCheckLevel;
      (function(PointerEventsCheckLevel2) {
        PointerEventsCheckLevel2[PointerEventsCheckLevel2[
          /**
          * Check pointer events on every user interaction that triggers a bunch of events.
          * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
          */
          "EachTrigger"
        ] = 4] = "EachTrigger";
        PointerEventsCheckLevel2[PointerEventsCheckLevel2[
          /** Check each target once per call to pointer (related) API */
          "EachApiCall"
        ] = 2] = "EachApiCall";
        PointerEventsCheckLevel2[PointerEventsCheckLevel2[
          /** Check each event target once */
          "EachTarget"
        ] = 1] = "EachTarget";
        PointerEventsCheckLevel2[PointerEventsCheckLevel2[
          /** No pointer events check */
          "Never"
        ] = 0] = "Never";
      })(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));
      function isDisabled(element) {
        for (let el = element; el; el = el.parentElement) {
          if (isElementType(el, [
            "button",
            "input",
            "select",
            "textarea",
            "optgroup",
            "option"
          ])) {
            if (el.hasAttribute("disabled")) {
              return true;
            }
          } else if (isElementType(el, "fieldset")) {
            var ref;
            if (el.hasAttribute("disabled") && !((ref = el.querySelector(":scope > legend")) === null || ref === void 0 ? void 0 : ref.contains(element))) {
              return true;
            }
          } else if (el.tagName.includes("-")) {
            if (el.constructor.formAssociated && el.hasAttribute("disabled")) {
              return true;
            }
          }
        }
        return false;
      }
      function getActiveElement(document2) {
        const activeElement = document2.activeElement;
        if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) {
          return getActiveElement(activeElement.shadowRoot);
        } else {
          if (isDisabled(activeElement)) {
            return document2.ownerDocument ? (
              /* istanbul ignore next */
              document2.ownerDocument.body
            ) : document2.body;
          }
          return activeElement;
        }
      }
      function getActiveElementOrBody(document2) {
        var ref;
        return (ref = getActiveElement(document2)) !== null && ref !== void 0 ? ref : (
          /* istanbul ignore next */
          document2.body
        );
      }
      function findClosest(element, callback) {
        let el = element;
        do {
          if (callback(el)) {
            return el;
          }
          el = el.parentElement;
        } while (el && el !== element.ownerDocument.body);
        return void 0;
      }
      function hasOwnSelection(node2) {
        return isElement$3(node2) && isEditableInputOrTextArea(node2);
      }
      function hasNoSelection(node2) {
        return isElement$3(node2) && isClickableInput(node2);
      }
      function isElement$3(node2) {
        return node2.nodeType === 1;
      }
      function updateSelectionOnFocus(element) {
        const selection = element.ownerDocument.getSelection();
        if (!(selection === null || selection === void 0 ? void 0 : selection.focusNode)) {
          return;
        }
        if (hasOwnSelection(element)) {
          const contenteditable = getContentEditable(selection.focusNode);
          if (contenteditable) {
            if (!selection.isCollapsed) {
              var ref;
              const focusNode = ((ref = contenteditable.firstChild) === null || ref === void 0 ? void 0 : ref.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
              selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
            }
          } else {
            selection.setBaseAndExtent(element, 0, element, 0);
          }
        }
      }
      var build$1 = {};
      var ansiStyles = { exports: {} };
      ansiStyles.exports;
      (function(module2) {
        const ANSI_BACKGROUND_OFFSET = 10;
        const wrapAnsi256 = (offset2 = 0) => (code) => `\x1B[${38 + offset2};5;${code}m`;
        const wrapAnsi16m = (offset2 = 0) => (red, green, blue2) => `\x1B[${38 + offset2};2;${red};${green};${blue2}m`;
        function assembleStyles() {
          const codes = /* @__PURE__ */ new Map();
          const styles = {
            modifier: {
              reset: [0, 0],
              // 21 isn't widely supported and 22 does the same thing
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              overline: [53, 55],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29]
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              // Bright color
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39]
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              // Bright color
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49]
            }
          };
          styles.color.gray = styles.color.blackBright;
          styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
          styles.color.grey = styles.color.blackBright;
          styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
          for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style2] of Object.entries(group)) {
              styles[styleName] = {
                open: `\x1B[${style2[0]}m`,
                close: `\x1B[${style2[1]}m`
              };
              group[styleName] = styles[styleName];
              codes.set(style2[0], style2[1]);
            }
            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: false
            });
          }
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
          styles.color.close = "\x1B[39m";
          styles.bgColor.close = "\x1B[49m";
          styles.color.ansi256 = wrapAnsi256();
          styles.color.ansi16m = wrapAnsi16m();
          styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
          styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
          Object.defineProperties(styles, {
            rgbToAnsi256: {
              value: (red, green, blue2) => {
                if (red === green && green === blue2) {
                  if (red < 8) {
                    return 16;
                  }
                  if (red > 248) {
                    return 231;
                  }
                  return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
              },
              enumerable: false
            },
            hexToRgb: {
              value: (hex) => {
                const matches2 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
                if (!matches2) {
                  return [0, 0, 0];
                }
                let { colorString } = matches2.groups;
                if (colorString.length === 3) {
                  colorString = colorString.split("").map((character2) => character2 + character2).join("");
                }
                const integer2 = Number.parseInt(colorString, 16);
                return [
                  integer2 >> 16 & 255,
                  integer2 >> 8 & 255,
                  integer2 & 255
                ];
              },
              enumerable: false
            },
            hexToAnsi256: {
              value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
              enumerable: false
            }
          });
          return styles;
        }
        Object.defineProperty(module2, "exports", {
          enumerable: true,
          get: assembleStyles
        });
      })(ansiStyles);
      var ansiStylesExports = ansiStyles.exports;
      var collections = {};
      Object.defineProperty(collections, "__esModule", {
        value: true
      });
      collections.printIteratorEntries = printIteratorEntries;
      collections.printIteratorValues = printIteratorValues;
      collections.printListItems = printListItems;
      collections.printObjectProperties = printObjectProperties;
      const getKeysOfEnumerableProperties = (object2, compareKeys) => {
        const keys2 = Object.keys(object2).sort(compareKeys);
        if (Object.getOwnPropertySymbols) {
          Object.getOwnPropertySymbols(object2).forEach((symbol) => {
            if (Object.getOwnPropertyDescriptor(object2, symbol).enumerable) {
              keys2.push(symbol);
            }
          });
        }
        return keys2;
      };
      function printIteratorEntries(iterator, config2, indentation, depth, refs, printer2, separator = ": ") {
        let result = "";
        let current = iterator.next();
        if (!current.done) {
          result += config2.spacingOuter;
          const indentationNext = indentation + config2.indent;
          while (!current.done) {
            const name = printer2(
              current.value[0],
              config2,
              indentationNext,
              depth,
              refs
            );
            const value = printer2(
              current.value[1],
              config2,
              indentationNext,
              depth,
              refs
            );
            result += indentationNext + name + separator + value;
            current = iterator.next();
            if (!current.done) {
              result += "," + config2.spacingInner;
            } else if (!config2.min) {
              result += ",";
            }
          }
          result += config2.spacingOuter + indentation;
        }
        return result;
      }
      function printIteratorValues(iterator, config2, indentation, depth, refs, printer2) {
        let result = "";
        let current = iterator.next();
        if (!current.done) {
          result += config2.spacingOuter;
          const indentationNext = indentation + config2.indent;
          while (!current.done) {
            result += indentationNext + printer2(current.value, config2, indentationNext, depth, refs);
            current = iterator.next();
            if (!current.done) {
              result += "," + config2.spacingInner;
            } else if (!config2.min) {
              result += ",";
            }
          }
          result += config2.spacingOuter + indentation;
        }
        return result;
      }
      function printListItems(list, config2, indentation, depth, refs, printer2) {
        let result = "";
        if (list.length) {
          result += config2.spacingOuter;
          const indentationNext = indentation + config2.indent;
          for (let i2 = 0; i2 < list.length; i2++) {
            result += indentationNext;
            if (i2 in list) {
              result += printer2(list[i2], config2, indentationNext, depth, refs);
            }
            if (i2 < list.length - 1) {
              result += "," + config2.spacingInner;
            } else if (!config2.min) {
              result += ",";
            }
          }
          result += config2.spacingOuter + indentation;
        }
        return result;
      }
      function printObjectProperties(val, config2, indentation, depth, refs, printer2) {
        let result = "";
        const keys2 = getKeysOfEnumerableProperties(val, config2.compareKeys);
        if (keys2.length) {
          result += config2.spacingOuter;
          const indentationNext = indentation + config2.indent;
          for (let i2 = 0; i2 < keys2.length; i2++) {
            const key2 = keys2[i2];
            const name = printer2(key2, config2, indentationNext, depth, refs);
            const value = printer2(val[key2], config2, indentationNext, depth, refs);
            result += indentationNext + name + ": " + value;
            if (i2 < keys2.length - 1) {
              result += "," + config2.spacingInner;
            } else if (!config2.min) {
              result += ",";
            }
          }
          result += config2.spacingOuter + indentation;
        }
        return result;
      }
      var AsymmetricMatcher = {};
      Object.defineProperty(AsymmetricMatcher, "__esModule", {
        value: true
      });
      AsymmetricMatcher.test = AsymmetricMatcher.serialize = AsymmetricMatcher.default = void 0;
      var _collections$3 = collections;
      var global$2 = function() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof global$2 !== "undefined") {
          return global$2;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      }();
      var Symbol$2 = global$2["jest-symbol-do-not-touch"] || global$2.Symbol;
      const asymmetricMatcher = typeof Symbol$2 === "function" && Symbol$2.for ? Symbol$2.for("jest.asymmetricMatcher") : 1267621;
      const SPACE$2 = " ";
      const serialize$6 = (val, config2, indentation, depth, refs, printer2) => {
        const stringedValue = val.toString();
        if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
          if (++depth > config2.maxDepth) {
            return "[" + stringedValue + "]";
          }
          return stringedValue + SPACE$2 + "[" + (0, _collections$3.printListItems)(
            val.sample,
            config2,
            indentation,
            depth,
            refs,
            printer2
          ) + "]";
        }
        if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
          if (++depth > config2.maxDepth) {
            return "[" + stringedValue + "]";
          }
          return stringedValue + SPACE$2 + "{" + (0, _collections$3.printObjectProperties)(
            val.sample,
            config2,
            indentation,
            depth,
            refs,
            printer2
          ) + "}";
        }
        if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
          return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
        }
        if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
          return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
        }
        return val.toAsymmetricMatcher();
      };
      AsymmetricMatcher.serialize = serialize$6;
      const test$7 = (val) => val && val.$$typeof === asymmetricMatcher;
      AsymmetricMatcher.test = test$7;
      const plugin$6 = {
        serialize: serialize$6,
        test: test$7
      };
      var _default$2p = plugin$6;
      AsymmetricMatcher.default = _default$2p;
      var ConvertAnsi = {};
      var ansiRegex = ({ onlyFirst = false } = {}) => {
        const pattern2 = [
          "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
          "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(pattern2, onlyFirst ? void 0 : "g");
      };
      Object.defineProperty(ConvertAnsi, "__esModule", {
        value: true
      });
      ConvertAnsi.test = ConvertAnsi.serialize = ConvertAnsi.default = void 0;
      var _ansiRegex = _interopRequireDefault$d(ansiRegex);
      var _ansiStyles$1 = _interopRequireDefault$d(ansiStylesExports);
      function _interopRequireDefault$d(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      const toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match2) => {
        switch (match2) {
          case _ansiStyles$1.default.red.close:
          case _ansiStyles$1.default.green.close:
          case _ansiStyles$1.default.cyan.close:
          case _ansiStyles$1.default.gray.close:
          case _ansiStyles$1.default.white.close:
          case _ansiStyles$1.default.yellow.close:
          case _ansiStyles$1.default.bgRed.close:
          case _ansiStyles$1.default.bgGreen.close:
          case _ansiStyles$1.default.bgYellow.close:
          case _ansiStyles$1.default.inverse.close:
          case _ansiStyles$1.default.dim.close:
          case _ansiStyles$1.default.bold.close:
          case _ansiStyles$1.default.reset.open:
          case _ansiStyles$1.default.reset.close:
            return "</>";
          case _ansiStyles$1.default.red.open:
            return "<red>";
          case _ansiStyles$1.default.green.open:
            return "<green>";
          case _ansiStyles$1.default.cyan.open:
            return "<cyan>";
          case _ansiStyles$1.default.gray.open:
            return "<gray>";
          case _ansiStyles$1.default.white.open:
            return "<white>";
          case _ansiStyles$1.default.yellow.open:
            return "<yellow>";
          case _ansiStyles$1.default.bgRed.open:
            return "<bgRed>";
          case _ansiStyles$1.default.bgGreen.open:
            return "<bgGreen>";
          case _ansiStyles$1.default.bgYellow.open:
            return "<bgYellow>";
          case _ansiStyles$1.default.inverse.open:
            return "<inverse>";
          case _ansiStyles$1.default.dim.open:
            return "<dim>";
          case _ansiStyles$1.default.bold.open:
            return "<bold>";
          default:
            return "";
        }
      });
      const test$6 = (val) => typeof val === "string" && !!val.match((0, _ansiRegex.default)());
      ConvertAnsi.test = test$6;
      const serialize$5 = (val, config2, indentation, depth, refs, printer2) => printer2(toHumanReadableAnsi(val), config2, indentation, depth, refs);
      ConvertAnsi.serialize = serialize$5;
      const plugin$5 = {
        serialize: serialize$5,
        test: test$6
      };
      var _default$2o = plugin$5;
      ConvertAnsi.default = _default$2o;
      var DOMCollection$1 = {};
      Object.defineProperty(DOMCollection$1, "__esModule", {
        value: true
      });
      DOMCollection$1.test = DOMCollection$1.serialize = DOMCollection$1.default = void 0;
      var _collections$2 = collections;
      const SPACE$1 = " ";
      const OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
      const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
      const testName = (name) => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
      const test$5 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
      DOMCollection$1.test = test$5;
      const isNamedNodeMap = (collection) => collection.constructor.name === "NamedNodeMap";
      const serialize$4 = (collection, config2, indentation, depth, refs, printer2) => {
        const name = collection.constructor.name;
        if (++depth > config2.maxDepth) {
          return "[" + name + "]";
        }
        return (config2.min ? "" : name + SPACE$1) + (OBJECT_NAMES.indexOf(name) !== -1 ? "{" + (0, _collections$2.printObjectProperties)(
          isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}) : { ...collection },
          config2,
          indentation,
          depth,
          refs,
          printer2
        ) + "}" : "[" + (0, _collections$2.printListItems)(
          Array.from(collection),
          config2,
          indentation,
          depth,
          refs,
          printer2
        ) + "]");
      };
      DOMCollection$1.serialize = serialize$4;
      const plugin$4 = {
        serialize: serialize$4,
        test: test$5
      };
      var _default$2n = plugin$4;
      DOMCollection$1.default = _default$2n;
      var DOMElement = {};
      var markup = {};
      var escapeHTML$2 = {};
      Object.defineProperty(escapeHTML$2, "__esModule", {
        value: true
      });
      escapeHTML$2.default = escapeHTML$1;
      function escapeHTML$1(str) {
        return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      Object.defineProperty(markup, "__esModule", {
        value: true
      });
      markup.printText = markup.printProps = markup.printElementAsLeaf = markup.printElement = markup.printComment = markup.printChildren = void 0;
      var _escapeHTML = _interopRequireDefault$c(escapeHTML$2);
      function _interopRequireDefault$c(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      const printProps$1 = (keys2, props, config2, indentation, depth, refs, printer2) => {
        const indentationNext = indentation + config2.indent;
        const colors = config2.colors;
        return keys2.map((key2) => {
          const value = props[key2];
          let printed = printer2(value, config2, indentationNext, depth, refs);
          if (typeof value !== "string") {
            if (printed.indexOf("\n") !== -1) {
              printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation;
            }
            printed = "{" + printed + "}";
          }
          return config2.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
        }).join("");
      };
      markup.printProps = printProps$1;
      const printChildren$1 = (children, config2, indentation, depth, refs, printer2) => children.map(
        (child) => config2.spacingOuter + indentation + (typeof child === "string" ? printText$1(child, config2) : printer2(child, config2, indentation, depth, refs))
      ).join("");
      markup.printChildren = printChildren$1;
      const printText$1 = (text, config2) => {
        const contentColor = config2.colors.content;
        return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
      };
      markup.printText = printText$1;
      const printComment$1 = (comment2, config2) => {
        const commentColor = config2.colors.comment;
        return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment2) + "-->" + commentColor.close;
      };
      markup.printComment = printComment$1;
      const printElement$1 = (type2, printedProps, printedChildren, config2, indentation) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type2 + (printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config2.spacingOuter + indentation + tagColor.open + "</" + type2 : (printedProps && !config2.min ? "" : " ") + "/") + ">" + tagColor.close;
      };
      markup.printElement = printElement$1;
      const printElementAsLeaf$1 = (type2, config2) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type2 + tagColor.close + " …" + tagColor.open + " />" + tagColor.close;
      };
      markup.printElementAsLeaf = printElementAsLeaf$1;
      Object.defineProperty(DOMElement, "__esModule", {
        value: true
      });
      DOMElement.test = DOMElement.serialize = DOMElement.default = void 0;
      var _markup$2 = markup;
      const ELEMENT_NODE$2 = 1;
      const TEXT_NODE$2 = 3;
      const COMMENT_NODE$2 = 8;
      const FRAGMENT_NODE$1 = 11;
      const ELEMENT_REGEXP$1 = /^((HTML|SVG)\w*)?Element$/;
      const testHasAttribute = (val) => {
        try {
          return typeof val.hasAttribute === "function" && val.hasAttribute("is");
        } catch {
          return false;
        }
      };
      const testNode$1 = (val) => {
        const constructorName = val.constructor.name;
        const { nodeType, tagName } = val;
        const isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
        return nodeType === ELEMENT_NODE$2 && (ELEMENT_REGEXP$1.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE$2 && constructorName === "Text" || nodeType === COMMENT_NODE$2 && constructorName === "Comment" || nodeType === FRAGMENT_NODE$1 && constructorName === "DocumentFragment";
      };
      const test$4 = (val) => {
        var _val$constructor;
        return (val === null || val === void 0 ? void 0 : (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode$1(val);
      };
      DOMElement.test = test$4;
      function nodeIsText$1(node2) {
        return node2.nodeType === TEXT_NODE$2;
      }
      function nodeIsComment$1(node2) {
        return node2.nodeType === COMMENT_NODE$2;
      }
      function nodeIsFragment$1(node2) {
        return node2.nodeType === FRAGMENT_NODE$1;
      }
      const serialize$3 = (node2, config2, indentation, depth, refs, printer2) => {
        if (nodeIsText$1(node2)) {
          return (0, _markup$2.printText)(node2.data, config2);
        }
        if (nodeIsComment$1(node2)) {
          return (0, _markup$2.printComment)(node2.data, config2);
        }
        const type2 = nodeIsFragment$1(node2) ? "DocumentFragment" : node2.tagName.toLowerCase();
        if (++depth > config2.maxDepth) {
          return (0, _markup$2.printElementAsLeaf)(type2, config2);
        }
        return (0, _markup$2.printElement)(
          type2,
          (0, _markup$2.printProps)(
            nodeIsFragment$1(node2) ? [] : Array.from(node2.attributes).map((attr) => attr.name).sort(),
            nodeIsFragment$1(node2) ? {} : Array.from(node2.attributes).reduce((props, attribute) => {
              props[attribute.name] = attribute.value;
              return props;
            }, {}),
            config2,
            indentation + config2.indent,
            depth,
            refs,
            printer2
          ),
          (0, _markup$2.printChildren)(
            Array.prototype.slice.call(node2.childNodes || node2.children),
            config2,
            indentation + config2.indent,
            depth,
            refs,
            printer2
          ),
          config2,
          indentation
        );
      };
      DOMElement.serialize = serialize$3;
      const plugin$3 = {
        serialize: serialize$3,
        test: test$4
      };
      var _default$2m = plugin$3;
      DOMElement.default = _default$2m;
      var Immutable = {};
      Object.defineProperty(Immutable, "__esModule", {
        value: true
      });
      Immutable.test = Immutable.serialize = Immutable.default = void 0;
      var _collections$1 = collections;
      const IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
      const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
      const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
      const IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
      const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
      const IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
      const IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
      const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
      const IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
      const getImmutableName = (name) => "Immutable." + name;
      const printAsLeaf = (name) => "[" + name + "]";
      const SPACE = " ";
      const LAZY = "…";
      const printImmutableEntries = (val, config2, indentation, depth, refs, printer2, type2) => ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type2)) : getImmutableName(type2) + SPACE + "{" + (0, _collections$1.printIteratorEntries)(
        val.entries(),
        config2,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
      function getRecordEntries(val) {
        let i2 = 0;
        return {
          next() {
            if (i2 < val._keys.length) {
              const key2 = val._keys[i2++];
              return {
                done: false,
                value: [key2, val.get(key2)]
              };
            }
            return {
              done: true,
              value: void 0
            };
          }
        };
      }
      const printImmutableRecord = (val, config2, indentation, depth, refs, printer2) => {
        const name = getImmutableName(val._name || "Record");
        return ++depth > config2.maxDepth ? printAsLeaf(name) : name + SPACE + "{" + (0, _collections$1.printIteratorEntries)(
          getRecordEntries(val),
          config2,
          indentation,
          depth,
          refs,
          printer2
        ) + "}";
      };
      const printImmutableSeq = (val, config2, indentation, depth, refs, printer2) => {
        const name = getImmutableName("Seq");
        if (++depth > config2.maxDepth) {
          return printAsLeaf(name);
        }
        if (val[IS_KEYED_SENTINEL]) {
          return name + SPACE + "{" + // from Immutable collection of entries or from ECMAScript object
          (val._iter || val._object ? (0, _collections$1.printIteratorEntries)(
            val.entries(),
            config2,
            indentation,
            depth,
            refs,
            printer2
          ) : LAZY) + "}";
        }
        return name + SPACE + "[" + (val._iter || // from Immutable collection of values
        val._array || // from ECMAScript array
        val._collection || // from ECMAScript collection in immutable v4
        val._iterable ? (0, _collections$1.printIteratorValues)(
          val.values(),
          config2,
          indentation,
          depth,
          refs,
          printer2
        ) : LAZY) + "]";
      };
      const printImmutableValues = (val, config2, indentation, depth, refs, printer2, type2) => ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type2)) : getImmutableName(type2) + SPACE + "[" + (0, _collections$1.printIteratorValues)(
        val.values(),
        config2,
        indentation,
        depth,
        refs,
        printer2
      ) + "]";
      const serialize$2 = (val, config2, indentation, depth, refs, printer2) => {
        if (val[IS_MAP_SENTINEL]) {
          return printImmutableEntries(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer2,
            val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
          );
        }
        if (val[IS_LIST_SENTINEL]) {
          return printImmutableValues(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer2,
            "List"
          );
        }
        if (val[IS_SET_SENTINEL]) {
          return printImmutableValues(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer2,
            val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
          );
        }
        if (val[IS_STACK_SENTINEL]) {
          return printImmutableValues(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer2,
            "Stack"
          );
        }
        if (val[IS_SEQ_SENTINEL]) {
          return printImmutableSeq(val, config2, indentation, depth, refs, printer2);
        }
        return printImmutableRecord(val, config2, indentation, depth, refs, printer2);
      };
      Immutable.serialize = serialize$2;
      const test$3 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
      Immutable.test = test$3;
      const plugin$2 = {
        serialize: serialize$2,
        test: test$3
      };
      var _default$2l = plugin$2;
      Immutable.default = _default$2l;
      var ReactElement = {};
      var reactIs = { exports: {} };
      var reactIs_production_min = {};
      /** @license React v17.0.2
       * react-is.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var b = 60103, c = 60106, d = 60107, e = 60108, f = 60114, g$3 = 60109, h = 60110, k$1 = 60112, l = 60113, m = 60120, n = 60115, p = 60116, q = 60121, r = 60122, u = 60117, v = 60129, w = 60131;
      if ("function" === typeof Symbol && Symbol.for) {
        var x = Symbol.for;
        b = x("react.element");
        c = x("react.portal");
        d = x("react.fragment");
        e = x("react.strict_mode");
        f = x("react.profiler");
        g$3 = x("react.provider");
        h = x("react.context");
        k$1 = x("react.forward_ref");
        l = x("react.suspense");
        m = x("react.suspense_list");
        n = x("react.memo");
        p = x("react.lazy");
        q = x("react.block");
        r = x("react.server.block");
        u = x("react.fundamental");
        v = x("react.debug_trace_mode");
        w = x("react.legacy_hidden");
      }
      function y(a) {
        if ("object" === typeof a && null !== a) {
          var t2 = a.$$typeof;
          switch (t2) {
            case b:
              switch (a = a.type, a) {
                case d:
                case f:
                case e:
                case l:
                case m:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case h:
                    case k$1:
                    case p:
                    case n:
                    case g$3:
                      return a;
                    default:
                      return t2;
                  }
              }
            case c:
              return t2;
          }
        }
      }
      var z = g$3, A = b, B = k$1, C = d, D = p, E = n, F = c, G = f, H = e, I = l;
      reactIs_production_min.ContextConsumer = h;
      reactIs_production_min.ContextProvider = z;
      reactIs_production_min.Element = A;
      reactIs_production_min.ForwardRef = B;
      reactIs_production_min.Fragment = C;
      reactIs_production_min.Lazy = D;
      reactIs_production_min.Memo = E;
      reactIs_production_min.Portal = F;
      reactIs_production_min.Profiler = G;
      reactIs_production_min.StrictMode = H;
      reactIs_production_min.Suspense = I;
      reactIs_production_min.isAsyncMode = function() {
        return false;
      };
      reactIs_production_min.isConcurrentMode = function() {
        return false;
      };
      reactIs_production_min.isContextConsumer = function(a) {
        return y(a) === h;
      };
      reactIs_production_min.isContextProvider = function(a) {
        return y(a) === g$3;
      };
      reactIs_production_min.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === b;
      };
      reactIs_production_min.isForwardRef = function(a) {
        return y(a) === k$1;
      };
      reactIs_production_min.isFragment = function(a) {
        return y(a) === d;
      };
      reactIs_production_min.isLazy = function(a) {
        return y(a) === p;
      };
      reactIs_production_min.isMemo = function(a) {
        return y(a) === n;
      };
      reactIs_production_min.isPortal = function(a) {
        return y(a) === c;
      };
      reactIs_production_min.isProfiler = function(a) {
        return y(a) === f;
      };
      reactIs_production_min.isStrictMode = function(a) {
        return y(a) === e;
      };
      reactIs_production_min.isSuspense = function(a) {
        return y(a) === l;
      };
      reactIs_production_min.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g$3 || a.$$typeof === h || a.$$typeof === k$1 || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? true : false;
      };
      reactIs_production_min.typeOf = y;
      {
        reactIs.exports = reactIs_production_min;
      }
      var reactIsExports = reactIs.exports;
      Object.defineProperty(ReactElement, "__esModule", {
        value: true
      });
      ReactElement.test = ReactElement.serialize = ReactElement.default = void 0;
      var ReactIs = _interopRequireWildcard(reactIsExports);
      var _markup$1 = markup;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key2 in obj) {
          if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key2, desc);
            } else {
              newObj[key2] = obj[key2];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      const getChildren = (arg, children = []) => {
        if (Array.isArray(arg)) {
          arg.forEach((item) => {
            getChildren(item, children);
          });
        } else if (arg != null && arg !== false) {
          children.push(arg);
        }
        return children;
      };
      const getType = (element) => {
        const type2 = element.type;
        if (typeof type2 === "string") {
          return type2;
        }
        if (typeof type2 === "function") {
          return type2.displayName || type2.name || "Unknown";
        }
        if (ReactIs.isFragment(element)) {
          return "React.Fragment";
        }
        if (ReactIs.isSuspense(element)) {
          return "React.Suspense";
        }
        if (typeof type2 === "object" && type2 !== null) {
          if (ReactIs.isContextProvider(element)) {
            return "Context.Provider";
          }
          if (ReactIs.isContextConsumer(element)) {
            return "Context.Consumer";
          }
          if (ReactIs.isForwardRef(element)) {
            if (type2.displayName) {
              return type2.displayName;
            }
            const functionName = type2.render.displayName || type2.render.name || "";
            return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
          }
          if (ReactIs.isMemo(element)) {
            const functionName = type2.displayName || type2.type.displayName || type2.type.name || "";
            return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
          }
        }
        return "UNDEFINED";
      };
      const getPropKeys$1 = (element) => {
        const { props } = element;
        return Object.keys(props).filter((key2) => key2 !== "children" && props[key2] !== void 0).sort();
      };
      const serialize$1 = (element, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? (0, _markup$1.printElementAsLeaf)(getType(element), config2) : (0, _markup$1.printElement)(
        getType(element),
        (0, _markup$1.printProps)(
          getPropKeys$1(element),
          element.props,
          config2,
          indentation + config2.indent,
          depth,
          refs,
          printer2
        ),
        (0, _markup$1.printChildren)(
          getChildren(element.props.children),
          config2,
          indentation + config2.indent,
          depth,
          refs,
          printer2
        ),
        config2,
        indentation
      );
      ReactElement.serialize = serialize$1;
      const test$2 = (val) => val != null && ReactIs.isElement(val);
      ReactElement.test = test$2;
      const plugin$1 = {
        serialize: serialize$1,
        test: test$2
      };
      var _default$2k = plugin$1;
      ReactElement.default = _default$2k;
      var ReactTestComponent = {};
      Object.defineProperty(ReactTestComponent, "__esModule", {
        value: true
      });
      ReactTestComponent.test = ReactTestComponent.serialize = ReactTestComponent.default = void 0;
      var _markup = markup;
      var global$1 = function() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof global$1 !== "undefined") {
          return global$1;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      }();
      var Symbol$1 = global$1["jest-symbol-do-not-touch"] || global$1.Symbol;
      const testSymbol = typeof Symbol$1 === "function" && Symbol$1.for ? Symbol$1.for("react.test.json") : 245830487;
      const getPropKeys = (object2) => {
        const { props } = object2;
        return props ? Object.keys(props).filter((key2) => props[key2] !== void 0).sort() : [];
      };
      const serialize = (object2, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? (0, _markup.printElementAsLeaf)(object2.type, config2) : (0, _markup.printElement)(
        object2.type,
        object2.props ? (0, _markup.printProps)(
          getPropKeys(object2),
          object2.props,
          config2,
          indentation + config2.indent,
          depth,
          refs,
          printer2
        ) : "",
        object2.children ? (0, _markup.printChildren)(
          object2.children,
          config2,
          indentation + config2.indent,
          depth,
          refs,
          printer2
        ) : "",
        config2,
        indentation
      );
      ReactTestComponent.serialize = serialize;
      const test$1 = (val) => val && val.$$typeof === testSymbol;
      ReactTestComponent.test = test$1;
      const plugin = {
        serialize,
        test: test$1
      };
      var _default$2j = plugin;
      ReactTestComponent.default = _default$2j;
      Object.defineProperty(build$1, "__esModule", {
        value: true
      });
      build$1.default = build$1.DEFAULT_OPTIONS = void 0;
      var format_1 = build$1.format = format;
      var plugins_1 = build$1.plugins = void 0;
      var _ansiStyles = _interopRequireDefault$b(ansiStylesExports);
      var _collections = collections;
      var _AsymmetricMatcher = _interopRequireDefault$b(
        AsymmetricMatcher
      );
      var _ConvertAnsi = _interopRequireDefault$b(ConvertAnsi);
      var _DOMCollection = _interopRequireDefault$b(DOMCollection$1);
      var _DOMElement = _interopRequireDefault$b(DOMElement);
      var _Immutable = _interopRequireDefault$b(Immutable);
      var _ReactElement = _interopRequireDefault$b(ReactElement);
      var _ReactTestComponent = _interopRequireDefault$b(
        ReactTestComponent
      );
      function _interopRequireDefault$b(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      const toString$1 = Object.prototype.toString;
      const toISOString = Date.prototype.toISOString;
      const errorToString = Error.prototype.toString;
      const regExpToString = RegExp.prototype.toString;
      const getConstructorName = (val) => typeof val.constructor === "function" && val.constructor.name || "Object";
      const isWindow = (val) => typeof window !== "undefined" && val === window;
      const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
      const NEWLINE_REGEXP = /\n/gi;
      class PrettyFormatPluginError extends Error {
        constructor(message, stack) {
          super(message);
          this.stack = stack;
          this.name = this.constructor.name;
        }
      }
      function isToStringedArrayType(toStringed) {
        return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
      }
      function printNumber(val) {
        return Object.is(val, -0) ? "-0" : String(val);
      }
      function printBigInt(val) {
        return String(`${val}n`);
      }
      function printFunction(val, printFunctionName) {
        if (!printFunctionName) {
          return "[Function]";
        }
        return "[Function " + (val.name || "anonymous") + "]";
      }
      function printSymbol(val) {
        return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      }
      function printError(val) {
        return "[" + errorToString.call(val) + "]";
      }
      function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
        if (val === true || val === false) {
          return "" + val;
        }
        if (val === void 0) {
          return "undefined";
        }
        if (val === null) {
          return "null";
        }
        const typeOf = typeof val;
        if (typeOf === "number") {
          return printNumber(val);
        }
        if (typeOf === "bigint") {
          return printBigInt(val);
        }
        if (typeOf === "string") {
          if (escapeString) {
            return '"' + val.replace(/"|\\/g, "\\$&") + '"';
          }
          return '"' + val + '"';
        }
        if (typeOf === "function") {
          return printFunction(val, printFunctionName);
        }
        if (typeOf === "symbol") {
          return printSymbol(val);
        }
        const toStringed = toString$1.call(val);
        if (toStringed === "[object WeakMap]") {
          return "WeakMap {}";
        }
        if (toStringed === "[object WeakSet]") {
          return "WeakSet {}";
        }
        if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
          return printFunction(val, printFunctionName);
        }
        if (toStringed === "[object Symbol]") {
          return printSymbol(val);
        }
        if (toStringed === "[object Date]") {
          return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
        }
        if (toStringed === "[object Error]") {
          return printError(val);
        }
        if (toStringed === "[object RegExp]") {
          if (escapeRegex) {
            return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          return regExpToString.call(val);
        }
        if (val instanceof Error) {
          return printError(val);
        }
        return null;
      }
      function printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON) {
        if (refs.indexOf(val) !== -1) {
          return "[Circular]";
        }
        refs = refs.slice();
        refs.push(val);
        const hitMaxDepth = ++depth > config2.maxDepth;
        const min = config2.min;
        if (config2.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
          return printer(val.toJSON(), config2, indentation, depth, refs, true);
        }
        const toStringed = toString$1.call(val);
        if (toStringed === "[object Arguments]") {
          return hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer
          ) + "]";
        }
        if (isToStringedArrayType(toStringed)) {
          return hitMaxDepth ? "[" + val.constructor.name + "]" : (min ? "" : !config2.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
            val,
            config2,
            indentation,
            depth,
            refs,
            printer
          ) + "]";
        }
        if (toStringed === "[object Map]") {
          return hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
            val.entries(),
            config2,
            indentation,
            depth,
            refs,
            printer,
            " => "
          ) + "}";
        }
        if (toStringed === "[object Set]") {
          return hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
            val.values(),
            config2,
            indentation,
            depth,
            refs,
            printer
          ) + "}";
        }
        return hitMaxDepth || isWindow(val) ? "[" + getConstructorName(val) + "]" : (min ? "" : !config2.printBasicPrototype && getConstructorName(val) === "Object" ? "" : getConstructorName(val) + " ") + "{" + (0, _collections.printObjectProperties)(
          val,
          config2,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      function isNewPlugin(plugin2) {
        return plugin2.serialize != null;
      }
      function printPlugin(plugin2, val, config2, indentation, depth, refs) {
        let printed;
        try {
          printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config2, indentation, depth, refs, printer) : plugin2.print(
            val,
            (valChild) => printer(valChild, config2, indentation, depth, refs),
            (str) => {
              const indentationNext = indentation + config2.indent;
              return indentationNext + str.replace(NEWLINE_REGEXP, "\n" + indentationNext);
            },
            {
              edgeSpacing: config2.spacingOuter,
              min: config2.min,
              spacing: config2.spacingInner
            },
            config2.colors
          );
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
        if (typeof printed !== "string") {
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
          );
        }
        return printed;
      }
      function findPlugin(plugins2, val) {
        for (let p2 = 0; p2 < plugins2.length; p2++) {
          try {
            if (plugins2[p2].test(val)) {
              return plugins2[p2];
            }
          } catch (error) {
            throw new PrettyFormatPluginError(error.message, error.stack);
          }
        }
        return null;
      }
      function printer(val, config2, indentation, depth, refs, hasCalledToJSON) {
        const plugin2 = findPlugin(config2.plugins, val);
        if (plugin2 !== null) {
          return printPlugin(plugin2, val, config2, indentation, depth, refs);
        }
        const basicResult = printBasicValue(
          val,
          config2.printFunctionName,
          config2.escapeRegex,
          config2.escapeString
        );
        if (basicResult !== null) {
          return basicResult;
        }
        return printComplexValue(
          val,
          config2,
          indentation,
          depth,
          refs,
          hasCalledToJSON
        );
      }
      const DEFAULT_THEME = {
        comment: "gray",
        content: "reset",
        prop: "yellow",
        tag: "cyan",
        value: "green"
      };
      const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
      const DEFAULT_OPTIONS = {
        callToJSON: true,
        compareKeys: void 0,
        escapeRegex: false,
        escapeString: true,
        highlight: false,
        indent: 2,
        maxDepth: Infinity,
        min: false,
        plugins: [],
        printBasicPrototype: true,
        printFunctionName: true,
        theme: DEFAULT_THEME
      };
      build$1.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
      function validateOptions(options) {
        Object.keys(options).forEach((key2) => {
          if (!DEFAULT_OPTIONS.hasOwnProperty(key2)) {
            throw new Error(`pretty-format: Unknown option "${key2}".`);
          }
        });
        if (options.min && options.indent !== void 0 && options.indent !== 0) {
          throw new Error(
            'pretty-format: Options "min" and "indent" cannot be used together.'
          );
        }
        if (options.theme !== void 0) {
          if (options.theme === null) {
            throw new Error('pretty-format: Option "theme" must not be null.');
          }
          if (typeof options.theme !== "object") {
            throw new Error(
              `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
            );
          }
        }
      }
      const getColorsHighlight = (options) => DEFAULT_THEME_KEYS.reduce((colors, key2) => {
        const value = options.theme && options.theme[key2] !== void 0 ? options.theme[key2] : DEFAULT_THEME[key2];
        const color = value && _ansiStyles.default[value];
        if (color && typeof color.close === "string" && typeof color.open === "string") {
          colors[key2] = color;
        } else {
          throw new Error(
            `pretty-format: Option "theme" has a key "${key2}" whose value "${value}" is undefined in ansi-styles.`
          );
        }
        return colors;
      }, /* @__PURE__ */ Object.create(null));
      const getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key2) => {
        colors[key2] = {
          close: "",
          open: ""
        };
        return colors;
      }, /* @__PURE__ */ Object.create(null));
      const getPrintFunctionName = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS.printFunctionName;
      const getEscapeRegex = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS.escapeRegex;
      const getEscapeString = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS.escapeString;
      const getConfig$1 = (options) => {
        var _options$printBasicPr;
        return {
          callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS.callToJSON,
          colors: options && options.highlight ? getColorsHighlight(options) : getColorsEmpty(),
          compareKeys: options && typeof options.compareKeys === "function" ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
          escapeRegex: getEscapeRegex(options),
          escapeString: getEscapeString(options),
          indent: options && options.min ? "" : createIndent(
            options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS.indent
          ),
          maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS.maxDepth,
          min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS.min,
          plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS.plugins,
          printBasicPrototype: (_options$printBasicPr = options === null || options === void 0 ? void 0 : options.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : true,
          printFunctionName: getPrintFunctionName(options),
          spacingInner: options && options.min ? " " : "\n",
          spacingOuter: options && options.min ? "" : "\n"
        };
      };
      function createIndent(indent) {
        return new Array(indent + 1).join(" ");
      }
      function format(val, options) {
        if (options) {
          validateOptions(options);
          if (options.plugins) {
            const plugin2 = findPlugin(options.plugins, val);
            if (plugin2 !== null) {
              return printPlugin(plugin2, val, getConfig$1(options), "", 0, []);
            }
          }
        }
        const basicResult = printBasicValue(
          val,
          getPrintFunctionName(options),
          getEscapeRegex(options),
          getEscapeString(options)
        );
        if (basicResult !== null) {
          return basicResult;
        }
        return printComplexValue(val, getConfig$1(options), "", 0, []);
      }
      const plugins = {
        AsymmetricMatcher: _AsymmetricMatcher.default,
        ConvertAnsi: _ConvertAnsi.default,
        DOMCollection: _DOMCollection.default,
        DOMElement: _DOMElement.default,
        Immutable: _Immutable.default,
        ReactElement: _ReactElement.default,
        ReactTestComponent: _ReactTestComponent.default
      };
      plugins_1 = build$1.plugins = plugins;
      var _default$2i = format;
      build$1.default = _default$2i;
      var toStr$a = Object.prototype.toString;
      function isCallable$2(fn) {
        return typeof fn === "function" || toStr$a.call(fn) === "[object Function]";
      }
      function toInteger(value) {
        var number2 = Number(value);
        if (isNaN(number2)) {
          return 0;
        }
        if (number2 === 0 || !isFinite(number2)) {
          return number2;
        }
        return (number2 > 0 ? 1 : -1) * Math.floor(Math.abs(number2));
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function toLength(value) {
        var len = toInteger(value);
        return Math.min(Math.max(len, 0), maxSafeInteger);
      }
      function arrayFrom(arrayLike, mapFn) {
        var C2 = Array;
        var items = Object(arrayLike);
        if (arrayLike == null) {
          throw new TypeError("Array.from requires an array-like object - not null or undefined");
        }
        if (typeof mapFn !== "undefined") {
          if (!isCallable$2(mapFn)) {
            throw new TypeError("Array.from: when provided, the second argument must be a function");
          }
        }
        var len = toLength(items.length);
        var A2 = isCallable$2(C2) ? Object(new C2(len)) : new Array(len);
        var k2 = 0;
        var kValue;
        while (k2 < len) {
          kValue = items[k2];
          if (mapFn) {
            A2[k2] = mapFn(kValue, k2);
          } else {
            A2[k2] = kValue;
          }
          k2 += 1;
        }
        A2.length = len;
        return A2;
      }
      function _typeof$2(obj) {
        "@babel/helpers - typeof";
        return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$2(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _defineProperty$2(obj, key2, value) {
        key2 = _toPropertyKey$1(key2);
        if (key2 in obj) {
          Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key2] = value;
        }
        return obj;
      }
      function _toPropertyKey$1(arg) {
        var key2 = _toPrimitive$1(arg, "string");
        return _typeof$2(key2) === "symbol" ? key2 : String(key2);
      }
      function _toPrimitive$1(input2, hint) {
        if (_typeof$2(input2) !== "object" || input2 === null)
          return input2;
        var prim = input2[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input2, hint || "default");
          if (_typeof$2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input2);
      }
      var SetLike = /* @__PURE__ */ function() {
        function SetLike2() {
          var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          _classCallCheck(this, SetLike2);
          _defineProperty$2(this, "items", void 0);
          this.items = items;
        }
        _createClass(SetLike2, [{
          key: "add",
          value: function add(value) {
            if (this.has(value) === false) {
              this.items.push(value);
            }
            return this;
          }
        }, {
          key: "clear",
          value: function clear2() {
            this.items = [];
          }
        }, {
          key: "delete",
          value: function _delete(value) {
            var previousLength = this.items.length;
            this.items = this.items.filter(function(item) {
              return item !== value;
            });
            return previousLength !== this.items.length;
          }
        }, {
          key: "forEach",
          value: function forEach2(callbackfn) {
            var _this = this;
            this.items.forEach(function(item) {
              callbackfn(item, item, _this);
            });
          }
        }, {
          key: "has",
          value: function has2(value) {
            return this.items.indexOf(value) !== -1;
          }
        }, {
          key: "size",
          get: function get2() {
            return this.items.length;
          }
        }]);
        return SetLike2;
      }();
      const SetLike$1 = typeof Set === "undefined" ? Set : SetLike;
      function getLocalName(element) {
        var _element$localName;
        return (
          // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
          (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
            // eslint-disable-next-line no-restricted-properties -- required for the fallback
            element.tagName.toLowerCase()
          )
        );
      }
      var localNameToRoleMappings = {
        article: "article",
        aside: "complementary",
        button: "button",
        datalist: "listbox",
        dd: "definition",
        details: "group",
        dialog: "dialog",
        dt: "term",
        fieldset: "group",
        figure: "figure",
        // WARNING: Only with an accessible name
        form: "form",
        footer: "contentinfo",
        h1: "heading",
        h2: "heading",
        h3: "heading",
        h4: "heading",
        h5: "heading",
        h6: "heading",
        header: "banner",
        hr: "separator",
        html: "document",
        legend: "legend",
        li: "listitem",
        math: "math",
        main: "main",
        menu: "list",
        nav: "navigation",
        ol: "list",
        optgroup: "group",
        // WARNING: Only in certain context
        option: "option",
        output: "status",
        progress: "progressbar",
        // WARNING: Only with an accessible name
        section: "region",
        summary: "button",
        table: "table",
        tbody: "rowgroup",
        textarea: "textbox",
        tfoot: "rowgroup",
        // WARNING: Only in certain context
        td: "cell",
        th: "columnheader",
        thead: "rowgroup",
        tr: "row",
        ul: "list"
      };
      var prohibitedAttributes = {
        caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
        insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
        superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
      };
      function hasGlobalAriaAttributes(element, role2) {
        return [
          "aria-atomic",
          "aria-busy",
          "aria-controls",
          "aria-current",
          "aria-describedby",
          "aria-details",
          // "disabled",
          "aria-dropeffect",
          // "errormessage",
          "aria-flowto",
          "aria-grabbed",
          // "haspopup",
          "aria-hidden",
          // "invalid",
          "aria-keyshortcuts",
          "aria-label",
          "aria-labelledby",
          "aria-live",
          "aria-owns",
          "aria-relevant",
          "aria-roledescription"
        ].some(function(attributeName) {
          var _prohibitedAttributes;
          return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role2]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
        });
      }
      function ignorePresentationalRole(element, implicitRole) {
        return hasGlobalAriaAttributes(element, implicitRole);
      }
      function getRole(element) {
        var explicitRole = getExplicitRole(element);
        if (explicitRole === null || explicitRole === "presentation") {
          var implicitRole = getImplicitRole(element);
          if (explicitRole !== "presentation" || ignorePresentationalRole(element, implicitRole || "")) {
            return implicitRole;
          }
        }
        return explicitRole;
      }
      function getImplicitRole(element) {
        var mappedByTag = localNameToRoleMappings[getLocalName(element)];
        if (mappedByTag !== void 0) {
          return mappedByTag;
        }
        switch (getLocalName(element)) {
          case "a":
          case "area":
          case "link":
            if (element.hasAttribute("href")) {
              return "link";
            }
            break;
          case "img":
            if (element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img")) {
              return "presentation";
            }
            return "img";
          case "input": {
            var _ref = element, type2 = _ref.type;
            switch (type2) {
              case "button":
              case "image":
              case "reset":
              case "submit":
                return "button";
              case "checkbox":
              case "radio":
                return type2;
              case "range":
                return "slider";
              case "email":
              case "tel":
              case "text":
              case "url":
                if (element.hasAttribute("list")) {
                  return "combobox";
                }
                return "textbox";
              case "search":
                if (element.hasAttribute("list")) {
                  return "combobox";
                }
                return "searchbox";
              case "number":
                return "spinbutton";
              default:
                return null;
            }
          }
          case "select":
            if (element.hasAttribute("multiple") || element.size > 1) {
              return "listbox";
            }
            return "combobox";
        }
        return null;
      }
      function getExplicitRole(element) {
        var role2 = element.getAttribute("role");
        if (role2 !== null) {
          var explicitRole = role2.trim().split(" ")[0];
          if (explicitRole.length > 0) {
            return explicitRole;
          }
        }
        return null;
      }
      function isElement$2(node2) {
        return node2 !== null && node2.nodeType === node2.ELEMENT_NODE;
      }
      function isHTMLTableCaptionElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "caption";
      }
      function isHTMLInputElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "input";
      }
      function isHTMLOptGroupElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "optgroup";
      }
      function isHTMLSelectElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "select";
      }
      function isHTMLTableElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "table";
      }
      function isHTMLTextAreaElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "textarea";
      }
      function safeWindow(node2) {
        var _ref = node2.ownerDocument === null ? node2 : node2.ownerDocument, defaultView = _ref.defaultView;
        if (defaultView === null) {
          throw new TypeError("no window available");
        }
        return defaultView;
      }
      function isHTMLFieldSetElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "fieldset";
      }
      function isHTMLLegendElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "legend";
      }
      function isHTMLSlotElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "slot";
      }
      function isSVGElement(node2) {
        return isElement$2(node2) && node2.ownerSVGElement !== void 0;
      }
      function isSVGSVGElement(node2) {
        return isElement$2(node2) && getLocalName(node2) === "svg";
      }
      function isSVGTitleElement(node2) {
        return isSVGElement(node2) && getLocalName(node2) === "title";
      }
      function queryIdRefs(node2, attributeName) {
        if (isElement$2(node2) && node2.hasAttribute(attributeName)) {
          var ids = node2.getAttribute(attributeName).split(" ");
          var root = node2.getRootNode ? node2.getRootNode() : node2.ownerDocument;
          return ids.map(function(id) {
            return root.getElementById(id);
          }).filter(
            function(element) {
              return element !== null;
            }
            // TODO: why does this not narrow?
          );
        }
        return [];
      }
      function hasAnyConcreteRoles(node2, roles2) {
        if (isElement$2(node2)) {
          return roles2.indexOf(getRole(node2)) !== -1;
        }
        return false;
      }
      function asFlatString(s) {
        return s.trim().replace(/\s\s+/g, " ");
      }
      function isHidden(node2, getComputedStyleImplementation) {
        if (!isElement$2(node2)) {
          return false;
        }
        if (node2.hasAttribute("hidden") || node2.getAttribute("aria-hidden") === "true") {
          return true;
        }
        var style2 = getComputedStyleImplementation(node2);
        return style2.getPropertyValue("display") === "none" || style2.getPropertyValue("visibility") === "hidden";
      }
      function isControl(node2) {
        return hasAnyConcreteRoles(node2, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node2, "range");
      }
      function hasAbstractRole(node2, role2) {
        if (!isElement$2(node2)) {
          return false;
        }
        switch (role2) {
          case "range":
            return hasAnyConcreteRoles(node2, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
          default:
            throw new TypeError("No knowledge about abstract role '".concat(role2, "'. This is likely a bug :("));
        }
      }
      function querySelectorAllSubtree(element, selectors) {
        var elements = arrayFrom(element.querySelectorAll(selectors));
        queryIdRefs(element, "aria-owns").forEach(function(root) {
          elements.push.apply(elements, arrayFrom(root.querySelectorAll(selectors)));
        });
        return elements;
      }
      function querySelectedOptions(listbox) {
        if (isHTMLSelectElement(listbox)) {
          return listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]");
        }
        return querySelectorAllSubtree(listbox, '[aria-selected="true"]');
      }
      function isMarkedPresentational(node2) {
        return hasAnyConcreteRoles(node2, ["none", "presentation"]);
      }
      function isNativeHostLanguageTextAlternativeElement(node2) {
        return isHTMLTableCaptionElement(node2);
      }
      function allowsNameFromContent(node2) {
        return hasAnyConcreteRoles(node2, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
      }
      function isDescendantOfNativeHostLanguageTextAlternativeElement(node2) {
        return false;
      }
      function getValueOfTextbox(element) {
        if (isHTMLInputElement(element) || isHTMLTextAreaElement(element)) {
          return element.value;
        }
        return element.textContent || "";
      }
      function getTextualContent(declaration2) {
        var content = declaration2.getPropertyValue("content");
        if (/^["'].*["']$/.test(content)) {
          return content.slice(1, -1);
        }
        return "";
      }
      function isLabelableElement(element) {
        var localName = getLocalName(element);
        return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
      }
      function findLabelableElement(element) {
        if (isLabelableElement(element)) {
          return element;
        }
        var labelableElement = null;
        element.childNodes.forEach(function(childNode) {
          if (labelableElement === null && isElement$2(childNode)) {
            var descendantLabelableElement = findLabelableElement(childNode);
            if (descendantLabelableElement !== null) {
              labelableElement = descendantLabelableElement;
            }
          }
        });
        return labelableElement;
      }
      function getControlOfLabel(label) {
        if (label.control !== void 0) {
          return label.control;
        }
        var htmlFor = label.getAttribute("for");
        if (htmlFor !== null) {
          return label.ownerDocument.getElementById(htmlFor);
        }
        return findLabelableElement(label);
      }
      function getLabels$1(element) {
        var labelsProperty = element.labels;
        if (labelsProperty === null) {
          return labelsProperty;
        }
        if (labelsProperty !== void 0) {
          return arrayFrom(labelsProperty);
        }
        if (!isLabelableElement(element)) {
          return null;
        }
        var document2 = element.ownerDocument;
        return arrayFrom(document2.querySelectorAll("label")).filter(function(label) {
          return getControlOfLabel(label) === element;
        });
      }
      function getSlotContents(slot) {
        var assignedNodes = slot.assignedNodes();
        if (assignedNodes.length === 0) {
          return arrayFrom(slot.childNodes);
        }
        return assignedNodes;
      }
      function computeTextAlternative(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var consultedNodes = new SetLike$1();
        var window2 = safeWindow(root);
        var _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
        function computeMiscTextAlternative(node2, context) {
          var accumulatedText = "";
          if (isElement$2(node2) && computedStyleSupportsPseudoElements) {
            var pseudoBefore = getComputedStyle2(node2, "::before");
            var beforeContent = getTextualContent(pseudoBefore);
            accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
          }
          var childNodes = isHTMLSlotElement(node2) ? getSlotContents(node2) : arrayFrom(node2.childNodes).concat(queryIdRefs(node2, "aria-owns"));
          childNodes.forEach(function(child) {
            var result = computeTextAlternative2(child, {
              isEmbeddedInLabel: context.isEmbeddedInLabel,
              isReferenced: false,
              recursion: true
            });
            var display = isElement$2(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline";
            var separator = display !== "inline" ? " " : "";
            accumulatedText += "".concat(separator).concat(result).concat(separator);
          });
          if (isElement$2(node2) && computedStyleSupportsPseudoElements) {
            var pseudoAfter = getComputedStyle2(node2, "::after");
            var afterContent = getTextualContent(pseudoAfter);
            accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
          }
          return accumulatedText.trim();
        }
        function useAttribute(element, attributeName) {
          var attribute = element.getAttributeNode(attributeName);
          if (attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "") {
            consultedNodes.add(attribute);
            return attribute.value;
          }
          return null;
        }
        function computeTooltipAttributeValue(node2) {
          if (!isElement$2(node2)) {
            return null;
          }
          return useAttribute(node2, "title");
        }
        function computeElementTextAlternative(node2) {
          if (!isElement$2(node2)) {
            return null;
          }
          if (isHTMLFieldSetElement(node2)) {
            consultedNodes.add(node2);
            var children = arrayFrom(node2.childNodes);
            for (var i2 = 0; i2 < children.length; i2 += 1) {
              var child = children[i2];
              if (isHTMLLegendElement(child)) {
                return computeTextAlternative2(child, {
                  isEmbeddedInLabel: false,
                  isReferenced: false,
                  recursion: false
                });
              }
            }
          } else if (isHTMLTableElement(node2)) {
            consultedNodes.add(node2);
            var _children = arrayFrom(node2.childNodes);
            for (var _i = 0; _i < _children.length; _i += 1) {
              var _child = _children[_i];
              if (isHTMLTableCaptionElement(_child)) {
                return computeTextAlternative2(_child, {
                  isEmbeddedInLabel: false,
                  isReferenced: false,
                  recursion: false
                });
              }
            }
          } else if (isSVGSVGElement(node2)) {
            consultedNodes.add(node2);
            var _children2 = arrayFrom(node2.childNodes);
            for (var _i2 = 0; _i2 < _children2.length; _i2 += 1) {
              var _child2 = _children2[_i2];
              if (isSVGTitleElement(_child2)) {
                return _child2.textContent;
              }
            }
            return null;
          } else if (getLocalName(node2) === "img" || getLocalName(node2) === "area") {
            var nameFromAlt = useAttribute(node2, "alt");
            if (nameFromAlt !== null) {
              return nameFromAlt;
            }
          } else if (isHTMLOptGroupElement(node2)) {
            var nameFromLabel = useAttribute(node2, "label");
            if (nameFromLabel !== null) {
              return nameFromLabel;
            }
          }
          if (isHTMLInputElement(node2) && (node2.type === "button" || node2.type === "submit" || node2.type === "reset")) {
            var nameFromValue = useAttribute(node2, "value");
            if (nameFromValue !== null) {
              return nameFromValue;
            }
            if (node2.type === "submit") {
              return "Submit";
            }
            if (node2.type === "reset") {
              return "Reset";
            }
          }
          var labels = getLabels$1(node2);
          if (labels !== null && labels.length !== 0) {
            consultedNodes.add(node2);
            return arrayFrom(labels).map(function(element) {
              return computeTextAlternative2(element, {
                isEmbeddedInLabel: true,
                isReferenced: false,
                recursion: true
              });
            }).filter(function(label) {
              return label.length > 0;
            }).join(" ");
          }
          if (isHTMLInputElement(node2) && node2.type === "image") {
            var _nameFromAlt = useAttribute(node2, "alt");
            if (_nameFromAlt !== null) {
              return _nameFromAlt;
            }
            var nameFromTitle = useAttribute(node2, "title");
            if (nameFromTitle !== null) {
              return nameFromTitle;
            }
            return "Submit Query";
          }
          if (hasAnyConcreteRoles(node2, ["button"])) {
            var nameFromSubTree = computeMiscTextAlternative(node2, {
              isEmbeddedInLabel: false,
              isReferenced: false
            });
            if (nameFromSubTree !== "") {
              return nameFromSubTree;
            }
          }
          return null;
        }
        function computeTextAlternative2(current, context) {
          if (consultedNodes.has(current)) {
            return "";
          }
          if (!hidden && isHidden(current, getComputedStyle2) && !context.isReferenced) {
            consultedNodes.add(current);
            return "";
          }
          var labelAttributeNode = isElement$2(current) ? current.getAttributeNode("aria-labelledby") : null;
          var labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
          if (compute === "name" && !context.isReferenced && labelElements.length > 0) {
            consultedNodes.add(labelAttributeNode);
            return labelElements.map(function(element) {
              return computeTextAlternative2(element, {
                isEmbeddedInLabel: context.isEmbeddedInLabel,
                isReferenced: true,
                // this isn't recursion as specified, otherwise we would skip
                // `aria-label` in
                // <input id="myself" aria-label="foo" aria-labelledby="myself"
                recursion: false
              });
            }).join(" ");
          }
          var skipToStep2E = context.recursion && isControl(current) && compute === "name";
          if (!skipToStep2E) {
            var ariaLabel = (isElement$2(current) && current.getAttribute("aria-label") || "").trim();
            if (ariaLabel !== "" && compute === "name") {
              consultedNodes.add(current);
              return ariaLabel;
            }
            if (!isMarkedPresentational(current)) {
              var elementTextAlternative = computeElementTextAlternative(current);
              if (elementTextAlternative !== null) {
                consultedNodes.add(current);
                return elementTextAlternative;
              }
            }
          }
          if (hasAnyConcreteRoles(current, ["menu"])) {
            consultedNodes.add(current);
            return "";
          }
          if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
            if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
              consultedNodes.add(current);
              var selectedOptions = querySelectedOptions(current);
              if (selectedOptions.length === 0) {
                return isHTMLInputElement(current) ? current.value : "";
              }
              return arrayFrom(selectedOptions).map(function(selectedOption) {
                return computeTextAlternative2(selectedOption, {
                  isEmbeddedInLabel: context.isEmbeddedInLabel,
                  isReferenced: false,
                  recursion: true
                });
              }).join(" ");
            }
            if (hasAbstractRole(current, "range")) {
              consultedNodes.add(current);
              if (current.hasAttribute("aria-valuetext")) {
                return current.getAttribute("aria-valuetext");
              }
              if (current.hasAttribute("aria-valuenow")) {
                return current.getAttribute("aria-valuenow");
              }
              return current.getAttribute("value") || "";
            }
            if (hasAnyConcreteRoles(current, ["textbox"])) {
              consultedNodes.add(current);
              return getValueOfTextbox(current);
            }
          }
          if (allowsNameFromContent(current) || isElement$2(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement()) {
            var accumulatedText2F = computeMiscTextAlternative(current, {
              isEmbeddedInLabel: context.isEmbeddedInLabel,
              isReferenced: false
            });
            if (accumulatedText2F !== "") {
              consultedNodes.add(current);
              return accumulatedText2F;
            }
          }
          if (current.nodeType === current.TEXT_NODE) {
            consultedNodes.add(current);
            return current.textContent || "";
          }
          if (context.recursion) {
            consultedNodes.add(current);
            return computeMiscTextAlternative(current, {
              isEmbeddedInLabel: context.isEmbeddedInLabel,
              isReferenced: false
            });
          }
          var tooltipAttributeValue = computeTooltipAttributeValue(current);
          if (tooltipAttributeValue !== null) {
            consultedNodes.add(current);
            return tooltipAttributeValue;
          }
          consultedNodes.add(current);
          return "";
        }
        return asFlatString(computeTextAlternative2(root, {
          isEmbeddedInLabel: false,
          // by spec computeAccessibleDescription starts with the referenced elements as roots
          isReferenced: compute === "description",
          recursion: false
        }));
      }
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof$1(obj);
      }
      function ownKeys(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
            _defineProperty$1(target, key2, source[key2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
        return target;
      }
      function _defineProperty$1(obj, key2, value) {
        key2 = _toPropertyKey(key2);
        if (key2 in obj) {
          Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key2] = value;
        }
        return obj;
      }
      function _toPropertyKey(arg) {
        var key2 = _toPrimitive(arg, "string");
        return _typeof$1(key2) === "symbol" ? key2 : String(key2);
      }
      function _toPrimitive(input2, hint) {
        if (_typeof$1(input2) !== "object" || input2 === null)
          return input2;
        var prim = input2[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input2, hint || "default");
          if (_typeof$1(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input2);
      }
      function computeAccessibleDescription(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var description = queryIdRefs(root, "aria-describedby").map(function(element) {
          return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
            compute: "description"
          }));
        }).join(" ");
        if (description === "") {
          var title = root.getAttribute("title");
          description = title === null ? "" : title;
        }
        return description;
      }
      function prohibitsNaming(node2) {
        return hasAnyConcreteRoles(node2, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
      }
      function computeAccessibleName(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (prohibitsNaming(root)) {
          return "";
        }
        return computeTextAlternative(root, options);
      }
      var lib = {};
      var ariaPropsMap$1 = {};
      var iterationDecorator$1 = {};
      var iteratorProxy$1 = {};
      Object.defineProperty(iteratorProxy$1, "__esModule", {
        value: true
      });
      iteratorProxy$1.default = void 0;
      function iteratorProxy() {
        var values = this;
        var index2 = 0;
        var iter = {
          "@@iterator": function iterator() {
            return iter;
          },
          next: function next2() {
            if (index2 < values.length) {
              var value = values[index2];
              index2 = index2 + 1;
              return {
                done: false,
                value
              };
            } else {
              return {
                done: true
              };
            }
          }
        };
        return iter;
      }
      var _default$2h = iteratorProxy;
      iteratorProxy$1.default = _default$2h;
      Object.defineProperty(iterationDecorator$1, "__esModule", {
        value: true
      });
      iterationDecorator$1.default = iterationDecorator;
      var _iteratorProxy = _interopRequireDefault$a(iteratorProxy$1);
      function _interopRequireDefault$a(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      function iterationDecorator(collection, entries) {
        if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
          Object.defineProperty(collection, Symbol.iterator, {
            value: _iteratorProxy.default.bind(entries)
          });
        }
        return collection;
      }
      Object.defineProperty(ariaPropsMap$1, "__esModule", {
        value: true
      });
      ariaPropsMap$1.default = void 0;
      var _iterationDecorator$4 = _interopRequireDefault$9(iterationDecorator$1);
      function _interopRequireDefault$9(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray$4(arr, i2) {
        return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i2) || _unsupportedIterableToArray$4(arr, i2) || _nonIterableRest$4();
      }
      function _nonIterableRest$4() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit$4(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles$4(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper$4(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray$4(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it)
              o2 = it;
            var i2 = 0;
            var F2 = function F3() {
            };
            return { s: F2, n: function n2() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            }, e: function e2(_e2) {
              throw _e2;
            }, f: F2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o2);
        }, n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e2(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f2() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray$4(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$4(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$4(o2, minLen);
      }
      function _arrayLikeToArray$4(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var properties = [["aria-activedescendant", {
        "type": "id"
      }], ["aria-atomic", {
        "type": "boolean"
      }], ["aria-autocomplete", {
        "type": "token",
        "values": ["inline", "list", "both", "none"]
      }], ["aria-busy", {
        "type": "boolean"
      }], ["aria-checked", {
        "type": "tristate"
      }], ["aria-colcount", {
        type: "integer"
      }], ["aria-colindex", {
        type: "integer"
      }], ["aria-colspan", {
        type: "integer"
      }], ["aria-controls", {
        "type": "idlist"
      }], ["aria-current", {
        type: "token",
        values: ["page", "step", "location", "date", "time", true, false]
      }], ["aria-describedby", {
        "type": "idlist"
      }], ["aria-details", {
        "type": "id"
      }], ["aria-disabled", {
        "type": "boolean"
      }], ["aria-dropeffect", {
        "type": "tokenlist",
        "values": ["copy", "execute", "link", "move", "none", "popup"]
      }], ["aria-errormessage", {
        "type": "id"
      }], ["aria-expanded", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-flowto", {
        "type": "idlist"
      }], ["aria-grabbed", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-haspopup", {
        "type": "token",
        "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
      }], ["aria-hidden", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-invalid", {
        "type": "token",
        "values": ["grammar", false, "spelling", true]
      }], ["aria-keyshortcuts", {
        type: "string"
      }], ["aria-label", {
        "type": "string"
      }], ["aria-labelledby", {
        "type": "idlist"
      }], ["aria-level", {
        "type": "integer"
      }], ["aria-live", {
        "type": "token",
        "values": ["assertive", "off", "polite"]
      }], ["aria-modal", {
        type: "boolean"
      }], ["aria-multiline", {
        "type": "boolean"
      }], ["aria-multiselectable", {
        "type": "boolean"
      }], ["aria-orientation", {
        "type": "token",
        "values": ["vertical", "undefined", "horizontal"]
      }], ["aria-owns", {
        "type": "idlist"
      }], ["aria-placeholder", {
        type: "string"
      }], ["aria-posinset", {
        "type": "integer"
      }], ["aria-pressed", {
        "type": "tristate"
      }], ["aria-readonly", {
        "type": "boolean"
      }], ["aria-relevant", {
        "type": "tokenlist",
        "values": ["additions", "all", "removals", "text"]
      }], ["aria-required", {
        "type": "boolean"
      }], ["aria-roledescription", {
        type: "string"
      }], ["aria-rowcount", {
        type: "integer"
      }], ["aria-rowindex", {
        type: "integer"
      }], ["aria-rowspan", {
        type: "integer"
      }], ["aria-selected", {
        "type": "boolean",
        "allowundefined": true
      }], ["aria-setsize", {
        "type": "integer"
      }], ["aria-sort", {
        "type": "token",
        "values": ["ascending", "descending", "none", "other"]
      }], ["aria-valuemax", {
        "type": "number"
      }], ["aria-valuemin", {
        "type": "number"
      }], ["aria-valuenow", {
        "type": "number"
      }], ["aria-valuetext", {
        "type": "string"
      }]];
      var ariaPropsMap = {
        entries: function entries() {
          return properties;
        },
        forEach: function forEach2(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$4(properties), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray$4(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, key2, properties);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = properties.find(function(tuple2) {
            return tuple2[0] === key2 ? true : false;
          });
          return item && item[1];
        },
        has: function has2(key2) {
          return !!ariaPropsMap.get(key2);
        },
        keys: function keys2() {
          return properties.map(function(_ref) {
            var _ref2 = _slicedToArray$4(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return properties.map(function(_ref3) {
            var _ref4 = _slicedToArray$4(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default$2g = (0, _iterationDecorator$4.default)(ariaPropsMap, ariaPropsMap.entries());
      ariaPropsMap$1.default = _default$2g;
      var domMap$1 = {};
      Object.defineProperty(domMap$1, "__esModule", {
        value: true
      });
      domMap$1.default = void 0;
      var _iterationDecorator$3 = _interopRequireDefault$8(iterationDecorator$1);
      function _interopRequireDefault$8(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray$3(arr, i2) {
        return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest$3();
      }
      function _nonIterableRest$3() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit$3(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles$3(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper$3(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray$3(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it)
              o2 = it;
            var i2 = 0;
            var F2 = function F3() {
            };
            return { s: F2, n: function n2() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            }, e: function e2(_e2) {
              throw _e2;
            }, f: F2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o2);
        }, n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e2(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f2() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray$3(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$3(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$3(o2, minLen);
      }
      function _arrayLikeToArray$3(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var dom$1 = [["a", {
        reserved: false
      }], ["abbr", {
        reserved: false
      }], ["acronym", {
        reserved: false
      }], ["address", {
        reserved: false
      }], ["applet", {
        reserved: false
      }], ["area", {
        reserved: false
      }], ["article", {
        reserved: false
      }], ["aside", {
        reserved: false
      }], ["audio", {
        reserved: false
      }], ["b", {
        reserved: false
      }], ["base", {
        reserved: true
      }], ["bdi", {
        reserved: false
      }], ["bdo", {
        reserved: false
      }], ["big", {
        reserved: false
      }], ["blink", {
        reserved: false
      }], ["blockquote", {
        reserved: false
      }], ["body", {
        reserved: false
      }], ["br", {
        reserved: false
      }], ["button", {
        reserved: false
      }], ["canvas", {
        reserved: false
      }], ["caption", {
        reserved: false
      }], ["center", {
        reserved: false
      }], ["cite", {
        reserved: false
      }], ["code", {
        reserved: false
      }], ["col", {
        reserved: true
      }], ["colgroup", {
        reserved: true
      }], ["content", {
        reserved: false
      }], ["data", {
        reserved: false
      }], ["datalist", {
        reserved: false
      }], ["dd", {
        reserved: false
      }], ["del", {
        reserved: false
      }], ["details", {
        reserved: false
      }], ["dfn", {
        reserved: false
      }], ["dialog", {
        reserved: false
      }], ["dir", {
        reserved: false
      }], ["div", {
        reserved: false
      }], ["dl", {
        reserved: false
      }], ["dt", {
        reserved: false
      }], ["em", {
        reserved: false
      }], ["embed", {
        reserved: false
      }], ["fieldset", {
        reserved: false
      }], ["figcaption", {
        reserved: false
      }], ["figure", {
        reserved: false
      }], ["font", {
        reserved: false
      }], ["footer", {
        reserved: false
      }], ["form", {
        reserved: false
      }], ["frame", {
        reserved: false
      }], ["frameset", {
        reserved: false
      }], ["h1", {
        reserved: false
      }], ["h2", {
        reserved: false
      }], ["h3", {
        reserved: false
      }], ["h4", {
        reserved: false
      }], ["h5", {
        reserved: false
      }], ["h6", {
        reserved: false
      }], ["head", {
        reserved: true
      }], ["header", {
        reserved: false
      }], ["hgroup", {
        reserved: false
      }], ["hr", {
        reserved: false
      }], ["html", {
        reserved: true
      }], ["i", {
        reserved: false
      }], ["iframe", {
        reserved: false
      }], ["img", {
        reserved: false
      }], ["input", {
        reserved: false
      }], ["ins", {
        reserved: false
      }], ["kbd", {
        reserved: false
      }], ["keygen", {
        reserved: false
      }], ["label", {
        reserved: false
      }], ["legend", {
        reserved: false
      }], ["li", {
        reserved: false
      }], ["link", {
        reserved: true
      }], ["main", {
        reserved: false
      }], ["map", {
        reserved: false
      }], ["mark", {
        reserved: false
      }], ["marquee", {
        reserved: false
      }], ["menu", {
        reserved: false
      }], ["menuitem", {
        reserved: false
      }], ["meta", {
        reserved: true
      }], ["meter", {
        reserved: false
      }], ["nav", {
        reserved: false
      }], ["noembed", {
        reserved: true
      }], ["noscript", {
        reserved: true
      }], ["object", {
        reserved: false
      }], ["ol", {
        reserved: false
      }], ["optgroup", {
        reserved: false
      }], ["option", {
        reserved: false
      }], ["output", {
        reserved: false
      }], ["p", {
        reserved: false
      }], ["param", {
        reserved: true
      }], ["picture", {
        reserved: true
      }], ["pre", {
        reserved: false
      }], ["progress", {
        reserved: false
      }], ["q", {
        reserved: false
      }], ["rp", {
        reserved: false
      }], ["rt", {
        reserved: false
      }], ["rtc", {
        reserved: false
      }], ["ruby", {
        reserved: false
      }], ["s", {
        reserved: false
      }], ["samp", {
        reserved: false
      }], ["script", {
        reserved: true
      }], ["section", {
        reserved: false
      }], ["select", {
        reserved: false
      }], ["small", {
        reserved: false
      }], ["source", {
        reserved: true
      }], ["spacer", {
        reserved: false
      }], ["span", {
        reserved: false
      }], ["strike", {
        reserved: false
      }], ["strong", {
        reserved: false
      }], ["style", {
        reserved: true
      }], ["sub", {
        reserved: false
      }], ["summary", {
        reserved: false
      }], ["sup", {
        reserved: false
      }], ["table", {
        reserved: false
      }], ["tbody", {
        reserved: false
      }], ["td", {
        reserved: false
      }], ["textarea", {
        reserved: false
      }], ["tfoot", {
        reserved: false
      }], ["th", {
        reserved: false
      }], ["thead", {
        reserved: false
      }], ["time", {
        reserved: false
      }], ["title", {
        reserved: true
      }], ["tr", {
        reserved: false
      }], ["track", {
        reserved: true
      }], ["tt", {
        reserved: false
      }], ["u", {
        reserved: false
      }], ["ul", {
        reserved: false
      }], ["var", {
        reserved: false
      }], ["video", {
        reserved: false
      }], ["wbr", {
        reserved: false
      }], ["xmp", {
        reserved: false
      }]];
      var domMap = {
        entries: function entries() {
          return dom$1;
        },
        forEach: function forEach2(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$3(dom$1), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray$3(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, key2, dom$1);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = dom$1.find(function(tuple2) {
            return tuple2[0] === key2 ? true : false;
          });
          return item && item[1];
        },
        has: function has2(key2) {
          return !!domMap.get(key2);
        },
        keys: function keys2() {
          return dom$1.map(function(_ref) {
            var _ref2 = _slicedToArray$3(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return dom$1.map(function(_ref3) {
            var _ref4 = _slicedToArray$3(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default$2f = (0, _iterationDecorator$3.default)(domMap, domMap.entries());
      domMap$1.default = _default$2f;
      var rolesMap$1 = {};
      var ariaAbstractRoles$1 = {};
      var commandRole$1 = {};
      Object.defineProperty(commandRole$1, "__esModule", {
        value: true
      });
      commandRole$1.default = void 0;
      var commandRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menuitem"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default$2e = commandRole;
      commandRole$1.default = _default$2e;
      var compositeRole$1 = {};
      Object.defineProperty(compositeRole$1, "__esModule", {
        value: true
      });
      compositeRole$1.default = void 0;
      var compositeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default$2d = compositeRole;
      compositeRole$1.default = _default$2d;
      var inputRole$1 = {};
      Object.defineProperty(inputRole$1, "__esModule", {
        value: true
      });
      inputRole$1.default = void 0;
      var inputRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null
        },
        relatedConcepts: [{
          concept: {
            name: "input"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget"]]
      };
      var _default$2c = inputRole;
      inputRole$1.default = _default$2c;
      var landmarkRole$1 = {};
      Object.defineProperty(landmarkRole$1, "__esModule", {
        value: true
      });
      landmarkRole$1.default = void 0;
      var landmarkRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$2b = landmarkRole;
      landmarkRole$1.default = _default$2b;
      var rangeRole$1 = {};
      Object.defineProperty(rangeRole$1, "__esModule", {
        value: true
      });
      rangeRole$1.default = void 0;
      var rangeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuemax": null,
          "aria-valuemin": null,
          "aria-valuenow": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$2a = rangeRole;
      rangeRole$1.default = _default$2a;
      var roletypeRole$1 = {};
      Object.defineProperty(roletypeRole$1, "__esModule", {
        value: true
      });
      roletypeRole$1.default = void 0;
      var roletypeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {
          "aria-atomic": null,
          "aria-busy": null,
          "aria-controls": null,
          "aria-current": null,
          "aria-describedby": null,
          "aria-details": null,
          "aria-dropeffect": null,
          "aria-flowto": null,
          "aria-grabbed": null,
          "aria-hidden": null,
          "aria-keyshortcuts": null,
          "aria-label": null,
          "aria-labelledby": null,
          "aria-live": null,
          "aria-owns": null,
          "aria-relevant": null,
          "aria-roledescription": null
        },
        relatedConcepts: [{
          concept: {
            name: "rel"
          },
          module: "HTML"
        }, {
          concept: {
            name: "role"
          },
          module: "XHTML"
        }, {
          concept: {
            name: "type"
          },
          module: "Dublin Core"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default$29 = roletypeRole;
      roletypeRole$1.default = _default$29;
      var sectionRole$1 = {};
      Object.defineProperty(sectionRole$1, "__esModule", {
        value: true
      });
      sectionRole$1.default = void 0;
      var sectionRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "frontmatter"
          },
          module: "DTB"
        }, {
          concept: {
            name: "level"
          },
          module: "DTB"
        }, {
          concept: {
            name: "level"
          },
          module: "SMIL"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$28 = sectionRole;
      sectionRole$1.default = _default$28;
      var sectionheadRole$1 = {};
      Object.defineProperty(sectionheadRole$1, "__esModule", {
        value: true
      });
      sectionheadRole$1.default = void 0;
      var sectionheadRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$27 = sectionheadRole;
      sectionheadRole$1.default = _default$27;
      var selectRole$1 = {};
      Object.defineProperty(selectRole$1, "__esModule", {
        value: true
      });
      selectRole$1.default = void 0;
      var selectRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
      };
      var _default$26 = selectRole;
      selectRole$1.default = _default$26;
      var structureRole$1 = {};
      Object.defineProperty(structureRole$1, "__esModule", {
        value: true
      });
      structureRole$1.default = void 0;
      var structureRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default$25 = structureRole;
      structureRole$1.default = _default$25;
      var widgetRole$1 = {};
      Object.defineProperty(widgetRole$1, "__esModule", {
        value: true
      });
      widgetRole$1.default = void 0;
      var widgetRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default$24 = widgetRole;
      widgetRole$1.default = _default$24;
      var windowRole$1 = {};
      Object.defineProperty(windowRole$1, "__esModule", {
        value: true
      });
      windowRole$1.default = void 0;
      var windowRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-modal": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype"]]
      };
      var _default$23 = windowRole;
      windowRole$1.default = _default$23;
      Object.defineProperty(ariaAbstractRoles$1, "__esModule", {
        value: true
      });
      ariaAbstractRoles$1.default = void 0;
      var _commandRole = _interopRequireDefault$7(commandRole$1);
      var _compositeRole = _interopRequireDefault$7(compositeRole$1);
      var _inputRole = _interopRequireDefault$7(inputRole$1);
      var _landmarkRole = _interopRequireDefault$7(landmarkRole$1);
      var _rangeRole = _interopRequireDefault$7(rangeRole$1);
      var _roletypeRole = _interopRequireDefault$7(roletypeRole$1);
      var _sectionRole = _interopRequireDefault$7(sectionRole$1);
      var _sectionheadRole = _interopRequireDefault$7(sectionheadRole$1);
      var _selectRole = _interopRequireDefault$7(selectRole$1);
      var _structureRole = _interopRequireDefault$7(structureRole$1);
      var _widgetRole = _interopRequireDefault$7(widgetRole$1);
      var _windowRole = _interopRequireDefault$7(windowRole$1);
      function _interopRequireDefault$7(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
      var _default$22 = ariaAbstractRoles;
      ariaAbstractRoles$1.default = _default$22;
      var ariaLiteralRoles$1 = {};
      var alertRole$1 = {};
      Object.defineProperty(alertRole$1, "__esModule", {
        value: true
      });
      alertRole$1.default = void 0;
      var alertRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-atomic": "true",
          "aria-live": "assertive"
        },
        relatedConcepts: [{
          concept: {
            name: "alert"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$21 = alertRole;
      alertRole$1.default = _default$21;
      var alertdialogRole$1 = {};
      Object.defineProperty(alertdialogRole$1, "__esModule", {
        value: true
      });
      alertdialogRole$1.default = void 0;
      var alertdialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "alert"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
      };
      var _default$20 = alertdialogRole;
      alertdialogRole$1.default = _default$20;
      var applicationRole$1 = {};
      Object.defineProperty(applicationRole$1, "__esModule", {
        value: true
      });
      applicationRole$1.default = void 0;
      var applicationRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "Device Independence Delivery Unit"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$1$ = applicationRole;
      applicationRole$1.default = _default$1$;
      var articleRole$1 = {};
      Object.defineProperty(articleRole$1, "__esModule", {
        value: true
      });
      articleRole$1.default = void 0;
      var articleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "article"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "document"]]
      };
      var _default$1_ = articleRole;
      articleRole$1.default = _default$1_;
      var bannerRole$1 = {};
      Object.defineProperty(bannerRole$1, "__esModule", {
        value: true
      });
      bannerRole$1.default = void 0;
      var bannerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ["direct descendant of document"],
            name: "header"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1Z = bannerRole;
      bannerRole$1.default = _default$1Z;
      var blockquoteRole$1 = {};
      Object.defineProperty(blockquoteRole$1, "__esModule", {
        value: true
      });
      blockquoteRole$1.default = void 0;
      var blockquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1Y = blockquoteRole;
      blockquoteRole$1.default = _default$1Y;
      var buttonRole$1 = {};
      Object.defineProperty(buttonRole$1, "__esModule", {
        value: true
      });
      buttonRole$1.default = void 0;
      var buttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-pressed": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-pressed"
            }, {
              name: "type",
              value: "checkbox"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "aria-expanded",
              value: "false"
            }],
            name: "summary"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "aria-expanded",
              value: "true"
            }],
            constraints: ["direct descendant of details element with the open attribute defined"],
            name: "summary"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "button"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "image"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "reset"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "type",
              value: "submit"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "button"
          },
          module: "HTML"
        }, {
          concept: {
            name: "trigger"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default$1X = buttonRole;
      buttonRole$1.default = _default$1X;
      var captionRole$1 = {};
      Object.defineProperty(captionRole$1, "__esModule", {
        value: true
      });
      captionRole$1.default = void 0;
      var captionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: ["figure", "grid", "table"],
        requiredContextRole: ["figure", "grid", "table"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1W = captionRole;
      captionRole$1.default = _default$1W;
      var cellRole$1 = {};
      Object.defineProperty(cellRole$1, "__esModule", {
        value: true
      });
      cellRole$1.default = void 0;
      var cellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-colindex": null,
          "aria-colspan": null,
          "aria-rowindex": null,
          "aria-rowspan": null
        },
        relatedConcepts: [{
          concept: {
            constraints: ["descendant of table"],
            name: "td"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1V = cellRole;
      cellRole$1.default = _default$1V;
      var checkboxRole$1 = {};
      Object.defineProperty(checkboxRole$1, "__esModule", {
        value: true
      });
      checkboxRole$1.default = void 0;
      var checkboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "checkbox"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default$1U = checkboxRole;
      checkboxRole$1.default = _default$1U;
      var codeRole$1 = {};
      Object.defineProperty(codeRole$1, "__esModule", {
        value: true
      });
      codeRole$1.default = void 0;
      var codeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1T = codeRole;
      codeRole$1.default = _default$1T;
      var columnheaderRole$1 = {};
      Object.defineProperty(columnheaderRole$1, "__esModule", {
        value: true
      });
      columnheaderRole$1.default = void 0;
      var columnheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-sort": null
        },
        relatedConcepts: [{
          attributes: [{
            name: "scope",
            value: "col"
          }],
          concept: {
            name: "th"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
      };
      var _default$1S = columnheaderRole;
      columnheaderRole$1.default = _default$1S;
      var comboboxRole$1 = {};
      Object.defineProperty(comboboxRole$1, "__esModule", {
        value: true
      });
      comboboxRole$1.default = void 0;
      var comboboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-autocomplete": null,
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-expanded": "false",
          "aria-haspopup": "listbox"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "email"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "search"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "tel"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "text"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "multiple"
            }, {
              constraints: ["undefined"],
              name: "size"
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "multiple"
            }, {
              name: "size",
              value: 1
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-controls": null,
          "aria-expanded": "false"
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default$1R = comboboxRole;
      comboboxRole$1.default = _default$1R;
      var complementaryRole$1 = {};
      Object.defineProperty(complementaryRole$1, "__esModule", {
        value: true
      });
      complementaryRole$1.default = void 0;
      var complementaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "aside"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1Q = complementaryRole;
      complementaryRole$1.default = _default$1Q;
      var contentinfoRole$1 = {};
      Object.defineProperty(contentinfoRole$1, "__esModule", {
        value: true
      });
      contentinfoRole$1.default = void 0;
      var contentinfoRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            constraints: ["direct descendant of document"],
            name: "footer"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1P = contentinfoRole;
      contentinfoRole$1.default = _default$1P;
      var definitionRole$1 = {};
      Object.defineProperty(definitionRole$1, "__esModule", {
        value: true
      });
      definitionRole$1.default = void 0;
      var definitionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dd"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1O = definitionRole;
      definitionRole$1.default = _default$1O;
      var deletionRole$1 = {};
      Object.defineProperty(deletionRole$1, "__esModule", {
        value: true
      });
      deletionRole$1.default = void 0;
      var deletionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1N = deletionRole;
      deletionRole$1.default = _default$1N;
      var dialogRole$1 = {};
      Object.defineProperty(dialogRole$1, "__esModule", {
        value: true
      });
      dialogRole$1.default = void 0;
      var dialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dialog"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "window"]]
      };
      var _default$1M = dialogRole;
      dialogRole$1.default = _default$1M;
      var directoryRole$1 = {};
      Object.defineProperty(directoryRole$1, "__esModule", {
        value: true
      });
      directoryRole$1.default = void 0;
      var directoryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          module: "DAISY Guide"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "list"]]
      };
      var _default$1L = directoryRole;
      directoryRole$1.default = _default$1L;
      var documentRole$1 = {};
      Object.defineProperty(documentRole$1, "__esModule", {
        value: true
      });
      documentRole$1.default = void 0;
      var documentRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "Device Independence Delivery Unit"
          }
        }, {
          concept: {
            name: "body"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$1K = documentRole;
      documentRole$1.default = _default$1K;
      var emphasisRole$1 = {};
      Object.defineProperty(emphasisRole$1, "__esModule", {
        value: true
      });
      emphasisRole$1.default = void 0;
      var emphasisRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1J = emphasisRole;
      emphasisRole$1.default = _default$1J;
      var feedRole$1 = {};
      Object.defineProperty(feedRole$1, "__esModule", {
        value: true
      });
      feedRole$1.default = void 0;
      var feedRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["article"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "list"]]
      };
      var _default$1I = feedRole;
      feedRole$1.default = _default$1I;
      var figureRole$1 = {};
      Object.defineProperty(figureRole$1, "__esModule", {
        value: true
      });
      figureRole$1.default = void 0;
      var figureRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "figure"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1H = figureRole;
      figureRole$1.default = _default$1H;
      var formRole$1 = {};
      Object.defineProperty(formRole$1, "__esModule", {
        value: true
      });
      formRole$1.default = void 0;
      var formRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-label"
            }],
            name: "form"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-labelledby"
            }],
            name: "form"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "name"
            }],
            name: "form"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1G = formRole;
      formRole$1.default = _default$1G;
      var genericRole$1 = {};
      Object.defineProperty(genericRole$1, "__esModule", {
        value: true
      });
      genericRole$1.default = void 0;
      var genericRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "span"
          },
          module: "HTML"
        }, {
          concept: {
            name: "div"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$1F = genericRole;
      genericRole$1.default = _default$1F;
      var gridRole$1 = {};
      Object.defineProperty(gridRole$1, "__esModule", {
        value: true
      });
      gridRole$1.default = void 0;
      var gridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-multiselectable": null,
          "aria-readonly": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "role",
              value: "grid"
            }],
            name: "table"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
      };
      var _default$1E = gridRole;
      gridRole$1.default = _default$1E;
      var gridcellRole$1 = {};
      Object.defineProperty(gridcellRole$1, "__esModule", {
        value: true
      });
      gridcellRole$1.default = void 0;
      var gridcellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-selected": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "role",
              value: "gridcell"
            }],
            name: "td"
          },
          module: "HTML"
        }],
        requireContextRole: ["row"],
        requiredContextRole: ["row"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
      };
      var _default$1D = gridcellRole;
      gridcellRole$1.default = _default$1D;
      var groupRole$1 = {};
      Object.defineProperty(groupRole$1, "__esModule", {
        value: true
      });
      groupRole$1.default = void 0;
      var groupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-disabled": null
        },
        relatedConcepts: [{
          concept: {
            name: "details"
          },
          module: "HTML"
        }, {
          concept: {
            name: "fieldset"
          },
          module: "HTML"
        }, {
          concept: {
            name: "optgroup"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1C = groupRole;
      groupRole$1.default = _default$1C;
      var headingRole$1 = {};
      Object.defineProperty(headingRole$1, "__esModule", {
        value: true
      });
      headingRole$1.default = void 0;
      var headingRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-level": "2"
        },
        relatedConcepts: [{
          concept: {
            name: "h1"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h2"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h3"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h4"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h5"
          },
          module: "HTML"
        }, {
          concept: {
            name: "h6"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-level": "2"
        },
        superClass: [["roletype", "structure", "sectionhead"]]
      };
      var _default$1B = headingRole;
      headingRole$1.default = _default$1B;
      var imgRole$1 = {};
      Object.defineProperty(imgRole$1, "__esModule", {
        value: true
      });
      imgRole$1.default = void 0;
      var imgRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "alt"
            }],
            name: "img"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "alt"
            }],
            name: "img"
          },
          module: "HTML"
        }, {
          concept: {
            name: "imggroup"
          },
          module: "DTB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1A = imgRole;
      imgRole$1.default = _default$1A;
      var insertionRole$1 = {};
      Object.defineProperty(insertionRole$1, "__esModule", {
        value: true
      });
      insertionRole$1.default = void 0;
      var insertionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1z = insertionRole;
      insertionRole$1.default = _default$1z;
      var linkRole$1 = {};
      Object.defineProperty(linkRole$1, "__esModule", {
        value: true
      });
      linkRole$1.default = void 0;
      var linkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "href"
            }],
            name: "a"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "href"
            }],
            name: "area"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "href"
            }],
            name: "link"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default$1y = linkRole;
      linkRole$1.default = _default$1y;
      var listRole$1 = {};
      Object.defineProperty(listRole$1, "__esModule", {
        value: true
      });
      listRole$1.default = void 0;
      var listRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menu"
          },
          module: "HTML"
        }, {
          concept: {
            name: "ol"
          },
          module: "HTML"
        }, {
          concept: {
            name: "ul"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["listitem"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1x = listRole;
      listRole$1.default = _default$1x;
      var listboxRole$1 = {};
      Object.defineProperty(listboxRole$1, "__esModule", {
        value: true
      });
      listboxRole$1.default = void 0;
      var listboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-invalid": null,
          "aria-multiselectable": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-orientation": "vertical"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: [">1"],
              name: "size"
            }, {
              name: "multiple"
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: [">1"],
              name: "size"
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "multiple"
            }],
            name: "select"
          },
          module: "HTML"
        }, {
          concept: {
            name: "datalist"
          },
          module: "HTML"
        }, {
          concept: {
            name: "list"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["option", "group"], ["option"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default$1w = listboxRole;
      listboxRole$1.default = _default$1w;
      var listitemRole$1 = {};
      Object.defineProperty(listitemRole$1, "__esModule", {
        value: true
      });
      listitemRole$1.default = void 0;
      var listitemRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-level": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            constraints: ["direct descendant of ol, ul or menu"],
            name: "li"
          },
          module: "HTML"
        }, {
          concept: {
            name: "item"
          },
          module: "XForms"
        }],
        requireContextRole: ["directory", "list"],
        requiredContextRole: ["directory", "list"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1v = listitemRole;
      listitemRole$1.default = _default$1v;
      var logRole$1 = {};
      Object.defineProperty(logRole$1, "__esModule", {
        value: true
      });
      logRole$1.default = void 0;
      var logRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-live": "polite"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1u = logRole;
      logRole$1.default = _default$1u;
      var mainRole$1 = {};
      Object.defineProperty(mainRole$1, "__esModule", {
        value: true
      });
      mainRole$1.default = void 0;
      var mainRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "main"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1t = mainRole;
      mainRole$1.default = _default$1t;
      var marqueeRole$1 = {};
      Object.defineProperty(marqueeRole$1, "__esModule", {
        value: true
      });
      marqueeRole$1.default = void 0;
      var marqueeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1s = marqueeRole;
      marqueeRole$1.default = _default$1s;
      var mathRole$1 = {};
      Object.defineProperty(mathRole$1, "__esModule", {
        value: true
      });
      mathRole$1.default = void 0;
      var mathRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "math"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1r = mathRole;
      mathRole$1.default = _default$1r;
      var menuRole$1 = {};
      Object.defineProperty(menuRole$1, "__esModule", {
        value: true
      });
      menuRole$1.default = void 0;
      var menuRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "vertical"
        },
        relatedConcepts: [{
          concept: {
            name: "MENU"
          },
          module: "JAPI"
        }, {
          concept: {
            name: "list"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "select"
          },
          module: "XForms"
        }, {
          concept: {
            name: "sidebar"
          },
          module: "DTB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default$1q = menuRole;
      menuRole$1.default = _default$1q;
      var menubarRole$1 = {};
      Object.defineProperty(menubarRole$1, "__esModule", {
        value: true
      });
      menubarRole$1.default = void 0;
      var menubarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          concept: {
            name: "toolbar"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
      };
      var _default$1p = menubarRole;
      menubarRole$1.default = _default$1p;
      var menuitemRole$1 = {};
      Object.defineProperty(menuitemRole$1, "__esModule", {
        value: true
      });
      menuitemRole$1.default = void 0;
      var menuitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "MENU_ITEM"
          },
          module: "JAPI"
        }, {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "menuitem"
          },
          module: "HTML"
        }, {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command"]]
      };
      var _default$1o = menuitemRole;
      menuitemRole$1.default = _default$1o;
      var menuitemcheckboxRole$1 = {};
      Object.defineProperty(menuitemcheckboxRole$1, "__esModule", {
        value: true
      });
      menuitemcheckboxRole$1.default = void 0;
      var menuitemcheckboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
      };
      var _default$1n = menuitemcheckboxRole;
      menuitemcheckboxRole$1.default = _default$1n;
      var menuitemradioRole$1 = {};
      Object.defineProperty(menuitemradioRole$1, "__esModule", {
        value: true
      });
      menuitemradioRole$1.default = void 0;
      var menuitemradioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }],
        requireContextRole: ["group", "menu", "menubar"],
        requiredContextRole: ["group", "menu", "menubar"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
      };
      var _default$1m = menuitemradioRole;
      menuitemradioRole$1.default = _default$1m;
      var meterRole$1 = {};
      Object.defineProperty(meterRole$1, "__esModule", {
        value: true
      });
      meterRole$1.default = void 0;
      var meterRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuetext": null,
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-valuenow": null
        },
        superClass: [["roletype", "structure", "range"]]
      };
      var _default$1l = meterRole;
      meterRole$1.default = _default$1l;
      var navigationRole$1 = {};
      Object.defineProperty(navigationRole$1, "__esModule", {
        value: true
      });
      navigationRole$1.default = void 0;
      var navigationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "nav"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1k = navigationRole;
      navigationRole$1.default = _default$1k;
      var noneRole$1 = {};
      Object.defineProperty(noneRole$1, "__esModule", {
        value: true
      });
      noneRole$1.default = void 0;
      var noneRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
      };
      var _default$1j = noneRole;
      noneRole$1.default = _default$1j;
      var noteRole$1 = {};
      Object.defineProperty(noteRole$1, "__esModule", {
        value: true
      });
      noteRole$1.default = void 0;
      var noteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1i = noteRole;
      noteRole$1.default = _default$1i;
      var optionRole$1 = {};
      Object.defineProperty(optionRole$1, "__esModule", {
        value: true
      });
      optionRole$1.default = void 0;
      var optionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-posinset": null,
          "aria-setsize": null,
          "aria-selected": "false"
        },
        relatedConcepts: [{
          concept: {
            name: "item"
          },
          module: "XForms"
        }, {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        }, {
          concept: {
            name: "option"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-selected": "false"
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default$1h = optionRole;
      optionRole$1.default = _default$1h;
      var paragraphRole$1 = {};
      Object.defineProperty(paragraphRole$1, "__esModule", {
        value: true
      });
      paragraphRole$1.default = void 0;
      var paragraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$1g = paragraphRole;
      paragraphRole$1.default = _default$1g;
      var presentationRole$1 = {};
      Object.defineProperty(presentationRole$1, "__esModule", {
        value: true
      });
      presentationRole$1.default = void 0;
      var presentationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$1f = presentationRole;
      presentationRole$1.default = _default$1f;
      var progressbarRole$1 = {};
      Object.defineProperty(progressbarRole$1, "__esModule", {
        value: true
      });
      progressbarRole$1.default = void 0;
      var progressbarRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-valuetext": null
        },
        relatedConcepts: [{
          concept: {
            name: "progress"
          },
          module: "HTML"
        }, {
          concept: {
            name: "status"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
      };
      var _default$1e = progressbarRole;
      progressbarRole$1.default = _default$1e;
      var radioRole$1 = {};
      Object.defineProperty(radioRole$1, "__esModule", {
        value: true
      });
      radioRole$1.default = void 0;
      var radioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-checked": null,
          "aria-posinset": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "radio"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input"]]
      };
      var _default$1d = radioRole;
      radioRole$1.default = _default$1d;
      var radiogroupRole$1 = {};
      Object.defineProperty(radiogroupRole$1, "__esModule", {
        value: true
      });
      radiogroupRole$1.default = void 0;
      var radiogroupRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            name: "list"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["radio"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default$1c = radiogroupRole;
      radiogroupRole$1.default = _default$1c;
      var regionRole$1 = {};
      Object.defineProperty(regionRole$1, "__esModule", {
        value: true
      });
      regionRole$1.default = void 0;
      var regionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-label"
            }],
            name: "section"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["set"],
              name: "aria-labelledby"
            }],
            name: "section"
          },
          module: "HTML"
        }, {
          concept: {
            name: "Device Independence Glossart perceivable unit"
          }
        }, {
          concept: {
            name: "frame"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$1b = regionRole;
      regionRole$1.default = _default$1b;
      var rowRole$1 = {};
      Object.defineProperty(rowRole$1, "__esModule", {
        value: true
      });
      rowRole$1.default = void 0;
      var rowRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-colindex": null,
          "aria-expanded": null,
          "aria-level": null,
          "aria-posinset": null,
          "aria-rowindex": null,
          "aria-selected": null,
          "aria-setsize": null
        },
        relatedConcepts: [{
          concept: {
            name: "tr"
          },
          module: "HTML"
        }],
        requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
        requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
        requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
      };
      var _default$1a = rowRole;
      rowRole$1.default = _default$1a;
      var rowgroupRole$1 = {};
      Object.defineProperty(rowgroupRole$1, "__esModule", {
        value: true
      });
      rowgroupRole$1.default = void 0;
      var rowgroupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "tbody"
          },
          module: "HTML"
        }, {
          concept: {
            name: "tfoot"
          },
          module: "HTML"
        }, {
          concept: {
            name: "thead"
          },
          module: "HTML"
        }],
        requireContextRole: ["grid", "table", "treegrid"],
        requiredContextRole: ["grid", "table", "treegrid"],
        requiredOwnedElements: [["row"]],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$19 = rowgroupRole;
      rowgroupRole$1.default = _default$19;
      var rowheaderRole$1 = {};
      Object.defineProperty(rowheaderRole$1, "__esModule", {
        value: true
      });
      rowheaderRole$1.default = void 0;
      var rowheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-sort": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "scope",
              value: "row"
            }],
            name: "th"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              name: "scope",
              value: "rowgroup"
            }],
            name: "th"
          },
          module: "HTML"
        }],
        requireContextRole: ["row", "rowgroup"],
        requiredContextRole: ["row", "rowgroup"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
      };
      var _default$18 = rowheaderRole;
      rowheaderRole$1.default = _default$18;
      var scrollbarRole$1 = {};
      Object.defineProperty(scrollbarRole$1, "__esModule", {
        value: true
      });
      scrollbarRole$1.default = void 0;
      var scrollbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-valuetext": null,
          "aria-orientation": "vertical",
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-controls": null,
          "aria-valuenow": null
        },
        superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
      };
      var _default$17 = scrollbarRole;
      scrollbarRole$1.default = _default$17;
      var searchRole$1 = {};
      Object.defineProperty(searchRole$1, "__esModule", {
        value: true
      });
      searchRole$1.default = void 0;
      var searchRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$16 = searchRole;
      searchRole$1.default = _default$16;
      var searchboxRole$1 = {};
      Object.defineProperty(searchboxRole$1, "__esModule", {
        value: true
      });
      searchboxRole$1.default = void 0;
      var searchboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "search"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "input", "textbox"]]
      };
      var _default$15 = searchboxRole;
      searchboxRole$1.default = _default$15;
      var separatorRole$1 = {};
      Object.defineProperty(separatorRole$1, "__esModule", {
        value: true
      });
      separatorRole$1.default = void 0;
      var separatorRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-orientation": "horizontal",
          "aria-valuemax": "100",
          "aria-valuemin": "0",
          "aria-valuenow": null,
          "aria-valuetext": null
        },
        relatedConcepts: [{
          concept: {
            name: "hr"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure"]]
      };
      var _default$14 = separatorRole;
      separatorRole$1.default = _default$14;
      var sliderRole$1 = {};
      Object.defineProperty(sliderRole$1, "__esModule", {
        value: true
      });
      sliderRole$1.default = void 0;
      var sliderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-valuetext": null,
          "aria-orientation": "horizontal",
          "aria-valuemax": "100",
          "aria-valuemin": "0"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "range"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-valuenow": null
        },
        superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
      };
      var _default$13 = sliderRole;
      sliderRole$1.default = _default$13;
      var spinbuttonRole$1 = {};
      Object.defineProperty(spinbuttonRole$1, "__esModule", {
        value: true
      });
      spinbuttonRole$1.default = void 0;
      var spinbuttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-readonly": null,
          "aria-required": null,
          "aria-valuetext": null,
          "aria-valuenow": "0"
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              name: "type",
              value: "number"
            }],
            name: "input"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
      };
      var _default$12 = spinbuttonRole;
      spinbuttonRole$1.default = _default$12;
      var statusRole$1 = {};
      Object.defineProperty(statusRole$1, "__esModule", {
        value: true
      });
      statusRole$1.default = void 0;
      var statusRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-atomic": "true",
          "aria-live": "polite"
        },
        relatedConcepts: [{
          concept: {
            name: "output"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$11 = statusRole;
      statusRole$1.default = _default$11;
      var strongRole$1 = {};
      Object.defineProperty(strongRole$1, "__esModule", {
        value: true
      });
      strongRole$1.default = void 0;
      var strongRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$10 = strongRole;
      strongRole$1.default = _default$10;
      var subscriptRole$1 = {};
      Object.defineProperty(subscriptRole$1, "__esModule", {
        value: true
      });
      subscriptRole$1.default = void 0;
      var subscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$$ = subscriptRole;
      subscriptRole$1.default = _default$$;
      var superscriptRole$1 = {};
      Object.defineProperty(superscriptRole$1, "__esModule", {
        value: true
      });
      superscriptRole$1.default = void 0;
      var superscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["prohibited"],
        prohibitedProps: ["aria-label", "aria-labelledby"],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$_ = superscriptRole;
      superscriptRole$1.default = _default$_;
      var switchRole$1 = {};
      Object.defineProperty(switchRole$1, "__esModule", {
        value: true
      });
      switchRole$1.default = void 0;
      var switchRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "button"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-checked": null
        },
        superClass: [["roletype", "widget", "input", "checkbox"]]
      };
      var _default$Z = switchRole;
      switchRole$1.default = _default$Z;
      var tabRole$1 = {};
      Object.defineProperty(tabRole$1, "__esModule", {
        value: true
      });
      tabRole$1.default = void 0;
      var tabRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-posinset": null,
          "aria-setsize": null,
          "aria-selected": "false"
        },
        relatedConcepts: [],
        requireContextRole: ["tablist"],
        requiredContextRole: ["tablist"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
      };
      var _default$Y = tabRole;
      tabRole$1.default = _default$Y;
      var tableRole$1 = {};
      Object.defineProperty(tableRole$1, "__esModule", {
        value: true
      });
      tableRole$1.default = void 0;
      var tableRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-colcount": null,
          "aria-rowcount": null
        },
        relatedConcepts: [{
          concept: {
            name: "table"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$X = tableRole;
      tableRole$1.default = _default$X;
      var tablistRole$1 = {};
      Object.defineProperty(tablistRole$1, "__esModule", {
        value: true
      });
      tablistRole$1.default = void 0;
      var tablistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-level": null,
          "aria-multiselectable": null,
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          module: "DAISY",
          concept: {
            name: "guide"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["tab"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite"]]
      };
      var _default$W = tablistRole;
      tablistRole$1.default = _default$W;
      var tabpanelRole$1 = {};
      Object.defineProperty(tabpanelRole$1, "__esModule", {
        value: true
      });
      tabpanelRole$1.default = void 0;
      var tabpanelRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$V = tabpanelRole;
      tabpanelRole$1.default = _default$V;
      var termRole$1 = {};
      Object.defineProperty(termRole$1, "__esModule", {
        value: true
      });
      termRole$1.default = void 0;
      var termRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "dfn"
          },
          module: "HTML"
        }, {
          concept: {
            name: "dt"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$U = termRole;
      termRole$1.default = _default$U;
      var textboxRole$1 = {};
      Object.defineProperty(textboxRole$1, "__esModule", {
        value: true
      });
      textboxRole$1.default = void 0;
      var textboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-activedescendant": null,
          "aria-autocomplete": null,
          "aria-errormessage": null,
          "aria-haspopup": null,
          "aria-invalid": null,
          "aria-multiline": null,
          "aria-placeholder": null,
          "aria-readonly": null,
          "aria-required": null
        },
        relatedConcepts: [{
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "type"
            }, {
              constraints: ["undefined"],
              name: "list"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "email"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "tel"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "text"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            attributes: [{
              constraints: ["undefined"],
              name: "list"
            }, {
              name: "type",
              value: "url"
            }],
            name: "input"
          },
          module: "HTML"
        }, {
          concept: {
            name: "input"
          },
          module: "XForms"
        }, {
          concept: {
            name: "textarea"
          },
          module: "HTML"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "input"]]
      };
      var _default$T = textboxRole;
      textboxRole$1.default = _default$T;
      var timeRole$1 = {};
      Object.defineProperty(timeRole$1, "__esModule", {
        value: true
      });
      timeRole$1.default = void 0;
      var timeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$S = timeRole;
      timeRole$1.default = _default$S;
      var timerRole$1 = {};
      Object.defineProperty(timerRole$1, "__esModule", {
        value: true
      });
      timerRole$1.default = void 0;
      var timerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "status"]]
      };
      var _default$R = timerRole;
      timerRole$1.default = _default$R;
      var toolbarRole$1 = {};
      Object.defineProperty(toolbarRole$1, "__esModule", {
        value: true
      });
      toolbarRole$1.default = void 0;
      var toolbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-orientation": "horizontal"
        },
        relatedConcepts: [{
          concept: {
            name: "menubar"
          },
          module: "ARIA"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"]]
      };
      var _default$Q = toolbarRole;
      toolbarRole$1.default = _default$Q;
      var tooltipRole$1 = {};
      Object.defineProperty(tooltipRole$1, "__esModule", {
        value: true
      });
      tooltipRole$1.default = void 0;
      var tooltipRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$P = tooltipRole;
      tooltipRole$1.default = _default$P;
      var treeRole$1 = {};
      Object.defineProperty(treeRole$1, "__esModule", {
        value: true
      });
      treeRole$1.default = void 0;
      var treeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null,
          "aria-multiselectable": null,
          "aria-required": null,
          "aria-orientation": "vertical"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
      };
      var _default$O = treeRole;
      treeRole$1.default = _default$O;
      var treegridRole$1 = {};
      Object.defineProperty(treegridRole$1, "__esModule", {
        value: true
      });
      treegridRole$1.default = void 0;
      var treegridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["row"], ["row", "rowgroup"]],
        requiredProps: {},
        superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
      };
      var _default$N = treegridRole;
      treegridRole$1.default = _default$N;
      var treeitemRole$1 = {};
      Object.defineProperty(treeitemRole$1, "__esModule", {
        value: true
      });
      treeitemRole$1.default = void 0;
      var treeitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-expanded": null,
          "aria-haspopup": null
        },
        relatedConcepts: [],
        requireContextRole: ["group", "tree"],
        requiredContextRole: ["group", "tree"],
        requiredOwnedElements: [],
        requiredProps: {
          "aria-selected": null
        },
        superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
      };
      var _default$M = treeitemRole;
      treeitemRole$1.default = _default$M;
      Object.defineProperty(ariaLiteralRoles$1, "__esModule", {
        value: true
      });
      ariaLiteralRoles$1.default = void 0;
      var _alertRole = _interopRequireDefault$6(alertRole$1);
      var _alertdialogRole = _interopRequireDefault$6(alertdialogRole$1);
      var _applicationRole = _interopRequireDefault$6(applicationRole$1);
      var _articleRole = _interopRequireDefault$6(articleRole$1);
      var _bannerRole = _interopRequireDefault$6(bannerRole$1);
      var _blockquoteRole = _interopRequireDefault$6(blockquoteRole$1);
      var _buttonRole = _interopRequireDefault$6(buttonRole$1);
      var _captionRole = _interopRequireDefault$6(captionRole$1);
      var _cellRole = _interopRequireDefault$6(cellRole$1);
      var _checkboxRole = _interopRequireDefault$6(checkboxRole$1);
      var _codeRole = _interopRequireDefault$6(codeRole$1);
      var _columnheaderRole = _interopRequireDefault$6(columnheaderRole$1);
      var _comboboxRole = _interopRequireDefault$6(comboboxRole$1);
      var _complementaryRole = _interopRequireDefault$6(complementaryRole$1);
      var _contentinfoRole = _interopRequireDefault$6(contentinfoRole$1);
      var _definitionRole = _interopRequireDefault$6(definitionRole$1);
      var _deletionRole = _interopRequireDefault$6(deletionRole$1);
      var _dialogRole = _interopRequireDefault$6(dialogRole$1);
      var _directoryRole = _interopRequireDefault$6(directoryRole$1);
      var _documentRole = _interopRequireDefault$6(documentRole$1);
      var _emphasisRole = _interopRequireDefault$6(emphasisRole$1);
      var _feedRole = _interopRequireDefault$6(feedRole$1);
      var _figureRole = _interopRequireDefault$6(figureRole$1);
      var _formRole = _interopRequireDefault$6(formRole$1);
      var _genericRole = _interopRequireDefault$6(genericRole$1);
      var _gridRole = _interopRequireDefault$6(gridRole$1);
      var _gridcellRole = _interopRequireDefault$6(gridcellRole$1);
      var _groupRole = _interopRequireDefault$6(groupRole$1);
      var _headingRole = _interopRequireDefault$6(headingRole$1);
      var _imgRole = _interopRequireDefault$6(imgRole$1);
      var _insertionRole = _interopRequireDefault$6(insertionRole$1);
      var _linkRole = _interopRequireDefault$6(linkRole$1);
      var _listRole = _interopRequireDefault$6(listRole$1);
      var _listboxRole = _interopRequireDefault$6(listboxRole$1);
      var _listitemRole = _interopRequireDefault$6(listitemRole$1);
      var _logRole = _interopRequireDefault$6(logRole$1);
      var _mainRole = _interopRequireDefault$6(mainRole$1);
      var _marqueeRole = _interopRequireDefault$6(marqueeRole$1);
      var _mathRole = _interopRequireDefault$6(mathRole$1);
      var _menuRole = _interopRequireDefault$6(menuRole$1);
      var _menubarRole = _interopRequireDefault$6(menubarRole$1);
      var _menuitemRole = _interopRequireDefault$6(menuitemRole$1);
      var _menuitemcheckboxRole = _interopRequireDefault$6(menuitemcheckboxRole$1);
      var _menuitemradioRole = _interopRequireDefault$6(menuitemradioRole$1);
      var _meterRole = _interopRequireDefault$6(meterRole$1);
      var _navigationRole = _interopRequireDefault$6(navigationRole$1);
      var _noneRole = _interopRequireDefault$6(noneRole$1);
      var _noteRole = _interopRequireDefault$6(noteRole$1);
      var _optionRole = _interopRequireDefault$6(optionRole$1);
      var _paragraphRole = _interopRequireDefault$6(paragraphRole$1);
      var _presentationRole = _interopRequireDefault$6(presentationRole$1);
      var _progressbarRole = _interopRequireDefault$6(progressbarRole$1);
      var _radioRole = _interopRequireDefault$6(radioRole$1);
      var _radiogroupRole = _interopRequireDefault$6(radiogroupRole$1);
      var _regionRole = _interopRequireDefault$6(regionRole$1);
      var _rowRole = _interopRequireDefault$6(rowRole$1);
      var _rowgroupRole = _interopRequireDefault$6(rowgroupRole$1);
      var _rowheaderRole = _interopRequireDefault$6(rowheaderRole$1);
      var _scrollbarRole = _interopRequireDefault$6(scrollbarRole$1);
      var _searchRole = _interopRequireDefault$6(searchRole$1);
      var _searchboxRole = _interopRequireDefault$6(searchboxRole$1);
      var _separatorRole = _interopRequireDefault$6(separatorRole$1);
      var _sliderRole = _interopRequireDefault$6(sliderRole$1);
      var _spinbuttonRole = _interopRequireDefault$6(spinbuttonRole$1);
      var _statusRole = _interopRequireDefault$6(statusRole$1);
      var _strongRole = _interopRequireDefault$6(strongRole$1);
      var _subscriptRole = _interopRequireDefault$6(subscriptRole$1);
      var _superscriptRole = _interopRequireDefault$6(superscriptRole$1);
      var _switchRole = _interopRequireDefault$6(switchRole$1);
      var _tabRole = _interopRequireDefault$6(tabRole$1);
      var _tableRole = _interopRequireDefault$6(tableRole$1);
      var _tablistRole = _interopRequireDefault$6(tablistRole$1);
      var _tabpanelRole = _interopRequireDefault$6(tabpanelRole$1);
      var _termRole = _interopRequireDefault$6(termRole$1);
      var _textboxRole = _interopRequireDefault$6(textboxRole$1);
      var _timeRole = _interopRequireDefault$6(timeRole$1);
      var _timerRole = _interopRequireDefault$6(timerRole$1);
      var _toolbarRole = _interopRequireDefault$6(toolbarRole$1);
      var _tooltipRole = _interopRequireDefault$6(tooltipRole$1);
      var _treeRole = _interopRequireDefault$6(treeRole$1);
      var _treegridRole = _interopRequireDefault$6(treegridRole$1);
      var _treeitemRole = _interopRequireDefault$6(treeitemRole$1);
      function _interopRequireDefault$6(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
      var _default$L = ariaLiteralRoles;
      ariaLiteralRoles$1.default = _default$L;
      var ariaDpubRoles$1 = {};
      var docAbstractRole$1 = {};
      Object.defineProperty(docAbstractRole$1, "__esModule", {
        value: true
      });
      docAbstractRole$1.default = void 0;
      var docAbstractRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "abstract [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$K = docAbstractRole;
      docAbstractRole$1.default = _default$K;
      var docAcknowledgmentsRole$1 = {};
      Object.defineProperty(docAcknowledgmentsRole$1, "__esModule", {
        value: true
      });
      docAcknowledgmentsRole$1.default = void 0;
      var docAcknowledgmentsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "acknowledgments [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$J = docAcknowledgmentsRole;
      docAcknowledgmentsRole$1.default = _default$J;
      var docAfterwordRole$1 = {};
      Object.defineProperty(docAfterwordRole$1, "__esModule", {
        value: true
      });
      docAfterwordRole$1.default = void 0;
      var docAfterwordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "afterword [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$I = docAfterwordRole;
      docAfterwordRole$1.default = _default$I;
      var docAppendixRole$1 = {};
      Object.defineProperty(docAppendixRole$1, "__esModule", {
        value: true
      });
      docAppendixRole$1.default = void 0;
      var docAppendixRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "appendix [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$H = docAppendixRole;
      docAppendixRole$1.default = _default$H;
      var docBacklinkRole$1 = {};
      Object.defineProperty(docBacklinkRole$1, "__esModule", {
        value: true
      });
      docBacklinkRole$1.default = void 0;
      var docBacklinkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "content"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "referrer [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default$G = docBacklinkRole;
      docBacklinkRole$1.default = _default$G;
      var docBiblioentryRole$1 = {};
      Object.defineProperty(docBiblioentryRole$1, "__esModule", {
        value: true
      });
      docBiblioentryRole$1.default = void 0;
      var docBiblioentryRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "EPUB biblioentry [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: ["doc-bibliography"],
        requiredContextRole: ["doc-bibliography"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "listitem"]]
      };
      var _default$F = docBiblioentryRole;
      docBiblioentryRole$1.default = _default$F;
      var docBibliographyRole$1 = {};
      Object.defineProperty(docBibliographyRole$1, "__esModule", {
        value: true
      });
      docBibliographyRole$1.default = void 0;
      var docBibliographyRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "bibliography [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["doc-biblioentry"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$E = docBibliographyRole;
      docBibliographyRole$1.default = _default$E;
      var docBibliorefRole$1 = {};
      Object.defineProperty(docBibliorefRole$1, "__esModule", {
        value: true
      });
      docBibliorefRole$1.default = void 0;
      var docBibliorefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "biblioref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default$D = docBibliorefRole;
      docBibliorefRole$1.default = _default$D;
      var docChapterRole$1 = {};
      Object.defineProperty(docChapterRole$1, "__esModule", {
        value: true
      });
      docChapterRole$1.default = void 0;
      var docChapterRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "chapter [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$C = docChapterRole;
      docChapterRole$1.default = _default$C;
      var docColophonRole$1 = {};
      Object.defineProperty(docColophonRole$1, "__esModule", {
        value: true
      });
      docColophonRole$1.default = void 0;
      var docColophonRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "colophon [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$B = docColophonRole;
      docColophonRole$1.default = _default$B;
      var docConclusionRole$1 = {};
      Object.defineProperty(docConclusionRole$1, "__esModule", {
        value: true
      });
      docConclusionRole$1.default = void 0;
      var docConclusionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "conclusion [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$A = docConclusionRole;
      docConclusionRole$1.default = _default$A;
      var docCoverRole$1 = {};
      Object.defineProperty(docCoverRole$1, "__esModule", {
        value: true
      });
      docCoverRole$1.default = void 0;
      var docCoverRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "cover [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "img"]]
      };
      var _default$z = docCoverRole;
      docCoverRole$1.default = _default$z;
      var docCreditRole$1 = {};
      Object.defineProperty(docCreditRole$1, "__esModule", {
        value: true
      });
      docCreditRole$1.default = void 0;
      var docCreditRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "credit [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$y = docCreditRole;
      docCreditRole$1.default = _default$y;
      var docCreditsRole$1 = {};
      Object.defineProperty(docCreditsRole$1, "__esModule", {
        value: true
      });
      docCreditsRole$1.default = void 0;
      var docCreditsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "credits [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$x = docCreditsRole;
      docCreditsRole$1.default = _default$x;
      var docDedicationRole$1 = {};
      Object.defineProperty(docDedicationRole$1, "__esModule", {
        value: true
      });
      docDedicationRole$1.default = void 0;
      var docDedicationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "dedication [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$w = docDedicationRole;
      docDedicationRole$1.default = _default$w;
      var docEndnoteRole$1 = {};
      Object.defineProperty(docEndnoteRole$1, "__esModule", {
        value: true
      });
      docEndnoteRole$1.default = void 0;
      var docEndnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "rearnote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: ["doc-endnotes"],
        requiredContextRole: ["doc-endnotes"],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "listitem"]]
      };
      var _default$v = docEndnoteRole;
      docEndnoteRole$1.default = _default$v;
      var docEndnotesRole$1 = {};
      Object.defineProperty(docEndnotesRole$1, "__esModule", {
        value: true
      });
      docEndnotesRole$1.default = void 0;
      var docEndnotesRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "rearnotes [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["doc-endnote"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$u = docEndnotesRole;
      docEndnotesRole$1.default = _default$u;
      var docEpigraphRole$1 = {};
      Object.defineProperty(docEpigraphRole$1, "__esModule", {
        value: true
      });
      docEpigraphRole$1.default = void 0;
      var docEpigraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "epigraph [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$t = docEpigraphRole;
      docEpigraphRole$1.default = _default$t;
      var docEpilogueRole$1 = {};
      Object.defineProperty(docEpilogueRole$1, "__esModule", {
        value: true
      });
      docEpilogueRole$1.default = void 0;
      var docEpilogueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "epilogue [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$s = docEpilogueRole;
      docEpilogueRole$1.default = _default$s;
      var docErrataRole$1 = {};
      Object.defineProperty(docErrataRole$1, "__esModule", {
        value: true
      });
      docErrataRole$1.default = void 0;
      var docErrataRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "errata [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$r = docErrataRole;
      docErrataRole$1.default = _default$r;
      var docExampleRole$1 = {};
      Object.defineProperty(docExampleRole$1, "__esModule", {
        value: true
      });
      docExampleRole$1.default = void 0;
      var docExampleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$q = docExampleRole;
      docExampleRole$1.default = _default$q;
      var docFootnoteRole$1 = {};
      Object.defineProperty(docFootnoteRole$1, "__esModule", {
        value: true
      });
      docFootnoteRole$1.default = void 0;
      var docFootnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "footnote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$p = docFootnoteRole;
      docFootnoteRole$1.default = _default$p;
      var docForewordRole$1 = {};
      Object.defineProperty(docForewordRole$1, "__esModule", {
        value: true
      });
      docForewordRole$1.default = void 0;
      var docForewordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "foreword [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$o = docForewordRole;
      docForewordRole$1.default = _default$o;
      var docGlossaryRole$1 = {};
      Object.defineProperty(docGlossaryRole$1, "__esModule", {
        value: true
      });
      docGlossaryRole$1.default = void 0;
      var docGlossaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "glossary [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [["definition"], ["term"]],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$n = docGlossaryRole;
      docGlossaryRole$1.default = _default$n;
      var docGlossrefRole$1 = {};
      Object.defineProperty(docGlossrefRole$1, "__esModule", {
        value: true
      });
      docGlossrefRole$1.default = void 0;
      var docGlossrefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "glossref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default$m = docGlossrefRole;
      docGlossrefRole$1.default = _default$m;
      var docIndexRole$1 = {};
      Object.defineProperty(docIndexRole$1, "__esModule", {
        value: true
      });
      docIndexRole$1.default = void 0;
      var docIndexRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "index [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default$l = docIndexRole;
      docIndexRole$1.default = _default$l;
      var docIntroductionRole$1 = {};
      Object.defineProperty(docIntroductionRole$1, "__esModule", {
        value: true
      });
      docIntroductionRole$1.default = void 0;
      var docIntroductionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "introduction [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$k = docIntroductionRole;
      docIntroductionRole$1.default = _default$k;
      var docNoterefRole$1 = {};
      Object.defineProperty(docNoterefRole$1, "__esModule", {
        value: true
      });
      docNoterefRole$1.default = void 0;
      var docNoterefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "noteref [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "widget", "command", "link"]]
      };
      var _default$j = docNoterefRole;
      docNoterefRole$1.default = _default$j;
      var docNoticeRole$1 = {};
      Object.defineProperty(docNoticeRole$1, "__esModule", {
        value: true
      });
      docNoticeRole$1.default = void 0;
      var docNoticeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "notice [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "note"]]
      };
      var _default$i = docNoticeRole;
      docNoticeRole$1.default = _default$i;
      var docPagebreakRole$1 = {};
      Object.defineProperty(docPagebreakRole$1, "__esModule", {
        value: true
      });
      docPagebreakRole$1.default = void 0;
      var docPagebreakRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "pagebreak [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "separator"]]
      };
      var _default$h = docPagebreakRole;
      docPagebreakRole$1.default = _default$h;
      var docPagelistRole$1 = {};
      Object.defineProperty(docPagelistRole$1, "__esModule", {
        value: true
      });
      docPagelistRole$1.default = void 0;
      var docPagelistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "page-list [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default$g = docPagelistRole;
      docPagelistRole$1.default = _default$g;
      var docPartRole$1 = {};
      Object.defineProperty(docPartRole$1, "__esModule", {
        value: true
      });
      docPartRole$1.default = void 0;
      var docPartRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "part [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$f = docPartRole;
      docPartRole$1.default = _default$f;
      var docPrefaceRole$1 = {};
      Object.defineProperty(docPrefaceRole$1, "__esModule", {
        value: true
      });
      docPrefaceRole$1.default = void 0;
      var docPrefaceRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "preface [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$e = docPrefaceRole;
      docPrefaceRole$1.default = _default$e;
      var docPrologueRole$1 = {};
      Object.defineProperty(docPrologueRole$1, "__esModule", {
        value: true
      });
      docPrologueRole$1.default = void 0;
      var docPrologueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "prologue [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark"]]
      };
      var _default$d = docPrologueRole;
      docPrologueRole$1.default = _default$d;
      var docPullquoteRole$1 = {};
      Object.defineProperty(docPullquoteRole$1, "__esModule", {
        value: true
      });
      docPullquoteRole$1.default = void 0;
      var docPullquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [{
          concept: {
            name: "pullquote [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["none"]]
      };
      var _default$c = docPullquoteRole;
      docPullquoteRole$1.default = _default$c;
      var docQnaRole$1 = {};
      Object.defineProperty(docQnaRole$1, "__esModule", {
        value: true
      });
      docQnaRole$1.default = void 0;
      var docQnaRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "qna [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section"]]
      };
      var _default$b = docQnaRole;
      docQnaRole$1.default = _default$b;
      var docSubtitleRole$1 = {};
      Object.defineProperty(docSubtitleRole$1, "__esModule", {
        value: true
      });
      docSubtitleRole$1.default = void 0;
      var docSubtitleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "subtitle [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "sectionhead"]]
      };
      var _default$a = docSubtitleRole;
      docSubtitleRole$1.default = _default$a;
      var docTipRole$1 = {};
      Object.defineProperty(docTipRole$1, "__esModule", {
        value: true
      });
      docTipRole$1.default = void 0;
      var docTipRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "help [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "note"]]
      };
      var _default$9 = docTipRole;
      docTipRole$1.default = _default$9;
      var docTocRole$1 = {};
      Object.defineProperty(docTocRole$1, "__esModule", {
        value: true
      });
      docTocRole$1.default = void 0;
      var docTocRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          concept: {
            name: "toc [EPUB-SSV]"
          },
          module: "EPUB"
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
      };
      var _default$8 = docTocRole;
      docTocRole$1.default = _default$8;
      Object.defineProperty(ariaDpubRoles$1, "__esModule", {
        value: true
      });
      ariaDpubRoles$1.default = void 0;
      var _docAbstractRole = _interopRequireDefault$5(docAbstractRole$1);
      var _docAcknowledgmentsRole = _interopRequireDefault$5(docAcknowledgmentsRole$1);
      var _docAfterwordRole = _interopRequireDefault$5(docAfterwordRole$1);
      var _docAppendixRole = _interopRequireDefault$5(docAppendixRole$1);
      var _docBacklinkRole = _interopRequireDefault$5(docBacklinkRole$1);
      var _docBiblioentryRole = _interopRequireDefault$5(docBiblioentryRole$1);
      var _docBibliographyRole = _interopRequireDefault$5(docBibliographyRole$1);
      var _docBibliorefRole = _interopRequireDefault$5(docBibliorefRole$1);
      var _docChapterRole = _interopRequireDefault$5(docChapterRole$1);
      var _docColophonRole = _interopRequireDefault$5(docColophonRole$1);
      var _docConclusionRole = _interopRequireDefault$5(docConclusionRole$1);
      var _docCoverRole = _interopRequireDefault$5(docCoverRole$1);
      var _docCreditRole = _interopRequireDefault$5(docCreditRole$1);
      var _docCreditsRole = _interopRequireDefault$5(docCreditsRole$1);
      var _docDedicationRole = _interopRequireDefault$5(docDedicationRole$1);
      var _docEndnoteRole = _interopRequireDefault$5(docEndnoteRole$1);
      var _docEndnotesRole = _interopRequireDefault$5(docEndnotesRole$1);
      var _docEpigraphRole = _interopRequireDefault$5(docEpigraphRole$1);
      var _docEpilogueRole = _interopRequireDefault$5(docEpilogueRole$1);
      var _docErrataRole = _interopRequireDefault$5(docErrataRole$1);
      var _docExampleRole = _interopRequireDefault$5(docExampleRole$1);
      var _docFootnoteRole = _interopRequireDefault$5(docFootnoteRole$1);
      var _docForewordRole = _interopRequireDefault$5(docForewordRole$1);
      var _docGlossaryRole = _interopRequireDefault$5(docGlossaryRole$1);
      var _docGlossrefRole = _interopRequireDefault$5(docGlossrefRole$1);
      var _docIndexRole = _interopRequireDefault$5(docIndexRole$1);
      var _docIntroductionRole = _interopRequireDefault$5(docIntroductionRole$1);
      var _docNoterefRole = _interopRequireDefault$5(docNoterefRole$1);
      var _docNoticeRole = _interopRequireDefault$5(docNoticeRole$1);
      var _docPagebreakRole = _interopRequireDefault$5(docPagebreakRole$1);
      var _docPagelistRole = _interopRequireDefault$5(docPagelistRole$1);
      var _docPartRole = _interopRequireDefault$5(docPartRole$1);
      var _docPrefaceRole = _interopRequireDefault$5(docPrefaceRole$1);
      var _docPrologueRole = _interopRequireDefault$5(docPrologueRole$1);
      var _docPullquoteRole = _interopRequireDefault$5(docPullquoteRole$1);
      var _docQnaRole = _interopRequireDefault$5(docQnaRole$1);
      var _docSubtitleRole = _interopRequireDefault$5(docSubtitleRole$1);
      var _docTipRole = _interopRequireDefault$5(docTipRole$1);
      var _docTocRole = _interopRequireDefault$5(docTocRole$1);
      function _interopRequireDefault$5(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
      var _default$7 = ariaDpubRoles;
      ariaDpubRoles$1.default = _default$7;
      var ariaGraphicsRoles$1 = {};
      var graphicsDocumentRole$1 = {};
      Object.defineProperty(graphicsDocumentRole$1, "__esModule", {
        value: true
      });
      graphicsDocumentRole$1.default = void 0;
      var graphicsDocumentRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          module: "GRAPHICS",
          concept: {
            name: "graphics-object"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "img"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "article"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "document"]]
      };
      var _default$6 = graphicsDocumentRole;
      graphicsDocumentRole$1.default = _default$6;
      var graphicsObjectRole$1 = {};
      Object.defineProperty(graphicsObjectRole$1, "__esModule", {
        value: true
      });
      graphicsObjectRole$1.default = void 0;
      var graphicsObjectRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: ["author", "contents"],
        prohibitedProps: [],
        props: {
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [{
          module: "GRAPHICS",
          concept: {
            name: "graphics-document"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "group"
          }
        }, {
          module: "ARIA",
          concept: {
            name: "img"
          }
        }, {
          module: "GRAPHICS",
          concept: {
            name: "graphics-symbol"
          }
        }],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "group"]]
      };
      var _default$5 = graphicsObjectRole;
      graphicsObjectRole$1.default = _default$5;
      var graphicsSymbolRole$1 = {};
      Object.defineProperty(graphicsSymbolRole$1, "__esModule", {
        value: true
      });
      graphicsSymbolRole$1.default = void 0;
      var graphicsSymbolRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: ["author"],
        prohibitedProps: [],
        props: {
          "aria-disabled": null,
          "aria-errormessage": null,
          "aria-expanded": null,
          "aria-haspopup": null,
          "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [["roletype", "structure", "section", "img"]]
      };
      var _default$4 = graphicsSymbolRole;
      graphicsSymbolRole$1.default = _default$4;
      Object.defineProperty(ariaGraphicsRoles$1, "__esModule", {
        value: true
      });
      ariaGraphicsRoles$1.default = void 0;
      var _graphicsDocumentRole = _interopRequireDefault$4(graphicsDocumentRole$1);
      var _graphicsObjectRole = _interopRequireDefault$4(graphicsObjectRole$1);
      var _graphicsSymbolRole = _interopRequireDefault$4(graphicsSymbolRole$1);
      function _interopRequireDefault$4(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
      var _default$3 = ariaGraphicsRoles;
      ariaGraphicsRoles$1.default = _default$3;
      Object.defineProperty(rolesMap$1, "__esModule", {
        value: true
      });
      rolesMap$1.default = void 0;
      var _ariaAbstractRoles = _interopRequireDefault$3(ariaAbstractRoles$1);
      var _ariaLiteralRoles = _interopRequireDefault$3(ariaLiteralRoles$1);
      var _ariaDpubRoles = _interopRequireDefault$3(ariaDpubRoles$1);
      var _ariaGraphicsRoles = _interopRequireDefault$3(ariaGraphicsRoles$1);
      var _iterationDecorator$2 = _interopRequireDefault$3(iterationDecorator$1);
      function _interopRequireDefault$3(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _defineProperty(obj, key2, value) {
        if (key2 in obj) {
          Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key2] = value;
        }
        return obj;
      }
      function _createForOfIteratorHelper$2(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray$2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it)
              o2 = it;
            var i2 = 0;
            var F2 = function F3() {
            };
            return { s: F2, n: function n2() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            }, e: function e2(_e2) {
              throw _e2;
            }, f: F2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o2);
        }, n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e2(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f2() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _slicedToArray$2(arr, i2) {
        return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
      }
      function _nonIterableRest$2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray$2(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$2(o2, minLen);
      }
      function _arrayLikeToArray$2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _iterableToArrayLimit$2(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles$2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      var roles$1 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
      roles$1.forEach(function(_ref) {
        var _ref2 = _slicedToArray$2(_ref, 2), roleDefinition = _ref2[1];
        var _iterator = _createForOfIteratorHelper$2(roleDefinition.superClass), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var superClassIter = _step.value;
            var _iterator2 = _createForOfIteratorHelper$2(superClassIter), _step2;
            try {
              var _loop2 = function _loop3() {
                var superClassName = _step2.value;
                var superClassRoleTuple = roles$1.find(function(_ref3) {
                  var _ref4 = _slicedToArray$2(_ref3, 1), name = _ref4[0];
                  return name === superClassName;
                });
                if (superClassRoleTuple) {
                  var superClassDefinition = superClassRoleTuple[1];
                  for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                    var prop = _Object$keys[_i2];
                    if (
                      // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                      !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)
                    ) {
                      Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                    }
                  }
                }
              };
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                _loop2();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      var rolesMap = {
        entries: function entries() {
          return roles$1;
        },
        forEach: function forEach2(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator3 = _createForOfIteratorHelper$2(roles$1), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var _step3$value = _slicedToArray$2(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
              fn.call(thisArg, values, key2, roles$1);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        get: function get2(key2) {
          var item = roles$1.find(function(tuple2) {
            return tuple2[0] === key2 ? true : false;
          });
          return item && item[1];
        },
        has: function has2(key2) {
          return !!rolesMap.get(key2);
        },
        keys: function keys2() {
          return roles$1.map(function(_ref5) {
            var _ref6 = _slicedToArray$2(_ref5, 1), key2 = _ref6[0];
            return key2;
          });
        },
        values: function values() {
          return roles$1.map(function(_ref7) {
            var _ref8 = _slicedToArray$2(_ref7, 2), values2 = _ref8[1];
            return values2;
          });
        }
      };
      var _default$2 = (0, _iterationDecorator$2.default)(rolesMap, rolesMap.entries());
      rolesMap$1.default = _default$2;
      var elementRoleMap$1 = {};
      var toStr$9 = Object.prototype.toString;
      var isArguments$3 = function isArguments2(value) {
        var str = toStr$9.call(value);
        var isArgs2 = str === "[object Arguments]";
        if (!isArgs2) {
          isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$9.call(value.callee) === "[object Function]";
        }
        return isArgs2;
      };
      var implementation$b;
      var hasRequiredImplementation;
      function requireImplementation() {
        if (hasRequiredImplementation)
          return implementation$b;
        hasRequiredImplementation = 1;
        var keysShim2;
        if (!Object.keys) {
          var has2 = Object.prototype.hasOwnProperty;
          var toStr2 = Object.prototype.toString;
          var isArgs2 = isArguments$3;
          var isEnumerable2 = Object.prototype.propertyIsEnumerable;
          var hasDontEnumBug = !isEnumerable2.call({ toString: null }, "toString");
          var hasProtoEnumBug = isEnumerable2.call(function() {
          }, "prototype");
          var dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
          ];
          var equalsConstructorPrototype = function(o2) {
            var ctor = o2.constructor;
            return ctor && ctor.prototype === o2;
          };
          var excludedKeys = {
            $applicationCache: true,
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $onmozfullscreenchange: true,
            $onmozfullscreenerror: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
          };
          var hasAutomationEqualityBug = function() {
            if (typeof window === "undefined") {
              return false;
            }
            for (var k2 in window) {
              try {
                if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
                  try {
                    equalsConstructorPrototype(window[k2]);
                  } catch (e2) {
                    return true;
                  }
                }
              } catch (e2) {
                return true;
              }
            }
            return false;
          }();
          var equalsConstructorPrototypeIfNotBuggy = function(o2) {
            if (typeof window === "undefined" || !hasAutomationEqualityBug) {
              return equalsConstructorPrototype(o2);
            }
            try {
              return equalsConstructorPrototype(o2);
            } catch (e2) {
              return false;
            }
          };
          keysShim2 = function keys2(object2) {
            var isObject2 = object2 !== null && typeof object2 === "object";
            var isFunction2 = toStr2.call(object2) === "[object Function]";
            var isArguments2 = isArgs2(object2);
            var isString2 = isObject2 && toStr2.call(object2) === "[object String]";
            var theKeys = [];
            if (!isObject2 && !isFunction2 && !isArguments2) {
              throw new TypeError("Object.keys called on a non-object");
            }
            var skipProto = hasProtoEnumBug && isFunction2;
            if (isString2 && object2.length > 0 && !has2.call(object2, 0)) {
              for (var i2 = 0; i2 < object2.length; ++i2) {
                theKeys.push(String(i2));
              }
            }
            if (isArguments2 && object2.length > 0) {
              for (var j = 0; j < object2.length; ++j) {
                theKeys.push(String(j));
              }
            } else {
              for (var name in object2) {
                if (!(skipProto && name === "prototype") && has2.call(object2, name)) {
                  theKeys.push(String(name));
                }
              }
            }
            if (hasDontEnumBug) {
              var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
              for (var k2 = 0; k2 < dontEnums.length; ++k2) {
                if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object2, dontEnums[k2])) {
                  theKeys.push(dontEnums[k2]);
                }
              }
            }
            return theKeys;
          };
        }
        implementation$b = keysShim2;
        return implementation$b;
      }
      var slice$1 = Array.prototype.slice;
      var isArgs = isArguments$3;
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys2(o2) {
        return origKeys(o2);
      } : requireImplementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys2(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice$1.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      var objectKeys$2 = keysShim;
      var shams$1 = function hasSymbols2() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = shams$1;
      var hasSymbols$5 = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
      var test = {
        foo: {}
      };
      var $Object = Object;
      var hasProto$1 = function hasProto2() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr$8 = Object.prototype.toString;
      var funcType = "[object Function]";
      var implementation$a = function bind2(that) {
        var target = this;
        if (typeof target !== "function" || toStr$8.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound2;
        var binder = function() {
          if (this instanceof bound2) {
            var result = target.apply(
              this,
              args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs.push("$" + i2);
        }
        bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty2 = function Empty3() {
          };
          Empty2.prototype = target.prototype;
          bound2.prototype = new Empty2();
          Empty2.prototype = null;
        }
        return bound2;
      };
      var implementation$9 = implementation$a;
      var functionBind = Function.prototype.bind || implementation$9;
      var bind$1 = functionBind;
      var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
      var undefined$1;
      var $SyntaxError$1 = SyntaxError;
      var $Function = Function;
      var $TypeError$2 = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD$2 = Object.getOwnPropertyDescriptor;
      if ($gOPD$2) {
        try {
          $gOPD$2({}, "");
        } catch (e2) {
          $gOPD$2 = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError$2();
      };
      var ThrowTypeError = $gOPD$2 ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD$2(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols$4 = hasSymbols$5();
      var hasProto = hasProto$1();
      var getProto$1 = Object.getPrototypeOf || (hasProto ? function(x2) {
        return x2.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols$4 ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError$1,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError$2,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
      };
      if (getProto$1) {
        try {
          null.error;
        } catch (e2) {
          var errorProto = getProto$1(getProto$1(e2));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto$1) {
            value = getProto$1(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = functionBind;
      var hasOwn$1 = src;
      var $concat$1 = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace$1 = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec$1 = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string2) {
        var first = $strSlice(string2, 0, 1);
        var last = $strSlice(string2, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace$1(string2, rePropName, function(match2, number2, quote2, subString) {
          result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match2;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn$1(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError$2("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
      };
      var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError$2("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError$2('"allowMissing" argument must be a boolean');
        }
        if ($exec$1(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat$1([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError$1("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError$2("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD$2 && i2 + 1 >= parts.length) {
              var desc = $gOPD$2(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn$1(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
      var GetIntrinsic$8 = getIntrinsic;
      var $defineProperty = GetIntrinsic$8("%Object.defineProperty%", true);
      var hasPropertyDescriptors$1 = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e2) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors$1()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e2) {
          return true;
        }
      };
      var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
      var keys$2 = objectKeys$2;
      var hasSymbols$3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr$7 = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr$7.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = hasPropertyDescriptors_1();
      var supportsDescriptors$2 = origDefineProperty && hasPropertyDescriptors;
      var defineProperty$1 = function(object2, name, value, predicate) {
        if (name in object2) {
          if (predicate === true) {
            if (object2[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors$2) {
          origDefineProperty(object2, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name] = value;
        }
      };
      var defineProperties$1 = function(object2, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys$2(map);
        if (hasSymbols$3) {
          props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i2 = 0; i2 < props.length; i2 += 1) {
          defineProperty$1(object2, props[i2], map[props[i2]], predicates[props[i2]]);
        }
      };
      defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
      var defineProperties_1 = defineProperties$1;
      var callBind$5 = { exports: {} };
      (function(module2) {
        var bind2 = functionBind;
        var GetIntrinsic2 = getIntrinsic;
        var $apply = GetIntrinsic2("%Function.prototype.apply%");
        var $call = GetIntrinsic2("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
        var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%", true);
        var $defineProperty2 = GetIntrinsic2("%Object.defineProperty%", true);
        var $max = GetIntrinsic2("%Math.max%");
        if ($defineProperty2) {
          try {
            $defineProperty2({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty2 = null;
          }
        }
        module2.exports = function callBind2(originalFunction) {
          var func = $reflectApply(bind2, $call, arguments);
          if ($gOPD2 && $defineProperty2) {
            var desc = $gOPD2(func, "length");
            if (desc.configurable) {
              $defineProperty2(
                func,
                "length",
                { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
              );
            }
          }
          return func;
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind2, $apply, arguments);
        };
        if ($defineProperty2) {
          $defineProperty2(module2.exports, "apply", { value: applyBind });
        } else {
          module2.exports.apply = applyBind;
        }
      })(callBind$5);
      var callBindExports = callBind$5.exports;
      var GetIntrinsic$7 = getIntrinsic;
      var callBind$4 = callBindExports;
      var $indexOf$1 = callBind$4(GetIntrinsic$7("String.prototype.indexOf"));
      var callBound$d = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic$7(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.") > -1) {
          return callBind$4(intrinsic);
        }
        return intrinsic;
      };
      var objectKeys$1 = objectKeys$2;
      var hasSymbols$2 = shams$1();
      var callBound$c = callBound$d;
      var toObject = Object;
      var $push = callBound$c("Array.prototype.push");
      var $propIsEnumerable = callBound$c("Object.prototype.propertyIsEnumerable");
      var originalGetSymbols = hasSymbols$2 ? Object.getOwnPropertySymbols : null;
      var implementation$8 = function assign2(target, source1) {
        if (target == null) {
          throw new TypeError("target must be an object");
        }
        var to = toObject(target);
        if (arguments.length === 1) {
          return to;
        }
        for (var s = 1; s < arguments.length; ++s) {
          var from2 = toObject(arguments[s]);
          var keys2 = objectKeys$1(from2);
          var getSymbols = hasSymbols$2 && (Object.getOwnPropertySymbols || originalGetSymbols);
          if (getSymbols) {
            var syms = getSymbols(from2);
            for (var j = 0; j < syms.length; ++j) {
              var key2 = syms[j];
              if ($propIsEnumerable(from2, key2)) {
                $push(keys2, key2);
              }
            }
          }
          for (var i2 = 0; i2 < keys2.length; ++i2) {
            var nextKey = keys2[i2];
            if ($propIsEnumerable(from2, nextKey)) {
              var propValue = from2[nextKey];
              to[nextKey] = propValue;
            }
          }
        }
        return to;
      };
      var implementation$7 = implementation$8;
      var lacksProperEnumerationOrder = function() {
        if (!Object.assign) {
          return false;
        }
        var str = "abcdefghijklmnopqrst";
        var letters = str.split("");
        var map = {};
        for (var i2 = 0; i2 < letters.length; ++i2) {
          map[letters[i2]] = letters[i2];
        }
        var obj = Object.assign({}, map);
        var actual = "";
        for (var k2 in obj) {
          actual += k2;
        }
        return str !== actual;
      };
      var assignHasPendingExceptions = function() {
        if (!Object.assign || !Object.preventExtensions) {
          return false;
        }
        var thrower = Object.preventExtensions({ 1: 2 });
        try {
          Object.assign(thrower, "xy");
        } catch (e2) {
          return thrower[1] === "y";
        }
        return false;
      };
      var polyfill$4 = function getPolyfill2() {
        if (!Object.assign) {
          return implementation$7;
        }
        if (lacksProperEnumerationOrder()) {
          return implementation$7;
        }
        if (assignHasPendingExceptions()) {
          return implementation$7;
        }
        return Object.assign;
      };
      var define$3 = defineProperties_1;
      var getPolyfill$5 = polyfill$4;
      var shim$5 = function shimAssign() {
        var polyfill2 = getPolyfill$5();
        define$3(
          Object,
          { assign: polyfill2 },
          { assign: function() {
            return Object.assign !== polyfill2;
          } }
        );
        return polyfill2;
      };
      var defineProperties = defineProperties_1;
      var callBind$3 = callBindExports;
      var implementation$6 = implementation$8;
      var getPolyfill$4 = polyfill$4;
      var shim$4 = shim$5;
      var polyfill$3 = callBind$3.apply(getPolyfill$4());
      var bound = function assign2(target, source1) {
        return polyfill$3(Object, arguments);
      };
      defineProperties(bound, {
        getPolyfill: getPolyfill$4,
        implementation: implementation$6,
        shim: shim$4
      });
      var object_assign = bound;
      var implementation$5 = { exports: {} };
      var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f2() {
        }.name === "string";
      };
      var gOPD$4 = Object.getOwnPropertyDescriptor;
      if (gOPD$4) {
        try {
          gOPD$4([], "length");
        } catch (e2) {
          gOPD$4 = null;
        }
      }
      functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD$4) {
          return false;
        }
        var desc = gOPD$4(function() {
        }, "name");
        return !!desc && !!desc.configurable;
      };
      var $bind = Function.prototype.bind;
      functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f2() {
        }.bind().name !== "";
      };
      var functionsHaveNames_1 = functionsHaveNames;
      (function(module2) {
        var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();
        var $Object2 = Object;
        var $TypeError2 = TypeError;
        module2.exports = function flags2() {
          if (this != null && this !== $Object2(this)) {
            throw new $TypeError2("RegExp.prototype.flags getter called on non-object");
          }
          var result = "";
          if (this.hasIndices) {
            result += "d";
          }
          if (this.global) {
            result += "g";
          }
          if (this.ignoreCase) {
            result += "i";
          }
          if (this.multiline) {
            result += "m";
          }
          if (this.dotAll) {
            result += "s";
          }
          if (this.unicode) {
            result += "u";
          }
          if (this.unicodeSets) {
            result += "v";
          }
          if (this.sticky) {
            result += "y";
          }
          return result;
        };
        if (functionsHaveConfigurableNames && Object.defineProperty) {
          Object.defineProperty(module2.exports, "name", { value: "get flags" });
        }
      })(implementation$5);
      var implementationExports = implementation$5.exports;
      var implementation$4 = implementationExports;
      var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
      var $gOPD$1 = Object.getOwnPropertyDescriptor;
      var polyfill$2 = function getPolyfill2() {
        if (supportsDescriptors$1 && /a/mig.flags === "gim") {
          var descriptor = $gOPD$1(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
            var calls = "";
            var o2 = {};
            Object.defineProperty(o2, "hasIndices", {
              get: function() {
                calls += "d";
              }
            });
            Object.defineProperty(o2, "sticky", {
              get: function() {
                calls += "y";
              }
            });
            if (calls === "dy") {
              return descriptor.get;
            }
          }
        }
        return implementation$4;
      };
      var supportsDescriptors = defineProperties_1.supportsDescriptors;
      var getPolyfill$3 = polyfill$2;
      var gOPD$3 = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex$1 = /a/;
      var shim$3 = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill2 = getPolyfill$3();
        var proto = getProto(regex$1);
        var descriptor = gOPD$3(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill2) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill2
          });
        }
        return polyfill2;
      };
      var define$2 = defineProperties_1;
      var callBind$2 = callBindExports;
      var implementation$3 = implementationExports;
      var getPolyfill$2 = polyfill$2;
      var shim$2 = shim$3;
      var flagsBound = callBind$2(getPolyfill$2());
      define$2(flagsBound, {
        getPolyfill: getPolyfill$2,
        implementation: implementation$3,
        shim: shim$2
      });
      var regexp_prototype_flags = flagsBound;
      var esGetIterator = { exports: {} };
      var hasSymbols$1 = shams$1;
      var shams = function hasToStringTagShams() {
        return hasSymbols$1() && !!Symbol.toStringTag;
      };
      var hasToStringTag$8 = shams();
      var callBound$b = callBound$d;
      var $toString$4 = callBound$b("Object.prototype.toString");
      var isStandardArguments = function isArguments2(value) {
        if (hasToStringTag$8 && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString$4(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments2(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$4(value) !== "[object Array]" && $toString$4(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
      const __viteBrowserExternal = {};
      const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
      }, Symbol.toStringTag, { value: "Module" }));
      const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice$2 = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf$1 = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var gPO$1 = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
        return O.__proto__;
      } : null);
      function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num);
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice$2.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }
      var utilInspect = require$$0;
      var inspectCustom = utilInspect.custom;
      var inspectSymbol = isSymbol$2(inspectCustom) ? inspectCustom : null;
      var objectInspect = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has$2(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has$2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has$2(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has$2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has$2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray$2(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }
        function inspect2(value, from2, noIndent) {
          if (from2) {
            seen = $arrSlice.call(seen);
            seen.push(from2);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has$2(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function" && !isRegExp(obj)) {
          var name = nameOf(obj);
          var keys2 = arrObjKeys(obj, inspect2);
          return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
        }
        if (isSymbol$2(obj)) {
          var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement$1(obj)) {
          var s = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i2 = 0; i2 < attrs.length; i2++) {
            s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
          }
          s += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s += "...";
          }
          s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s;
        }
        if (isArray$2(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect2);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect2);
          if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
            return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap$3(obj)) {
          var mapParts = [];
          if (mapForEach) {
            mapForEach.call(obj, function(value, key2) {
              mapParts.push(inspect2(key2, obj, true) + " => " + inspect2(value, obj));
            });
          }
          return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet$3(obj)) {
          var setParts = [];
          if (setForEach) {
            setForEach.call(obj, function(value) {
              setParts.push(inspect2(value, obj));
            });
          }
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap$1(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet$1(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber$1(obj)) {
          return markBoxed(inspect2(Number(obj)));
        }
        if (isBigInt$1(obj)) {
          return markBoxed(inspect2(bigIntValueOf$1.call(obj)));
        }
        if (isBoolean$1(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString$3(obj)) {
          return markBoxed(inspect2(String(obj)));
        }
        if (!isDate$1(obj) && !isRegExp(obj)) {
          var ys = arrObjKeys(obj, inspect2);
          var isPlainObject = gPO$1 ? gPO$1(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$2.call(toStr$6(obj), 8, -1) : protoTag ? "Object" : "";
          var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
          var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };
      function wrapQuotes(s, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s + quoteChar;
      }
      function quote(s) {
        return $replace.call(String(s), /"/g, "&quot;");
      }
      function isArray$2(obj) {
        return toStr$6(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate$1(obj) {
        return toStr$6(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp(obj) {
        return toStr$6(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr$6(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString$3(obj) {
        return toStr$6(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber$1(obj) {
        return toStr$6(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean$1(obj) {
        return toStr$6(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isSymbol$2(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isBigInt$1(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf$1) {
          return false;
        }
        try {
          bigIntValueOf$1.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
        return key2 in this;
      };
      function has$2(obj, key2) {
        return hasOwn.call(obj, key2);
      }
      function toStr$6(obj) {
        return objectToString.call(obj);
      }
      function nameOf(f2) {
        if (f2.name) {
          return f2.name;
        }
        var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
        if (m2) {
          return m2[1];
        }
        return null;
      }
      function indexOf(xs, x2) {
        if (xs.indexOf) {
          return xs.indexOf(x2);
        }
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x2) {
            return i2;
          }
        }
        return -1;
      }
      function isMap$3(x2) {
        if (!mapSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          mapSize.call(x2);
          try {
            setSize.call(x2);
          } catch (s) {
            return true;
          }
          return x2 instanceof Map;
        } catch (e2) {
        }
        return false;
      }
      function isWeakMap$1(x2) {
        if (!weakMapHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x2, weakMapHas);
          try {
            weakSetHas.call(x2, weakSetHas);
          } catch (s) {
            return true;
          }
          return x2 instanceof WeakMap;
        } catch (e2) {
        }
        return false;
      }
      function isWeakRef(x2) {
        if (!weakRefDeref || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x2);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isSet$3(x2) {
        if (!setSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          setSize.call(x2);
          try {
            mapSize.call(x2);
          } catch (m2) {
            return true;
          }
          return x2 instanceof Set;
        } catch (e2) {
        }
        return false;
      }
      function isWeakSet$1(x2) {
        if (!weakSetHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x2, weakSetHas);
          try {
            weakMapHas.call(x2, weakMapHas);
          } catch (s) {
            return true;
          }
          return x2 instanceof WeakSet;
        } catch (e2) {
        }
        return false;
      }
      function isElement$1(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
          return true;
        }
        return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
      }
      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice$2.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s, "single", opts);
      }
      function lowbyte(c2) {
        var n2 = c2.charCodeAt(0);
        var x2 = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n2];
        if (x2) {
          return "\\" + x2;
        }
        return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
      }
      function markBoxed(str) {
        return "Object(" + str + ")";
      }
      function weakCollectionOf(type2) {
        return type2 + " { ? }";
      }
      function collectionOf(type2, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type2 + " (" + size + ") {" + joinedEntries + "}";
      }
      function singleLineValues(xs) {
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (indexOf(xs[i2], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }
      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
          baseIndent = "	";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }
      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }
      function arrObjKeys(obj, inspect2) {
        var isArr = isArray$2(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i2 = 0; i2 < obj.length; i2++) {
            xs[i2] = has$2(obj, i2) ? inspect2(obj[i2], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k2 = 0; k2 < syms.length; k2++) {
            symMap["$" + syms[k2]] = syms[k2];
          }
        }
        for (var key2 in obj) {
          if (!has$2(obj, key2)) {
            continue;
          }
          if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
            continue;
          }
          if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
            continue;
          } else if ($test.call(/[^\w$]/, key2)) {
            xs.push(inspect2(key2, obj) + ": " + inspect2(obj[key2], obj));
          } else {
            xs.push(key2 + ": " + inspect2(obj[key2], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
              xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
            }
          }
        }
        return xs;
      }
      var GetIntrinsic$6 = getIntrinsic;
      var callBound$a = callBound$d;
      var inspect = objectInspect;
      var $TypeError$1 = GetIntrinsic$6("%TypeError%");
      var $WeakMap$1 = GetIntrinsic$6("%WeakMap%", true);
      var $Map$3 = GetIntrinsic$6("%Map%", true);
      var $weakMapGet = callBound$a("WeakMap.prototype.get", true);
      var $weakMapSet = callBound$a("WeakMap.prototype.set", true);
      var $weakMapHas = callBound$a("WeakMap.prototype.has", true);
      var $mapGet$1 = callBound$a("Map.prototype.get", true);
      var $mapSet = callBound$a("Map.prototype.set", true);
      var $mapHas$5 = callBound$a("Map.prototype.has", true);
      var listGetNode = function(list, key2) {
        for (var prev2 = list, curr; (curr = prev2.next) !== null; prev2 = curr) {
          if (curr.key === key2) {
            prev2.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
          }
        }
      };
      var listGet = function(objects, key2) {
        var node2 = listGetNode(objects, key2);
        return node2 && node2.value;
      };
      var listSet = function(objects, key2, value) {
        var node2 = listGetNode(objects, key2);
        if (node2) {
          node2.value = value;
        } else {
          objects.next = {
            // eslint-disable-line no-param-reassign
            key: key2,
            next: objects.next,
            value
          };
        }
      };
      var listHas = function(objects, key2) {
        return !!listGetNode(objects, key2);
      };
      var sideChannel = function getSideChannel2() {
        var $wm;
        var $m;
        var $o;
        var channel2 = {
          assert: function(key2) {
            if (!channel2.has(key2)) {
              throw new $TypeError$1("Side channel does not contain " + inspect(key2));
            }
          },
          get: function(key2) {
            if ($WeakMap$1 && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key2);
              }
            } else if ($Map$3) {
              if ($m) {
                return $mapGet$1($m, key2);
              }
            } else {
              if ($o) {
                return listGet($o, key2);
              }
            }
          },
          has: function(key2) {
            if ($WeakMap$1 && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key2);
              }
            } else if ($Map$3) {
              if ($m) {
                return $mapHas$5($m, key2);
              }
            } else {
              if ($o) {
                return listHas($o, key2);
              }
            }
            return false;
          },
          set: function(key2, value) {
            if ($WeakMap$1 && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
              if (!$wm) {
                $wm = new $WeakMap$1();
              }
              $weakMapSet($wm, key2, value);
            } else if ($Map$3) {
              if (!$m) {
                $m = new $Map$3();
              }
              $mapSet($m, key2, value);
            } else {
              if (!$o) {
                $o = { key: {}, next: null };
              }
              listSet($o, key2, value);
            }
          }
        };
        return channel2;
      };
      var GetIntrinsic$5 = getIntrinsic;
      var has$1 = src;
      var channel = sideChannel();
      var $TypeError = GetIntrinsic$5("%TypeError%");
      var SLOT$1 = {
        assert: function(O, slot) {
          if (!O || typeof O !== "object" && typeof O !== "function") {
            throw new $TypeError("`O` is not an object");
          }
          if (typeof slot !== "string") {
            throw new $TypeError("`slot` must be a string");
          }
          channel.assert(O);
          if (!SLOT$1.has(O, slot)) {
            throw new $TypeError("`" + slot + "` is not present on `O`");
          }
        },
        get: function(O, slot) {
          if (!O || typeof O !== "object" && typeof O !== "function") {
            throw new $TypeError("`O` is not an object");
          }
          if (typeof slot !== "string") {
            throw new $TypeError("`slot` must be a string");
          }
          var slots = channel.get(O);
          return slots && slots["$" + slot];
        },
        has: function(O, slot) {
          if (!O || typeof O !== "object" && typeof O !== "function") {
            throw new $TypeError("`O` is not an object");
          }
          if (typeof slot !== "string") {
            throw new $TypeError("`slot` must be a string");
          }
          var slots = channel.get(O);
          return !!slots && has$1(slots, "$" + slot);
        },
        set: function(O, slot, V) {
          if (!O || typeof O !== "object" && typeof O !== "function") {
            throw new $TypeError("`O` is not an object");
          }
          if (typeof slot !== "string") {
            throw new $TypeError("`slot` must be a string");
          }
          var slots = channel.get(O);
          if (!slots) {
            slots = {};
            channel.set(O, slots);
          }
          slots["$" + slot] = V;
        }
      };
      if (Object.freeze) {
        Object.freeze(SLOT$1);
      }
      var internalSlot = SLOT$1;
      var SLOT = internalSlot;
      var $SyntaxError = SyntaxError;
      var $StopIteration = typeof StopIteration === "object" ? StopIteration : null;
      var stopIterationIterator = function getStopIterationIterator2(origIterator) {
        if (!$StopIteration) {
          throw new $SyntaxError("this environment lacks StopIteration");
        }
        SLOT.set(origIterator, "[[Done]]", false);
        var siIterator = {
          next: function next2() {
            var iterator = SLOT.get(this, "[[Iterator]]");
            var done = SLOT.get(iterator, "[[Done]]");
            try {
              return {
                done,
                value: done ? void 0 : iterator.next()
              };
            } catch (e2) {
              SLOT.set(iterator, "[[Done]]", true);
              if (e2 !== $StopIteration) {
                throw e2;
              }
              return {
                done: true,
                value: void 0
              };
            }
          }
        };
        SLOT.set(siIterator, "[[Iterator]]", origIterator);
        return siIterator;
      };
      var toString = {}.toString;
      var isarray = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      var strValue = String.prototype.valueOf;
      var tryStringObject = function tryStringObject2(value) {
        try {
          strValue.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr$5 = Object.prototype.toString;
      var strClass = "[object String]";
      var hasToStringTag$7 = shams();
      var isString$2 = function isString2(value) {
        if (typeof value === "string") {
          return true;
        }
        if (typeof value !== "object") {
          return false;
        }
        return hasToStringTag$7 ? tryStringObject(value) : toStr$5.call(value) === strClass;
      };
      var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
      var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
      var exported$2;
      if (!$Map$2) {
        exported$2 = function isMap2(x2) {
          return false;
        };
      }
      var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
      var $setHas$4 = $Set$3 ? Set.prototype.has : null;
      if (!exported$2 && !$mapHas$4) {
        exported$2 = function isMap2(x2) {
          return false;
        };
      }
      var isMap$2 = exported$2 || function isMap2(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          $mapHas$4.call(x2);
          if ($setHas$4) {
            try {
              $setHas$4.call(x2);
            } catch (e2) {
              return true;
            }
          }
          return x2 instanceof $Map$2;
        } catch (e2) {
        }
        return false;
      };
      var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
      var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
      var exported$1;
      if (!$Set$2) {
        exported$1 = function isSet2(x2) {
          return false;
        };
      }
      var $mapHas$3 = $Map$1 ? Map.prototype.has : null;
      var $setHas$3 = $Set$2 ? Set.prototype.has : null;
      if (!exported$1 && !$setHas$3) {
        exported$1 = function isSet2(x2) {
          return false;
        };
      }
      var isSet$2 = exported$1 || function isSet2(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          $setHas$3.call(x2);
          if ($mapHas$3) {
            try {
              $mapHas$3.call(x2);
            } catch (e2) {
              return true;
            }
          }
          return x2 instanceof $Set$2;
        } catch (e2) {
        }
        return false;
      };
      var isArguments$1 = isArguments$2;
      var getStopIterationIterator = stopIterationIterator;
      if (hasSymbols$5() || shams$1()) {
        var $iterator = Symbol.iterator;
        esGetIterator.exports = function getIterator2(iterable) {
          if (iterable != null && typeof iterable[$iterator] !== "undefined") {
            return iterable[$iterator]();
          }
          if (isArguments$1(iterable)) {
            return Array.prototype[$iterator].call(iterable);
          }
        };
      } else {
        var isArray$1 = isarray;
        var isString$1 = isString$2;
        var GetIntrinsic$4 = getIntrinsic;
        var $Map = GetIntrinsic$4("%Map%", true);
        var $Set$1 = GetIntrinsic$4("%Set%", true);
        var callBound$9 = callBound$d;
        var $arrayPush = callBound$9("Array.prototype.push");
        var $charCodeAt = callBound$9("String.prototype.charCodeAt");
        var $stringSlice = callBound$9("String.prototype.slice");
        var advanceStringIndex = function advanceStringIndex2(S, index2) {
          var length2 = S.length;
          if (index2 + 1 >= length2) {
            return index2 + 1;
          }
          var first = $charCodeAt(S, index2);
          if (first < 55296 || first > 56319) {
            return index2 + 1;
          }
          var second = $charCodeAt(S, index2 + 1);
          if (second < 56320 || second > 57343) {
            return index2 + 1;
          }
          return index2 + 2;
        };
        var getArrayIterator = function getArrayIterator2(arraylike) {
          var i2 = 0;
          return {
            next: function next2() {
              var done = i2 >= arraylike.length;
              var value;
              if (!done) {
                value = arraylike[i2];
                i2 += 1;
              }
              return {
                done,
                value
              };
            }
          };
        };
        var getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
          if (isArray$1(iterable) || isArguments$1(iterable)) {
            return getArrayIterator(iterable);
          }
          if (isString$1(iterable)) {
            var i2 = 0;
            return {
              next: function next2() {
                var nextIndex = advanceStringIndex(iterable, i2);
                var value = $stringSlice(iterable, i2, nextIndex);
                i2 = nextIndex;
                return {
                  done: nextIndex > iterable.length,
                  value
                };
              }
            };
          }
          if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
            return iterable["_es6-shim iterator_"]();
          }
        };
        if (!$Map && !$Set$1) {
          esGetIterator.exports = function getIterator2(iterable) {
            if (iterable != null) {
              return getNonCollectionIterator(iterable, true);
            }
          };
        } else {
          var isMap$1 = isMap$2;
          var isSet$1 = isSet$2;
          var $mapForEach = callBound$9("Map.prototype.forEach", true);
          var $setForEach = callBound$9("Set.prototype.forEach", true);
          if (typeof process === "undefined" || !process.versions || !process.versions.node) {
            var $mapIterator = callBound$9("Map.prototype.iterator", true);
            var $setIterator = callBound$9("Set.prototype.iterator", true);
          }
          var $mapAtAtIterator = callBound$9("Map.prototype.@@iterator", true) || callBound$9("Map.prototype._es6-shim iterator_", true);
          var $setAtAtIterator = callBound$9("Set.prototype.@@iterator", true) || callBound$9("Set.prototype._es6-shim iterator_", true);
          var getCollectionIterator = function getCollectionIterator2(iterable) {
            if (isMap$1(iterable)) {
              if ($mapIterator) {
                return getStopIterationIterator($mapIterator(iterable));
              }
              if ($mapAtAtIterator) {
                return $mapAtAtIterator(iterable);
              }
              if ($mapForEach) {
                var entries = [];
                $mapForEach(iterable, function(v2, k2) {
                  $arrayPush(entries, [k2, v2]);
                });
                return getArrayIterator(entries);
              }
            }
            if (isSet$1(iterable)) {
              if ($setIterator) {
                return getStopIterationIterator($setIterator(iterable));
              }
              if ($setAtAtIterator) {
                return $setAtAtIterator(iterable);
              }
              if ($setForEach) {
                var values = [];
                $setForEach(iterable, function(v2) {
                  $arrayPush(values, v2);
                });
                return getArrayIterator(values);
              }
            }
          };
          esGetIterator.exports = function getIterator2(iterable) {
            return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
          };
        }
      }
      var esGetIteratorExports = esGetIterator.exports;
      var numberIsNaN = function(value) {
        return value !== value;
      };
      var implementation$2 = function is2(a, b2) {
        if (a === 0 && b2 === 0) {
          return 1 / a === 1 / b2;
        }
        if (a === b2) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b2)) {
          return true;
        }
        return false;
      };
      var implementation$1 = implementation$2;
      var polyfill$1 = function getPolyfill2() {
        return typeof Object.is === "function" ? Object.is : implementation$1;
      };
      var getPolyfill$1 = polyfill$1;
      var define$1 = defineProperties_1;
      var shim$1 = function shimObjectIs() {
        var polyfill2 = getPolyfill$1();
        define$1(Object, { is: polyfill2 }, {
          is: function testObjectIs() {
            return Object.is !== polyfill2;
          }
        });
        return polyfill2;
      };
      var define = defineProperties_1;
      var callBind$1 = callBindExports;
      var implementation = implementation$2;
      var getPolyfill = polyfill$1;
      var shim = shim$1;
      var polyfill = callBind$1(getPolyfill(), Object);
      define(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      var objectIs = polyfill;
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e2) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr$4 = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag$6 = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        var all = document.all;
        if (toStr$4.call(all) === toStr$4.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr$4.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e2) {
              }
            }
            return false;
          };
        }
      }
      var isCallable$1 = reflectApply ? function isCallable2(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e2) {
          if (e2 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable2(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag$6) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass2 = toStr$4.call(value);
        if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2)) {
          return false;
        }
        return tryFunctionObject(value);
      };
      var isCallable = isCallable$1;
      var toStr$3 = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array2, iterator, receiver) {
        for (var i2 = 0, len = array2.length; i2 < len; i2++) {
          if (hasOwnProperty.call(array2, i2)) {
            if (receiver == null) {
              iterator(array2[i2], i2, array2);
            } else {
              iterator.call(receiver, array2[i2], i2, array2);
            }
          }
        }
      };
      var forEachString = function forEachString2(string2, iterator, receiver) {
        for (var i2 = 0, len = string2.length; i2 < len; i2++) {
          if (receiver == null) {
            iterator(string2.charAt(i2), i2, string2);
          } else {
            iterator.call(receiver, string2.charAt(i2), i2, string2);
          }
        }
      };
      var forEachObject = function forEachObject2(object2, iterator, receiver) {
        for (var k2 in object2) {
          if (hasOwnProperty.call(object2, k2)) {
            if (receiver == null) {
              iterator(object2[k2], k2, object2);
            } else {
              iterator.call(receiver, object2[k2], k2, object2);
            }
          }
        }
      };
      var forEach$2 = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr$3.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      var forEach_1 = forEach$2;
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
      var availableTypedArrays$2 = function availableTypedArrays2() {
        var out = [];
        for (var i2 = 0; i2 < possibleNames.length; i2++) {
          if (typeof g$2[possibleNames[i2]] === "function") {
            out[out.length] = possibleNames[i2];
          }
        }
        return out;
      };
      var GetIntrinsic$3 = getIntrinsic;
      var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var gopd = $gOPD;
      var forEach$1 = forEach_1;
      var availableTypedArrays$1 = availableTypedArrays$2;
      var callBound$8 = callBound$d;
      var $toString$3 = callBound$8("Object.prototype.toString");
      var hasToStringTag$5 = shams();
      var gOPD$2 = gopd;
      var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
      var typedArrays$1 = availableTypedArrays$1();
      var $indexOf = callBound$8("Array.prototype.indexOf", true) || function indexOf2(array2, value) {
        for (var i2 = 0; i2 < array2.length; i2 += 1) {
          if (array2[i2] === value) {
            return i2;
          }
        }
        return -1;
      };
      var $slice$1 = callBound$8("String.prototype.slice");
      var toStrTags$1 = {};
      var getPrototypeOf$1 = Object.getPrototypeOf;
      if (hasToStringTag$5 && gOPD$2 && getPrototypeOf$1) {
        forEach$1(typedArrays$1, function(typedArray) {
          var arr = new g$1[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf$1(arr);
            var descriptor = gOPD$2(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf$1(proto);
              descriptor = gOPD$2(superProto, Symbol.toStringTag);
            }
            toStrTags$1[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays$1 = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach$1(toStrTags$1, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e2) {
            }
          }
        });
        return anyTrue;
      };
      var isTypedArray$2 = function isTypedArray2(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag$5 || !(Symbol.toStringTag in value)) {
          var tag = $slice$1($toString$3(value), 8, -1);
          return $indexOf(typedArrays$1, tag) > -1;
        }
        if (!gOPD$2) {
          return false;
        }
        return tryTypedArrays$1(value);
      };
      var callBind = callBindExports;
      var callBound$7 = callBound$d;
      var GetIntrinsic$2 = getIntrinsic;
      var isTypedArray$1 = isTypedArray$2;
      var $ArrayBuffer = GetIntrinsic$2("ArrayBuffer", true);
      var $Float32Array = GetIntrinsic$2("Float32Array", true);
      var $byteLength$2 = callBound$7("ArrayBuffer.prototype.byteLength", true);
      var abSlice = $ArrayBuffer && !$byteLength$2 && new $ArrayBuffer().slice;
      var $abSlice = abSlice && callBind(abSlice);
      var isArrayBuffer$2 = $byteLength$2 || $abSlice ? function isArrayBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        try {
          if ($byteLength$2) {
            $byteLength$2(obj);
          } else {
            $abSlice(obj, 0);
          }
          return true;
        } catch (e2) {
          return false;
        }
      } : $Float32Array ? function IsArrayBuffer(obj) {
        try {
          return new $Float32Array(obj).buffer === obj && !isTypedArray$1(obj);
        } catch (e2) {
          return typeof obj === "object" && e2.name === "RangeError";
        }
      } : function isArrayBuffer2(obj) {
        return false;
      };
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr$2 = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag$4 = shams();
      var isDateObject = function isDateObject2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag$4 ? tryDateObject(value) : toStr$2.call(value) === dateClass;
      };
      var callBound$6 = callBound$d;
      var hasToStringTag$3 = shams();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag$3) {
        has = callBound$6("Object.prototype.hasOwnProperty");
        $exec = callBound$6("RegExp.prototype.exec");
        isRegexMarker = {};
        var throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var $toString$2 = callBound$6("Object.prototype.toString");
      var gOPD$1 = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      var isRegex$1 = hasToStringTag$3 ? function isRegex2(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD$1(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e2) {
          return e2 === isRegexMarker;
        }
      } : function isRegex2(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString$2(value) === regexClass;
      };
      var callBound$5 = callBound$d;
      var $byteLength$1 = callBound$5("SharedArrayBuffer.prototype.byteLength", true);
      var isSharedArrayBuffer$1 = $byteLength$1 ? function isSharedArrayBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        try {
          $byteLength$1(obj);
          return true;
        } catch (e2) {
          return false;
        }
      } : function isSharedArrayBuffer2(obj) {
        return false;
      };
      var numToStr = Number.prototype.toString;
      var tryNumberObject = function tryNumberObject2(value) {
        try {
          numToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr$1 = Object.prototype.toString;
      var numClass = "[object Number]";
      var hasToStringTag$2 = shams();
      var isNumberObject = function isNumberObject2(value) {
        if (typeof value === "number") {
          return true;
        }
        if (typeof value !== "object") {
          return false;
        }
        return hasToStringTag$2 ? tryNumberObject(value) : toStr$1.call(value) === numClass;
      };
      var callBound$4 = callBound$d;
      var $boolToStr = callBound$4("Boolean.prototype.toString");
      var $toString$1 = callBound$4("Object.prototype.toString");
      var tryBooleanObject = function booleanBrandCheck(value) {
        try {
          $boolToStr(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var boolClass = "[object Boolean]";
      var hasToStringTag$1 = shams();
      var isBooleanObject = function isBoolean2(value) {
        if (typeof value === "boolean") {
          return true;
        }
        if (value === null || typeof value !== "object") {
          return false;
        }
        return hasToStringTag$1 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$1(value) === boolClass;
      };
      var isSymbol$1 = { exports: {} };
      var toStr = Object.prototype.toString;
      var hasSymbols = hasSymbols$5();
      if (hasSymbols) {
        var symToStr = Symbol.prototype.toString;
        var symStringRegex = /^Symbol\(.*\)$/;
        var isSymbolObject = function isRealSymbolObject(value) {
          if (typeof value.valueOf() !== "symbol") {
            return false;
          }
          return symStringRegex.test(symToStr.call(value));
        };
        isSymbol$1.exports = function isSymbol2(value) {
          if (typeof value === "symbol") {
            return true;
          }
          if (toStr.call(value) !== "[object Symbol]") {
            return false;
          }
          try {
            return isSymbolObject(value);
          } catch (e2) {
            return false;
          }
        };
      } else {
        isSymbol$1.exports = function isSymbol2(value) {
          return false;
        };
      }
      var isSymbolExports = isSymbol$1.exports;
      var isBigint = { exports: {} };
      var $BigInt = typeof BigInt !== "undefined" && BigInt;
      var hasBigints = function hasNativeBigInts() {
        return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
      };
      var hasBigInts = hasBigints();
      if (hasBigInts) {
        var bigIntValueOf = BigInt.prototype.valueOf;
        var tryBigInt = function tryBigIntObject(value) {
          try {
            bigIntValueOf.call(value);
            return true;
          } catch (e2) {
          }
          return false;
        };
        isBigint.exports = function isBigInt2(value) {
          if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
            return false;
          }
          if (typeof value === "bigint") {
            return true;
          }
          return tryBigInt(value);
        };
      } else {
        isBigint.exports = function isBigInt2(value) {
          return false;
        };
      }
      var isBigintExports = isBigint.exports;
      var isString = isString$2;
      var isNumber = isNumberObject;
      var isBoolean = isBooleanObject;
      var isSymbol = isSymbolExports;
      var isBigInt = isBigintExports;
      var whichBoxedPrimitive$1 = function whichBoxedPrimitive2(value) {
        if (value == null || typeof value !== "object" && typeof value !== "function") {
          return null;
        }
        if (isString(value)) {
          return "String";
        }
        if (isNumber(value)) {
          return "Number";
        }
        if (isBoolean(value)) {
          return "Boolean";
        }
        if (isSymbol(value)) {
          return "Symbol";
        }
        if (isBigInt(value)) {
          return "BigInt";
        }
      };
      var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
      var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
      var exported;
      if (!$WeakMap) {
        exported = function isWeakMap2(x2) {
          return false;
        };
      }
      var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
      var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
      if (!exported && !$mapHas$2) {
        exported = function isWeakMap2(x2) {
          return false;
        };
      }
      var isWeakmap = exported || function isWeakMap2(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          $mapHas$2.call(x2, $mapHas$2);
          if ($setHas$2) {
            try {
              $setHas$2.call(x2, $setHas$2);
            } catch (e2) {
              return true;
            }
          }
          return x2 instanceof $WeakMap;
        } catch (e2) {
        }
        return false;
      };
      var isWeakset = { exports: {} };
      var GetIntrinsic$1 = getIntrinsic;
      var callBound$3 = callBound$d;
      var $WeakSet = GetIntrinsic$1("%WeakSet%", true);
      var $setHas$1 = callBound$3("WeakSet.prototype.has", true);
      if ($setHas$1) {
        var $mapHas$1 = callBound$3("WeakMap.prototype.has", true);
        isWeakset.exports = function isWeakSet2(x2) {
          if (!x2 || typeof x2 !== "object") {
            return false;
          }
          try {
            $setHas$1(x2, $setHas$1);
            if ($mapHas$1) {
              try {
                $mapHas$1(x2, $mapHas$1);
              } catch (e2) {
                return true;
              }
            }
            return x2 instanceof $WeakSet;
          } catch (e2) {
          }
          return false;
        };
      } else {
        isWeakset.exports = function isWeakSet2(x2) {
          return false;
        };
      }
      var isWeaksetExports = isWeakset.exports;
      var isMap = isMap$2;
      var isSet = isSet$2;
      var isWeakMap = isWeakmap;
      var isWeakSet = isWeaksetExports;
      var whichCollection$1 = function whichCollection2(value) {
        if (value && typeof value === "object") {
          if (isMap(value)) {
            return "Map";
          }
          if (isSet(value)) {
            return "Set";
          }
          if (isWeakMap(value)) {
            return "WeakMap";
          }
          if (isWeakSet(value)) {
            return "WeakSet";
          }
        }
        return false;
      };
      var forEach = forEach_1;
      var availableTypedArrays = availableTypedArrays$2;
      var callBound$2 = callBound$d;
      var gOPD = gopd;
      var $toString = callBound$2("Object.prototype.toString");
      var hasToStringTag = shams();
      var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound$2("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g[typedArray] === "function") {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e2) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = isTypedArray$2;
      var whichTypedArray$1 = function whichTypedArray2(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
      var callBound$1 = callBound$d;
      var $byteLength = callBound$1("ArrayBuffer.prototype.byteLength", true);
      var isArrayBuffer$1 = isArrayBuffer$2;
      var arrayBufferByteLength = function byteLength2(ab) {
        if (!isArrayBuffer$1(ab)) {
          return NaN;
        }
        return $byteLength ? $byteLength(ab) : ab.byteLength;
      };
      var assign = object_assign;
      var callBound = callBound$d;
      var flags = regexp_prototype_flags;
      var GetIntrinsic = getIntrinsic;
      var getIterator = esGetIteratorExports;
      var getSideChannel = sideChannel;
      var is = objectIs;
      var isArguments = isArguments$2;
      var isArray = isarray;
      var isArrayBuffer = isArrayBuffer$2;
      var isDate = isDateObject;
      var isRegex = isRegex$1;
      var isSharedArrayBuffer = isSharedArrayBuffer$1;
      var objectKeys = objectKeys$2;
      var whichBoxedPrimitive = whichBoxedPrimitive$1;
      var whichCollection = whichCollection$1;
      var whichTypedArray = whichTypedArray$1;
      var byteLength = arrayBufferByteLength;
      var sabByteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
      var $getTime = callBound("Date.prototype.getTime");
      var gPO = Object.getPrototypeOf;
      var $objToString = callBound("Object.prototype.toString");
      var $Set = GetIntrinsic("%Set%", true);
      var $mapHas = callBound("Map.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSize = callBound("Map.prototype.size", true);
      var $setAdd = callBound("Set.prototype.add", true);
      var $setDelete = callBound("Set.prototype.delete", true);
      var $setHas = callBound("Set.prototype.has", true);
      var $setSize = callBound("Set.prototype.size", true);
      function setHasEqualElement(set2, val1, opts, channel2) {
        var i2 = getIterator(set2);
        var result;
        while ((result = i2.next()) && !result.done) {
          if (internalDeepEqual(val1, result.value, opts, channel2)) {
            $setDelete(set2, result.value);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        if (typeof prim === "undefined") {
          return null;
        }
        if (typeof prim === "object") {
          return void 0;
        }
        if (typeof prim === "symbol") {
          return false;
        }
        if (typeof prim === "string" || typeof prim === "number") {
          return +prim === +prim;
        }
        return true;
      }
      function mapMightHaveLoosePrim(a, b2, prim, item, opts, channel2) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = $mapGet(b2, altValue);
        var looseOpts = assign({}, opts, { strict: false });
        if (typeof curB === "undefined" && !$mapHas(b2, altValue) || !internalDeepEqual(item, curB, looseOpts, channel2)) {
          return false;
        }
        return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel2);
      }
      function setMightHaveLoosePrim(a, b2, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        return $setHas(b2, altValue) && !$setHas(a, altValue);
      }
      function mapHasEqualEntry(set2, map, key1, item1, opts, channel2) {
        var i2 = getIterator(set2);
        var result;
        var key2;
        while ((result = i2.next()) && !result.done) {
          key2 = result.value;
          if (
            // eslint-disable-next-line no-use-before-define
            internalDeepEqual(key1, key2, opts, channel2) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel2)
          ) {
            $setDelete(set2, key2);
            return true;
          }
        }
        return false;
      }
      function internalDeepEqual(actual, expected, options, channel2) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        var actualBoxed = whichBoxedPrimitive(actual);
        var expectedBoxed = whichBoxedPrimitive(expected);
        if (actualBoxed !== expectedBoxed) {
          return false;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        var hasActual = channel2.has(actual);
        var hasExpected = channel2.has(expected);
        var sentinel;
        if (hasActual && hasExpected) {
          if (channel2.get(actual) === channel2.get(expected)) {
            return true;
          }
        } else {
          sentinel = {};
        }
        if (!hasActual) {
          channel2.set(actual, sentinel);
        }
        if (!hasExpected) {
          channel2.set(expected, sentinel);
        }
        return objEquiv(actual, expected, opts, channel2);
      }
      function isBuffer(x2) {
        if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
          return false;
        }
        if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
          return false;
        }
        if (x2.length > 0 && typeof x2[0] !== "number") {
          return false;
        }
        return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
      }
      function setEquiv(a, b2, opts, channel2) {
        if ($setSize(a) !== $setSize(b2)) {
          return false;
        }
        var iA = getIterator(a);
        var iB = getIterator(b2);
        var resultA;
        var resultB;
        var set2;
        while ((resultA = iA.next()) && !resultA.done) {
          if (resultA.value && typeof resultA.value === "object") {
            if (!set2) {
              set2 = new $Set();
            }
            $setAdd(set2, resultA.value);
          } else if (!$setHas(b2, resultA.value)) {
            if (opts.strict) {
              return false;
            }
            if (!setMightHaveLoosePrim(a, b2, resultA.value)) {
              return false;
            }
            if (!set2) {
              set2 = new $Set();
            }
            $setAdd(set2, resultA.value);
          }
        }
        if (set2) {
          while ((resultB = iB.next()) && !resultB.done) {
            if (resultB.value && typeof resultB.value === "object") {
              if (!setHasEqualElement(set2, resultB.value, opts.strict, channel2)) {
                return false;
              }
            } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set2, resultB.value, opts.strict, channel2)) {
              return false;
            }
          }
          return $setSize(set2) === 0;
        }
        return true;
      }
      function mapEquiv(a, b2, opts, channel2) {
        if ($mapSize(a) !== $mapSize(b2)) {
          return false;
        }
        var iA = getIterator(a);
        var iB = getIterator(b2);
        var resultA;
        var resultB;
        var set2;
        var key2;
        var item1;
        var item2;
        while ((resultA = iA.next()) && !resultA.done) {
          key2 = resultA.value[0];
          item1 = resultA.value[1];
          if (key2 && typeof key2 === "object") {
            if (!set2) {
              set2 = new $Set();
            }
            $setAdd(set2, key2);
          } else {
            item2 = $mapGet(b2, key2);
            if (typeof item2 === "undefined" && !$mapHas(b2, key2) || !internalDeepEqual(item1, item2, opts, channel2)) {
              if (opts.strict) {
                return false;
              }
              if (!mapMightHaveLoosePrim(a, b2, key2, item1, opts, channel2)) {
                return false;
              }
              if (!set2) {
                set2 = new $Set();
              }
              $setAdd(set2, key2);
            }
          }
        }
        if (set2) {
          while ((resultB = iB.next()) && !resultB.done) {
            key2 = resultB.value[0];
            item2 = resultB.value[1];
            if (key2 && typeof key2 === "object") {
              if (!mapHasEqualEntry(set2, a, key2, item2, opts, channel2)) {
                return false;
              }
            } else if (!opts.strict && (!a.has(key2) || !internalDeepEqual($mapGet(a, key2), item2, opts, channel2)) && !mapHasEqualEntry(set2, a, key2, item2, assign({}, opts, { strict: false }), channel2)) {
              return false;
            }
          }
          return $setSize(set2) === 0;
        }
        return true;
      }
      function objEquiv(a, b2, opts, channel2) {
        var i2, key2;
        if (typeof a !== typeof b2) {
          return false;
        }
        if (a == null || b2 == null) {
          return false;
        }
        if ($objToString(a) !== $objToString(b2)) {
          return false;
        }
        if (isArguments(a) !== isArguments(b2)) {
          return false;
        }
        var aIsArray = isArray(a);
        var bIsArray = isArray(b2);
        if (aIsArray !== bIsArray) {
          return false;
        }
        var aIsError = a instanceof Error;
        var bIsError = b2 instanceof Error;
        if (aIsError !== bIsError) {
          return false;
        }
        if (aIsError || bIsError) {
          if (a.name !== b2.name || a.message !== b2.message) {
            return false;
          }
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b2);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if ((aIsRegex || bIsRegex) && (a.source !== b2.source || flags(a) !== flags(b2))) {
          return false;
        }
        var aIsDate = isDate(a);
        var bIsDate = isDate(b2);
        if (aIsDate !== bIsDate) {
          return false;
        }
        if (aIsDate || bIsDate) {
          if ($getTime(a) !== $getTime(b2)) {
            return false;
          }
        }
        if (opts.strict && gPO && gPO(a) !== gPO(b2)) {
          return false;
        }
        var aWhich = whichTypedArray(a);
        var bWhich = whichTypedArray(b2);
        if ((aWhich || bWhich) && aWhich !== bWhich) {
          return false;
        }
        var aIsBuffer = isBuffer(a);
        var bIsBuffer = isBuffer(b2);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a.length !== b2.length) {
            return false;
          }
          for (i2 = 0; i2 < a.length; i2++) {
            if (a[i2] !== b2[i2]) {
              return false;
            }
          }
          return true;
        }
        var aIsArrayBuffer = isArrayBuffer(a);
        var bIsArrayBuffer = isArrayBuffer(b2);
        if (aIsArrayBuffer !== bIsArrayBuffer) {
          return false;
        }
        if (aIsArrayBuffer || bIsArrayBuffer) {
          if (byteLength(a) !== byteLength(b2)) {
            return false;
          }
          return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b2), opts, channel2);
        }
        var aIsSAB = isSharedArrayBuffer(a);
        var bIsSAB = isSharedArrayBuffer(b2);
        if (aIsSAB !== bIsSAB) {
          return false;
        }
        if (aIsSAB || bIsSAB) {
          if (sabByteLength(a) !== sabByteLength(b2)) {
            return false;
          }
          return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b2), opts, channel2);
        }
        if (typeof a !== typeof b2) {
          return false;
        }
        var ka = objectKeys(a);
        var kb = objectKeys(b2);
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i2 = ka.length - 1; i2 >= 0; i2--) {
          if (ka[i2] != kb[i2]) {
            return false;
          }
        }
        for (i2 = ka.length - 1; i2 >= 0; i2--) {
          key2 = ka[i2];
          if (!internalDeepEqual(a[key2], b2[key2], opts, channel2)) {
            return false;
          }
        }
        var aCollection = whichCollection(a);
        var bCollection = whichCollection(b2);
        if (aCollection !== bCollection) {
          return false;
        }
        if (aCollection === "Set" || bCollection === "Set") {
          return setEquiv(a, b2, opts, channel2);
        }
        if (aCollection === "Map") {
          return mapEquiv(a, b2, opts, channel2);
        }
        return true;
      }
      var deepEqual = function deepEqual2(a, b2, opts) {
        return internalDeepEqual(a, b2, opts, getSideChannel());
      };
      Object.defineProperty(elementRoleMap$1, "__esModule", {
        value: true
      });
      elementRoleMap$1.default = void 0;
      var _deepEqual = _interopRequireDefault$2(deepEqual);
      var _iterationDecorator$1 = _interopRequireDefault$2(iterationDecorator$1);
      var _rolesMap$2 = _interopRequireDefault$2(rolesMap$1);
      function _interopRequireDefault$2(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray$1(arr, i2) {
        return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
      }
      function _nonIterableRest$1() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit$1(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles$1(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper$1(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray$1(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it)
              o2 = it;
            var i2 = 0;
            var F2 = function F3() {
            };
            return { s: F2, n: function n2() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            }, e: function e2(_e2) {
              throw _e2;
            }, f: F2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o2);
        }, n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e2(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f2() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray$1(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$1(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$1(o2, minLen);
      }
      function _arrayLikeToArray$1(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var elementRoles$1 = [];
      var keys$1 = _rolesMap$2.default.keys();
      for (var i$1 = 0; i$1 < keys$1.length; i$1++) {
        var key = keys$1[i$1];
        var role = _rolesMap$2.default.get(key);
        if (role) {
          var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
          for (var k = 0; k < concepts.length; k++) {
            var relation = concepts[k];
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                (function() {
                  var conceptStr = JSON.stringify(concept);
                  var elementRoleRelation = elementRoles$1.find(function(relation2) {
                    return JSON.stringify(relation2[0]) === conceptStr;
                  });
                  var roles2 = void 0;
                  if (elementRoleRelation) {
                    roles2 = elementRoleRelation[1];
                  } else {
                    roles2 = [];
                  }
                  var isUnique = true;
                  for (var _i = 0; _i < roles2.length; _i++) {
                    if (roles2[_i] === key) {
                      isUnique = false;
                      break;
                    }
                  }
                  if (isUnique) {
                    roles2.push(key);
                  }
                  elementRoles$1.push([concept, roles2]);
                })();
              }
            }
          }
        }
      }
      var elementRoleMap = {
        entries: function entries() {
          return elementRoles$1;
        },
        forEach: function forEach2(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper$1(elementRoles$1), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray$1(_step.value, 2), _key = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, _key, elementRoles$1);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = elementRoles$1.find(function(tuple2) {
            return (0, _deepEqual.default)(key2, tuple2[0]);
          });
          return item && item[1];
        },
        has: function has2(key2) {
          return !!elementRoleMap.get(key2);
        },
        keys: function keys2() {
          return elementRoles$1.map(function(_ref) {
            var _ref2 = _slicedToArray$1(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return elementRoles$1.map(function(_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default$1 = (0, _iterationDecorator$1.default)(elementRoleMap, elementRoleMap.entries());
      elementRoleMap$1.default = _default$1;
      var roleElementMap$1 = {};
      Object.defineProperty(roleElementMap$1, "__esModule", {
        value: true
      });
      roleElementMap$1.default = void 0;
      var _iterationDecorator = _interopRequireDefault$1(iterationDecorator$1);
      var _rolesMap$1 = _interopRequireDefault$1(rolesMap$1);
      function _interopRequireDefault$1(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it)
              o2 = it;
            var i2 = 0;
            var F2 = function F3() {
            };
            return { s: F2, n: function n2() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            }, e: function e2(_e2) {
              throw _e2;
            }, f: F2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o2);
        }, n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e2(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f2() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      var roleElement = [];
      var keys = _rolesMap$1.default.keys();
      var _loop = function _loop2(i2) {
        var key2 = keys[i2];
        var role2 = _rolesMap$1.default.get(key2);
        if (role2) {
          var concepts2 = [].concat(role2.baseConcepts, role2.relatedConcepts);
          for (var k2 = 0; k2 < concepts2.length; k2++) {
            var relation2 = concepts2[k2];
            if (relation2.module === "HTML") {
              var concept2 = relation2.concept;
              if (concept2) {
                var roleElementRelation = roleElement.find(function(item) {
                  return item[0] === key2;
                });
                var relationConcepts = void 0;
                if (roleElementRelation) {
                  relationConcepts = roleElementRelation[1];
                } else {
                  relationConcepts = [];
                }
                relationConcepts.push(concept2);
                roleElement.push([key2, relationConcepts]);
              }
            }
          }
        }
      };
      for (var i = 0; i < keys.length; i++) {
        _loop(i);
      }
      var roleElementMap = {
        entries: function entries() {
          return roleElement;
        },
        forEach: function forEach2(fn) {
          var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var _iterator = _createForOfIteratorHelper(roleElement), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
              fn.call(thisArg, values, key2, roleElement);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        },
        get: function get2(key2) {
          var item = roleElement.find(function(tuple2) {
            return tuple2[0] === key2 ? true : false;
          });
          return item && item[1];
        },
        has: function has2(key2) {
          return !!roleElementMap.get(key2);
        },
        keys: function keys2() {
          return roleElement.map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
            return key2;
          });
        },
        values: function values() {
          return roleElement.map(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
            return values2;
          });
        }
      };
      var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
      roleElementMap$1.default = _default;
      Object.defineProperty(lib, "__esModule", {
        value: true
      });
      var roles_1 = lib.roles = roleElements_1 = lib.roleElements = elementRoles_1 = lib.elementRoles = lib.dom = lib.aria = void 0;
      var _ariaPropsMap = _interopRequireDefault(ariaPropsMap$1);
      var _domMap = _interopRequireDefault(domMap$1);
      var _rolesMap = _interopRequireDefault(rolesMap$1);
      var _elementRoleMap = _interopRequireDefault(elementRoleMap$1);
      var _roleElementMap = _interopRequireDefault(roleElementMap$1);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var aria = _ariaPropsMap.default;
      lib.aria = aria;
      var dom = _domMap.default;
      lib.dom = dom;
      var roles = _rolesMap.default;
      roles_1 = lib.roles = roles;
      var elementRoles = _elementRoleMap.default;
      var elementRoles_1 = lib.elementRoles = elementRoles;
      var roleElements = _roleElementMap.default;
      var roleElements_1 = lib.roleElements = roleElements;
      var lzString$1 = { exports: {} };
      lzString$1.exports;
      (function(module2) {
        var LZString = function() {
          var f2 = String.fromCharCode;
          var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
          var baseReverseDic = {};
          function getBaseValue(alphabet, character2) {
            if (!baseReverseDic[alphabet]) {
              baseReverseDic[alphabet] = {};
              for (var i2 = 0; i2 < alphabet.length; i2++) {
                baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
              }
            }
            return baseReverseDic[alphabet][character2];
          }
          var LZString2 = {
            compressToBase64: function(input2) {
              if (input2 == null)
                return "";
              var res = LZString2._compress(input2, 6, function(a) {
                return keyStrBase64.charAt(a);
              });
              switch (res.length % 4) {
                default:
                case 0:
                  return res;
                case 1:
                  return res + "===";
                case 2:
                  return res + "==";
                case 3:
                  return res + "=";
              }
            },
            decompressFromBase64: function(input2) {
              if (input2 == null)
                return "";
              if (input2 == "")
                return null;
              return LZString2._decompress(input2.length, 32, function(index2) {
                return getBaseValue(keyStrBase64, input2.charAt(index2));
              });
            },
            compressToUTF16: function(input2) {
              if (input2 == null)
                return "";
              return LZString2._compress(input2, 15, function(a) {
                return f2(a + 32);
              }) + " ";
            },
            decompressFromUTF16: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 16384, function(index2) {
                return compressed.charCodeAt(index2) - 32;
              });
            },
            //compress into uint8array (UCS-2 big endian format)
            compressToUint8Array: function(uncompressed) {
              var compressed = LZString2.compress(uncompressed);
              var buf = new Uint8Array(compressed.length * 2);
              for (var i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
                var current_value = compressed.charCodeAt(i2);
                buf[i2 * 2] = current_value >>> 8;
                buf[i2 * 2 + 1] = current_value % 256;
              }
              return buf;
            },
            //decompress from uint8array (UCS-2 big endian format)
            decompressFromUint8Array: function(compressed) {
              if (compressed === null || compressed === void 0) {
                return LZString2.decompress(compressed);
              } else {
                var buf = new Array(compressed.length / 2);
                for (var i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++) {
                  buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
                }
                var result = [];
                buf.forEach(function(c2) {
                  result.push(f2(c2));
                });
                return LZString2.decompress(result.join(""));
              }
            },
            //compress into a string that is already URI encoded
            compressToEncodedURIComponent: function(input2) {
              if (input2 == null)
                return "";
              return LZString2._compress(input2, 6, function(a) {
                return keyStrUriSafe.charAt(a);
              });
            },
            //decompress from an output of compressToEncodedURIComponent
            decompressFromEncodedURIComponent: function(input2) {
              if (input2 == null)
                return "";
              if (input2 == "")
                return null;
              input2 = input2.replace(/ /g, "+");
              return LZString2._decompress(input2.length, 32, function(index2) {
                return getBaseValue(keyStrUriSafe, input2.charAt(index2));
              });
            },
            compress: function(uncompressed) {
              return LZString2._compress(uncompressed, 16, function(a) {
                return f2(a);
              });
            },
            _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
              if (uncompressed == null)
                return "";
              var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
              for (ii = 0; ii < uncompressed.length; ii += 1) {
                context_c = uncompressed.charAt(ii);
                if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                  context_dictionary[context_c] = context_dictSize++;
                  context_dictionaryToCreate[context_c] = true;
                }
                context_wc = context_w + context_c;
                if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                  context_w = context_wc;
                } else {
                  if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                    if (context_w.charCodeAt(0) < 256) {
                      for (i2 = 0; i2 < context_numBits; i2++) {
                        context_data_val = context_data_val << 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                      }
                      value = context_w.charCodeAt(0);
                      for (i2 = 0; i2 < 8; i2++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    } else {
                      value = 1;
                      for (i2 = 0; i2 < context_numBits; i2++) {
                        context_data_val = context_data_val << 1 | value;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = 0;
                      }
                      value = context_w.charCodeAt(0);
                      for (i2 = 0; i2 < 16; i2++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    }
                    context_enlargeIn--;
                    if (context_enlargeIn == 0) {
                      context_enlargeIn = Math.pow(2, context_numBits);
                      context_numBits++;
                    }
                    delete context_dictionaryToCreate[context_w];
                  } else {
                    value = context_dictionary[context_w];
                    for (i2 = 0; i2 < context_numBits; i2++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  context_dictionary[context_wc] = context_dictSize++;
                  context_w = String(context_c);
                }
              }
              if (context_w !== "") {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i2 = 0; i2 < context_numBits; i2++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i2 = 0; i2 < 8; i2++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i2 = 0; i2 < context_numBits; i2++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i2 = 0; i2 < 16; i2++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
              }
              value = 2;
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
              while (true) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data.push(getCharFromInt(context_data_val));
                  break;
                } else
                  context_data_position++;
              }
              return context_data.join("");
            },
            decompress: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 32768, function(index2) {
                return compressed.charCodeAt(index2);
              });
            },
            _decompress: function(length2, resetValue, getNextValue) {
              var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w2, bits, resb, maxpower, power, c2, data = { val: getNextValue(0), position: resetValue, index: 1 };
              for (i2 = 0; i2 < 3; i2 += 1) {
                dictionary[i2] = i2;
              }
              bits = 0;
              maxpower = Math.pow(2, 2);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c2 = f2(bits);
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c2 = f2(bits);
                  break;
                case 2:
                  return "";
              }
              dictionary[3] = c2;
              w2 = c2;
              result.push(c2);
              while (true) {
                if (data.index > length2) {
                  return "";
                }
                bits = 0;
                maxpower = Math.pow(2, numBits);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                switch (c2 = bits) {
                  case 0:
                    bits = 0;
                    maxpower = Math.pow(2, 8);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f2(bits);
                    c2 = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 1:
                    bits = 0;
                    maxpower = Math.pow(2, 16);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f2(bits);
                    c2 = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 2:
                    return result.join("");
                }
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
                if (dictionary[c2]) {
                  entry = dictionary[c2];
                } else {
                  if (c2 === dictSize) {
                    entry = w2 + w2.charAt(0);
                  } else {
                    return null;
                  }
                }
                result.push(entry);
                dictionary[dictSize++] = w2 + entry.charAt(0);
                enlargeIn--;
                w2 = entry;
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
              }
            }
          };
          return LZString2;
        }();
        if (module2 != null) {
          module2.exports = LZString;
        } else if (typeof angular !== "undefined" && angular != null) {
          angular.module("LZString", []).factory("LZString", function() {
            return LZString;
          });
        }
      })(lzString$1);
      var lzStringExports = lzString$1.exports;
      const lzString = /* @__PURE__ */ getDefaultExportFromCjs(lzStringExports);
      function escapeHTML(str) {
        return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      const printProps = (keys2, props, config2, indentation, depth, refs, printer2) => {
        const indentationNext = indentation + config2.indent;
        const colors = config2.colors;
        return keys2.map((key2) => {
          const value = props[key2];
          let printed = printer2(value, config2, indentationNext, depth, refs);
          if (typeof value !== "string") {
            if (printed.indexOf("\n") !== -1) {
              printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation;
            }
            printed = "{" + printed + "}";
          }
          return config2.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
        }).join("");
      };
      const NodeTypeTextNode = 3;
      const printChildren = (children, config2, indentation, depth, refs, printer2) => children.map((child) => {
        const printedChild = typeof child === "string" ? printText(child, config2) : printer2(child, config2, indentation, depth, refs);
        if (printedChild === "" && typeof child === "object" && child !== null && child.nodeType !== NodeTypeTextNode) {
          return "";
        }
        return config2.spacingOuter + indentation + printedChild;
      }).join("");
      const printText = (text, config2) => {
        const contentColor = config2.colors.content;
        return contentColor.open + escapeHTML(text) + contentColor.close;
      };
      const printComment = (comment2, config2) => {
        const commentColor = config2.colors.comment;
        return commentColor.open + "<!--" + escapeHTML(comment2) + "-->" + commentColor.close;
      };
      const printElement = (type2, printedProps, printedChildren, config2, indentation) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type2 + (printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config2.spacingOuter + indentation + tagColor.open + "</" + type2 : (printedProps && !config2.min ? "" : " ") + "/") + ">" + tagColor.close;
      };
      const printElementAsLeaf = (type2, config2) => {
        const tagColor = config2.colors.tag;
        return tagColor.open + "<" + type2 + tagColor.close + " …" + tagColor.open + " />" + tagColor.close;
      };
      const ELEMENT_NODE$1 = 1;
      const TEXT_NODE$1 = 3;
      const COMMENT_NODE$1 = 8;
      const FRAGMENT_NODE = 11;
      const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
      const testNode = (val) => {
        const constructorName = val.constructor.name;
        const {
          nodeType,
          tagName
        } = val;
        const isCustomElement = typeof tagName === "string" && tagName.includes("-") || typeof val.hasAttribute === "function" && val.hasAttribute("is");
        return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
      };
      function nodeIsText(node2) {
        return node2.nodeType === TEXT_NODE$1;
      }
      function nodeIsComment(node2) {
        return node2.nodeType === COMMENT_NODE$1;
      }
      function nodeIsFragment(node2) {
        return node2.nodeType === FRAGMENT_NODE;
      }
      function createDOMElementFilter(filterNode) {
        return {
          test: (val) => {
            var _val$constructor2;
            return (val == null ? void 0 : (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) && testNode(val);
          },
          serialize: (node2, config2, indentation, depth, refs, printer2) => {
            if (nodeIsText(node2)) {
              return printText(node2.data, config2);
            }
            if (nodeIsComment(node2)) {
              return printComment(node2.data, config2);
            }
            const type2 = nodeIsFragment(node2) ? "DocumentFragment" : node2.tagName.toLowerCase();
            if (++depth > config2.maxDepth) {
              return printElementAsLeaf(type2, config2);
            }
            return printElement(type2, printProps(nodeIsFragment(node2) ? [] : Array.from(node2.attributes).map((attr) => attr.name).sort(), nodeIsFragment(node2) ? {} : Array.from(node2.attributes).reduce((props, attribute) => {
              props[attribute.name] = attribute.value;
              return props;
            }, {}), config2, indentation + config2.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node2.childNodes || node2.children).filter(filterNode), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation);
          }
        };
      }
      let chalk = null;
      let readFileSync = null;
      let codeFrameColumns = null;
      try {
        const nodeRequire = module && module.require;
        readFileSync = nodeRequire.call(module, "fs").readFileSync;
        codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns;
        chalk = nodeRequire.call(module, "chalk");
      } catch {
      }
      function getCodeFrame(frame) {
        const locationStart = frame.indexOf("(") + 1;
        const locationEnd = frame.indexOf(")");
        const frameLocation = frame.slice(locationStart, locationEnd);
        const frameLocationElements = frameLocation.split(":");
        const [filename, line2, column2] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
        let rawFileContents = "";
        try {
          rawFileContents = readFileSync(filename, "utf-8");
        } catch {
          return "";
        }
        const codeFrame = codeFrameColumns(rawFileContents, {
          start: {
            line: line2,
            column: column2
          }
        }, {
          highlightCode: true,
          linesBelow: 0
        });
        return chalk.dim(frameLocation) + "\n" + codeFrame + "\n";
      }
      function getUserCodeFrame() {
        if (!readFileSync || !codeFrameColumns) {
          return "";
        }
        const err = new Error();
        const firstClientCodeFrame = err.stack.split("\n").slice(1).find((frame) => !frame.includes("node_modules/"));
        return getCodeFrame(firstClientCodeFrame);
      }
      const TEXT_NODE = 3;
      function jestFakeTimersAreEnabled() {
        if (typeof jest !== "undefined" && jest !== null) {
          return (
            // legacy timers
            setTimeout._isMockFunction === true || // modern timers
            // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
            Object.prototype.hasOwnProperty.call(setTimeout, "clock")
          );
        }
        return false;
      }
      function getDocument$1() {
        if (typeof window === "undefined") {
          throw new Error("Could not find default container");
        }
        return window.document;
      }
      function getWindowFromNode(node2) {
        if (node2.defaultView) {
          return node2.defaultView;
        } else if (node2.ownerDocument && node2.ownerDocument.defaultView) {
          return node2.ownerDocument.defaultView;
        } else if (node2.window) {
          return node2.window;
        } else if (node2.ownerDocument && node2.ownerDocument.defaultView === null) {
          throw new Error("It looks like the window object is not available for the provided node.");
        } else if (node2.then instanceof Function) {
          throw new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?");
        } else if (Array.isArray(node2)) {
          throw new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?");
        } else if (typeof node2.debug === "function" && typeof node2.logTestingPlaygroundURL === "function") {
          throw new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?");
        } else {
          throw new Error("The given node is not an Element, the node type is: " + typeof node2 + ".");
        }
      }
      function checkContainerType(container) {
        if (!container || !(typeof container.querySelector === "function") || !(typeof container.querySelectorAll === "function")) {
          throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
        }
        function getTypeName(object2) {
          if (typeof object2 === "object") {
            return object2 === null ? "null" : object2.constructor.name;
          }
          return typeof object2;
        }
      }
      const shouldHighlight = () => {
        let colors;
        try {
          var _process, _process$env;
          colors = JSON.parse((_process = process) == null ? void 0 : (_process$env = _process.env) == null ? void 0 : _process$env.COLORS);
        } catch (e2) {
        }
        if (typeof colors === "boolean") {
          return colors;
        } else {
          return typeof process !== "undefined" && process.versions !== void 0 && process.versions.node !== void 0;
        }
      };
      const {
        DOMCollection
      } = plugins_1;
      const ELEMENT_NODE = 1;
      const COMMENT_NODE = 8;
      function filterCommentsAndDefaultIgnoreTagsTags(value) {
        return value.nodeType !== COMMENT_NODE && (value.nodeType !== ELEMENT_NODE || !value.matches(getConfig().defaultIgnore));
      }
      function prettyDOM(dom2, maxLength, options) {
        if (options === void 0) {
          options = {};
        }
        if (!dom2) {
          dom2 = getDocument$1().body;
        }
        if (typeof maxLength !== "number") {
          maxLength = typeof process !== "undefined" && {}.DEBUG_PRINT_LIMIT || 7e3;
        }
        if (maxLength === 0) {
          return "";
        }
        if (dom2.documentElement) {
          dom2 = dom2.documentElement;
        }
        let domTypeName = typeof dom2;
        if (domTypeName === "object") {
          domTypeName = dom2.constructor.name;
        } else {
          dom2 = {};
        }
        if (!("outerHTML" in dom2)) {
          throw new TypeError("Expected an element or document but got " + domTypeName);
        }
        const {
          filterNode = filterCommentsAndDefaultIgnoreTagsTags,
          ...prettyFormatOptions
        } = options;
        const debugContent = format_1(dom2, {
          plugins: [createDOMElementFilter(filterNode), DOMCollection],
          printFunctionName: false,
          highlight: shouldHighlight(),
          ...prettyFormatOptions
        });
        return maxLength !== void 0 && dom2.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
      }
      const logDOM = function() {
        const userCodeFrame = getUserCodeFrame();
        if (userCodeFrame) {
          console.log(prettyDOM(...arguments) + "\n\n" + userCodeFrame);
        } else {
          console.log(prettyDOM(...arguments));
        }
      };
      let config = {
        testIdAttribute: "data-testid",
        asyncUtilTimeout: 1e3,
        // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
        // forcing react-testing-library to wrap all async functions would've been
        // a total nightmare (consider wrapping every findBy* query and then also
        // updating `within` so those would be wrapped too. Total nightmare).
        // so we have this config option that's really only intended for
        // react-testing-library to use. For that reason, this feature will remain
        // undocumented.
        asyncWrapper: (cb) => cb(),
        unstable_advanceTimersWrapper: (cb) => cb(),
        eventWrapper: (cb) => cb(),
        // default value for the `hidden` option in `ByRole` queries
        defaultHidden: false,
        // default value for the `ignore` option in `ByText` queries
        defaultIgnore: "script, style",
        // showOriginalStackTrace flag to show the full error stack traces for async errors
        showOriginalStackTrace: false,
        // throw errors w/ suggestions for better queries. Opt in so off by default.
        throwSuggestions: false,
        // called when getBy* queries fail. (message, container) => Error
        getElementError(message, container) {
          const prettifiedDOM = prettyDOM(container);
          const error = new Error([message, "Ignored nodes: comments, " + config.defaultIgnore + "\n" + prettifiedDOM].filter(Boolean).join("\n\n"));
          error.name = "TestingLibraryElementError";
          return error;
        },
        _disableExpensiveErrorDiagnostics: false,
        computedStyleSupportsPseudoElements: false
      };
      function runWithExpensiveErrorDiagnosticsDisabled(callback) {
        try {
          config._disableExpensiveErrorDiagnostics = true;
          return callback();
        } finally {
          config._disableExpensiveErrorDiagnostics = false;
        }
      }
      function getConfig() {
        return config;
      }
      const labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
      function getTextContent(node2) {
        if (labelledNodeNames.includes(node2.nodeName.toLowerCase())) {
          return "";
        }
        if (node2.nodeType === TEXT_NODE)
          return node2.textContent;
        return Array.from(node2.childNodes).map((childNode) => getTextContent(childNode)).join("");
      }
      function getLabelContent(element) {
        let textContent;
        if (element.tagName.toLowerCase() === "label") {
          textContent = getTextContent(element);
        } else {
          textContent = element.value || element.textContent;
        }
        return textContent;
      }
      function getRealLabels(element) {
        if (element.labels !== void 0) {
          var _labels;
          return (_labels = element.labels) != null ? _labels : [];
        }
        if (!isLabelable(element))
          return [];
        const labels = element.ownerDocument.querySelectorAll("label");
        return Array.from(labels).filter((label) => label.control === element);
      }
      function isLabelable(element) {
        return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
      }
      function getLabels(container, element, _temp) {
        let {
          selector = "*"
        } = _temp === void 0 ? {} : _temp;
        const ariaLabelledBy = element.getAttribute("aria-labelledby");
        const labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
        return labelsId.length ? labelsId.map((labelId) => {
          const labellingElement = container.querySelector('[id="' + labelId + '"]');
          return labellingElement ? {
            content: getLabelContent(labellingElement),
            formControl: null
          } : {
            content: "",
            formControl: null
          };
        }) : Array.from(getRealLabels(element)).map((label) => {
          const textToMatch = getLabelContent(label);
          const formControlSelector = "button, input, meter, output, progress, select, textarea";
          const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter((formControlElement) => formControlElement.matches(selector))[0];
          return {
            content: textToMatch,
            formControl: labelledFormControl
          };
        });
      }
      function assertNotNullOrUndefined(matcher) {
        if (matcher === null || matcher === void 0) {
          throw new Error(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
            "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
          );
        }
      }
      function fuzzyMatches(textToMatch, node2, matcher, normalizer) {
        if (typeof textToMatch !== "string") {
          return false;
        }
        assertNotNullOrUndefined(matcher);
        const normalizedText = normalizer(textToMatch);
        if (typeof matcher === "string" || typeof matcher === "number") {
          return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
        } else if (typeof matcher === "function") {
          return matcher(normalizedText, node2);
        } else {
          return matchRegExp(matcher, normalizedText);
        }
      }
      function matches(textToMatch, node2, matcher, normalizer) {
        if (typeof textToMatch !== "string") {
          return false;
        }
        assertNotNullOrUndefined(matcher);
        const normalizedText = normalizer(textToMatch);
        if (matcher instanceof Function) {
          return matcher(normalizedText, node2);
        } else if (matcher instanceof RegExp) {
          return matchRegExp(matcher, normalizedText);
        } else {
          return normalizedText === String(matcher);
        }
      }
      function getDefaultNormalizer(_temp) {
        let {
          trim: trim2 = true,
          collapseWhitespace = true
        } = _temp === void 0 ? {} : _temp;
        return (text) => {
          let normalizedText = text;
          normalizedText = trim2 ? normalizedText.trim() : normalizedText;
          normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText;
          return normalizedText;
        };
      }
      function makeNormalizer(_ref) {
        let {
          trim: trim2,
          collapseWhitespace,
          normalizer
        } = _ref;
        if (!normalizer) {
          return getDefaultNormalizer({
            trim: trim2,
            collapseWhitespace
          });
        }
        if (typeof trim2 !== "undefined" || typeof collapseWhitespace !== "undefined") {
          throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
        }
        return normalizer;
      }
      function matchRegExp(matcher, text) {
        const match2 = matcher.test(text);
        if (matcher.global && matcher.lastIndex !== 0) {
          console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.");
          matcher.lastIndex = 0;
        }
        return match2;
      }
      function getNodeText(node2) {
        if (node2.matches("input[type=submit], input[type=button], input[type=reset]")) {
          return node2.value;
        }
        return Array.from(node2.childNodes).filter((child) => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map((c2) => c2.textContent).join("");
      }
      const elementRoleList = buildElementRoleList(elementRoles_1);
      function isSubtreeInaccessible(element) {
        if (element.hidden === true) {
          return true;
        }
        if (element.getAttribute("aria-hidden") === "true") {
          return true;
        }
        const window2 = element.ownerDocument.defaultView;
        if (window2.getComputedStyle(element).display === "none") {
          return true;
        }
        return false;
      }
      function isInaccessible(element, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
        } = options;
        const window2 = element.ownerDocument.defaultView;
        if (window2.getComputedStyle(element).visibility === "hidden") {
          return true;
        }
        let currentElement = element;
        while (currentElement) {
          if (isSubtreeInaccessibleImpl(currentElement)) {
            return true;
          }
          currentElement = currentElement.parentElement;
        }
        return false;
      }
      function getImplicitAriaRoles(currentNode) {
        for (const {
          match: match2,
          roles: roles2
        } of elementRoleList) {
          if (match2(currentNode)) {
            return [...roles2];
          }
        }
        return [];
      }
      function buildElementRoleList(elementRolesMap) {
        function makeElementSelector(_ref) {
          let {
            name,
            attributes: attributes2
          } = _ref;
          return "" + name + attributes2.map((_ref2) => {
            let {
              name: attributeName,
              value,
              constraints = []
            } = _ref2;
            const shouldNotExist = constraints.indexOf("undefined") !== -1;
            if (shouldNotExist) {
              return ":not([" + attributeName + "])";
            } else if (value) {
              return "[" + attributeName + '="' + value + '"]';
            } else {
              return "[" + attributeName + "]";
            }
          }).join("");
        }
        function getSelectorSpecificity(_ref3) {
          let {
            attributes: attributes2 = []
          } = _ref3;
          return attributes2.length;
        }
        function bySelectorSpecificity(_ref4, _ref5) {
          let {
            specificity: leftSpecificity
          } = _ref4;
          let {
            specificity: rightSpecificity
          } = _ref5;
          return rightSpecificity - leftSpecificity;
        }
        function match2(element) {
          let {
            attributes: attributes2 = []
          } = element;
          const typeTextIndex = attributes2.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
          if (typeTextIndex >= 0) {
            attributes2 = [...attributes2.slice(0, typeTextIndex), ...attributes2.slice(typeTextIndex + 1)];
          }
          const selector = makeElementSelector({
            ...element,
            attributes: attributes2
          });
          return (node2) => {
            if (typeTextIndex >= 0 && node2.type !== "text") {
              return false;
            }
            return node2.matches(selector);
          };
        }
        let result = [];
        for (const [element, roles2] of elementRolesMap.entries()) {
          result = [...result, {
            match: match2(element),
            roles: Array.from(roles2),
            specificity: getSelectorSpecificity(element)
          }];
        }
        return result.sort(bySelectorSpecificity);
      }
      function getRoles(container, _temp) {
        let {
          hidden = false
        } = _temp === void 0 ? {} : _temp;
        function flattenDOM(node2) {
          return [node2, ...Array.from(node2.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
        }
        return flattenDOM(container).filter((element) => {
          return hidden === false ? isInaccessible(element) === false : true;
        }).reduce((acc, node2) => {
          let roles2 = [];
          if (node2.hasAttribute("role")) {
            roles2 = node2.getAttribute("role").split(" ").slice(0, 1);
          } else {
            roles2 = getImplicitAriaRoles(node2);
          }
          return roles2.reduce((rolesAcc, role2) => Array.isArray(rolesAcc[role2]) ? {
            ...rolesAcc,
            [role2]: [...rolesAcc[role2], node2]
          } : {
            ...rolesAcc,
            [role2]: [node2]
          }, acc);
        }, {});
      }
      function prettyRoles(dom2, _ref6) {
        let {
          hidden,
          includeDescription
        } = _ref6;
        const roles2 = getRoles(dom2, {
          hidden
        });
        return Object.entries(roles2).filter((_ref7) => {
          let [role2] = _ref7;
          return role2 !== "generic";
        }).map((_ref8) => {
          let [role2, elements] = _ref8;
          const delimiterBar = "-".repeat(50);
          const elementsString = elements.map((el) => {
            const nameString = 'Name "' + computeAccessibleName(el, {
              computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
            }) + '":\n';
            const domString = prettyDOM(el.cloneNode(false));
            if (includeDescription) {
              const descriptionString = 'Description "' + computeAccessibleDescription(el, {
                computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
              }) + '":\n';
              return "" + nameString + descriptionString + domString;
            }
            return "" + nameString + domString;
          }).join("\n\n");
          return role2 + ":\n\n" + elementsString + "\n\n" + delimiterBar;
        }).join("\n");
      }
      function computeAriaSelected(element) {
        if (element.tagName === "OPTION") {
          return element.selected;
        }
        return checkBooleanAttribute(element, "aria-selected");
      }
      function computeAriaBusy(element) {
        return element.getAttribute("aria-busy") === "true";
      }
      function computeAriaChecked(element) {
        if ("indeterminate" in element && element.indeterminate) {
          return void 0;
        }
        if ("checked" in element) {
          return element.checked;
        }
        return checkBooleanAttribute(element, "aria-checked");
      }
      function computeAriaPressed(element) {
        return checkBooleanAttribute(element, "aria-pressed");
      }
      function computeAriaCurrent(element) {
        var _ref9, _checkBooleanAttribut;
        return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
      }
      function computeAriaExpanded(element) {
        return checkBooleanAttribute(element, "aria-expanded");
      }
      function checkBooleanAttribute(element, attribute) {
        const attributeValue = element.getAttribute(attribute);
        if (attributeValue === "true") {
          return true;
        }
        if (attributeValue === "false") {
          return false;
        }
        return void 0;
      }
      function computeHeadingLevel(element) {
        const implicitHeadingLevels = {
          H1: 1,
          H2: 2,
          H3: 3,
          H4: 4,
          H5: 5,
          H6: 6
        };
        const ariaLevelAttribute = element.getAttribute("aria-level") && Number(element.getAttribute("aria-level"));
        return ariaLevelAttribute || implicitHeadingLevels[element.tagName];
      }
      function computeAriaValueNow(element) {
        const valueNow = element.getAttribute("aria-valuenow");
        return valueNow === null ? void 0 : +valueNow;
      }
      function computeAriaValueMax(element) {
        const valueMax = element.getAttribute("aria-valuemax");
        return valueMax === null ? void 0 : +valueMax;
      }
      function computeAriaValueMin(element) {
        const valueMin = element.getAttribute("aria-valuemin");
        return valueMin === null ? void 0 : +valueMin;
      }
      function computeAriaValueText(element) {
        const valueText = element.getAttribute("aria-valuetext");
        return valueText === null ? void 0 : valueText;
      }
      const normalize = getDefaultNormalizer();
      function escapeRegExp(string2) {
        return string2.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
      }
      function getRegExpMatcher(string2) {
        return new RegExp(escapeRegExp(string2.toLowerCase()), "i");
      }
      function makeSuggestion(queryName, element, content, _ref) {
        let {
          variant,
          name
        } = _ref;
        let warning2 = "";
        const queryOptions = {};
        const queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
        if (name) {
          queryOptions.name = getRegExpMatcher(name);
        }
        if (queryName === "Role" && isInaccessible(element)) {
          queryOptions.hidden = true;
          warning2 = "Element is inaccessible. This means that the element and all its children are invisible to screen readers.\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\n    ";
        }
        if (Object.keys(queryOptions).length > 0) {
          queryArgs.push(queryOptions);
        }
        const queryMethod = variant + "By" + queryName;
        return {
          queryName,
          queryMethod,
          queryArgs,
          variant,
          warning: warning2,
          toString() {
            if (warning2) {
              console.warn(warning2);
            }
            let [text, options] = queryArgs;
            text = typeof text === "string" ? "'" + text + "'" : text;
            options = options ? ", { " + Object.entries(options).map((_ref2) => {
              let [k2, v2] = _ref2;
              return k2 + ": " + v2;
            }).join(", ") + " }" : "";
            return queryMethod + "(" + text + options + ")";
          }
        };
      }
      function canSuggest(currentMethod, requestedMethod, data) {
        return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
      }
      function getSuggestedQuery(element, variant, method2) {
        var _element$getAttribute, _getImplicitAriaRoles;
        if (variant === void 0) {
          variant = "get";
        }
        if (element.matches(getConfig().defaultIgnore)) {
          return void 0;
        }
        const role2 = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles(element)) == null ? void 0 : _getImplicitAriaRoles[0];
        if (role2 !== "generic" && canSuggest("Role", method2, role2)) {
          return makeSuggestion("Role", element, role2, {
            variant,
            name: computeAccessibleName(element, {
              computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
            })
          });
        }
        const labelText = getLabels(document, element).map((label) => label.content).join(" ");
        if (canSuggest("LabelText", method2, labelText)) {
          return makeSuggestion("LabelText", element, labelText, {
            variant
          });
        }
        const placeholderText = element.getAttribute("placeholder");
        if (canSuggest("PlaceholderText", method2, placeholderText)) {
          return makeSuggestion("PlaceholderText", element, placeholderText, {
            variant
          });
        }
        const textContent = normalize(getNodeText(element));
        if (canSuggest("Text", method2, textContent)) {
          return makeSuggestion("Text", element, textContent, {
            variant
          });
        }
        if (canSuggest("DisplayValue", method2, element.value)) {
          return makeSuggestion("DisplayValue", element, normalize(element.value), {
            variant
          });
        }
        const alt = element.getAttribute("alt");
        if (canSuggest("AltText", method2, alt)) {
          return makeSuggestion("AltText", element, alt, {
            variant
          });
        }
        const title = element.getAttribute("title");
        if (canSuggest("Title", method2, title)) {
          return makeSuggestion("Title", element, title, {
            variant
          });
        }
        const testId = element.getAttribute(getConfig().testIdAttribute);
        if (canSuggest("TestId", method2, testId)) {
          return makeSuggestion("TestId", element, testId, {
            variant
          });
        }
        return void 0;
      }
      function copyStackTrace(target, source) {
        target.stack = source.stack.replace(source.message, target.message);
      }
      function waitFor(callback, _ref) {
        let {
          container = getDocument$1(),
          timeout = getConfig().asyncUtilTimeout,
          showOriginalStackTrace = getConfig().showOriginalStackTrace,
          stackTraceError,
          interval = 50,
          onTimeout = (error) => {
            error.message = getConfig().getElementError(error.message, container).message;
            return error;
          },
          mutationObserverOptions = {
            subtree: true,
            childList: true,
            attributes: true,
            characterData: true
          }
        } = _ref;
        if (typeof callback !== "function") {
          throw new TypeError("Received `callback` arg must be a function");
        }
        return new Promise(async (resolve, reject) => {
          let lastError, intervalId, observer;
          let finished = false;
          let promiseStatus = "idle";
          const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
          const usingJestFakeTimers = jestFakeTimersAreEnabled();
          if (usingJestFakeTimers) {
            const {
              unstable_advanceTimersWrapper: advanceTimersWrapper
            } = getConfig();
            checkCallback();
            while (!finished) {
              if (!jestFakeTimersAreEnabled()) {
                const error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
                if (!showOriginalStackTrace)
                  copyStackTrace(error, stackTraceError);
                reject(error);
                return;
              }
              await advanceTimersWrapper(async () => {
                jest.advanceTimersByTime(interval);
              });
              checkCallback();
              if (finished) {
                break;
              }
            }
          } else {
            try {
              checkContainerType(container);
            } catch (e2) {
              reject(e2);
              return;
            }
            intervalId = setInterval(checkRealTimersCallback, interval);
            const {
              MutationObserver: MutationObserver2
            } = getWindowFromNode(container);
            observer = new MutationObserver2(checkRealTimersCallback);
            observer.observe(container, mutationObserverOptions);
            checkCallback();
          }
          function onDone(error, result) {
            finished = true;
            clearTimeout(overallTimeoutTimer);
            if (!usingJestFakeTimers) {
              clearInterval(intervalId);
              observer.disconnect();
            }
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          }
          function checkRealTimersCallback() {
            if (jestFakeTimersAreEnabled()) {
              const error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
              if (!showOriginalStackTrace)
                copyStackTrace(error, stackTraceError);
              return reject(error);
            } else {
              return checkCallback();
            }
          }
          function checkCallback() {
            if (promiseStatus === "pending")
              return;
            try {
              const result = runWithExpensiveErrorDiagnosticsDisabled(callback);
              if (typeof (result == null ? void 0 : result.then) === "function") {
                promiseStatus = "pending";
                result.then((resolvedValue) => {
                  promiseStatus = "resolved";
                  onDone(null, resolvedValue);
                }, (rejectedValue) => {
                  promiseStatus = "rejected";
                  lastError = rejectedValue;
                });
              } else {
                onDone(null, result);
              }
            } catch (error) {
              lastError = error;
            }
          }
          function handleTimeout() {
            let error;
            if (lastError) {
              error = lastError;
              if (!showOriginalStackTrace && error.name === "TestingLibraryElementError") {
                copyStackTrace(error, stackTraceError);
              }
            } else {
              error = new Error("Timed out in waitFor.");
              if (!showOriginalStackTrace) {
                copyStackTrace(error, stackTraceError);
              }
            }
            onDone(onTimeout(error), null);
          }
        });
      }
      function waitForWrapper(callback, options) {
        const stackTraceError = new Error("STACK_TRACE_MESSAGE");
        return getConfig().asyncWrapper(() => waitFor(callback, {
          stackTraceError,
          ...options
        }));
      }
      function getElementError(message, container) {
        return getConfig().getElementError(message, container);
      }
      function getMultipleElementsFoundError(message, container) {
        return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
      }
      function queryAllByAttribute(attribute, container, text, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim: trim2,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node2) => matcher(node2.getAttribute(attribute), node2, text, matchNormalizer));
      }
      function makeSingleQuery(allQuery, getMultipleError2) {
        return function(container) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          const els = allQuery(container, ...args);
          if (els.length > 1) {
            const elementStrings = els.map((element) => getElementError(null, element).message).join("\n\n");
            throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + "\n\nHere are the matching elements:\n\n" + elementStrings, container);
          }
          return els[0] || null;
        };
      }
      function getSuggestionError(suggestion, container) {
        return getConfig().getElementError("A better query is available, try this:\n" + suggestion.toString() + "\n", container);
      }
      function makeGetAllQuery(allQuery, getMissingError2) {
        return function(container) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          const els = allQuery(container, ...args);
          if (!els.length) {
            throw getConfig().getElementError(getMissingError2(container, ...args), container);
          }
          return els;
        };
      }
      function makeFindQuery(getter) {
        return (container, text, options, waitForOptions) => {
          return waitForWrapper(() => {
            return getter(container, text, options);
          }, {
            container,
            ...waitForOptions
          });
        };
      }
      const wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        const element = query(container, ...args);
        const [{
          suggest = getConfig().throwSuggestions
        } = {}] = args.slice(-1);
        if (element && suggest) {
          const suggestion = getSuggestedQuery(element, variant);
          if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {
            throw getSuggestionError(suggestion.toString(), container);
          }
        }
        return element;
      };
      const wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        const els = query(container, ...args);
        const [{
          suggest = getConfig().throwSuggestions
        } = {}] = args.slice(-1);
        if (els.length && suggest) {
          const uniqueSuggestionMessages = [...new Set(els.map((element) => {
            var _getSuggestedQuery;
            return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
          }))];
          if (
            // only want to suggest if all the els have the same suggestion.
            uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
              getSuggestedQuery(els[0], variant).queryName
            )
          ) {
            throw getSuggestionError(uniqueSuggestionMessages[0], container);
          }
        }
        return els;
      };
      function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
        const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query");
        const getAllBy = makeGetAllQuery(queryAllBy, getMissingError2);
        const getBy = makeSingleQuery(getAllBy, getMultipleError2);
        const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get");
        const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll");
        const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll"));
        const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
        return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
      }
      function queryAllLabels(container) {
        return Array.from(container.querySelectorAll("label,input")).map((node2) => {
          return {
            node: node2,
            textToMatch: getLabelContent(node2)
          };
        }).filter((_ref) => {
          let {
            textToMatch
          } = _ref;
          return textToMatch !== null;
        });
      }
      const queryAllLabelsByText = function(container, text, _temp) {
        let {
          exact = true,
          trim: trim2,
          collapseWhitespace,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        const textToMatchByLabels = queryAllLabels(container);
        return textToMatchByLabels.filter((_ref2) => {
          let {
            node: node2,
            textToMatch
          } = _ref2;
          return matcher(textToMatch, node2, text, matchNormalizer);
        }).map((_ref3) => {
          let {
            node: node2
          } = _ref3;
          return node2;
        });
      };
      const queryAllByLabelText = function(container, text, _temp2) {
        let {
          selector = "*",
          exact = true,
          collapseWhitespace,
          trim: trim2,
          normalizer
        } = _temp2 === void 0 ? {} : _temp2;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        const matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => {
          return getRealLabels(element).length || element.hasAttribute("aria-labelledby");
        }).reduce((labelledElements, labelledElement) => {
          const labelList = getLabels(container, labelledElement, {
            selector
          });
          labelList.filter((label) => Boolean(label.formControl)).forEach((label) => {
            if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {
              labelledElements.push(label.formControl);
            }
          });
          const labelsValue = labelList.filter((label) => Boolean(label.content)).map((label) => label.content);
          if (matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer)) {
            labelledElements.push(labelledElement);
          }
          if (labelsValue.length > 1) {
            labelsValue.forEach((labelValue, index2) => {
              if (matcher(labelValue, labelledElement, text, matchNormalizer)) {
                labelledElements.push(labelledElement);
              }
              const labelsFiltered = [...labelsValue];
              labelsFiltered.splice(index2, 1);
              if (labelsFiltered.length > 1) {
                if (matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer)) {
                  labelledElements.push(labelledElement);
                }
              }
            });
          }
          return labelledElements;
        }, []).concat(queryAllByAttribute("aria-label", container, text, {
          exact,
          normalizer: matchNormalizer
        }));
        return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
      };
      const getAllByLabelText = function(container, text) {
        for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          rest[_key - 2] = arguments[_key];
        }
        const els = queryAllByLabelText(container, text, ...rest);
        if (!els.length) {
          const labels = queryAllLabelsByText(container, text, ...rest);
          if (labels.length) {
            const tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
            if (tagNames.length) {
              throw getConfig().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join("\n\n"), container);
            } else {
              throw getConfig().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
            }
          } else {
            throw getConfig().getElementError("Unable to find a label with the text of: " + text, container);
          }
        }
        return els;
      };
      function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
        const htmlFor = label.getAttribute("for");
        if (!htmlFor) {
          return null;
        }
        const element = container.querySelector('[id="' + htmlFor + '"]');
        return element ? element.tagName.toLowerCase() : null;
      }
      const getMultipleError$7 = (c2, text) => "Found multiple elements with the text of: " + text;
      const queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query");
      const getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);
      const findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll"));
      const findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find"));
      const getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll");
      const getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get");
      const queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll");
      const queryAllByPlaceholderText = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        checkContainerType(args[0]);
        return queryAllByAttribute("placeholder", ...args);
      };
      const getMultipleError$6 = (c2, text) => "Found multiple elements with the placeholder text of: " + text;
      const getMissingError$6 = (c2, text) => "Unable to find an element with the placeholder text of: " + text;
      const queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll");
      const [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);
      const queryAllByText = function(container, text, _temp) {
        let {
          selector = "*",
          exact = true,
          collapseWhitespace,
          trim: trim2,
          ignore = getConfig().defaultIgnore,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        let baseArray = [];
        if (typeof container.matches === "function" && container.matches(selector)) {
          baseArray = [container];
        }
        return [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node2) => !ignore || !node2.matches(ignore)).filter((node2) => matcher(getNodeText(node2), node2, text, matchNormalizer));
      };
      const getMultipleError$5 = (c2, text) => "Found multiple elements with the text: " + text;
      const getMissingError$5 = function(c2, text, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          collapseWhitespace,
          trim: trim2,
          normalizer,
          selector
        } = options;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        const normalizedText = matchNormalizer(text.toString());
        const isNormalizedDifferent = normalizedText !== text.toString();
        const isCustomSelector = (selector != null ? selector : "*") !== "*";
        return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
      };
      const queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll");
      const [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);
      const queryAllByDisplayValue = function(container, value, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim: trim2,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        return Array.from(container.querySelectorAll("input,textarea,select")).filter((node2) => {
          if (node2.tagName === "SELECT") {
            const selectedOptions = Array.from(node2.options).filter((option) => option.selected);
            return selectedOptions.some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));
          } else {
            return matcher(node2.value, node2, value, matchNormalizer);
          }
        });
      };
      const getMultipleError$4 = (c2, value) => "Found multiple elements with the display value: " + value + ".";
      const getMissingError$4 = (c2, value) => "Unable to find an element with the display value: " + value + ".";
      const queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll");
      const [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);
      const VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;
      const queryAllByAltText = function(container, alt, options) {
        if (options === void 0) {
          options = {};
        }
        checkContainerType(container);
        return queryAllByAttribute("alt", container, alt, options).filter((node2) => VALID_TAG_REGEXP.test(node2.tagName));
      };
      const getMultipleError$3 = (c2, alt) => "Found multiple elements with the alt text: " + alt;
      const getMissingError$3 = (c2, alt) => "Unable to find an element with the alt text: " + alt;
      const queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll");
      const [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);
      const isSvgTitle = (node2) => {
        var _node$parentElement;
        return node2.tagName.toLowerCase() === "title" && ((_node$parentElement = node2.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
      };
      const queryAllByTitle = function(container, text, _temp) {
        let {
          exact = true,
          collapseWhitespace,
          trim: trim2,
          normalizer
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        const matcher = exact ? matches : fuzzyMatches;
        const matchNormalizer = makeNormalizer({
          collapseWhitespace,
          trim: trim2,
          normalizer
        });
        return Array.from(container.querySelectorAll("[title], svg > title")).filter((node2) => matcher(node2.getAttribute("title"), node2, text, matchNormalizer) || isSvgTitle(node2) && matcher(getNodeText(node2), node2, text, matchNormalizer));
      };
      const getMultipleError$2 = (c2, title) => "Found multiple elements with the title: " + title + ".";
      const getMissingError$2 = (c2, title) => "Unable to find an element with the title: " + title + ".";
      const queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll");
      const [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);
      const queryAllByRole = function(container, role2, _temp) {
        let {
          hidden = getConfig().defaultHidden,
          name,
          description,
          queryFallbacks = false,
          selected,
          busy,
          checked,
          pressed,
          current,
          level,
          expanded,
          value: {
            now: valueNow,
            min: valueMin,
            max: valueMax,
            text: valueText
          } = {}
        } = _temp === void 0 ? {} : _temp;
        checkContainerType(container);
        if (selected !== void 0) {
          var _allRoles$get;
          if (((_allRoles$get = roles_1.get(role2)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0) {
            throw new Error('"aria-selected" is not supported on role "' + role2 + '".');
          }
        }
        if (busy !== void 0) {
          var _allRoles$get2;
          if (((_allRoles$get2 = roles_1.get(role2)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0) {
            throw new Error('"aria-busy" is not supported on role "' + role2 + '".');
          }
        }
        if (checked !== void 0) {
          var _allRoles$get3;
          if (((_allRoles$get3 = roles_1.get(role2)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0) {
            throw new Error('"aria-checked" is not supported on role "' + role2 + '".');
          }
        }
        if (pressed !== void 0) {
          var _allRoles$get4;
          if (((_allRoles$get4 = roles_1.get(role2)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0) {
            throw new Error('"aria-pressed" is not supported on role "' + role2 + '".');
          }
        }
        if (current !== void 0) {
          var _allRoles$get5;
          if (((_allRoles$get5 = roles_1.get(role2)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0) {
            throw new Error('"aria-current" is not supported on role "' + role2 + '".');
          }
        }
        if (level !== void 0) {
          if (role2 !== "heading") {
            throw new Error('Role "' + role2 + '" cannot have "level" property.');
          }
        }
        if (valueNow !== void 0) {
          var _allRoles$get6;
          if (((_allRoles$get6 = roles_1.get(role2)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0) {
            throw new Error('"aria-valuenow" is not supported on role "' + role2 + '".');
          }
        }
        if (valueMax !== void 0) {
          var _allRoles$get7;
          if (((_allRoles$get7 = roles_1.get(role2)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0) {
            throw new Error('"aria-valuemax" is not supported on role "' + role2 + '".');
          }
        }
        if (valueMin !== void 0) {
          var _allRoles$get8;
          if (((_allRoles$get8 = roles_1.get(role2)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0) {
            throw new Error('"aria-valuemin" is not supported on role "' + role2 + '".');
          }
        }
        if (valueText !== void 0) {
          var _allRoles$get9;
          if (((_allRoles$get9 = roles_1.get(role2)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0) {
            throw new Error('"aria-valuetext" is not supported on role "' + role2 + '".');
          }
        }
        if (expanded !== void 0) {
          var _allRoles$get10;
          if (((_allRoles$get10 = roles_1.get(role2)) == null ? void 0 : _allRoles$get10.props["aria-expanded"]) === void 0) {
            throw new Error('"aria-expanded" is not supported on role "' + role2 + '".');
          }
        }
        const subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
        function cachedIsSubtreeInaccessible(element) {
          if (!subtreeIsInaccessibleCache.has(element)) {
            subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));
          }
          return subtreeIsInaccessibleCache.get(element);
        }
        return Array.from(container.querySelectorAll(
          // Only query elements that can be matched by the following filters
          makeRoleSelector(role2)
        )).filter((node2) => {
          const isRoleSpecifiedExplicitly = node2.hasAttribute("role");
          if (isRoleSpecifiedExplicitly) {
            const roleValue = node2.getAttribute("role");
            if (queryFallbacks) {
              return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role2);
            }
            const [firstRoleAttributeToken] = roleValue.split(" ");
            return firstRoleAttributeToken === role2;
          }
          const implicitRoles = getImplicitAriaRoles(node2);
          return implicitRoles.some((implicitRole) => {
            return implicitRole === role2;
          });
        }).filter((element) => {
          if (selected !== void 0) {
            return selected === computeAriaSelected(element);
          }
          if (busy !== void 0) {
            return busy === computeAriaBusy(element);
          }
          if (checked !== void 0) {
            return checked === computeAriaChecked(element);
          }
          if (pressed !== void 0) {
            return pressed === computeAriaPressed(element);
          }
          if (current !== void 0) {
            return current === computeAriaCurrent(element);
          }
          if (expanded !== void 0) {
            return expanded === computeAriaExpanded(element);
          }
          if (level !== void 0) {
            return level === computeHeadingLevel(element);
          }
          if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
            let valueMatches = true;
            if (valueNow !== void 0) {
              valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));
            }
            if (valueMax !== void 0) {
              valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));
            }
            if (valueMin !== void 0) {
              valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));
            }
            if (valueText !== void 0) {
              var _computeAriaValueText;
              valueMatches && (valueMatches = matches((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
            }
            return valueMatches;
          }
          return true;
        }).filter((element) => {
          if (name === void 0) {
            return true;
          }
          return matches(computeAccessibleName(element, {
            computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
          }), element, name, (text) => text);
        }).filter((element) => {
          if (description === void 0) {
            return true;
          }
          return matches(computeAccessibleDescription(element, {
            computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements
          }), element, description, (text) => text);
        }).filter((element) => {
          return hidden === false ? isInaccessible(element, {
            isSubtreeInaccessible: cachedIsSubtreeInaccessible
          }) === false : true;
        });
      };
      function makeRoleSelector(role2) {
        var _roleElements$get;
        const explicitRoleSelector = '*[role~="' + role2 + '"]';
        const roleRelations = (_roleElements$get = roleElements_1.get(role2)) != null ? _roleElements$get : /* @__PURE__ */ new Set();
        const implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
          let {
            name
          } = _ref;
          return name;
        }));
        return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
      }
      const getNameHint = (name) => {
        let nameHint = "";
        if (name === void 0) {
          nameHint = "";
        } else if (typeof name === "string") {
          nameHint = ' and name "' + name + '"';
        } else {
          nameHint = " and name `" + name + "`";
        }
        return nameHint;
      };
      const getMultipleError$1 = function(c2, role2, _temp2) {
        let {
          name
        } = _temp2 === void 0 ? {} : _temp2;
        return 'Found multiple elements with the role "' + role2 + '"' + getNameHint(name);
      };
      const getMissingError$1 = function(container, role2, _temp3) {
        let {
          hidden = getConfig().defaultHidden,
          name,
          description
        } = _temp3 === void 0 ? {} : _temp3;
        if (getConfig()._disableExpensiveErrorDiagnostics) {
          return 'Unable to find role="' + role2 + '"' + getNameHint(name);
        }
        let roles2 = "";
        Array.from(container.children).forEach((childElement) => {
          roles2 += prettyRoles(childElement, {
            hidden,
            includeDescription: description !== void 0
          });
        });
        let roleMessage;
        if (roles2.length === 0) {
          if (hidden === false) {
            roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole";
          } else {
            roleMessage = "There are no available roles.";
          }
        } else {
          roleMessage = ("\nHere are the " + (hidden === false ? "accessible" : "available") + " roles:\n\n  " + roles2.replace(/\n/g, "\n  ").replace(/\n\s\s\n/g, "\n\n") + "\n").trim();
        }
        let nameHint = "";
        if (name === void 0) {
          nameHint = "";
        } else if (typeof name === "string") {
          nameHint = ' and name "' + name + '"';
        } else {
          nameHint = " and name `" + name + "`";
        }
        let descriptionHint = "";
        if (description === void 0) {
          descriptionHint = "";
        } else if (typeof description === "string") {
          descriptionHint = ' and description "' + description + '"';
        } else {
          descriptionHint = " and description `" + description + "`";
        }
        return ("\nUnable to find an " + (hidden === false ? "accessible " : "") + 'element with the role "' + role2 + '"' + nameHint + descriptionHint + "\n\n" + roleMessage).trim();
      };
      const queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll");
      const [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);
      const getTestIdAttribute = () => getConfig().testIdAttribute;
      const queryAllByTestId = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        checkContainerType(args[0]);
        return queryAllByAttribute(getTestIdAttribute(), ...args);
      };
      const getMultipleError = (c2, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]';
      const getMissingError = (c2, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]';
      const queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll");
      const [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);
      var queries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        queryAllByLabelText: queryAllByLabelTextWithSuggestions,
        queryByLabelText,
        getAllByLabelText: getAllByLabelTextWithSuggestions,
        getByLabelText: getByLabelTextWithSuggestions,
        findAllByLabelText,
        findByLabelText,
        queryByPlaceholderText,
        queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
        getByPlaceholderText,
        getAllByPlaceholderText,
        findAllByPlaceholderText,
        findByPlaceholderText,
        queryByText,
        queryAllByText: queryAllByTextWithSuggestions,
        getByText,
        getAllByText,
        findAllByText,
        findByText,
        queryByDisplayValue,
        queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
        getByDisplayValue,
        getAllByDisplayValue,
        findAllByDisplayValue,
        findByDisplayValue,
        queryByAltText,
        queryAllByAltText: queryAllByAltTextWithSuggestions,
        getByAltText,
        getAllByAltText,
        findAllByAltText,
        findByAltText,
        queryByTitle,
        queryAllByTitle: queryAllByTitleWithSuggestions,
        getByTitle,
        getAllByTitle,
        findAllByTitle,
        findByTitle,
        queryByRole,
        queryAllByRole: queryAllByRoleWithSuggestions,
        getAllByRole,
        getByRole,
        findAllByRole,
        findByRole,
        queryByTestId,
        queryAllByTestId: queryAllByTestIdWithSuggestions,
        getByTestId,
        getAllByTestId,
        findAllByTestId,
        findByTestId
      });
      function getQueriesForElement(element, queries$1, initialValue2) {
        if (queries$1 === void 0) {
          queries$1 = queries;
        }
        if (initialValue2 === void 0) {
          initialValue2 = {};
        }
        return Object.keys(queries$1).reduce((helpers2, key2) => {
          const fn = queries$1[key2];
          helpers2[key2] = fn.bind(null, element);
          return helpers2;
        }, initialValue2);
      }
      const eventMap$3 = {
        // Clipboard Events
        copy: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        cut: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        paste: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Composition Events
        compositionEnd: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionStart: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionUpdate: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Keyboard Events
        keyDown: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyPress: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyUp: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        // Focus Events
        focus: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        blur: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        focusIn: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        focusOut: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // Form Events
        change: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        input: {
          EventType: "InputEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        invalid: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: true
          }
        },
        submit: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        reset: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        // Mouse Events
        click: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            button: 0,
            composed: true
          }
        },
        contextMenu: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dblClick: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drag: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragEnd: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragEnter: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragExit: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragLeave: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragOver: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragStart: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drop: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseDown: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseEnter: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseLeave: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseMove: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOut: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOver: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseUp: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Selection Events
        select: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Touch Events
        touchCancel: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        touchEnd: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchMove: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchStart: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // UI Events
        resize: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        scroll: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Wheel Events
        wheel: {
          EventType: "WheelEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Media Events
        abort: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlay: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlayThrough: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        durationChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        emptied: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        encrypted: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        ended: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedData: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedMetadata: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadStart: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pause: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        play: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        playing: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        progress: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        rateChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeked: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeking: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        stalled: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        suspend: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        timeUpdate: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        volumeChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        waiting: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Events
        load: {
          // TODO: load events can be UIEvent or Event depending on what generated them
          // This is where this abstraction breaks down.
          // But the common targets are <img />, <script /> and window.
          // Neither of these targets receive a UIEvent
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        error: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Animation Events
        animationStart: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationEnd: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationIteration: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Transition Events
        transitionCancel: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionEnd: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        transitionRun: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionStart: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // pointer events
        pointerOver: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerEnter: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pointerDown: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerMove: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerUp: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerCancel: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        pointerOut: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerLeave: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        gotPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        lostPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // history events
        popState: {
          EventType: "PopStateEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // window events
        offline: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        online: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        }
      };
      const eventAliasMap$1 = {
        doubleClick: "dblClick"
      };
      Object.keys(eventMap$3).forEach((key2) => {
        key2.toLowerCase();
      });
      Object.keys(eventAliasMap$1).forEach((aliasKey) => {
      });
      function unindent(string2) {
        return string2.replace(/[ \t]*[\n][ \t]*/g, "\n");
      }
      function encode(value) {
        return lzString.compressToEncodedURIComponent(unindent(value));
      }
      function getPlaygroundUrl(markup2) {
        return "https://testing-playground.com/#markup=" + encode(markup2);
      }
      const debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options);
      const logTestingPlaygroundURL = function(element) {
        if (element === void 0) {
          element = getDocument$1().body;
        }
        if (!element || !("innerHTML" in element)) {
          console.log("The element you're providing isn't a valid DOM element.");
          return;
        }
        if (!element.innerHTML) {
          console.log("The provided element doesn't have any children.");
          return;
        }
        const playgroundUrl = getPlaygroundUrl(element.innerHTML);
        console.log("Open this URL in your browser\n\n" + playgroundUrl);
        return playgroundUrl;
      };
      const initialValue = {
        debug,
        logTestingPlaygroundURL
      };
      typeof document !== "undefined" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers2, key2) => {
        helpers2[key2] = () => {
          throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
        };
        return helpers2;
      }, initialValue);
      function wrapEvent(cb, _element) {
        return getConfig().eventWrapper(cb);
      }
      function focusElement(element) {
        const target = findClosest(element, isFocusable);
        const activeElement = getActiveElement(element.ownerDocument);
        if ((target !== null && target !== void 0 ? target : element.ownerDocument.body) === activeElement) {
          return;
        } else if (target) {
          wrapEvent(() => target.focus());
        } else {
          wrapEvent(() => {
            var ref;
            return (ref = activeElement) === null || ref === void 0 ? void 0 : ref.blur();
          });
        }
        updateSelectionOnFocus(target !== null && target !== void 0 ? target : element.ownerDocument.body);
      }
      function blurElement(element) {
        if (!isFocusable(element))
          return;
        const wasActive = getActiveElement(element.ownerDocument) === element;
        if (!wasActive)
          return;
        wrapEvent(() => element.blur());
      }
      const behavior = {};
      behavior.click = (event, target, instance) => {
        const context = target.closest("button,input,label,select,textarea");
        const control = context && isElementType(context, "label") && context.control;
        if (control) {
          return () => {
            if (isFocusable(control)) {
              focusElement(control);
            }
            instance.dispatchEvent(control, cloneEvent(event));
          };
        } else if (isElementType(target, "input", {
          type: "file"
        })) {
          return () => {
            blurElement(target);
            target.dispatchEvent(new (getWindow(target)).Event("fileDialog"));
            focusElement(target);
          };
        }
      };
      const UIValue = Symbol("Displayed value in UI");
      const UISelection = Symbol("Displayed selection in UI");
      const InitialValue = Symbol("Initial value to compare on blur");
      function isUIValue(value) {
        return typeof value === "object" && UIValue in value;
      }
      function isUISelectionStart(start) {
        return !!start && typeof start === "object" && UISelection in start;
      }
      function setUIValue(element, value) {
        if (element[InitialValue] === void 0) {
          element[InitialValue] = element.value;
        }
        element[UIValue] = value;
        element.value = Object.assign(new String(value), {
          [UIValue]: true
        });
      }
      function getUIValue(element) {
        return element[UIValue] === void 0 ? element.value : String(element[UIValue]);
      }
      function setUIValueClean(element) {
        element[UIValue] = void 0;
      }
      function clearInitialValue(element) {
        element[InitialValue] = void 0;
      }
      function getInitialValue(element) {
        return element[InitialValue];
      }
      function setUISelectionRaw(element, selection) {
        element[UISelection] = selection;
      }
      function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = "replace") {
        const valueLength = getUIValue(element).length;
        const sanitizeOffset = (o2) => Math.max(0, Math.min(valueLength, o2));
        const anchorOffset = mode === "replace" || element[UISelection] === void 0 ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;
        const focusOffset = sanitizeOffset(focusOffsetParam);
        const startOffset = Math.min(anchorOffset, focusOffset);
        const endOffset = Math.max(anchorOffset, focusOffset);
        element[UISelection] = {
          anchorOffset,
          focusOffset
        };
        if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {
          return;
        }
        const startObj = Object.assign(new Number(startOffset), {
          [UISelection]: true
        });
        try {
          element.setSelectionRange(startObj, endOffset);
        } catch {
        }
      }
      function getUISelection(element) {
        var _selectionStart, _selectionEnd, _UISelection;
        const sel = (_UISelection = element[UISelection]) !== null && _UISelection !== void 0 ? _UISelection : {
          anchorOffset: (_selectionStart = element.selectionStart) !== null && _selectionStart !== void 0 ? _selectionStart : 0,
          focusOffset: (_selectionEnd = element.selectionEnd) !== null && _selectionEnd !== void 0 ? _selectionEnd : 0
        };
        return {
          ...sel,
          startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
          endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
        };
      }
      function hasUISelection(element) {
        return !!element[UISelection];
      }
      function setUISelectionClean(element) {
        element[UISelection] = void 0;
      }
      const parseInt$1 = globalThis.parseInt;
      function buildTimeValue(value) {
        const onlyDigitsValue = value.replace(/\D/g, "");
        if (onlyDigitsValue.length < 2) {
          return value;
        }
        const firstDigit = parseInt$1(onlyDigitsValue[0], 10);
        const secondDigit = parseInt$1(onlyDigitsValue[1], 10);
        if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
          let index2;
          if (firstDigit >= 3) {
            index2 = 1;
          } else {
            index2 = 2;
          }
          return build(onlyDigitsValue, index2);
        }
        if (value.length === 2) {
          return value;
        }
        return build(onlyDigitsValue, 2);
      }
      function build(onlyDigitsValue, index2) {
        const hours = onlyDigitsValue.slice(0, index2);
        const validHours = Math.min(parseInt$1(hours, 10), 23);
        const minuteCharacters = onlyDigitsValue.slice(index2);
        const parsedMinutes = parseInt$1(minuteCharacters, 10);
        const validMinutes = Math.min(parsedMinutes, 59);
        return `${validHours.toString().padStart(2, "0")}:${validMinutes.toString().padStart(2, "0")}`;
      }
      function isValidDateOrTimeValue(element, value) {
        const clone = element.cloneNode();
        clone.value = value;
        return clone.value === value;
      }
      function getNextCursorPosition(node2, offset2, direction, inputType) {
        if (isTextNode(node2) && offset2 + direction >= 0 && offset2 + direction <= node2.nodeValue.length) {
          return {
            node: node2,
            offset: offset2 + direction
          };
        }
        const nextNode = getNextCharacterContentNode(node2, offset2, direction);
        if (nextNode) {
          if (isTextNode(nextNode)) {
            return {
              node: nextNode,
              offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
            };
          } else if (isElementType(nextNode, "br")) {
            const nextPlusOne = getNextCharacterContentNode(nextNode, void 0, direction);
            if (!nextPlusOne) {
              if (direction < 0 && inputType === "deleteContentBackward") {
                return {
                  node: nextNode.parentNode,
                  offset: getOffset(nextNode)
                };
              }
              return void 0;
            } else if (isTextNode(nextPlusOne)) {
              return {
                node: nextPlusOne,
                offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
              };
            } else if (direction < 0 && isElementType(nextPlusOne, "br")) {
              return {
                node: nextNode.parentNode,
                offset: getOffset(nextNode)
              };
            } else {
              return {
                node: nextPlusOne.parentNode,
                offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
              };
            }
          } else {
            return {
              node: nextNode.parentNode,
              offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
            };
          }
        }
      }
      function getNextCharacterContentNode(node2, offset2, direction) {
        const nextOffset = Number(offset2) + (direction < 0 ? -1 : 0);
        if (offset2 !== void 0 && isElement(node2) && nextOffset >= 0 && nextOffset < node2.children.length) {
          node2 = node2.children[nextOffset];
        }
        return walkNodes(node2, direction === 1 ? "next" : "previous", isTreatedAsCharacterContent);
      }
      function isTreatedAsCharacterContent(node2) {
        if (isTextNode(node2)) {
          return true;
        }
        if (isElement(node2)) {
          if (isElementType(node2, [
            "input",
            "textarea"
          ])) {
            return node2.type !== "hidden";
          } else if (isElementType(node2, "br")) {
            return true;
          }
        }
        return false;
      }
      function getOffset(node2) {
        let i2 = 0;
        while (node2.previousSibling) {
          i2++;
          node2 = node2.previousSibling;
        }
        return i2;
      }
      function isElement(node2) {
        return node2.nodeType === 1;
      }
      function isTextNode(node2) {
        return node2.nodeType === 3;
      }
      function walkNodes(node2, direction, callback) {
        for (; ; ) {
          var ref;
          const sibling = node2[`${direction}Sibling`];
          if (sibling) {
            node2 = getDescendant(sibling, direction === "next" ? "first" : "last");
            if (callback(node2)) {
              return node2;
            }
          } else if (node2.parentNode && (!isElement(node2.parentNode) || !isContentEditable(node2.parentNode) && node2.parentNode !== ((ref = node2.ownerDocument) === null || ref === void 0 ? void 0 : ref.body))) {
            node2 = node2.parentNode;
          } else {
            break;
          }
        }
      }
      function getDescendant(node2, direction) {
        while (node2.hasChildNodes()) {
          node2 = node2[`${direction}Child`];
        }
        return node2;
      }
      const TrackChanges = Symbol("Track programmatic changes for React workaround");
      function isReact17Element(element) {
        return Object.getOwnPropertyNames(element).some((k2) => k2.startsWith("__react")) && getWindow(element).REACT_VERSION === 17;
      }
      function startTrackValue(element) {
        if (!isReact17Element(element)) {
          return;
        }
        element[TrackChanges] = {
          previousValue: String(element.value),
          tracked: []
        };
      }
      function trackOrSetValue(element, v2) {
        var ref, ref1;
        (ref = element[TrackChanges]) === null || ref === void 0 ? void 0 : (ref1 = ref.tracked) === null || ref1 === void 0 ? void 0 : ref1.push(v2);
        if (!element[TrackChanges]) {
          setUIValueClean(element);
          setUISelection(element, {
            focusOffset: v2.length
          });
        }
      }
      function commitValueAfterInput(element, cursorOffset) {
        var ref;
        const changes = element[TrackChanges];
        element[TrackChanges] = void 0;
        if (!(changes === null || changes === void 0 ? void 0 : (ref = changes.tracked) === null || ref === void 0 ? void 0 : ref.length)) {
          return;
        }
        const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
        if (!isJustReactStateUpdate) {
          setUIValueClean(element);
        }
        if (hasUISelection(element)) {
          setUISelection(element, {
            focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length
          });
        }
      }
      function getTargetTypeAndSelection(node2) {
        const element = getElement(node2);
        if (element && hasOwnSelection(element)) {
          return {
            type: "input",
            selection: getUISelection(element)
          };
        }
        const selection = element === null || element === void 0 ? void 0 : element.ownerDocument.getSelection();
        const isCE = getContentEditable(node2) && (selection === null || selection === void 0 ? void 0 : selection.anchorNode) && getContentEditable(selection.anchorNode);
        return {
          type: isCE ? "contenteditable" : "default",
          selection
        };
      }
      function getElement(node2) {
        return node2.nodeType === 1 ? node2 : node2.parentElement;
      }
      function getInputRange(focusNode) {
        const typeAndSelection = getTargetTypeAndSelection(focusNode);
        if (typeAndSelection.type === "input") {
          return typeAndSelection.selection;
        } else if (typeAndSelection.type === "contenteditable") {
          var ref;
          return (ref = typeAndSelection.selection) === null || ref === void 0 ? void 0 : ref.getRangeAt(0);
        }
      }
      function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
        var ref, ref1;
        const typeAndSelection = getTargetTypeAndSelection(focusNode);
        if (typeAndSelection.type === "input") {
          return setUISelection(focusNode, {
            anchorOffset,
            focusOffset
          });
        }
        (ref1 = (ref = anchorNode.ownerDocument) === null || ref === void 0 ? void 0 : ref.getSelection()) === null || ref1 === void 0 ? void 0 : ref1.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function isDateOrTime(element) {
        return isElementType(element, "input") && [
          "date",
          "time"
        ].includes(element.type);
      }
      function input(instance, element, data, inputType = "insertText") {
        const inputRange = getInputRange(element);
        if (!inputRange) {
          return;
        }
        if (!isDateOrTime(element)) {
          const unprevented = instance.dispatchUIEvent(element, "beforeinput", {
            inputType,
            data
          });
          if (!unprevented) {
            return;
          }
        }
        if ("startContainer" in inputRange) {
          editContenteditable(instance, element, inputRange, data, inputType);
        } else {
          editInputElement(instance, element, inputRange, data, inputType);
        }
      }
      function editContenteditable(instance, element, inputRange, data, inputType) {
        let del = false;
        if (!inputRange.collapsed) {
          del = true;
          inputRange.deleteContents();
        } else if ([
          "deleteContentBackward",
          "deleteContentForward"
        ].includes(inputType)) {
          const nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === "deleteContentBackward" ? -1 : 1, inputType);
          if (nextPosition) {
            del = true;
            const delRange = inputRange.cloneRange();
            if (delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0) {
              delRange.setStart(nextPosition.node, nextPosition.offset);
            } else {
              delRange.setEnd(nextPosition.node, nextPosition.offset);
            }
            delRange.deleteContents();
          }
        }
        if (data) {
          if (inputRange.endContainer.nodeType === 3) {
            const offset2 = inputRange.endOffset;
            inputRange.endContainer.insertData(offset2, data);
            inputRange.setStart(inputRange.endContainer, offset2 + data.length);
            inputRange.setEnd(inputRange.endContainer, offset2 + data.length);
          } else {
            const text = element.ownerDocument.createTextNode(data);
            inputRange.insertNode(text);
            inputRange.setStart(text, data.length);
            inputRange.setEnd(text, data.length);
          }
        }
        if (del || data) {
          instance.dispatchUIEvent(element, "input", {
            inputType
          });
        }
      }
      function editInputElement(instance, element, inputRange, data, inputType) {
        let dataToInsert = data;
        if (supportsMaxLength(element)) {
          const maxLength = getMaxLength(element);
          if (maxLength !== void 0 && data.length > 0) {
            const spaceUntilMaxLength = maxLength - element.value.length;
            if (spaceUntilMaxLength > 0) {
              dataToInsert = data.substring(0, spaceUntilMaxLength);
            } else {
              return;
            }
          }
        }
        const { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
        if (newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset) {
          return;
        }
        if (isElementType(element, "input", {
          type: "number"
        }) && !isValidNumberInput(newValue)) {
          return;
        }
        setUIValue(element, newValue);
        setSelection({
          focusNode: element,
          anchorOffset: newOffset,
          focusOffset: newOffset
        });
        if (isDateOrTime(element)) {
          if (isValidDateOrTimeValue(element, newValue)) {
            commitInput(instance, element, newOffset, {});
            instance.dispatchUIEvent(element, "change");
            clearInitialValue(element);
          }
        } else {
          commitInput(instance, element, newOffset, {
            data,
            inputType
          });
        }
      }
      function calculateNewValue(inputData, node2, { startOffset, endOffset }, inputType) {
        const value = getUIValue(node2);
        const prologEnd = Math.max(0, startOffset === endOffset && inputType === "deleteContentBackward" ? startOffset - 1 : startOffset);
        const prolog = value.substring(0, prologEnd);
        const epilogStart = Math.min(value.length, startOffset === endOffset && inputType === "deleteContentForward" ? startOffset + 1 : endOffset);
        const epilog = value.substring(epilogStart, value.length);
        let newValue = `${prolog}${inputData}${epilog}`;
        let newOffset = prologEnd + inputData.length;
        if (isElementType(node2, "input", {
          type: "time"
        })) {
          const builtValue = buildTimeValue(newValue);
          if (builtValue !== "" && isValidDateOrTimeValue(node2, builtValue)) {
            newValue = builtValue;
            newOffset = builtValue.length;
          }
        }
        return {
          oldValue: value,
          newValue,
          newOffset
        };
      }
      function commitInput(instance, element, newOffset, inputInit) {
        instance.dispatchUIEvent(element, "input", inputInit);
        commitValueAfterInput(element, newOffset);
      }
      function isValidNumberInput(value) {
        var ref, ref1;
        const valueParts = value.split("e", 2);
        return !(/[^\d.\-e]/.test(value) || Number((ref = value.match(/-/g)) === null || ref === void 0 ? void 0 : ref.length) > 2 || Number((ref1 = value.match(/\./g)) === null || ref1 === void 0 ? void 0 : ref1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
      }
      behavior.cut = (event, target, instance) => {
        return () => {
          if (isEditable(target)) {
            input(instance, target, "", "deleteByCut");
          }
        };
      };
      function getValueOrTextContent(element) {
        if (!element) {
          return null;
        }
        if (isContentEditable(element)) {
          return element.textContent;
        }
        return getUIValue(element);
      }
      function isVisible(element) {
        const window2 = getWindow(element);
        for (let el = element; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement) {
          const { display, visibility } = window2.getComputedStyle(el);
          if (display === "none") {
            return false;
          }
          if (visibility === "hidden") {
            return false;
          }
        }
        return true;
      }
      function getTabDestination(activeElement, shift) {
        const document2 = activeElement.ownerDocument;
        const focusableElements = document2.querySelectorAll(FOCUSABLE_SELECTOR);
        const enabledElements = Array.from(focusableElements).filter((el) => el === activeElement || !(Number(el.getAttribute("tabindex")) < 0 || isDisabled(el)));
        if (Number(activeElement.getAttribute("tabindex")) >= 0) {
          enabledElements.sort((a, b2) => {
            const i2 = Number(a.getAttribute("tabindex"));
            const j = Number(b2.getAttribute("tabindex"));
            if (i2 === j) {
              return 0;
            } else if (i2 === 0) {
              return 1;
            } else if (j === 0) {
              return -1;
            }
            return i2 - j;
          });
        }
        const checkedRadio = {};
        let prunedElements = [
          document2.body
        ];
        const activeRadioGroup = isElementType(activeElement, "input", {
          type: "radio"
        }) ? activeElement.name : void 0;
        enabledElements.forEach((currentElement) => {
          const el = currentElement;
          if (isElementType(el, "input", {
            type: "radio"
          }) && el.name) {
            if (el === activeElement) {
              prunedElements.push(el);
              return;
            } else if (el.name === activeRadioGroup) {
              return;
            }
            if (el.checked) {
              prunedElements = prunedElements.filter((e2) => !isElementType(e2, "input", {
                type: "radio",
                name: el.name
              }));
              prunedElements.push(el);
              checkedRadio[el.name] = el;
              return;
            }
            if (typeof checkedRadio[el.name] !== "undefined") {
              return;
            }
          }
          prunedElements.push(el);
        });
        for (let index2 = prunedElements.findIndex((el) => el === activeElement); ; ) {
          index2 += shift ? -1 : 1;
          if (index2 === prunedElements.length) {
            index2 = 0;
          } else if (index2 === -1) {
            index2 = prunedElements.length - 1;
          }
          if (prunedElements[index2] === activeElement || prunedElements[index2] === document2.body || isVisible(prunedElements[index2])) {
            return prunedElements[index2];
          }
        }
      }
      function moveSelection(node2, direction) {
        if (hasOwnSelection(node2)) {
          const selection = getUISelection(node2);
          setSelection({
            focusNode: node2,
            focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
          });
        } else {
          const selection1 = node2.ownerDocument.getSelection();
          if (!(selection1 === null || selection1 === void 0 ? void 0 : selection1.focusNode)) {
            return;
          }
          if (selection1.isCollapsed) {
            const nextPosition = getNextCursorPosition(selection1.focusNode, selection1.focusOffset, direction);
            if (nextPosition) {
              setSelection({
                focusNode: nextPosition.node,
                focusOffset: nextPosition.offset
              });
            }
          } else {
            selection1[direction < 0 ? "collapseToStart" : "collapseToEnd"]();
          }
        }
      }
      function selectAll(target) {
        if (hasOwnSelection(target)) {
          return setSelection({
            focusNode: target,
            anchorOffset: 0,
            focusOffset: getUIValue(target).length
          });
        }
        var ref;
        const focusNode = (ref = getContentEditable(target)) !== null && ref !== void 0 ? ref : target.ownerDocument.body;
        setSelection({
          focusNode,
          anchorOffset: 0,
          focusOffset: focusNode.childNodes.length
        });
      }
      function isAllSelected(target) {
        if (hasOwnSelection(target)) {
          return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
        }
        var ref;
        const focusNode = (ref = getContentEditable(target)) !== null && ref !== void 0 ? ref : target.ownerDocument.body;
        const selection = target.ownerDocument.getSelection();
        return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
      }
      function setSelectionRange(element, anchorOffset, focusOffset) {
        var ref;
        if (hasOwnSelection(element)) {
          return setSelection({
            focusNode: element,
            anchorOffset,
            focusOffset
          });
        }
        if (isContentEditable(element) && ((ref = element.firstChild) === null || ref === void 0 ? void 0 : ref.nodeType) === 3) {
          return setSelection({
            focusNode: element.firstChild,
            anchorOffset,
            focusOffset
          });
        }
        throw new Error("Not implemented. The result of this interaction is unreliable.");
      }
      function walkRadio(instance, el, direction) {
        const window2 = getWindow(el);
        const group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window2.CSS.escape(el.name)}"]` : `input[type="radio"][name=""], input[type="radio"]:not([name])`));
        for (let i2 = group.findIndex((e2) => e2 === el) + direction; ; i2 += direction) {
          if (!group[i2]) {
            i2 = direction > 0 ? 0 : group.length - 1;
          }
          if (group[i2] === el) {
            return;
          }
          if (isDisabled(group[i2])) {
            continue;
          }
          focusElement(group[i2]);
          instance.dispatchUIEvent(group[i2], "click");
        }
      }
      behavior.keydown = (event, target, instance) => {
        var ref;
        var ref1;
        return (ref1 = (ref = keydownBehavior[event.key]) === null || ref === void 0 ? void 0 : ref.call(keydownBehavior, event, target, instance)) !== null && ref1 !== void 0 ? ref1 : combinationBehavior(event, target, instance);
      };
      const keydownBehavior = {
        ArrowDown: (event, target, instance) => {
          if (isElementType(target, "input", {
            type: "radio"
          })) {
            return () => walkRadio(instance, target, -1);
          }
        },
        ArrowLeft: (event, target, instance) => {
          if (isElementType(target, "input", {
            type: "radio"
          })) {
            return () => walkRadio(instance, target, -1);
          }
          return () => moveSelection(target, -1);
        },
        ArrowRight: (event, target, instance) => {
          if (isElementType(target, "input", {
            type: "radio"
          })) {
            return () => walkRadio(instance, target, 1);
          }
          return () => moveSelection(target, 1);
        },
        ArrowUp: (event, target, instance) => {
          if (isElementType(target, "input", {
            type: "radio"
          })) {
            return () => walkRadio(instance, target, 1);
          }
        },
        Backspace: (event, target, instance) => {
          if (isEditable(target)) {
            return () => {
              input(instance, target, "", "deleteContentBackward");
            };
          }
        },
        Delete: (event, target, instance) => {
          if (isEditable(target)) {
            return () => {
              input(instance, target, "", "deleteContentForward");
            };
          }
        },
        End: (event, target) => {
          if (isElementType(target, [
            "input",
            "textarea"
          ]) || isContentEditable(target)) {
            return () => {
              var ref;
              var ref1;
              const newPos = (ref1 = (ref = getValueOrTextContent(target)) === null || ref === void 0 ? void 0 : ref.length) !== null && ref1 !== void 0 ? ref1 : (
                /* istanbul ignore next */
                0
              );
              setSelectionRange(target, newPos, newPos);
            };
          }
        },
        Home: (event, target) => {
          if (isElementType(target, [
            "input",
            "textarea"
          ]) || isContentEditable(target)) {
            return () => {
              setSelectionRange(target, 0, 0);
            };
          }
        },
        PageDown: (event, target) => {
          if (isElementType(target, [
            "input"
          ])) {
            return () => {
              const newPos = getUIValue(target).length;
              setSelectionRange(target, newPos, newPos);
            };
          }
        },
        PageUp: (event, target) => {
          if (isElementType(target, [
            "input"
          ])) {
            return () => {
              setSelectionRange(target, 0, 0);
            };
          }
        },
        Tab: (event, target, instance) => {
          return () => {
            const dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
            focusElement(dest);
            if (hasOwnSelection(dest)) {
              setUISelection(dest, {
                anchorOffset: 0,
                focusOffset: dest.value.length
              });
            }
          };
        }
      };
      const combinationBehavior = (event, target, instance) => {
        if (event.code === "KeyA" && instance.system.keyboard.modifiers.Control) {
          return () => selectAll(target);
        }
      };
      behavior.keypress = (event, target, instance) => {
        if (event.key === "Enter") {
          if (isElementType(target, "button") || isElementType(target, "input") && ClickInputOnEnter.includes(target.type) || isElementType(target, "a") && Boolean(target.href)) {
            return () => {
              instance.dispatchUIEvent(target, "click");
            };
          } else if (isElementType(target, "input")) {
            const form = target.form;
            const submit = form === null || form === void 0 ? void 0 : form.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
            if (submit) {
              return () => instance.dispatchUIEvent(submit, "click");
            } else if (form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll("input").length === 1) {
              return () => instance.dispatchUIEvent(form, "submit");
            } else {
              return;
            }
          }
        }
        if (isEditable(target)) {
          const inputType = event.key === "Enter" ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText";
          const inputData = event.key === "Enter" ? "\n" : event.key;
          return () => input(instance, target, inputData, inputType);
        }
      };
      const ClickInputOnEnter = [
        "button",
        "color",
        "file",
        "image",
        "reset",
        "submit"
      ];
      const SubmitSingleInputOnEnter = [
        "email",
        "month",
        "password",
        "search",
        "tel",
        "text",
        "url",
        "week"
      ];
      behavior.keyup = (event, target, instance) => {
        var ref;
        return (ref = keyupBehavior[event.key]) === null || ref === void 0 ? void 0 : ref.call(keyupBehavior, event, target, instance);
      };
      const keyupBehavior = {
        " ": (event, target, instance) => {
          if (isClickableInput(target)) {
            return () => instance.dispatchUIEvent(target, "click");
          }
        }
      };
      behavior.paste = (event, target, instance) => {
        if (isEditable(target)) {
          return () => {
            var ref;
            const insertData = (ref = event.clipboardData) === null || ref === void 0 ? void 0 : ref.getData("text");
            if (insertData) {
              input(instance, target, insertData, "insertFromPaste");
            }
          };
        }
      };
      var eventMap$2 = {};
      Object.defineProperty(eventMap$2, "__esModule", {
        value: true
      });
      var eventMap_2 = eventMap$2.eventMap = eventMap$2.eventAliasMap = void 0;
      const eventMap$1 = {
        // Clipboard Events
        copy: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        cut: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        paste: {
          EventType: "ClipboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Composition Events
        compositionEnd: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionStart: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        compositionUpdate: {
          EventType: "CompositionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Keyboard Events
        keyDown: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyPress: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        keyUp: {
          EventType: "KeyboardEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            charCode: 0,
            composed: true
          }
        },
        // Focus Events
        focus: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        blur: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        focusIn: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        focusOut: {
          EventType: "FocusEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // Form Events
        change: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        input: {
          EventType: "InputEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        invalid: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: true
          }
        },
        submit: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        reset: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        // Mouse Events
        click: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            button: 0,
            composed: true
          }
        },
        contextMenu: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dblClick: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drag: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragEnd: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragEnter: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragExit: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragLeave: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        dragOver: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        dragStart: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        drop: {
          EventType: "DragEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseDown: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseEnter: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseLeave: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false,
            composed: true
          }
        },
        mouseMove: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOut: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseOver: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        mouseUp: {
          EventType: "MouseEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Selection Events
        select: {
          EventType: "Event",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Touch Events
        touchCancel: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        touchEnd: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchMove: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        touchStart: {
          EventType: "TouchEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // UI Events
        resize: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        scroll: {
          EventType: "UIEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Wheel Events
        wheel: {
          EventType: "WheelEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        // Media Events
        abort: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlay: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        canPlayThrough: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        durationChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        emptied: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        encrypted: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        ended: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedData: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadedMetadata: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        loadStart: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pause: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        play: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        playing: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        progress: {
          EventType: "ProgressEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        rateChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeked: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        seeking: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        stalled: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        suspend: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        timeUpdate: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        volumeChange: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        waiting: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Events
        load: {
          // TODO: load events can be UIEvent or Event depending on what generated them
          // This is where this abstraction breaks down.
          // But the common targets are <img />, <script /> and window.
          // Neither of these targets receive a UIEvent
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        error: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        // Animation Events
        animationStart: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationEnd: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        animationIteration: {
          EventType: "AnimationEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // Transition Events
        transitionCancel: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionEnd: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true
          }
        },
        transitionRun: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        transitionStart: {
          EventType: "TransitionEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // pointer events
        pointerOver: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerEnter: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        pointerDown: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerMove: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerUp: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerCancel: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        pointerOut: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        pointerLeave: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        gotPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        lostPointerCapture: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        },
        // history events
        popState: {
          EventType: "PopStateEvent",
          defaultInit: {
            bubbles: true,
            cancelable: false
          }
        },
        // window events
        offline: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        },
        online: {
          EventType: "Event",
          defaultInit: {
            bubbles: false,
            cancelable: false
          }
        }
      };
      eventMap_2 = eventMap$2.eventMap = eventMap$1;
      const eventAliasMap = {
        doubleClick: "dblClick"
      };
      eventMap$2.eventAliasMap = eventAliasMap;
      const eventMap = {
        ...eventMap_2,
        click: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        auxclick: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        contextmenu: {
          EventType: "PointerEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        },
        beforeInput: {
          EventType: "InputEvent",
          defaultInit: {
            bubbles: true,
            cancelable: true,
            composed: true
          }
        }
      };
      const eventMapKeys = Object.fromEntries(Object.keys(eventMap).map((k2) => [
        k2.toLowerCase(),
        k2
      ]));
      function getEventClass(type2) {
        const k2 = eventMapKeys[type2];
        return k2 && eventMap[k2].EventType;
      }
      const mouseEvents = [
        "MouseEvent",
        "PointerEvent"
      ];
      function isMouseEvent(type2) {
        return mouseEvents.includes(getEventClass(type2));
      }
      function isKeyboardEvent(type2) {
        return getEventClass(type2) === "KeyboardEvent";
      }
      const eventInitializer = {
        ClipboardEvent: [
          initClipboardEvent
        ],
        InputEvent: [
          initUIEvent,
          initInputEvent
        ],
        MouseEvent: [
          initUIEvent,
          initUIEventModififiers,
          initMouseEvent
        ],
        PointerEvent: [
          initUIEvent,
          initUIEventModififiers,
          initMouseEvent,
          initPointerEvent
        ],
        KeyboardEvent: [
          initUIEvent,
          initUIEventModififiers,
          initKeyboardEvent
        ]
      };
      function createEvent(type2, target, init) {
        var ref;
        const window2 = getWindow(target);
        const { EventType, defaultInit } = eventMap[eventMapKeys[type2]];
        const event = new (getEventConstructors(window2))[EventType](type2, defaultInit);
        (ref = eventInitializer[EventType]) === null || ref === void 0 ? void 0 : ref.forEach((f2) => f2(event, init !== null && init !== void 0 ? init : {}));
        return event;
      }
      function getEventConstructors(window2) {
        var _Event;
        const Event = (_Event = window2.Event) !== null && _Event !== void 0 ? _Event : class Event {
        };
        var _AnimationEvent;
        const AnimationEvent = (_AnimationEvent = window2.AnimationEvent) !== null && _AnimationEvent !== void 0 ? _AnimationEvent : class AnimationEvent extends Event {
        };
        var _ClipboardEvent;
        const ClipboardEvent = (_ClipboardEvent = window2.ClipboardEvent) !== null && _ClipboardEvent !== void 0 ? _ClipboardEvent : class ClipboardEvent extends Event {
        };
        var _PopStateEvent;
        const PopStateEvent = (_PopStateEvent = window2.PopStateEvent) !== null && _PopStateEvent !== void 0 ? _PopStateEvent : class PopStateEvent extends Event {
        };
        var _ProgressEvent;
        const ProgressEvent = (_ProgressEvent = window2.ProgressEvent) !== null && _ProgressEvent !== void 0 ? _ProgressEvent : class ProgressEvent extends Event {
        };
        var _TransitionEvent;
        const TransitionEvent = (_TransitionEvent = window2.TransitionEvent) !== null && _TransitionEvent !== void 0 ? _TransitionEvent : class TransitionEvent extends Event {
        };
        var _UIEvent;
        const UIEvent = (_UIEvent = window2.UIEvent) !== null && _UIEvent !== void 0 ? _UIEvent : class UIEvent extends Event {
        };
        var _CompositionEvent;
        const CompositionEvent = (_CompositionEvent = window2.CompositionEvent) !== null && _CompositionEvent !== void 0 ? _CompositionEvent : class CompositionEvent extends UIEvent {
        };
        var _FocusEvent;
        const FocusEvent = (_FocusEvent = window2.FocusEvent) !== null && _FocusEvent !== void 0 ? _FocusEvent : class FocusEvent extends UIEvent {
        };
        var _InputEvent;
        const InputEvent = (_InputEvent = window2.InputEvent) !== null && _InputEvent !== void 0 ? _InputEvent : class InputEvent extends UIEvent {
        };
        var _KeyboardEvent;
        const KeyboardEvent = (_KeyboardEvent = window2.KeyboardEvent) !== null && _KeyboardEvent !== void 0 ? _KeyboardEvent : class KeyboardEvent extends UIEvent {
        };
        var _MouseEvent;
        const MouseEvent = (_MouseEvent = window2.MouseEvent) !== null && _MouseEvent !== void 0 ? _MouseEvent : class MouseEvent extends UIEvent {
        };
        var _DragEvent;
        const DragEvent = (_DragEvent = window2.DragEvent) !== null && _DragEvent !== void 0 ? _DragEvent : class DragEvent extends MouseEvent {
        };
        var _PointerEvent;
        const PointerEvent = (_PointerEvent = window2.PointerEvent) !== null && _PointerEvent !== void 0 ? _PointerEvent : class PointerEvent extends MouseEvent {
        };
        var _TouchEvent;
        const TouchEvent = (_TouchEvent = window2.TouchEvent) !== null && _TouchEvent !== void 0 ? _TouchEvent : class TouchEvent extends UIEvent {
        };
        return {
          Event,
          AnimationEvent,
          ClipboardEvent,
          PopStateEvent,
          ProgressEvent,
          TransitionEvent,
          UIEvent,
          CompositionEvent,
          FocusEvent,
          InputEvent,
          KeyboardEvent,
          MouseEvent,
          DragEvent,
          PointerEvent,
          TouchEvent
        };
      }
      function assignProps(obj, props) {
        for (const [key2, value] of Object.entries(props)) {
          Object.defineProperty(obj, key2, {
            get: () => value !== null && value !== void 0 ? value : null
          });
        }
      }
      function sanitizeNumber(n2) {
        return Number(n2 !== null && n2 !== void 0 ? n2 : 0);
      }
      function initClipboardEvent(event, { clipboardData }) {
        assignProps(event, {
          clipboardData
        });
      }
      function initInputEvent(event, { data, inputType, isComposing }) {
        assignProps(event, {
          data,
          isComposing: Boolean(isComposing),
          inputType: String(inputType)
        });
      }
      function initUIEvent(event, { view, detail }) {
        assignProps(event, {
          view,
          detail: sanitizeNumber(detail !== null && detail !== void 0 ? detail : 0)
        });
      }
      function initUIEventModififiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
        assignProps(event, {
          altKey: Boolean(altKey),
          ctrlKey: Boolean(ctrlKey),
          metaKey: Boolean(metaKey),
          shiftKey: Boolean(shiftKey),
          getModifierState(k2) {
            return Boolean({
              Alt: altKey,
              AltGraph: modifierAltGraph,
              CapsLock: modifierCapsLock,
              Control: ctrlKey,
              Fn: modifierFn,
              FnLock: modifierFnLock,
              Meta: metaKey,
              NumLock: modifierNumLock,
              ScrollLock: modifierScrollLock,
              Shift: shiftKey,
              Symbol: modifierSymbol,
              SymbolLock: modifierSymbolLock
            }[k2]);
          }
        });
      }
      function initKeyboardEvent(event, { key: key2, code, location: location2, repeat, isComposing, charCode }) {
        assignProps(event, {
          key: String(key2),
          code: String(code),
          location: sanitizeNumber(location2),
          repeat: Boolean(repeat),
          isComposing: Boolean(isComposing),
          charCode
        });
      }
      function initMouseEvent(event, { x: x2, y: y2, screenX, screenY, clientX = x2, clientY = y2, button, buttons, relatedTarget }) {
        assignProps(event, {
          screenX: sanitizeNumber(screenX),
          screenY: sanitizeNumber(screenY),
          clientX: sanitizeNumber(clientX),
          x: sanitizeNumber(clientX),
          clientY: sanitizeNumber(clientY),
          y: sanitizeNumber(clientY),
          button: sanitizeNumber(button),
          buttons: sanitizeNumber(buttons),
          relatedTarget
        });
      }
      function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
        assignProps(event, {
          pointerId: sanitizeNumber(pointerId),
          width: sanitizeNumber(width),
          height: sanitizeNumber(height),
          pressure: sanitizeNumber(pressure),
          tangentialPressure: sanitizeNumber(tangentialPressure),
          tiltX: sanitizeNumber(tiltX),
          tiltY: sanitizeNumber(tiltY),
          twist: sanitizeNumber(twist),
          pointerType: String(pointerType),
          isPrimary: Boolean(isPrimary)
        });
      }
      function dispatchUIEvent(target, type2, init, preventDefault = false) {
        if (isMouseEvent(type2) || isKeyboardEvent(type2)) {
          init = {
            ...init,
            ...this.system.getUIEventModifiers()
          };
        }
        const event = createEvent(type2, target, init);
        return dispatchEvent.call(this, target, event, preventDefault);
      }
      function dispatchEvent(target, event, preventDefault = false) {
        var ref;
        const type2 = event.type;
        const behaviorImplementation = preventDefault ? () => {
        } : (ref = behavior[type2]) === null || ref === void 0 ? void 0 : ref(event, target, this);
        if (behaviorImplementation) {
          event.preventDefault();
          let defaultPrevented = false;
          Object.defineProperty(event, "defaultPrevented", {
            get: () => defaultPrevented
          });
          Object.defineProperty(event, "preventDefault", {
            value: () => {
              defaultPrevented = event.cancelable;
            }
          });
          wrapEvent(() => target.dispatchEvent(event));
          if (!defaultPrevented) {
            behaviorImplementation();
          }
          return !defaultPrevented;
        }
        return wrapEvent(() => target.dispatchEvent(event));
      }
      function dispatchDOMEvent(target, type2, init) {
        const event = createEvent(type2, target, init);
        wrapEvent(() => target.dispatchEvent(event));
      }
      const Interceptor = Symbol("Interceptor for programmatical calls");
      function prepareInterceptor(element, propName, interceptorImpl) {
        const prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);
        const objectDescriptor = Object.getOwnPropertyDescriptor(element, propName);
        const target = (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor.set) ? "set" : "value";
        if (typeof (prototypeDescriptor === null || prototypeDescriptor === void 0 ? void 0 : prototypeDescriptor[target]) !== "function" || prototypeDescriptor[target][Interceptor]) {
          throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
        }
        function intercept(...args) {
          const { applyNative = false, realArgs, then } = interceptorImpl.call(this, ...args);
          const realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
          if (target === "set") {
            realFunc.call(this, realArgs);
          } else {
            realFunc.call(this, ...realArgs);
          }
          then === null || then === void 0 ? void 0 : then();
        }
        intercept[Interceptor] = Interceptor;
        Object.defineProperty(element, propName, {
          ...objectDescriptor !== null && objectDescriptor !== void 0 ? objectDescriptor : prototypeDescriptor,
          [target]: intercept
        });
      }
      function prepareValueInterceptor(element) {
        prepareInterceptor(element, "value", function interceptorImpl(v2) {
          const isUI = isUIValue(v2);
          if (isUI) {
            startTrackValue(this);
          }
          return {
            applyNative: !!isUI,
            realArgs: sanitizeValue(this, v2),
            then: isUI ? void 0 : () => trackOrSetValue(this, String(v2))
          };
        });
      }
      function sanitizeValue(element, v2) {
        if (isElementType(element, "input", {
          type: "number"
        }) && String(v2) !== "" && !Number.isNaN(Number(v2))) {
          return String(Number(v2));
        }
        return String(v2);
      }
      function prepareSelectionInterceptor(element) {
        prepareInterceptor(element, "setSelectionRange", function interceptorImpl(start, ...others) {
          const isUI = isUISelectionStart(start);
          return {
            applyNative: !!isUI,
            realArgs: [
              Number(start),
              ...others
            ],
            then: () => isUI ? void 0 : setUISelectionClean(element)
          };
        });
        prepareInterceptor(element, "selectionStart", function interceptorImpl(v2) {
          return {
            realArgs: v2,
            then: () => setUISelectionClean(element)
          };
        });
        prepareInterceptor(element, "selectionEnd", function interceptorImpl(v2) {
          return {
            realArgs: v2,
            then: () => setUISelectionClean(element)
          };
        });
        prepareInterceptor(element, "select", function interceptorImpl() {
          return {
            realArgs: [],
            then: () => setUISelectionRaw(element, {
              anchorOffset: 0,
              focusOffset: getUIValue(element).length
            })
          };
        });
      }
      function prepareRangeTextInterceptor(element) {
        prepareInterceptor(element, "setRangeText", function interceptorImpl(...realArgs) {
          return {
            realArgs,
            then: () => {
              setUIValueClean(element);
              setUISelectionClean(element);
            }
          };
        });
      }
      const isPrepared = Symbol("Node prepared with document state workarounds");
      function prepareDocument(document2) {
        if (document2[isPrepared]) {
          return;
        }
        document2.addEventListener("focus", (e2) => {
          const el = e2.target;
          prepareElement(el);
        }, {
          capture: true,
          passive: true
        });
        if (document2.activeElement) {
          prepareElement(document2.activeElement);
        }
        document2.addEventListener("blur", (e2) => {
          const el = e2.target;
          const initialValue2 = getInitialValue(el);
          if (initialValue2 !== void 0) {
            if (el.value !== initialValue2) {
              dispatchDOMEvent(el, "change");
            }
            clearInitialValue(el);
          }
        }, {
          capture: true,
          passive: true
        });
        document2[isPrepared] = isPrepared;
      }
      function prepareElement(el) {
        if (el[isPrepared]) {
          return;
        }
        if (isElementType(el, [
          "input",
          "textarea"
        ])) {
          prepareValueInterceptor(el);
          prepareSelectionInterceptor(el);
          prepareRangeTextInterceptor(el);
        }
        el[isPrepared] = isPrepared;
      }
      function getDocumentFromNode(el) {
        return isDocument(el) ? el : el.ownerDocument;
      }
      function isDocument(node2) {
        return node2.nodeType === 9;
      }
      function wait(config2) {
        const delay = config2.delay;
        if (typeof delay !== "number") {
          return;
        }
        return Promise.all([
          new Promise((resolve) => globalThis.setTimeout(() => resolve(), delay)),
          config2.advanceTimers(delay)
        ]);
      }
      var _pressed, _code, _code1;
      var DOM_KEY_LOCATION;
      (function(DOM_KEY_LOCATION2) {
        DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["STANDARD"] = 0] = "STANDARD";
        DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["LEFT"] = 1] = "LEFT";
        DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["RIGHT"] = 2] = "RIGHT";
        DOM_KEY_LOCATION2[DOM_KEY_LOCATION2["NUMPAD"] = 3] = "NUMPAD";
      })(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));
      const modifierKeys = [
        "Alt",
        "AltGraph",
        "Control",
        "Fn",
        "Meta",
        "Shift",
        "Symbol"
      ];
      function isModifierKey(key2) {
        return modifierKeys.includes(key2);
      }
      const modifierLocks = [
        "CapsLock",
        "FnLock",
        "NumLock",
        "ScrollLock",
        "SymbolLock"
      ];
      function isModifierLock(key2) {
        return modifierLocks.includes(key2);
      }
      class KeyboardHost {
        isKeyPressed(keyDef) {
          return !!this.pressed[String(keyDef.code)];
        }
        getPressedKeys() {
          return Object.values(this.pressed).map((p2) => p2.keyDef);
        }
        /** Press a key */
        async keydown(instance, keyDef) {
          const key2 = String(keyDef.key);
          const code = String(keyDef.code);
          const target = getActiveElementOrBody(instance.config.document);
          this.setKeydownTarget(target);
          var ref;
          (ref = (_pressed = this.pressed)[_code = code]) !== null && ref !== void 0 ? ref : _pressed[_code] = {
            keyDef,
            unpreventedDefault: false
          };
          if (isModifierKey(key2)) {
            this.modifiers[key2] = true;
          }
          const unprevented = instance.dispatchUIEvent(target, "keydown", {
            key: key2,
            code
          });
          if (isModifierLock(key2) && !this.modifiers[key2]) {
            this.modifiers[key2] = true;
            this.modifierLockStart[key2] = true;
          }
          (_code1 = this.pressed[code]).unpreventedDefault || (_code1.unpreventedDefault = unprevented);
          if (unprevented && this.hasKeyPress(key2)) {
            instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keypress", {
              key: key2,
              code,
              charCode: keyDef.key === "Enter" ? 13 : String(keyDef.key).charCodeAt(0)
            });
          }
        }
        /** Release a key */
        async keyup(instance, keyDef) {
          const key2 = String(keyDef.key);
          const code = String(keyDef.code);
          const unprevented = this.pressed[code].unpreventedDefault;
          delete this.pressed[code];
          if (isModifierKey(key2) && !Object.values(this.pressed).find((p2) => p2.keyDef.key === key2)) {
            this.modifiers[key2] = false;
          }
          instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keyup", {
            key: key2,
            code
          }, !unprevented);
          if (isModifierLock(key2) && this.modifiers[key2]) {
            if (this.modifierLockStart[key2]) {
              this.modifierLockStart[key2] = false;
            } else {
              this.modifiers[key2] = false;
            }
          }
        }
        setKeydownTarget(target) {
          if (target !== this.lastKeydownTarget) {
            this.carryChar = "";
          }
          this.lastKeydownTarget = target;
        }
        hasKeyPress(key2) {
          return (key2.length === 1 || key2 === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
        }
        constructor(system) {
          this.modifiers = {
            Alt: false,
            AltGraph: false,
            CapsLock: false,
            Control: false,
            Fn: false,
            FnLock: false,
            Meta: false,
            NumLock: false,
            ScrollLock: false,
            Shift: false,
            Symbol: false,
            SymbolLock: false
          };
          this.pressed = {};
          this.carryChar = "";
          this.lastKeydownTarget = void 0;
          this.modifierLockStart = {};
          this.system = system;
        }
      }
      const defaultKeyMap$1 = [
        // alphanumeric keys
        ..."0123456789".split("").map((c2) => ({
          code: `Digit${c2}`,
          key: c2
        })),
        ...")!@#$%^&*(".split("").map((c2, i2) => ({
          code: `Digit${i2}`,
          key: c2,
          shiftKey: true
        })),
        ..."abcdefghijklmnopqrstuvwxyz".split("").map((c2) => ({
          code: `Key${c2.toUpperCase()}`,
          key: c2
        })),
        ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((c2) => ({
          code: `Key${c2}`,
          key: c2,
          shiftKey: true
        })),
        // alphanumeric block - functional
        {
          code: "Space",
          key: " "
        },
        {
          code: "AltLeft",
          key: "Alt",
          location: DOM_KEY_LOCATION.LEFT
        },
        {
          code: "AltRight",
          key: "Alt",
          location: DOM_KEY_LOCATION.RIGHT
        },
        {
          code: "ShiftLeft",
          key: "Shift",
          location: DOM_KEY_LOCATION.LEFT
        },
        {
          code: "ShiftRight",
          key: "Shift",
          location: DOM_KEY_LOCATION.RIGHT
        },
        {
          code: "ControlLeft",
          key: "Control",
          location: DOM_KEY_LOCATION.LEFT
        },
        {
          code: "ControlRight",
          key: "Control",
          location: DOM_KEY_LOCATION.RIGHT
        },
        {
          code: "MetaLeft",
          key: "Meta",
          location: DOM_KEY_LOCATION.LEFT
        },
        {
          code: "MetaRight",
          key: "Meta",
          location: DOM_KEY_LOCATION.RIGHT
        },
        {
          code: "OSLeft",
          key: "OS",
          location: DOM_KEY_LOCATION.LEFT
        },
        {
          code: "OSRight",
          key: "OS",
          location: DOM_KEY_LOCATION.RIGHT
        },
        {
          code: "Tab",
          key: "Tab"
        },
        {
          code: "CapsLock",
          key: "CapsLock"
        },
        {
          code: "Backspace",
          key: "Backspace"
        },
        {
          code: "Enter",
          key: "Enter"
        },
        // function
        {
          code: "Escape",
          key: "Escape"
        },
        // arrows
        {
          code: "ArrowUp",
          key: "ArrowUp"
        },
        {
          code: "ArrowDown",
          key: "ArrowDown"
        },
        {
          code: "ArrowLeft",
          key: "ArrowLeft"
        },
        {
          code: "ArrowRight",
          key: "ArrowRight"
        },
        // control pad
        {
          code: "Home",
          key: "Home"
        },
        {
          code: "End",
          key: "End"
        },
        {
          code: "Delete",
          key: "Delete"
        },
        {
          code: "PageUp",
          key: "PageUp"
        },
        {
          code: "PageDown",
          key: "PageDown"
        },
        // Special keys that are not part of a default US-layout but included for specific behavior
        {
          code: "Fn",
          key: "Fn"
        },
        {
          code: "Symbol",
          key: "Symbol"
        },
        {
          code: "AltRight",
          key: "AltGraph"
        }
      ];
      const defaultKeyMap = [
        {
          name: "MouseLeft",
          pointerType: "mouse",
          button: "primary"
        },
        {
          name: "MouseRight",
          pointerType: "mouse",
          button: "secondary"
        },
        {
          name: "MouseMiddle",
          pointerType: "mouse",
          button: "auxiliary"
        },
        {
          name: "TouchA",
          pointerType: "touch"
        },
        {
          name: "TouchB",
          pointerType: "touch"
        },
        {
          name: "TouchC",
          pointerType: "touch"
        }
      ];
      class Buttons {
        getButtons() {
          let v2 = 0;
          for (const button of Object.keys(this.pressed)) {
            v2 |= 2 ** Number(button);
          }
          return v2;
        }
        down(keyDef) {
          const button = getMouseButtonId(keyDef.button);
          if (button in this.pressed) {
            this.pressed[button].push(keyDef);
            return void 0;
          }
          this.pressed[button] = [
            keyDef
          ];
          return button;
        }
        up(keyDef) {
          const button = getMouseButtonId(keyDef.button);
          if (button in this.pressed) {
            this.pressed[button] = this.pressed[button].filter((k2) => k2.name !== keyDef.name);
            if (this.pressed[button].length === 0) {
              delete this.pressed[button];
              return button;
            }
          }
          return void 0;
        }
        constructor() {
          this.pressed = {};
        }
      }
      const MouseButton = {
        primary: 0,
        secondary: 1,
        auxiliary: 2,
        back: 3,
        X1: 3,
        forward: 4,
        X2: 4
      };
      function getMouseButtonId(button = 0) {
        if (button in MouseButton) {
          return MouseButton[button];
        }
        return Number(button);
      }
      const MouseButtonFlip = {
        1: 2,
        2: 1
      };
      function getMouseEventButton(button) {
        button = getMouseButtonId(button);
        if (button in MouseButtonFlip) {
          return MouseButtonFlip[button];
        }
        return button;
      }
      class Device {
        get countPressed() {
          return this.pressedKeys.size;
        }
        isPressed(keyDef) {
          return this.pressedKeys.has(keyDef.name);
        }
        addPressed(keyDef) {
          return this.pressedKeys.add(keyDef.name);
        }
        removePressed(keyDef) {
          return this.pressedKeys.delete(keyDef.name);
        }
        constructor() {
          this.pressedKeys = /* @__PURE__ */ new Set();
        }
      }
      function getTreeDiff(a, b2) {
        const treeA = [];
        for (let el = a; el; el = el.parentElement) {
          treeA.push(el);
        }
        const treeB = [];
        for (let el1 = b2; el1; el1 = el1.parentElement) {
          treeB.push(el1);
        }
        let i2 = 0;
        for (; ; i2++) {
          if (i2 >= treeA.length || i2 >= treeB.length || treeA[treeA.length - 1 - i2] !== treeB[treeB.length - 1 - i2]) {
            break;
          }
        }
        return [
          treeA.slice(0, treeA.length - i2),
          treeB.slice(0, treeB.length - i2),
          treeB.slice(treeB.length - i2)
        ];
      }
      function resolveCaretPosition({ target, node: node2, offset: offset2 }) {
        if (hasOwnSelection(target)) {
          return {
            node: target,
            offset: offset2 !== null && offset2 !== void 0 ? offset2 : getUIValue(target).length
          };
        } else if (node2) {
          return {
            node: node2,
            offset: offset2 !== null && offset2 !== void 0 ? offset2 : node2.nodeType === 3 ? node2.nodeValue.length : node2.childNodes.length
          };
        }
        return findNodeAtTextOffset(target, offset2);
      }
      function findNodeAtTextOffset(node2, offset2, isRoot = true) {
        let i2 = offset2 === void 0 ? node2.childNodes.length - 1 : 0;
        const step = offset2 === void 0 ? -1 : 1;
        while (offset2 === void 0 ? i2 >= (isRoot ? Math.max(node2.childNodes.length - 1, 0) : 0) : i2 <= node2.childNodes.length) {
          if (offset2 && i2 === node2.childNodes.length) {
            throw new Error("The given offset is out of bounds.");
          }
          const c2 = node2.childNodes.item(i2);
          const text = String(c2.textContent);
          if (text.length) {
            if (offset2 !== void 0 && text.length < offset2) {
              offset2 -= text.length;
            } else if (c2.nodeType === 1) {
              return findNodeAtTextOffset(c2, offset2, false);
            } else {
              if (c2.nodeType === 3) {
                return {
                  node: c2,
                  offset: offset2 !== null && offset2 !== void 0 ? offset2 : c2.nodeValue.length
                };
              }
            }
          }
          i2 += step;
        }
        return {
          node: node2,
          offset: node2.childNodes.length
        };
      }
      function setSelectionPerMouseDown({ document: document2, target, clickCount, node: node2, offset: offset2 }) {
        if (hasNoSelection(target)) {
          return;
        }
        const targetHasOwnSelection = hasOwnSelection(target);
        const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);
        const [start, end] = node2 ? (
          // which elements might be considered in the same line of text.
          // TODO: support expanding initial range on multiple clicks if node is given
          [
            offset2,
            offset2
          ]
        ) : getTextRange(text, offset2, clickCount);
        if (targetHasOwnSelection) {
          setUISelection(target, {
            anchorOffset: start !== null && start !== void 0 ? start : text.length,
            focusOffset: end !== null && end !== void 0 ? end : text.length
          });
          return {
            node: target,
            start: start !== null && start !== void 0 ? start : 0,
            end: end !== null && end !== void 0 ? end : text.length
          };
        } else {
          const { node: startNode, offset: startOffset } = resolveCaretPosition({
            target,
            node: node2,
            offset: start
          });
          const { node: endNode, offset: endOffset } = resolveCaretPosition({
            target,
            node: node2,
            offset: end
          });
          const range2 = target.ownerDocument.createRange();
          try {
            range2.setStart(startNode, startOffset);
            range2.setEnd(endNode, endOffset);
          } catch (e2) {
            throw new Error("The given offset is out of bounds.");
          }
          const selection = document2.getSelection();
          selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
          selection === null || selection === void 0 ? void 0 : selection.addRange(range2.cloneRange());
          return range2;
        }
      }
      function getTextRange(text, pos, clickCount) {
        if (clickCount % 3 === 1 || text.length === 0) {
          return [
            pos,
            pos
          ];
        }
        const textPos = pos !== null && pos !== void 0 ? pos : text.length;
        if (clickCount % 3 === 2) {
          return [
            textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
            pos === void 0 ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
          ];
        }
        return [
          textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
          pos === void 0 ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
        ];
      }
      function modifySelectionPerMouseMove(selectionRange, { document: document2, target, node: node2, offset: offset2 }) {
        const selectionFocus = resolveCaretPosition({
          target,
          node: node2,
          offset: offset2
        });
        if ("node" in selectionRange) {
          if (selectionFocus.node === selectionRange.node) {
            const anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start;
            const focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
            setUISelection(selectionRange.node, {
              anchorOffset,
              focusOffset
            });
          }
        } else {
          const range2 = selectionRange.cloneRange();
          const cmp = range2.comparePoint(selectionFocus.node, selectionFocus.offset);
          if (cmp < 0) {
            range2.setStart(selectionFocus.node, selectionFocus.offset);
          } else if (cmp > 0) {
            range2.setEnd(selectionFocus.node, selectionFocus.offset);
          }
          const selection = document2.getSelection();
          selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
          selection === null || selection === void 0 ? void 0 : selection.addRange(range2.cloneRange());
        }
      }
      function isDifferentPointerPosition(positionA, positionB) {
        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
        return positionA.target !== positionB.target || ((ref = positionA.coords) === null || ref === void 0 ? void 0 : ref.x) !== ((ref1 = positionB.coords) === null || ref1 === void 0 ? void 0 : ref1.y) || ((ref2 = positionA.coords) === null || ref2 === void 0 ? void 0 : ref2.y) !== ((ref3 = positionB.coords) === null || ref3 === void 0 ? void 0 : ref3.y) || ((ref4 = positionA.caret) === null || ref4 === void 0 ? void 0 : ref4.node) !== ((ref5 = positionB.caret) === null || ref5 === void 0 ? void 0 : ref5.node) || ((ref6 = positionA.caret) === null || ref6 === void 0 ? void 0 : ref6.offset) !== ((ref7 = positionB.caret) === null || ref7 === void 0 ? void 0 : ref7.offset);
      }
      class Mouse {
        move(instance, position2) {
          const prevPosition = this.position;
          const prevTarget = this.getTarget(instance);
          this.position = position2;
          if (!isDifferentPointerPosition(prevPosition, position2)) {
            return;
          }
          const nextTarget = this.getTarget(instance);
          const init = this.getEventInit("mousemove");
          const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
          return {
            leave: () => {
              if (prevTarget !== nextTarget) {
                instance.dispatchUIEvent(prevTarget, "mouseout", init);
                leave.forEach((el) => instance.dispatchUIEvent(el, "mouseleave", init));
              }
            },
            enter: () => {
              if (prevTarget !== nextTarget) {
                instance.dispatchUIEvent(nextTarget, "mouseover", init);
                enter.forEach((el) => instance.dispatchUIEvent(el, "mouseenter", init));
              }
            },
            move: () => {
              instance.dispatchUIEvent(nextTarget, "mousemove", init);
              this.modifySelecting(instance);
            }
          };
        }
        down(instance, keyDef, pointer2) {
          const button = this.buttons.down(keyDef);
          if (button === void 0) {
            return;
          }
          const target = this.getTarget(instance);
          this.buttonDownTarget[button] = target;
          const disabled = isDisabled(target);
          const init = this.getEventInit("mousedown", keyDef.button);
          if (disabled || instance.dispatchUIEvent(target, "mousedown", init)) {
            this.startSelecting(instance, init.detail);
            focusElement(target);
          }
          if (!disabled && getMouseEventButton(keyDef.button) === 2) {
            instance.dispatchUIEvent(target, "contextmenu", this.getEventInit("contextmenu", keyDef.button, pointer2));
          }
        }
        up(instance, keyDef, pointer2) {
          const button = this.buttons.up(keyDef);
          if (button === void 0) {
            return;
          }
          const target = this.getTarget(instance);
          if (!isDisabled(target)) {
            instance.dispatchUIEvent(target, "mouseup", this.getEventInit("mouseup", keyDef.button));
            this.endSelecting();
            const clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
            if (clickTarget) {
              const init = this.getEventInit("click", keyDef.button, pointer2);
              if (init.detail) {
                instance.dispatchUIEvent(clickTarget, init.button === 0 ? "click" : "auxclick", init);
                if (init.button === 0 && init.detail === 2) {
                  instance.dispatchUIEvent(clickTarget, "dblclick", {
                    ...this.getEventInit("dblclick", keyDef.button),
                    detail: init.detail
                  });
                }
              }
            }
          }
        }
        resetClickCount() {
          this.clickCount.reset();
        }
        getEventInit(type2, button, pointer2) {
          const init = {
            ...this.position.coords
          };
          if (pointer2) {
            init.pointerId = pointer2.pointerId;
            init.pointerType = pointer2.pointerType;
            init.isPrimary = pointer2.isPrimary;
          }
          init.button = getMouseEventButton(button);
          init.buttons = this.buttons.getButtons();
          if (type2 === "mousedown") {
            init.detail = this.clickCount.getOnDown(init.button);
          } else if (type2 === "mouseup") {
            init.detail = this.clickCount.getOnUp(init.button);
          } else if (type2 === "click" || type2 === "auxclick") {
            init.detail = this.clickCount.incOnClick(init.button);
          }
          return init;
        }
        getTarget(instance) {
          var _target;
          return (_target = this.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;
        }
        startSelecting(instance, clickCount) {
          var ref, ref1;
          this.selecting = setSelectionPerMouseDown({
            document: instance.config.document,
            target: this.getTarget(instance),
            node: (ref = this.position.caret) === null || ref === void 0 ? void 0 : ref.node,
            offset: (ref1 = this.position.caret) === null || ref1 === void 0 ? void 0 : ref1.offset,
            clickCount
          });
        }
        modifySelecting(instance) {
          var ref, ref1;
          if (!this.selecting) {
            return;
          }
          modifySelectionPerMouseMove(this.selecting, {
            document: instance.config.document,
            target: this.getTarget(instance),
            node: (ref = this.position.caret) === null || ref === void 0 ? void 0 : ref.node,
            offset: (ref1 = this.position.caret) === null || ref1 === void 0 ? void 0 : ref1.offset
          });
        }
        endSelecting() {
          this.selecting = void 0;
        }
        constructor() {
          this.position = {};
          this.buttons = new Buttons();
          this.buttonDownTarget = {};
          this.clickCount = new class {
            incOnClick(button) {
              const current = this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
              this.count = this.count[button] === void 0 ? {} : {
                [button]: Number(this.count[button]) + 1
              };
              return current;
            }
            getOnDown(button) {
              var _button;
              this.down = {
                [button]: (_button = this.count[button]) !== null && _button !== void 0 ? _button : 0
              };
              var _button1;
              this.count = {
                [button]: (_button1 = this.count[button]) !== null && _button1 !== void 0 ? _button1 : 0
              };
              return Number(this.count[button]) + 1;
            }
            getOnUp(button) {
              return this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
            }
            reset() {
              this.count = {};
            }
            constructor() {
              this.down = {};
              this.count = {};
            }
          }();
        }
      }
      function hasPointerEvents(instance, element) {
        var ref;
        return ((ref = checkPointerEvents(instance, element)) === null || ref === void 0 ? void 0 : ref.pointerEvents) !== "none";
      }
      function closestPointerEventsDeclaration(element) {
        const window2 = getWindow(element);
        for (let el = element, tree = []; el === null || el === void 0 ? void 0 : el.ownerDocument; el = el.parentElement) {
          tree.push(el);
          const pointerEvents = window2.getComputedStyle(el).pointerEvents;
          if (pointerEvents && ![
            "inherit",
            "unset"
          ].includes(pointerEvents)) {
            return {
              pointerEvents,
              tree
            };
          }
        }
        return void 0;
      }
      const PointerEventsCheck = Symbol("Last check for pointer-events");
      function checkPointerEvents(instance, element) {
        const lastCheck = element[PointerEventsCheck];
        const needsCheck = instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger));
        if (!needsCheck) {
          return lastCheck === null || lastCheck === void 0 ? void 0 : lastCheck.result;
        }
        const declaration2 = closestPointerEventsDeclaration(element);
        element[PointerEventsCheck] = {
          [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
          [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
          result: declaration2
        };
        return declaration2;
      }
      function assertPointerEvents(instance, element) {
        const declaration2 = checkPointerEvents(instance, element);
        if ((declaration2 === null || declaration2 === void 0 ? void 0 : declaration2.pointerEvents) === "none") {
          throw new Error([
            `Unable to perform pointer interaction as the element ${declaration2.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
            "",
            printTree(declaration2.tree)
          ].join("\n"));
        }
      }
      function printTree(tree) {
        return tree.reverse().map((el, i2) => [
          "".padEnd(i2),
          el.tagName,
          el.id && `#${el.id}`,
          el.hasAttribute("data-testid") && `(testId=${el.getAttribute("data-testid")})`,
          getLabelDescr(el),
          tree.length > 1 && i2 === 0 && "  <-- This element declared `pointer-events: none`",
          tree.length > 1 && i2 === tree.length - 1 && "  <-- Asserted pointer events here"
        ].filter(Boolean).join("")).join("\n");
      }
      function getLabelDescr(element) {
        var ref;
        let label;
        if (element.hasAttribute("aria-label")) {
          label = element.getAttribute("aria-label");
        } else if (element.hasAttribute("aria-labelledby")) {
          var ref1, ref2;
          label = (ref1 = element.ownerDocument.getElementById(element.getAttribute("aria-labelledby"))) === null || ref1 === void 0 ? void 0 : (ref2 = ref1.textContent) === null || ref2 === void 0 ? void 0 : ref2.trim();
        } else if (isElementType(element, [
          "button",
          "input",
          "meter",
          "output",
          "progress",
          "select",
          "textarea"
        ]) && ((ref = element.labels) === null || ref === void 0 ? void 0 : ref.length)) {
          label = Array.from(element.labels).map((el) => {
            var ref4;
            return (ref4 = el.textContent) === null || ref4 === void 0 ? void 0 : ref4.trim();
          }).join("|");
        } else if (isElementType(element, "button")) {
          var ref3;
          label = (ref3 = element.textContent) === null || ref3 === void 0 ? void 0 : ref3.trim();
        }
        label = label === null || label === void 0 ? void 0 : label.replace(/\n/g, "  ");
        if (Number(label === null || label === void 0 ? void 0 : label.length) > 30) {
          label = `${label === null || label === void 0 ? void 0 : label.substring(0, 29)}…`;
        }
        return label ? `(label=${label})` : "";
      }
      function hasBitFlag(conf, flag) {
        return (conf & flag) > 0;
      }
      class Pointer {
        init(instance, position2) {
          this.position = position2;
          const target = this.getTarget(instance);
          const [, enter] = getTreeDiff(null, target);
          const init = this.getEventInit();
          assertPointerEvents(instance, target);
          instance.dispatchUIEvent(target, "pointerover", init);
          enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init));
          return this;
        }
        move(instance, position2) {
          const prevPosition = this.position;
          const prevTarget = this.getTarget(instance);
          this.position = position2;
          if (!isDifferentPointerPosition(prevPosition, position2)) {
            return;
          }
          const nextTarget = this.getTarget(instance);
          const init = this.getEventInit();
          const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
          return {
            leave: () => {
              if (hasPointerEvents(instance, prevTarget)) {
                if (prevTarget !== nextTarget) {
                  instance.dispatchUIEvent(prevTarget, "pointerout", init);
                  leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init));
                }
              }
            },
            enter: () => {
              assertPointerEvents(instance, nextTarget);
              if (prevTarget !== nextTarget) {
                instance.dispatchUIEvent(nextTarget, "pointerover", init);
                enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init));
              }
            },
            move: () => {
              instance.dispatchUIEvent(nextTarget, "pointermove", init);
            }
          };
        }
        down(instance, _keyDef) {
          if (this.isDown) {
            return;
          }
          const target = this.getTarget(instance);
          assertPointerEvents(instance, target);
          this.isDown = true;
          this.isPrevented = !instance.dispatchUIEvent(target, "pointerdown", this.getEventInit());
        }
        up(instance, _keyDef) {
          if (!this.isDown) {
            return;
          }
          const target = this.getTarget(instance);
          assertPointerEvents(instance, target);
          this.isDown = false;
          instance.dispatchUIEvent(target, "pointerup", this.getEventInit());
        }
        release(instance) {
          const target = this.getTarget(instance);
          const [leave] = getTreeDiff(target, null);
          const init = this.getEventInit();
          if (hasPointerEvents(instance, target)) {
            instance.dispatchUIEvent(target, "pointerout", init);
            leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init));
          }
          this.isCancelled = true;
        }
        getTarget(instance) {
          var _target;
          return (_target = this.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;
        }
        getEventInit() {
          return {
            ...this.position.coords,
            pointerId: this.pointerId,
            pointerType: this.pointerType,
            isPrimary: this.isPrimary
          };
        }
        constructor({ pointerId, pointerType, isPrimary }) {
          this.isMultitouch = false;
          this.isCancelled = false;
          this.isDown = false;
          this.isPrevented = false;
          this.position = {};
          this.pointerId = pointerId;
          this.pointerType = pointerType;
          this.isPrimary = isPrimary;
          this.isMultitouch = !isPrimary;
        }
      }
      var _registry, _k;
      class PointerHost {
        isKeyPressed(keyDef) {
          return this.devices.get(keyDef.pointerType).isPressed(keyDef);
        }
        async press(instance, keyDef, position2) {
          const pointerName = this.getPointerName(keyDef);
          const pointer2 = keyDef.pointerType === "touch" ? this.pointers.new(pointerName, keyDef).init(instance, position2) : this.pointers.get(pointerName);
          pointer2.position = position2;
          if (pointer2.pointerType !== "touch") {
            this.mouse.position = position2;
          }
          this.devices.get(keyDef.pointerType).addPressed(keyDef);
          this.buttons.down(keyDef);
          pointer2.down(instance, keyDef);
          if (pointer2.pointerType !== "touch" && !pointer2.isPrevented) {
            this.mouse.down(instance, keyDef, pointer2);
          }
        }
        async move(instance, pointerName, position2) {
          const pointer2 = this.pointers.get(pointerName);
          const pointermove = pointer2.move(instance, position2);
          const mousemove = pointer2.pointerType === "touch" || pointer2.isPrevented && pointer2.isDown ? void 0 : this.mouse.move(instance, position2);
          pointermove === null || pointermove === void 0 ? void 0 : pointermove.leave();
          mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();
          pointermove === null || pointermove === void 0 ? void 0 : pointermove.enter();
          mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();
          pointermove === null || pointermove === void 0 ? void 0 : pointermove.move();
          mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();
        }
        async release(instance, keyDef, position2) {
          const device = this.devices.get(keyDef.pointerType);
          device.removePressed(keyDef);
          this.buttons.up(keyDef);
          const pointer2 = this.pointers.get(this.getPointerName(keyDef));
          pointer2.position = position2;
          if (pointer2.pointerType !== "touch") {
            this.mouse.position = position2;
          }
          if (device.countPressed === 0) {
            pointer2.up(instance, keyDef);
          }
          if (pointer2.pointerType === "touch") {
            pointer2.release(instance);
          }
          if (!pointer2.isPrevented) {
            if (pointer2.pointerType === "touch" && !pointer2.isMultitouch) {
              const mousemove = this.mouse.move(instance, pointer2.position);
              mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();
              mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();
              mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();
              this.mouse.down(instance, keyDef, pointer2);
            }
            if (!pointer2.isMultitouch) {
              const mousemove1 = this.mouse.move(instance, pointer2.position);
              mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.leave();
              mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.enter();
              mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.move();
              this.mouse.up(instance, keyDef, pointer2);
            }
          }
        }
        getPointerName(keyDef) {
          return keyDef.pointerType === "touch" ? keyDef.name : keyDef.pointerType;
        }
        getPreviousPosition(pointerName) {
          return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : void 0;
        }
        resetClickCount() {
          this.mouse.resetClickCount();
        }
        getMouseTarget(instance) {
          var _target;
          return (_target = this.mouse.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;
        }
        setMousePosition(position2) {
          this.mouse.position = position2;
          this.pointers.get("mouse").position = position2;
        }
        constructor(system) {
          this.devices = new class {
            get(k2) {
              var ref;
              (ref = (_registry = this.registry)[_k = k2]) !== null && ref !== void 0 ? ref : _registry[_k] = new Device();
              return this.registry[k2];
            }
            constructor() {
              this.registry = {};
            }
          }();
          this.pointers = new class {
            new(pointerName, keyDef) {
              const isPrimary = keyDef.pointerType !== "touch" || !Object.values(this.registry).some((p2) => p2.pointerType === "touch" && !p2.isCancelled);
              if (!isPrimary) {
                Object.values(this.registry).forEach((p2) => {
                  if (p2.pointerType === keyDef.pointerType && !p2.isCancelled) {
                    p2.isMultitouch = true;
                  }
                });
              }
              this.registry[pointerName] = new Pointer({
                pointerId: this.nextId++,
                pointerType: keyDef.pointerType,
                isPrimary
              });
              return this.registry[pointerName];
            }
            get(pointerName) {
              if (!this.has(pointerName)) {
                throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
              }
              return this.registry[pointerName];
            }
            has(pointerName) {
              return pointerName in this.registry;
            }
            constructor() {
              this.registry = {
                mouse: new Pointer({
                  pointerId: 1,
                  pointerType: "mouse",
                  isPrimary: true
                })
              };
              this.nextId = 2;
            }
          }();
          this.system = system;
          this.buttons = new Buttons();
          this.mouse = new Mouse();
        }
      }
      class System {
        getUIEventModifiers() {
          return {
            altKey: this.keyboard.modifiers.Alt,
            ctrlKey: this.keyboard.modifiers.Control,
            metaKey: this.keyboard.modifiers.Meta,
            shiftKey: this.keyboard.modifiers.Shift,
            modifierAltGraph: this.keyboard.modifiers.AltGraph,
            modifierCapsLock: this.keyboard.modifiers.CapsLock,
            modifierFn: this.keyboard.modifiers.Fn,
            modifierFnLock: this.keyboard.modifiers.FnLock,
            modifierNumLock: this.keyboard.modifiers.NumLock,
            modifierScrollLock: this.keyboard.modifiers.ScrollLock,
            modifierSymbol: this.keyboard.modifiers.Symbol,
            modifierSymbolLock: this.keyboard.modifiers.SymbolLock
          };
        }
        constructor() {
          this.keyboard = new KeyboardHost(this);
          this.pointer = new PointerHost(this);
        }
      }
      async function click$1(element) {
        const pointerIn = [];
        if (!this.config.skipHover) {
          pointerIn.push({
            target: element
          });
        }
        pointerIn.push({
          keys: "[MouseLeft]",
          target: element
        });
        return this.pointer(pointerIn);
      }
      async function dblClick$1(element) {
        return this.pointer([
          {
            target: element
          },
          "[MouseLeft][MouseLeft]"
        ]);
      }
      async function tripleClick$1(element) {
        return this.pointer([
          {
            target: element
          },
          "[MouseLeft][MouseLeft][MouseLeft]"
        ]);
      }
      async function hover$1(element) {
        return this.pointer({
          target: element
        });
      }
      async function unhover$1(element) {
        assertPointerEvents(this, this.system.pointer.getMouseTarget(this));
        return this.pointer({
          target: element.ownerDocument.body
        });
      }
      async function tab$1({ shift } = {}) {
        return this.keyboard(shift === true ? "{Shift>}{Tab}{/Shift}" : shift === false ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
      }
      function parseKeyDef$1(keyboardMap, text) {
        const defs = [];
        do {
          const { type: type2, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, "keyboard");
          var ref;
          const keyDef = (ref = keyboardMap.find((def) => {
            if (type2 === "[") {
              var ref2;
              return ((ref2 = def.code) === null || ref2 === void 0 ? void 0 : ref2.toLowerCase()) === descriptor.toLowerCase();
            } else if (type2 === "{") {
              var ref1;
              return ((ref1 = def.key) === null || ref1 === void 0 ? void 0 : ref1.toLowerCase()) === descriptor.toLowerCase();
            }
            return def.key === descriptor;
          })) !== null && ref !== void 0 ? ref : {
            key: "Unknown",
            code: "Unknown",
            [type2 === "[" ? "code" : "key"]: descriptor
          };
          defs.push({
            keyDef,
            releasePrevious,
            releaseSelf,
            repeat
          });
          text = text.slice(consumedLength);
        } while (text);
        return defs;
      }
      async function keyboard$1(text) {
        const actions = parseKeyDef$1(this.config.keyboardMap, text);
        for (let i2 = 0; i2 < actions.length; i2++) {
          await wait(this.config);
          await keyboardAction(this, actions[i2]);
        }
      }
      async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
        const { system } = instance;
        if (system.keyboard.isKeyPressed(keyDef)) {
          await system.keyboard.keyup(instance, keyDef);
        }
        if (!releasePrevious) {
          for (let i2 = 1; i2 <= repeat; i2++) {
            await system.keyboard.keydown(instance, keyDef);
            if (i2 < repeat) {
              await wait(instance.config);
            }
          }
          if (releaseSelf) {
            await system.keyboard.keyup(instance, keyDef);
          }
        }
      }
      async function releaseAllKeys(instance) {
        for (const k2 of instance.system.keyboard.getPressedKeys()) {
          await instance.system.keyboard.keyup(instance, k2);
        }
      }
      function copySelection(target) {
        const data = hasOwnSelection(target) ? {
          "text/plain": readSelectedValueFromInput(target)
        } : {
          "text/plain": String(target.ownerDocument.getSelection())
        };
        const dt = createDataTransfer(getWindow(target));
        for (const type2 in data) {
          if (data[type2]) {
            dt.setData(type2, data[type2]);
          }
        }
        return dt;
      }
      function readSelectedValueFromInput(target) {
        const sel = getUISelection(target);
        const val = getUIValue(target);
        return val.substring(sel.startOffset, sel.endOffset);
      }
      async function copy$1() {
        const doc = this.config.document;
        var _activeElement;
        const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : (
          /* istanbul ignore next */
          doc.body
        );
        const clipboardData = copySelection(target);
        if (clipboardData.items.length === 0) {
          return;
        }
        if (this.dispatchUIEvent(target, "copy", {
          clipboardData
        }) && this.config.writeToClipboard) {
          await writeDataTransferToClipboard(doc, clipboardData);
        }
        return clipboardData;
      }
      async function cut$1() {
        const doc = this.config.document;
        var _activeElement;
        const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : (
          /* istanbul ignore next */
          doc.body
        );
        const clipboardData = copySelection(target);
        if (clipboardData.items.length === 0) {
          return;
        }
        if (this.dispatchUIEvent(target, "cut", {
          clipboardData
        }) && this.config.writeToClipboard) {
          await writeDataTransferToClipboard(target.ownerDocument, clipboardData);
        }
        return clipboardData;
      }
      async function paste$1(clipboardData) {
        const doc = this.config.document;
        var _activeElement;
        const target = (_activeElement = doc.activeElement) !== null && _activeElement !== void 0 ? _activeElement : (
          /* istanbul ignore next */
          doc.body
        );
        var ref;
        const dataTransfer = (ref = typeof clipboardData === "string" ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && ref !== void 0 ? ref : await readDataTransferFromClipboard(doc).catch(() => {
          throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
        });
        this.dispatchUIEvent(target, "paste", {
          clipboardData: dataTransfer
        });
      }
      function getClipboardDataFromString(doc, text) {
        const dt = createDataTransfer(getWindow(doc));
        dt.setData("text", text);
        return dt;
      }
      function parseKeyDef(pointerMap, keys2) {
        const defs = [];
        do {
          const { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys2, "pointer");
          const keyDef = pointerMap.find((p2) => p2.name === descriptor);
          if (keyDef) {
            defs.push({
              keyDef,
              releasePrevious,
              releaseSelf
            });
          }
          keys2 = keys2.slice(consumedLength);
        } while (keys2);
        return defs;
      }
      async function pointer$1(input2) {
        const { pointerMap } = this.config;
        const actions = [];
        (Array.isArray(input2) ? input2 : [
          input2
        ]).forEach((actionInput) => {
          if (typeof actionInput === "string") {
            actions.push(...parseKeyDef(pointerMap, actionInput));
          } else if ("keys" in actionInput) {
            actions.push(...parseKeyDef(pointerMap, actionInput.keys).map((i2) => ({
              ...actionInput,
              ...i2
            })));
          } else {
            actions.push(actionInput);
          }
        });
        for (let i2 = 0; i2 < actions.length; i2++) {
          await wait(this.config);
          await pointerAction(this, actions[i2]);
        }
        this.system.pointer.resetClickCount();
      }
      async function pointerAction(instance, action) {
        var ref, ref1;
        const pointerName = "pointerName" in action && action.pointerName ? action.pointerName : "keyDef" in action ? instance.system.pointer.getPointerName(action.keyDef) : "mouse";
        const previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
        var _target, _coords, _node, _offset;
        const position2 = {
          target: (_target = action.target) !== null && _target !== void 0 ? _target : getPrevTarget(instance, previousPosition),
          coords: (_coords = action.coords) !== null && _coords !== void 0 ? _coords : previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.coords,
          caret: {
            node: (_node = action.node) !== null && _node !== void 0 ? _node : hasCaretPosition(action) ? void 0 : previousPosition === null || previousPosition === void 0 ? void 0 : (ref = previousPosition.caret) === null || ref === void 0 ? void 0 : ref.node,
            offset: (_offset = action.offset) !== null && _offset !== void 0 ? _offset : hasCaretPosition(action) ? void 0 : previousPosition === null || previousPosition === void 0 ? void 0 : (ref1 = previousPosition.caret) === null || ref1 === void 0 ? void 0 : ref1.offset
          }
        };
        if ("keyDef" in action) {
          if (instance.system.pointer.isKeyPressed(action.keyDef)) {
            setLevelRef(instance, ApiLevel.Trigger);
            await instance.system.pointer.release(instance, action.keyDef, position2);
          }
          if (!action.releasePrevious) {
            setLevelRef(instance, ApiLevel.Trigger);
            await instance.system.pointer.press(instance, action.keyDef, position2);
            if (action.releaseSelf) {
              setLevelRef(instance, ApiLevel.Trigger);
              await instance.system.pointer.release(instance, action.keyDef, position2);
            }
          }
        } else {
          setLevelRef(instance, ApiLevel.Trigger);
          await instance.system.pointer.move(instance, pointerName, position2);
        }
      }
      function hasCaretPosition(action) {
        var _target, ref;
        return !!((ref = (_target = action.target) !== null && _target !== void 0 ? _target : action.node) !== null && ref !== void 0 ? ref : action.offset !== void 0);
      }
      function getPrevTarget(instance, position2) {
        if (!position2) {
          throw new Error("This pointer has no previous position. Provide a target property!");
        }
        var _target;
        return (_target = position2.target) !== null && _target !== void 0 ? _target : instance.config.document.body;
      }
      async function clear$1(element) {
        if (!isEditable(element) || isDisabled(element)) {
          throw new Error("clear()` is only supported on editable elements.");
        }
        focusElement(element);
        if (element.ownerDocument.activeElement !== element) {
          throw new Error("The element to be cleared could not be focused.");
        }
        selectAll(element);
        if (!isAllSelected(element)) {
          throw new Error("The element content to be cleared could not be selected.");
        }
        input(this, element, "", "deleteContentBackward");
      }
      async function selectOptions$1(select, values) {
        return selectOptionsBase.call(this, true, select, values);
      }
      async function deselectOptions$1(select, values) {
        return selectOptionsBase.call(this, false, select, values);
      }
      async function selectOptionsBase(newValue, select, values) {
        if (!newValue && !select.multiple) {
          throw getConfig().getElementError(`Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.`, select);
        }
        const valArray = Array.isArray(values) ? values : [
          values
        ];
        const allOptions = Array.from(select.querySelectorAll('option, [role="option"]'));
        const selectedOptions = valArray.map((val) => {
          if (typeof val !== "string" && allOptions.includes(val)) {
            return val;
          } else {
            const matchingOption = allOptions.find((o2) => o2.value === val || o2.innerHTML === val);
            if (matchingOption) {
              return matchingOption;
            } else {
              throw getConfig().getElementError(`Value "${String(val)}" not found in options`, select);
            }
          }
        }).filter((option) => !isDisabled(option));
        if (isDisabled(select) || !selectedOptions.length)
          return;
        const selectOption = (option) => {
          option.selected = newValue;
          this.dispatchUIEvent(select, "input", {
            bubbles: true,
            cancelable: false,
            composed: true
          });
          this.dispatchUIEvent(select, "change");
        };
        if (isElementType(select, "select")) {
          if (select.multiple) {
            for (const option of selectedOptions) {
              const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
              if (withPointerEvents) {
                this.dispatchUIEvent(option, "pointerover");
                this.dispatchUIEvent(select, "pointerenter");
                this.dispatchUIEvent(option, "mouseover");
                this.dispatchUIEvent(select, "mouseenter");
                this.dispatchUIEvent(option, "pointermove");
                this.dispatchUIEvent(option, "mousemove");
                this.dispatchUIEvent(option, "pointerdown");
                this.dispatchUIEvent(option, "mousedown");
              }
              focusElement(select);
              if (withPointerEvents) {
                this.dispatchUIEvent(option, "pointerup");
                this.dispatchUIEvent(option, "mouseup");
              }
              selectOption(option);
              if (withPointerEvents) {
                this.dispatchUIEvent(option, "click");
              }
              await wait(this.config);
            }
          } else if (selectedOptions.length === 1) {
            const withPointerEvents1 = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
            if (withPointerEvents1) {
              await this.click(select);
            } else {
              focusElement(select);
            }
            selectOption(selectedOptions[0]);
            if (withPointerEvents1) {
              this.dispatchUIEvent(select, "pointerover");
              this.dispatchUIEvent(select, "pointerenter");
              this.dispatchUIEvent(select, "mouseover");
              this.dispatchUIEvent(select, "mouseenter");
              this.dispatchUIEvent(select, "pointerup");
              this.dispatchUIEvent(select, "mouseup");
              this.dispatchUIEvent(select, "click");
            }
            await wait(this.config);
          } else {
            throw getConfig().getElementError(`Cannot select multiple options on a non-multiple select`, select);
          }
        } else if (select.getAttribute("role") === "listbox") {
          for (const option1 of selectedOptions) {
            await this.click(option1);
            await this.unhover(option1);
          }
        } else {
          throw getConfig().getElementError(`Cannot select options on elements that are neither select nor listbox elements`, select);
        }
      }
      async function type$1(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
        if (element.disabled)
          return;
        if (!skipClick) {
          await this.click(element);
        }
        if (initialSelectionStart !== void 0) {
          setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== void 0 ? initialSelectionEnd : initialSelectionStart);
        }
        await this.keyboard(text);
        if (!skipAutoClose) {
          await releaseAllKeys(this);
        }
      }
      const fakeFiles = Symbol("files and value properties are mocked");
      function restoreProperty(obj, prop, descriptor) {
        if (descriptor) {
          Object.defineProperty(obj, prop, descriptor);
        } else {
          delete obj[prop];
        }
      }
      function setFiles(el, files) {
        var ref;
        (ref = el[fakeFiles]) === null || ref === void 0 ? void 0 : ref.restore();
        const typeDescr = Object.getOwnPropertyDescriptor(el, "type");
        const valueDescr = Object.getOwnPropertyDescriptor(el, "value");
        const filesDescr = Object.getOwnPropertyDescriptor(el, "files");
        function restore() {
          restoreProperty(el, "type", typeDescr);
          restoreProperty(el, "value", valueDescr);
          restoreProperty(el, "files", filesDescr);
        }
        el[fakeFiles] = {
          restore
        };
        Object.defineProperties(el, {
          files: {
            configurable: true,
            get: () => files
          },
          value: {
            configurable: true,
            get: () => files.length ? `C:\\fakepath\\${files[0].name}` : "",
            set(v2) {
              if (v2 === "") {
                restore();
              } else {
                var ref2;
                valueDescr === null || valueDescr === void 0 ? void 0 : (ref2 = valueDescr.set) === null || ref2 === void 0 ? void 0 : ref2.call(el, v2);
              }
            }
          },
          type: {
            configurable: true,
            get: () => "file",
            set(v2) {
              if (v2 !== "file") {
                restore();
                el.type = v2;
              }
            }
          }
        });
      }
      async function upload$1(element, fileOrFiles) {
        const input2 = isElementType(element, "label") ? element.control : element;
        if (!input2 || !isElementType(input2, "input", {
          type: "file"
        })) {
          throw new TypeError(`The ${input2 === element ? "given" : "associated"} ${input2 === null || input2 === void 0 ? void 0 : input2.tagName} element does not accept file uploads`);
        }
        if (isDisabled(element))
          return;
        const files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
          fileOrFiles
        ]).filter((file) => !this.config.applyAccept || isAcceptableFile(file, input2.accept)).slice(0, input2.multiple ? void 0 : 1);
        const fileDialog = () => {
          var ref;
          if (files.length === ((ref = input2.files) === null || ref === void 0 ? void 0 : ref.length) && files.every((f2, i2) => {
            var ref2;
            return f2 === ((ref2 = input2.files) === null || ref2 === void 0 ? void 0 : ref2.item(i2));
          })) {
            return;
          }
          setFiles(input2, createFileList(getWindow(element), files));
          this.dispatchUIEvent(input2, "input");
          this.dispatchUIEvent(input2, "change");
        };
        input2.addEventListener("fileDialog", fileDialog);
        await this.click(element);
        input2.removeEventListener("fileDialog", fileDialog);
      }
      function isAcceptableFile(file, accept) {
        if (!accept) {
          return true;
        }
        const wildcards = [
          "audio/*",
          "image/*",
          "video/*"
        ];
        return accept.split(",").some((acceptToken) => {
          if (acceptToken.startsWith(".")) {
            return file.name.endsWith(acceptToken);
          } else if (wildcards.includes(acceptToken)) {
            return file.type.startsWith(acceptToken.substr(0, acceptToken.length - 1));
          }
          return file.type === acceptToken;
        });
      }
      const api = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        clear: clear$1,
        click: click$1,
        copy: copy$1,
        cut: cut$1,
        dblClick: dblClick$1,
        deselectOptions: deselectOptions$1,
        hover: hover$1,
        keyboard: keyboard$1,
        paste: paste$1,
        pointer: pointer$1,
        selectOptions: selectOptions$1,
        tab: tab$1,
        tripleClick: tripleClick$1,
        type: type$1,
        unhover: unhover$1,
        upload: upload$1
      }, Symbol.toStringTag, { value: "Module" }));
      function wrapAsync(implementation2) {
        return getConfig().asyncWrapper(implementation2);
      }
      const defaultOptionsDirect = {
        applyAccept: true,
        autoModify: true,
        delay: 0,
        document: globalThis.document,
        keyboardMap: defaultKeyMap$1,
        pointerMap: defaultKeyMap,
        pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
        skipAutoClose: false,
        skipClick: false,
        skipHover: false,
        writeToClipboard: false,
        advanceTimers: () => Promise.resolve()
      };
      const defaultOptionsSetup = {
        ...defaultOptionsDirect,
        writeToClipboard: true
      };
      function createConfig(options = {}, defaults = defaultOptionsSetup, node2) {
        const document2 = getDocument(options, node2, defaults);
        return {
          ...defaults,
          ...options,
          document: document2
        };
      }
      function setupMain(options = {}) {
        const config2 = createConfig(options);
        prepareDocument(config2.document);
        var _defaultView;
        const view = (_defaultView = config2.document.defaultView) !== null && _defaultView !== void 0 ? _defaultView : (
          /* istanbul ignore next */
          globalThis.window
        );
        attachClipboardStubToView(view);
        return createInstance(config2).api;
      }
      function setupDirect({ keyboardState, pointerState, ...options } = {}, node2) {
        const config2 = createConfig(options, defaultOptionsDirect, node2);
        prepareDocument(config2.document);
        var ref;
        const system = (ref = pointerState !== null && pointerState !== void 0 ? pointerState : keyboardState) !== null && ref !== void 0 ? ref : new System();
        return {
          api: createInstance(config2, system).api,
          system
        };
      }
      function setupSub(options) {
        return createInstance({
          ...this.config,
          ...options
        }, this.system).api;
      }
      function wrapAndBindImpl(instance, impl) {
        function method2(...args) {
          setLevelRef(instance, ApiLevel.Call);
          return wrapAsync(() => impl.apply(instance, args).then(async (ret) => {
            await wait(instance.config);
            return ret;
          }));
        }
        Object.defineProperty(method2, "name", {
          get: () => impl.name
        });
        return method2;
      }
      function createInstance(config2, system = new System()) {
        const instance = {};
        Object.assign(instance, {
          config: config2,
          dispatchEvent: dispatchEvent.bind(instance),
          dispatchUIEvent: dispatchUIEvent.bind(instance),
          system,
          levelRefs: {},
          ...api
        });
        return {
          instance,
          api: {
            ...Object.fromEntries(Object.entries(api).map(([name, api2]) => [
              name,
              wrapAndBindImpl(instance, api2)
            ])),
            setup: setupSub.bind(instance)
          }
        };
      }
      function getDocument(options, node2, defaults) {
        var _document, ref;
        return (ref = (_document = options.document) !== null && _document !== void 0 ? _document : node2 && getDocumentFromNode(node2)) !== null && ref !== void 0 ? ref : defaults.document;
      }
      function clear(element) {
        return setupDirect().api.clear(element);
      }
      function click(element, options = {}) {
        return setupDirect(options, element).api.click(element);
      }
      function copy(options = {}) {
        return setupDirect(options).api.copy();
      }
      function cut(options = {}) {
        return setupDirect(options).api.cut();
      }
      function dblClick(element, options = {}) {
        return setupDirect(options).api.dblClick(element);
      }
      function deselectOptions(select, values, options = {}) {
        return setupDirect(options).api.deselectOptions(select, values);
      }
      function hover(element, options = {}) {
        return setupDirect(options).api.hover(element);
      }
      async function keyboard(text, options = {}) {
        const { api: api2, system } = setupDirect(options);
        return api2.keyboard(text).then(() => system);
      }
      async function pointer(input2, options = {}) {
        const { api: api2, system } = setupDirect(options);
        return api2.pointer(input2).then(() => system);
      }
      function paste(clipboardData, options) {
        return setupDirect(options).api.paste(clipboardData);
      }
      function selectOptions(select, values, options = {}) {
        return setupDirect(options).api.selectOptions(select, values);
      }
      function tripleClick(element, options = {}) {
        return setupDirect(options).api.tripleClick(element);
      }
      function type(element, text, options = {}) {
        return setupDirect(options, element).api.type(element, text, options);
      }
      function unhover(element, options = {}) {
        const { api: api2, system } = setupDirect(options);
        system.pointer.setMousePosition({
          target: element
        });
        return api2.unhover(element);
      }
      function upload(element, fileOrFiles, options = {}) {
        return setupDirect(options).api.upload(element, fileOrFiles);
      }
      function tab(options = {}) {
        return setupDirect().api.tab(options);
      }
      const directApi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        clear,
        click,
        copy,
        cut,
        dblClick,
        deselectOptions,
        hover,
        keyboard,
        paste,
        pointer,
        selectOptions,
        tab,
        tripleClick,
        type,
        unhover,
        upload
      }, Symbol.toStringTag, { value: "Module" }));
      const userEvent = {
        ...directApi,
        setup: setupMain
      };
      var _GM_openInTab = /* @__PURE__ */ (() => typeof GM_openInTab != "undefined" ? GM_openInTab : void 0)();
      var _monkeyWindow = /* @__PURE__ */ (() => window)();
      function __read(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e2 = new Error(message);
        return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
      };
      function useGetState(initialState) {
        var _a = __read(React.useState(initialState), 2), state = _a[0], setState = _a[1];
        var stateRef = React.useRef(state);
        stateRef.current = state;
        var getState = React.useCallback(function() {
          return stateRef.current;
        }, []);
        return [state, setState, getState];
      }
      const nanoid = (t2 = 21) => crypto.getRandomValues(new Uint8Array(t2)).reduce(
        (t22, e2) => t22 += (e2 &= 63) < 36 ? e2.toString(36) : e2 < 62 ? (e2 - 26).toString(36).toUpperCase() : e2 > 62 ? "-" : "_",
        ""
      );
      function debounce(fn, wait2) {
        var timer = null;
        return function() {
          if (timer !== null) {
            clearTimeout(timer);
          }
          timer = setTimeout(fn, wait2);
        };
      }
      function validateIDCard(idCard) {
        var regex2 = /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/;
        if (!regex2.test(idCard)) {
          return false;
        }
        var Wi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
        var Xi = "10X98765432";
        var sum = 0;
        for (var i2 = 0; i2 < 17; i2++) {
          sum += parseInt(idCard.charAt(i2)) * Wi[i2];
        }
        var mod = sum % 11;
        var lastChar = Xi.charAt(mod);
        if (lastChar !== idCard.charAt(17)) {
          return false;
        }
        var year = idCard.substring(6, 10);
        var month = idCard.substring(10, 12);
        var day = idCard.substring(12, 14);
        var genderCode = idCard.charAt(16);
        var gender = genderCode % 2 === 0 ? 1 : 0;
        const birthday = year + "-" + month + "-" + day;
        return {
          birthday,
          gender
        };
      }
      const regex = {
        "id-card": /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/
      };
      const user = userEvent.setup();
      function executePromisesInOrder(promises) {
        return promises.reduce((promiseChain, [currentPromise, option]) => {
          return promiseChain.then(() => currentPromise(option));
        }, Promise.resolve());
      }
      function executeActions(rootSelectorStr, actionConfigList) {
        const actionFun = {
          radio: (props) => new Promise(async (resolve) => {
            const { fieldName, inputValue } = props;
            const dom2 = document.querySelectorAll(
              `${rootSelectorStr} [formcontrolname="${fieldName}"] [nz-radio-button]`
            )[Number(inputValue)];
            await user.click(dom2);
            resolve(true);
          }),
          select: (props) => new Promise(async (resolve) => {
            const { fieldName, inputValue, dom: dom2 } = props;
            const selectNode = dom2 ? dom2 : document.querySelector(
              `${rootSelectorStr} [formcontrolname="${fieldName}"] input`
            );
            if (!selectNode) {
              resolve(true);
              return;
            }
            await user.type(selectNode, inputValue);
            setTimeout(async () => {
              await user.click(
                document.querySelector(
                  `nz-option-container nz-option-item[title*="${inputValue}"]`
                )
              );
              resolve(true);
            }, 300);
          }),
          input: (props) => new Promise(async (resolve) => {
            const { fieldName, inputValue, inline: inline2 } = props;
            const selectNode = document.querySelector(
              `${rootSelectorStr} [formcontrolname="${fieldName}"]${inline2 ? "" : " input"}`
            );
            await user.click(selectNode);
            await user.clear(selectNode);
            await user.type(selectNode, inputValue);
            await user.tab();
            resolve(true);
          }),
          openTab: (props) => new Promise(async (resolve) => {
            const { dom: dom2 } = props;
            if (dom2) {
              let href = dom2.getAttribute("href") || "";
              href = href.indexOf("/") === 0 ? location.origin + href : href;
              _GM_openInTab(href);
              dom2.setAttribute("href", "javascript:void(0);");
              dom2.removeAttribute("target");
            }
            resolve(true);
          }),
          click: (props) => new Promise(async (resolve) => {
            if (props.dom) {
              await user.click(props.dom);
            }
            resolve(true);
          }),
          submit: () => new Promise(async (resolve) => {
            await user.click(
              document.querySelector(`${rootSelectorStr} button.ant-btn-primary`)
            );
            resolve(true);
          }),
          sleep: (props) => new Promise((resolve) => {
            setTimeout(() => {
              resolve(true);
            }, props.time || 1e3);
          })
        };
        const rootDom = document.querySelector(rootSelectorStr);
        if (rootSelectorStr !== "body" && rootDom && !document.querySelector(".igb-form-tips")) {
          const tipsDom = document.createElement("div");
          tipsDom.className = `igb-form-tips ${actionConfigList.length > 0 ? "success" : "error"}`;
          tipsDom.textContent = actionConfigList.length > 0 ? "自动填单中..." : "当前页面请自行填写";
          rootDom.insertBefore(tipsDom, rootDom.firstChild);
        }
        if (actionConfigList.length > 0) {
          executePromisesInOrder(
            [{ type: "sleep", time: 2e3 }, ...actionConfigList].map((config2) => [
              // @ts-ignore
              actionFun[config2.type],
              config2
            ])
          );
        }
      }
      let formFieldsValue = {};
      const FillButton = () => {
        const [open, setOpen] = React.useState(false);
        const [isAutoFill, setIsAutoFill, getIsAutoFill] = useGetState(false);
        const [form] = Form$1.useForm();
        const handleFillClick = async () => {
          if (!isAutoFill) {
            setOpen(true);
          } else {
            setIsAutoFill(false);
          }
        };
        const autoFillAction = () => {
          console.log("isAutoFill", getIsAutoFill());
          if (!getIsAutoFill())
            return;
          const { pathname, search } = location;
          const currentComponent = new URLSearchParams(search).get("component");
          const actionType = currentComponent || pathname.replace("/", "");
          const actions = {
            "home": () => {
              executeActions("body", [
                {
                  type: "click",
                  dom: document.querySelector(`[routerlink="/account-opening-home"]`)
                }
              ]);
            },
            "account-opening-home": () => {
              executeActions("body", [
                {
                  type: "click",
                  dom: document.querySelector(`form button .ng-star-inserted`)
                }
              ]);
            },
            "new-or-old-client": () => {
              executeActions("body", [
                {
                  type: "click",
                  dom: document.querySelector(
                    `app-account-opening-new-or-old-client .custom-button`
                  )
                }
              ]);
            },
            "employed-or-business-partner": () => {
              const rootElementName = "app-account-opening-employed-or-business-partner";
              if (document.querySelector(`${rootElementName} form`)) {
                executeActions(rootElementName, [
                  {
                    type: "click",
                    dom: document.querySelectorAll(`${rootElementName} .country-btn`)[3]
                  },
                  {
                    type: "input",
                    fieldName: "coCode",
                    inputValue: "GPL"
                  },
                  {
                    type: "input",
                    fieldName: "ifaId",
                    inputValue: formFieldsValue["phone"]
                  },
                  {
                    type: "submit"
                  }
                ]);
              } else {
                executeActions(rootElementName, [
                  {
                    type: "click",
                    dom: document.querySelectorAll(`${rootElementName} .custom-button`)[1]
                  }
                ]);
              }
            },
            "create-login": () => {
              executeActions("app-account-opening-create-login", []);
            },
            "upload-your-documents": () => {
              executeActions("app-account-opening-upload-documents", []);
            },
            "important-information-about-this-account": () => {
              executeActions("body", [
                {
                  type: "click",
                  dom: document.querySelector(
                    "app-account-opening-important-information-about-this-account button.ant-btn-primary"
                  )
                }
              ]);
            },
            "check-your-eligibility": async () => {
              const rootElementName = "app-account-opening-check-eligibility";
              const selectNodes = document.querySelectorAll(`${rootElementName} nz-select input`);
              const configs = Array.from(selectNodes).map((node2) => ({
                type: "select",
                dom: node2,
                inputValue: "China"
              }));
              executeActions(rootElementName, [...configs, { type: "submit" }]);
            },
            "fatca-status": () => {
              const actionConfigList = [
                {
                  type: "select",
                  fieldName: "nzJurisdictionTaxResidentSelect",
                  // 税务管辖地
                  inputValue: "China"
                },
                {
                  type: "input",
                  fieldName: "nzTaxIdentificationNumberTextInput",
                  // 纳税号
                  inputValue: formFieldsValue["id-card"]
                },
                {
                  type: "submit"
                }
              ];
              executeActions("app-account-opening-fatca-status", actionConfigList);
            },
            "personal-details": () => {
              const actionConfigList = [
                {
                  type: "select",
                  fieldName: "primaryMobileCountryCode",
                  inputValue: "China"
                },
                {
                  type: "input",
                  fieldName: "primaryMobileNumber",
                  inputValue: formFieldsValue["phone"]
                },
                {
                  type: "select",
                  fieldName: "title",
                  inputValue: formFieldsValue["gender"] === 0 ? "Mr." : "Mrs."
                },
                {
                  type: "input",
                  fieldName: "lastName",
                  inputValue: formFieldsValue["lastname-en"]
                },
                {
                  type: "input",
                  fieldName: "firstName",
                  inputValue: formFieldsValue["firstname-en"]
                },
                {
                  type: "select",
                  fieldName: "gender",
                  inputValue: formFieldsValue["gender"] === 0 ? "Male" : "Female"
                },
                {
                  type: "input",
                  fieldName: "dataOfBirth",
                  inputValue: formFieldsValue["birthday"]
                },
                {
                  type: "select",
                  fieldName: "countryOfIdIssue",
                  inputValue: "China"
                },
                {
                  type: "select",
                  fieldName: "idType",
                  inputValue: "Identity Card"
                },
                {
                  type: "input",
                  fieldName: "idNumber",
                  inputValue: formFieldsValue["id-card"]
                },
                {
                  type: "select",
                  fieldName: "nationality",
                  inputValue: "Chinese"
                },
                {
                  type: "select",
                  fieldName: "citizenship",
                  inputValue: "Chinese"
                },
                {
                  type: "input",
                  fieldName: "lastNameCn",
                  inputValue: formFieldsValue["lastname-cn"]
                },
                {
                  type: "input",
                  fieldName: "firstNameCn",
                  inputValue: formFieldsValue["firstname-cn"]
                },
                {
                  type: "input",
                  fieldName: "addressCn",
                  inputValue: formFieldsValue["address-cn"]
                },
                {
                  type: "input",
                  fieldName: "residentialAddress",
                  inputValue: formFieldsValue["address-en"]
                },
                {
                  type: "input",
                  fieldName: "stateProvince",
                  inputValue: formFieldsValue["province"]
                },
                {
                  type: "select",
                  fieldName: "countryRegion",
                  inputValue: "China"
                },
                {
                  type: "select",
                  fieldName: "residentialStatus",
                  inputValue: "Owned"
                },
                {
                  type: "input",
                  fieldName: "moveInDate",
                  inputValue: formFieldsValue["move-to-date"]
                },
                {
                  type: "submit"
                }
              ];
              executeActions("app-account-opening-personal-details", actionConfigList);
            },
            "financial-details": () => {
              const actionConfigList = [
                {
                  type: "select",
                  fieldName: "occupation",
                  inputValue: "Clerk"
                },
                {
                  type: "select",
                  fieldName: "natureOfBusiness",
                  inputValue: "Information Technology"
                },
                {
                  type: "input",
                  fieldName: "nameOfEmployer",
                  inputValue: "PlanYun"
                },
                {
                  type: "select",
                  fieldName: "employeeStatus",
                  inputValue: "Full-time employment"
                },
                {
                  type: "input",
                  fieldName: "startJobDate",
                  inputValue: "Aug / 2018"
                },
                { type: "select", fieldName: "annualSalary", inputValue: "GBP 30,001 – GBP 60,000" },
                { type: "submit" }
              ];
              executeActions("app-account-opening-financial-details", actionConfigList);
            },
            "reason-to-open-account": () => {
              const actionConfigList = [
                {
                  type: "select",
                  fieldName: "mainReason",
                  inputValue: "Cash Deposit"
                },
                {
                  type: "select",
                  fieldName: "expectedAmountFirstDeposit",
                  inputValue: "<£50,000"
                },
                {
                  type: "select",
                  fieldName: "firstPaymentMethod",
                  inputValue: "Bank transfers from own account"
                },
                {
                  type: "select",
                  fieldName: "firstPaymentOrigin",
                  inputValue: "China"
                },
                {
                  type: "select",
                  fieldName: "mainIncomeSource",
                  inputValue: "Employment (Salaried)"
                },
                { type: "select", fieldName: "regularFundsSource", inputValue: "Employment (Salaried)" },
                {
                  type: "select",
                  fieldName: "internationalTransfersOriginAndDestination",
                  inputValue: "China"
                },
                {
                  type: "input",
                  fieldName: "monthlyFundTransferOrReceive",
                  inputValue: "500",
                  inline: true
                },
                {
                  type: "input",
                  fieldName: "monthlyPaymentOrTransfers",
                  inputValue: "2",
                  inline: true
                },
                {
                  type: "radio",
                  fieldName: "industryFlag",
                  inputValue: "1"
                },
                {
                  type: "radio",
                  fieldName: "weeklyOrMonthlyPaymentsFromBanksFlag",
                  inputValue: "1"
                },
                {
                  type: "submit"
                }
              ];
              executeActions("app-account-opening-reason-to-open-account", actionConfigList);
            },
            "information-about-our-products-and-services": async () => {
              const rootSelectorStr = "app-account-opening-information-about-our-products-and-services";
              const radio = document.querySelectorAll(
                `${rootSelectorStr} [nz-radio-button]`
              )[0];
              const checkbox = document.querySelectorAll(
                `${rootSelectorStr} [nz-checkbox]`
              )[2];
              executeActions(rootSelectorStr, [
                { type: "click", dom: radio },
                { type: "click", dom: checkbox },
                { type: "submit" }
              ]);
            },
            "review-application": async () => {
              const rootSelectorStr = "app-account-opening-review-application";
              executeActions(rootSelectorStr, [
                {
                  type: "click",
                  dom: document.querySelector(`${rootSelectorStr} button`)
                },
                { type: "submit" }
              ]);
            },
            "important-information-review": async () => {
              const rootSelectorStr = "app-account-opening-important-information-review";
              const links = document.querySelectorAll(`${rootSelectorStr} a.text-right`);
              if (Array.from(links).length === 0) {
                executeActions(rootSelectorStr, [{ type: "submit" }]);
                return;
              }
              const openTabActions = Array.from(links).map((link) => ({
                type: "openTab",
                dom: link
              }));
              const doms = document.querySelectorAll(`${rootSelectorStr} a.text-right span`);
              const clickActions = Array.from(doms).map((dom2) => ({
                type: "click",
                dom: dom2
              }));
              executeActions(rootSelectorStr, [...openTabActions, ...clickActions, { type: "submit" }]);
            }
          };
          actions[actionType] && actions[actionType]();
        };
        const onCancel = () => {
          setOpen(false);
          form.setFieldsValue(formFieldsValue);
        };
        const onSubmit = (fieldsValue) => {
          const config2 = validateIDCard(fieldsValue["id-card"]);
          if (config2) {
            const threeYearsAgo = dayjs().subtract(3, "year");
            formFieldsValue = {
              ...fieldsValue,
              "move-to-date": fieldsValue["move-to-date"].isBefore(threeYearsAgo) ? fieldsValue["move-to-date"].format("DD / MMM / YYYY") : threeYearsAgo.format("DD / MMM / YYYY"),
              "birthday": dayjs(config2.birthday).format("DD / MMM / YYYY"),
              "gender": config2.gender
            };
            console.log(formFieldsValue);
            setOpen(false);
            setIsAutoFill(true);
          }
        };
        React.useEffect(() => {
          if (isAutoFill) {
            autoFillAction();
          }
        }, [isAutoFill]);
        React.useEffect(() => {
          handleBodyChange();
          if (_monkeyWindow.onurlchange === null) {
            _monkeyWindow.addEventListener("urlchange", () => {
              autoFillAction();
            });
          }
        }, []);
        function handleBodyChange() {
          const callback = function() {
            const currentComponent = new URLSearchParams(location.search).get("component") || "";
            if (["important-information-review", "employed-or-business-partner"].includes(currentComponent)) {
              console.log("bodychange");
              autoFillAction();
            }
          };
          const observer = new MutationObserver(debounce(callback, 2e3));
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "side_btn", id: "fill-button", onClick: handleFillClick, children: isAutoFill ? "停 止 填 单" : " 一 键 填 单 " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Modal$1,
            {
              open,
              title: "自动填单信息收集",
              okText: "开始",
              cancelText: "取消",
              onCancel,
              onOk: () => {
                form.validateFields().then((values) => {
                  onSubmit(values);
                }).catch((info) => {
                  console.log("Validate Failed:", info);
                });
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Form$1, { form, layout: "vertical", name: "form_in_modal", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "phone",
                    label: "手机号",
                    rules: [{ required: true, message: "请填写手机号" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { maxLength: 11 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "id-card",
                    label: "身份证号码",
                    required: true,
                    rules: [
                      {
                        validator: (_, value) => regex["id-card"].test(value) ? Promise.resolve() : Promise.reject(new Error("请填写正确的身份证号码"))
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Form$1.Item, { label: "姓（中英文）", required: true, style: { marginBottom: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "lastname-cn",
                      rules: [{ required: true, message: "请填写您的姓氏(中文)" }],
                      style: { display: "inline-block", width: "calc(50% - 8px)" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的姓氏(中文)" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "lastname-en",
                      rules: [{ required: true, message: "请填写您的姓氏(英文)" }],
                      style: { display: "inline-block", width: "calc(50% - 8px)", margin: "0 8px" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的姓氏(英文)" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Form$1.Item, { label: "名（中英文）", style: { marginBottom: 0 }, required: true, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "firstname-cn",
                      rules: [{ required: true, message: "请填写您的名字(中文)" }],
                      style: { display: "inline-block", width: "calc(50% - 8px)" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的名字(中文)" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "firstname-en",
                      rules: [{ required: true, message: "请填写您的名字(英文)" }],
                      style: { display: "inline-block", width: "calc(50% - 8px)", margin: "0 8px" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的名字(英文)" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Form$1.Item, { label: "居住地址（中英文）", style: { marginBottom: 0 }, required: true, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "address-cn",
                      rules: [{ required: true, message: "请填写您的居住地址(中文)" }],
                      style: { marginBottom: "6px" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的居住地址(中文)" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Form$1.Item,
                    {
                      name: "address-en",
                      rules: [{ required: true, message: "请填写您的居住地址(英文)" }],
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您的居住地址(英文)，可采用拼音的形式拼写" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    label: "所在省份(英文)",
                    name: "province",
                    rules: [{ required: true, message: "请填写您所在的省份(英文)" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "请填写您所在的省份(英文)" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "move-to-date",
                    label: "开始居住日期",
                    rules: [{ required: true, message: "必填项不能为空" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatePicker$1, { format: "DD / MMM / YYYY" })
                  }
                )
              ] })
            }
          )
        ] });
      };
      const zh = {
        "Yes": "是",
        "No": "否",
        "Attention": "注意",
        "Open Account": "开户",
        "Login": "登录",
        "Help": "帮助",
        "Personal": "个人业务",
        "Business": "公司业务",
        "About Us": "关于我们",
        "I am applying for an account as": "我以下面的身份申请开户",
        "An Individual Applicant": "个人申请者",
        "Get Started": "开始",
        "Back": "返回",
        "Next": "下一步",
        "Continue": "继续",
        "Save & Continue": "保存并继续",
        "Cancel": "取消",
        "Submit": "提交",
        "Verified": "已验证",
        "Apply Now": "立即申请",
        "Personal Banking": "个人银行账户",
        "Corporate Banking": "公司银行账户",
        "Continue your unfinished application?": "继续未完成的申请？",
        "Continue your unfinished application": "继续未完成的申请",
        "We cannot locate an account with the information provided, please contact us for assistance": "我们无法根据所提供的信息找到帐户，请联系我们寻求帮助",
        "Forgot Password": "忘记密码",
        "Click here": "点击这里",
        "Find Out More": "了解更多",
        "User Type": "用户类型",
        "The UK digital bank that bridges you to the world.": "英国数字银行 带您联接世界",
        "Why iFAST Global Bank?": "为什么选择 iFast 环球银行？",
        "Regulated UK bank": "受监管的英国银行",
        "Fully regulated UK bank": "受全面监管的英国银行",
        "Following a single application, we offer you multi-currency account including GBP, USD, EUR, HKD, SGD and CNY": "多币种账户，包括英镑、美元、欧元、港币、新加坡元和人民币",
        "Your eligible deposits with us, are protected up to the total sum of £85,000 by the Financial Services Compensation Scheme (FSCS)": "合格存款受金融服务补偿计划 (FSCS) 保护，总金额高达 85,000 英镑",
        "Covered by the Financial Services Compensation Scheme (FSCS) up to a total sum of £85,000 eligible deposits": "受金融服务补偿计划 (FSCS) 保障，合格存款总额高达 85,000 英镑",
        "Free for account opening and pay no annual account fees": "免费开户，无年费",
        "Following a single application, we offer you": "一次申请，终身享有",
        "multi-currency access to GBP, USD, EUR, HKD, SGD and CNY": "英镑、美元、欧元、港币、新加坡元和人民币多币种账户",
        ". All in one place, no more hassle!": "。一处搞定，不再麻烦！",
        "The": " ",
        "UK digital bank": "英国数字银行 ",
        "that bridges you to the world": " 带您联接世界",
        "Your eligible deposits are protected by the": "保护您的合格存款——",
        "iFAST Global Bank is a fully regulated UK Bank. Your eligible deposits are protected by the Financial Services Compensation Scheme (FSCS) up to a value of": "iFAST 环球银行是一家受全面监管的英国银行。您的合格存款受到金融服务补偿计划 (FSCS) 的保护，最高价值为",
        "per person. FSCS is the UK’s deposit guaranteed scheme.": "/人。FSCS 是英国的存款担保计划。",
        "Earn as you deposit into your Multi-Currency Account": "存入多币种账户即可赚取收益",
        "Start putting your surplus cash with us today and enjoy up to 4.00% of AER interest. Interest accrues daily and is distributed monthly.": "今天开始存入您的剩余现金，享受高达 4.00% 的实际年利率。利息每天累积并每月分配。",
        "View Interest Rates": "查看利率",
        "Grow": "每日生息 ",
        "with daily interest": " 累积增长",
        "Join over 780,000 people in iFAST Group who use iFAST to save, invest and send your money instantly*, and it's free!": "超过 780,000 用户信赖 iFAST，使用 iFAST 储蓄、投资和汇款*，而且完全免费！",
        "*Terms and conditions apply. For any enquiries, please": "*详见适用条款和条件。如有任何疑问，请",
        "Contact Us.": "联系我们。",
        "View More FAQ": "查看更多常见问题解答",
        "Global banking at your fingertips": "指尖上的环球银行",
        "Download our app and manage your multi-currency account on-the-go!": "下载我们的应用程序，随时随地管理您的多币种帐户！",
        "Eligible deposits are": "合格存款",
        "protected by FSCS up to a total of £85,000": "受 FSCS 保护，金额最高可达 85,000 英镑",
        "Interest accrues and distributed daily.": "利息每日累积分配。",
        "Enjoy interest everyday": "收益天天见",
        "When we increase interest rate, you will": "当利率提高时，您将于",
        "enjoy the new rate the next day": "次日享受新利率",
        "Inform us 95 days ahead of your": "免费提款前 95 天通知我们，您将",
        "free withdrawal while you continue to earn daily interest": "继续赚取每日利息",
        "FAQs": "常见问题解答",
        "Is there a minimum or maximum balance requirement for the current interest rate to be applicable? Can the multi-currency account be accessed instantly?": "当前利率是否有最低或最高余额要求？多币种账户可以即时访问吗？",
        "No matter how much or how little you deposit, the current interest rate will always apply without any conditions. Please note that the interest rate is variable hence it is subject to changes. The multi-currency account provides instant access for all the 6 currencies available.": "无论您存款多少，当前利率将始终适用，无任何条件。请注意，利率是波动的，因此可能会发生变化。多币种账户提供所有 6 种可用货币的即时访问。",
        "How do I open an account with iFAST Global Bank? Is my deposit protected?": "我如何在 iFAST 环球银行开设账户？我的存款受保护吗？",
        "To open an account with iFAST Global Bank, you need to follow these 6 easy steps:\n\nStep 1: Go to our website and fill out the application form.\nStep 2: Gather your ID or passport and address proof, which you need to upload.\nStep 3: Our onboarding team will contact you to arrange a video call for verification.\nStep 4: You will receive a confirmation email that will include the scheduled time for the video call.\nStep 5: After the video call, the bank will review your application and inform you of the outcome soon.\nStep 6: Once your application is approved, you can start using your account. iFAST Global Bank is a fully regulated UK Bank. Your eligible deposits are protected by the Financial Services Compensation Scheme (FSCS) up to a value of £85,000 per person.": "在 iFAST 环球银行开设账户，您需要遵循以下 6 个简单步骤：\n\n第 1 步：访问我们的网站并填写申请表。\n第 2 步：收集您的身份证件或护照以及地址证明。需要上传。\n第 3 步：我们的专职团队将联系您安排视频通话进行验证。\n第 4 步：您将收到一封确认电子邮件，其中包含视频通话的预定时间。\n第 5 步：视频通话结束后，银行将审核您的申请并尽快通知您结果。\n第 6 步：您的申请获得批准后，您就可以开始使用您的账户了。iFAST环球银行是一家受全面监管的英国银行。您的合格存款受到金融服务补偿计划 (FSCS) 的保护，最高每人价值 85,000 英镑。",
        "What are the required documents for the application? How do I talk to someone from customer services?": "申请时需要提供哪些文件？我如何与客户服务人员交谈？",
        "The necessary documents may vary based on your nationality. Typically, you will need to provide proof of identity, such as your passport, ID card, or driver's license, and proof of address, like bank statements, utility bills, council tax letters, or letters from local government, that are issued within the last three months. If any further documents are necessary, our onboarding team will inform you during the scheduling call, and you can submit them by replying to our email at clienthelp@ifastgb.com, or by uploading to your application. You can message us, request for audio call or video call with us via our live chat function. Our live chat is open 1am to 530pm GMT (2am to 530pm British Summer Time) on weekdays, except for public holidays.": "必要的文件可能因您的国籍而异。通常，您需要提供身份证明，例如您的护照、身份证或驾照，以及地址证明，例如银行对账单、公用事业账单、市政税信函或当地政府的信函，这些信函均在过去三个月内由当地政府签发。如果需要任何其他文件，我们的专职团队将在安排电话会议期间通知您，您可以通过回复我们的电子邮件 clienthelp@ifastgb.com 或上传到您的申请来提交这些文件。您可以通过我们的实时聊天功能向我们发送消息、请求音频通话或视频通话。我们的实时聊天开放时间为工作日凌晨 1 点至下午 5:30（英国夏令时凌晨 2 点至下午 5:30），公众假期除外。",
        'How can I make an international payment at no cost? What is "Transfer within iFAST Group"?': "如何进行免费国际付款？什么是「iFAST 集团内部转账」？",
        'If you hold an iFAST investment account in any of our Asian network countries, you can take advantage of our "Transfer within iFAST group" feature to move your funds between the UK and our Asian network countries instantly and at no cost. iFAST Global Bank enables you to benefit from the iFAST ecosystem by using the "Transfer within iFAST Group" function to transfer money instantly between countries within the network. With over 780,000 individuals in the iFAST group already using iFAST for their investment and savings needs, you can do the same. This feature serves as a link between your iFAST Global Bank account and your iFAST investment account, which is located in Hong Kong, Singapore, and Malaysia. You can transfer money quickly cross-border and without any charges.': "如果您在任何一个亚洲网络国家/地区持有 iFAST 投资账户，您可以使用我们的「iFAST 集团内部转账」功能，在英国和我们的亚洲网络国家/地区之间即时免费转移您的资金。iFAST 环球银行让您可以利用「iFAST 集团内部转账」功能，在网络内的国家之间即时转账，从而从 iFAST 生态系统中获益。iFAST 集团已服务超过 780,000 名客户，满足他们的投资和储蓄需求，您也同样可以享受。此功能可连接您的 iFAST 环球银行账户和位于香港、新加坡和马来西亚的 iFAST 投资账户。您可以快速跨境转账，无需支付任何费用。",
        "To Help Us Understand You Better": "增进了解，精益服务",
        "Have you registered with any companies of iFAST Group?": "您是否曾在奕丰集团（iFAST Group）旗下任何公司有过注册？",
        "No, I am new to iFAST": "没有，我是新客户",
        "Yes, I am an iFAST client": "是的，我是老客户",
        "Are you currently employed by or a business partner of iFAST Group?": "您目前是否受雇于奕丰集团或其业务合作伙伴？",
        "No, I am not": "不，我不是",
        "Yes, I am": "是的，我是",
        "Which iFAST Group role are you associated with?": "您属于奕丰集团（iFAST Group）的哪个职位？",
        "I am an iFAST employee": "我是 iFAST 的雇员",
        "I am an iFAST business partner": "我是 iFAST 的合作伙伴",
        "To proceed further,": "在开始注册前，",
        "Could you kindly provide us with your respective code?": "请提供您的渠道代码",
        "Select the business partner region/country that you are connected to": "选择您所属的业务合作伙伴地区/国家",
        "Please enter your respective code": "请输入您的渠道代码",
        "Hong Kong": "香港",
        "Singapore": "新加坡",
        "Malaysia": "马来西亚",
        "China": "中国",
        "India": "印度",
        "EzRemit": "易汇",
        "Create your login for now and future": "创建账户",
        "So we can auto-save along your application, and you can continue with the login anytime. This is also the login for your future online banking.": "我们会自动保存您的申请，您可以随时登录继续申请。同时这也是您未来网上银行的登录名。",
        "Verify": "验证",
        "Email Address": "Email邮箱地址",
        "Login Name": "登录名",
        "Email Address or Login Name": "email邮箱地址或登录名",
        "Login name must be at least 8 characters": "登录名必须至少 8 个字符",
        "Login name must contain alphabet value and combination of alphanumeric value only": "登录名只能包含字母或字母数字的组合",
        "Password": "密码",
        "Re-Enter Password": "再次输入密码",
        "Password must not contain sequential characters from username": "密码不得包含用户名的连续字符",
        "Minimum 8 characters": "至少 8 个字符",
        "One upper/lower case": "至少 1 个大写/小写字符",
        "One number": "至少 1 个数字",
        "One special character": "至少 1 个特殊字符",
        "Please make sure this field is not blank.": "请确保该字段不为空。",
        "Login name is required": "用户名必填",
        "Password is required": "密码必填",
        "Re-enter password is required": "再次输入密码必填",
        "Please make sure your passwords match": "请确保两次输入密码相同",
        "Please make sure the requirement below has been fulfilled": "请确保满足以下要求",
        "Please make sure the format of the password follows the requirements below": "请确保密码格式符满足以下要求",
        "Please enter a valid email": "请输入有效的email地址",
        "Your application:": "您的申请：",
        "iFAST Global Bank account in United Kingdom": "iFAST 环球银行英国账户",
        "Verify your Email Address": "验证您的邮箱",
        "Send OTP": "发送验证码",
        "A 6-digit One Time Password (OTP) will be sent via email to": "6 位验证码（OTP）将通过电子邮件发送至 ",
        "Enter the OTP below to verify your email.": "输入 6 位验证码以验证您的邮箱。",
        "The OTP will be valid for 10 minutes.": "验证码 10 分钟内有效。",
        "Resend OTP": "重新发送",
        "Important information about this account": "关于此帐户的重要信息",
        "Check your eligibility": "检查您的资格",
        "Before you apply for iFAST Global Bank account, please confirm you meet the following criteria": "申请 iFAST 环球银行账户前，请确认您符合以下条件",
        "You are applying for a personal account": "您正在申请个人账户",
        "You are age 18 years or above": "您已年满 18 周岁",
        "You live in": "您居住在",
        "You are currently located in": "您目前位于",
        "FATCA Status": "FATCA 状态",
        "Before we start, let us determine your Foreign Account Tax Compliance Act (FATCA) status": "在开始之前，我们需要确定您的海外账户税收合规法案 (FATCA) 状态",
        "U.S. Indicia": "美国身份",
        "Do you possess any of the following U.S. indicia?": "您是否拥有以下任何美国身份？",
        "US citizenship/tax residency (e.g. US passport/Green Card holder, U.S. taxpayer, etc.)": "美国公民身份/税收居民身份（例如美国护照/绿卡持有人、美国纳税人等）",
        "US place of birth": "出生在美国",
        "US address (e.g. residential address, mailing address, P.O. box)": "拥有美国地址（例如居住地址、邮寄地址、邮政信箱）",
        "US telephone number": "美国电话号码",
        "Please note that due to restrictions and tax reporting requirements to U.S. persons, we are sorry to inform that we are unable to open accounts for an individual with U.S. citizenship/ U.S. Permanent Resident Status/ U.S. Taxpayer Identification Number (TIN) and/ or U.S. Residential/ Mailing Address. For further clarification, please contact us.": "请注意，由于对美国人的限制和税务报告要求，我们很抱歉地通知您，我们无法为具有美国公民身份/美国永久居民身份/美国纳税人识别号 (TIN) 和/或美国住宅 / 邮寄地址的个人开设账户。如需进一步说明，请联系我们。",
        "Repeating instructions to pay amounts from iFAST account to a US account maintained in the US": "重复指示从 iFAST 账户向在美国维护的美国账户付款",
        "Tax Residency": "税务居民",
        "Jurisdiction of Residence for Tax Purposes": "税务管辖地",
        "Is Tax Identification Number (TIN) available?": "税号 (TIN) 可用吗？",
        "Tax Identification Number": "税号",
        "Apart from the above, do you have any additional tax residency?": "除上述之外，您还有其他税务居民身份吗？",
        "You might need to provide additional supporting document if you have additional tax residency": "如果您有额外的税务居民身份，您可能需要提供额外的支持文件",
        "+ Add Additional Tax Residency": "+ 添加额外的税收居民身份",
        "Personal Details": "个人信息详情",
        "To get started, tell us about yourself": "开户需要您的个人信息",
        "Contact Information": "联系信息",
        "Personal Information": "个人信息",
        "Residential Information": "居住信息",
        "When did you move to this address?": "您什么时候搬到此地址？",
        "If less than 3 years, you will be required to fill up your past residential address.": "如果少于3年，则需填写过去的居住地址。",
        "Correspondence address same with residential address": "通讯地址与居住地址相同",
        "Where would you like us to send your correspondence to": "您希望我们将您的信件寄往",
        "Send it to my current correspondence address": "发送至我当前的通讯地址",
        "Send it to an alternative mailing address": "发送至其他邮寄地址",
        "Alternative mailing address": "其他邮寄地址",
        "Correspondence address": "通讯地址",
        "Country Code": "国家编号",
        "Mobile Number": "手机号码",
        "Alternative Number (Optional)": "备用号码（可选）",
        "Title": "称呼",
        "Last name (Surname)": "姓",
        "First name (Given Name)": "名",
        "Middle name (optional)": "中间名（可选）",
        "Gender": "性别",
        "Date of birth": "出生日期",
        "Country of ID Issue": "证件签发国",
        "ID Type": "证件类型",
        "ID Number (Alphanumeric only)": "证件号（仅限数字字母）",
        "Nationality": "国籍",
        "Citizenship": "公民身份",
        "Residential Address": "居住地址",
        "State/Province": "省",
        "Postal/Zip Code": "邮编",
        "Country/Region": "国家/地区",
        "Residential Status": "居留状态",
        "Select Date": "选择日期",
        "Select Month": "选择日期",
        "Female (including Transgender Female)": "女",
        "Male (including Transgender Male)": "男",
        "Identity Card": "身份证",
        "Passport": "护照",
        "Residence Permit": "居留许可证",
        "Living with Family": "与家人同住",
        "Mortgaged": "按揭",
        "Owned": "自有",
        "Rented": "租赁",
        "Financial Details": "财务信息",
        "Allow us to know your financial details": "我们需要了解您的财务状况",
        "Occupation Information": "工作信息",
        "Occupation": "职位",
        "Nature of Business": "所在行业",
        "Name of Employer": "雇主名称",
        "Employment Status": "雇佣状态",
        "Full-time employment": "全职",
        "Part time employment": "兼职",
        "Self-employed": "个体经营",
        "Student and retired": "学生或退休",
        "Unemployed": "自由职业",
        "None": "未知",
        "When did you start this job?": "合适开启此份工作？",
        "Financial Information": "财务信息",
        "Your annual salary in GBP": "年收入（英镑）",
        "Other income in GBP (optional)": "其他收入（英镑）（可选）",
        "Other incomes includes": "其他收入包括",
        "Rental income": "租金收入",
        "Dividends": "分红",
        "Investment income": "投资收益",
        "Others (please specify)": "其他（请注明）",
        "Other incomes (other)": "其他收入（其他）",
        "Reason to open account": "开户缘由",
        "We wish to know:": "我们希望了解：",
        "What's your main reason for wanting to bank with iFAST Global Bank?": "您想在 iFAST 环球银行办理银行业务的主要原因是什么？",
        "Bank transfers from 3rd party": "来自第三方的银行转账",
        "Bank transfers from own account": "来自自己账户的银行转账",
        "Cash Deposit": "现金存款",
        "Investment": "投资",
        "Payments of daily expenses": "支付日常费用",
        "Receiving salary": "领取工资",
        "Saving": "储蓄",
        "Send money abroad": "汇款到国外",
        "Your first deposit": "首次存款",
        "What's the expected amount of your first deposit in GBP?": "您的第一笔存款金额预计是多少（英镑）？",
        "How would you make the first payment into your account?": "您将如何将第一笔存款存入您的帐户？",
        // "Bank transfers from own account": "自有账户转账",
        "Salary Payment from employer": "雇主支付工资",
        "Transfers from remittance account": "从汇款账户转帐",
        "Other source (Please specify)": "其他来源（请注明）",
        "First payment method (Others)": "第一笔存款方式（其他）",
        "Where will the first payment into your account come from?": "第一笔存款将来自哪里？",
        "Ongoing funding": "持续存款",
        "What is your main source of income?": "您的主要收入来源是什么？",
        "Where do you expect the majority of your incoming international transfers to originate from?": "您预计大部分国际转账来自哪里？",
        "Where do you expect your regular/monthly account funds to come from?": "您预计定期/每月账户资金从何而来？",
        "How much money do you expect to receive and transfer each month?": "您预计每月收到和转账多少钱？",
        "How many transactions do you expect to take place each month?": "您预计每月会发生多少笔交易？",
        "Do you work in or are the funds derived from the following industries such as money changers, casino, gambling, moneylenders, cryptocurrencies, etc?": "您是否在以下行业工作或您的资金来自以下行业，例如货币兑换商、赌场、赌博、放债人、加密货币等？",
        "Will anyone make weekly or monthly payments into your account, except for salary, rental income or dividends?": "除工资、租金或分红之外，是否会有人每周或每月向您的账户付款？",
        "Business earnings": "经营所得",
        "Employment (Retirement Income)/Pension": "就业（退休收入）/养老金",
        "Employment (Salaried)": "就业（受薪）",
        "Employment (Self-employed)": "就业（个体经营）",
        "Inheritance/Family gift": "遗产/家族赠与",
        "Investment income/returns": "投资收入/回报",
        "Property sales or rental income": "物业销售或租金收入",
        "Other source": "其他来源",
        "Reason of banking": "开户缘由",
        "Expected Deposit Amount": "预计存款金额",
        "First Payment Method": "首次支付方式",
        "Main income source": "主要收入来源",
        "Regular funds source": "定期资金来源",
        "Number of times": "次数",
        "Information about our products & services": "我们的产品和服务",
        "Personal Data in Direct Marketing": "直接营销中的个人数据",
        "Your personal data will be used by iFAST Global Bank Limited (iFAST Global Bank) for the following direct marketing purposes:": "您的个人资料将由 iFAST 环球银行有限公司（iFAST 环球银行）用于以下直接营销目的：",
        "To send invitation to you on any marketing events or seminars;": "向您发送营销活动或研讨会的邀请；",
        "To send marketing materials to you regarding any products or other promotional offers in relation to your Account.": "向您发送与您帐户相关的产品或其他促销优惠的营销材料。",
        "Note: iFAST Global Bank will not use or transfer your personal data for the above mentioned purposes of direct marketing, unless iFAST Global Bank obtains your written consent to the intended use or transfer.": "注：iFAST 环球银行不会将您的个人资料用于上述直接营销目的，除非 iFAST 环球银行获得您对拟使用或转移的书面同意。",
        "I have read and understood the": "我已经阅读并了解 iFAST 环球银行的",
        "Privacy Policy": "隐私条款",
        "of iFAST Global Bank and the above provisions on the use of my personal data by iFAST Global Bank, and hereby declare that I agree to iFAST Global Bank using my personal data for the direct marketing purposes as stated above.": "以及上述有关 iFAST 环球银行使用本人个人资料的规定，并特此声明本人同意 iFAST 环球银行将本人个人资料用于上述直接营销目的。",
        "How would you like to be contacted about our products and services?": "您希望我们如何将我们的产品和服务告知到您？",
        "Phone": "电话",
        "Text": "短信",
        "Email": "电子邮件",
        "Are you a tax resident in any jurisdiction(s)?": "您是任何司法管辖区的税务居民吗？",
        "Tax Residency 1": "税务居民 1",
        "Industry/Sector": "行业/领域",
        "Agree & Continue": "同意并继续",
        "By clicking": "点击",
        ", I have reviewed the above application, and confirm that all the information provided are as of latest and accurate.": "即表示，我已审查了上述申请，并确认所提供的所有信息均为最新且准确的。",
        "Important Information": "重要信息",
        "Please review these documents before electronically signing and submitting your application:": "请在以电子方式签署并提交您的申请之前查看一下文件：",
        "Pending Review": "待查看",
        "Opened": "已查看",
        "Financial Services Compensation Scheme (FSCS)": "金融服务补偿计划 (FSCS)",
        "Personal Bank Account General Terms & Conditions": "个人银行账户一般条款和条件",
        "Personal Bank Account Fee Information Document": "个人银行账户费用信息文件",
        ", I have read and accept all account disclosures.": "即表示，我已阅读并接受所有帐户披露信息。",
        "English Language Disclaimer": "英语免责声明",
        "We have provided some text in this application in your local language. If there are questions or discrepancies on the accuracy of information in the translated version, please refer to the English version, which is the official version of the website. All account information and terms and conditions is provided in English and will prevail over any translations.": "我们在此应用程序中以您的本地语言提供了一些文本。如果翻译版本中的信息准确性存在疑问或差异，请参阅英文版本，该版本是网站的官方版本。所有帐户信息以及条款和条件均以英文提供，并优先于任何翻译版本。",
        "Use of your information": "信息使用条款",
        "For the purpose of this application, I authorise the Bank and any other member of iFAST Group to": "就本申请而言，本人授权银行及 iFAST 集团任何其他成员",
        "Share this application, together with any related documentation or information, with other members of the iFAST Group and their agent named in the application.": "与 iFAST 集团的其他成员及其在申请中指定的代理人分享此申请以及任何相关文件或信息。",
        "Share any information permitted by law with other members of the iFAST Group and their agents named in the application for assessing my qualification for the requested financial products.": "与 iFAST 集团的其他成员及其在申请中指定的代理人分享法律允许的任何信息，以评估我对所要求的金融产品的资格。",
        "Input any information relating to this application onto a database which may be accessed by other members of the iFAST Group involved in the application , unless and until I direct otherwise.": "将与本申请相关的任何信息输入数据库，该申请涉及的 iFAST 集团其他成员可以访问该数据库，除非且直至我另有指示。",
        "I understand that although data/privacy protection laws may vary in different countries, my information will be protected by a strict code of secrecy and security observed by all members of the iFAST Group, their staff and any third parties. I understand that this consent only applies to this application, and that any future applications will require a separate consent form.": "我明白，虽然不同国家的数据/隐私保护法可能有所不同，但我的信息将受到 iFAST 集团所有成员、其员工和任何第三方遵守的严格保密和安全准则的保护。我了解此同意书仅适用于本次申请，任何未来的申请都需要单独的同意书。",
        "Consent to Submit": "提交许可",
        "I certify that where I have provided information regarding any other person (such as a Controlling person or other Reportable Person to which this form relates) that I will, within 30 days of signing this form, notify those persons that I have provided such information to iFAST and that such information may be provided to the tax authorities of the country in which the account(s) is/are maintained and exchanged with tax authorities of another country or countries in which the person may be tax resident pursuant to intergovernmental agreements to exchange financial account information. A Controlling Person is defined as a person, other than a Financial Institution, holding a Financial Account for the benefit of another person as an agent, a custodian, a nominee, a signatory, an investment advisor, an intermediary, or as a legal guardian; A Reportable Person is defined as any individual who is tax resident in a reportable jurisdiction (i.e. a jurisdiction with which an obligation to provide financial account information is in place) under the tax laws of that jurisdiction.": "我保证，如果我提供了有关任何其他人（例如与本表格相关的控制人或其他应报告人）的信息，我将在签署本表格后 30 天内通知这些人我已向 iFAST 提供了此类信息，并且此类信息可能会提供给账户所在国家/地区的税务机关，并根据政府间协议与该人可能是税务居民的另一个国家/地区的税务机关进行交换 金融账户信息。控制人的定义是除金融机构外，以代理人、托管人、代理人、签字人、投资顾问、中介人或法定监护人的身份为他人利益持有金融账户的人 ; 应报告人被定义为根据该司法管辖区税法属于应报告司法管辖区（即有义务提供财务账户信息的司法管辖区）的税务居民的任何个人。",
        "Agree and submit": "同意并提交",
        "By selecting “Agree and submit”, you confirm that you have read all information provided and believe that all facts stated are true.": "点击“同意并提交”，即表示您确认您已阅读所提供的所有信息并确信所陈述的所有事实都是真实的。",
        "I confirm that the details input on this application are correct to the best of my knowledge and that I’ve read and agree to the current.": "我确认，据我所知，本申请中输入的详细信息是正确的，并且我已阅读并同意当前内容。",
        "Terms and Conditions": "条款和条件",
        "and": "和",
        "Fees Information": "费用信息",
        "Skip and Upload Later": "稍后上传",
        "Upload your Documents": "上传文件",
        "You can alternatively snap a picture to upload your document by scanning this QR code with your mobile phone.": "您也可以使用手机扫描此二维码拍照上传您的文件。",
        "Expires in:": "过期：",
        "Support for a single or bulk upload. A maximum of 5 files and they must be in either PDF, GIF, JPG, JPEG, PNG, and JFIF format. The maximum permissible size for each uploaded file is 5mb.": "支持单次或批量上传。最多 5 个文件，且格式必须为 PDF、GIF、JPG、JPEG、PNG 和 JFIF。每个上传文件的最大允许大小为 5Mb。",
        "Click or drag file to this area to upload": "点击或拖拽文件至此区域即可上传",
        "Identity Proof": "身份证明",
        "Address Proof": "地址证明",
        "A full clear copy of Passport or National Identity Card front and back if applicable.": "护照或居民身份证正面和背面的完整清晰副本（如果适用）。",
        "Download Sample": "下载范例",
        "Take/upload a clear colour photo of your address proof dated within the last 3 months.": "拍摄/上传最近 3 个月内的地址证明的清晰彩色照片。",
        "Clear full coloured": "清晰全彩",
        "Black and white/blur photo": "黑白/模糊",
        "Screenshots or recordings of the Digital Identity Card": "电子身份证的截图或翻录",
        "Bank statements, bills or statement from other regulated financial institutions dated within the last 3 months.": "过去 3 个月内的银行对账单、账单或其他受监管金融机构的对账单。",
        "Please ensure that the address proof document corresponds to the most recent residential address.": "请确保地址证明文件与最近的居住地址相符。",
        "Address proof corresponds to the most recent residential address": "地址证明对应最近的居住地址",
        "Telco or mobile phone bill is not acceptable": "不接受电话或手机账单",
        "Do not have your documents certified? We are here to help!": "您的文件未经认证吗？我们随时为您提供帮助！",
        "I need help with certification": "我需要认证协助",
        "Appointment of certifier": "指定认证员",
        "I hereby would like to:": "本人谨此：",
        "Appoint the staff of iFAST Global Bank and/or iFAST Group members to verify and certify my uploaded documents.": "委托 iFAST 环球银行及/或 iFAST 集团成员的职员核实及证明我上传的文件。",
        "You will be contacted by one of our onboarding team members via a UK number": "我们的专职团队成员将通过英国号码与您联系",
        "By confirming this appointment, you hereby agree to pass on your uploaded documents to your appointed certifier. Your appointed certifier will be in contact with you to witness the original documentation and ensure that they are accurate copy of the original.": "通过确认此委托，您特此同意将您上传的文件传递给您指定的认证员。您指定的认证员将与您联系，见证原始文件并确保它们是原件的准确副本。",
        "Your application reference no. is": "您的申请号为",
        "To complete your application, please proceed to submit your supporting documents.": "要完成您的申请，请继续提交您的证明文件。",
        "Global Services Centre": "全球服务中心",
        "Manage your application or simply reach out for support via iFAST Global Bank": "管理您的申请或寻求帮助可以添加 iFAST 环球银行的",
        "WhatsApp at": "WhatsApp",
        "Save our number or scan the QR code to Whatsapp us.": "保存我们的电话号码或用 Whatapp 扫描二维码联系我们。",
        "Logout": "登出",
        "View my submitted application": "浏览我的申请材料",
        "Upload supporting documents": "提交证明文件",
        "iFAST Global Bank Limited is part of the iFAST Group": "iFAST 环球银行有限公司隶属于 iFAST 集团。iFAST 集团为新加坡国家主权基金淡马锡控股企业。",
        "Useful Links": "快捷链接",
        "Responsible Bank": "责任银行",
        "How-to Guides": "帮助指南",
        "Press & Media": "新闻与媒体",
        "Investor Relations": "投资者关系",
        "Women in Finance Charter": "女性金融宪章",
        "Open Banking": "开放银行",
        "iFAST Global Bank": "iFAST 环球银行",
        "iFAST Global Bank is a member of the Financial Services Compensation Scheme (FSCS).": "iFAST 环球银行是金融服务补偿计划（FSCS）的成员。",
        "iFAST Global Bank is authorised by the Prudential Regulation Authority and regulated by the  Financial Conduct Authority and the Prudential Regulation Authority. Our Financial Services Register number: 716167. Registered in England and Wales: company number 4797759.": "iFAST 环球银行获审慎监管局授权，并受金融行为监管局和审慎监管局监管。我们的金融服务注册号：716167。在英格兰和威尔士注册：公司号 4797759。",
        "Click here to see": "点击这里查看",
        "The FSCS Information Sheet": "金融服务补偿计划信息表",
        "Legal": "法律",
        "Privacy": "隐私",
        "Cookie Policy": "Cookie 政策",
        "Review Application": "浏览申请信息",
        "Download PDF": "下载PDF",
        "Application reference no:": "申请号：",
        "End of application": "我是有底线的",
        "Welcome to Online Banking!": "欢迎使用网上银行！",
        "Forgot Password?": "忘记密码？",
        "New customer? Apply for an account in minutes!": "还未开户？一分钟快速开户！",
        "What is the next step?": "接下来做什么？",
        "Have you booked your appointment for video verification? If you have booked an appointment with us, sit back and mark your calendar.": "您已预约视频验证了吗？如果您已预约，请将预约加入您的日历。",
        "If you have yet to schedule it, book now or message us via WhatsApp or Chat.": "如果您尚未预约，请立即预约或通过 WhatsApp 或在线客服联系我们。",
        "Book Appointment Now": "立即预约",
        "WhatsApp Us": "发送 WhatsApp 信息",
        "Chat Now": "在线联系我们"
      };
      const i18n = {
        zh
      };
      let originalTextMap = /* @__PURE__ */ new Map();
      function translatePage(targetLanguage) {
        const textNodes = getTextNodes(document.body);
        for (const node2 of textNodes) {
          if (node2.nodeType === 3) {
            const translatedText = translateText(
              node2.parentElement,
              node2.textContent,
              targetLanguage,
              "_helper-text-hash"
            );
            node2.textContent = translatedText;
          }
          if (node2.nodeType === 1) {
            const translatedText = translateText(
              node2,
              node2.placeholder,
              targetLanguage,
              "_helper-placeholder-hash"
            );
            node2.placeholder = translatedText;
          }
        }
        console.log("translate store size:", originalTextMap.size);
      }
      function getTextNodes(node2) {
        let all2 = [];
        for (node2 = node2.firstChild; node2; node2 = node2.nextSibling) {
          if (node2.nodeType === 3 || node2.nodeType === 1 && node2.placeholder) {
            all2.push(node2);
          } else {
            all2 = all2.concat(getTextNodes(node2));
          }
        }
        return all2;
      }
      function translateText(currentElement, text, targetLanguage, hashKey) {
        const hashId = nanoid(10);
        const translatedText = i18n[targetLanguage][text.trim()] || text;
        const oldHashId = originalTextMap.has(currentElement.getAttribute(hashKey));
        if (!oldHashId && translatedText !== text) {
          currentElement.setAttribute(hashKey, hashId);
          originalTextMap.set(hashId, text);
        }
        return translatedText;
      }
      function restoreOriginalText() {
        const textNodes = document.querySelectorAll("[_helper-text-hash]");
        for (const node2 of textNodes) {
          const hashId = node2.getAttribute("_helper-text-hash");
          const originalText = originalTextMap.get(hashId);
          if (!originalText)
            continue;
          node2.textContent = originalText;
        }
        const placeholderNodes = document.querySelectorAll("[_helper-placeholder-hash]");
        for (const node2 of placeholderNodes) {
          const hashId = node2.getAttribute("_helper-placeholder-hash");
          const originalText = originalTextMap.get(hashId);
          if (!originalText)
            continue;
          node2.placeholder = originalText;
        }
      }
      const translate = {
        translatePage,
        restoreOriginalText
      };
      const TranslateButton = () => {
        const [isTranslated, setIsTranslated] = React.useState(false);
        React.useEffect(() => {
          handleBodyChange();
        }, []);
        function handleBodyChange() {
          const callback = function() {
            const btn = document.querySelector("#blue-helper");
            if (btn.textContent === " 一 键 还 原 ") {
              translate.translatePage("zh");
            }
          };
          const observer = new MutationObserver(debounce(callback, 1e3));
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
        const handleTranslateClick = React.useCallback(() => {
          if (!isTranslated) {
            translate.translatePage("zh");
          } else {
            translate.restoreOriginalText();
          }
          setIsTranslated(!isTranslated);
        }, [isTranslated]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "side_btn", id: "blue-helper", onClick: handleTranslateClick, children: isTranslated ? " 一 键 还 原 " : " 一 键 翻 译 " });
      };
      function App() {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "helper-fixed-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TranslateButton, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FillButton, {})
        ] });
      }
      client.createRoot(
        (() => {
          const app = document.createElement("div");
          app.id = "igb-helper";
          document.documentElement.append(app);
          return app;
        })()
      ).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider$1, { prefixCls: "igb", children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
      );
    }
  });
  require_main_001();

})(React, ReactDOM);
