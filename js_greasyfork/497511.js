// ==UserScript==
// @name       企微发送今日上线清单
// @namespace  npm/vite-plugin-monkey
// @description  SHEIN商品发布企微发送今日上线清单,且只能一个人运行
// @version    0.0.0
// @author     Pei Li
// @icon       https://www.shein.com/favicon.ico
// @match      https://jira.dotfashion.cn/issues/?jql=*
// @require    https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js
// @require    https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js
// @grant      GM_addStyle
// @grant      GM_getValue
// @grant      GM_info
// @grant      GM_notification
// @grant      GM_openInTab
// @grant      GM_setValue
// @grant      GM_xmlhttpRequest
// @license    GPL
// @downloadURL https://update.greasyfork.org/scripts/497511/%E4%BC%81%E5%BE%AE%E5%8F%91%E9%80%81%E4%BB%8A%E6%97%A5%E4%B8%8A%E7%BA%BF%E6%B8%85%E5%8D%95.user.js
// @updateURL https://update.greasyfork.org/scripts/497511/%E4%BC%81%E5%BE%AE%E5%8F%91%E9%80%81%E4%BB%8A%E6%97%A5%E4%B8%8A%E7%BA%BF%E6%B8%85%E5%8D%95.meta.js
// ==/UserScript==

(o=>{if(typeof GM_addStyle=="function"){GM_addStyle(o);return}const t=document.createElement("style");t.textContent=o,document.head.append(t)})(' .drawer_container .ant-drawer-body{padding:0 24px 24px!important;overflow:hidden!important;display:flex!important}.drawer_container .ant-tabs{flex:1!important}.drawer_container .ant-tabs-nav{height:42px!important}.drawer_container .ant-tabs-content-holder{flex:1!important;overflow-y:auto!important}.data_container{display:flex;flex-direction:column}.title{display:flex;align-items:center}.body_container{display:flex;flex-direction:column}.body_container p{margin:0}.tr_item{margin-top:8px;background:#f0f0f8;padding:4px 7px;border-radius:4px;width:100%;display:flex;flex-direction:column}.tr_header{display:flex;align-items:center}.tr_link{width:75px;font-weight:700}.tr_title{flex:1;width:0}.tr_p{margin-top:6px;margin-bottom:0}.tr_pre{margin-top:2px}.tr_p_info{margin-top:2px;margin-bottom:0;display:flex;align-items:center}.data_item{display:flex;flex-direction:row;align-items:baseline;margin-bottom:20px}.data_input{margin-right:5px}.data_title{min-width:65px;padding:4px 0;text-align:right}.data_content{display:flex;flex-direction:column;flex:1}.tr_body{display:flex;flex-direction:column}.success_tag{cursor:pointer}.tr_red{color:red;margin-top:4px}.shein-components_icon_icon{display:inline-block;font-style:normal;line-height:0;text-align:center;text-transform:none;vertical-align:-.125em;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:inherit}.shein-components_icon_icon:before{display:none}.shein-components_icon_icon svg{width:1em;height:1em;fill:currentColor;overflow:hidden;display:inline-block;line-height:1;font-size:inherit}.gradient{-webkit-background-clip:text;background-image:linear-gradient(360deg,rgba(49,209,220,.9) 0%,rgba(44,80,238,.9) 100%);-webkit-text-fill-color:transparent}/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */body{--btn-hover-darken: 10%;--primary-color: #3399ff;--primary-color-fade-50: rgba(51, 153, 255, .5);--gray-500: #adb5bd}*,*:before,*:after{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}body{margin:0;color:var(--gray-900, #212529);font-family:var(--common-body-font-family, "Chinese Quote", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif);font-size:var(--font-size-base, 14px);line-height:var(--common-line-height, 1.42857143)}article,aside,footer,header,nav,section{display:block}h1{margin:.67em 0;font-size:2em}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{overflow:visible;height:0;box-sizing:content-box}pre{font-family:SFMono-Regular,Menlo,Monaco,Consolas,Courier New,monospace;font-size:1em}a{background-color:transparent;color:var(--primary-color, #3399ff);cursor:pointer;outline:none;text-decoration:none;-webkit-text-decoration-skip:objects;transition:color .3s}a:active,a:hover{color:var(--primary-color-dark-15, #0073e5);outline:0;text-decoration:none}a[disabled]{color:var(--gray-600, #6c757d);cursor:not-allowed;pointer-events:none}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:100%;line-height:1.15}button,input{overflow:visible}button,select{text-transform:none}button,html [type=button],[type=reset],[type=submit]{-webkit-appearance:button}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{padding:0;border-style:none}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{display:table;max-width:100%;box-sizing:border-box;padding:0;color:inherit;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}template{display:none}[hidden]{display:none}h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6{color:inherit;font-family:inherit;font-weight:500;line-height:1.1}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small,.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 .small,h2 .small,h3 .small,h4 .small,h5 .small,h6 .small,.h1 .small,.h2 .small,.h3 .small,.h4 .small,.h5 .small,.h6 .small{color:var(--gray-500, #adb5bd);font-weight:400;line-height:1}h1,.h1,h2,.h2,h3,.h3{margin-top:20px;margin-bottom:10px}h1 small,.h1 small,h2 small,.h2 small,h3 small,.h3 small,h1 .small,.h1 .small,h2 .small,.h2 .small,h3 .small,.h3 .small{font-size:65%}h4,.h4,h5,.h5,h6,.h6{margin-top:10px;margin-bottom:10px}h4 small,.h4 small,h5 small,.h5 small,h6 small,.h6 small,h4 .small,.h4 .small,h5 .small,.h5 .small,h6 .small,.h6 .small{font-size:75%}p{margin:0 0 10px}.so-button{display:inline-block;margin-bottom:0;border:1px solid transparent;background-image:none;cursor:pointer;font-weight:400;outline:none;text-align:center;touch-action:manipulation;vertical-align:middle;white-space:nowrap;padding:var(--button-padding-base-vertical, 6px) var(--button-padding-base-horizontal, 12px);border-radius:var(--button-border-radius, 3px);font-size:var(--button-font-size-base, var(--font-size-base, 14px));line-height:var(--common-line-height, 1.42857143);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.so-button-rtl{direction:rtl;text-align:right}.so-button-spin{display:inline-block}.so-button-spin-ltr{margin-right:var(--button-spin-margin, 8px)}.so-button-spin-rtl{margin-left:var(--button-spin-margin, 8px)}.so-button:hover,.so-button:focus{z-index:10;color:var(--primary-color-dark-15, #0073e5);outline:none;text-decoration:none}.so-button::-moz-focus-inner{border:0}.so-button.active{background-image:none;outline:0}.so-button+.so-button:not(.so-button+.so-button-rtl){margin-left:var(--button-margin-left, 12px)}.so-button+.so-button-rtl{margin-right:var(--button-margin-left, 12px)}.so-button[disabled],fieldset[disabled] .so-button{position:relative;box-shadow:none;cursor:not-allowed;opacity:1}.so-button.so-button-disabled{opacity:1}.so-button.so-button-disabled.so-button-link{opacity:.4}.so-button.so-button-disabled.so-button-text{opacity:.65}fieldset[disabled] a.so-button{pointer-events:none}.so-button-default{border-color:var(--button-default-border, #dee2e6);background-color:#fff;color:var(--button-default-text-color, #333);fill:var(--button-default-text-color, #333);transition:all .15s ease-in-out}@keyframes btn-focus-default{0%{box-shadow:0 0 0 0 var(--button-default-border-fade-60, rgba(222, 226, 230, .6))}50%{box-shadow:0 0 0 .4em var(--button-default-border-fade-0, rgba(222, 226, 230, 0))}to{box-shadow:0 0 0 .8em var(--button-default-border-fade-0, rgba(222, 226, 230, 0))}}.so-button-default:focus,.so-button-default:hover{border-color:var(--primary-color, #3399ff);background-color:#fff;color:var(--button-default-text-color, #333)}.so-button-default:active{border-color:var(--primary-color, #3399ff);animation:btn-focus-default .4s ease-out;background-color:#fff;color:var(--button-default-text-color, #333)}.so-button-default:active{background-image:none}.so-button-default[disabled]:hover,fieldset[disabled] .so-button-default:hover,.so-button-default[disabled]:focus,fieldset[disabled] .so-button-default:focus{border-color:var(--button-default-border, #dee2e6);background-color:#fff}.so-button-default[disabled]:active,fieldset[disabled] .so-button-default:active{animation:none}.so-button-default.so-button-outline:not(.so-button-disabled){border-color:#fff;background:transparent;color:#fff;fill:#fff}.so-button-default.so-button-outline:not(.so-button-disabled):focus,.so-button-default.so-button-outline:not(.so-button-disabled):hover{background-color:#fff;color:var(--button-default-text-color, #333)}.so-button-default.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-default .4s ease-out;background-color:#fff;color:var(--button-default-text-color, #333)}.so-button-default.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-default.so-button-outline:not(.so-button-disabled):hover,.so-button-default.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-default.so-button-outline:not(.so-button-disabled):focus{border-color:#fff;background:transparent;color:#fff}.so-button-default.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-default.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-default:not(.so-button-disabled):hover,.so-button-default:not(.so-button-disabled):focus,.so-button-default:not(.so-button-disabled):active{color:var(--primary-color, #3399ff)}.so-button-default:not(.so-button-disabled):hover .so-icon,.so-button-default:not(.so-button-disabled):focus .so-icon,.so-button-default:not(.so-button-disabled):active .so-icon{color:var(--primary-color, #3399ff);fill:var(--primary-color, #3399ff)}.so-button-default[disabled]:hover{color:var(--button-default-text-color, #333);fill:var(--primary-color, #3399ff)}.so-button-primary{border-color:transparent;background-color:var(--primary-color, #3399ff);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-primary{0%{box-shadow:0 0 0 0 var(--primary-color-dark-5_fade-60, rgba(25, 140, 255, .6))}50%{box-shadow:0 0 0 .4em var(--primary-color-dark-5_fade-0, rgba(25, 140, 255, 0))}to{box-shadow:0 0 0 .8em var(--primary-color-dark-5_fade-0, rgba(25, 140, 255, 0))}}.so-button-primary:focus,.so-button-primary:hover{border-color:var(--primary-color, #3399ff);background-color:var(--primary-color-dark-btn-hover, #007fff);color:#fff}.so-button-primary:active{border-color:var(--primary-color, #3399ff);animation:btn-focus-primary .4s ease-out;background-color:var(--primary-color-dark-btn-hover, #007fff);color:#fff}.so-button-primary:active{background-image:none}.so-button-primary[disabled]:hover,fieldset[disabled] .so-button-primary:hover,.so-button-primary[disabled]:focus,fieldset[disabled] .so-button-primary:focus{border-color:transparent;background-color:var(--primary-color, #3399ff)}.so-button-primary[disabled]:active,fieldset[disabled] .so-button-primary:active{animation:none}.so-button-primary.so-button-outline:not(.so-button-disabled){border-color:var(--primary-color, #3399ff);background:transparent;color:var(--primary-color, #3399ff);fill:var(--primary-color, #3399ff)}.so-button-primary.so-button-outline:not(.so-button-disabled):focus,.so-button-primary.so-button-outline:not(.so-button-disabled):hover{background-color:var(--primary-color, #3399ff);color:#fff}.so-button-primary.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-primary .4s ease-out;background-color:var(--primary-color, #3399ff);color:#fff}.so-button-primary.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-primary.so-button-outline:not(.so-button-disabled):hover,.so-button-primary.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-primary.so-button-outline:not(.so-button-disabled):focus{border-color:var(--primary-color, #3399ff);background:transparent;color:var(--primary-color, #3399ff)}.so-button-primary.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-primary.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-secondary{border-color:transparent;background-color:var(--secondary-color, #999999);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-secondary{0%{box-shadow:0 0 0 0 var(--secondary-color-dark-5_fade-60, rgba(140, 140, 140, .6))}50%{box-shadow:0 0 0 .4em var(--secondary-color-dark-5_fade-0, rgba(140, 140, 140, 0))}to{box-shadow:0 0 0 .8em var(--secondary-color-dark-5_fade-0, rgba(140, 140, 140, 0))}}.so-button-secondary:focus,.so-button-secondary:hover{border-color:var(--secondary-color, #999999);background-color:var(--secondary-color-dark-btn-hover, #808080);color:#fff}.so-button-secondary:active{border-color:var(--secondary-color, #999999);animation:btn-focus-secondary .4s ease-out;background-color:var(--secondary-color-dark-btn-hover, #808080);color:#fff}.so-button-secondary:active{background-image:none}.so-button-secondary[disabled]:hover,fieldset[disabled] .so-button-secondary:hover,.so-button-secondary[disabled]:focus,fieldset[disabled] .so-button-secondary:focus{border-color:transparent;background-color:var(--secondary-color, #999999)}.so-button-secondary[disabled]:active,fieldset[disabled] .so-button-secondary:active{animation:none}.so-button-secondary.so-button-outline:not(.so-button-disabled){border-color:var(--secondary-color, #999999);background:transparent;color:var(--secondary-color, #999999);fill:var(--secondary-color, #999999)}.so-button-secondary.so-button-outline:not(.so-button-disabled):focus,.so-button-secondary.so-button-outline:not(.so-button-disabled):hover{background-color:var(--secondary-color, #999999);color:#fff}.so-button-secondary.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-secondary .4s ease-out;background-color:var(--secondary-color, #999999);color:#fff}.so-button-secondary.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-secondary.so-button-outline:not(.so-button-disabled):hover,.so-button-secondary.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-secondary.so-button-outline:not(.so-button-disabled):focus{border-color:var(--secondary-color, #999999);background:transparent;color:var(--secondary-color, #999999)}.so-button-secondary.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-secondary.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-success{border-color:transparent;background-color:var(--success-color, #00cc66);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-success{0%{box-shadow:0 0 0 0 var(--success-color-dark-5_fade-60, rgba(0, 179, 89, .6))}50%{box-shadow:0 0 0 .4em var(--success-color-dark-5_fade-0, rgba(0, 179, 89, 0))}to{box-shadow:0 0 0 .8em var(--success-color-dark-5_fade-0, rgba(0, 179, 89, 0))}}.so-button-success:focus,.so-button-success:hover{border-color:var(--success-color, #00cc66);background-color:var(--success-color-dark-btn-hover, #00994d);color:#fff}.so-button-success:active{border-color:var(--success-color, #00cc66);animation:btn-focus-success .4s ease-out;background-color:var(--success-color-dark-btn-hover, #00994d);color:#fff}.so-button-success:active{background-image:none}.so-button-success[disabled]:hover,fieldset[disabled] .so-button-success:hover,.so-button-success[disabled]:focus,fieldset[disabled] .so-button-success:focus{border-color:transparent;background-color:var(--success-color, #00cc66)}.so-button-success[disabled]:active,fieldset[disabled] .so-button-success:active{animation:none}.so-button-success.so-button-outline:not(.so-button-disabled){border-color:var(--success-color, #00cc66);background:transparent;color:var(--success-color, #00cc66);fill:var(--success-color, #00cc66)}.so-button-success.so-button-outline:not(.so-button-disabled):focus,.so-button-success.so-button-outline:not(.so-button-disabled):hover{background-color:var(--success-color, #00cc66);color:#fff}.so-button-success.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-success .4s ease-out;background-color:var(--success-color, #00cc66);color:#fff}.so-button-success.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-success.so-button-outline:not(.so-button-disabled):hover,.so-button-success.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-success.so-button-outline:not(.so-button-disabled):focus{border-color:var(--success-color, #00cc66);background:transparent;color:var(--success-color, #00cc66)}.so-button-success.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-success.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-info{border-color:transparent;background-color:var(--info-color, #17a2b8);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-info{0%{box-shadow:0 0 0 0 var(--info-color-dark-5_fade-60, rgba(20, 142, 161, .6))}50%{box-shadow:0 0 0 .4em var(--info-color-dark-5_fade-0, rgba(20, 142, 161, 0))}to{box-shadow:0 0 0 .8em var(--info-color-dark-5_fade-0, rgba(20, 142, 161, 0))}}.so-button-info:focus,.so-button-info:hover{border-color:var(--info-color, #17a2b8);background-color:var(--info-color-dark-btn-hover, #117a8b);color:#fff}.so-button-info:active{border-color:var(--info-color, #17a2b8);animation:btn-focus-info .4s ease-out;background-color:var(--info-color-dark-btn-hover, #117a8b);color:#fff}.so-button-info:active{background-image:none}.so-button-info[disabled]:hover,fieldset[disabled] .so-button-info:hover,.so-button-info[disabled]:focus,fieldset[disabled] .so-button-info:focus{border-color:transparent;background-color:var(--info-color, #17a2b8)}.so-button-info[disabled]:active,fieldset[disabled] .so-button-info:active{animation:none}.so-button-info.so-button-outline:not(.so-button-disabled){border-color:var(--info-color, #17a2b8);background:transparent;color:var(--info-color, #17a2b8);fill:var(--info-color, #17a2b8)}.so-button-info.so-button-outline:not(.so-button-disabled):focus,.so-button-info.so-button-outline:not(.so-button-disabled):hover{background-color:var(--info-color, #17a2b8);color:#fff}.so-button-info.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-info .4s ease-out;background-color:var(--info-color, #17a2b8);color:#fff}.so-button-info.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-info.so-button-outline:not(.so-button-disabled):hover,.so-button-info.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-info.so-button-outline:not(.so-button-disabled):focus{border-color:var(--info-color, #17a2b8);background:transparent;color:var(--info-color, #17a2b8)}.so-button-info.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-info.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-warning{border-color:transparent;background-color:var(--warning-color, #ff9900);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-warning{0%{box-shadow:0 0 0 0 var(--warning-color-dark-5_fade-60, rgba(230, 138, 0, .6))}50%{box-shadow:0 0 0 .4em var(--warning-color-dark-5_fade-0, rgba(230, 138, 0, 0))}to{box-shadow:0 0 0 .8em var(--warning-color-dark-5_fade-0, rgba(230, 138, 0, 0))}}.so-button-warning:focus,.so-button-warning:hover{border-color:var(--warning-color, #ff9900);background-color:var(--warning-color-dark-btn-hover, #cc7a00);color:#fff}.so-button-warning:active{border-color:var(--warning-color, #ff9900);animation:btn-focus-warning .4s ease-out;background-color:var(--warning-color-dark-btn-hover, #cc7a00);color:#fff}.so-button-warning:active{background-image:none}.so-button-warning[disabled]:hover,fieldset[disabled] .so-button-warning:hover,.so-button-warning[disabled]:focus,fieldset[disabled] .so-button-warning:focus{border-color:transparent;background-color:var(--warning-color, #ff9900)}.so-button-warning[disabled]:active,fieldset[disabled] .so-button-warning:active{animation:none}.so-button-warning.so-button-outline:not(.so-button-disabled){border-color:var(--warning-color, #ff9900);background:transparent;color:var(--warning-color, #ff9900);fill:var(--warning-color, #ff9900)}.so-button-warning.so-button-outline:not(.so-button-disabled):focus,.so-button-warning.so-button-outline:not(.so-button-disabled):hover{background-color:var(--warning-color, #ff9900);color:#fff}.so-button-warning.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-warning .4s ease-out;background-color:var(--warning-color, #ff9900);color:#fff}.so-button-warning.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-warning.so-button-outline:not(.so-button-disabled):hover,.so-button-warning.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-warning.so-button-outline:not(.so-button-disabled):focus{border-color:var(--warning-color, #ff9900);background:transparent;color:var(--warning-color, #ff9900)}.so-button-warning.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-warning.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-error,.so-button-danger{border-color:transparent;background-color:var(--danger-color, #f85555);color:#fff;fill:#fff;transition:all .15s ease-in-out}@keyframes btn-focus-danger{0%{box-shadow:0 0 0 0 var(--danger-color-dark-5_fade-60, rgba(247, 61, 61, .6))}50%{box-shadow:0 0 0 .4em var(--danger-color-dark-5_fade-0, rgba(247, 61, 61, 0))}to{box-shadow:0 0 0 .8em var(--danger-color-dark-5_fade-0, rgba(247, 61, 61, 0))}}.so-button-error:focus,.so-button-danger:focus,.so-button-error:hover,.so-button-danger:hover{border-color:var(--danger-color, #f85555);background-color:var(--danger-color-dark-btn-hover, #f62424);color:#fff}.so-button-error:active,.so-button-danger:active{border-color:var(--danger-color, #f85555);animation:btn-focus-danger .4s ease-out;background-color:var(--danger-color-dark-btn-hover, #f62424);color:#fff}.so-button-error:active,.so-button-danger:active{background-image:none}.so-button-error[disabled]:hover,.so-button-danger[disabled]:hover,fieldset[disabled] .so-button-error:hover,fieldset[disabled] .so-button-danger:hover,.so-button-error[disabled]:focus,.so-button-danger[disabled]:focus,fieldset[disabled] .so-button-error:focus,fieldset[disabled] .so-button-danger:focus{border-color:transparent;background-color:var(--danger-color, #f85555)}.so-button-error[disabled]:active,.so-button-danger[disabled]:active,fieldset[disabled] .so-button-error:active,fieldset[disabled] .so-button-danger:active{animation:none}.so-button-error.so-button-outline:not(.so-button-disabled),.so-button-danger.so-button-outline:not(.so-button-disabled){border-color:var(--danger-color, #f85555);background:transparent;color:var(--danger-color, #f85555);fill:var(--danger-color, #f85555)}.so-button-error.so-button-outline:not(.so-button-disabled):focus,.so-button-danger.so-button-outline:not(.so-button-disabled):focus,.so-button-error.so-button-outline:not(.so-button-disabled):hover,.so-button-danger.so-button-outline:not(.so-button-disabled):hover{background-color:var(--danger-color, #f85555);color:#fff}.so-button-error.so-button-outline:not(.so-button-disabled):active,.so-button-danger.so-button-outline:not(.so-button-disabled):active{animation:btn-focus-danger .4s ease-out;background-color:var(--danger-color, #f85555);color:#fff}.so-button-error.so-button-outline:not(.so-button-disabled)[disabled]:hover,.so-button-danger.so-button-outline:not(.so-button-disabled)[disabled]:hover,fieldset[disabled] .so-button-error.so-button-outline:not(.so-button-disabled):hover,fieldset[disabled] .so-button-danger.so-button-outline:not(.so-button-disabled):hover,.so-button-error.so-button-outline:not(.so-button-disabled)[disabled]:focus,.so-button-danger.so-button-outline:not(.so-button-disabled)[disabled]:focus,fieldset[disabled] .so-button-error.so-button-outline:not(.so-button-disabled):focus,fieldset[disabled] .so-button-danger.so-button-outline:not(.so-button-disabled):focus{border-color:var(--danger-color, #f85555);background:transparent;color:var(--danger-color, #f85555)}.so-button-error.so-button-outline:not(.so-button-disabled)[disabled]:active,.so-button-danger.so-button-outline:not(.so-button-disabled)[disabled]:active,fieldset[disabled] .so-button-error.so-button-outline:not(.so-button-disabled):active,fieldset[disabled] .so-button-danger.so-button-outline:not(.so-button-disabled):active{animation:none}.so-button-text{background:transparent;border:none;box-shadow:none;padding-left:4px;padding-right:4px;display:inline-flex;align-items:center}.so-button-text:not(:disabled):hover{opacity:.8}.so-button-text,.so-button-text:hover,.so-button-text:focus,.so-button-text:active{background:transparent;border:none;box-shadow:none;animation:none}.so-button-text:disabled:hover{background:transparent}.so-button-text.so-button-primary{color:var(--primary-color, #3399ff)}.so-button-text.so-button-success{color:var(--success-color, #00cc66)}.so-button-text.so-button-info{color:var(--info-color, #17a2b8)}.so-button-text.so-button-danger{color:var(--danger-color, #f85555)}.so-button-text.so-button-warning{color:var(--warning-color, #ff9900)}.so-button-text.so-button-secondary{color:var(--secondary-color, #999999)}.so-button-link{border-radius:0;color:var(--primary-color, #3399ff);font-weight:400}.so-button-link,.so-button-link:active,.so-button-link[disabled],fieldset[disabled] .so-button-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.so-button-link,.so-button-link:hover,.so-button-link:focus,.so-button-link:active{border-color:transparent}.so-button-link:hover,.so-button-link:focus{background-color:transparent;color:var(--primary-color-dark-15, #0073e5);text-decoration:none}.so-button-link[disabled]:hover,fieldset[disabled] .so-button-link:hover,.so-button-link[disabled]:focus,fieldset[disabled] .so-button-link:focus{color:var(--primary-color, #3399ff);text-decoration:none}.so-button-large{padding:var(--button-padding-large-vertical, 8px) var(--button-padding-large-horizontal, 16px);border-radius:var(--button-large-border-radius, 4px);font-size:var(--button-font-size-large, var(--font-size-large, 18px));line-height:var(--common-line-height, 1.42857143)}.so-button-small{padding:var(--button-padding-small-vertical, 5px) var(--button-padding-small-horizontal, 10px);border-radius:var(--button-small-border-radius, 3px);font-size:var(--button-font-size-small, var(--font-size-small, 12px));line-height:1.5}.so-button-disabled:not(.so-button-link):not(.so-button-text),.so-button-disabled:not(.so-button-link):not(.so-button-text):hover{background:var(--button-disabled-bg, #f5f5f5);color:var(--button-disabled-color, rgba(0, 0, 0, .45));fill:var(--button-disabled-color, rgba(0, 0, 0, .45));border-color:var(--button-disabled-border-color, #d9d9d9)}.so-button-circle{border-radius:50%;min-width:34px;padding-left:0;padding-right:0}.so-button-circle.so-button-large{min-width:43px}.so-button-circle.so-button-small{min-width:30px}.so-button-round{border-radius:1000px}.so-button-group .so-button{position:relative;border-right-width:0;border-left-width:0}.so-button-group .so-button:not(.so-button-group .so-button-rtl){margin-left:0}.so-button-group .so-button-rtl{margin-right:0}.so-button-group .so-button:before{position:absolute;top:50%;left:0;height:50%;border-left-width:1px;border-left-style:solid;border-left-color:#fff6;content:" ";transform:translateY(-50%)}.so-button-group-rtl.so-button-group .so-button:before{left:auto;right:0}.so-button-group .so-button:first-child:not(.so-button-rtl){margin-left:0;border-left-width:1px}.so-button-group .so-button:first-child.so-button-rtl{border-right-width:1px;margin-right:0}.so-button-group .so-button:first-child:before{display:none}.so-button-group .so-button:last-child:not(.so-button-rtl){border-right-width:1px}.so-button-group .so-button:last-child.so-button-rtl{border-left-width:1px}.so-button-group .so-button:not(:first-child):not(:last-child){border-radius:0}.so-button-group .so-button:first-child:not(:last-child):not(.so-button-rtl){border-bottom-right-radius:0;border-top-right-radius:0}.so-button-group .so-button:first-child:not(:last-child).so-button-rtl{border-bottom-left-radius:0;border-top-left-radius:0}.so-button-group .so-button:last-child:not(:first-child):not(.so-button-rtl){border-bottom-left-radius:0;border-top-left-radius:0}.so-button-group .so-button:last-child:not(:first-child).so-button-rtl{border-bottom-right-radius:0;border-top-right-radius:0}.so-button-group .so-button:before{border-left-color:#d9d9d9;transition:all .2s}.so-button-group .so-button:not(.so-button-outline):not(.so-button-default):not(.so-button-disabled):before{border-left-color:#fff}.so-button-group .so-button.so-button-outline:not(.so-button-default):before{border-left-color:inherit}.so-button-group .so-button.so-button-disabled:before{border-left-color:#fff}.so-button-group .so-button.so-button-disabled.so-button-default:before,.so-button-group .so-button.so-button-disabled.so-button-outline:before{border-left-color:var(--button-disabled-delimiter, #d9d9d9)}.so-button-group .so-button.so-button-disabled+.so-button:not(.so-button-disabled):before{border-left-color:transparent}.so-button-group .so-button.so-button-disabled+.so-button:not(.so-button-disabled).so-button-outline:not(.so-button-default):before{height:100%;border-left-color:var(--primary-color, #3399ff)}.so-button-group .so-button:not(.so-button-disabled)+.so-button-disabled:before{border-left-color:transparent}.so-button-group .so-button:not(.so-button-disabled)+.so-button-disabled.so-button-outline:not(.so-button-default):before{height:100%;border-left-color:var(--primary-color, #3399ff)}.so-button-group .so-button.so-button-default:not(.so-button-disabled):hover:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):active:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):focus:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):hover+.so-button:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):active+.so-button:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):focus+.so-button:before{border-left-color:var(--primary-color, #3399ff);height:100%}.so-button-group .so-button.so-button-default:not(.so-button-disabled):hover+.so-dropdown-split-dropdown>.so-dropdown-button.so-dropdown-split-button:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):active+.so-dropdown-split-dropdown>.so-dropdown-button.so-dropdown-split-button:before,.so-button-group .so-button.so-button-default:not(.so-button-disabled):focus+.so-dropdown-split-dropdown>.so-dropdown-button.so-dropdown-split-button:before{border-left-color:var(--primary-color, #3399ff);height:100%}.so-button-group .so-button.so-button-outline:not(.so-button-disabled):hover:before,.so-button-group .so-button.so-button-outline:not(.so-button-disabled):active:before,.so-button-group .so-button.so-button-outline:not(.so-button-disabled):focus:before{border-left-color:inherit}.so-button-group .so-button.so-button-outline:not(.so-button-disabled):hover+.so-button:not(.so-button-disabled):before,.so-button-group .so-button.so-button-outline:not(.so-button-disabled):active+.so-button:not(.so-button-disabled):before,.so-button-group .so-button.so-button-outline:not(.so-button-disabled):focus+.so-button:not(.so-button-disabled):before{height:0;transition:none}.so-button-from-input-group .so-button:before{border-left:none}.so-button .so-dropdown{border-top-width:1px;border-bottom-width:1px}.so-form{position:relative}.so-form-item{display:flex;align-items:flex-start;margin-bottom:var(--form-item-margin-bottom, 20px)}.so-form-item.so-form-item-keep-height{margin-bottom:var(--form-Item-min-keep-height, 24px)}.so-form-item.so-form-item-keep-height .so-form-error{margin:0;height:auto;min-height:var(--form-Item-min-keep-height, 24px);line-height:1.5715}.so-form-item.so-form-item-keep-height.so-form-invalid{margin-bottom:0}.so-form-item.so-form-label-vertical-align-middle{align-items:center}.so-form-item.so-form-label-vertical-align-middle .so-form-label{margin-top:0;line-height:1;padding:0}.so-form-item.so-form-label-vertical-align-bottom{align-items:flex-end}.so-form-item .so-form-label{display:inline-block;width:140px;padding:6px;word-break:break-word}.so-form-item.so-form-required .so-form-label:before{margin-right:4px;color:var(--danger-color, #f85555);content:"*";font-family:SimSun}.so-form-item:not(.so-form-label-align-top) .so-form-label{text-align:left;text-align:var(--form-item-label-align, start)}.so-form-item .so-form-control{flex:1;padding:0 6px;min-width:0}.so-form-item .so-form-control:first-child{padding-left:0}.so-form .so-form-tip,.so-form .so-form-error{margin-top:var(--form-item-error-margin-top, 5px);margin-bottom:var(--form-item-error-margin-bottom, 8px);line-height:var(--form-item-error-line-height, var(--common-line-height, 1.42857143));color:var(--form-tip-color, #7e8b98);font-size:var(--form-tip-font-size, 13px)}.so-form .so-form-error{color:var(--danger-color, #f85555)}.so-form .so-form-error+.so-form-tip{display:none}.so-form-item.so-form-label-align-right .so-form-label{text-align:right;text-align:end}.so-form-item.so-form-label-align-left .so-form-label{text-align:left;text-align:start}.so-form-label-align-top{display:block;width:100%}.so-form-label-align-top .so-form-label{width:100%;padding:0;margin-bottom:6px}.so-form-label-align-top .so-form-control{padding:0}.so-form-inline .so-input{display:inline-flex;width:auto;vertical-align:top}.so-form-inline>.so-input{margin-right:var(--form-item-margin-right, 20px)}.so-form-inline .so-input-group{display:inline-flex}.so-form-inline .so-form-item{display:inline-flex;margin-right:var(--form-item-margin-right, 20px);vertical-align:top}.so-form-inline .so-form-item.so-form-label-vertical-align-middle .so-form-label{margin-top:0}.so-form-inline .so-form-item .so-form-label{width:auto;padding:0;margin-top:8px;margin-right:12px}.so-form-inline .so-form-item .so-input{margin-right:0}.so-form-inline .so-form-item .so-form-control{display:inline-block;padding:0}.so-form-inline>*{margin-bottom:12px}.so-form-disabled .so-input,.so-form-disabled .so-input:hover,.so-form-disabled .so-input input{border-color:var(--input-border-color, #ced4da);background-color:var(--input-bg-disabled, #e9ecef);cursor:not-allowed;color:var(--input-disabled-color, #999DA8)}.so-form-disabled .so-input .so-input-disabled:hover,.so-form-disabled .so-input input{background:rgba(255,255,255,0)}.so-form.so-form-rtl{direction:rtl}.so-form.so-form-rtl .so-form-item.so-form-required .so-form-label:before{margin-right:0;margin-left:4px}.so-form.so-form-rtl .so-form-item .so-form-control:first-child{padding-left:6px;padding-right:0}.so-form.so-form-rtl.so-form-inline>.so-input{margin-right:0;margin-left:var(--form-item-margin-right, 20px)}.so-form.so-form-rtl.so-form-inline .so-form-item{margin-right:0;margin-left:var(--form-item-margin-right, 20px)}.so-form.so-form-rtl.so-form-inline .so-form-item .so-form-label,.so-form.so-form-rtl .so-upload .so-upload-image-item{margin-right:0;margin-left:12px}.so-input{position:relative;display:flex;width:100%;border:1px solid var(--input-border-color, #ced4da);background-color:#fff;background-image:none;border-radius:var(--input-border-radius, 4px);color:var(--input-text-color, #333E59);font-size:var(--font-size-base, 14px);line-height:var(--common-line-height, 1.42857143);transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.so-input:focus{outline:none;border-color:var(--input-border-focus-color, #80bdff);box-shadow:0 0 0 var(--input-focus-width, 3px) var(--input-border-focus-color-fade-25, rgba(128, 189, 255, .25))}.so-input-clearable:hover+.so-input-clear-wrapper,.so-input-clearable:focus+.so-input-clear-wrapper{display:block}.so-input-clear-wrapper:hover{display:block}.so-input-clear-wrapper{flex-basis:16px;display:none}.so-input-clear-wrapper .so-input-clear{position:absolute;top:50%;right:8px;width:12px;height:12px;transform:translateY(-50%);cursor:pointer;background:var(--input-clear-bg-color, #ced4da);border-radius:6px}.so-input-clear-wrapper .so-input-clear:hover{background:var(--input-clear-bg-hover-color, #3399ff)}.so-input-clear-wrapper .so-input-clear:after,.so-input-clear-wrapper .so-input-clear:before{position:absolute;top:5px;left:3px;display:block;width:6px;height:1px;background:#fff;content:" "}.so-input-clear-wrapper .so-input-clear:after{transform:rotate(45deg)}.so-input-clear-wrapper .so-input-clear:before{transform:rotate(315deg)}.so-input-rtl .so-input-clear-wrapper .so-input-clear{right:auto;left:8px}.so-input-rtl .so-input-clear-wrapper .so-input-clear:after,.so-input-rtl .so-input-clear-wrapper .so-input-clear:before{left:auto;right:3px}.so-input-inline{display:inline-block;display:inline-flex}.so-input:hover{border-color:var(--input-border-focus-color, #80bdff)}.so-input-group{display:flex;flex-wrap:wrap;align-items:stretch;padding:0}.so-input-group .so-input+.so-input{border-left-width:1px}.so-input-group button{border-width:0;min-width:0}.so-input-group>span,.so-input-group>i{display:block;margin:auto 0;background:transparent}.so-input-group>span:first-child,.so-input-group>i:first-child{padding-left:12px}.so-input-rtl.so-input-group>span:first-child,.so-input-rtl.so-input-group>i:first-child{padding-right:12px;padding-left:0}.so-input-group>span:last-child,.so-input-group>i:last-child{padding-right:8px}.so-input-rtl.so-input-group>span:last-child,.so-input-rtl.so-input-group>i:last-child{padding-left:8px;padding-right:0}.so-input-group>b{display:flex;align-items:center;padding:0 8px;margin:0 0 0 -1px;border:1px solid var(--input-border-color, #ced4da);border-width:0 1px;background:var(--gray-200, #e9ecef);font-weight:400}.so-input-group>b:first-child{margin-left:0;border-left-width:0;border-bottom-left-radius:var(--input-border-radius, 4px);border-top-left-radius:var(--input-border-radius, 4px)}.so-input-group>b:last-child{border-right-width:0;border-bottom-right-radius:var(--input-border-radius, 4px);border-top-right-radius:var(--input-border-radius, 4px)}.so-input-group .so-input-invalid.so-input-focus{box-shadow:none}.so-input-group .so-icon{color:var(--gray-400, #ced4da);fill:var(--gray-400, #ced4da)}.so-input-number-up,.so-input-number-down{position:absolute;right:0;width:18px;padding:0 4px;border-left:solid 1px var(--gray-200, #e9ecef);line-height:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.so-input-number-up svg path,.so-input-number-down svg path{fill:var(--gray-500, #adb5bd)}.so-input-number-up:hover svg path,.so-input-number-down:hover svg path{fill:var(--primary-color, #3399ff)}.so-input-number-up{top:0;bottom:50%;border-bottom:solid 1px var(--gray-200, #e9ecef)}.so-input-number-up svg{transform:rotate(-90deg)}.so-input-number-down{top:50%;bottom:0}.so-input-number-down svg{transform:rotate(90deg)}.so-input-group.so-input-small,.so-input-group.so-input-large{padding:0}.so-input .so-input{width:auto;flex:1;border-width:0;border-color:var(--input-border-color, #ced4da);background:transparent;border-radius:0;box-shadow:none}.so-input .so-input-disabled{border-color:var(--input-border-color, #ced4da);background-color:var(--input-bg-disabled, #e9ecef);cursor:not-allowed;background:transparent;color:var(--input-disabled-color, #999DA8)}@keyframes so-input-fade-center{0%{transform:scale(.6) translate(-50%)}to{transform:scale(1) translate(-50%)}}@keyframes so-input-fade{0%{transform:scale(.6)}to{transform:scale(1)}}.so-input-tip,.so-input-error{position:absolute;z-index:1000;min-width:200px;max-width:400px;padding:6px 12px;background:var(--gray-100, #f8f9fa);border-radius:var(--input-border-radius, 4px);box-shadow:0 0 0 1px var(--input-border-color, #ced4da),0 2px 8px #00000026;color:var(--gray-900-lighten-40, #7e8b98);font-size:12px}.so-input-tip:before,.so-input-error:before{position:absolute;width:6px;height:6px;border:solid 1px var(--input-border-color, #ced4da);border-width:1px 0 0 1px;background:inherit;content:" "}.so-input-tip.so-input-bottom-left,.so-input-error.so-input-bottom-left,.so-input-tip.so-input-bottom,.so-input-error.so-input-bottom,.so-input-tip.so-input-bottom-right,.so-input-error.so-input-bottom-right{top:100%;margin-top:10px;transform-origin:0 0}.so-input-tip.so-input-bottom-left:before,.so-input-error.so-input-bottom-left:before,.so-input-tip.so-input-bottom:before,.so-input-error.so-input-bottom:before,.so-input-tip.so-input-bottom-right:before,.so-input-error.so-input-bottom-right:before{bottom:100%;transform:rotate(45deg) translateY(3px)}.so-input-tip.so-input-top-left,.so-input-error.so-input-top-left,.so-input-tip.so-input-top,.so-input-error.so-input-top,.so-input-tip.so-input-top-right,.so-input-error.so-input-top-right{bottom:100%;margin-bottom:10px;transform-origin:0 100%}.so-input-tip.so-input-top-left:before,.so-input-error.so-input-top-left:before,.so-input-tip.so-input-top:before,.so-input-error.so-input-top:before,.so-input-tip.so-input-top-right:before,.so-input-error.so-input-top-right:before{top:100%;transform:rotate(225deg) translate(3px)}.so-input-tip.so-input-bottom,.so-input-error.so-input-bottom,.so-input-tip.so-input-top,.so-input-error.so-input-top{left:50%;animation:so-input-fade-center .16s ease-in;transform:translate(-50%)}.so-input-tip.so-input-bottom:before,.so-input-error.so-input-bottom:before,.so-input-tip.so-input-top:before,.so-input-error.so-input-top:before{left:50%}.so-input-tip.so-input-bottom-left,.so-input-error.so-input-bottom-left,.so-input-tip.so-input-top-left,.so-input-error.so-input-top-left{left:0;animation:so-input-fade .16s ease-in}.so-input-tip.so-input-bottom-right,.so-input-error.so-input-bottom-right,.so-input-tip.so-input-top-right,.so-input-error.so-input-top-right{right:0;animation:so-input-fade .16s ease-in}.so-input-tip.so-input-bottom-right:before,.so-input-error.so-input-bottom-right:before,.so-input-tip.so-input-top-right:before,.so-input-error.so-input-top-right:before{right:9px}.so-input-tip.so-input-bottom-right,.so-input-error.so-input-bottom-right{transform-origin:100% 0}.so-input-tip.so-input-top-right,.so-input-error.so-input-top-right{transform-origin:100% 100%}.so-input-tip{visibility:hidden}.so-input-error{box-shadow:0 0 0 1px #ebccd1,0 2px 8px #00000026;color:var(--danger-color, #f85555)}.so-input-error:before{border-color:#ebccd1}.so-input-focus{border-color:var(--input-border-focus-color, #80bdff);box-shadow:0 0 0 var(--input-focus-width, 3px) var(--input-border-focus-color-fade-25, rgba(128, 189, 255, .25))}.so-input-focus .so-input-tip{visibility:visible}.so-input-invalid,.so-input-invalid:hover{border-color:var(--danger-color, #f85555)}.so-input-invalid.so-input-focus{border-color:var(--danger-color, #f85555);box-shadow:0 0 0 var(--input-focus-width, 3px) var(--danger-color-fade-25, rgba(248, 85, 85, .25))}.so-input-no-border{border-width:0}.so-input-no-border.so-input-focus{box-shadow:none}.so-input-overflow-auto{overflow:auto}.so-input-overflow-hidden{overflow:hidden}.so-input input,.so-input textarea,.so-input-spare{display:block;width:100%;padding:6px 12px;border:0;background:transparent;line-height:inherit;outline:none;color:var(--input-text-color, #333E59)}.so-input-disabled,.so-input-disabled:hover,.so-input-disabled input{border-color:var(--input-border-color, #ced4da);background-color:var(--input-bg-disabled, #e9ecef);cursor:not-allowed;color:var(--input-disabled-color, #999DA8)}.so-input-disabled input{background:rgba(255,255,255,0)}.so-input-disabled .so-input-disabled:hover{background:transparent}.so-input-disabled .so-select-result{color:var(--input-disabled-color, #999DA8)}.so-input ::placeholder,.so-input-placeholder{color:var(--input-placeholder-color, #999);font-size:var(--input-placeholder-size, 14px)}.so-input textarea{position:relative;z-index:2;line-height:var(--common-line-height, 1.42857143);resize:none}.so-input input.so-input-number-ltr{padding-right:22px}.so-input input.so-input-number-ltr+.so-input-clear-wrapper .so-input-clear{right:22px}.so-input input.so-input-number-rtl{padding-left:22px}.so-input input.so-input-number-rtl+.so-input-clear-wrapper .so-input-clear{left:22px;right:auto}.so-input:not(.so-input-rtl) .so-input-number-title-box .so-input-title-box-title{padding-right:22px}.so-input-rtl .so-input-number-title-box .so-input-title-box-title{padding-left:22px}.so-input:not(.so-input-rtl) .so-input-number-title-box+.so-input-clear-wrapper .so-input-clear{right:22px}.so-input-rtl .so-input-number-title-box+.so-input-clear-wrapper .so-input-clear{left:22px;right:auto}textarea.so-input-shadow{position:absolute;z-index:0;top:0;left:0;visibility:hidden}textarea.so-input-auto-size{overflow:hidden}textarea.so-input-textarea-resize{resize:vertical}.so-input-with-footer{flex-direction:column}.so-input-with-footer .so-input-footer{padding:12px 6px;border-top:1px solid var(--input-border-color, #ced4da)}.so-input-small{font-size:var(--font-size-small, 12px);line-height:1.5}.so-input-small input,.so-input-small .so-input-spare{padding:5px 10px}.so-input-small ::placeholder,.so-input-small .so-input-placeholder{font-size:var(--font-size-small, 12px)}.so-input-large{font-size:var(--font-size-large, 18px)}.so-input-large input,.so-input-large .so-input-spare{padding:8px 12px}.so-input-large ::placeholder,.so-input-large .so-input-placeholder{font-size:var(--font-size-large, 18px)}.so-input.so-input-rtl{direction:rtl}.so-input.so-input-rtl-clear-wrapper{right:auto;left:8px}.so-input.so-input-rtl-clear-wrapper:after,.so-input.so-input-rtl-clear-wrapper:before{left:auto;right:3px}.so-input.so-input-rtl .so-input-number-up,.so-input.so-input-rtl .so-input-number-down{left:0;right:auto;border-left:none;border-right:1px solid var(--gray-200, #e9ecef)}.so-input.so-input-rtl input.so-input-number{padding-right:8px;padding-left:22px}.so-input.so-input-underline{border-left-width:0;border-right-width:0;border-top-color:transparent;border-bottom-width:var(--input-underline-height, 1px);border-radius:0}.so-input-group.so-input-rtl .so-input+.so-input.so-input-rtl{border-left-width:0;border-right-width:1px}.so-inputBorder-rtl{direction:rtl}.so-alert{position:relative;display:flex;padding:var(--alert-padding-y, 15px) var(--alert-padding-x, 16px);margin-bottom:20px;border:var(--alert-border-width, 1px) solid transparent;border-radius:var(--alert-border-radius, 4px);transform-origin:0 0;transition:transform .216s,opacity .216s ease-out;font-size:var(--alert-font-size, var(--font-size-base, 14px))}.so-alert-rtl{direction:rtl;text-align:right}.so-alert h2,.so-alert h3,.so-alert h4{margin-top:.3em;color:inherit}.so-alert-with-close:not(.so-alert-rtl){padding-right:calc(var(--alert-padding-x, 16px) + 20px)}.so-alert-rtl.so-alert-with-close{padding-left:calc(var(--alert-padding-x, 16px) + 20px)}.so-alert-link{font-weight:700}.so-alert-close{position:absolute;top:var(--alert-padding-y, 15px);right:12px;display:block}.so-alert-rtl .so-alert-close{right:auto;left:12px}.so-alert-close svg{width:10px;height:10px}.so-alert-close svg path{fill:var(--alert-close-color, rgba(0, 0, 0, .3))}.so-alert-close:hover svg path{fill:var(--alert-close-hover-color, rgba(0, 0, 0, .8))}.so-alert-dismissed{opacity:0;transform:scaleY(0)}.so-alert-icon{display:block;margin-top:var(--alert-icon-margin-top, 2px)}.so-alert-content{flex:1;word-break:break-all}.so-alert>p,.so-alert>ul{margin-bottom:0}.so-alert>p+p{margin-top:5px}.so-alert h2,.so-alert h3,.so-alert h4{margin-top:0}.so-alert-default{border-color:var(--gray-200, #e9ecef);background-color:#fff;color:#333;box-shadow:var(--alert-box-shadow, "none")}.so-alert-default hr{border-top-color:var(--gray-200-darken-5, #dadfe4)}.so-alert-default .alert-link{color:#1a1a1a}.so-alert-info{border-color:var(--alert-info-border-color, #bce8f1);background-color:var(--alert-info-bg, #d9edf7);color:var(--alert-info-text-color, #31708f);box-shadow:var(--alert-info-box-shadow, "none")}.so-alert-info hr{border-top-color:var(--alert-info-border-darken-5-color, #a6e1ec)}.so-alert-info .alert-link{color:var(--alert-info-text-darken-10-color, #245269)}.so-alert-info .so-alert-icon path{fill:var(--info-color, #17a2b8)}.so-alert-warning{border-color:var(--alert-warning-border-color, #faebcc);background-color:var(--alert-warning-bg, #fcf8e3);color:var(--alert-warning-text-color, #8a6d3b);box-shadow:var(--alert-warning-box-shadow, "none")}.so-alert-warning hr{border-top-color:var(--alert-warning-border-darken-5-color, #f7e1b5)}.so-alert-warning .alert-link{color:var(--alert-warning-text-darken-10-color, #66512c)}.so-alert-warning .so-alert-icon path{fill:var(--warning-color, #ff9900)}.so-alert-success{border-color:var(--alert-success-border-color, #d6e9c6);background-color:var(--alert-success-bg, #dff0d8);color:var(--alert-success-text-color, #3c763d);box-shadow:var(--alert-success-box-shadow, "none")}.so-alert-success hr{border-top-color:var(--alert-success-border-darken-5-color, #c9e2b3)}.so-alert-success .alert-link{color:var(--alert-success-text-darken-10-color, #2b542c)}.so-alert-success .so-alert-icon path{fill:var(--success-color, #00cc66)}.so-alert-danger,.so-alert-error,.so-alert-confirmwarning{border-color:var(--alert-danger-border-color, #ebccd1);background-color:var(--alert-danger-bg, #f2dede);color:var(--alert-danger-text-color, #a94442);box-shadow:var(--alert-danger-box-shadow, "none")}.so-alert-danger hr,.so-alert-error hr,.so-alert-confirmwarning hr{border-top-color:var(--alert-danger-border-darken-5-color, #e4b9c0)}.so-alert-danger .alert-link,.so-alert-error .alert-link,.so-alert-confirmwarning .alert-link{color:var(--alert-danger-text-darken-10-color, #843534)}.so-alert-danger .so-alert-icon path,.so-alert-error .so-alert-icon path,.so-alert-confirmwarning .so-alert-icon path{fill:var(--danger-color, #f85555)}.so-popover{position:absolute;z-index:1060;display:block;border:var(--popover-border-width, 1px) solid var(--popover-border-color, #dee2e6);background-clip:padding-box;background-color:#fff;border-radius:var(--popover-border-radius, 4px);box-shadow:var(--popover-box-shadow, 0 5px 10px rgba(0, 0, 0, .2));font-size:var(--popover-text-font-size, var(--font-size-small, 12px));word-wrap:break-word}@keyframes so-popover-kf-opacity{0%{opacity:0}to{opacity:1}}.so-popover:after{background:transparent;position:absolute;content:""}.so-popover-arrow{position:absolute;z-index:1;display:inline-block;padding:4.2px;border:var(--popover-border-width, 1px) solid var(--popover-border-color, #dee2e6);background-color:#fff;border-left:none;border-bottom:none}.so-popover-top,.so-popover-top-left,.so-popover-top-right{margin-top:-10px;transform:translate(-50%,-100%)}.so-popover-top:after,.so-popover-top-left:after,.so-popover-top-right:after{left:0;right:0;bottom:-12px;height:12px}.so-popover-top .so-popover-arrow,.so-popover-top-left .so-popover-arrow,.so-popover-top-right .so-popover-arrow{bottom:0;left:50%;transform:translate(-50%,50%) rotate(135deg)}.so-popover-top-left{transform:translateY(-100%)}.so-popover-top-left .so-popover-arrow{left:12px}.so-popover-top-right{transform:translate(-100%,-100%)}.so-popover-top-right .so-popover-arrow{right:6px;left:auto}.so-popover-left-top,.so-popover-left-bottom,.so-popover-left{margin-left:-10px;transform:translate(-100%,-50%)}.so-popover-left-top:after,.so-popover-left-bottom:after,.so-popover-left:after{top:0;bottom:0;right:-12px;width:12px}.so-popover-left-top .so-popover-arrow,.so-popover-left-bottom .so-popover-arrow,.so-popover-left .so-popover-arrow{top:50%;right:0;transform:translate(50%,-50%) rotate(45deg)}.so-popover-left-top{transform:translate(-100%)}.so-popover-left-top .so-popover-arrow{top:12px}.so-popover-left-bottom{transform:translate(-100%,-100%)}.so-popover-left-bottom .so-popover-arrow{top:auto;bottom:6px}.so-popover-right-top,.so-popover-right-bottom,.so-popover-right{margin-left:10px;transform:translateY(-50%)}.so-popover-right-top:after,.so-popover-right-bottom:after,.so-popover-right:after{top:0;bottom:0;left:-12px;width:12px}.so-popover-right-top .so-popover-arrow,.so-popover-right-bottom .so-popover-arrow,.so-popover-right .so-popover-arrow{top:50%;left:0;transform:translate(-50%,-50%) rotate(225deg)}.so-popover-right-top{transform:translateY(0)}.so-popover-right-top .so-popover-arrow{top:12px}.so-popover-right-bottom{transform:translateY(-100%)}.so-popover-right-bottom .so-popover-arrow{top:auto;bottom:6px}.so-popover-bottom-left,.so-popover-bottom,.so-popover-bottom-right,.so-popover-cover{margin-top:10px;transform:translate(-50%)}.so-popover-bottom-left:after,.so-popover-bottom:after,.so-popover-bottom-right:after,.so-popover-cover:after{left:0;right:0;top:-12px;height:12px}.so-popover-bottom-left .so-popover-arrow,.so-popover-bottom .so-popover-arrow,.so-popover-bottom-right .so-popover-arrow,.so-popover-cover .so-popover-arrow{top:0;left:50%;transform:translate(-50%,-50%) rotate(315deg)}.so-popover-bottom-left,.so-popover-cover{transform:translate(0)}.so-popover-bottom-left .so-popover-arrow,.so-popover-cover .so-popover-arrow{left:12px}.so-popover-cover{margin-top:0}.so-popover-bottom-right{transform:translate(-100%)}.so-popover-bottom-right .so-popover-arrow{right:6px;left:auto}.so-popover-bottom-right{transform:none}.so-popover-top-right{transform:translateY(-100%)}.so-popover-content{position:relative;z-index:2;background-color:#fff;border-radius:inherit}.so-popover-info{border-color:var(--alert-info-border-color, #bce8f1)}.so-popover-info .so-popover-content{background:var(--alert-info-bg, #d9edf7)}.so-popover-info .so-popover-arrow{border-color:var(--alert-info-border-color, #bce8f1);background:var(--alert-info-bg, #d9edf7)}.so-popover-info .so-popover-icon path{fill:var(--info-color, #17a2b8)}.so-popover-warning{border-color:var(--alert-warning-border-color, #faebcc)}.so-popover-warning .so-popover-content{background:var(--alert-warning-bg, #fcf8e3)}.so-popover-warning .so-popover-arrow{border-color:var(--alert-warning-border-color, #faebcc);background:var(--alert-warning-bg, #fcf8e3)}.so-popover-warning .so-popover-icon path{fill:var(--warning-color, #ff9900)}.so-popover-success{border-color:var(--alert-success-border-color, #d6e9c6)}.so-popover-success .so-popover-content{background:var(--alert-success-bg, #dff0d8)}.so-popover-success .so-popover-arrow{border-color:var(--alert-success-border-color, #d6e9c6);background:var(--alert-success-bg, #dff0d8)}.so-popover-success .so-popover-icon path{fill:var(--success-color, #00cc66)}.so-popover-danger,.so-popover-error{border-color:var(--alert-danger-border-color, #ebccd1)}.so-popover-danger .so-popover-content,.so-popover-error .so-popover-content{background:var(--alert-danger-bg, #f2dede)}.so-popover-danger .so-popover-arrow,.so-popover-error .so-popover-arrow{border-color:var(--alert-danger-border-color, #ebccd1);background:var(--alert-danger-bg, #f2dede)}.so-popover-danger .so-popover-icon path,.so-popover-error .so-popover-icon path{fill:var(--danger-color, #f85555)}.so-popover-confirm{padding:16px}.so-popover-confirm .so-popover-footer{text-align:right}.so-popover-confirm .so-popover-mention .so-popover-alert{padding-top:0;padding-left:0;padding-right:0;background:transparent;border:none;color:var(--gray-900, #212529);box-shadow:none;margin-bottom:8px;font-size:var(--font-size-base, 14px)}.so-popover-text{display:inline-block;max-width:var(--popover-text-max-width, 320px);padding:var(--common-content-text-padding, 8px 12px)}.so-popover-input-tip{color:var(--form-tip-color, #7e8b98);border:none;box-shadow:0 0 0 1px var(--input-border-color, #ced4da),0 2px 8px #00000026}.so-popover-input-tip .so-popover-content,.so-popover-input-tip .so-popover-arrow{background-color:var(--gray-100, #f8f9fa);border-color:var(--input-border-color, #ced4da)}.so-popover-input-tip .so-popover-content>span{padding:6px 12px}.so-popover-input-error{color:var(--danger-color, #f85555);border:none;box-shadow:0 0 0 1px #ebccd1,0 2px 8px #00000026}.so-popover-input-error .so-popover-arrow{border-color:#ebccd1}.so-tooltip{position:absolute;z-index:1070;display:block;font-size:var(--font-size-small, 12px);word-wrap:break-word;pointer-events:none}@keyframes so-tooltip-kf-opacity{0%{opacity:0}to{opacity:1}}@keyframes so-tooltip-kf-top{0%{margin-top:0}to{margin-top:-9px}}@keyframes so-tooltip-kf-bottom{0%{margin-top:0}to{margin-top:9px}}@keyframes so-tooltip-kf-left{0%{margin-left:0}to{margin-left:-9px}}@keyframes so-tooltip-kf-right{0%{margin-left:0}to{margin-left:9px}}.so-tooltip-animation{transition:opacity .3 ease,transform .3s cubic-bezier(.71,1.7,.77,1.24)}.so-tooltip-disabled-wrapper{display:inline-block}.so-tooltip-arrow{position:absolute;z-index:1;display:inline-block;width:0;height:0}.so-tooltip-inner{position:relative;z-index:2;max-width:200px;padding:var(--tooltip-padding-vertical, 3px) var(--tooltip-padding-horizontal, 8px);background-color:var(--tooltip-bg, #000);border-radius:4px;color:#fff;text-align:center}.so-tooltip-top{margin-top:-9px;transform:translate(-50%,-100%)}.so-tooltip-top .so-tooltip-arrow{bottom:-5px;left:50%;border-top:6px solid var(--tooltip-bg, #000);border-right:6px solid transparent;border-left:6px solid transparent;transform:translate(-50%)}.so-tooltip-top.so-tooltip-animation{animation:so-tooltip-kf-opacity .3s ease,so-tooltip-kf-top .3s cubic-bezier(.71,1.7,.77,1.24)}.so-tooltip-right{margin-left:9px;transform:translateY(-50%)}.so-tooltip-right .so-tooltip-arrow{top:50%;left:-5px;border-top:6px solid transparent;border-right:6px solid var(--tooltip-bg, #000);border-bottom:6px solid transparent;transform:translateY(-50%)}.so-tooltip-right.so-tooltip-animation{animation:so-tooltip-kf-opacity .3s ease,so-tooltip-kf-right .3s cubic-bezier(.71,1.7,.77,1.24)}.so-tooltip-left{margin-left:-9px;transform:translate(-100%,-50%)}.so-tooltip-left .so-tooltip-arrow{top:50%;right:-5px;border-top:6px solid transparent;border-bottom:6px solid transparent;border-left:6px solid var(--tooltip-bg, #000);transform:translateY(-50%)}.so-tooltip-left.so-tooltip-animation{animation:so-tooltip-kf-opacity .3s ease,so-tooltip-kf-left .3s cubic-bezier(.71,1.7,.77,1.24)}.so-tooltip-bottom{margin-top:9px;transform:translate(-50%)}.so-tooltip-bottom .so-tooltip-arrow{top:-5px;left:50%;border-right:6px solid transparent;border-bottom:6px solid var(--tooltip-bg, #000);border-left:6px solid transparent;transform:translate(-50%)}.so-tooltip-bottom.so-tooltip-animation{animation:so-tooltip-kf-opacity .3s ease,so-tooltip-kf-bottom .3s cubic-bezier(.71,1.7,.77,1.24)}.so-tag{position:relative;display:inline-block;padding:var(--tag-padding-vertical, 2px) var(--tag-padding-horizontal, 8px);margin:0 4px;border:1px solid transparent;background:var(--tag-bg, #fafafa);border-radius:var(--tag-border-radius, 3px);color:var(--tag-color, #595959);cursor:pointer;font-size:75%;font-weight:var(--tag-font-weight, 600);line-height:1.5;transition:all .3s}.so-tag .so-tag-inline{display:inline-block;vertical-align:top}.so-tag.so-tag-disabled{cursor:not-allowed}.so-tag-input{display:inline-block;width:100px;height:24px;margin:0 0 0 4px;font-size:75%;vertical-align:middle}.so-tag-input input{padding:2px 4px;line-height:18px}.so-tag .so-tag-close-icon{display:inline-block;width:6px;margin:0 0 0 8px}.so-tag-rtl.so-tag .so-tag-close-icon{margin:0 8px 0 0}.so-tag .so-tag-close-icon:hover svg{fill:var(--tag-close-hover-color, "#000")}.so-tag .so-tag-close-icon svg{fill:var(--tag-close-color, "#000");width:6px;margin-bottom:1px}.so-tag .so-tag-close-loading{display:inline-block;margin:0 0 0 8px}.so-tag-rtl.so-tag .so-tag-close-loading{margin:0 8px 0 0}.so-tag-default{border-color:var(--tag-border-color, #d9d9d9)}.so-tag-success{border-color:transparent;background-color:var(--tag-success-bg, var(--success-color, #00cc66));color:#fff;color:var(--tag-success-color, #fff)}.so-tag-info{border-color:transparent;background-color:var(--tag-info-bg, var(--info-color, #17a2b8));color:#fff;color:var(--tag-info-color, #fff)}.so-tag-warning{border-color:transparent;background-color:var(--tag-warning-bg, var(--warning-color, #ff9900));color:#fff;color:var(--tag-warning-color, #fff)}.so-tag-danger,.so-tag-error{border-color:transparent;background-color:var(--tag-danger-bg, var(--danger-color, #f85555));color:#fff;color:var(--tag-danger-color, #fff)}.so-tag.so-tag-rtl{direction:rtl;text-align:right}.so-spin{margin:auto;line-height:1.5715;display:flex;flex-flow:column nowrap;align-items:center;justify-content:center}.so-spin>div{margin:unset}.so-spin-tip{margin:auto;text-align:center;padding-top:5px}.so-spin-container{position:relative}.so-spin-container .so-spin-loading{position:absolute;top:0;left:0;z-index:4;width:100%;height:100%;display:flex;justify-content:center;align-items:center}.so-spin-container .so-spin-content{position:relative}.so-spin-container .so-spin-content:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:3;width:100%;height:100%;background:#fff;opacity:0;transition:all .3s;content:"";pointer-events:none}.so-spin-show .so-spin-content:after{opacity:.5}.so-spin-default{position:relative;margin:auto}@keyframes so-spin-default-scale{0%,80%,to{transform:scale3d(0,0,1)}40%{transform:scaleZ(1)}}@keyframes so-spin-default-fade{0%,39%,to{opacity:.2}40%{opacity:1}}.so-spin-default-item{position:absolute;top:0;left:45%;width:10%;height:50%;transform-origin:50% 100%}.so-spin-default-item div{height:55%;margin:0 auto;animation:so-spin-default-fade 1s infinite ease-in-out both}.so-spin-default-scale svg,.so-spin-default-scale div{animation:so-spin-default-scale 1s infinite ease-in-out both}.so-spin-default-fade svg,.so-spin-default-fade div{animation:so-spin-default-fade 1s infinite ease-in-out both}.so-spin-default .so-spin-default-item:nth-child(2){transform:rotate(30deg)}.so-spin-default .so-spin-default-item:nth-child(2) svg,.so-spin-default .so-spin-default-item:nth-child(2) div{animation-delay:-.91666667s}.so-spin-default .so-spin-default-item:nth-child(3){transform:rotate(60deg)}.so-spin-default .so-spin-default-item:nth-child(3) svg,.so-spin-default .so-spin-default-item:nth-child(3) div{animation-delay:-.83333333s}.so-spin-default .so-spin-default-item:nth-child(4){transform:rotate(90deg)}.so-spin-default .so-spin-default-item:nth-child(4) svg,.so-spin-default .so-spin-default-item:nth-child(4) div{animation-delay:-.75s}.so-spin-default .so-spin-default-item:nth-child(5){transform:rotate(120deg)}.so-spin-default .so-spin-default-item:nth-child(5) svg,.so-spin-default .so-spin-default-item:nth-child(5) div{animation-delay:-.66666667s}.so-spin-default .so-spin-default-item:nth-child(6){transform:rotate(150deg)}.so-spin-default .so-spin-default-item:nth-child(6) svg,.so-spin-default .so-spin-default-item:nth-child(6) div{animation-delay:-.58333333s}.so-spin-default .so-spin-default-item:nth-child(7){transform:rotate(180deg)}.so-spin-default .so-spin-default-item:nth-child(7) svg,.so-spin-default .so-spin-default-item:nth-child(7) div{animation-delay:-.5s}.so-spin-default .so-spin-default-item:nth-child(8){transform:rotate(210deg)}.so-spin-default .so-spin-default-item:nth-child(8) svg,.so-spin-default .so-spin-default-item:nth-child(8) div{animation-delay:-.41666667s}.so-spin-default .so-spin-default-item:nth-child(9){transform:rotate(240deg)}.so-spin-default .so-spin-default-item:nth-child(9) svg,.so-spin-default .so-spin-default-item:nth-child(9) div{animation-delay:-.33333333s}.so-spin-default .so-spin-default-item:nth-child(10){transform:rotate(270deg)}.so-spin-default .so-spin-default-item:nth-child(10) svg,.so-spin-default .so-spin-default-item:nth-child(10) div{animation-delay:-.25s}.so-spin-default .so-spin-default-item:nth-child(11){transform:rotate(300deg)}.so-spin-default .so-spin-default-item:nth-child(11) svg,.so-spin-default .so-spin-default-item:nth-child(11) div{animation-delay:-.16666667s}.so-spin-default .so-spin-default-item:nth-child(12){transform:rotate(330deg)}.so-spin-default .so-spin-default-item:nth-child(12) svg,.so-spin-default .so-spin-default-item:nth-child(12) div{animation-delay:-.08333333s}.so-spin-ring{margin:auto;border-style:solid;border-color:#0000000d;animation:so-spin-ring-spin 1s infinite linear;border-radius:50%}@keyframes so-spin-ring-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.so-spin-plane{margin:auto;animation:so-spin-plane-spin 1s infinite linear}@keyframes so-spin-plane-spin{0%{transform:perspective(120px) rotateX(0) rotateY(0)}50%{transform:perspective(120px) rotateX(-180.1deg) rotateY(0)}to{transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)}}.so-spin-pulse{margin:auto;animation:so-spin-pulse-scale 1s infinite ease-in-out;border-radius:100%}@keyframes so-spin-pulse-scale{0%{transform:scale3d(0,0,1)}to{opacity:0;transform:scaleZ(1)}}.so-spin-wave{margin:auto;font-size:10px;text-align:center;white-space:nowrap}@keyframes so-spin-wave-scale{0%,40%,to{transform:scale3d(1,.4,1)}20%{transform:scaleZ(1)}}.so-spin-wave-item{display:inline-block;height:100%;margin-right:2px;animation:so-spin-wave-scale 1.2s infinite ease-in-out}.so-spin-wave-item:last-child{margin-right:0}.so-spin-wave .so-spin-wave-item:nth-child(2){animation-delay:-1.1s}.so-spin-wave .so-spin-wave-item:nth-child(3){animation-delay:-1s}.so-spin-wave .so-spin-wave-item:nth-child(4){animation-delay:-.9s}.so-spin-wave .so-spin-wave-item:nth-child(5){animation-delay:-.8s}.so-chasing-dots{position:relative;margin:auto;animation:so-chasing-dots-rotate 2s infinite linear;text-align:center}@keyframes so-chasing-dots-rotate{to{transform:rotate(360deg)}}@keyframes so-chasing-dots-bounce{0%,to{transform:scale3d(0,0,1)}50%{transform:scaleZ(1)}}.so-chasing-dots-item{position:absolute;top:0;display:inline-block;width:60%;height:60%;animation:so-chasing-dots-bounce 2s infinite ease-in-out;border-radius:100%}.so-chasing-dots-item:last-child{top:auto;bottom:0;animation-delay:-1s}.so-double-bounce{position:relative;margin:auto}@keyframes so-double-bounce-spin{0%,to{transform:scale3d(0,0,1)}50%{transform:scaleZ(1)}}.so-double-bounce-item{position:absolute;top:0;left:0;width:100%;height:100%;animation:so-double-bounce-spin 2s infinite ease-in-out;border-radius:50%;opacity:.6}.so-double-bounce-item:last-child{animation-delay:-1s}.so-cube-grid{margin:auto}.so-cube-grid-item{width:33.33333%;height:33.3333%;animation:so-cube-grid-spin 1.3s infinite ease-in-out;float:left}@keyframes so-cube-grid-spin{0%,70%,to{transform:scaleZ(1)}35%{transform:scale3D(0,0,1)}}.so-cube-grid-item:nth-child(1){animation-delay:.2s}.so-cube-grid-item:nth-child(2){animation-delay:.3s}.so-cube-grid-item:nth-child(3){animation-delay:.4s}.so-cube-grid-item:nth-child(4){animation-delay:.1s}.so-cube-grid-item:nth-child(5){animation-delay:.2s}.so-cube-grid-item:nth-child(6){animation-delay:.3s}.so-cube-grid-item:nth-child(7){animation-delay:0s}.so-cube-grid-item:nth-child(8){animation-delay:.1s}.so-cube-grid-item:nth-child(9){animation-delay:.2s}.so-chasing-ring{position:relative;margin:auto}@keyframes so-chasing-ring-loading{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes so-chasing-ring-loading1{0%{transform:rotate(0)}44%{transform:rotate(225deg)}to{transform:rotate(360deg)}}@keyframes so-chasing-ring-loading2{0%{transform:rotate(75deg)}44%{transform:rotate(225deg)}to{transform:rotate(435deg)}}@keyframes so-chasing-ring-loading3{0%{transform:rotate(150deg)}44%{transform:rotate(225deg)}to{transform:rotate(510deg)}}@keyframes so-chasing-ring-loading4{0%{transform:rotate(225deg)}44%{transform:rotate(225deg)}to{transform:rotate(585deg)}}.so-chasing-ring-item{position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;border:solid 1px transparent;border-radius:100%;transform-origin:50% 50%}.so-chasing-ring-item:nth-child(1){animation:so-chasing-ring-loading1 2s infinite}.so-chasing-ring-item:nth-child(2){animation:so-chasing-ring-loading2 2s infinite}.so-chasing-ring-item:nth-child(3){animation:so-chasing-ring-loading3 2s infinite}.so-chasing-ring-item:nth-child(4){animation:so-chasing-ring-loading4 2s infinite}.so-scale-circle{position:relative;margin:auto}@keyframes so-scale-circle-scale{0%,80%,to{transform:scale3d(0,0,1)}40%{transform:scaleZ(1)}}@keyframes so-scale-circle-fade{0%,39%,to{opacity:0}40%{opacity:1}}.so-scale-circle-item{position:absolute;top:10%;left:10%;width:80%;height:80%}.so-scale-circle-item div{border-radius:100%}.so-scale-circle-scale svg,.so-scale-circle-scale div{animation:so-scale-circle-scale 1.2s infinite ease-in-out both}.so-scale-circle-fade svg,.so-scale-circle-fade div{animation:so-scale-circle-fade 1.2s infinite ease-in-out both}.so-scale-circle .so-scale-circle-item:nth-child(2){transform:rotate(30deg)}.so-scale-circle .so-scale-circle-item:nth-child(2) svg,.so-scale-circle .so-scale-circle-item:nth-child(2) div{animation-delay:-1.1s}.so-scale-circle .so-scale-circle-item:nth-child(3){transform:rotate(60deg)}.so-scale-circle .so-scale-circle-item:nth-child(3) svg,.so-scale-circle .so-scale-circle-item:nth-child(3) div{animation-delay:-1s}.so-scale-circle .so-scale-circle-item:nth-child(4){transform:rotate(90deg)}.so-scale-circle .so-scale-circle-item:nth-child(4) svg,.so-scale-circle .so-scale-circle-item:nth-child(4) div{animation-delay:-.9s}.so-scale-circle .so-scale-circle-item:nth-child(5){transform:rotate(120deg)}.so-scale-circle .so-scale-circle-item:nth-child(5) svg,.so-scale-circle .so-scale-circle-item:nth-child(5) div{animation-delay:-.8s}.so-scale-circle .so-scale-circle-item:nth-child(6){transform:rotate(150deg)}.so-scale-circle .so-scale-circle-item:nth-child(6) svg,.so-scale-circle .so-scale-circle-item:nth-child(6) div{animation-delay:-.7s}.so-scale-circle .so-scale-circle-item:nth-child(7){transform:rotate(180deg)}.so-scale-circle .so-scale-circle-item:nth-child(7) svg,.so-scale-circle .so-scale-circle-item:nth-child(7) div{animation-delay:-.6s}.so-scale-circle .so-scale-circle-item:nth-child(8){transform:rotate(210deg)}.so-scale-circle .so-scale-circle-item:nth-child(8) svg,.so-scale-circle .so-scale-circle-item:nth-child(8) div{animation-delay:-.5s}.so-scale-circle .so-scale-circle-item:nth-child(9){transform:rotate(240deg)}.so-scale-circle .so-scale-circle-item:nth-child(9) svg,.so-scale-circle .so-scale-circle-item:nth-child(9) div{animation-delay:-.4s}.so-scale-circle .so-scale-circle-item:nth-child(10){transform:rotate(270deg)}.so-scale-circle .so-scale-circle-item:nth-child(10) svg,.so-scale-circle .so-scale-circle-item:nth-child(10) div{animation-delay:-.3s}.so-scale-circle .so-scale-circle-item:nth-child(11){transform:rotate(300deg)}.so-scale-circle .so-scale-circle-item:nth-child(11) svg,.so-scale-circle .so-scale-circle-item:nth-child(11) div{animation-delay:-.2s}.so-scale-circle .so-scale-circle-item:nth-child(12){transform:rotate(330deg)}.so-scale-circle .so-scale-circle-item:nth-child(12) svg,.so-scale-circle .so-scale-circle-item:nth-child(12) div{animation-delay:-.1s}.so-three-bounce{margin:auto;text-align:center}@keyframes so-three-bounce-bounce{0%,80%,to{transform:scale3d(0,0,1)}40%{transform:scaleZ(1)}}.so-three-bounce-item{display:inline-block;animation:so-three-bounce-bounce 1.4s ease-in-out 0s infinite both}.so-three-bounce-item div{border-radius:100%}.so-three-bounce-item:nth-child(1){animation-delay:-.32s}.so-three-bounce-item:nth-child(2){animation-delay:-.16s}.so-four-dots{position:relative;margin:auto;animation:so-four-dots-rotate 1.6s infinite linear}@keyframes so-four-dots-rotate{0%{transform:rotate(0)}to{transform:rotate(359deg)}}@keyframes so-four-dots-fade{0%{opacity:.2}50%{opacity:.9}to{opacity:.2}}.so-four-dots-item{position:absolute;width:32%;height:32%;animation:so-four-dots-fade 1.6s linear infinite;line-height:0;opacity:.2}.so-four-dots-item div{border-radius:100%}.so-four-dots-item:nth-child(1){top:10%;left:10%}.so-four-dots-item:nth-child(2){top:10%;right:10%;animation-delay:.4s}.so-four-dots-item:nth-child(3){right:10%;bottom:10%;animation-delay:.8s}.so-four-dots-item:nth-child(4){bottom:10%;left:10%;animation-delay:1.2s}.shein-components_ellipsis_ellipsis{overflow:hidden;-ms-text-overflow:ellipsis;text-overflow:ellipsis;position:relative}.shein-components_ellipsis_ellipsis:before{content:"";display:block}.shein-components_ellipsis_ellipsis:after{content:"";display:block}.shein-components_ellipsis_hide{display:inline-block;position:absolute;top:0;left:0;z-index:-1;opacity:0;visibility:hidden;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.shein-components_ellipsis_more:after{content:"...";width:1.5em;background-color:#fff;display:inline-block;position:absolute;right:0;bottom:0}.shein-components_ellipsis_popStyle{padding:10px;white-space:pre-wrap;display:flex;flex-wrap:wrap;row-gap:8px}.shein-components_ellipsis_pointer{cursor:pointer}.shein-components_ellipsis_ellipsisWrap{overflow:hidden;position:relative;background-color:#fff}.shein-components_ellipsis_beforeText{content:"";float:left;display:block;width:1.5em}.shein-components_ellipsis_endText{float:right;width:1.5em;position:relative;left:100%;text-align:right;transform:translate(-100%,-100%);cursor:pointer;background:linear-gradient(to right,rgba(255,255,255,0),white 50%,white)}.shein-components_ellipsis_text{float:right;width:100%;margin-left:-1.5em;word-break:break-all}.shein-components_ellipsis_autoSizeWrap{position:relative;height:100%;width:100%}.shein-components_ellipsis_autoSizeIn{position:absolute;width:100%;left:0;top:0}.shein-components_ellipsis_flexWrap{display:flex;flex-flow:row nowrap}.shein-components_ellipsis_grow{flex-grow:1;width:0}.shein-components_ellipsis_arLang{direction:rtl}.shein-components_ellipsis_tagWrap{display:inline-block}.shein-components_ellipsis_arrayEllipsis{width:100%;height:100%;position:relative}:root{font-family:Inter,Avenir,Helvetica,Arial,sans-serif;font-size:16px;line-height:24px;font-weight:400;color-scheme:light dark;color:#ffffffde;background-color:#242424;font-synthesis:none;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-text-size-adjust:100%} ');

(function (React, ReactDOM__default) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
  const ReactDOM__default__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM__default);

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$1 = React, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
  function q$1(c2, a, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a.key && (e2 = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b2 in a)
      m$2.call(a, b2) && !p$1.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a = c2.defaultProps, a)
        void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
  }
  reactJsxRuntime_production_min.Fragment = l$1;
  reactJsxRuntime_production_min.jsx = q$1;
  reactJsxRuntime_production_min.jsxs = q$1;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var m$1 = ReactDOM__default;
  {
    client.createRoot = m$1.createRoot;
    client.hydrateRoot = m$1.hydrateRoot;
  }
  var classnames = { exports: {} };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  (function(module) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner2 = classNames.apply(null, arg);
              if (inner2) {
                classes.push(inner2);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  })(classnames);
  var classnamesExports = classnames.exports;
  const classname = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  function _extends$7() {
    _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$7.apply(this, arguments);
  }
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if ("object" === typeof a && null !== a) {
      var r = a.$$typeof;
      switch (r) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e:
            case m:
            case n:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r;
              }
          }
        case c:
          return r;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a) {
    return v(a) === h;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return v(a) === g;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return v(a) === l;
  };
  reactIs_production_min.isFragment = function(a) {
    return v(a) === d;
  };
  reactIs_production_min.isLazy = function(a) {
    return v(a) === q;
  };
  reactIs_production_min.isMemo = function(a) {
    return v(a) === p;
  };
  reactIs_production_min.isPortal = function(a) {
    return v(a) === c;
  };
  reactIs_production_min.isProfiler = function(a) {
    return v(a) === f;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return v(a) === e;
  };
  reactIs_production_min.isSuspense = function(a) {
    return v(a) === m;
  };
  reactIs_production_min.isSuspenseList = function(a) {
    return v(a) === n;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  {
    reactIs.exports = reactIs_production_min;
  }
  var reactIsExports = reactIs.exports;
  function toArray$3(children) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var ret = [];
    React.Children.forEach(children, function(child) {
      if ((child === void 0 || child === null) && !option.keepEmpty) {
        return;
      }
      if (Array.isArray(child)) {
        ret = ret.concat(toArray$3(child));
      } else if (reactIsExports.isFragment(child) && child.props) {
        ret = ret.concat(toArray$3(child.props.children, option));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }
  var warned = {};
  var preMessage = function preMessage2(fn) {
  };
  function warning$3(valid, message2) {
  }
  function note(valid, message2) {
  }
  function resetWarned() {
    warned = {};
  }
  function call(method4, valid, message2) {
    if (!valid && !warned[message2]) {
      method4(false, message2);
      warned[message2] = true;
    }
  }
  function warningOnce(valid, message2) {
    call(warning$3, valid, message2);
  }
  function noteOnce(valid, message2) {
    call(note, valid, message2);
  }
  warningOnce.preMessage = preMessage;
  warningOnce.resetWarned = resetWarned;
  warningOnce.noteOnce = noteOnce;
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _defineProperty$1(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys$1(e2, r) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e2);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
      })), t2.push.apply(t2, o);
    }
    return t2;
  }
  function _objectSpread2(e2) {
    for (var r = 1; r < arguments.length; r++) {
      var t2 = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$1(Object(t2), true).forEach(function(r2) {
        _defineProperty$1(e2, r2, t2[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r2) {
        Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t2, r2));
      });
    }
    return e2;
  }
  function isDOM(node2) {
    return node2 instanceof HTMLElement || node2 instanceof SVGElement;
  }
  function findDOMNode(node2) {
    if (isDOM(node2)) {
      return node2;
    }
    if (node2 instanceof React.Component) {
      return ReactDOM__default.findDOMNode(node2);
    }
    return null;
  }
  function useMemo(getValue2, condition, shouldUpdate) {
    var cacheRef = React__namespace.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue2();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }
  function fillRef(ref, node2) {
    if (typeof ref === "function") {
      ref(node2);
    } else if (_typeof(ref) === "object" && ref && "current" in ref) {
      ref.current = node2;
    }
  }
  function composeRef() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    var refList = refs.filter(function(ref) {
      return ref;
    });
    if (refList.length <= 1) {
      return refList[0];
    }
    return function(node2) {
      refs.forEach(function(ref) {
        fillRef(ref, node2);
      });
    };
  }
  function useComposeRef() {
    for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      refs[_key2] = arguments[_key2];
    }
    return useMemo(function() {
      return composeRef.apply(void 0, refs);
    }, refs, function(prev2, next2) {
      return prev2.length !== next2.length || prev2.every(function(ref, i) {
        return ref !== next2[i];
      });
    });
  }
  function supportRef(nodeOrComponent) {
    var _type$prototype, _nodeOrComponent$prot;
    var type4 = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
      return false;
    }
    if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
      return false;
    }
    return true;
  }
  var CollectionContext = /* @__PURE__ */ React__namespace.createContext(null);
  function Collection(_ref) {
    var children = _ref.children, onBatchResize = _ref.onBatchResize;
    var resizeIdRef = React__namespace.useRef(0);
    var resizeInfosRef = React__namespace.useRef([]);
    var onCollectionResize = React__namespace.useContext(CollectionContext);
    var onResize2 = React__namespace.useCallback(function(size, element, data) {
      resizeIdRef.current += 1;
      var currentId2 = resizeIdRef.current;
      resizeInfosRef.current.push({
        size,
        element,
        data
      });
      Promise.resolve().then(function() {
        if (currentId2 === resizeIdRef.current) {
          onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
          resizeInfosRef.current = [];
        }
      });
      onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
    }, [onBatchResize, onCollectionResize]);
    return /* @__PURE__ */ React__namespace.createElement(CollectionContext.Provider, {
      value: onResize2
    }, children);
  }
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function(entry, index2) {
        if (entry[0] === key) {
          result = index2;
          return true;
        }
        return false;
      });
      return result;
    }
    return (
      /** @class */
      function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key) {
          var index2 = getIndex(this.__entries__, key);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key, value) {
          var index2 = getIndex(this.__entries__, key);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        class_1.prototype.delete = function(key) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key) {
          return !!~getIndex(this.__entries__, key);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }()
    );
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle$1(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = (
    /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }()
  );
  var defineConfigurable = function(target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target;
  };
  var getWindowOf = function(target) {
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles2) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position2) {
      var value = styles2["border-" + position2 + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  function getPaddings(styles2) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position2 = positions_1[_i];
      var value = styles2["padding-" + position2];
      paddings[position2] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target) {
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles2 = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles2);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles2.width), height = toFloat(styles2.height);
    if (styles2.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles2, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles2, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    return function(target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
    };
  }();
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x,
      y,
      width,
      height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  function createRectInit(x, y, width, height) {
    return { x, y, width, height };
  }
  var ResizeObservation = (
    /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }()
  );
  var ResizeObserverEntry = (
    /** @class */
    function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }()
  );
  var ResizeObserverSPI = (
    /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }()
  );
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver$2 = (
    /** @class */
    function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver2;
    }()
  );
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method4) {
    ResizeObserver$2.prototype[method4] = function() {
      var _a;
      return (_a = observers.get(this))[method4].apply(_a, arguments);
    };
  });
  var index$2 = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
  }();
  var elementListeners = /* @__PURE__ */ new Map();
  function onResize(entities) {
    entities.forEach(function(entity) {
      var _elementListeners$get;
      var target = entity.target;
      (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
        return listener(target);
      });
    });
  }
  var resizeObserver = new index$2(onResize);
  function observe(element, callback) {
    if (!elementListeners.has(element)) {
      elementListeners.set(element, /* @__PURE__ */ new Set());
      resizeObserver.observe(element);
    }
    elementListeners.get(element).add(callback);
  }
  function unobserve(element, callback) {
    if (elementListeners.has(element)) {
      elementListeners.get(element).delete(callback);
      if (!elementListeners.get(element).size) {
        resizeObserver.unobserve(element);
        elementListeners.delete(element);
      }
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _setPrototypeOf$1(o, p2) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf$1(o, p2);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf$1(subClass, superClass);
  }
  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf$1(o);
  }
  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper2, _React$Component);
    var _super = _createSuper(DomWrapper2);
    function DomWrapper2() {
      _classCallCheck(this, DomWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass(DomWrapper2, [{
      key: "render",
      value: function render2() {
        return this.props.children;
      }
    }]);
    return DomWrapper2;
  }(React__namespace.Component);
  function SingleObserver(props, ref) {
    var children = props.children, disabled = props.disabled;
    var elementRef = React__namespace.useRef(null);
    var wrapperRef = React__namespace.useRef(null);
    var onCollectionResize = React__namespace.useContext(CollectionContext);
    var isRenderProps = typeof children === "function";
    var mergedChildren = isRenderProps ? children(elementRef) : children;
    var sizeRef = React__namespace.useRef({
      width: -1,
      height: -1,
      offsetWidth: -1,
      offsetHeight: -1
    });
    var canRef = !isRenderProps && /* @__PURE__ */ React__namespace.isValidElement(mergedChildren) && supportRef(mergedChildren);
    var originRef = canRef ? mergedChildren.ref : null;
    var mergedRef = useComposeRef(originRef, elementRef);
    var getDom = function getDom2() {
      var _elementRef$current;
      return findDOMNode(elementRef.current) || // Support `nativeElement` format
      (elementRef.current && _typeof(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
    };
    React__namespace.useImperativeHandle(ref, function() {
      return getDom();
    });
    var propsRef = React__namespace.useRef(props);
    propsRef.current = props;
    var onInternalResize = React__namespace.useCallback(function(target) {
      var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
      var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
      var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);
      if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
        var size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        sizeRef.current = size;
        var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
        var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
        var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
          offsetWidth: mergedOffsetWidth,
          offsetHeight: mergedOffsetHeight
        });
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
        if (onResize2) {
          Promise.resolve().then(function() {
            onResize2(sizeInfo, target);
          });
        }
      }
    }, []);
    React__namespace.useEffect(function() {
      var currentElement = getDom();
      if (currentElement && !disabled) {
        observe(currentElement, onInternalResize);
      }
      return function() {
        return unobserve(currentElement, onInternalResize);
      };
    }, [elementRef.current, disabled]);
    return /* @__PURE__ */ React__namespace.createElement(DomWrapper$1, {
      ref: wrapperRef
    }, canRef ? /* @__PURE__ */ React__namespace.cloneElement(mergedChildren, {
      ref: mergedRef
    }) : mergedChildren);
  }
  var RefSingleObserver = /* @__PURE__ */ React__namespace.forwardRef(SingleObserver);
  var INTERNAL_PREFIX_KEY = "rc-observer-key";
  function ResizeObserver$1(props, ref) {
    var children = props.children;
    var childNodes = typeof children === "function" ? [children] : toArray$3(children);
    return childNodes.map(function(child, index2) {
      var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
      return /* @__PURE__ */ React__namespace.createElement(RefSingleObserver, _extends$7({}, props, {
        key,
        ref: index2 === 0 ? ref : void 0
      }), child);
    });
  }
  var RefResizeObserver = /* @__PURE__ */ React__namespace.forwardRef(ResizeObserver$1);
  RefResizeObserver.Collection = Collection;
  function omit(obj, fields) {
    var clone = _objectSpread2({}, obj);
    if (Array.isArray(fields)) {
      fields.forEach(function(key) {
        delete clone[key];
      });
    }
    return clone;
  }
  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray$2(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray$2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray$2(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray$2(o, minLen);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread();
  }
  var raf = function raf2(callback) {
    return +setTimeout(callback, 16);
  };
  var caf = function caf2(num) {
    return clearTimeout(num);
  };
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = function raf3(callback) {
      return window.requestAnimationFrame(callback);
    };
    caf = function caf3(handle) {
      return window.cancelAnimationFrame(handle);
    };
  }
  var rafUUID = 0;
  var rafIds = /* @__PURE__ */ new Map();
  function cleanup(id) {
    rafIds.delete(id);
  }
  var wrapperRaf = function wrapperRaf2(callback) {
    var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    var id = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id);
        callback();
      } else {
        var realId = raf(function() {
          callRef(leftTimes - 1);
        });
        rafIds.set(id, realId);
      }
    }
    callRef(times);
    return id;
  };
  wrapperRaf.cancel = function(id) {
    var realId = rafIds.get(id);
    cleanup(realId);
    return caf(realId);
  };
  function throttleByAnimationFrame(fn) {
    let requestId;
    const later = (args) => () => {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args));
    };
    const throttled = function() {
      if (requestId == null) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        requestId = wrapperRaf(later(args));
      }
    };
    throttled.cancel = () => {
      wrapperRaf.cancel(requestId);
      requestId = null;
    };
    return throttled;
  }
  function murmur2(str) {
    var h2 = 0;
    var k2, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  function _objectWithoutPropertiesLoose$8(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties$8(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$8(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function isEqual(obj1, obj2) {
    var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var refSet = /* @__PURE__ */ new Set();
    function deepEqual(a, b2) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var circular = refSet.has(a);
      warningOnce(!circular, "Warning: There may be circular references");
      if (circular) {
        return false;
      }
      if (a === b2) {
        return true;
      }
      if (shallow && level > 1) {
        return false;
      }
      refSet.add(a);
      var newLevel = level + 1;
      if (Array.isArray(a)) {
        if (!Array.isArray(b2) || a.length !== b2.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!deepEqual(a[i], b2[i], newLevel)) {
            return false;
          }
        }
        return true;
      }
      if (a && b2 && _typeof(a) === "object" && _typeof(b2) === "object") {
        var keys2 = Object.keys(a);
        if (keys2.length !== Object.keys(b2).length) {
          return false;
        }
        return keys2.every(function(key) {
          return deepEqual(a[key], b2[key], newLevel);
        });
      }
      return false;
    }
    return deepEqual(obj1, obj2);
  }
  var SPLIT$1 = "%";
  var Entity = /* @__PURE__ */ function() {
    function Entity2(instanceId) {
      _classCallCheck(this, Entity2);
      _defineProperty$1(this, "instanceId", void 0);
      _defineProperty$1(this, "cache", /* @__PURE__ */ new Map());
      this.instanceId = instanceId;
    }
    _createClass(Entity2, [{
      key: "get",
      value: function get2(keys2) {
        return this.cache.get(keys2.join(SPLIT$1)) || null;
      }
    }, {
      key: "update",
      value: function update(keys2, valueFn) {
        var path = keys2.join(SPLIT$1);
        var prevValue = this.cache.get(path);
        var nextValue = valueFn(prevValue);
        if (nextValue === null) {
          this.cache.delete(path);
        } else {
          this.cache.set(path, nextValue);
        }
      }
    }]);
    return Entity2;
  }();
  var ATTR_TOKEN = "data-token-hash";
  var ATTR_MARK = "data-css-hash";
  var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache() {
    var cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      var styles2 = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
      var firstChild = document.head.firstChild;
      Array.from(styles2).forEach(function(style2) {
        style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style2, firstChild);
        }
      });
      var styleHash = {};
      Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
        var hash = style2.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
          }
        } else {
          styleHash[hash] = true;
        }
      });
    }
    return new Entity(cssinjsInstanceId);
  }
  var StyleContext = /* @__PURE__ */ React__namespace.createContext({
    hashPriority: "low",
    cache: createCache(),
    defaultCache: true
  });
  const StyleContext$1 = StyleContext;
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains(root, n2) {
    if (!root) {
      return false;
    }
    if (root.contains) {
      return root.contains(n2);
    }
    var node2 = n2;
    while (node2) {
      if (node2 === root) {
        return true;
      }
      node2 = node2.parentNode;
    }
    return false;
  }
  var APPEND_ORDER = "data-rc-order";
  var APPEND_PRIORITY = "data-rc-priority";
  var MARK_KEY = "rc-util-key";
  var containerCache = /* @__PURE__ */ new Map();
  function getMark() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
    if (mark) {
      return mark.startsWith("data-") ? mark : "data-".concat(mark);
    }
    return MARK_KEY;
  }
  function getContainer$1(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
      return node2.tagName === "STYLE";
    });
  }
  function injectCSS(css) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) {
      return null;
    }
    var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
    var mergedOrder = getOrder(prepend);
    var isPrependQueue = mergedOrder === "prependQueue";
    var styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, mergedOrder);
    if (isPrependQueue && priority) {
      styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
    }
    if (csp !== null && csp !== void 0 && csp.nonce) {
      styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    }
    styleNode.innerHTML = css;
    var container = getContainer$1(option);
    var firstChild = container.firstChild;
    if (prepend) {
      if (isPrependQueue) {
        var existStyle = findStyles(container).filter(function(node2) {
          if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER))) {
            return false;
          }
          var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
          return priority >= nodePriority;
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer$1(option);
    return findStyles(container).find(function(node2) {
      return node2.getAttribute(getMark(option)) === key;
    });
  }
  function removeCSS(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var existNode = findExistNode(key, option);
    if (existNode) {
      var container = getContainer$1(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer(container, option) {
    var cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      var placeholderStyle = injectCSS("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css, key) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer$1(option);
    syncRealContainer(container, option);
    var existNode = findExistNode(key, option);
    if (existNode) {
      var _option$csp, _option$csp2;
      if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
        var _option$csp3;
        existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
      }
      if (existNode.innerHTML !== css) {
        existNode.innerHTML = css;
      }
      return existNode;
    }
    var newNode = injectCSS(css, option);
    newNode.setAttribute(getMark(option), key);
    return newNode;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(r, l2) {
    var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t2) {
      var e2, n2, i, u2, a = [], f2 = true, o = false;
      try {
        if (i = (t2 = t2.call(r)).next, 0 === l2) {
          if (Object(t2) !== t2)
            return;
          f2 = false;
        } else
          for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
            ;
      } catch (r2) {
        o = true, n2 = r2;
      } finally {
        try {
          if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
            return;
        } finally {
          if (o)
            throw n2;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest();
  }
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (var i = 0; i < left.length; i++) {
      if (left[i] !== right[i]) {
        return false;
      }
    }
    return true;
  }
  var ThemeCache = /* @__PURE__ */ function() {
    function ThemeCache2() {
      _classCallCheck(this, ThemeCache2);
      _defineProperty$1(this, "cache", void 0);
      _defineProperty$1(this, "keys", void 0);
      _defineProperty$1(this, "cacheCallTimes", void 0);
      this.cache = /* @__PURE__ */ new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    _createClass(ThemeCache2, [{
      key: "size",
      value: function size() {
        return this.keys.length;
      }
    }, {
      key: "internalGet",
      value: function internalGet(derivativeOption) {
        var _cache2, _cache3;
        var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var cache = {
          map: this.cache
        };
        derivativeOption.forEach(function(derivative2) {
          if (!cache) {
            cache = void 0;
          } else {
            var _cache, _cache$map;
            cache = (_cache = cache) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
          }
        });
        if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
          cache.value[1] = this.cacheCallTimes++;
        }
        return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
      }
    }, {
      key: "get",
      value: function get2(derivativeOption) {
        var _this$internalGet;
        return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
      }
    }, {
      key: "has",
      value: function has(derivativeOption) {
        return !!this.internalGet(derivativeOption);
      }
    }, {
      key: "set",
      value: function set2(derivativeOption, value) {
        var _this = this;
        if (!this.has(derivativeOption)) {
          if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
            var _this$keys$reduce = this.keys.reduce(function(result, key) {
              var _result = _slicedToArray(result, 2), callTimes = _result[1];
              if (_this.internalGet(key)[1] < callTimes) {
                return [key, _this.internalGet(key)[1]];
              }
              return result;
            }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
            this.delete(targetKey);
          }
          this.keys.push(derivativeOption);
        }
        var cache = this.cache;
        derivativeOption.forEach(function(derivative2, index2) {
          if (index2 === derivativeOption.length - 1) {
            cache.set(derivative2, {
              value: [value, _this.cacheCallTimes++]
            });
          } else {
            var cacheValue = cache.get(derivative2);
            if (!cacheValue) {
              cache.set(derivative2, {
                map: /* @__PURE__ */ new Map()
              });
            } else if (!cacheValue.map) {
              cacheValue.map = /* @__PURE__ */ new Map();
            }
            cache = cache.get(derivative2).map;
          }
        });
      }
    }, {
      key: "deleteByPath",
      value: function deleteByPath(currentCache, derivatives) {
        var cache = currentCache.get(derivatives[0]);
        if (derivatives.length === 1) {
          var _cache$value;
          if (!cache.map) {
            currentCache.delete(derivatives[0]);
          } else {
            currentCache.set(derivatives[0], {
              map: cache.map
            });
          }
          return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
        }
        var result = this.deleteByPath(cache.map, derivatives.slice(1));
        if ((!cache.map || cache.map.size === 0) && !cache.value) {
          currentCache.delete(derivatives[0]);
        }
        return result;
      }
    }, {
      key: "delete",
      value: function _delete(derivativeOption) {
        if (this.has(derivativeOption)) {
          this.keys = this.keys.filter(function(item) {
            return !sameDerivativeOption(item, derivativeOption);
          });
          return this.deleteByPath(this.cache, derivativeOption);
        }
        return void 0;
      }
    }]);
    return ThemeCache2;
  }();
  _defineProperty$1(ThemeCache, "MAX_CACHE_SIZE", 20);
  _defineProperty$1(ThemeCache, "MAX_CACHE_OFFSET", 5);
  var uuid$4 = 0;
  var Theme = /* @__PURE__ */ function() {
    function Theme2(derivatives) {
      _classCallCheck(this, Theme2);
      _defineProperty$1(this, "derivatives", void 0);
      _defineProperty$1(this, "id", void 0);
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid$4;
      if (derivatives.length === 0) {
        warning$3(derivatives.length > 0);
      }
      uuid$4 += 1;
    }
    _createClass(Theme2, [{
      key: "getDerivativeToken",
      value: function getDerivativeToken(token2) {
        return this.derivatives.reduce(function(result, derivative2) {
          return derivative2(token2, result);
        }, void 0);
      }
    }]);
    return Theme2;
  }();
  var cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }
  var resultCache = /* @__PURE__ */ new WeakMap();
  var RESULT_VALUE = {};
  function memoResult(callback, deps) {
    var current = resultCache;
    for (var i = 0; i < deps.length; i += 1) {
      var dep = deps[i];
      if (!current.has(dep)) {
        current.set(dep, /* @__PURE__ */ new WeakMap());
      }
      current = current.get(dep);
    }
    if (!current.has(RESULT_VALUE)) {
      current.set(RESULT_VALUE, callback());
    }
    return current.get(RESULT_VALUE);
  }
  var flattenTokenCache = /* @__PURE__ */ new WeakMap();
  function flattenToken(token2) {
    var str = flattenTokenCache.get(token2) || "";
    if (!str) {
      Object.keys(token2).forEach(function(key) {
        var value = token2[key];
        str += key;
        if (value instanceof Theme) {
          str += value.id;
        } else if (value && _typeof(value) === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      flattenTokenCache.set(token2, str);
    }
    return str;
  }
  function token2key(token2, salt) {
    return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
  }
  var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
  var checkContent = "_bAmBoO_";
  function supportSelector(styleStr, handleElement, supportCheck) {
    if (canUseDom()) {
      var _getComputedStyle$con, _ele$parentNode;
      updateCSS(styleStr, randomSelectorKey);
      var _ele = document.createElement("div");
      _ele.style.position = "fixed";
      _ele.style.left = "0";
      _ele.style.top = "0";
      handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
      document.body.appendChild(_ele);
      var support = supportCheck ? supportCheck(_ele) : (_getComputedStyle$con = getComputedStyle(_ele).content) === null || _getComputedStyle$con === void 0 ? void 0 : _getComputedStyle$con.includes(checkContent);
      (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
      removeCSS(randomSelectorKey);
      return support;
    }
    return false;
  }
  var canLayer = void 0;
  function supportLayer() {
    if (canLayer === void 0) {
      canLayer = supportSelector("@layer ".concat(randomSelectorKey, " { .").concat(randomSelectorKey, ' { content: "').concat(checkContent, '"!important; } }'), function(ele) {
        ele.className = randomSelectorKey;
      });
    }
    return canLayer;
  }
  var useInternalLayoutEffect = canUseDom() ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var useLayoutEffect$1 = function useLayoutEffect(callback, deps) {
    var firstMountRef = React__namespace.useRef(true);
    useInternalLayoutEffect(function() {
      return callback(firstMountRef.current);
    }, deps);
    useInternalLayoutEffect(function() {
      firstMountRef.current = false;
      return function() {
        firstMountRef.current = true;
      };
    }, []);
  };
  var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
    useLayoutEffect$1(function(firstMount) {
      if (!firstMount) {
        return callback();
      }
    }, deps);
  };
  var fullClone$2 = _objectSpread2({}, React__namespace);
  var useInsertionEffect$1 = fullClone$2.useInsertionEffect;
  var useInsertionEffectPolyfill = function useInsertionEffectPolyfill2(renderEffect, effect, deps) {
    React__namespace.useMemo(renderEffect, deps);
    useLayoutEffect$1(function() {
      return effect(true);
    }, deps);
  };
  var useCompatibleInsertionEffect = useInsertionEffect$1 ? function(renderEffect, effect, deps) {
    return useInsertionEffect$1(function() {
      renderEffect();
      return effect();
    }, deps);
  } : useInsertionEffectPolyfill;
  const useCompatibleInsertionEffect$1 = useCompatibleInsertionEffect;
  var fullClone$1 = _objectSpread2({}, React__namespace);
  var useInsertionEffect = fullClone$1.useInsertionEffect;
  var useCleanupRegister = function useCleanupRegister2(deps) {
    var effectCleanups = [];
    var cleanupFlag = false;
    function register2(fn) {
      if (cleanupFlag) {
        return;
      }
      effectCleanups.push(fn);
    }
    React__namespace.useEffect(function() {
      cleanupFlag = false;
      return function() {
        cleanupFlag = true;
        if (effectCleanups.length) {
          effectCleanups.forEach(function(fn) {
            return fn();
          });
        }
      };
    }, deps);
    return register2;
  };
  var useRun = function useRun2() {
    return function(fn) {
      fn();
    };
  };
  var useEffectCleanupRegister = typeof useInsertionEffect !== "undefined" ? useCleanupRegister : useRun;
  const useEffectCleanupRegister$1 = useEffectCleanupRegister;
  function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
    var _React$useContext = React__namespace.useContext(StyleContext$1), globalCache = _React$useContext.cache;
    var fullPath = [prefix].concat(_toConsumableArray(keyPath));
    var deps = fullPath.join("_");
    var register2 = useEffectCleanupRegister$1([deps]);
    var buildCache = function buildCache2(updater) {
      globalCache.update(fullPath, function(prevCache) {
        var _ref = prevCache || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
        var tmpCache = cache;
        var mergedCache = tmpCache || cacheFn();
        var data = [times, mergedCache];
        return updater ? updater(data) : data;
      });
    };
    React__namespace.useMemo(
      function() {
        buildCache();
      },
      /* eslint-disable react-hooks/exhaustive-deps */
      [deps]
      /* eslint-enable */
    );
    var cacheEntity = globalCache.get(fullPath);
    var cacheContent = cacheEntity[1];
    useCompatibleInsertionEffect$1(function() {
      onCacheEffect === null || onCacheEffect === void 0 ? void 0 : onCacheEffect(cacheContent);
    }, function(polyfill) {
      buildCache(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
        if (polyfill && times === 0) {
          onCacheEffect === null || onCacheEffect === void 0 ? void 0 : onCacheEffect(cacheContent);
        }
        return [times + 1, cache];
      });
      return function() {
        globalCache.update(fullPath, function(prevCache) {
          var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1];
          var nextCount = times - 1;
          if (nextCount === 0) {
            register2(function() {
              return onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
            });
            return null;
          }
          return [times - 1, cache];
        });
      };
    }, [deps]);
    return cacheContent;
  }
  var EMPTY_OVERRIDE = {};
  var hashPrefix = "css";
  var tokenKeys = /* @__PURE__ */ new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key, instanceId) {
    if (typeof document !== "undefined") {
      var styles2 = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
      styles2.forEach(function(style2) {
        if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
        }
      });
    }
  }
  var TOKEN_THRESHOLD = 0;
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    var tokenKeyList = Array.from(tokenKeys.keys());
    var cleanableKeyList = tokenKeyList.filter(function(key) {
      var count = tokenKeys.get(key) || 0;
      return count <= 0;
    });
    if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
      cleanableKeyList.forEach(function(key) {
        removeStyleTags(key, instanceId);
        tokenKeys.delete(key);
      });
    }
  }
  var getComputedToken$1 = function getComputedToken(originToken, overrideToken, theme, format2) {
    var derivativeToken = theme.getDerivativeToken(originToken);
    var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  function useCacheToken(theme, tokens) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _useContext = React.useContext(StyleContext$1), instanceId = _useContext.cache.instanceId;
    var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken, compute = option.getComputedToken;
    var mergedToken = memoResult(function() {
      return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
    }, tokens);
    var tokenStr = flattenToken(mergedToken);
    var overrideTokenStr = flattenToken(override);
    var cachedToken = useGlobalCache("token", [salt, theme.id, tokenStr, overrideTokenStr], function() {
      var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken$1(mergedToken, override, theme, formatToken2);
      var tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      recordCleanToken(tokenKey);
      var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
      mergedDerivativeToken._hashId = hashId;
      return [mergedDerivativeToken, hashId];
    }, function(cache) {
      cleanTokenStyle(cache[0]._tokenKey, instanceId);
    });
    return cachedToken;
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  function trim(value) {
    return value.trim();
  }
  function replace(value, pattern4, replacement) {
    return value.replace(pattern4, replacement);
  }
  function indexof(value, search2) {
    return value.indexOf(search2);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array4) {
    return array4.push(value), value;
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type4, props, children, length2, siblings) {
    return { value, root, parent, type: type4, props, children, line, column, length: length2, return: "", siblings };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type4) {
    switch (type4) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type4) {
    return trim(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
  }
  function whitespace$1(type4) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type4) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type4) {
    while (next())
      switch (character) {
        case type4:
          return position;
        case 34:
        case 39:
          if (type4 !== 34 && type4 !== 39)
            delimiter(character);
          break;
        case 40:
          if (type4 === 41)
            delimiter(type4);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type4, index2) {
    while (next())
      if (type4 + character === 47 + 10)
        break;
      else if (type4 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type4 = "";
    var props = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type4;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$1(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference = ruleset(characters2, root, parent, index2, offset, rules2, points, type4, props = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index2 = offset = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index2, offset, rules2, points, type4, props, children, length2, siblings) {
    var post = offset - 1;
    var rule = offset === 0 ? rules2 : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k2++] = z;
    return node(value, root, parent, offset === 0 ? RULESET : type4, props, children, length2, siblings);
  }
  function comment(value, root, parent, siblings) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root, parent, length2, siblings) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }
  function serialize(children, callback) {
    var output = "";
    for (var i = 0; i < children.length; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify$3(element, index2, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(",")))
          return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
  var CSS_FILE_STYLE = "_FILE_STYLE__";
  var cachePathMap;
  var fromCSSFile = true;
  function prepare() {
    if (!cachePathMap) {
      cachePathMap = {};
      if (canUseDom()) {
        var div2 = document.createElement("div");
        div2.className = ATTR_CACHE_MAP;
        div2.style.position = "fixed";
        div2.style.visibility = "hidden";
        div2.style.top = "-9999px";
        document.body.appendChild(div2);
        var content = getComputedStyle(div2).content || "";
        content = content.replace(/^"/, "").replace(/"$/, "");
        content.split(";").forEach(function(item) {
          var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path = _item$split2[0], hash = _item$split2[1];
          cachePathMap[path] = hash;
        });
        var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
        if (inlineMapStyle) {
          var _inlineMapStyle$paren;
          fromCSSFile = false;
          (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 ? void 0 : _inlineMapStyle$paren.removeChild(inlineMapStyle);
        }
        document.body.removeChild(div2);
      }
    }
  }
  function existPath(path) {
    prepare();
    return !!cachePathMap[path];
  }
  function getStyleAndHash(path) {
    var hash = cachePathMap[path];
    var styleStr = null;
    if (hash && canUseDom()) {
      if (fromCSSFile) {
        styleStr = CSS_FILE_STYLE;
      } else {
        var _style = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[path], '"]'));
        if (_style) {
          styleStr = _style.innerHTML;
        } else {
          delete cachePathMap[path];
        }
      }
    }
    return [styleStr, hash];
  }
  var isClientSide = canUseDom();
  var SKIP_CHECK = "_skip_check_";
  var MULTI_VALUE = "_multi_value_";
  function normalizeStyle(styleStr) {
    var serialized = serialize(compile(styleStr), stringify$3);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return _typeof(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key, hashId, hashPriority) {
    if (!hashId) {
      return key;
    }
    var hashClassName = ".".concat(hashId);
    var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
    var keys2 = key.split(",").map(function(k2) {
      var _firstPath$match;
      var fullPath = k2.trim().split(/\s+/);
      var firstPath = fullPath[0] || "";
      var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
      firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
      return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
    });
    return keys2.join(",");
  }
  var parseStyle = function parseStyle2(interpolation) {
    var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      root: true,
      parentSelectors: []
    }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
    var hashId = config2.hashId, layer = config2.layer;
    config2.path;
    var hashPriority = config2.hashPriority, _config$transformers = config2.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
    config2.linters;
    var styleStr = "";
    var effectStyle = {};
    function parseKeyframes(keyframes) {
      var animationName = keyframes.getName(hashId);
      if (!effectStyle[animationName]) {
        var _parseStyle = parseStyle2(keyframes.style, config2, {
          root: false,
          parentSelectors
        }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
        effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
      }
    }
    function flattenList(list) {
      var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      list.forEach(function(item) {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach(function(originStyle) {
      var style2 = typeof originStyle === "string" && !root ? {} : originStyle;
      if (typeof style2 === "string") {
        styleStr += "".concat(style2, "\n");
      } else if (style2._keyframe) {
        parseKeyframes(style2);
      } else {
        var mergedStyle = transformers.reduce(function(prev2, trans) {
          var _trans$visit;
          return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
        }, style2);
        Object.keys(mergedStyle).forEach(function(key) {
          var value = mergedStyle[key];
          if (_typeof(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            var subInjectHash = false;
            var mergedKey = key.trim();
            var nextRoot = false;
            if ((root || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else {
                mergedKey = injectSelectorHash(key, hashId, hashPriority);
              }
            } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            var _parseStyle3 = parseStyle2(value, config2, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
            }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
            effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
            styleStr += "".concat(mergedKey).concat(_parsedStr2);
          } else {
            let appendStyle = function(cssKey, cssValue) {
              var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
                return "-".concat(match2.toLowerCase());
              });
              var formatValue = cssValue;
              if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = "".concat(formatValue, "px");
              }
              if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += "".concat(styleName, ":").concat(formatValue, ";");
            };
            var _value;
            var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
            if (_typeof(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
              actualValue.forEach(function(item) {
                appendStyle(key, item);
              });
            } else {
              appendStyle(key, actualValue);
            }
          }
        });
      }
    });
    if (!root) {
      styleStr = "{".concat(styleStr, "}");
    } else if (layer && supportLayer()) {
      var layerCells = layer.split(",");
      var layerName = layerCells[layerCells.length - 1].trim();
      styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
      if (layerCells.length > 1) {
        styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path, styleStr) {
    return murmur2("".concat(path.join("%")).concat(styleStr));
  }
  function Empty$3() {
    return null;
  }
  function useStyleRegister(info2, styleFn) {
    var token2 = info2.token, path = info2.path, hashId = info2.hashId, layer = info2.layer, nonce = info2.nonce, clientOnly = info2.clientOnly, _info$order = info2.order, order = _info$order === void 0 ? 0 : _info$order;
    var _React$useContext = React__namespace.useContext(StyleContext$1), autoClear = _React$useContext.autoClear;
    _React$useContext.mock;
    var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache;
    var tokenKey = token2._tokenKey;
    var fullPath = [tokenKey].concat(_toConsumableArray(path));
    var isMergedClientSide = isClientSide;
    var _useGlobalCache = useGlobalCache(
      "style",
      fullPath,
      // Create cache if needed
      function() {
        var cachePath = fullPath.join("|");
        if (existPath(cachePath)) {
          var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
          if (inlineCacheStyleStr) {
            return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
          }
        }
        var styleObj = styleFn();
        var _parseStyle5 = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer,
          path: path.join("-"),
          transformers,
          linters
        }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
        var styleStr = normalizeStyle(parsedStyle);
        var styleId = uniqueHash(fullPath, styleStr);
        return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
      },
      // Remove cache if no need
      function(_ref2, fromHMR) {
        var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
        if ((fromHMR || autoClear) && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      },
      // Effect: Inject style here
      function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0];
        _ref5[1];
        var styleId = _ref5[2], effectStyle = _ref5[3];
        if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
          var mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: order
          };
          var nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          var _style = updateCSS(styleStr, styleId, mergedCSSConfig);
          _style[CSS_IN_JS_INSTANCE] = cache.instanceId;
          _style.setAttribute(ATTR_TOKEN, tokenKey);
          Object.keys(effectStyle).forEach(function(effectKey) {
            updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
          });
        }
      }
    ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
    return function(node2) {
      var styleNode;
      if (!ssrInline || isMergedClientSide || !defaultCache) {
        styleNode = /* @__PURE__ */ React__namespace.createElement(Empty$3, null);
      } else {
        var _ref6;
        styleNode = /* @__PURE__ */ React__namespace.createElement("style", _extends$7({}, (_ref6 = {}, _defineProperty$1(_ref6, ATTR_TOKEN, cachedTokenKey), _defineProperty$1(_ref6, ATTR_MARK, cachedStyleId), _ref6), {
          dangerouslySetInnerHTML: {
            __html: cachedStyleStr
          }
        }));
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, styleNode, node2);
    };
  }
  var Keyframe = /* @__PURE__ */ function() {
    function Keyframe2(name, style2) {
      _classCallCheck(this, Keyframe2);
      _defineProperty$1(this, "name", void 0);
      _defineProperty$1(this, "style", void 0);
      _defineProperty$1(this, "_keyframe", true);
      this.name = name;
      this.style = style2;
    }
    _createClass(Keyframe2, [{
      key: "getName",
      value: function getName2() {
        var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
      }
    }]);
    return Keyframe2;
  }();
  function noSplit(list) {
    list.notSplit = true;
    return list;
  }
  ({
    // Inset
    inset: ["top", "right", "bottom", "left"],
    insetBlock: ["top", "bottom"],
    insetBlockStart: ["top"],
    insetBlockEnd: ["bottom"],
    insetInline: ["left", "right"],
    insetInlineStart: ["left"],
    insetInlineEnd: ["right"],
    // Margin
    marginBlock: ["marginTop", "marginBottom"],
    marginBlockStart: ["marginTop"],
    marginBlockEnd: ["marginBottom"],
    marginInline: ["marginLeft", "marginRight"],
    marginInlineStart: ["marginLeft"],
    marginInlineEnd: ["marginRight"],
    // Padding
    paddingBlock: ["paddingTop", "paddingBottom"],
    paddingBlockStart: ["paddingTop"],
    paddingBlockEnd: ["paddingBottom"],
    paddingInline: ["paddingLeft", "paddingRight"],
    paddingInlineStart: ["paddingLeft"],
    paddingInlineEnd: ["paddingRight"],
    // Border
    borderBlock: noSplit(["borderTop", "borderBottom"]),
    borderBlockStart: noSplit(["borderTop"]),
    borderBlockEnd: noSplit(["borderBottom"]),
    borderInline: noSplit(["borderLeft", "borderRight"]),
    borderInlineStart: noSplit(["borderLeft"]),
    borderInlineEnd: noSplit(["borderRight"]),
    // Border width
    borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
    borderBlockStartWidth: ["borderTopWidth"],
    borderBlockEndWidth: ["borderBottomWidth"],
    borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
    borderInlineStartWidth: ["borderLeftWidth"],
    borderInlineEndWidth: ["borderRightWidth"],
    // Border style
    borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
    borderBlockStartStyle: ["borderTopStyle"],
    borderBlockEndStyle: ["borderBottomStyle"],
    borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
    borderInlineStartStyle: ["borderLeftStyle"],
    borderInlineEndStyle: ["borderRightStyle"],
    // Border color
    borderBlockColor: ["borderTopColor", "borderBottomColor"],
    borderBlockStartColor: ["borderTopColor"],
    borderBlockEndColor: ["borderBottomColor"],
    borderInlineColor: ["borderLeftColor", "borderRightColor"],
    borderInlineStartColor: ["borderLeftColor"],
    borderInlineEndColor: ["borderRightColor"],
    // Border radius
    borderStartStartRadius: ["borderTopLeftRadius"],
    borderStartEndRadius: ["borderTopRightRadius"],
    borderEndStartRadius: ["borderBottomLeftRadius"],
    borderEndEndRadius: ["borderBottomRightRadius"]
  });
  var IconContext = /* @__PURE__ */ React.createContext({});
  const Context$2 = IconContext;
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableRest();
  }
  function get(entity, path) {
    var current = entity;
    for (var i = 0; i < path.length; i += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path[i]];
    }
    return current;
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
    var clone;
    if (!entity && typeof path === "number") {
      clone = [];
    } else if (Array.isArray(entity)) {
      clone = _toConsumableArray(entity);
    } else {
      clone = _objectSpread2({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone[path][restPath[0]];
    } else {
      clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
    }
    return clone;
  }
  function set(entity, paths, value) {
    var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function isObject$1(obj) {
    return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
  }
  var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
  function merge$1() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var clone = createEmpty(sources[0]);
    sources.forEach(function(src) {
      function internalMerge(path, parentLoopSet) {
        var loopSet = new Set(parentLoopSet);
        var value = get(src, path);
        var isArr = Array.isArray(value);
        if (isArr || isObject$1(value)) {
          if (!loopSet.has(value)) {
            loopSet.add(value);
            var originValue = get(clone, path);
            if (isArr) {
              clone = set(clone, path, []);
            } else if (!originValue || _typeof(originValue) !== "object") {
              clone = set(clone, path, createEmpty(value));
            }
            keys(value).forEach(function(key) {
              internalMerge([].concat(_toConsumableArray(path), [key]), loopSet);
            });
          }
        } else {
          clone = set(clone, path, value);
        }
      }
      internalMerge([]);
    });
    return clone;
  }
  function noop$1() {
  }
  const WarningContext = /* @__PURE__ */ React__namespace.createContext({});
  const devUseWarning = () => {
    const noopWarning = () => {
    };
    noopWarning.deprecated = noop$1;
    return noopWarning;
  };
  const ValidateMessagesContext = /* @__PURE__ */ React.createContext(void 0);
  const enUS$1 = {
    // Options.jsx
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    // Pagination.jsx
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
  };
  var locale$3 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: true,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  };
  const locale$2 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  const TimePicker = locale$2;
  const locale$1 = {
    lang: Object.assign({
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"]
    }, locale$3),
    timePickerLocale: Object.assign({}, TimePicker)
  };
  const enUS = locale$1;
  const typeTemplate$1 = "${label} is not a valid ${type}";
  const localeValues = {
    locale: "en",
    Pagination: enUS$1,
    DatePicker: enUS,
    TimePicker,
    Calendar: enUS,
    global: {
      placeholder: "Please select"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand"
    },
    PageHeader: {
      back: "Back"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate$1,
          method: typeTemplate$1,
          array: typeTemplate$1,
          object: typeTemplate$1,
          number: typeTemplate$1,
          date: typeTemplate$1,
          boolean: typeTemplate$1,
          integer: typeTemplate$1,
          float: typeTemplate$1,
          regexp: typeTemplate$1,
          email: typeTemplate$1,
          url: typeTemplate$1,
          hex: typeTemplate$1
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    Image: {
      preview: "Preview"
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh"
    },
    ColorPicker: {
      presetEmpty: "Empty"
    }
  };
  const defaultLocale = localeValues;
  Object.assign({}, defaultLocale.Modal);
  let localeList = [];
  const generateLocale = () => localeList.reduce((merged, locale2) => Object.assign(Object.assign({}, merged), locale2), defaultLocale.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      const cloneLocale = Object.assign({}, newLocale);
      localeList.push(cloneLocale);
      generateLocale();
      return () => {
        localeList = localeList.filter((locale2) => locale2 !== cloneLocale);
        generateLocale();
      };
    }
    Object.assign({}, defaultLocale.Modal);
  }
  const LocaleContext = /* @__PURE__ */ React.createContext(void 0);
  const LocaleContext$1 = LocaleContext;
  const useLocale = (componentName, defaultLocale$1) => {
    const fullLocale = React__namespace.useContext(LocaleContext$1);
    const getLocale2 = React__namespace.useMemo(() => {
      var _a;
      const locale2 = defaultLocale$1 || defaultLocale[componentName];
      const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
    }, [componentName, defaultLocale$1, fullLocale]);
    const getLocaleCode = React__namespace.useMemo(() => {
      const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
      if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
        return defaultLocale.locale;
      }
      return localeCode;
    }, [fullLocale]);
    return [getLocale2, getLocaleCode];
  };
  const useLocale$1 = useLocale;
  const ANT_MARK = "internalMark";
  const LocaleProvider = (props) => {
    const {
      locale: locale2 = {},
      children,
      _ANT_MARK__
    } = props;
    React__namespace.useEffect(() => {
      const clearLocale = changeConfirmLocale(locale2 && locale2.Modal);
      return clearLocale;
    }, [locale2]);
    const getMemoizedContextValue = React__namespace.useMemo(() => Object.assign(Object.assign({}, locale2), {
      exist: true
    }), [locale2]);
    return /* @__PURE__ */ React__namespace.createElement(LocaleContext$1.Provider, {
      value: getMemoizedContextValue
    }, children);
  };
  const LocaleProvider$1 = LocaleProvider;
  function bound01(n2, max) {
    if (isOnePointZero(n2)) {
      n2 = "100%";
    }
    var isPercent3 = isPercentage(n2);
    n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
    if (isPercent3) {
      n2 = parseInt(String(n2 * max), 10) / 100;
    }
    if (Math.abs(n2 - max) < 1e-6) {
      return 1;
    }
    if (max === 360) {
      n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
    } else {
      n2 = n2 % max / parseFloat(String(max));
    }
    return n2;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n2) {
    return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
  }
  function isPercentage(n2) {
    return typeof n2 === "string" && n2.indexOf("%") !== -1;
  }
  function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }
    return a;
  }
  function convertToPercentage(n2) {
    if (n2 <= 1) {
      return "".concat(Number(n2) * 100, "%");
    }
    return n2;
  }
  function pad2(c2) {
    return c2.length === 1 ? "0" + c2 : String(c2);
  }
  function rgbToRgb(r, g2, b2) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g2, 255) * 255,
      b: bound01(b2, 255) * 255
    };
  }
  function rgbToHsl(r, g2, b2) {
    r = bound01(r, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r, g2, b2);
    var min = Math.min(r, g2, b2);
    var h2 = 0;
    var s = 0;
    var l2 = (max + min) / 2;
    if (max === min) {
      s = 0;
      h2 = 0;
    } else {
      var d2 = max - min;
      s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
      switch (max) {
        case r:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r) / d2 + 2;
          break;
        case b2:
          h2 = (r - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s, l: l2 };
  }
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p2 + (q2 - p2) * (6 * t2);
    }
    if (t2 < 1 / 2) {
      return q2;
    }
    if (t2 < 2 / 3) {
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    }
    return p2;
  }
  function hslToRgb$1(h2, s, l2) {
    var r;
    var g2;
    var b2;
    h2 = bound01(h2, 360);
    s = bound01(s, 100);
    l2 = bound01(l2, 100);
    if (s === 0) {
      g2 = l2;
      b2 = l2;
      r = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
      var p2 = 2 * l2 - q2;
      r = hue2rgb(p2, q2, h2 + 1 / 3);
      g2 = hue2rgb(p2, q2, h2);
      b2 = hue2rgb(p2, q2, h2 - 1 / 3);
    }
    return { r: r * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHsv(r, g2, b2) {
    r = bound01(r, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r, g2, b2);
    var min = Math.min(r, g2, b2);
    var h2 = 0;
    var v2 = max;
    var d2 = max - min;
    var s = max === 0 ? 0 : d2 / max;
    if (max === min) {
      h2 = 0;
    } else {
      switch (max) {
        case r:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r) / d2 + 2;
          break;
        case b2:
          h2 = (r - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s, v: v2 };
  }
  function hsvToRgb(h2, s, v2) {
    h2 = bound01(h2, 360) * 6;
    s = bound01(s, 100);
    v2 = bound01(v2, 100);
    var i = Math.floor(h2);
    var f2 = h2 - i;
    var p2 = v2 * (1 - s);
    var q2 = v2 * (1 - f2 * s);
    var t2 = v2 * (1 - (1 - f2) * s);
    var mod = i % 6;
    var r = [v2, q2, p2, p2, t2, v2][mod];
    var g2 = [t2, v2, v2, q2, p2, p2][mod];
    var b2 = [p2, p2, t2, v2, v2, q2][mod];
    return { r: r * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHex(r, g2, b2, allow3Char) {
    var hex2 = [
      pad2(Math.round(r).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16))
    ];
    if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
    }
    return hex2.join("");
  }
  function rgbaToHex(r, g2, b2, a, allow4Char) {
    var hex2 = [
      pad2(Math.round(r).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16)),
      pad2(convertDecimalToHex(a))
    ];
    if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
    }
    return hex2.join("");
  }
  function convertDecimalToHex(d2) {
    return Math.round(parseFloat(d2) * 255).toString(16);
  }
  function convertHexToDecimal(h2) {
    return parseIntFromHex(h2) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  }
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v2 = null;
    var l2 = null;
    var ok = false;
    var format2 = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v2 = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v2);
        ok = true;
        format2 = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l2 = convertToPercentage(color.l);
        rgb = hslToRgb$1(color.h, s, l2);
        ok = true;
        format2 = "hsl";
      }
      if (Object.prototype.hasOwnProperty.call(color, "a")) {
        a = color.a;
      }
    }
    a = boundAlpha(a);
    return {
      ok,
      format: color.format || format2,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a
    };
  }
  var CSS_INTEGER$1 = "[-\\+]?\\d+%?";
  var CSS_NUMBER$1 = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT$1 = "(?:".concat(CSS_NUMBER$1, ")|(?:").concat(CSS_INTEGER$1, ")");
  var PERMISSIVE_MATCH3$1 = "[\\s|\\(]+(".concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")\\s*\\)?");
  var PERMISSIVE_MATCH4$1 = "[\\s|\\(]+(".concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")[,|\\s]+(").concat(CSS_UNIT$1, ")\\s*\\)?");
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT$1),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3$1),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4$1),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3$1),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4$1),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3$1),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4$1),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
      return false;
    }
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match2 = matchers.rgb.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3] };
    }
    match2 = matchers.rgba.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
    }
    match2 = matchers.hsl.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3] };
    }
    match2 = matchers.hsla.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
    }
    match2 = matchers.hsv.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3] };
    }
    match2 = matchers.hsva.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
    }
    match2 = matchers.hex8.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        a: convertHexToDecimal(match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex6.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        format: named ? "name" : "hex"
      };
    }
    match2 = matchers.hex4.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        a: convertHexToDecimal(match2[4] + match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex3.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
  }
  var TinyColor = (
    /** @class */
    function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R;
        var G;
        var B;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.isMonochrome = function() {
        var s = this.toHsl().s;
        return s === 0;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s = Math.round(hsv.s * 100);
        var v2 = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toHexShortString = function(allowShortChar) {
        if (allowShortChar === void 0) {
          allowShortChar = false;
        }
        return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r = Math.round(this.r);
        var g2 = Math.round(this.g);
        var b2 = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x) {
          return "".concat(Math.round(bound01(x, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x) {
          return Math.round(bound01(x, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
          var _b = _a[_i], key = _b[0], value = _b[1];
          if (hex2 === value) {
            return key;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p2 = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s = hsv.s;
        var v2 = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        var alpha = fg.a + bg.a * (1 - fg.a);
        return new TinyColor2({
          r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
          g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
          b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
          a: alpha
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n2) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n2;
        for (var i = 1; i < n2; i++) {
          result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }()
  );
  var hueStep = 2;
  var saturationStep = 0.16;
  var saturationStep2 = 0.05;
  var brightnessStep1 = 0.05;
  var brightnessStep2 = 0.15;
  var lightColorCount = 5;
  var darkColorCount = 4;
  var darkColorMap = [{
    index: 7,
    opacity: 0.15
  }, {
    index: 6,
    opacity: 0.25
  }, {
    index: 5,
    opacity: 0.3
  }, {
    index: 5,
    opacity: 0.45
  }, {
    index: 5,
    opacity: 0.65
  }, {
    index: 5,
    opacity: 0.85
  }, {
    index: 4,
    opacity: 0.9
  }, {
    index: 3,
    opacity: 0.95
  }, {
    index: 2,
    opacity: 0.97
  }, {
    index: 1,
    opacity: 0.98
  }];
  function toHsv(_ref) {
    var r = _ref.r, g2 = _ref.g, b2 = _ref.b;
    var hsv = rgbToHsv(r, g2, b2);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v
    };
  }
  function toHex(_ref2) {
    var r = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
    return "#".concat(rgbToHex(r, g2, b2, false));
  }
  function mix(rgb1, rgb2, amount) {
    var p2 = amount / 100;
    var rgb = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b
    };
    return rgb;
  }
  function getHue(hsv, i, light) {
    var hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    var saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i;
    } else if (i === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Number(saturation.toFixed(2));
  }
  function getValue$1(hsv, i, light) {
    var value;
    if (light) {
      value = hsv.v + brightnessStep1 * i;
    } else {
      value = hsv.v - brightnessStep2 * i;
    }
    if (value > 1) {
      value = 1;
    }
    return Number(value.toFixed(2));
  }
  function generate$1(color) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var patterns = [];
    var pColor = inputToRGB(color);
    for (var i = lightColorCount; i > 0; i -= 1) {
      var hsv = toHsv(pColor);
      var colorString = toHex(inputToRGB({
        h: getHue(hsv, i, true),
        s: getSaturation(hsv, i, true),
        v: getValue$1(hsv, i, true)
      }));
      patterns.push(colorString);
    }
    patterns.push(toHex(pColor));
    for (var _i = 1; _i <= darkColorCount; _i += 1) {
      var _hsv = toHsv(pColor);
      var _colorString = toHex(inputToRGB({
        h: getHue(_hsv, _i),
        s: getSaturation(_hsv, _i),
        v: getValue$1(_hsv, _i)
      }));
      patterns.push(_colorString);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(function(_ref3) {
        var index2 = _ref3.index, opacity = _ref3.opacity;
        var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
        return darkColorString;
      });
    }
    return patterns;
  }
  var presetPrimaryColors = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
  };
  var presetPalettes = {};
  var presetDarkPalettes = {};
  Object.keys(presetPrimaryColors).forEach(function(key) {
    presetPalettes[key] = generate$1(presetPrimaryColors[key]);
    presetPalettes[key].primary = presetPalettes[key][5];
    presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
      theme: "dark",
      backgroundColor: "#141414"
    });
    presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
  });
  var blue = presetPalettes.blue;
  const genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  const genControlHeight$1 = genControlHeight;
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
      sizeXL: sizeUnit * (sizeStep + 4),
      sizeLG: sizeUnit * (sizeStep + 2),
      sizeMD: sizeUnit * (sizeStep + 1),
      sizeMS: sizeUnit * sizeStep,
      size: sizeUnit * sizeStep,
      sizeSM: sizeUnit * (sizeStep - 1),
      sizeXS: sizeUnit * (sizeStep - 2),
      sizeXXS: sizeUnit * (sizeStep - 3)
      // 4
    };
  }
  const defaultPresetColors = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
    // Color
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    // Font
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
    fontSize: 14,
    // Line
    lineWidth: 1,
    lineType: "solid",
    // Motion
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    // Radius
    borderRadius: 6,
    // Size
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    // Control Base
    controlHeight: 32,
    // zIndex
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    // Image
    opacityImage: 1,
    // Wireframe
    wireframe: false,
    // Motion
    motion: true
  });
  const seedToken$1 = seedToken;
  function genColorMapToken(seed, _ref) {
    let {
      generateColorPalettes: generateColorPalettes2,
      generateNeutralColorPalettes: generateNeutralColorPalettes2
    } = _ref;
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    const colorLink = seed.colorLink || seed.colorInfo;
    const linkColors = generateColorPalettes2(colorLink);
    return Object.assign(Object.assign({}, neutralColors), {
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorLinkHover: linkColors[4],
      colorLink: linkColors[6],
      colorLinkActive: linkColors[7],
      colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
      colorWhite: "#fff"
    });
  }
  const genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  const genRadius$1 = genRadius;
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return Object.assign({
      // motion
      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
      // line
      lineWidthBold: lineWidth + 1
    }, genRadius$1(borderRadius));
  }
  const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
  const getSolidColor = (baseColor, brightness) => {
    const instance = new TinyColor(baseColor);
    return instance.darken(brightness).toHexString();
  };
  const generateColorPalettes = (baseColor) => {
    const colors = generate$1(baseColor);
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[4],
      6: colors[5],
      7: colors[6],
      8: colors[4],
      9: colors[5],
      10: colors[6]
      // 8: colors[7],
      // 9: colors[8],
      // 10: colors[9],
    };
  };
  const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor$1(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
      colorFill: getAlphaColor$1(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
      colorBgLayout: getSolidColor(colorBgBase, 4),
      colorBgContainer: getSolidColor(colorBgBase, 0),
      colorBgElevated: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
      colorBgBlur: "transparent",
      colorBorder: getSolidColor(colorBgBase, 15),
      colorBorderSecondary: getSolidColor(colorBgBase, 6)
    };
  };
  function getFontSizes(base) {
    const fontSizes = new Array(10).fill(null).map((_, index2) => {
      const i = index2 - 1;
      const baseSize = base * Math.pow(2.71828, i / 5);
      const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base;
    return fontSizes.map((size) => {
      const height = size + 8;
      return {
        size,
        lineHeight: height / size
      };
    });
  }
  const genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    return {
      fontSizeSM: fontSizes[0],
      fontSize: fontSizes[1],
      fontSizeLG: fontSizes[2],
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight: lineHeights[1],
      lineHeightLG: lineHeights[2],
      lineHeightSM: lineHeights[0],
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  const genFontMapToken$1 = genFontMapToken;
  function derivative(token2) {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = generate$1(token2[colorKey]);
      return new Array(10).fill(1).reduce((prev2, _, i) => {
        prev2[`${colorKey}-${i + 1}`] = colors[i];
        prev2[`${colorKey}${i + 1}`] = colors[i];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = Object.assign(Object.assign({}, prev2), cur);
      return prev2;
    }, {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    })), genFontMapToken$1(token2.fontSize)), genSizeMapToken(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
  }
  const defaultTheme = createTheme(derivative);
  const defaultConfig = {
    token: seedToken$1,
    override: {
      override: seedToken$1
    },
    hashed: true
  };
  const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
  const defaultIconPrefixCls = "anticon";
  const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `ant-${suffixCls}` : "ant";
  };
  const ConfigContext = /* @__PURE__ */ React__namespace.createContext({
    // We provide a default function for Context without provider
    getPrefixCls: defaultGetPrefixCls,
    iconPrefixCls: defaultIconPrefixCls
  });
  const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
  function getStyle$1(globalPrefixCls2, theme) {
    const variables = {};
    const formatColor = (color, updater) => {
      let clone = color.clone();
      clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
      return clone.toRgbString();
    };
    const fillColor = (colorVal, type4) => {
      const baseColor = new TinyColor(colorVal);
      const colorPalettes = generate$1(baseColor.toRgbString());
      variables[`${type4}-color`] = formatColor(baseColor);
      variables[`${type4}-color-disabled`] = colorPalettes[1];
      variables[`${type4}-color-hover`] = colorPalettes[4];
      variables[`${type4}-color-active`] = colorPalettes[6];
      variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
      variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
      variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
    };
    if (theme.primaryColor) {
      fillColor(theme.primaryColor, "primary");
      const primaryColor = new TinyColor(theme.primaryColor);
      const primaryColors = generate$1(primaryColor.toRgbString());
      primaryColors.forEach((color, index2) => {
        variables[`primary-${index2 + 1}`] = color;
      });
      variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
      const primaryActiveColor = new TinyColor(primaryColors[0]);
      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
    }
    if (theme.successColor) {
      fillColor(theme.successColor, "success");
    }
    if (theme.warningColor) {
      fillColor(theme.warningColor, "warning");
    }
    if (theme.errorColor) {
      fillColor(theme.errorColor, "error");
    }
    if (theme.infoColor) {
      fillColor(theme.infoColor, "info");
    }
    const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
    return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
  }
  function registerTheme(globalPrefixCls2, theme) {
    const style2 = getStyle$1(globalPrefixCls2, theme);
    if (canUseDom()) {
      updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
    }
  }
  const DisabledContext = /* @__PURE__ */ React__namespace.createContext(false);
  const DisabledContextProvider = (_ref) => {
    let {
      children,
      disabled
    } = _ref;
    const originDisabled = React__namespace.useContext(DisabledContext);
    return /* @__PURE__ */ React__namespace.createElement(DisabledContext.Provider, {
      value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
    }, children);
  };
  const DisabledContext$1 = DisabledContext;
  const SizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const SizeContextProvider = (_ref) => {
    let {
      children,
      size
    } = _ref;
    const originSize = React__namespace.useContext(SizeContext);
    return /* @__PURE__ */ React__namespace.createElement(SizeContext.Provider, {
      value: size || originSize
    }, children);
  };
  const SizeContext$1 = SizeContext;
  function useConfig() {
    const componentDisabled = React.useContext(DisabledContext$1);
    const componentSize = React.useContext(SizeContext$1);
    return {
      componentDisabled,
      componentSize
    };
  }
  const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
  const version$1 = "5.10.3";
  function isStableColor(color) {
    return color >= 0 && color <= 255;
  }
  function getAlphaColor(frontColor, backgroundColor) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new TinyColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new TinyColor(backgroundColor).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r = Math.round((fR - bR * (1 - fA)) / fA);
      const g2 = Math.round((fG - bG * (1 - fA)) / fA);
      const b2 = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r) && isStableColor(g2) && isStableColor(b2)) {
        return new TinyColor({
          r,
          g: g2,
          b: b2,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new TinyColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  var __rest$q = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function formatToken(derivativeToken) {
    const {
      override
    } = derivativeToken, restToken = __rest$q(derivativeToken, ["override"]);
    const overrideTokens = Object.assign({}, override);
    Object.keys(seedToken$1).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    if (mergedToken.motion === false) {
      const fastDuration = "0s";
      mergedToken.motionDurationFast = fastDuration;
      mergedToken.motionDurationMid = fastDuration;
      mergedToken.motionDurationSlow = fastDuration;
    }
    const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
      // ============== Background ============== //
      colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
      // ============== Split ============== //
      colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
      // ============== Text ============== //
      colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
      // Font
      fontSizeIcon: mergedToken.fontSizeSM,
      // Line
      lineWidthFocus: mergedToken.lineWidth * 4,
      // Control
      lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
      // Checkbox size and expand icon size
      controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), overrideTokens);
    return aliasToken;
  }
  var __rest$p = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const getComputedToken2 = (originToken, overrideToken, theme) => {
    const derivativeToken = theme.getDerivativeToken(originToken);
    const {
      override
    } = overrideToken, components = __rest$p(overrideToken, ["override"]);
    let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
      override
    });
    mergedDerivativeToken = formatToken(mergedDerivativeToken);
    if (components) {
      Object.entries(components).forEach((_ref) => {
        let [key, value] = _ref;
        const {
          theme: componentTheme
        } = value, componentTokens = __rest$p(value, ["theme"]);
        let mergedComponentToken = componentTokens;
        if (componentTheme) {
          mergedComponentToken = getComputedToken2(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
            override: componentTokens
          }, componentTheme);
        }
        mergedDerivativeToken[key] = mergedComponentToken;
      });
    }
    return mergedDerivativeToken;
  };
  function useToken() {
    const {
      token: rootDesignToken,
      hashed,
      theme,
      override
    } = React.useContext(DesignTokenContext);
    const salt = `${version$1}-${hashed || ""}`;
    const mergedTheme = theme || defaultTheme;
    const [token2, hashId] = useCacheToken(mergedTheme, [seedToken$1, rootDesignToken], {
      salt,
      override,
      getComputedToken: getComputedToken2,
      // formatToken will not be consumed after 1.15.0 with getComputedToken.
      // But token will break if @ant-design/cssinjs is under 1.15.0 without it
      formatToken
    });
    return [mergedTheme, token2, hashed ? hashId : ""];
  }
  function useEvent(callback) {
    var fnRef = React__namespace.useRef();
    fnRef.current = callback;
    var memoFn = React__namespace.useCallback(function() {
      var _fnRef$current;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
    }, []);
    return memoFn;
  }
  function useSafeState(defaultValue) {
    var destroyRef = React__namespace.useRef(false);
    var _React$useState = React__namespace.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
    React__namespace.useEffect(function() {
      destroyRef.current = false;
      return function() {
        destroyRef.current = true;
      };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
      if (ignoreDestroy && destroyRef.current) {
        return;
      }
      setValue(updater);
    }
    return [value, safeSetState];
  }
  function hasValue$1(value) {
    return value !== void 0;
  }
  function useMergedState(defaultStateValue, option) {
    var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
    var _useState = useSafeState(function() {
      if (hasValue$1(value)) {
        return value;
      } else if (hasValue$1(defaultValue)) {
        return typeof defaultValue === "function" ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      }
    }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
    var mergedValue = value !== void 0 ? value : innerValue;
    var postMergedValue = postState ? postState(mergedValue) : mergedValue;
    var onChangeFn = useEvent(onChange);
    var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
    useLayoutUpdateEffect(function() {
      var prev2 = prevValue[0];
      if (innerValue !== prev2) {
        onChangeFn(innerValue, prev2);
      }
    }, [prevValue]);
    useLayoutUpdateEffect(function() {
      if (!hasValue$1(value)) {
        setInnerValue(value);
      }
    }, [value]);
    var triggerChange = useEvent(function(updater, ignoreDestroy) {
      setInnerValue(updater, ignoreDestroy);
      setPrevValue([mergedValue], ignoreDestroy);
    });
    return [postMergedValue, triggerChange];
  }
  const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
    const unitWidth = width / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = outerRadius * 1 / Math.sqrt(2);
    const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
    const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
    const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
    return {
      pointerEvents: "none",
      width,
      height: width,
      overflow: "hidden",
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width,
        height: width / 2,
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
        },
        content: '""'
      },
      "&::after": {
        content: '""',
        position: "absolute",
        width: shadowWidth,
        height: shadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${innerRadius}px 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      }
    };
  };
  const textEllipsis = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  };
  const resetComponent = function(token2) {
    let needInheritFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return {
      boxSizing: "border-box",
      margin: 0,
      padding: 0,
      color: token2.colorText,
      fontSize: token2.fontSize,
      // font-variant: @font-variant-base;
      lineHeight: token2.lineHeight,
      listStyle: "none",
      // font-feature-settings: @font-feature-settings-base;
      fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
    };
  };
  const resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  const clearFix = () => ({
    // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/21864
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  const genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      [`&:active,
  &:hover`]: {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      // https://github.com/ant-design/ant-design/issues/22503
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  const genCommonStyle = (token2, componentPrefixCls) => {
    const {
      fontFamily,
      fontSize
    } = token2;
    const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    return {
      [rootPrefixSelector]: {
        fontFamily,
        fontSize,
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        },
        [rootPrefixSelector]: {
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          }
        }
      }
    };
  };
  const genFocusOutline = (token2) => ({
    outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
  });
  const genFocusStyle = (token2) => ({
    "&:focus-visible": Object.assign({}, genFocusOutline(token2))
  });
  const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
  let recording = true;
  function merge() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    if (!enableStatistic) {
      return Object.assign.apply(Object, [{}].concat(objs));
    }
    recording = false;
    const ret = {};
    objs.forEach((obj) => {
      const keys2 = Object.keys(obj);
      keys2.forEach((key) => {
        Object.defineProperty(ret, key, {
          configurable: true,
          enumerable: true,
          get: () => obj[key]
        });
      });
    });
    recording = true;
    return ret;
  }
  const statistic = {};
  function noop() {
  }
  function statisticToken(token2) {
    let tokenKeys2;
    let proxy = token2;
    let flush = noop;
    if (enableStatistic) {
      tokenKeys2 = /* @__PURE__ */ new Set();
      proxy = new Proxy(token2, {
        get(obj, prop) {
          if (recording) {
            tokenKeys2.add(prop);
          }
          return obj[prop];
        }
      });
      flush = (componentName, componentToken) => {
        var _a;
        statistic[componentName] = {
          global: Array.from(tokenKeys2),
          component: Object.assign(Object.assign({}, (_a = statistic[componentName]) === null || _a === void 0 ? void 0 : _a.component), componentToken)
        };
      };
    }
    return {
      token: proxy,
      keys: tokenKeys2,
      flush
    };
  }
  const useResetIconStyle = (iconPrefixCls, csp) => {
    const [theme, token2] = useToken();
    return useStyleRegister({
      theme,
      token: token2,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls],
      nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
    }, () => [{
      [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
        [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
          display: "block"
        }
      })
    }]);
  };
  const useStyle$e = useResetIconStyle;
  function genComponentStyleHook(componentName, styleFn, getDefaultToken) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
    const [component] = cells;
    const concatComponent = cells.join("-");
    return (prefixCls) => {
      const [theme, token2, hashId] = useToken();
      const {
        getPrefixCls,
        iconPrefixCls,
        csp
      } = React.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const sharedConfig = {
        theme,
        token: token2,
        hashId,
        nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
        clientOnly: options.clientOnly,
        // antd is always at top of styles
        order: options.order || -999
      };
      useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
        clientOnly: false,
        path: ["Shared", rootPrefixCls]
      }), () => [{
        // Link
        "&": genLinkStyle(token2)
      }]);
      useStyle$e(iconPrefixCls, csp);
      return [useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
        path: [concatComponent, prefixCls, iconPrefixCls]
      }), () => {
        const {
          token: proxyToken,
          flush
        } = statisticToken(token2);
        const customComponentToken = Object.assign({}, token2[component]);
        if (options.deprecatedTokens) {
          const {
            deprecatedTokens
          } = options;
          deprecatedTokens.forEach((_ref) => {
            let [oldTokenKey, newTokenKey] = _ref;
            var _a;
            if ((customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey]) || (customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[newTokenKey])) {
              (_a = customComponentToken[newTokenKey]) !== null && _a !== void 0 ? _a : customComponentToken[newTokenKey] = customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey];
            }
          });
        }
        const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(merge(proxyToken, customComponentToken !== null && customComponentToken !== void 0 ? customComponentToken : {})) : getDefaultToken;
        const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), customComponentToken);
        const componentCls = `.${prefixCls}`;
        const mergedToken = merge(proxyToken, {
          componentCls,
          prefixCls,
          iconCls: `.${iconPrefixCls}`,
          antCls: `.${rootPrefixCls}`
        }, mergedComponentToken);
        const styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls,
          overrideComponentToken: customComponentToken
        });
        flush(component, mergedComponentToken);
        return [options.resetStyle === false ? null : genCommonStyle(token2, prefixCls), styleInterpolation];
      }), hashId];
    };
  }
  const genSubStyleComponent = (componentName, styleFn, getDefaultToken, options) => {
    const useStyle2 = genComponentStyleHook(componentName, styleFn, getDefaultToken, Object.assign({
      resetStyle: false,
      // Sub Style should default after root one
      order: -998
    }, options));
    const StyledComponent = (_ref2) => {
      let {
        prefixCls
      } = _ref2;
      useStyle2(prefixCls);
      return null;
    };
    return StyledComponent;
  };
  function genPresetColor(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}1`];
      const lightBorderColor = token2[`${colorKey}3`];
      const darkColor = token2[`${colorKey}6`];
      const textColor = token2[`${colorKey}7`];
      return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      }));
    }, {});
  }
  function useTheme(theme, parentTheme) {
    const themeConfig = theme || {};
    const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
    return useMemo(() => {
      if (!theme) {
        return parentTheme;
      }
      const mergedComponents = Object.assign({}, parentThemeConfig.components);
      Object.keys(theme.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
      });
      return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
        token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
        components: mergedComponents
      });
    }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
      const nextTheme = next2[index2];
      return !isEqual(prevTheme, nextTheme, true);
    }));
  }
  var _excluded$H = ["children"];
  var Context$1 = /* @__PURE__ */ React__namespace.createContext({});
  function MotionProvider(_ref) {
    var children = _ref.children, props = _objectWithoutProperties$8(_ref, _excluded$H);
    return /* @__PURE__ */ React__namespace.createElement(Context$1.Provider, {
      value: props
    }, children);
  }
  var DomWrapper = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper2, _React$Component);
    var _super = _createSuper(DomWrapper2);
    function DomWrapper2() {
      _classCallCheck(this, DomWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass(DomWrapper2, [{
      key: "render",
      value: function render2() {
        return this.props.children;
      }
    }]);
    return DomWrapper2;
  }(React__namespace.Component);
  var STATUS_NONE = "none";
  var STATUS_APPEAR = "appear";
  var STATUS_ENTER = "enter";
  var STATUS_LEAVE = "leave";
  var STEP_NONE = "none";
  var STEP_PREPARE = "prepare";
  var STEP_START = "start";
  var STEP_ACTIVE = "active";
  var STEP_ACTIVATED = "end";
  var STEP_PREPARED = "prepared";
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
    prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
    prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
    prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
    return prefixes;
  }
  function getVendorPrefixes(domSupport, win) {
    var prefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    if (domSupport) {
      if (!("AnimationEvent" in win)) {
        delete prefixes.animationend.animation;
      }
      if (!("TransitionEvent" in win)) {
        delete prefixes.transitionend.transition;
      }
    }
    return prefixes;
  }
  var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
  var style$1 = {};
  if (canUseDom()) {
    var _document$createEleme = document.createElement("div");
    style$1 = _document$createEleme.style;
  }
  var prefixedEventNames = {};
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    }
    var prefixMap = vendorPrefixes[eventName];
    if (prefixMap) {
      var stylePropList = Object.keys(prefixMap);
      var len = stylePropList.length;
      for (var i = 0; i < len; i += 1) {
        var styleProp = stylePropList[i];
        if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style$1) {
          prefixedEventNames[eventName] = prefixMap[styleProp];
          return prefixedEventNames[eventName];
        }
      }
    }
    return "";
  }
  var internalAnimationEndName = getVendorPrefixedEventName("animationend");
  var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
  var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
  var animationEndName = internalAnimationEndName || "animationend";
  var transitionEndName = internalTransitionEndName || "transitionend";
  function getTransitionName$1(transitionName, transitionType) {
    if (!transitionName)
      return null;
    if (_typeof(transitionName) === "object") {
      var type4 = transitionType.replace(/-\w/g, function(match2) {
        return match2[1].toUpperCase();
      });
      return transitionName[type4];
    }
    return "".concat(transitionName, "-").concat(transitionType);
  }
  const useDomMotionEvents = function(callback) {
    var cacheElementRef = React.useRef();
    var callbackRef = React.useRef(callback);
    callbackRef.current = callback;
    var onInternalMotionEnd = React__namespace.useCallback(function(event) {
      callbackRef.current(event);
    }, []);
    function removeMotionEvents(element) {
      if (element) {
        element.removeEventListener(transitionEndName, onInternalMotionEnd);
        element.removeEventListener(animationEndName, onInternalMotionEnd);
      }
    }
    function patchMotionEvents(element) {
      if (cacheElementRef.current && cacheElementRef.current !== element) {
        removeMotionEvents(cacheElementRef.current);
      }
      if (element && element !== cacheElementRef.current) {
        element.addEventListener(transitionEndName, onInternalMotionEnd);
        element.addEventListener(animationEndName, onInternalMotionEnd);
        cacheElementRef.current = element;
      }
    }
    React__namespace.useEffect(function() {
      return function() {
        removeMotionEvents(cacheElementRef.current);
      };
    }, []);
    return [patchMotionEvents, removeMotionEvents];
  };
  var useIsomorphicLayoutEffect = canUseDom() ? React.useLayoutEffect : React.useEffect;
  const useNextFrame = function() {
    var nextFrameRef = React__namespace.useRef(null);
    function cancelNextFrame() {
      wrapperRaf.cancel(nextFrameRef.current);
    }
    function nextFrame(callback) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      cancelNextFrame();
      var nextFrameId = wrapperRaf(function() {
        if (delay <= 1) {
          callback({
            isCanceled: function isCanceled() {
              return nextFrameId !== nextFrameRef.current;
            }
          });
        } else {
          nextFrame(callback, delay - 1);
        }
      });
      nextFrameRef.current = nextFrameId;
    }
    React__namespace.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [nextFrame, cancelNextFrame];
  };
  var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
  var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
  var SkipStep = false;
  var DoStep = true;
  function isActive(step) {
    return step === STEP_ACTIVE || step === STEP_ACTIVATED;
  }
  const useStepQueue = function(status, prepareOnly, callback) {
    var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
    var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
    function startQueue() {
      setStep(STEP_PREPARE, true);
    }
    var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    useIsomorphicLayoutEffect(function() {
      if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
        var index2 = STEP_QUEUE.indexOf(step);
        var nextStep = STEP_QUEUE[index2 + 1];
        var result = callback(step);
        if (result === SkipStep) {
          setStep(nextStep, true);
        } else if (nextStep) {
          nextFrame(function(info2) {
            function doNext() {
              if (info2.isCanceled())
                return;
              setStep(nextStep, true);
            }
            if (result === true) {
              doNext();
            } else {
              Promise.resolve(result).then(doNext);
            }
          });
        }
      }
    }, [status, step]);
    React__namespace.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [startQueue, step];
  };
  function useStatus(supportMotion, visible, getElement, _ref) {
    var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
    var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
    var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
    var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
    var mountedRef = React.useRef(false);
    var deadlineRef = React.useRef(null);
    function getDomElement() {
      return getElement();
    }
    var activeRef = React.useRef(false);
    function updateMotionEndStatus() {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
    function onInternalMotionEnd(event) {
      var element = getDomElement();
      if (event && !event.deadline && event.target !== element) {
        return;
      }
      var currentActive = activeRef.current;
      var canEnd;
      if (status === STATUS_APPEAR && currentActive) {
        canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
      } else if (status === STATUS_ENTER && currentActive) {
        canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
      } else if (status === STATUS_LEAVE && currentActive) {
        canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
      }
      if (status !== STATUS_NONE && currentActive && canEnd !== false) {
        updateMotionEndStatus();
      }
    }
    var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
    var getEventHandlers = function getEventHandlers2(targetStatus) {
      var _ref2, _ref3, _ref4;
      switch (targetStatus) {
        case STATUS_APPEAR:
          return _ref2 = {}, _defineProperty$1(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$1(_ref2, STEP_START, onAppearStart), _defineProperty$1(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
        case STATUS_ENTER:
          return _ref3 = {}, _defineProperty$1(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$1(_ref3, STEP_START, onEnterStart), _defineProperty$1(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
        case STATUS_LEAVE:
          return _ref4 = {}, _defineProperty$1(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$1(_ref4, STEP_START, onLeaveStart), _defineProperty$1(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
        default:
          return {};
      }
    };
    var eventHandlers = React__namespace.useMemo(function() {
      return getEventHandlers(status);
    }, [status]);
    var _useStepQueue = useStepQueue(status, !supportMotion, function(newStep) {
      if (newStep === STEP_PREPARE) {
        var onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }
      if (step in eventHandlers) {
        var _eventHandlers$step;
        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
      }
      if (step === STEP_ACTIVE) {
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(function() {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (step === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
    var active = isActive(step);
    activeRef.current = active;
    useIsomorphicLayoutEffect(function() {
      setAsyncVisible(visible);
      var isMounted = mountedRef.current;
      mountedRef.current = true;
      var nextStatus;
      if (!isMounted && visible && motionAppear) {
        nextStatus = STATUS_APPEAR;
      }
      if (isMounted && visible && motionEnter) {
        nextStatus = STATUS_ENTER;
      }
      if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
        nextStatus = STATUS_LEAVE;
      }
      var nextEventHandlers = getEventHandlers(nextStatus);
      if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
        setStatus(nextStatus);
        startStep();
      } else {
        setStatus(STATUS_NONE);
      }
    }, [visible]);
    React.useEffect(function() {
      if (
        // Cancel appear
        status === STATUS_APPEAR && !motionAppear || // Cancel enter
        status === STATUS_ENTER && !motionEnter || // Cancel leave
        status === STATUS_LEAVE && !motionLeave
      ) {
        setStatus(STATUS_NONE);
      }
    }, [motionAppear, motionEnter, motionLeave]);
    React.useEffect(function() {
      return function() {
        mountedRef.current = false;
        clearTimeout(deadlineRef.current);
      };
    }, []);
    var firstMountChangeRef = React__namespace.useRef(false);
    React.useEffect(function() {
      if (asyncVisible) {
        firstMountChangeRef.current = true;
      }
      if (asyncVisible !== void 0 && status === STATUS_NONE) {
        if (firstMountChangeRef.current || asyncVisible) {
          onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
        }
        firstMountChangeRef.current = true;
      }
    }, [asyncVisible, status]);
    var mergedStyle = style2;
    if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
      mergedStyle = _objectSpread2({
        transition: "none"
      }, mergedStyle);
    }
    return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
  }
  function genCSSMotion(config2) {
    var transitionSupport = config2;
    if (_typeof(config2) === "object") {
      transitionSupport = config2.transitionSupport;
    }
    function isSupportTransition(props, contextMotion) {
      return !!(props.motionName && transitionSupport && contextMotion !== false);
    }
    var CSSMotion2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
      var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
      var _React$useContext = React__namespace.useContext(Context$1), contextMotion = _React$useContext.motion;
      var supportMotion = isSupportTransition(props, contextMotion);
      var nodeRef = React.useRef();
      var wrapperNodeRef = React.useRef();
      function getDomElement() {
        try {
          return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
        } catch (e2) {
          return null;
        }
      }
      var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
      var renderedRef = React__namespace.useRef(mergedVisible);
      if (mergedVisible) {
        renderedRef.current = true;
      }
      var setNodeRef = React__namespace.useCallback(function(node2) {
        nodeRef.current = node2;
        fillRef(ref, node2);
      }, [ref]);
      var motionChildren;
      var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
        visible
      });
      if (!children) {
        motionChildren = null;
      } else if (status === STATUS_NONE) {
        if (mergedVisible) {
          motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
        } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: leavedClassName
          }), setNodeRef);
        } else if (forceRender || !removeOnLeave && !leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            style: {
              display: "none"
            }
          }), setNodeRef);
        } else {
          motionChildren = null;
        }
      } else {
        var _classNames;
        var statusSuffix;
        if (statusStep === STEP_PREPARE) {
          statusSuffix = "prepare";
        } else if (isActive(statusStep)) {
          statusSuffix = "active";
        } else if (statusStep === STEP_START) {
          statusSuffix = "start";
        }
        var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: classname(getTransitionName$1(motionName, status), (_classNames = {}, _defineProperty$1(_classNames, motionCls, motionCls && statusSuffix), _defineProperty$1(_classNames, motionName, typeof motionName === "string"), _classNames)),
          style: statusStyle
        }), setNodeRef);
      }
      if (/* @__PURE__ */ React__namespace.isValidElement(motionChildren) && supportRef(motionChildren)) {
        var _ref = motionChildren, originNodeRef = _ref.ref;
        if (!originNodeRef) {
          motionChildren = /* @__PURE__ */ React__namespace.cloneElement(motionChildren, {
            ref: setNodeRef
          });
        }
      }
      return /* @__PURE__ */ React__namespace.createElement(DomWrapper, {
        ref: wrapperNodeRef
      }, motionChildren);
    });
    CSSMotion2.displayName = "CSSMotion";
    return CSSMotion2;
  }
  const CSSMotion = genCSSMotion(supportTransition);
  var STATUS_ADD = "add";
  var STATUS_KEEP = "keep";
  var STATUS_REMOVE = "remove";
  var STATUS_REMOVED = "removed";
  function wrapKeyToObject(key) {
    var keyObj;
    if (key && _typeof(key) === "object" && "key" in key) {
      keyObj = key;
    } else {
      keyObj = {
        key
      };
    }
    return _objectSpread2(_objectSpread2({}, keyObj), {}, {
      key: String(keyObj.key)
    });
  }
  function parseKeys() {
    var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return keys2.map(wrapKeyToObject);
  }
  function diffKeys() {
    var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var list = [];
    var currentIndex = 0;
    var currentLen = currentKeys.length;
    var prevKeyObjects = parseKeys(prevKeys);
    var currentKeyObjects = parseKeys(currentKeys);
    prevKeyObjects.forEach(function(keyObj) {
      var hit = false;
      for (var i = currentIndex; i < currentLen; i += 1) {
        var currentKeyObj = currentKeyObjects[i];
        if (currentKeyObj.key === keyObj.key) {
          if (currentIndex < i) {
            list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
              return _objectSpread2(_objectSpread2({}, obj), {}, {
                status: STATUS_ADD
              });
            }));
            currentIndex = i;
          }
          list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
            status: STATUS_KEEP
          }));
          currentIndex += 1;
          hit = true;
          break;
        }
      }
      if (!hit) {
        list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
          status: STATUS_REMOVE
        }));
      }
    });
    if (currentIndex < currentLen) {
      list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
        return _objectSpread2(_objectSpread2({}, obj), {}, {
          status: STATUS_ADD
        });
      }));
    }
    var keys2 = {};
    list.forEach(function(_ref) {
      var key = _ref.key;
      keys2[key] = (keys2[key] || 0) + 1;
    });
    var duplicatedKeys = Object.keys(keys2).filter(function(key) {
      return keys2[key] > 1;
    });
    duplicatedKeys.forEach(function(matchKey) {
      list = list.filter(function(_ref2) {
        var key = _ref2.key, status = _ref2.status;
        return key !== matchKey || status !== STATUS_REMOVE;
      });
      list.forEach(function(node2) {
        if (node2.key === matchKey) {
          node2.status = STATUS_KEEP;
        }
      });
    });
    return list;
  }
  var _excluded$G = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$7 = ["status"];
  var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
  function genCSSMotionList(transitionSupport) {
    var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
    var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
      _inherits(CSSMotionList3, _React$Component);
      var _super = _createSuper(CSSMotionList3);
      function CSSMotionList3() {
        var _this;
        _classCallCheck(this, CSSMotionList3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$1(_assertThisInitialized(_this), "state", {
          keyEntities: []
        });
        _defineProperty$1(_assertThisInitialized(_this), "removeKey", function(removeKey) {
          var keyEntities = _this.state.keyEntities;
          var nextKeyEntities = keyEntities.map(function(entity) {
            if (entity.key !== removeKey)
              return entity;
            return _objectSpread2(_objectSpread2({}, entity), {}, {
              status: STATUS_REMOVED
            });
          });
          _this.setState({
            keyEntities: nextKeyEntities
          });
          return nextKeyEntities.filter(function(_ref) {
            var status = _ref.status;
            return status !== STATUS_REMOVED;
          }).length;
        });
        return _this;
      }
      _createClass(CSSMotionList3, [{
        key: "render",
        value: function render2() {
          var _this2 = this;
          var keyEntities = this.state.keyEntities;
          var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$8(_this$props, _excluded$G);
          var Component2 = component || React__namespace.Fragment;
          var motionProps = {};
          MOTION_PROP_NAMES.forEach(function(prop) {
            motionProps[prop] = restProps[prop];
            delete restProps[prop];
          });
          delete restProps.keys;
          return /* @__PURE__ */ React__namespace.createElement(Component2, restProps, keyEntities.map(function(_ref2, index2) {
            var status = _ref2.status, eventProps = _objectWithoutProperties$8(_ref2, _excluded2$7);
            var visible = status === STATUS_ADD || status === STATUS_KEEP;
            return /* @__PURE__ */ React__namespace.createElement(CSSMotion$1, _extends$7({}, motionProps, {
              key: eventProps.key,
              visible,
              eventProps,
              onVisibleChanged: function onVisibleChanged(changedVisible) {
                _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                  key: eventProps.key
                });
                if (!changedVisible) {
                  var restKeysCount = _this2.removeKey(eventProps.key);
                  if (restKeysCount === 0 && onAllRemoved) {
                    onAllRemoved();
                  }
                }
              }
            }), function(props, ref) {
              return children(_objectSpread2(_objectSpread2({}, props), {}, {
                index: index2
              }), ref);
            });
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(_ref3, _ref4) {
          var keys2 = _ref3.keys;
          var keyEntities = _ref4.keyEntities;
          var parsedKeyObjects = parseKeys(keys2);
          var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
          return {
            keyEntities: mixedKeyEntities.filter(function(entity) {
              var prevEntity = keyEntities.find(function(_ref5) {
                var key = _ref5.key;
                return entity.key === key;
              });
              if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                return false;
              }
              return true;
            })
          };
        }
      }]);
      return CSSMotionList3;
    }(React__namespace.Component);
    _defineProperty$1(CSSMotionList2, "defaultProps", {
      component: "div"
    });
    return CSSMotionList2;
  }
  const CSSMotionList = genCSSMotionList(supportTransition);
  function MotionWrapper(props) {
    const {
      children
    } = props;
    const [, token2] = useToken();
    const {
      motion: motion2
    } = token2;
    const needWrapMotionProviderRef = React__namespace.useRef(false);
    needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion2 === false;
    if (needWrapMotionProviderRef.current) {
      return /* @__PURE__ */ React__namespace.createElement(MotionProvider, {
        motion: motion2
      }, children);
    }
    return children;
  }
  const PropWarning = () => null;
  var __rest$o = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button"];
  const defaultPrefixCls = "ant";
  let globalPrefixCls;
  let globalIconPrefixCls;
  let globalTheme;
  function getGlobalPrefixCls() {
    return globalPrefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalIconPrefixCls || defaultIconPrefixCls;
  }
  function isLegacyTheme(theme) {
    return Object.keys(theme).some((key) => key.endsWith("Color"));
  }
  const setGlobalConfig = (_ref) => {
    let {
      prefixCls,
      iconPrefixCls,
      theme
    } = _ref;
    if (prefixCls !== void 0) {
      globalPrefixCls = prefixCls;
    }
    if (iconPrefixCls !== void 0) {
      globalIconPrefixCls = iconPrefixCls;
    }
    if (theme) {
      if (isLegacyTheme(theme)) {
        registerTheme(getGlobalPrefixCls(), theme);
      } else {
        globalTheme = theme;
      }
    }
  };
  const globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      return getGlobalPrefixCls();
    },
    getTheme: () => globalTheme
  });
  const ProviderChildren = (props) => {
    const {
      children,
      csp: customCsp,
      autoInsertSpaceInButton,
      alert,
      anchor,
      form,
      locale: locale2,
      componentSize,
      direction,
      space,
      virtual,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      popupOverflow,
      legacyLocale,
      parentContext,
      iconPrefixCls: customIconPrefixCls,
      theme,
      componentDisabled,
      segmented,
      statistic: statistic2,
      spin,
      calendar: calendar2,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      layout: layout2,
      list,
      mentions,
      modal,
      progress,
      result,
      slider,
      breadcrumb,
      menu,
      pagination,
      input,
      empty,
      badge,
      radio,
      rate,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      tabs,
      timeline,
      timePicker,
      upload,
      notification,
      tree,
      colorPicker,
      datePicker,
      flex,
      wave,
      warning: warningConfig
    } = props;
    const getPrefixCls = React__namespace.useCallback((suffixCls, customizePrefixCls) => {
      const {
        prefixCls
      } = props;
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    }, [parentContext.getPrefixCls, props.prefixCls]);
    const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
    const csp = customCsp || parentContext.csp;
    useStyle$e(iconPrefixCls, csp);
    const mergedTheme = useTheme(theme, parentContext.theme);
    const baseConfig = {
      csp,
      autoInsertSpaceInButton,
      alert,
      anchor,
      locale: locale2 || legacyLocale,
      direction,
      space,
      virtual,
      popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
      popupOverflow,
      getPrefixCls,
      iconPrefixCls,
      theme: mergedTheme,
      segmented,
      statistic: statistic2,
      spin,
      calendar: calendar2,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      input,
      layout: layout2,
      list,
      mentions,
      modal,
      progress,
      result,
      slider,
      breadcrumb,
      menu,
      pagination,
      empty,
      badge,
      radio,
      rate,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      tabs,
      timeline,
      timePicker,
      upload,
      notification,
      tree,
      colorPicker,
      datePicker,
      flex,
      wave,
      warning: warningConfig
    };
    const config2 = Object.assign({}, parentContext);
    Object.keys(baseConfig).forEach((key) => {
      if (baseConfig[key] !== void 0) {
        config2[key] = baseConfig[key];
      }
    });
    PASSED_PROPS.forEach((propName) => {
      const propValue = props[propName];
      if (propValue) {
        config2[propName] = propValue;
      }
    });
    const memoedConfig = useMemo(() => config2, config2, (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    });
    const memoIconContextValue = React__namespace.useMemo(() => ({
      prefixCls: iconPrefixCls,
      csp
    }), [iconPrefixCls, csp]);
    let childNode = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(PropWarning, {
      dropdownMatchSelectWidth
    }), children);
    const validateMessages = React__namespace.useMemo(() => {
      var _a, _b, _c, _d;
      return merge$1(((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
    }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
    if (Object.keys(validateMessages).length > 0) {
      childNode = /* @__PURE__ */ React__namespace.createElement(ValidateMessagesContext.Provider, {
        value: validateMessages
      }, childNode);
    }
    if (locale2) {
      childNode = /* @__PURE__ */ React__namespace.createElement(LocaleProvider$1, {
        locale: locale2,
        _ANT_MARK__: ANT_MARK
      }, childNode);
    }
    if (iconPrefixCls || csp) {
      childNode = /* @__PURE__ */ React__namespace.createElement(Context$2.Provider, {
        value: memoIconContextValue
      }, childNode);
    }
    if (componentSize) {
      childNode = /* @__PURE__ */ React__namespace.createElement(SizeContextProvider, {
        size: componentSize
      }, childNode);
    }
    childNode = /* @__PURE__ */ React__namespace.createElement(MotionWrapper, null, childNode);
    const memoTheme = React__namespace.useMemo(() => {
      const _a = mergedTheme || {}, {
        algorithm,
        token: token2,
        components
      } = _a, rest = __rest$o(_a, ["algorithm", "token", "components"]);
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
      const parsedComponents = {};
      Object.entries(components || {}).forEach((_ref2) => {
        let [componentName, componentToken] = _ref2;
        const parsedToken = Object.assign({}, componentToken);
        if ("algorithm" in parsedToken) {
          if (parsedToken.algorithm === true) {
            parsedToken.theme = themeObj;
          } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
            parsedToken.theme = createTheme(parsedToken.algorithm);
          }
          delete parsedToken.algorithm;
        }
        parsedComponents[componentName] = parsedToken;
      });
      const mergedToken = Object.assign(Object.assign({}, seedToken$1), token2);
      return Object.assign(Object.assign({}, rest), {
        theme: themeObj,
        token: mergedToken,
        components: parsedComponents,
        override: Object.assign({
          override: mergedToken
        }, parsedComponents)
      });
    }, [mergedTheme]);
    if (theme) {
      childNode = /* @__PURE__ */ React__namespace.createElement(DesignTokenContext.Provider, {
        value: memoTheme
      }, childNode);
    }
    if (memoedConfig.warning) {
      childNode = /* @__PURE__ */ React__namespace.createElement(WarningContext.Provider, {
        value: memoedConfig.warning
      }, childNode);
    }
    if (componentDisabled !== void 0) {
      childNode = /* @__PURE__ */ React__namespace.createElement(DisabledContextProvider, {
        disabled: componentDisabled
      }, childNode);
    }
    return /* @__PURE__ */ React__namespace.createElement(ConfigContext.Provider, {
      value: memoedConfig
    }, childNode);
  };
  const ConfigProvider = (props) => {
    const context2 = React__namespace.useContext(ConfigContext);
    const antLocale = React__namespace.useContext(LocaleContext$1);
    return /* @__PURE__ */ React__namespace.createElement(ProviderChildren, Object.assign({
      parentContext: context2,
      legacyLocale: antLocale
    }, props));
  };
  ConfigProvider.ConfigContext = ConfigContext;
  ConfigProvider.SizeContext = SizeContext$1;
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.useConfig = useConfig;
  Object.defineProperty(ConfigProvider, "SizeContext", {
    get: () => {
      return SizeContext$1;
    }
  });
  var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  const CheckCircleFilledSvg = CheckCircleFilled$2;
  function getRoot(ele) {
    var _ele$getRootNode;
    return ele === null || ele === void 0 ? void 0 : (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
  }
  function inShadow(ele) {
    return getRoot(ele) instanceof ShadowRoot;
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }
  function camelCase$1(input) {
    return input.replace(/-(.)/g, function(match2, g2) {
      return g2.toUpperCase();
    });
  }
  function warning$2(valid, message2) {
    warningOnce(valid, "[@ant-design/icons] ".concat(message2));
  }
  function isIconDefinition(target) {
    return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
  }
  function normalizeAttrs() {
    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.keys(attrs).reduce(function(acc, key) {
      var val = attrs[key];
      switch (key) {
        case "class":
          acc.className = val;
          delete acc.class;
          break;
        default:
          delete acc[key];
          acc[camelCase$1(key)] = val;
      }
      return acc;
    }, {});
  }
  function generate(node2, key, rootProps) {
    if (!rootProps) {
      return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2({
        key
      }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2(_objectSpread2({
      key
    }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  function getSecondaryColor(primaryColor) {
    return generate$1(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  var useInsertStyles = function useInsertStyles2(eleRef) {
    var _useContext = React.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
    var mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
    }
    React.useEffect(function() {
      var ele = eleRef.current;
      var shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-icons", {
        prepend: true,
        csp,
        attachTo: shadowRoot
      });
    }, []);
  };
  var _excluded$F = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
  var twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  };
  function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return _objectSpread2({}, twoToneColorPalette);
  }
  var IconBase = function IconBase2(props) {
    var icon2 = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$8(props, _excluded$F);
    var svgRef = React__namespace.useRef();
    var colors = twoToneColorPalette;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    useInsertStyles(svgRef);
    warning$2(isIconDefinition(icon2), "icon should be icon definiton, but got ".concat(icon2));
    if (!isIconDefinition(icon2)) {
      return null;
    }
    var target = icon2;
    if (target && typeof target.icon === "function") {
      target = _objectSpread2(_objectSpread2({}, target), {}, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
      className,
      onClick,
      style: style2,
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }, restProps), {}, {
      ref: svgRef
    }));
  };
  IconBase.displayName = "IconReact";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  const ReactIcon = IconBase;
  function setTwoToneColor(twoToneColor) {
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return ReactIcon.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    var colors = ReactIcon.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }
  var _excluded$E = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
  setTwoToneColor(blue.primary);
  var Icon$2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _classNames;
    var className = props.className, icon2 = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$8(props, _excluded$E);
    var _React$useContext = React__namespace.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
    var classString = classname(rootClassName, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(icon2.name), !!icon2.name), _defineProperty$1(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon2.name === "loading"), _classNames), className);
    var iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate ? {
      msTransform: "rotate(".concat(rotate, "deg)"),
      transform: "rotate(".concat(rotate, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return /* @__PURE__ */ React__namespace.createElement("span", _extends$7({
      role: "img",
      "aria-label": icon2.name
    }, restProps, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }), /* @__PURE__ */ React__namespace.createElement(ReactIcon, {
      icon: icon2,
      primaryColor,
      secondaryColor,
      style: svgStyle
    }));
  });
  Icon$2.displayName = "AntdIcon";
  Icon$2.getTwoToneColor = getTwoToneColor;
  Icon$2.setTwoToneColor = setTwoToneColor;
  const AntdIcon = Icon$2;
  var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: CheckCircleFilledSvg
    }));
  };
  const CheckCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CheckCircleFilled);
  var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
  const CloseCircleFilledSvg = CloseCircleFilled$2;
  var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: CloseCircleFilledSvg
    }));
  };
  const CloseCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseCircleFilled);
  var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
  const CloseOutlinedSvg = CloseOutlined$2;
  var CloseOutlined = function CloseOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: CloseOutlinedSvg
    }));
  };
  const CloseOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseOutlined);
  var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
  var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: ExclamationCircleFilledSvg
    }));
  };
  const ExclamationCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(ExclamationCircleFilled);
  var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  const InfoCircleFilledSvg = InfoCircleFilled$2;
  var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: InfoCircleFilledSvg
    }));
  };
  const InfoCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(InfoCircleFilled);
  var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
  var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
  var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
  var ariaPrefix = "aria-";
  var dataPrefix = "data-";
  function match(key, prefix) {
    return key.indexOf(prefix) === 0;
  }
  function pickAttrs(props) {
    var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = _objectSpread2({}, ariaOnly);
    }
    var attrs = {};
    Object.keys(props).forEach(function(key) {
      if (
        // Aria
        mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)
      ) {
        attrs[key] = props[key];
      }
    });
    return attrs;
  }
  const {
    isValidElement
  } = React__namespace;
  function isFragment(child) {
    return child && isValidElement(child) && child.type === React__namespace.Fragment;
  }
  function replaceElement(element, replacement, props) {
    if (!isValidElement(element)) {
      return replacement;
    }
    return /* @__PURE__ */ React__namespace.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
  }
  function cloneElement(element, props) {
    return replaceElement(element, element, props);
  }
  function isWindow(obj) {
    return obj !== null && obj !== void 0 && obj === obj.window;
  }
  function getScroll(target, top) {
    var _a, _b;
    if (typeof window === "undefined") {
      return 0;
    }
    const method4 = top ? "scrollTop" : "scrollLeft";
    let result = 0;
    if (isWindow(target)) {
      result = target[top ? "pageYOffset" : "pageXOffset"];
    } else if (target instanceof Document) {
      result = target.documentElement[method4];
    } else if (target instanceof HTMLElement) {
      result = target[method4];
    } else if (target) {
      result = target[method4];
    }
    if (target && !isWindow(target) && typeof result !== "number") {
      result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
    }
    return result;
  }
  function easeInOutCubic(t2, b2, c2, d2) {
    const cc = c2 - b2;
    t2 /= d2 / 2;
    if (t2 < 1) {
      return cc / 2 * t2 * t2 * t2 + b2;
    }
    return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
  }
  function scrollTo(y) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      getContainer: getContainer3 = () => window,
      callback,
      duration = 450
    } = options;
    const container = getContainer3();
    const scrollTop = getScroll(container, true);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        wrapperRaf(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    wrapperRaf(frameFunc);
  }
  var KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35,
    // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36,
    // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37,
    // also NUM_WEST
    /**
     * UP
     */
    UP: 38,
    // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39,
    // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40,
    // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45,
    // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46,
    // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63,
    // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91,
    // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    // needs localization
    /**
     * DASH
     */
    DASH: 189,
    // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187,
    // needs localization
    /**
     * COMMA
     */
    COMMA: 188,
    // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190,
    // needs localization
    /**
     * SLASH
     */
    SLASH: 191,
    // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192,
    // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222,
    // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220,
    // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229,
    // ======================== Function ========================
    /**
     * whether text and modified key is entered at the same time.
     */
    isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
      var keyCode = e2.keyCode;
      if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
      keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
        return false;
      }
      switch (keyCode) {
        case KeyCode.ALT:
        case KeyCode.CAPS_LOCK:
        case KeyCode.CONTEXT_MENU:
        case KeyCode.CTRL:
        case KeyCode.DOWN:
        case KeyCode.END:
        case KeyCode.ESC:
        case KeyCode.HOME:
        case KeyCode.INSERT:
        case KeyCode.LEFT:
        case KeyCode.MAC_FF_META:
        case KeyCode.META:
        case KeyCode.NUMLOCK:
        case KeyCode.NUM_CENTER:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAUSE:
        case KeyCode.PRINT_SCREEN:
        case KeyCode.RIGHT:
        case KeyCode.SHIFT:
        case KeyCode.UP:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_RIGHT:
          return false;
        default:
          return true;
      }
    },
    /**
     * whether character is entered.
     */
    isCharacterKey: function isCharacterKey(keyCode) {
      if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
        return true;
      }
      if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
        return true;
      }
      if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
        return true;
      }
      if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
        return true;
      }
      switch (keyCode) {
        case KeyCode.SPACE:
        case KeyCode.QUESTION_MARK:
        case KeyCode.NUM_PLUS:
        case KeyCode.NUM_MINUS:
        case KeyCode.NUM_PERIOD:
        case KeyCode.NUM_DIVISION:
        case KeyCode.SEMICOLON:
        case KeyCode.DASH:
        case KeyCode.EQUALS:
        case KeyCode.COMMA:
        case KeyCode.PERIOD:
        case KeyCode.SLASH:
        case KeyCode.APOSTROPHE:
        case KeyCode.SINGLE_QUOTE:
        case KeyCode.OPEN_SQUARE_BRACKET:
        case KeyCode.BACKSLASH:
        case KeyCode.CLOSE_SQUARE_BRACKET:
          return true;
        default:
          return false;
      }
    }
  };
  var Notify = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, style2 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
    var mergedHovering = forcedHovering || hovering;
    var onInternalClose = function onInternalClose2() {
      onNoticeClose(eventKey);
    };
    var onCloseKeyDown = function onCloseKeyDown2(e2) {
      if (e2.key === "Enter" || e2.code === "Enter" || e2.keyCode === KeyCode.ENTER) {
        onInternalClose();
      }
    };
    React__namespace.useEffect(function() {
      if (!mergedHovering && duration > 0) {
        var timeout = setTimeout(function() {
          onInternalClose();
        }, duration * 1e3);
        return function() {
          clearTimeout(timeout);
        };
      }
    }, [duration, mergedHovering, times]);
    var noticePrefixCls = "".concat(prefixCls, "-notice");
    return /* @__PURE__ */ React__namespace.createElement("div", _extends$7({}, divProps, {
      ref,
      className: classname(noticePrefixCls, className, _defineProperty$1({}, "".concat(noticePrefixCls, "-closable"), closable)),
      style: style2,
      onMouseEnter: function onMouseEnter(e2) {
        var _divProps$onMouseEnte;
        setHovering(true);
        divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e2);
      },
      onMouseLeave: function onMouseLeave(e2) {
        var _divProps$onMouseLeav;
        setHovering(false);
        divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e2);
      },
      onClick
    }), /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(noticePrefixCls, "-content")
    }, content), closable && /* @__PURE__ */ React__namespace.createElement("a", {
      tabIndex: 0,
      className: "".concat(noticePrefixCls, "-close"),
      onKeyDown: onCloseKeyDown,
      onClick: function onClick2(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        onInternalClose();
      }
    }, closeIcon));
  });
  var NotificationContext = /* @__PURE__ */ React.createContext({});
  var NotificationProvider = function NotificationProvider2(_ref) {
    var children = _ref.children, classNames = _ref.classNames;
    return /* @__PURE__ */ React.createElement(NotificationContext.Provider, {
      value: {
        classNames
      }
    }, children);
  };
  var DEFAULT_OFFSET$1 = 8;
  var DEFAULT_THRESHOLD = 3;
  var DEFAULT_GAP = 16;
  var useStack = function useStack2(config2) {
    var result = {
      offset: DEFAULT_OFFSET$1,
      threshold: DEFAULT_THRESHOLD,
      gap: DEFAULT_GAP
    };
    if (config2 && _typeof(config2) === "object") {
      var _config$offset, _config$threshold, _config$gap;
      result.offset = (_config$offset = config2.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET$1;
      result.threshold = (_config$threshold = config2.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
      result.gap = (_config$gap = config2.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
    }
    return [!!config2, result];
  };
  var _excluded$D = ["className", "style", "classNames", "styles"];
  var NoticeList = function NoticeList2(props) {
    var _clsx;
    var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style2 = props.style, motion2 = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
    var _useContext = React.useContext(NotificationContext), ctxCls = _useContext.classNames;
    var dictRef = React.useRef({});
    var _useState = React.useState(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
    var _useState3 = React.useState([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
    var keys2 = configList.map(function(config2) {
      return {
        config: config2,
        key: String(config2.key)
      };
    });
    var _useStack = useStack(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
    var expanded = stack && (hoverKeys.length > 0 || keys2.length <= threshold);
    var placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
    React.useEffect(function() {
      if (stack && hoverKeys.length > 1) {
        setHoverKeys(function(prev2) {
          return prev2.filter(function(key) {
            return keys2.some(function(_ref) {
              var dataKey = _ref.key;
              return key === dataKey;
            });
          });
        });
      }
    }, [hoverKeys, keys2, stack]);
    React.useEffect(function() {
      var _keys;
      if (stack && dictRef.current[(_keys = keys2[keys2.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
        var _keys2;
        setLatestNotice(dictRef.current[(_keys2 = keys2[keys2.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
      }
    }, [keys2, stack]);
    return /* @__PURE__ */ React.createElement(CSSMotionList, _extends$7({
      key: placement,
      className: classname(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, (_clsx = {}, _defineProperty$1(_clsx, "".concat(prefixCls, "-stack"), !!stack), _defineProperty$1(_clsx, "".concat(prefixCls, "-stack-expanded"), expanded), _clsx)),
      style: style2,
      keys: keys2,
      motionAppear: true
    }, placementMotion, {
      onAllRemoved: function onAllRemoved() {
        onAllNoticeRemoved(placement);
      }
    }), function(_ref2, nodeRef) {
      var config2 = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
      var _ref3 = config2, key = _ref3.key, times = _ref3.times;
      var strKey = String(key);
      var _ref4 = config2, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties$8(_ref4, _excluded$D);
      var dataIndex = keys2.findIndex(function(item) {
        return item.key === strKey;
      });
      var stackStyle = {};
      if (stack) {
        var index2 = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
        var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
        if (index2 > 0) {
          var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
          stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
          var verticalOffset = 0;
          for (var i = 0; i < index2; i++) {
            var _dictRef$current$keys;
            verticalOffset += ((_dictRef$current$keys = dictRef.current[keys2[keys2.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
          }
          var transformY = (expanded ? verticalOffset : index2 * offset) * (placement.startsWith("top") ? 1 : -1);
          var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset * 2 * (index2 < 3 ? index2 : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
          stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
        } else {
          stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
        }
      }
      return /* @__PURE__ */ React.createElement("div", {
        ref: nodeRef,
        className: classname("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
        onMouseEnter: function onMouseEnter() {
          return setHoverKeys(function(prev2) {
            return prev2.includes(strKey) ? prev2 : [].concat(_toConsumableArray(prev2), [strKey]);
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setHoverKeys(function(prev2) {
            return prev2.filter(function(k2) {
              return k2 !== strKey;
            });
          });
        }
      }, /* @__PURE__ */ React.createElement(Notify, _extends$7({}, restConfig, {
        ref: function ref(node2) {
          if (dataIndex > -1) {
            dictRef.current[strKey] = node2;
          } else {
            delete dictRef.current[strKey];
          }
        },
        prefixCls,
        classNames: configClassNames,
        styles: configStyles,
        className: classname(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
        style: configStyle,
        times,
        key,
        eventKey: key,
        onNoticeClose,
        hovering: stack && hoverKeys.length > 0
      })));
    });
  };
  var Notifications = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion2 = props.motion, maxCount = props.maxCount, className = props.className, style2 = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications2 = props.renderNotifications;
    var _React$useState = React__namespace.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
    var onNoticeClose = function onNoticeClose2(key) {
      var _config$onClose;
      var config2 = configList.find(function(item) {
        return item.key === key;
      });
      config2 === null || config2 === void 0 || (_config$onClose = config2.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config2);
      setConfigList(function(list) {
        return list.filter(function(item) {
          return item.key !== key;
        });
      });
    };
    React__namespace.useImperativeHandle(ref, function() {
      return {
        open: function open2(config2) {
          setConfigList(function(list) {
            var clone = _toConsumableArray(list);
            var index2 = clone.findIndex(function(item) {
              return item.key === config2.key;
            });
            var innerConfig = _objectSpread2({}, config2);
            if (index2 >= 0) {
              var _list$index;
              innerConfig.times = (((_list$index = list[index2]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
              clone[index2] = innerConfig;
            } else {
              innerConfig.times = 0;
              clone.push(innerConfig);
            }
            if (maxCount > 0 && clone.length > maxCount) {
              clone = clone.slice(-maxCount);
            }
            return clone;
          });
        },
        close: function close2(key) {
          onNoticeClose(key);
        },
        destroy: function destroy2() {
          setConfigList([]);
        }
      };
    });
    var _React$useState3 = React__namespace.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements2 = _React$useState4[0], setPlacements = _React$useState4[1];
    React__namespace.useEffect(function() {
      var nextPlacements = {};
      configList.forEach(function(config2) {
        var _config$placement = config2.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
        if (placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
          nextPlacements[placement].push(config2);
        }
      });
      Object.keys(placements2).forEach(function(placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
      });
      setPlacements(nextPlacements);
    }, [configList]);
    var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
      setPlacements(function(originPlacements) {
        var clone = _objectSpread2({}, originPlacements);
        var list = clone[placement] || [];
        if (!list.length) {
          delete clone[placement];
        }
        return clone;
      });
    };
    var emptyRef = React__namespace.useRef(false);
    React__namespace.useEffect(function() {
      if (Object.keys(placements2).length > 0) {
        emptyRef.current = true;
      } else if (emptyRef.current) {
        onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
        emptyRef.current = false;
      }
    }, [placements2]);
    if (!container) {
      return null;
    }
    var placementList = Object.keys(placements2);
    return /* @__PURE__ */ ReactDOM__default.createPortal(/* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, placementList.map(function(placement) {
      var placementConfigList = placements2[placement];
      var list = /* @__PURE__ */ React__namespace.createElement(NoticeList, {
        key: placement,
        configList: placementConfigList,
        placement,
        prefixCls,
        className: className === null || className === void 0 ? void 0 : className(placement),
        style: style2 === null || style2 === void 0 ? void 0 : style2(placement),
        motion: motion2,
        onNoticeClose,
        onAllNoticeRemoved,
        stack
      });
      return renderNotifications2 ? renderNotifications2(list, {
        prefixCls,
        key: placement
      }) : list;
    })), container);
  });
  var _excluded$C = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
  var defaultGetContainer = function defaultGetContainer2() {
    return document.body;
  };
  var uniqueKey = 0;
  function mergeConfig() {
    var clone = {};
    for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
      objList[_key] = arguments[_key];
    }
    objList.forEach(function(obj) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          var val = obj[key];
          if (val !== void 0) {
            clone[key] = val;
          }
        });
      }
    });
    return clone;
  }
  function useNotification() {
    var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _rootConfig$getContai = rootConfig.getContainer, getContainer3 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion2 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style2 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications2 = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties$8(rootConfig, _excluded$C);
    var _React$useState = React__namespace.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
    var notificationsRef = React__namespace.useRef();
    var contextHolder = /* @__PURE__ */ React__namespace.createElement(Notifications, {
      container,
      ref: notificationsRef,
      prefixCls,
      motion: motion2,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack,
      renderNotifications: renderNotifications2
    });
    var _React$useState3 = React__namespace.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
    var api = React__namespace.useMemo(function() {
      return {
        open: function open2(config2) {
          var mergedConfig = mergeConfig(shareConfig, config2);
          if (mergedConfig.key === null || mergedConfig.key === void 0) {
            mergedConfig.key = "rc-notification-".concat(uniqueKey);
            uniqueKey += 1;
          }
          setTaskQueue(function(queue) {
            return [].concat(_toConsumableArray(queue), [{
              type: "open",
              config: mergedConfig
            }]);
          });
        },
        close: function close2(key) {
          setTaskQueue(function(queue) {
            return [].concat(_toConsumableArray(queue), [{
              type: "close",
              key
            }]);
          });
        },
        destroy: function destroy2() {
          setTaskQueue(function(queue) {
            return [].concat(_toConsumableArray(queue), [{
              type: "destroy"
            }]);
          });
        }
      };
    }, []);
    React__namespace.useEffect(function() {
      setContainer(getContainer3());
    });
    React__namespace.useEffect(function() {
      if (notificationsRef.current && taskQueue2.length) {
        taskQueue2.forEach(function(task) {
          switch (task.type) {
            case "open":
              notificationsRef.current.open(task.config);
              break;
            case "close":
              notificationsRef.current.close(task.key);
              break;
            case "destroy":
              notificationsRef.current.destroy();
              break;
          }
        });
        setTaskQueue(function(oriQueue) {
          return oriQueue.filter(function(task) {
            return !taskQueue2.includes(task);
          });
        });
      }
    }, [taskQueue2]);
    return [api, contextHolder];
  }
  var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  const LoadingOutlinedSvg = LoadingOutlined$2;
  var LoadingOutlined = function LoadingOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: LoadingOutlinedSvg
    }));
  };
  const LoadingOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(LoadingOutlined);
  const genMessageStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      boxShadow,
      colorText,
      colorSuccess,
      colorError,
      colorWarning,
      colorInfo,
      fontSizeLG,
      motionEaseInOutCirc,
      motionDurationSlow,
      marginXS,
      paddingXS,
      borderRadiusLG,
      zIndexPopup,
      // Custom token
      contentPadding,
      contentBg
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const messageMoveIn = new Keyframe("MessageMoveIn", {
      "0%": {
        padding: 0,
        transform: "translateY(-100%)",
        opacity: 0
      },
      "100%": {
        padding: paddingXS,
        transform: "translateY(0)",
        opacity: 1
      }
    });
    const messageMoveOut = new Keyframe("MessageMoveOut", {
      "0%": {
        maxHeight: token2.height,
        padding: paddingXS,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        padding: 0,
        opacity: 0
      }
    });
    const noticeStyle = {
      padding: paddingXS,
      textAlign: "center",
      [`${componentCls}-custom-content > ${iconCls}`]: {
        verticalAlign: "text-bottom",
        marginInlineEnd: marginXS,
        fontSize: fontSizeLG
      },
      [`${noticeCls}-content`]: {
        display: "inline-block",
        padding: contentPadding,
        background: contentBg,
        borderRadius: borderRadiusLG,
        boxShadow,
        pointerEvents: "all"
      },
      [`${componentCls}-success > ${iconCls}`]: {
        color: colorSuccess
      },
      [`${componentCls}-error > ${iconCls}`]: {
        color: colorError
      },
      [`${componentCls}-warning > ${iconCls}`]: {
        color: colorWarning
      },
      [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
        color: colorInfo
      }
    };
    return [
      // ============================ Holder ============================
      {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          color: colorText,
          position: "fixed",
          top: marginXS,
          width: "100%",
          pointerEvents: "none",
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: "forwards"
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: "running"
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: "running"
          },
          "&-rtl": {
            direction: "rtl",
            span: {
              direction: "rtl"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [componentCls]: {
          [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle)
        }
      },
      // ============================= Pure =============================
      {
        [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
          padding: 0,
          textAlign: "start"
        })
      }
    ];
  };
  const useStyle$d = genComponentStyleHook("Message", (token2) => {
    const combinedToken = merge(token2, {
      height: 150
    });
    return [genMessageStyle(combinedToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 10,
    contentBg: token2.colorBgElevated,
    contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
  }));
  var __rest$n = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const TypeIcon = {
    info: /* @__PURE__ */ React__namespace.createElement(InfoCircleFilled$1, null),
    success: /* @__PURE__ */ React__namespace.createElement(CheckCircleFilled$1, null),
    error: /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null),
    warning: /* @__PURE__ */ React__namespace.createElement(ExclamationCircleFilled$1, null),
    loading: /* @__PURE__ */ React__namespace.createElement(LoadingOutlined$1, null)
  };
  const PureContent = (_ref) => {
    let {
      prefixCls,
      type: type4,
      icon: icon2,
      children
    } = _ref;
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(`${prefixCls}-custom-content`, `${prefixCls}-${type4}`)
    }, icon2 || TypeIcon[type4], /* @__PURE__ */ React__namespace.createElement("span", null, children));
  };
  const PurePanel$6 = (props) => {
    const {
      prefixCls: staticPrefixCls,
      className,
      type: type4,
      icon: icon2,
      content
    } = props, restProps = __rest$n(props, ["prefixCls", "className", "type", "icon", "content"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const [, hashId] = useStyle$d(prefixCls);
    return /* @__PURE__ */ React__namespace.createElement(Notify, Object.assign({}, restProps, {
      prefixCls,
      className: classname(className, hashId, `${prefixCls}-notice-pure-panel`),
      eventKey: "pure",
      duration: null,
      content: /* @__PURE__ */ React__namespace.createElement(PureContent, {
        prefixCls,
        type: type4,
        icon: icon2
      }, content)
    }));
  };
  const PurePanel$7 = PurePanel$6;
  function getMotion$2(prefixCls, transitionName) {
    return {
      motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
    };
  }
  function wrapPromiseFn(openFn) {
    let closeFn;
    const closePromise = new Promise((resolve) => {
      closeFn = openFn(() => {
        resolve(true);
      });
    });
    const result = () => {
      closeFn === null || closeFn === void 0 ? void 0 : closeFn();
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  var __rest$m = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const DEFAULT_OFFSET = 8;
  const DEFAULT_DURATION = 3;
  const Wrapper = (_ref) => {
    let {
      children,
      prefixCls
    } = _ref;
    const [, hashId] = useStyle$d(prefixCls);
    return /* @__PURE__ */ React__namespace.createElement(NotificationProvider, {
      classNames: {
        list: hashId,
        notice: hashId
      }
    }, children);
  };
  const renderNotifications = (node2, _ref2) => {
    let {
      prefixCls,
      key
    } = _ref2;
    return /* @__PURE__ */ React__namespace.createElement(Wrapper, {
      prefixCls,
      key
    }, node2);
  };
  const Holder = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      top,
      prefixCls: staticPrefixCls,
      getContainer: staticGetContainer,
      maxCount,
      duration = DEFAULT_DURATION,
      rtl,
      transitionName,
      onAllRemoved
    } = props;
    const {
      getPrefixCls,
      getPopupContainer,
      message: message2
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const getStyle2 = () => ({
      left: "50%",
      transform: "translateX(-50%)",
      top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET
    });
    const getClassName = () => classname({
      [`${prefixCls}-rtl`]: rtl
    });
    const getNotificationMotion = () => getMotion$2(prefixCls, transitionName);
    const mergedCloseIcon = /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-close-x`
    }, /* @__PURE__ */ React__namespace.createElement(CloseOutlined$1, {
      className: `${prefixCls}-close-icon`
    }));
    const [api, holder] = useNotification({
      prefixCls,
      style: getStyle2,
      className: getClassName,
      motion: getNotificationMotion,
      closable: false,
      closeIcon: mergedCloseIcon,
      duration,
      getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
      maxCount,
      onAllRemoved,
      renderNotifications
    });
    React__namespace.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
      prefixCls,
      message: message2
    }));
    return holder;
  });
  let keyIndex = 0;
  function useInternalMessage(messageConfig) {
    const holderRef = React__namespace.useRef(null);
    devUseWarning();
    const wrapAPI = React__namespace.useMemo(() => {
      const close2 = (key) => {
        var _a;
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
      };
      const open2 = (config2) => {
        if (!holderRef.current) {
          const fakeResult = () => {
          };
          fakeResult.then = () => {
          };
          return fakeResult;
        }
        const {
          open: originOpen,
          prefixCls,
          message: message2
        } = holderRef.current;
        const noticePrefixCls = `${prefixCls}-notice`;
        const {
          content,
          icon: icon2,
          type: type4,
          key,
          className,
          style: style2,
          onClose
        } = config2, restConfig = __rest$m(config2, ["content", "icon", "type", "key", "className", "style", "onClose"]);
        let mergedKey = key;
        if (mergedKey === void 0 || mergedKey === null) {
          keyIndex += 1;
          mergedKey = `antd-message-${keyIndex}`;
        }
        return wrapPromiseFn((resolve) => {
          originOpen(Object.assign(Object.assign({}, restConfig), {
            key: mergedKey,
            content: /* @__PURE__ */ React__namespace.createElement(PureContent, {
              prefixCls,
              type: type4,
              icon: icon2
            }, content),
            placement: "top",
            className: classname(type4 && `${noticePrefixCls}-${type4}`, className, message2 === null || message2 === void 0 ? void 0 : message2.className),
            style: Object.assign(Object.assign({}, message2 === null || message2 === void 0 ? void 0 : message2.style), style2),
            onClose: () => {
              onClose === null || onClose === void 0 ? void 0 : onClose();
              resolve();
            }
          }));
          return () => {
            close2(mergedKey);
          };
        });
      };
      const destroy2 = (key) => {
        var _a;
        if (key !== void 0) {
          close2(key);
        } else {
          (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
        }
      };
      const clone = {
        open: open2,
        destroy: destroy2
      };
      const keys2 = ["info", "success", "warning", "error", "loading"];
      keys2.forEach((type4) => {
        const typeOpen2 = (jointContent, duration, onClose) => {
          let config2;
          if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
            config2 = jointContent;
          } else {
            config2 = {
              content: jointContent
            };
          }
          let mergedDuration;
          let mergedOnClose;
          if (typeof duration === "function") {
            mergedOnClose = duration;
          } else {
            mergedDuration = duration;
            mergedOnClose = onClose;
          }
          const mergedConfig = Object.assign(Object.assign({
            onClose: mergedOnClose,
            duration: mergedDuration
          }, config2), {
            type: type4
          });
          return open2(mergedConfig);
        };
        clone[type4] = typeOpen2;
      });
      return clone;
    }, []);
    return [wrapAPI, /* @__PURE__ */ React__namespace.createElement(Holder, Object.assign({
      key: "message-holder"
    }, messageConfig, {
      ref: holderRef
    }))];
  }
  function useMessage(messageConfig) {
    return useInternalMessage(messageConfig);
  }
  function _regeneratorRuntime$2() {
    _regeneratorRuntime$2 = function _regeneratorRuntime2() {
      return e2;
    };
    var t2, e2 = {}, r = Object.prototype, n2 = r.hasOwnProperty, o = Object.defineProperty || function(t3, e3, r2) {
      t3[e3] = r2.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c2 = i.asyncIterator || "@@asyncIterator", u2 = i.toStringTag || "@@toStringTag";
    function define(t3, e3, r2) {
      return Object.defineProperty(t3, e3, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t3[e3];
    }
    try {
      define({}, "");
    } catch (t3) {
      define = function define2(t4, e3, r2) {
        return t4[e3] = r2;
      };
    }
    function wrap(t3, e3, r2, n3) {
      var i2 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a2 = Object.create(i2.prototype), c3 = new Context2(n3 || []);
      return o(a2, "_invoke", {
        value: makeInvokeMethod(t3, r2, c3)
      }), a2;
    }
    function tryCatch(t3, e3, r2) {
      try {
        return {
          type: "normal",
          arg: t3.call(e3, r2)
        };
      } catch (t4) {
        return {
          type: "throw",
          arg: t4
        };
      }
    }
    e2.wrap = wrap;
    var h2 = "suspendedStart", l2 = "suspendedYield", f2 = "executing", s = "completed", y = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p2 = {};
    define(p2, a, function() {
      return this;
    });
    var d2 = Object.getPrototypeOf, v2 = d2 && d2(d2(values([])));
    v2 && v2 !== r && n2.call(v2, a) && (p2 = v2);
    var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
    function defineIteratorMethods(t3) {
      ["next", "throw", "return"].forEach(function(e3) {
        define(t3, e3, function(t4) {
          return this._invoke(e3, t4);
        });
      });
    }
    function AsyncIterator(t3, e3) {
      function invoke(r3, o2, i2, a2) {
        var c3 = tryCatch(t3[r3], t3, o2);
        if ("throw" !== c3.type) {
          var u3 = c3.arg, h3 = u3.value;
          return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e3.resolve(h3.__await).then(function(t4) {
            invoke("next", t4, i2, a2);
          }, function(t4) {
            invoke("throw", t4, i2, a2);
          }) : e3.resolve(h3).then(function(t4) {
            u3.value = t4, i2(u3);
          }, function(t4) {
            return invoke("throw", t4, i2, a2);
          });
        }
        a2(c3.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value(t4, n3) {
          function callInvokeWithMethodAndArg() {
            return new e3(function(e4, r3) {
              invoke(t4, n3, e4, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e3, r2, n3) {
      var o2 = h2;
      return function(i2, a2) {
        if (o2 === f2)
          throw new Error("Generator is already running");
        if (o2 === s) {
          if ("throw" === i2)
            throw a2;
          return {
            value: t2,
            done: true
          };
        }
        for (n3.method = i2, n3.arg = a2; ; ) {
          var c3 = n3.delegate;
          if (c3) {
            var u3 = maybeInvokeDelegate(c3, n3);
            if (u3) {
              if (u3 === y)
                continue;
              return u3;
            }
          }
          if ("next" === n3.method)
            n3.sent = n3._sent = n3.arg;
          else if ("throw" === n3.method) {
            if (o2 === h2)
              throw o2 = s, n3.arg;
            n3.dispatchException(n3.arg);
          } else
            "return" === n3.method && n3.abrupt("return", n3.arg);
          o2 = f2;
          var p3 = tryCatch(e3, r2, n3);
          if ("normal" === p3.type) {
            if (o2 = n3.done ? s : l2, p3.arg === y)
              continue;
            return {
              value: p3.arg,
              done: n3.done
            };
          }
          "throw" === p3.type && (o2 = s, n3.method = "throw", n3.arg = p3.arg);
        }
      };
    }
    function maybeInvokeDelegate(e3, r2) {
      var n3 = r2.method, o2 = e3.iterator[n3];
      if (o2 === t2)
        return r2.delegate = null, "throw" === n3 && e3.iterator["return"] && (r2.method = "return", r2.arg = t2, maybeInvokeDelegate(e3, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
      var i2 = tryCatch(o2, e3.iterator, r2.arg);
      if ("throw" === i2.type)
        return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
      var a2 = i2.arg;
      return a2 ? a2.done ? (r2[e3.resultName] = a2.value, r2.next = e3.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t2), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
    }
    function pushTryEntry(t3) {
      var e3 = {
        tryLoc: t3[0]
      };
      1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
    }
    function resetTryEntry(t3) {
      var e3 = t3.completion || {};
      e3.type = "normal", delete e3.arg, t3.completion = e3;
    }
    function Context2(t3) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t3.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(e3) {
      if (e3 || "" === e3) {
        var r2 = e3[a];
        if (r2)
          return r2.call(e3);
        if ("function" == typeof e3.next)
          return e3;
        if (!isNaN(e3.length)) {
          var o2 = -1, i2 = function next2() {
            for (; ++o2 < e3.length; )
              if (n2.call(e3, o2))
                return next2.value = e3[o2], next2.done = false, next2;
            return next2.value = t2, next2.done = true, next2;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof(e3) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g2, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
      var e3 = "function" == typeof t3 && t3.constructor;
      return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
    }, e2.mark = function(t3) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g2), t3;
    }, e2.awrap = function(t3) {
      return {
        __await: t3
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c2, function() {
      return this;
    }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r2, n3, o2, i2) {
      void 0 === i2 && (i2 = Promise);
      var a2 = new AsyncIterator(wrap(t3, r2, n3, o2), i2);
      return e2.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t4) {
        return t4.done ? t4.value : a2.next();
      });
    }, defineIteratorMethods(g2), define(g2, u2, "Generator"), define(g2, a, function() {
      return this;
    }), define(g2, "toString", function() {
      return "[object Generator]";
    }), e2.keys = function(t3) {
      var e3 = Object(t3), r2 = [];
      for (var n3 in e3)
        r2.push(n3);
      return r2.reverse(), function next2() {
        for (; r2.length; ) {
          var t4 = r2.pop();
          if (t4 in e3)
            return next2.value = t4, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, e2.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(e3) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3)
          for (var r2 in this)
            "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t2);
      },
      stop: function stop() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type)
          throw t3.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e3) {
        if (this.done)
          throw e3;
        var r2 = this;
        function handle(n3, o3) {
          return a2.type = "throw", a2.arg = e3, r2.next = n3, o3 && (r2.method = "next", r2.arg = t2), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc)
            return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c3 = n2.call(i2, "catchLoc"), u3 = n2.call(i2, "finallyLoc");
            if (c3 && u3) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            } else if (c3) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
            } else {
              if (!u3)
                throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t3, e3) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n2.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e3 && e3 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t3, a2.arg = e3, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      },
      complete: function complete(t3, e3) {
        if ("throw" === t3.type)
          throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y;
      },
      finish: function finish(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r2 = this.tryEntries[e3];
          if (r2.finallyLoc === t3)
            return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      },
      "catch": function _catch(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var r2 = this.tryEntries[e3];
          if (r2.tryLoc === t3) {
            var n3 = r2.completion;
            if ("throw" === n3.type) {
              var o2 = n3.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e3, r2, n3) {
        return this.delegate = {
          iterator: values(e3),
          resultName: r2,
          nextLoc: n3
        }, "next" === this.method && (this.arg = t2), y;
      }
    }, e2;
  }
  function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info2 = gen[key](arg);
      var value = info2.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info2.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$2(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var fullClone = _objectSpread2({}, ReactDOM__default__namespace);
  var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
  var createRoot;
  try {
    var mainVersion = Number((version || "").split(".")[0]);
    if (mainVersion >= 18) {
      createRoot = fullClone.createRoot;
    }
  } catch (e2) {
  }
  function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  var MARK = "__rc_react_root__";
  function modernRender(node2, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node2);
    container[MARK] = root;
  }
  function legacyRender(node2, container) {
    reactRender(node2, container);
  }
  function render(node2, container) {
    if (createRoot) {
      modernRender(node2, container);
      return;
    }
    legacyRender(node2, container);
  }
  function modernUnmount(_x) {
    return _modernUnmount.apply(this, arguments);
  }
  function _modernUnmount() {
    _modernUnmount = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee(container) {
      return _regeneratorRuntime$2().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Promise.resolve().then(function() {
                var _container$MARK;
                (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
                delete container[MARK];
              }));
            case 1:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return _modernUnmount.apply(this, arguments);
  }
  function legacyUnmount(container) {
    unmountComponentAtNode(container);
  }
  function unmount(_x2) {
    return _unmount.apply(this, arguments);
  }
  function _unmount() {
    _unmount = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee2(container) {
      return _regeneratorRuntime$2().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(createRoot !== void 0)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", modernUnmount(container));
            case 2:
              legacyUnmount(container);
            case 3:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return _unmount.apply(this, arguments);
  }
  const getTransitionName = (rootPrefixCls, motion2, transitionName) => {
    if (transitionName !== void 0) {
      return transitionName;
    }
    return `${rootPrefixCls}-${motion2}`;
  };
  const isVisible = function(element) {
    if (!element) {
      return false;
    }
    if (element instanceof Element) {
      if (element.offsetParent) {
        return true;
      }
      if (element.getBBox) {
        var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
        if (width || height) {
          return true;
        }
      }
      if (element.getBoundingClientRect) {
        var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
        if (_width || _height) {
          return true;
        }
      }
    }
    return false;
  };
  const genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary
    } = token2;
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${colorPrimary})`,
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
        // =================== Motion ===================
        "&.wave-motion-appear": {
          transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          },
          "&.wave-quick": {
            transition: [`box-shadow 0.3s ${token2.motionEaseInOut}`, `opacity 0.35s ${token2.motionEaseInOut}`].join(",")
          }
        }
      }
    };
  };
  const useStyle$c = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
  function isNotGrey(color) {
    const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
    if (match2 && match2[1] && match2[2] && match2[3]) {
      return !(match2[1] === match2[2] && match2[2] === match2[3]);
    }
    return true;
  }
  function isValidWaveColor(color) {
    return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
    color !== "transparent";
  }
  function getTargetWaveColor(node2) {
    const {
      borderTopColor,
      borderColor,
      backgroundColor
    } = getComputedStyle(node2);
    if (isValidWaveColor(borderTopColor)) {
      return borderTopColor;
    }
    if (isValidWaveColor(borderColor)) {
      return borderColor;
    }
    if (isValidWaveColor(backgroundColor)) {
      return backgroundColor;
    }
    return null;
  }
  const TARGET_CLS = "ant-wave-target";
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  const WaveEffect = (props) => {
    const {
      className,
      target,
      component
    } = props;
    const divRef = React__namespace.useRef(null);
    const [color, setWaveColor] = React__namespace.useState(null);
    const [borderRadius, setBorderRadius] = React__namespace.useState([]);
    const [left, setLeft] = React__namespace.useState(0);
    const [top, setTop] = React__namespace.useState(0);
    const [width, setWidth] = React__namespace.useState(0);
    const [height, setHeight] = React__namespace.useState(0);
    const [enabled, setEnabled] = React__namespace.useState(false);
    const waveStyle = {
      left,
      top,
      width,
      height,
      borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
    };
    if (color) {
      waveStyle["--wave-color"] = color;
    }
    function syncPos() {
      const nodeStyle = getComputedStyle(target);
      setWaveColor(getTargetWaveColor(target));
      const isStatic = nodeStyle.position === "static";
      const {
        borderLeftWidth,
        borderTopWidth
      } = nodeStyle;
      setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
      setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
      setWidth(target.offsetWidth);
      setHeight(target.offsetHeight);
      const {
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius
      } = nodeStyle;
      setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
    }
    React__namespace.useEffect(() => {
      if (target) {
        const id = wrapperRaf(() => {
          syncPos();
          setEnabled(true);
        });
        let resizeObserver2;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver2 = new ResizeObserver(syncPos);
          resizeObserver2.observe(target);
        }
        return () => {
          wrapperRaf.cancel(id);
          resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
        };
      }
    }, []);
    if (!enabled) {
      return null;
    }
    const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      visible: true,
      motionAppear: true,
      motionName: "wave-motion",
      motionDeadline: 5e3,
      onAppearEnd: (_, event) => {
        var _a;
        if (event.deadline || event.propertyName === "opacity") {
          const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
          unmount(holder).then(() => {
            holder === null || holder === void 0 ? void 0 : holder.remove();
          });
        }
        return false;
      }
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        ref: divRef,
        className: classname(className, {
          "wave-quick": isSmallComponent
        }, motionClassName),
        style: waveStyle
      });
    });
  };
  const showWaveEffect = (target, info2) => {
    var _a;
    const {
      component
    } = info2;
    if (component === "Checkbox" && !((_a = target.querySelector("input")) === null || _a === void 0 ? void 0 : _a.checked)) {
      return;
    }
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = "0px";
    holder.style.top = "0px";
    target === null || target === void 0 ? void 0 : target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
    render(/* @__PURE__ */ React__namespace.createElement(WaveEffect, Object.assign({}, info2, {
      target
    })), holder);
  };
  const showWaveEffect$1 = showWaveEffect;
  function useWave(nodeRef, className, component) {
    const {
      wave
    } = React__namespace.useContext(ConfigContext);
    const [, token2, hashId] = useToken();
    const showWave = useEvent((event) => {
      const node2 = nodeRef.current;
      if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node2) {
        return;
      }
      const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
      const {
        showEffect
      } = wave || {};
      (showEffect || showWaveEffect$1)(targetNode, {
        className,
        token: token2,
        component,
        event,
        hashId
      });
    });
    const rafId = React__namespace.useRef();
    const showDebounceWave = (event) => {
      wrapperRaf.cancel(rafId.current);
      rafId.current = wrapperRaf(() => {
        showWave(event);
      });
    };
    return showDebounceWave;
  }
  const Wave$1 = (props) => {
    const {
      children,
      disabled,
      component
    } = props;
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const containerRef = React.useRef(null);
    const prefixCls = getPrefixCls("wave");
    const [, hashId] = useStyle$c(prefixCls);
    const showWave = useWave(containerRef, classname(prefixCls, hashId), component);
    React.useEffect(() => {
      const node2 = containerRef.current;
      if (!node2 || node2.nodeType !== 1 || disabled) {
        return;
      }
      const onClick = (e2) => {
        if (!isVisible(e2.target) || // No need wave
        !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
          return;
        }
        showWave(e2);
      };
      node2.addEventListener("click", onClick, true);
      return () => {
        node2.removeEventListener("click", onClick, true);
      };
    }, [disabled]);
    if (!/* @__PURE__ */ React.isValidElement(children)) {
      return children !== null && children !== void 0 ? children : null;
    }
    const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
    return cloneElement(children, {
      ref
    });
  };
  const Wave$2 = Wave$1;
  const useSize = (customSize) => {
    const size = React.useContext(SizeContext$1);
    const mergedSize = React.useMemo(() => {
      if (!customSize) {
        return size;
      }
      if (typeof customSize === "string") {
        return customSize !== null && customSize !== void 0 ? customSize : size;
      }
      if (customSize instanceof Function) {
        return customSize(size);
      }
      return size;
    }, [customSize, size]);
    return mergedSize;
  };
  const useSize$1 = useSize;
  const SpaceCompactItemContext = /* @__PURE__ */ React__namespace.createContext(null);
  const useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = React__namespace.useContext(SpaceCompactItemContext);
    const compactItemClassnames = React__namespace.useMemo(() => {
      if (!compactItemContext) {
        return "";
      }
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return classname(`${prefixCls}-compact${separator}item`, {
        [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
      });
    }, [prefixCls, direction, compactItemContext]);
    return {
      compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
      compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
      compactItemClassnames
    };
  };
  const NoCompactStyle = (_ref) => {
    let {
      children
    } = _ref;
    return /* @__PURE__ */ React__namespace.createElement(SpaceCompactItemContext.Provider, {
      value: null
    }, children);
  };
  var __rest$l = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const GroupSizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const ButtonGroup$1 = (props) => {
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      size,
      className
    } = props, others = __rest$l(props, ["prefixCls", "size", "className"]);
    const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
    const [, , hashId] = useToken();
    let sizeCls = "";
    switch (size) {
      case "large":
        sizeCls = "lg";
        break;
      case "small":
        sizeCls = "sm";
        break;
    }
    const classes = classname(prefixCls, {
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, hashId);
    return /* @__PURE__ */ React__namespace.createElement(GroupSizeContext.Provider, {
      value: size
    }, /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, others, {
      className: classes
    })));
  };
  const Group$3 = ButtonGroup$1;
  const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
  const isTwoCNChar$1 = rxTwoCNChar.test.bind(rxTwoCNChar);
  function isString$2(str) {
    return typeof str === "string";
  }
  function isUnBorderedButtonType(type4) {
    return type4 === "text" || type4 === "link";
  }
  function splitCNCharsBySpace(child, needInserted) {
    if (child === null || child === void 0) {
      return;
    }
    const SPACE2 = needInserted ? " " : "";
    if (typeof child !== "string" && typeof child !== "number" && isString$2(child.type) && isTwoCNChar$1(child.props.children)) {
      return cloneElement(child, {
        children: child.props.children.split("").join(SPACE2)
      });
    }
    if (isString$2(child)) {
      return isTwoCNChar$1(child) ? /* @__PURE__ */ React.createElement("span", null, child.split("").join(SPACE2)) : /* @__PURE__ */ React.createElement("span", null, child);
    }
    if (isFragment(child)) {
      return /* @__PURE__ */ React.createElement("span", null, child);
    }
    return child;
  }
  function spaceChildren(children, needInserted) {
    let isPrevChildPure = false;
    const childList = [];
    React.Children.forEach(children, (child) => {
      const type4 = typeof child;
      const isCurrentChildPure = type4 === "string" || type4 === "number";
      if (isPrevChildPure && isCurrentChildPure) {
        const lastIndex = childList.length - 1;
        const lastChild = childList[lastIndex];
        childList[lastIndex] = `${lastChild}${child}`;
      } else {
        childList.push(child);
      }
      isPrevChildPure = isCurrentChildPure;
    });
    return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
  }
  const IconWrapper = /* @__PURE__ */ React.forwardRef((props, ref) => {
    const {
      className,
      style: style2,
      children,
      prefixCls
    } = props;
    const iconWrapperCls = classname(`${prefixCls}-icon`, className);
    return /* @__PURE__ */ React.createElement("span", {
      ref,
      className: iconWrapperCls,
      style: style2
    }, children);
  });
  const IconWrapper$1 = IconWrapper;
  const InnerLoadingIcon = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
    let {
      prefixCls,
      className,
      style: style2,
      iconClassName
    } = _ref;
    const mergedIconCls = classname(`${prefixCls}-loading-icon`, className);
    return /* @__PURE__ */ React.createElement(IconWrapper$1, {
      prefixCls,
      className: mergedIconCls,
      style: style2,
      ref
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, {
      className: iconClassName
    }));
  });
  const getCollapsedWidth = () => ({
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  });
  const getRealWidth = (node2) => ({
    width: node2.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  });
  const LoadingIcon = (props) => {
    const {
      prefixCls,
      loading,
      existIcon,
      className,
      style: style2
    } = props;
    const visible = !!loading;
    if (existIcon) {
      return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: style2
      });
    }
    return /* @__PURE__ */ React.createElement(CSSMotion, {
      visible,
      // We do not really use this motionName
      motionName: `${prefixCls}-loading-icon-motion`,
      motionLeave: visible,
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth
    }, (_ref2, ref) => {
      let {
        className: motionCls,
        style: motionStyle
      } = _ref2;
      return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: Object.assign(Object.assign({}, style2), motionStyle),
        ref,
        iconClassName: motionCls
      });
    });
  };
  const LoadingIcon$1 = LoadingIcon;
  const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
    // Border
    [`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  const genGroupStyle$1 = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      groupBorderColor,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          // Border
          [`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: -lineWidth,
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            [`&:hover,
          &:focus,
          &:active`]: {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  const genGroupStyle$2 = genGroupStyle$1;
  const genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      fontWeight
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        lineHeight: token2.lineHeight,
        color: token2.colorText,
        "&:disabled > *": {
          pointerEvents: "none"
        },
        "> span": {
          display: "inline-block"
        },
        [`${componentCls}-icon`]: {
          lineHeight: 0
        },
        // Leave a space between icon and text.
        [`> ${iconCls} + span, > span + ${iconCls}`]: {
          marginInlineStart: token2.marginXS
        },
        [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
          [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
            marginInlineEnd: token2.marginXS
          }
        },
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
        [`&${componentCls}-two-chinese-chars::first-letter`]: {
          letterSpacing: "0.34em"
        },
        [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em"
        },
        // make `btn-icon-only` not too narrow
        [`&-icon-only${componentCls}-compact-item`]: {
          flex: "none"
        },
        // Special styles for Primary Button
        [`&-compact-item${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: token2.lineWidth,
              height: `calc(100% + ${token2.lineWidth * 2}px)`,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        },
        // Special styles for Primary Button
        "&-compact-vertical-item": {
          [`&${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: `calc(100% + ${token2.lineWidth * 2}px)`,
                height: token2.lineWidth,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          }
        }
      }
    };
  };
  const genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
    [`&:not(:disabled):not(${btnCls}-disabled)`]: {
      "&:hover": hoverStyle,
      "&:active": activeStyle
    }
  });
  const genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%"
  });
  const genRoundButtonStyle = (token2) => ({
    borderRadius: token2.controlHeight,
    paddingInlineStart: token2.controlHeight / 2,
    paddingInlineEnd: token2.controlHeight / 2
  });
  const genDisabledStyle$1 = (token2) => ({
    cursor: "not-allowed",
    borderColor: token2.borderColorDisabled,
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    boxShadow: "none"
  });
  const genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
    [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
      color: textColor || void 0,
      backgroundColor: background,
      borderColor: borderColor || void 0,
      boxShadow: "none"
    }, genHoverActiveButtonStyle(btnCls, Object.assign({
      backgroundColor: background
    }, hoverStyle), Object.assign({
      backgroundColor: background
    }, activeStyle))), {
      "&:disabled": {
        cursor: "not-allowed",
        color: textColorDisabled || void 0,
        borderColor: borderColorDisabled || void 0
      }
    })
  });
  const genSolidDisabledButtonStyle = (token2) => ({
    [`&:disabled, &${token2.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token2))
  });
  const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
  const genPureDisabledButtonStyle = (token2) => ({
    [`&:disabled, &${token2.componentCls}-disabled`]: {
      cursor: "not-allowed",
      color: token2.colorTextDisabled
    }
  });
  const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
    backgroundColor: token2.defaultBg,
    borderColor: token2.defaultBorderColor,
    color: token2.defaultColor,
    boxShadow: token2.defaultShadow
  }), genHoverActiveButtonStyle(token2.componentCls, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.defaultGhostColor, token2.defaultGhostBorderColor, token2.colorTextDisabled, token2.colorBorder)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
      color: token2.colorError,
      borderColor: token2.colorError
    }, genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorBorderHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
  });
  const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
    color: token2.primaryColor,
    backgroundColor: token2.colorPrimary,
    boxShadow: token2.primaryShadow
  }), genHoverActiveButtonStyle(token2.componentCls, {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryHover
  }, {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
      backgroundColor: token2.colorError,
      boxShadow: token2.dangerShadow,
      color: token2.dangerColor
    }, genHoverActiveButtonStyle(token2.componentCls, {
      backgroundColor: token2.colorErrorHover
    }, {
      backgroundColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genSolidDisabledButtonStyle(token2))
  });
  const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
    borderStyle: "dashed"
  });
  const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
    color: token2.colorLink
  }, genHoverActiveButtonStyle(token2.componentCls, {
    color: token2.colorLinkHover,
    backgroundColor: token2.linkHoverBg
  }, {
    color: token2.colorLinkActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
      color: token2.colorError
    }, genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive
    })), genPureDisabledButtonStyle(token2))
  });
  const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle(token2.componentCls, {
    color: token2.colorText,
    backgroundColor: token2.textHoverBg
  }, {
    color: token2.colorText,
    backgroundColor: token2.colorBgTextActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
      color: token2.colorError
    }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }, {
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }))
  });
  const genTypeButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-default`]: genDefaultButtonStyle(token2),
      [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
      [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
      [`${componentCls}-link`]: genLinkButtonStyle(token2),
      [`${componentCls}-text`]: genTextButtonStyle(token2),
      [`${componentCls}-ghost`]: genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)
    };
  };
  const genSizeButtonStyle = function(token2) {
    let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
      componentCls,
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      borderRadius,
      buttonPaddingHorizontal,
      iconCls
    } = token2;
    const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
    const iconOnlyCls = `${componentCls}-icon-only`;
    return [
      // Size
      {
        [`${componentCls}${sizePrefixCls}`]: {
          fontSize,
          height: controlHeight,
          padding: `${paddingVertical}px ${buttonPaddingHorizontal}px`,
          borderRadius,
          [`&${iconOnlyCls}`]: {
            width: controlHeight,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${componentCls}-round`]: {
              width: "auto"
            },
            [iconCls]: {
              fontSize: token2.buttonIconOnlyFontSize
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: token2.opacityLoading,
            cursor: "default"
          },
          [`${componentCls}-loading-icon`]: {
            transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
      }
    ];
  };
  const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(merge(token2, {
    fontSize: token2.contentFontSize
  }));
  const genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge(token2, {
      controlHeight: token2.controlHeightSM,
      fontSize: token2.contentFontSizeSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: token2.paddingInlineSM,
      borderRadius: token2.borderRadiusSM,
      buttonIconOnlyFontSize: token2.onlyIconSizeSM
    });
    return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  const genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.contentFontSizeLG,
      buttonPaddingHorizontal: token2.paddingInlineLG,
      borderRadius: token2.borderRadiusLG,
      buttonIconOnlyFontSize: token2.onlyIconSizeLG
    });
    return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  const genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  const prepareToken$2 = (token2) => {
    const {
      paddingInline,
      onlyIconSize
    } = token2;
    const buttonToken = merge(token2, {
      buttonPaddingHorizontal: paddingInline,
      buttonIconOnlyFontSize: onlyIconSize
    });
    return buttonToken;
  };
  const prepareComponentToken$1 = (token2) => ({
    fontWeight: 400,
    defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
    primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
    dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
    primaryColor: token2.colorTextLightSolid,
    dangerColor: token2.colorTextLightSolid,
    borderColorDisabled: token2.colorBorder,
    defaultGhostColor: token2.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: token2.colorBgContainer,
    paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineSM: 8 - token2.lineWidth,
    onlyIconSize: token2.fontSizeLG,
    onlyIconSizeSM: token2.fontSizeLG - 2,
    onlyIconSizeLG: token2.fontSizeLG + 2,
    groupBorderColor: token2.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: token2.colorBgTextHover,
    defaultColor: token2.colorText,
    defaultBg: token2.colorBgContainer,
    defaultBorderColor: token2.colorBorder,
    defaultBorderColorDisabled: token2.colorBorder,
    contentFontSize: token2.fontSize,
    contentFontSizeSM: token2.fontSize,
    contentFontSizeLG: token2.fontSizeLG
  });
  const useStyle$b = genComponentStyleHook("Button", (token2) => {
    const buttonToken = prepareToken$2(token2);
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeSmallButtonStyle(buttonToken),
      genSizeBaseButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Group (type, ghost, danger, loading)
      genTypeButtonStyle(buttonToken),
      // Button Group
      genGroupStyle$2(buttonToken)
    ];
  }, prepareComponentToken$1);
  function compactItemBorder(token2, parentCls, options) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: -token2.lineWidth
      },
      "&-item": Object.assign(Object.assign({
        [hoverEffects]: {
          zIndex: 2
        }
      }, focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {}), {
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      })
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options) {
    const {
      borderElCls
    } = options;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      focus: true
    };
    const {
      componentCls
    } = token2;
    const compactCls = `${componentCls}-compact`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
    };
  }
  function compactItemVerticalBorder(token2, parentCls) {
    return {
      // border collapse
      [`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: -token2.lineWidth
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 2
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
    };
  }
  const CompactCmp = genSubStyleComponent(["Button", "compact"], (token2) => {
    const buttonToken = prepareToken$2(token2);
    return [
      // Space Compact
      genCompactItemStyle(buttonToken),
      genCompactItemVerticalStyle(buttonToken)
    ];
  }, prepareComponentToken$1);
  var __rest$k = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function getLoadingConfig(loading) {
    if (typeof loading === "object" && loading) {
      let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
      delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
      return {
        loading: delay <= 0,
        delay
      };
    }
    return {
      loading: !!loading,
      delay: 0
    };
  }
  const InternalButton = (props, ref) => {
    var _a, _b;
    const {
      loading = false,
      prefixCls: customizePrefixCls,
      type: type4 = "default",
      danger: danger2,
      shape = "default",
      size: customizeSize,
      styles: styles2,
      disabled: customDisabled,
      className,
      rootClassName,
      children,
      icon: icon2,
      ghost = false,
      block = false,
      // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
      htmlType = "button",
      classNames: customClassNames,
      style: customStyle = {}
    } = props, rest = __rest$k(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style"]);
    const {
      getPrefixCls,
      autoInsertSpaceInButton,
      direction,
      button
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("btn", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$b(prefixCls);
    const disabled = React.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const groupSize = React.useContext(GroupSizeContext);
    const loadingOrDelay = React.useMemo(() => getLoadingConfig(loading), [loading]);
    const [innerLoading, setLoading] = React.useState(loadingOrDelay.loading);
    const [hasTwoCNChar, setHasTwoCNChar] = React.useState(false);
    const internalRef = /* @__PURE__ */ React.createRef();
    const buttonRef = composeRef(ref, internalRef);
    const needInserted = React.Children.count(children) === 1 && !icon2 && !isUnBorderedButtonType(type4);
    React.useEffect(() => {
      let delayTimer = null;
      if (loadingOrDelay.delay > 0) {
        delayTimer = setTimeout(() => {
          delayTimer = null;
          setLoading(true);
        }, loadingOrDelay.delay);
      } else {
        setLoading(loadingOrDelay.loading);
      }
      function cleanupTimer() {
        if (delayTimer) {
          clearTimeout(delayTimer);
          delayTimer = null;
        }
      }
      return cleanupTimer;
    }, [loadingOrDelay]);
    React.useEffect(() => {
      if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
        return;
      }
      const buttonText = buttonRef.current.textContent;
      if (needInserted && isTwoCNChar$1(buttonText)) {
        if (!hasTwoCNChar) {
          setHasTwoCNChar(true);
        }
      } else if (hasTwoCNChar) {
        setHasTwoCNChar(false);
      }
    }, [buttonRef]);
    const handleClick = (e2) => {
      const {
        onClick
      } = props;
      if (innerLoading || mergedDisabled) {
        e2.preventDefault();
        return;
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    };
    const autoInsertSpace = autoInsertSpaceInButton !== false;
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const sizeClassNameMap = {
      large: "lg",
      small: "sm",
      middle: void 0
    };
    const sizeFullName = useSize$1((ctxSize) => {
      var _a2, _b2;
      return (_b2 = (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
    });
    const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] || "" : "";
    const iconType = innerLoading ? "loading" : icon2;
    const linkButtonRestProps = omit(rest, ["navigate"]);
    const classes = classname(prefixCls, hashId, {
      [`${prefixCls}-${shape}`]: shape !== "default" && shape,
      [`${prefixCls}-${type4}`]: type4,
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
      [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type4),
      [`${prefixCls}-loading`]: innerLoading,
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-dangerous`]: !!danger2,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, compactItemClassnames, className, rootClassName, button === null || button === void 0 ? void 0 : button.className);
    const fullStyle = Object.assign(Object.assign({}, button === null || button === void 0 ? void 0 : button.style), customStyle);
    const iconClasses = classname(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, (_a = button === null || button === void 0 ? void 0 : button.classNames) === null || _a === void 0 ? void 0 : _a.icon);
    const iconStyle = Object.assign(Object.assign({}, (styles2 === null || styles2 === void 0 ? void 0 : styles2.icon) || {}), ((_b = button === null || button === void 0 ? void 0 : button.styles) === null || _b === void 0 ? void 0 : _b.icon) || {});
    const iconNode = icon2 && !innerLoading ? /* @__PURE__ */ React.createElement(IconWrapper$1, {
      prefixCls,
      className: iconClasses,
      style: iconStyle
    }, icon2) : /* @__PURE__ */ React.createElement(LoadingIcon$1, {
      existIcon: !!icon2,
      prefixCls,
      loading: !!innerLoading
    });
    const kids = children || children === 0 ? spaceChildren(children, needInserted && autoInsertSpace) : null;
    if (linkButtonRestProps.href !== void 0) {
      return wrapSSR(/* @__PURE__ */ React.createElement("a", Object.assign({}, linkButtonRestProps, {
        className: classname(classes, {
          [`${prefixCls}-disabled`]: mergedDisabled
        }),
        style: fullStyle,
        onClick: handleClick,
        ref: buttonRef
      }), iconNode, kids));
    }
    let buttonNode = /* @__PURE__ */ React.createElement("button", Object.assign({}, rest, {
      type: htmlType,
      className: classes,
      style: fullStyle,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: buttonRef
    }), iconNode, kids, compactItemClassnames && /* @__PURE__ */ React.createElement(CompactCmp, {
      key: "compact",
      prefixCls
    }));
    if (!isUnBorderedButtonType(type4)) {
      buttonNode = /* @__PURE__ */ React.createElement(Wave$2, {
        component: "Button",
        disabled: !!innerLoading
      }, buttonNode);
    }
    return wrapSSR(buttonNode);
  };
  const Button$2 = /* @__PURE__ */ React.forwardRef(InternalButton);
  Button$2.Group = Group$3;
  Button$2.__ANT_BUTTON = true;
  const Button$3 = Button$2;
  var OrderContext = /* @__PURE__ */ React__namespace.createContext(null);
  var EMPTY_LIST$1 = [];
  function useDom(render2, debug) {
    var _React$useState = React__namespace.useState(function() {
      if (!canUseDom()) {
        return null;
      }
      var defaultEle = document.createElement("div");
      return defaultEle;
    }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
    var appendedRef = React__namespace.useRef(false);
    var queueCreate = React__namespace.useContext(OrderContext);
    var _React$useState3 = React__namespace.useState(EMPTY_LIST$1), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
    var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
      setQueue(function(origin) {
        var newQueue = [appendFn].concat(_toConsumableArray(origin));
        return newQueue;
      });
    });
    function append2() {
      if (!ele.parentElement) {
        document.body.appendChild(ele);
      }
      appendedRef.current = true;
    }
    function cleanup2() {
      var _ele$parentElement;
      (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
      appendedRef.current = false;
    }
    useLayoutEffect$1(function() {
      if (render2) {
        if (queueCreate) {
          queueCreate(append2);
        } else {
          append2();
        }
      } else {
        cleanup2();
      }
      return cleanup2;
    }, [render2]);
    useLayoutEffect$1(function() {
      if (queue.length) {
        queue.forEach(function(appendFn) {
          return appendFn();
        });
        setQueue(EMPTY_LIST$1);
      }
    }, [queue]);
    return [ele, mergedQueueCreate];
  }
  var cached;
  function getScrollBarSize(fresh) {
    if (typeof document === "undefined") {
      return 0;
    }
    if (fresh || cached === void 0) {
      var inner2 = document.createElement("div");
      inner2.style.width = "100%";
      inner2.style.height = "200px";
      var outer = document.createElement("div");
      var outerStyle = outer.style;
      outerStyle.position = "absolute";
      outerStyle.top = "0";
      outerStyle.left = "0";
      outerStyle.pointerEvents = "none";
      outerStyle.visibility = "hidden";
      outerStyle.width = "200px";
      outerStyle.height = "150px";
      outerStyle.overflow = "hidden";
      outer.appendChild(inner2);
      document.body.appendChild(outer);
      var widthContained = inner2.offsetWidth;
      outer.style.overflow = "scroll";
      var widthScroll = inner2.offsetWidth;
      if (widthContained === widthScroll) {
        widthScroll = outer.clientWidth;
      }
      document.body.removeChild(outer);
      cached = widthContained - widthScroll;
    }
    return cached;
  }
  function ensureSize(str) {
    var match2 = str.match(/^(.*)px$/);
    var value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
    return Number.isNaN(value) ? getScrollBarSize() : value;
  }
  function getTargetScrollBarSize(target) {
    if (typeof document === "undefined" || !target || !(target instanceof Element)) {
      return {
        width: 0,
        height: 0
      };
    }
    var _getComputedStyle = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle.width, height = _getComputedStyle.height;
    return {
      width: ensureSize(width),
      height: ensureSize(height)
    };
  }
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }
  var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
  var uuid$3 = 0;
  function useScrollLocker(lock) {
    var mergedLock = !!lock;
    var _React$useState = React__namespace.useState(function() {
      uuid$3 += 1;
      return "".concat(UNIQUE_ID, "_").concat(uuid$3);
    }), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
    useLayoutEffect$1(function() {
      if (mergedLock) {
        var scrollbarSize = getTargetScrollBarSize(document.body).width;
        var isOverflow = isBodyOverflowing();
        updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
      } else {
        removeCSS(id);
      }
      return function() {
        removeCSS(id);
      };
    }, [mergedLock, id]);
  }
  var inline = false;
  function inlineMock(nextInline) {
    if (typeof nextInline === "boolean") {
      inline = nextInline;
    }
    return inline;
  }
  var getPortalContainer = function getPortalContainer2(getContainer3) {
    if (getContainer3 === false) {
      return false;
    }
    if (!canUseDom() || !getContainer3) {
      return null;
    }
    if (typeof getContainer3 === "string") {
      return document.querySelector(getContainer3);
    }
    if (typeof getContainer3 === "function") {
      return getContainer3();
    }
    return getContainer3;
  };
  var Portal = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var open2 = props.open, autoLock = props.autoLock, getContainer3 = props.getContainer;
    props.debug;
    var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
    var _React$useState = React__namespace.useState(open2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
    var mergedRender = shouldRender || open2;
    React__namespace.useEffect(function() {
      if (autoDestroy || open2) {
        setShouldRender(open2);
      }
    }, [open2, autoDestroy]);
    var _React$useState3 = React__namespace.useState(function() {
      return getPortalContainer(getContainer3);
    }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
    React__namespace.useEffect(function() {
      var customizeContainer = getPortalContainer(getContainer3);
      setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
    });
    var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
    var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
    useScrollLocker(autoLock && open2 && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
    var childRef = null;
    if (children && supportRef(children) && ref) {
      var _ref = children;
      childRef = _ref.ref;
    }
    var mergedRef = useComposeRef(childRef, ref);
    if (!mergedRender || !canUseDom() || innerContainer === void 0) {
      return null;
    }
    var renderInline = mergedContainer === false || inlineMock();
    var reffedChildren = children;
    if (ref) {
      reffedChildren = /* @__PURE__ */ React__namespace.cloneElement(children, {
        ref: mergedRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(OrderContext.Provider, {
      value: queueCreate
    }, renderInline ? reffedChildren : /* @__PURE__ */ ReactDOM__default.createPortal(reffedChildren, mergedContainer));
  });
  function getUseId() {
    var fullClone2 = _objectSpread2({}, React__namespace);
    return fullClone2.useId;
  }
  var uuid$2 = 0;
  var useOriginId = getUseId();
  const useId$1 = useOriginId ? (
    // Use React `useId`
    function useId(id) {
      var reactId = useOriginId();
      if (id) {
        return id;
      }
      return reactId;
    }
  ) : (
    // Use compatible of `useId`
    function useCompatId(id) {
      var _React$useState = React__namespace.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      React__namespace.useEffect(function() {
        var nextId = uuid$2;
        uuid$2 += 1;
        setInnerId("rc_unique_".concat(nextId));
      }, []);
      if (id) {
        return id;
      }
      return innerId;
    }
  );
  function useInnerClosable(closable, closeIcon, defaultClosable) {
    if (typeof closable === "boolean") {
      return closable;
    }
    if (closeIcon === void 0) {
      return !!defaultClosable;
    }
    return closeIcon !== false && closeIcon !== null;
  }
  function useClosable(closable, closeIcon, customCloseIconRender) {
    let defaultCloseIcon = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ React.createElement(CloseOutlined$1, null);
    let defaultClosable = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const mergedClosable = useInnerClosable(closable, closeIcon, defaultClosable);
    if (!mergedClosable) {
      return [false, null];
    }
    const mergedCloseIcon = typeof closeIcon === "boolean" || closeIcon === void 0 || closeIcon === null ? defaultCloseIcon : closeIcon;
    return [true, customCloseIconRender ? customCloseIconRender(mergedCloseIcon) : mergedCloseIcon];
  }
  var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
  var warningFunc$1 = function warningFunc() {
    warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
  };
  var Context = /* @__PURE__ */ React__namespace.createContext({
    getFieldValue: warningFunc$1,
    getFieldsValue: warningFunc$1,
    getFieldError: warningFunc$1,
    getFieldWarning: warningFunc$1,
    getFieldsError: warningFunc$1,
    isFieldsTouched: warningFunc$1,
    isFieldTouched: warningFunc$1,
    isFieldValidating: warningFunc$1,
    isFieldsValidating: warningFunc$1,
    resetFields: warningFunc$1,
    setFields: warningFunc$1,
    setFieldValue: warningFunc$1,
    setFieldsValue: warningFunc$1,
    validateFields: warningFunc$1,
    submit: warningFunc$1,
    getInternalHooks: function getInternalHooks() {
      warningFunc$1();
      return {
        dispatch: warningFunc$1,
        initEntityValue: warningFunc$1,
        registerField: warningFunc$1,
        useSubscribe: warningFunc$1,
        setInitialValues: warningFunc$1,
        destroyForm: warningFunc$1,
        setCallbacks: warningFunc$1,
        registerWatch: warningFunc$1,
        getFields: warningFunc$1,
        setValidateMessages: warningFunc$1,
        setPreserve: warningFunc$1,
        getInitialValue: warningFunc$1
      };
    }
  });
  var ListContext = /* @__PURE__ */ React__namespace.createContext(null);
  function toArray$2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function isFormInstance(form) {
    return form && !!form._init;
  }
  function _extends$6() {
    _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$6.apply(this, arguments);
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper2);
      }
      function Wrapper2() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper2.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper2,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper2, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning$1 = function warning() {
  };
  if (typeof process !== "undefined" && process.env && false) {
    warning$1 = function warning3(type4, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e2) {
          return typeof e2 === "string";
        })) {
          console.warn(type4, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length)
      return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i >= len) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k2) {
      ret.push.apply(ret, objArr[k2] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose$1(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next2 = function next3(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value, path) {
    var v2 = value;
    for (var i = 0; i < path.length; i++) {
      if (v2 == void 0) {
        return v2;
      }
      v2 = v2[path[i]];
    }
    return v2;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if (typeof value === "object" && typeof target[s] === "object") {
            target[s] = _extends$6({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b2 = function b3(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v42 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v42 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v42 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v42 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v42 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v42 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v42 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v42 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v42 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v42 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v42 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("" + b2(options) + v42 + b2(options), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e2) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range$1 = function range(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range: range$1,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate2 = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate2) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var validators = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object2,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate2(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r) {
          var rule = r;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends$6({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends$6({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _extends$6({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _extends$6({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type4, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type4] = validator;
  };
  Schema.warning = warning$1;
  Schema.messages = messages;
  Schema.validators = validators;
  var typeTemplate = "'${name}' is not a valid ${type}";
  var defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  var AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, function(str) {
      var key = str.slice(2, -1);
      return kv[key];
    });
  }
  var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
  function validateRule(_x, _x2, _x3, _x4, _x5) {
    return _validateRule.apply(this, arguments);
  }
  function _validateRule() {
    _validateRule = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee2(name, value, rule, options, messageVariables) {
      var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
      return _regeneratorRuntime$2().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              cloneRule = _objectSpread2({}, rule);
              delete cloneRule.ruleIndex;
              AsyncValidator.warning = function() {
                return void 0;
              };
              if (cloneRule.validator) {
                originValidator = cloneRule.validator;
                cloneRule.validator = function() {
                  try {
                    return originValidator.apply(void 0, arguments);
                  } catch (error) {
                    console.error(error);
                    return Promise.reject(CODE_LOGIC_ERROR);
                  }
                };
              }
              subRuleField = null;
              if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }
              validator = new AsyncValidator(_defineProperty$1({}, name, [cloneRule]));
              messages2 = merge$1(defaultValidateMessages, options.validateMessages);
              validator.messages(messages2);
              result = [];
              _context2.prev = 10;
              _context2.next = 13;
              return Promise.resolve(validator.validate(_defineProperty$1({}, name, value), _objectSpread2({}, options)));
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](10);
              if (_context2.t0.errors) {
                result = _context2.t0.errors.map(function(_ref4, index2) {
                  var message2 = _ref4.message;
                  var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                  return /* @__PURE__ */ React__namespace.isValidElement(mergedMessage) ? (
                    // Wrap ReactNode with `key`
                    /* @__PURE__ */ React__namespace.cloneElement(mergedMessage, {
                      key: "error_".concat(index2)
                    })
                  ) : mergedMessage;
                });
              }
            case 18:
              if (!(!result.length && subRuleField)) {
                _context2.next = 23;
                break;
              }
              _context2.next = 21;
              return Promise.all(value.map(function(subValue, i) {
                return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
              }));
            case 21:
              subResults = _context2.sent;
              return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
              }, []));
            case 23:
              kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                name,
                enum: (rule.enum || []).join(", ")
              }, messageVariables);
              fillVariableResult = result.map(function(error) {
                if (typeof error === "string") {
                  return replaceMessage(error, kv);
                }
                return error;
              });
              return _context2.abrupt("return", fillVariableResult);
            case 26:
            case "end":
              return _context2.stop();
          }
      }, _callee2, null, [[10, 15]]);
    }));
    return _validateRule.apply(this, arguments);
  }
  function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
    var name = namePath.join(".");
    var filledRules = rules2.map(function(currentRule, ruleIndex) {
      var originValidatorFunc = currentRule.validator;
      var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = function(rule, val, callback) {
          var hasPromise = false;
          var wrappedCallback = function wrappedCallback2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(function() {
              warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback.apply(void 0, args);
              }
            });
          };
          var promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(function() {
              callback();
            }).catch(function(err) {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort(function(_ref, _ref2) {
      var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
      var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    var summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise(/* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee(resolve, reject) {
          var i, rule, errors;
          return _regeneratorRuntime$2().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  i = 0;
                case 1:
                  if (!(i < filledRules.length)) {
                    _context.next = 12;
                    break;
                  }
                  rule = filledRules[i];
                  _context.next = 5;
                  return validateRule(name, value, rule, options, messageVariables);
                case 5:
                  errors = _context.sent;
                  if (!errors.length) {
                    _context.next = 9;
                    break;
                  }
                  reject([{
                    errors,
                    rule
                  }]);
                  return _context.abrupt("return");
                case 9:
                  i += 1;
                  _context.next = 1;
                  break;
                case 12:
                  resolve([]);
                case 13:
                case "end":
                  return _context.stop();
              }
          }, _callee);
        }));
        return function(_x6, _x7) {
          return _ref3.apply(this, arguments);
        };
      }());
    } else {
      var rulePromises = filledRules.map(function(rule) {
        return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
          return {
            errors,
            rule
          };
        });
      });
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch(function(e2) {
      return e2;
    });
    return summaryPromise;
  }
  function finishOnAllFailed(_x8) {
    return _finishOnAllFailed.apply(this, arguments);
  }
  function _finishOnAllFailed() {
    _finishOnAllFailed = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee3(rulePromises) {
      return _regeneratorRuntime$2().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                var _ref5;
                var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                return errors;
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return _finishOnAllFailed.apply(this, arguments);
  }
  function finishOnFirstFailed(_x9) {
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function _finishOnFirstFailed() {
    _finishOnFirstFailed = _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee4(rulePromises) {
      var count;
      return _regeneratorRuntime$2().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              count = 0;
              return _context4.abrupt("return", new Promise(function(resolve) {
                rulePromises.forEach(function(promise) {
                  promise.then(function(ruleError) {
                    if (ruleError.errors.length) {
                      resolve([ruleError]);
                    }
                    count += 1;
                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function getNamePath(path) {
    return toArray$2(path);
  }
  function cloneByNamePathList(store, namePathList) {
    var newStore = {};
    namePathList.forEach(function(namePath) {
      var value = get(store, namePath);
      newStore = set(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return namePathList && namePathList.some(function(path) {
      return matchNamePath(namePath, path, partialMatch);
    });
  }
  function matchNamePath(namePath, subNamePath) {
    var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!namePath || !subNamePath) {
      return false;
    }
    if (!partialMatch && namePath.length !== subNamePath.length) {
      return false;
    }
    return subNamePath.every(function(nameUnit, i) {
      return namePath[i] === nameUnit;
    });
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }
    if (!source && target || source && !target) {
      return false;
    }
    if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") {
      return false;
    }
    var sourceKeys = Object.keys(source);
    var targetKeys = Object.keys(target);
    var keys2 = new Set([].concat(sourceKeys, targetKeys));
    return _toConsumableArray(keys2).every(function(key) {
      var sourceValue = source[key];
      var targetValue = target[key];
      if (typeof sourceValue === "function" && typeof targetValue === "function") {
        return true;
      }
      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName) {
    var event = arguments.length <= 1 ? void 0 : arguments[1];
    if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) {
      return event.target[valuePropName];
    }
    return event;
  }
  function move$1(array4, moveIndex, toIndex) {
    var length2 = array4.length;
    if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
      return array4;
    }
    var item = array4[moveIndex];
    var diff = moveIndex - toIndex;
    if (diff > 0) {
      return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2)));
    }
    if (diff < 0) {
      return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2)));
    }
    return array4;
  }
  var _excluded$B = ["name"];
  var EMPTY_ERRORS = [];
  function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info2) {
    if (typeof shouldUpdate === "function") {
      return shouldUpdate(prev2, next2, "source" in info2 ? {
        source: info2.source
      } : {});
    }
    return prevValue !== nextValue;
  }
  var Field = /* @__PURE__ */ function(_React$Component) {
    _inherits(Field2, _React$Component);
    var _super = _createSuper(Field2);
    function Field2(props) {
      var _this;
      _classCallCheck(this, Field2);
      _this = _super.call(this, props);
      _defineProperty$1(_assertThisInitialized(_this), "state", {
        resetCount: 0
      });
      _defineProperty$1(_assertThisInitialized(_this), "cancelRegisterFunc", null);
      _defineProperty$1(_assertThisInitialized(_this), "mounted", false);
      _defineProperty$1(_assertThisInitialized(_this), "touched", false);
      _defineProperty$1(_assertThisInitialized(_this), "dirty", false);
      _defineProperty$1(_assertThisInitialized(_this), "validatePromise", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "prevValidating", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
      _defineProperty$1(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
      _defineProperty$1(_assertThisInitialized(_this), "cancelRegister", function() {
        var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
        if (_this.cancelRegisterFunc) {
          _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
        }
        _this.cancelRegisterFunc = null;
      });
      _defineProperty$1(_assertThisInitialized(_this), "getNamePath", function() {
        var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
        var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
        return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
      });
      _defineProperty$1(_assertThisInitialized(_this), "getRules", function() {
        var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
        return rules2.map(function(rule) {
          if (typeof rule === "function") {
            return rule(fieldContext);
          }
          return rule;
        });
      });
      _defineProperty$1(_assertThisInitialized(_this), "refresh", function() {
        if (!_this.mounted)
          return;
        _this.setState(function(_ref) {
          var resetCount = _ref.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      });
      _defineProperty$1(_assertThisInitialized(_this), "metaCache", null);
      _defineProperty$1(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy2) {
        var onMetaChange = _this.props.onMetaChange;
        if (onMetaChange) {
          var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
            destroy: destroy2
          });
          if (!isEqual(_this.metaCache, _meta)) {
            onMetaChange(_meta);
          }
          _this.metaCache = _meta;
        } else {
          _this.metaCache = null;
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info2) {
        var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
        var store = info2.store;
        var namePath = _this.getNamePath();
        var prevValue = _this.getValue(prevStore);
        var curValue = _this.getValue(store);
        var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
        if (info2.type === "valueUpdate" && info2.source === "external" && prevValue !== curValue) {
          _this.touched = true;
          _this.dirty = true;
          _this.validatePromise = null;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
        }
        switch (info2.type) {
          case "reset":
            if (!namePathList || namePathMatch) {
              _this.touched = false;
              _this.dirty = false;
              _this.validatePromise = void 0;
              _this.errors = EMPTY_ERRORS;
              _this.warnings = EMPTY_ERRORS;
              _this.triggerMetaEvent();
              onReset === null || onReset === void 0 ? void 0 : onReset();
              _this.refresh();
              return;
            }
            break;
          case "remove": {
            if (shouldUpdate) {
              _this.reRender();
              return;
            }
            break;
          }
          case "setField": {
            var data = info2.data;
            if (namePathMatch) {
              if ("touched" in data) {
                _this.touched = data.touched;
              }
              if ("validating" in data && !("originRCField" in data)) {
                _this.validatePromise = data.validating ? Promise.resolve([]) : null;
              }
              if ("errors" in data) {
                _this.errors = data.errors || EMPTY_ERRORS;
              }
              if ("warnings" in data) {
                _this.warnings = data.warnings || EMPTY_ERRORS;
              }
              _this.dirty = true;
              _this.triggerMetaEvent();
              _this.reRender();
              return;
            } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
              _this.reRender();
              return;
            }
            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
              _this.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var dependencyList = dependencies.map(getNamePath);
            if (dependencyList.some(function(dependency) {
              return containsNamePath(info2.relatedFields, dependency);
            })) {
              _this.reRender();
              return;
            }
            break;
          }
          default:
            if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
              _this.reRender();
              return;
            }
            break;
        }
        if (shouldUpdate === true) {
          _this.reRender();
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "validateRules", function(options) {
        var namePath = _this.getNamePath();
        var currentValue = _this.getValue();
        var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
        var rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator$2(/* @__PURE__ */ _regeneratorRuntime$2().mark(function _callee() {
          var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
          return _regeneratorRuntime$2().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  if (_this.mounted) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 2:
                  _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce;
                  filteredRules = _this.getRules();
                  if (triggerName) {
                    filteredRules = filteredRules.filter(function(rule) {
                      return rule;
                    }).filter(function(rule) {
                      var validateTrigger = rule.validateTrigger;
                      if (!validateTrigger) {
                        return true;
                      }
                      var triggerList = toArray$2(validateTrigger);
                      return triggerList.includes(triggerName);
                    });
                  }
                  if (!(validateDebounce && triggerName)) {
                    _context.next = 10;
                    break;
                  }
                  _context.next = 8;
                  return new Promise(function(resolve) {
                    setTimeout(resolve, validateDebounce);
                  });
                case 8:
                  if (!(_this.validatePromise !== rootPromise)) {
                    _context.next = 10;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 10:
                  promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
                  promise.catch(function(e2) {
                    return e2;
                  }).then(function() {
                    var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                    if (_this.validatePromise === rootPromise) {
                      var _ruleErrors$forEach;
                      _this.validatePromise = null;
                      var nextErrors = [];
                      var nextWarnings = [];
                      (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
                        var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                        if (warningOnly) {
                          nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                        } else {
                          nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                        }
                      });
                      _this.errors = nextErrors;
                      _this.warnings = nextWarnings;
                      _this.triggerMetaEvent();
                      _this.reRender();
                    }
                  });
                  return _context.abrupt("return", promise);
                case 13:
                case "end":
                  return _context.stop();
              }
          }, _callee);
        })));
        if (validateOnly) {
          return rootPromise;
        }
        _this.validatePromise = rootPromise;
        _this.dirty = true;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
        _this.reRender();
        return rootPromise;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isFieldValidating", function() {
        return !!_this.validatePromise;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isFieldTouched", function() {
        return _this.touched;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isFieldDirty", function() {
        if (_this.dirty || _this.props.initialValue !== void 0) {
          return true;
        }
        var fieldContext = _this.props.fieldContext;
        var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
        if (getInitialValue(_this.getNamePath()) !== void 0) {
          return true;
        }
        return false;
      });
      _defineProperty$1(_assertThisInitialized(_this), "getErrors", function() {
        return _this.errors;
      });
      _defineProperty$1(_assertThisInitialized(_this), "getWarnings", function() {
        return _this.warnings;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isListField", function() {
        return _this.props.isListField;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isList", function() {
        return _this.props.isList;
      });
      _defineProperty$1(_assertThisInitialized(_this), "isPreserve", function() {
        return _this.props.preserve;
      });
      _defineProperty$1(_assertThisInitialized(_this), "getMeta", function() {
        _this.prevValidating = _this.isFieldValidating();
        var meta = {
          touched: _this.isFieldTouched(),
          validating: _this.prevValidating,
          errors: _this.errors,
          warnings: _this.warnings,
          name: _this.getNamePath(),
          validated: _this.validatePromise === null
        };
        return meta;
      });
      _defineProperty$1(_assertThisInitialized(_this), "getOnlyChild", function(children) {
        if (typeof children === "function") {
          var _meta2 = _this.getMeta();
          return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
            isFunction: true
          });
        }
        var childList = toArray$3(children);
        if (childList.length !== 1 || !/* @__PURE__ */ React__namespace.isValidElement(childList[0])) {
          return {
            child: childList,
            isFunction: false
          };
        }
        return {
          child: childList[0],
          isFunction: false
        };
      });
      _defineProperty$1(_assertThisInitialized(_this), "getValue", function(store) {
        var getFieldsValue = _this.props.fieldContext.getFieldsValue;
        var namePath = _this.getNamePath();
        return get(store || getFieldsValue(true), namePath);
      });
      _defineProperty$1(_assertThisInitialized(_this), "getControlled", function() {
        var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
        var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
        var namePath = _this.getNamePath();
        var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
        var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
        var value = _this.getValue();
        var mergedGetValueProps = getValueProps || function(val) {
          return _defineProperty$1({}, valuePropName, val);
        };
        var originTriggerFunc = childProps[trigger];
        var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
        control[trigger] = function() {
          _this.touched = true;
          _this.dirty = true;
          _this.triggerMetaEvent();
          var newValue;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (getValueFromEvent) {
            newValue = getValueFromEvent.apply(void 0, args);
          } else {
            newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
          }
          if (normalize2) {
            newValue = normalize2(newValue, value, getFieldsValue(true));
          }
          dispatch({
            type: "updateValue",
            namePath,
            value: newValue
          });
          if (originTriggerFunc) {
            originTriggerFunc.apply(void 0, args);
          }
        };
        var validateTriggerList = toArray$2(mergedValidateTrigger || []);
        validateTriggerList.forEach(function(triggerName) {
          var originTrigger = control[triggerName];
          control[triggerName] = function() {
            if (originTrigger) {
              originTrigger.apply(void 0, arguments);
            }
            var rules2 = _this.props.rules;
            if (rules2 && rules2.length) {
              dispatch({
                type: "validateField",
                namePath,
                triggerName
              });
            }
          };
        });
        return control;
      });
      if (props.fieldContext) {
        var getInternalHooks2 = props.fieldContext.getInternalHooks;
        var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
        initEntityValue(_assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Field2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
        this.mounted = true;
        if (fieldContext) {
          var getInternalHooks2 = fieldContext.getInternalHooks;
          var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
          this.cancelRegisterFunc = registerField(this);
        }
        if (shouldUpdate === true) {
          this.reRender();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.cancelRegister();
        this.triggerMetaEvent(true);
        this.mounted = false;
      }
    }, {
      key: "reRender",
      value: function reRender() {
        if (!this.mounted)
          return;
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render2() {
        var resetCount = this.state.resetCount;
        var children = this.props.children;
        var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction = _this$getOnlyChild.isFunction;
        var returnChildNode;
        if (isFunction) {
          returnChildNode = child;
        } else if (/* @__PURE__ */ React__namespace.isValidElement(child)) {
          returnChildNode = /* @__PURE__ */ React__namespace.cloneElement(child, this.getControlled(child.props));
        } else {
          warningOnce(!child, "`children` of Field is not validate ReactElement.");
          returnChildNode = child;
        }
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
          key: resetCount
        }, returnChildNode);
      }
    }]);
    return Field2;
  }(React__namespace.Component);
  _defineProperty$1(Field, "contextType", Context);
  _defineProperty$1(Field, "defaultProps", {
    trigger: "onChange",
    valuePropName: "value"
  });
  function WrapperField(_ref6) {
    var name = _ref6.name, restProps = _objectWithoutProperties$8(_ref6, _excluded$B);
    var fieldContext = React__namespace.useContext(Context);
    var listContext = React__namespace.useContext(ListContext);
    var namePath = name !== void 0 ? getNamePath(name) : void 0;
    var key = "keep";
    if (!restProps.isListField) {
      key = "_".concat((namePath || []).join("_"));
    }
    return /* @__PURE__ */ React__namespace.createElement(Field, _extends$7({
      key,
      name: namePath,
      isListField: !!listContext
    }, restProps, {
      fieldContext
    }));
  }
  function List$1(_ref) {
    var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
    var context2 = React__namespace.useContext(Context);
    var wrapperListContext = React__namespace.useContext(ListContext);
    var keyRef = React__namespace.useRef({
      keys: [],
      id: 0
    });
    var keyManager = keyRef.current;
    var prefixName = React__namespace.useMemo(function() {
      var parentPrefixName = getNamePath(context2.prefixName) || [];
      return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
    }, [context2.prefixName, name]);
    var fieldContext = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, context2), {}, {
        prefixName
      });
    }, [context2, prefixName]);
    var listContext = React__namespace.useMemo(function() {
      return {
        getKey: function getKey2(namePath) {
          var len = prefixName.length;
          var pathName = namePath[len];
          return [keyManager.keys[pathName], namePath.slice(len + 1)];
        }
      };
    }, [prefixName]);
    if (typeof children !== "function") {
      warningOnce(false, "Form.List only accepts function as children.");
      return null;
    }
    var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
      var source = _ref2.source;
      if (source === "internal") {
        return false;
      }
      return prevValue !== nextValue;
    };
    return /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
      value: listContext
    }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: fieldContext
    }, /* @__PURE__ */ React__namespace.createElement(WrapperField, {
      name: [],
      shouldUpdate,
      rules: rules2,
      validateTrigger,
      initialValue,
      isList: true,
      isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
    }, function(_ref3, meta) {
      var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
      var getFieldValue = context2.getFieldValue;
      var getNewValue = function getNewValue2() {
        var values = getFieldValue(prefixName || []);
        return values || [];
      };
      var operations = {
        add: function add(defaultValue, index2) {
          var newValue = getNewValue();
          if (index2 >= 0 && index2 <= newValue.length) {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
            onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
          } else {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
            onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
          }
          keyManager.id += 1;
        },
        remove: function remove(index2) {
          var newValue = getNewValue();
          var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
            return !indexSet.has(keysIndex);
          });
          onChange(newValue.filter(function(_, valueIndex) {
            return !indexSet.has(valueIndex);
          }));
        },
        move: function move2(from2, to) {
          if (from2 === to) {
            return;
          }
          var newValue = getNewValue();
          if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }
          keyManager.keys = move$1(keyManager.keys, from2, to);
          onChange(move$1(newValue, from2, to));
        }
      };
      var listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
      }
      return children(listValue.map(function(__, index2) {
        var key = keyManager.keys[index2];
        if (key === void 0) {
          keyManager.keys[index2] = keyManager.id;
          key = keyManager.keys[index2];
          keyManager.id += 1;
        }
        return {
          name: index2,
          key,
          isListField: true
        };
      }), operations, meta);
    })));
  }
  function allPromiseFinish(promiseList) {
    var hasError = false;
    var count = promiseList.length;
    var results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise(function(resolve, reject) {
      promiseList.forEach(function(promise, index2) {
        promise.catch(function(e2) {
          hasError = true;
          return e2;
        }).then(function(result) {
          count -= 1;
          results[index2] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve(results);
        });
      });
    });
  }
  var SPLIT = "__@field_split__";
  function normalize$1(namePath) {
    return namePath.map(function(cell) {
      return "".concat(_typeof(cell), ":").concat(cell);
    }).join(SPLIT);
  }
  var NameMap = /* @__PURE__ */ function() {
    function NameMap2() {
      _classCallCheck(this, NameMap2);
      _defineProperty$1(this, "kvs", /* @__PURE__ */ new Map());
    }
    _createClass(NameMap2, [{
      key: "set",
      value: function set2(key, value) {
        this.kvs.set(normalize$1(key), value);
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this.kvs.get(normalize$1(key));
      }
    }, {
      key: "update",
      value: function update(key, updater) {
        var origin = this.get(key);
        var next2 = updater(origin);
        if (!next2) {
          this.delete(key);
        } else {
          this.set(key, next2);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this.kvs.delete(normalize$1(key));
      }
      // Since we only use this in test, let simply realize this
    }, {
      key: "map",
      value: function map(callback) {
        return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
          var cells = key.split(SPLIT);
          return callback({
            key: cells.map(function(cell) {
              var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
              return type4 === "number" ? Number(unit) : unit;
            }),
            value
          });
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var json = {};
        this.map(function(_ref3) {
          var key = _ref3.key, value = _ref3.value;
          json[key.join(".")] = value;
          return null;
        });
        return json;
      }
    }]);
    return NameMap2;
  }();
  var _excluded$A = ["name"];
  var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
    var _this = this;
    _classCallCheck(this, FormStore2);
    _defineProperty$1(this, "formHooked", false);
    _defineProperty$1(this, "forceRootUpdate", void 0);
    _defineProperty$1(this, "subscribable", true);
    _defineProperty$1(this, "store", {});
    _defineProperty$1(this, "fieldEntities", []);
    _defineProperty$1(this, "initialValues", {});
    _defineProperty$1(this, "callbacks", {});
    _defineProperty$1(this, "validateMessages", null);
    _defineProperty$1(this, "preserve", null);
    _defineProperty$1(this, "lastValidatePromise", null);
    _defineProperty$1(this, "getForm", function() {
      return {
        getFieldValue: _this.getFieldValue,
        getFieldsValue: _this.getFieldsValue,
        getFieldError: _this.getFieldError,
        getFieldWarning: _this.getFieldWarning,
        getFieldsError: _this.getFieldsError,
        isFieldsTouched: _this.isFieldsTouched,
        isFieldTouched: _this.isFieldTouched,
        isFieldValidating: _this.isFieldValidating,
        isFieldsValidating: _this.isFieldsValidating,
        resetFields: _this.resetFields,
        setFields: _this.setFields,
        setFieldValue: _this.setFieldValue,
        setFieldsValue: _this.setFieldsValue,
        validateFields: _this.validateFields,
        submit: _this.submit,
        _init: true,
        getInternalHooks: _this.getInternalHooks
      };
    });
    _defineProperty$1(this, "getInternalHooks", function(key) {
      if (key === HOOK_MARK) {
        _this.formHooked = true;
        return {
          dispatch: _this.dispatch,
          initEntityValue: _this.initEntityValue,
          registerField: _this.registerField,
          useSubscribe: _this.useSubscribe,
          setInitialValues: _this.setInitialValues,
          destroyForm: _this.destroyForm,
          setCallbacks: _this.setCallbacks,
          setValidateMessages: _this.setValidateMessages,
          getFields: _this.getFields,
          setPreserve: _this.setPreserve,
          getInitialValue: _this.getInitialValue,
          registerWatch: _this.registerWatch
        };
      }
      warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    });
    _defineProperty$1(this, "useSubscribe", function(subscribable) {
      _this.subscribable = subscribable;
    });
    _defineProperty$1(this, "prevWithoutPreserves", null);
    _defineProperty$1(this, "setInitialValues", function(initialValues, init) {
      _this.initialValues = initialValues || {};
      if (init) {
        var _this$prevWithoutPres;
        var nextStore = merge$1(initialValues, _this.store);
        (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
          var namePath = _ref.key;
          nextStore = set(nextStore, namePath, get(initialValues, namePath));
        });
        _this.prevWithoutPreserves = null;
        _this.updateStore(nextStore);
      }
    });
    _defineProperty$1(this, "destroyForm", function() {
      var prevWithoutPreserves = new NameMap();
      _this.getFieldEntities(true).forEach(function(entity) {
        if (!_this.isMergedPreserve(entity.isPreserve())) {
          prevWithoutPreserves.set(entity.getNamePath(), true);
        }
      });
      _this.prevWithoutPreserves = prevWithoutPreserves;
    });
    _defineProperty$1(this, "getInitialValue", function(namePath) {
      var initValue = get(_this.initialValues, namePath);
      return namePath.length ? merge$1(initValue) : initValue;
    });
    _defineProperty$1(this, "setCallbacks", function(callbacks) {
      _this.callbacks = callbacks;
    });
    _defineProperty$1(this, "setValidateMessages", function(validateMessages) {
      _this.validateMessages = validateMessages;
    });
    _defineProperty$1(this, "setPreserve", function(preserve) {
      _this.preserve = preserve;
    });
    _defineProperty$1(this, "watchList", []);
    _defineProperty$1(this, "registerWatch", function(callback) {
      _this.watchList.push(callback);
      return function() {
        _this.watchList = _this.watchList.filter(function(fn) {
          return fn !== callback;
        });
      };
    });
    _defineProperty$1(this, "notifyWatch", function() {
      var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (_this.watchList.length) {
        var values = _this.getFieldsValue();
        var allValues = _this.getFieldsValue(true);
        _this.watchList.forEach(function(callback) {
          callback(values, allValues, namePath);
        });
      }
    });
    _defineProperty$1(this, "timeoutId", null);
    _defineProperty$1(this, "warningUnhooked", function() {
    });
    _defineProperty$1(this, "updateStore", function(nextStore) {
      _this.store = nextStore;
    });
    _defineProperty$1(this, "getFieldEntities", function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!pure) {
        return _this.fieldEntities;
      }
      return _this.fieldEntities.filter(function(field) {
        return field.getNamePath().length;
      });
    });
    _defineProperty$1(this, "getFieldsMap", function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var cache = new NameMap();
      _this.getFieldEntities(pure).forEach(function(field) {
        var namePath = field.getNamePath();
        cache.set(namePath, field);
      });
      return cache;
    });
    _defineProperty$1(this, "getFieldEntitiesForNamePathList", function(nameList) {
      if (!nameList) {
        return _this.getFieldEntities(true);
      }
      var cache = _this.getFieldsMap(true);
      return nameList.map(function(name) {
        var namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    });
    _defineProperty$1(this, "getFieldsValue", function(nameList, filterFunc) {
      _this.warningUnhooked();
      var mergedNameList;
      var mergedFilterFunc;
      var mergedStrict;
      if (nameList === true || Array.isArray(nameList)) {
        mergedNameList = nameList;
        mergedFilterFunc = filterFunc;
      } else if (nameList && _typeof(nameList) === "object") {
        mergedStrict = nameList.strict;
        mergedFilterFunc = nameList.filter;
      }
      if (mergedNameList === true && !mergedFilterFunc) {
        return _this.store;
      }
      var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
      var filteredNameList = [];
      fieldEntities.forEach(function(entity) {
        var _isListField, _ref3;
        var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
        if (mergedStrict) {
          var _isList, _ref2;
          if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {
            return;
          }
        } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {
          return;
        }
        if (!mergedFilterFunc) {
          filteredNameList.push(namePath);
        } else {
          var meta = "getMeta" in entity ? entity.getMeta() : null;
          if (mergedFilterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
    });
    _defineProperty$1(this, "getFieldValue", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      return get(_this.store, namePath);
    });
    _defineProperty$1(this, "getFieldsError", function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map(function(entity, index2) {
        if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index2]),
          errors: [],
          warnings: []
        };
      });
    });
    _defineProperty$1(this, "getFieldError", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.errors;
    });
    _defineProperty$1(this, "getFieldWarning", function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    });
    _defineProperty$1(this, "isFieldsTouched", function() {
      _this.warningUnhooked();
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var arg0 = args[0], arg1 = args[1];
      var namePathList;
      var isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      var fieldEntities = _this.getFieldEntities(true);
      var isFieldTouched = function isFieldTouched2(field) {
        return field.isFieldTouched();
      };
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
      }
      var map = new NameMap();
      namePathList.forEach(function(shortNamePath) {
        map.set(shortNamePath, []);
      });
      fieldEntities.forEach(function(field) {
        var fieldNamePath = field.getNamePath();
        namePathList.forEach(function(shortNamePath) {
          if (shortNamePath.every(function(nameUnit, i) {
            return fieldNamePath[i] === nameUnit;
          })) {
            map.update(shortNamePath, function(list) {
              return [].concat(_toConsumableArray(list), [field]);
            });
          }
        });
      });
      var isNamePathListTouched = function isNamePathListTouched2(entities) {
        return entities.some(isFieldTouched);
      };
      var namePathListEntities = map.map(function(_ref4) {
        var value = _ref4.value;
        return value;
      });
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    });
    _defineProperty$1(this, "isFieldTouched", function(name) {
      _this.warningUnhooked();
      return _this.isFieldsTouched([name]);
    });
    _defineProperty$1(this, "isFieldsValidating", function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some(function(testField) {
          return testField.isFieldValidating();
        });
      }
      var namePathList = nameList.map(getNamePath);
      return fieldEntities.some(function(testField) {
        var fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    });
    _defineProperty$1(this, "isFieldValidating", function(name) {
      _this.warningUnhooked();
      return _this.isFieldsValidating([name]);
    });
    _defineProperty$1(this, "resetWithFieldInitialValue", function() {
      var info2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var cache = new NameMap();
      var fieldEntities = _this.getFieldEntities(true);
      fieldEntities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        var namePath = field.getNamePath();
        if (initialValue !== void 0) {
          var records = cache.get(namePath) || /* @__PURE__ */ new Set();
          records.add({
            entity: field,
            value: initialValue
          });
          cache.set(namePath, records);
        }
      });
      var resetWithFields = function resetWithFields2(entities) {
        entities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          if (initialValue !== void 0) {
            var namePath = field.getNamePath();
            var formInitialValue = _this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
            } else {
              var records = cache.get(namePath);
              if (records && records.size > 1) {
                warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
              } else if (records) {
                var originValue = _this.getFieldValue(namePath);
                var isListField = field.isListField();
                if (!isListField && (!info2.skipExist || originValue === void 0)) {
                  _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                }
              }
            }
          }
        });
      };
      var requiredFieldEntities;
      if (info2.entities) {
        requiredFieldEntities = info2.entities;
      } else if (info2.namePathList) {
        requiredFieldEntities = [];
        info2.namePathList.forEach(function(namePath) {
          var records = cache.get(namePath);
          if (records) {
            var _requiredFieldEntitie;
            (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r) {
              return r.entity;
            })));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    });
    _defineProperty$1(this, "resetFields", function(nameList) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (!nameList) {
        _this.updateStore(merge$1(_this.initialValues));
        _this.resetWithFieldInitialValue();
        _this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        _this.notifyWatch();
        return;
      }
      var namePathList = nameList.map(getNamePath);
      namePathList.forEach(function(namePath) {
        var initialValue = _this.getInitialValue(namePath);
        _this.updateStore(set(_this.store, namePath, initialValue));
      });
      _this.resetWithFieldInitialValue({
        namePathList
      });
      _this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      _this.notifyWatch(namePathList);
    });
    _defineProperty$1(this, "setFields", function(fields) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      var namePathList = [];
      fields.forEach(function(fieldData) {
        var name = fieldData.name, data = _objectWithoutProperties$8(fieldData, _excluded$A);
        var namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data) {
          _this.updateStore(set(_this.store, namePath, data.value));
        }
        _this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      _this.notifyWatch(namePathList);
    });
    _defineProperty$1(this, "getFields", function() {
      var entities = _this.getFieldEntities(true);
      var fields = entities.map(function(field) {
        var namePath = field.getNamePath();
        var meta = field.getMeta();
        var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
          name: namePath,
          value: _this.getFieldValue(namePath)
        });
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    });
    _defineProperty$1(this, "initEntityValue", function(entity) {
      var initialValue = entity.props.initialValue;
      if (initialValue !== void 0) {
        var namePath = entity.getNamePath();
        var prevValue = get(_this.store, namePath);
        if (prevValue === void 0) {
          _this.updateStore(set(_this.store, namePath, initialValue));
        }
      }
    });
    _defineProperty$1(this, "isMergedPreserve", function(fieldPreserve) {
      var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
    });
    _defineProperty$1(this, "registerField", function(entity) {
      _this.fieldEntities.push(entity);
      var namePath = entity.getNamePath();
      _this.notifyWatch([namePath]);
      if (entity.props.initialValue !== void 0) {
        var prevStore = _this.store;
        _this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        _this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return function(isListField, preserve) {
        var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        _this.fieldEntities = _this.fieldEntities.filter(function(item) {
          return item !== entity;
        });
        if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
          var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
            return (
              // Only reset when no namePath exist
              !matchNamePath(field.getNamePath(), namePath)
            );
          })) {
            var _prevStore = _this.store;
            _this.updateStore(set(_prevStore, namePath, defaultValue, true));
            _this.notifyObservers(_prevStore, [namePath], {
              type: "remove"
            });
            _this.triggerDependenciesUpdate(_prevStore, namePath);
          }
        }
        _this.notifyWatch([namePath]);
      };
    });
    _defineProperty$1(this, "dispatch", function(action) {
      switch (action.type) {
        case "updateValue": {
          var namePath = action.namePath, value = action.value;
          _this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          var _namePath = action.namePath, triggerName = action.triggerName;
          _this.validateFields([_namePath], {
            triggerName
          });
          break;
        }
      }
    });
    _defineProperty$1(this, "notifyObservers", function(prevStore, namePathList, info2) {
      if (_this.subscribable) {
        var mergedInfo = _objectSpread2(_objectSpread2({}, info2), {}, {
          store: _this.getFieldsValue(true)
        });
        _this.getFieldEntities().forEach(function(_ref5) {
          var onStoreChange = _ref5.onStoreChange;
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        _this.forceRootUpdate();
      }
    });
    _defineProperty$1(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
      var childrenFields = _this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        _this.validateFields(childrenFields);
      }
      _this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
      });
      return childrenFields;
    });
    _defineProperty$1(this, "updateValue", function(name, value) {
      var namePath = getNamePath(name);
      var prevStore = _this.store;
      _this.updateStore(set(_this.store, namePath, value));
      _this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      _this.notifyWatch([namePath]);
      var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
      var onValuesChange = _this.callbacks.onValuesChange;
      if (onValuesChange) {
        var changedValues = cloneByNamePathList(_this.store, [namePath]);
        onValuesChange(changedValues, _this.getFieldsValue());
      }
      _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
    });
    _defineProperty$1(this, "setFieldsValue", function(store) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (store) {
        var nextStore = merge$1(_this.store, store);
        _this.updateStore(nextStore);
      }
      _this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      _this.notifyWatch();
    });
    _defineProperty$1(this, "setFieldValue", function(name, value) {
      _this.setFields([{
        name,
        value
      }]);
    });
    _defineProperty$1(this, "getDependencyChildrenFields", function(rootNamePath) {
      var children = /* @__PURE__ */ new Set();
      var childrenFields = [];
      var dependencies2fields = new NameMap();
      _this.getFieldEntities().forEach(function(field) {
        var dependencies = field.props.dependencies;
        (dependencies || []).forEach(function(dependency) {
          var dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, function() {
            var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
            fields.add(field);
            return fields;
          });
        });
      });
      var fillChildren = function fillChildren2(namePath) {
        var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
        fields.forEach(function(field) {
          if (!children.has(field)) {
            children.add(field);
            var fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren2(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    });
    _defineProperty$1(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
      var onFieldsChange = _this.callbacks.onFieldsChange;
      if (onFieldsChange) {
        var fields = _this.getFields();
        if (filedErrors) {
          var cache = new NameMap();
          filedErrors.forEach(function(_ref6) {
            var name = _ref6.name, errors = _ref6.errors;
            cache.set(name, errors);
          });
          fields.forEach(function(field) {
            field.errors = cache.get(field.name) || field.errors;
          });
        }
        var changedFields = fields.filter(function(_ref7) {
          var fieldName = _ref7.name;
          return containsNamePath(namePathList, fieldName);
        });
        if (changedFields.length) {
          onFieldsChange(changedFields, fields);
        }
      }
    });
    _defineProperty$1(this, "validateFields", function(arg1, arg2) {
      var _options;
      _this.warningUnhooked();
      var nameList;
      var options;
      if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
        nameList = arg1;
        options = arg2;
      } else {
        options = arg1;
      }
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? nameList.map(getNamePath) : [];
      var promiseList = [];
      var TMP_SPLIT = String(Date.now());
      var validateNamePathList = /* @__PURE__ */ new Set();
      var recursive = (_options = options) === null || _options === void 0 ? void 0 : _options.recursive;
      _this.getFieldEntities(true).forEach(function(field) {
        if (!provideNameList) {
          namePathList.push(field.getNamePath());
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        var fieldNamePath = field.getNamePath();
        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
          var promise = field.validateRules(_objectSpread2({
            validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var _ruleErrors$forEach;
            var mergedErrors = [];
            var mergedWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref8) {
              var warningOnly = _ref8.rule.warningOnly, errors = _ref8.errors;
              if (warningOnly) {
                mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
              } else {
                mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      var summaryPromise = allPromiseFinish(promiseList);
      _this.lastValidatePromise = summaryPromise;
      summaryPromise.catch(function(results) {
        return results;
      }).then(function(results) {
        var resultNamePathList = results.map(function(_ref9) {
          var name = _ref9.name;
          return name;
        });
        _this.notifyObservers(_this.store, resultNamePathList, {
          type: "validateFinish"
        });
        _this.triggerOnFieldsChange(resultNamePathList, results);
      });
      var returnPromise = summaryPromise.then(function() {
        if (_this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(_this.getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch(function(results) {
        var errorList = results.filter(function(result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: _this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: _this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch(function(e2) {
        return e2;
      });
      var triggerNamePathList = namePathList.filter(function(namePath) {
        return validateNamePathList.has(namePath.join(TMP_SPLIT));
      });
      _this.triggerOnFieldsChange(triggerNamePathList);
      return returnPromise;
    });
    _defineProperty$1(this, "submit", function() {
      _this.warningUnhooked();
      _this.validateFields().then(function(values) {
        var onFinish = _this.callbacks.onFinish;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch(function(e2) {
        var onFinishFailed = _this.callbacks.onFinishFailed;
        if (onFinishFailed) {
          onFinishFailed(e2);
        }
      });
    });
    this.forceRootUpdate = forceRootUpdate;
  });
  function useForm(form) {
    var formRef = React__namespace.useRef();
    var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        var forceReRender = function forceReRender2() {
          forceUpdate({});
        };
        var formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  }
  var FormContext = /* @__PURE__ */ React__namespace.createContext({
    triggerFormChange: function triggerFormChange() {
    },
    triggerFormFinish: function triggerFormFinish() {
    },
    registerForm: function registerForm() {
    },
    unregisterForm: function unregisterForm() {
    }
  });
  var FormProvider = function FormProvider2(_ref) {
    var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
    var formContext = React__namespace.useContext(FormContext);
    var formsRef = React__namespace.useRef({});
    return /* @__PURE__ */ React__namespace.createElement(FormContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, formContext), {}, {
        validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
        // =========================================================
        // =                  Global Form Control                  =
        // =========================================================
        triggerFormChange: function triggerFormChange2(name, changedFields) {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: function triggerFormFinish2(name, values) {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: function registerForm2(name, form) {
          if (name) {
            formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty$1({}, name, form));
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: function unregisterForm2(name) {
          var newForms = _objectSpread2({}, formsRef.current);
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      })
    }, children);
  };
  var _excluded$z = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
  var Form = function Form2(_ref, ref) {
    var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties$8(_ref, _excluded$z);
    var formContext = React__namespace.useContext(FormContext);
    var _useForm = useForm(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
    var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
    React__namespace.useImperativeHandle(ref, function() {
      return formInstance;
    });
    React__namespace.useEffect(function() {
      formContext.registerForm(name, formInstance);
      return function() {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]);
    setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
    setCallbacks({
      onValuesChange,
      onFieldsChange: function onFieldsChange(changedFields) {
        formContext.triggerFormChange(name, changedFields);
        if (_onFieldsChange) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          _onFieldsChange.apply(void 0, [changedFields].concat(rest));
        }
      },
      onFinish: function onFinish(values) {
        formContext.triggerFormFinish(name, values);
        if (_onFinish) {
          _onFinish(values);
        }
      },
      onFinishFailed
    });
    setPreserve(preserve);
    var mountRef = React__namespace.useRef(null);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    React__namespace.useEffect(
      function() {
        return destroyForm;
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    var childrenNode;
    var childrenRenderProps = typeof children === "function";
    if (childrenRenderProps) {
      var _values = formInstance.getFieldsValue(true);
      childrenNode = children(_values, formInstance);
    } else {
      childrenNode = children;
    }
    useSubscribe(!childrenRenderProps);
    var prevFieldsRef = React__namespace.useRef();
    React__namespace.useEffect(function() {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }
      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    var formContextValue = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, formInstance), {}, {
        validateTrigger
      });
    }, [formInstance, validateTrigger]);
    var wrapperNode = /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
      value: null
    }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: formContextValue
    }, childrenNode));
    if (Component2 === false) {
      return wrapperNode;
    }
    return /* @__PURE__ */ React__namespace.createElement(Component2, _extends$7({}, restProps, {
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: function onReset(event) {
        var _restProps$onReset;
        event.preventDefault();
        formInstance.resetFields();
        (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
      }
    }), wrapperNode);
  };
  function stringify$2(value) {
    try {
      return JSON.stringify(value);
    } catch (err) {
      return Math.random();
    }
  }
  function useWatch$1() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, _args$2 = args[1], _form = _args$2 === void 0 ? {} : _args$2;
    var options = isFormInstance(_form) ? {
      form: _form
    } : _form;
    var form = options.form;
    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
    var valueStr = React.useMemo(function() {
      return stringify$2(value);
    }, [value]);
    var valueStrRef = React.useRef(valueStr);
    valueStrRef.current = valueStr;
    var fieldContext = React.useContext(Context);
    var formInstance = form || fieldContext;
    var isValidForm = formInstance && formInstance._init;
    var namePath = getNamePath(dependencies);
    var namePathRef = React.useRef(namePath);
    namePathRef.current = namePath;
    React.useEffect(
      function() {
        if (!isValidForm) {
          return;
        }
        var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
        var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
        var cancelRegister = registerWatch(function(values, allValues) {
          var newValue = get(options.preserve ? allValues : values, namePathRef.current);
          var nextValueStr = stringify$2(newValue);
          if (valueStrRef.current !== nextValueStr) {
            valueStrRef.current = nextValueStr;
            setValue(newValue);
          }
        });
        var initialValue = get(options.preserve ? getFieldsValue(true) : getFieldsValue(), namePathRef.current);
        if (value !== initialValue) {
          setValue(initialValue);
        }
        return cancelRegister;
      },
      // We do not need re-register since namePath content is the same
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [isValidForm]
    );
    return value;
  }
  var InternalForm = /* @__PURE__ */ React__namespace.forwardRef(Form);
  var RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = WrapperField;
  RefForm.List = List$1;
  RefForm.useForm = useForm;
  RefForm.useWatch = useWatch$1;
  const FormItemInputContext = /* @__PURE__ */ React__namespace.createContext({});
  const NoFormStyle = (_ref) => {
    let {
      children,
      status,
      override
    } = _ref;
    const formItemInputContext = React.useContext(FormItemInputContext);
    const newFormItemInputContext = React.useMemo(() => {
      const newContext = Object.assign({}, formItemInputContext);
      if (override) {
        delete newContext.isFormItemInput;
      }
      if (status) {
        delete newContext.status;
        delete newContext.hasFeedback;
        delete newContext.feedbackIcon;
      }
      return newContext;
    }, [status, override, formItemInputContext]);
    return /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
      value: newFormItemInputContext
    }, children);
  };
  function voidFunc() {
  }
  const WatermarkContext = /* @__PURE__ */ React__namespace.createContext({
    add: voidFunc,
    remove: voidFunc
  });
  function usePanelRef(panelSelector) {
    const watermark = React__namespace.useContext(WatermarkContext);
    const panelEleRef = React__namespace.useRef();
    const panelRef = useEvent((ele) => {
      if (ele) {
        const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
        watermark.add(innerContentEle);
        panelEleRef.current = innerContentEle;
      } else {
        watermark.remove(panelEleRef.current);
      }
    });
    return panelRef;
  }
  const initMotionCommon = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotionCommonLeave = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
    let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
        animationPlayState: "paused"
      }),
      [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
        animationPlayState: "paused"
      }),
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };
  const fadeIn = new Keyframe("antFadeIn", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  const fadeOut = new Keyframe("antFadeOut", {
    "0%": {
      opacity: 1
    },
    "100%": {
      opacity: 0
    }
  });
  const initFadeMotion = function(token2) {
    let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-fade`;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }];
  };
  const moveDownIn = new Keyframe("antMoveDownIn", {
    "0%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut = new Keyframe("antMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveLeftIn = new Keyframe("antMoveLeftIn", {
    "0%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveLeftOut = new Keyframe("antMoveLeftOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveRightIn = new Keyframe("antMoveRightIn", {
    "0%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveRightOut = new Keyframe("antMoveRightOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveUpIn = new Keyframe("antMoveUpIn", {
    "0%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveUpOut = new Keyframe("antMoveUpOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveMotion = {
    "move-up": {
      inKeyframes: moveUpIn,
      outKeyframes: moveUpOut
    },
    "move-down": {
      inKeyframes: moveDownIn,
      outKeyframes: moveDownOut
    },
    "move-left": {
      inKeyframes: moveLeftIn,
      outKeyframes: moveLeftOut
    },
    "move-right": {
      inKeyframes: moveRightIn,
      outKeyframes: moveRightOut
    }
  };
  const initMoveMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = moveMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const slideUpIn = new Keyframe("antSlideUpIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideUpOut = new Keyframe("antSlideUpOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideDownIn = new Keyframe("antSlideDownIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    }
  });
  const slideDownOut = new Keyframe("antSlideDownOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    }
  });
  const slideLeftIn = new Keyframe("antSlideLeftIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideLeftOut = new Keyframe("antSlideLeftOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideRightIn = new Keyframe("antSlideRightIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    }
  });
  const slideRightOut = new Keyframe("antSlideRightOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    }
  });
  const slideMotion = {
    "slide-up": {
      inKeyframes: slideUpIn,
      outKeyframes: slideUpOut
    },
    "slide-down": {
      inKeyframes: slideDownIn,
      outKeyframes: slideDownOut
    },
    "slide-left": {
      inKeyframes: slideLeftIn,
      outKeyframes: slideLeftOut
    },
    "slide-right": {
      inKeyframes: slideRightIn,
      outKeyframes: slideRightOut
    }
  };
  const initSlideMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = slideMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
        transform: "scale(0)",
        transformOrigin: "0% 0%",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutQuint,
        [`&-prepare`]: {
          transform: "scale(1)"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInQuint
      }
    }];
  };
  const zoomIn = new Keyframe("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomOut = new Keyframe("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  const zoomBigIn = new Keyframe("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomBigOut = new Keyframe("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  const zoomUpIn = new Keyframe("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  const zoomUpOut = new Keyframe("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  const zoomLeftIn = new Keyframe("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  const zoomLeftOut = new Keyframe("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  const zoomRightIn = new Keyframe("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  const zoomRightOut = new Keyframe("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  const zoomDownIn = new Keyframe("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  const zoomDownOut = new Keyframe("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  const zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  const initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  function withPureRenderTheme(Component2) {
    return function PureRenderThemeComponent(props) {
      return /* @__PURE__ */ React__namespace.createElement(ConfigProvider, {
        theme: {
          token: {
            motion: false,
            zIndexPopupBase: 0
          }
        }
      }, /* @__PURE__ */ React__namespace.createElement(Component2, Object.assign({}, props)));
    };
  }
  function genPurePanel(Component2, defaultPrefixCls2, getDropdownCls, postProps) {
    function PurePanel2(props) {
      const {
        prefixCls: customizePrefixCls,
        style: style2
      } = props;
      const holderRef = React__namespace.useRef(null);
      const [popupHeight, setPopupHeight] = React__namespace.useState(0);
      const [popupWidth, setPopupWidth] = React__namespace.useState(0);
      const [open2, setOpen] = useMergedState(false, {
        value: props.open
      });
      const {
        getPrefixCls
      } = React__namespace.useContext(ConfigContext);
      const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
      React__namespace.useEffect(() => {
        setOpen(true);
        if (typeof ResizeObserver !== "undefined") {
          const resizeObserver2 = new ResizeObserver((entries) => {
            const element = entries[0].target;
            setPopupHeight(element.offsetHeight + 8);
            setPopupWidth(element.offsetWidth);
          });
          const interval = setInterval(() => {
            var _a;
            const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
            const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
            if (popup) {
              clearInterval(interval);
              resizeObserver2.observe(popup);
            }
          }, 10);
          return () => {
            clearInterval(interval);
            resizeObserver2.disconnect();
          };
        }
      }, []);
      let mergedProps = Object.assign(Object.assign({}, props), {
        style: Object.assign(Object.assign({}, style2), {
          margin: 0
        }),
        open: open2,
        visible: open2,
        getPopupContainer: () => holderRef.current
      });
      if (postProps) {
        mergedProps = postProps(mergedProps);
      }
      return /* @__PURE__ */ React__namespace.createElement("div", {
        ref: holderRef,
        style: {
          paddingBottom: popupHeight,
          position: "relative",
          minWidth: popupWidth
        }
      }, /* @__PURE__ */ React__namespace.createElement(Component2, Object.assign({}, mergedProps)));
    }
    return withPureRenderTheme(PurePanel2);
  }
  const isMobile = function() {
    if (typeof navigator === "undefined" || typeof window === "undefined") {
      return false;
    }
    var agent = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
  };
  var TransBtn = function TransBtn2(_ref) {
    var className = _ref.className, customizeIcon = _ref.customizeIcon, customizeIconProps = _ref.customizeIconProps, _onMouseDown = _ref.onMouseDown, onClick = _ref.onClick, children = _ref.children;
    var icon2;
    if (typeof customizeIcon === "function") {
      icon2 = customizeIcon(customizeIconProps);
    } else {
      icon2 = customizeIcon;
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      className,
      onMouseDown: function onMouseDown(event) {
        event.preventDefault();
        if (_onMouseDown) {
          _onMouseDown(event);
        }
      },
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      },
      unselectable: "on",
      onClick,
      "aria-hidden": true
    }, icon2 !== void 0 ? icon2 : /* @__PURE__ */ React__namespace.createElement("span", {
      className: classname(className.split(/\s+/).map(function(cls) {
        return "".concat(cls, "-icon");
      }))
    }, children));
  };
  function useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
    var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    var mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0;
    var mode = arguments.length > 7 ? arguments[7] : void 0;
    var mergedClearIcon = React.useMemo(function() {
      if (_typeof(allowClear) === "object") {
        return allowClear.clearIcon;
      }
      if (!!clearIcon)
        return clearIcon;
    }, [allowClear, clearIcon]);
    var mergedAllowClear = React.useMemo(function() {
      if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
        return true;
      }
      return false;
    }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
    return {
      allowClear: mergedAllowClear,
      clearIcon: /* @__PURE__ */ React.createElement(TransBtn, {
        className: "".concat(prefixCls, "-clear"),
        onMouseDown: onClearMouseDown,
        customizeIcon: mergedClearIcon
      }, "×")
    };
  }
  var BaseSelectContext = /* @__PURE__ */ React__namespace.createContext(null);
  function useBaseProps() {
    return React__namespace.useContext(BaseSelectContext);
  }
  function useDelayReset() {
    var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
    var delayRef = React__namespace.useRef(null);
    var cancelLatest = function cancelLatest2() {
      window.clearTimeout(delayRef.current);
    };
    React__namespace.useEffect(function() {
      return cancelLatest;
    }, []);
    var delaySetBool = function delaySetBool2(value, callback) {
      cancelLatest();
      delayRef.current = window.setTimeout(function() {
        setBool(value);
        if (callback) {
          callback();
        }
      }, timeout);
    };
    return [bool, delaySetBool, cancelLatest];
  }
  function useLock() {
    var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
    var lockRef = React__namespace.useRef(null);
    var timeoutRef = React__namespace.useRef(null);
    React__namespace.useEffect(function() {
      return function() {
        window.clearTimeout(timeoutRef.current);
      };
    }, []);
    function doLock(locked) {
      if (locked || lockRef.current === null) {
        lockRef.current = locked;
      }
      window.clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(function() {
        lockRef.current = null;
      }, duration);
    }
    return [function() {
      return lockRef.current;
    }, doLock];
  }
  function useSelectTriggerControl(elements, open2, triggerOpen, customizedTrigger) {
    var propsRef = React__namespace.useRef(null);
    propsRef.current = {
      open: open2,
      triggerOpen,
      customizedTrigger
    };
    React__namespace.useEffect(function() {
      function onGlobalMouseDown(event) {
        var _propsRef$current;
        if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
          return;
        }
        var target = event.target;
        if (target.shadowRoot && event.composed) {
          target = event.composedPath()[0] || target;
        }
        if (propsRef.current.open && elements().filter(function(element) {
          return element;
        }).every(function(element) {
          return !element.contains(target) && element !== target;
        })) {
          propsRef.current.triggerOpen(false);
        }
      }
      window.addEventListener("mousedown", onGlobalMouseDown);
      return function() {
        return window.removeEventListener("mousedown", onGlobalMouseDown);
      };
    }, []);
  }
  var _excluded$y = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
  var UNDEFINED = void 0;
  function InternalItem(props, ref) {
    var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$8(props, _excluded$y);
    var mergedHidden = responsive && !display;
    function internalRegisterSize(width) {
      registerSize(itemKey2, width);
    }
    React__namespace.useEffect(function() {
      return function() {
        internalRegisterSize(null);
      };
    }, []);
    var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
    var overflowStyle;
    if (!invalidate) {
      overflowStyle = {
        opacity: mergedHidden ? 0 : 1,
        height: mergedHidden ? 0 : UNDEFINED,
        overflowY: mergedHidden ? "hidden" : UNDEFINED,
        order: responsive ? order : UNDEFINED,
        pointerEvents: mergedHidden ? "none" : UNDEFINED,
        position: mergedHidden ? "absolute" : UNDEFINED
      };
    }
    var overflowProps = {};
    if (mergedHidden) {
      overflowProps["aria-hidden"] = true;
    }
    var itemNode = /* @__PURE__ */ React__namespace.createElement(Component2, _extends$7({
      className: classname(!invalidate && prefixCls, className),
      style: _objectSpread2(_objectSpread2({}, overflowStyle), style2)
    }, overflowProps, restProps, {
      ref
    }), childNode);
    if (responsive) {
      itemNode = /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
        onResize: function onResize2(_ref) {
          var offsetWidth = _ref.offsetWidth;
          internalRegisterSize(offsetWidth);
        },
        disabled: responsiveDisabled
      }, itemNode);
    }
    return itemNode;
  }
  var Item$1 = /* @__PURE__ */ React__namespace.forwardRef(InternalItem);
  Item$1.displayName = "Item";
  function channelUpdate(callback) {
    if (typeof MessageChannel === "undefined") {
      wrapperRaf(callback);
    } else {
      var channel = new MessageChannel();
      channel.port1.onmessage = function() {
        return callback();
      };
      channel.port2.postMessage(void 0);
    }
  }
  function useBatcher() {
    var updateFuncRef = React__namespace.useRef(null);
    var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
      if (!updateFuncRef.current) {
        updateFuncRef.current = [];
        channelUpdate(function() {
          ReactDOM__default.unstable_batchedUpdates(function() {
            updateFuncRef.current.forEach(function(fn) {
              fn();
            });
            updateFuncRef.current = null;
          });
        });
      }
      updateFuncRef.current.push(callback);
    };
    return notifyEffectUpdate;
  }
  function useEffectState(notifyEffectUpdate, defaultValue) {
    var _React$useState = React__namespace.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
    var setEffectVal = useEvent(function(nextValue) {
      notifyEffectUpdate(function() {
        setStateValue(nextValue);
      });
    });
    return [stateValue, setEffectVal];
  }
  var OverflowContext = /* @__PURE__ */ React.createContext(null);
  var _excluded$x = ["component"], _excluded2$6 = ["className"], _excluded3$1 = ["className"];
  var InternalRawItem = function InternalRawItem2(props, ref) {
    var context2 = React__namespace.useContext(OverflowContext);
    if (!context2) {
      var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$8(props, _excluded$x);
      return /* @__PURE__ */ React__namespace.createElement(Component2, _extends$7({}, _restProps, {
        ref
      }));
    }
    var contextClassName = context2.className, restContext = _objectWithoutProperties$8(context2, _excluded2$6);
    var className = props.className, restProps = _objectWithoutProperties$8(props, _excluded3$1);
    return /* @__PURE__ */ React__namespace.createElement(OverflowContext.Provider, {
      value: null
    }, /* @__PURE__ */ React__namespace.createElement(Item$1, _extends$7({
      ref,
      className: classname(contextClassName, className)
    }, restContext, restProps)));
  };
  var RawItem = /* @__PURE__ */ React__namespace.forwardRef(InternalRawItem);
  RawItem.displayName = "RawItem";
  var _excluded$w = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
  var RESPONSIVE = "responsive";
  var INVALIDATE = "invalidate";
  function defaultRenderRest(omittedItems) {
    return "+ ".concat(omittedItems.length, " ...");
  }
  function Overflow(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$8(props, _excluded$w);
    var fullySSR = ssr === "full";
    var notifyEffectUpdate = useBatcher();
    var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
    var mergedContainerWidth = containerWidth || 0;
    var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
    var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
    var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
    var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
    var _useState = React.useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
    var _useState3 = React.useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
    var mergedDisplayCount = React__namespace.useMemo(function() {
      if (displayCount === null && fullySSR) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount || 0;
    }, [displayCount, containerWidth]);
    var _useState5 = React.useState(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
    var itemPrefixCls = "".concat(prefixCls, "-item");
    var mergedRestWidth = Math.max(prevRestWidth, restWidth);
    var isResponsive = maxCount === RESPONSIVE;
    var shouldResponsive = data.length && isResponsive;
    var invalidate = maxCount === INVALIDATE;
    var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
    var mergedData = React.useMemo(function() {
      var items = data;
      if (shouldResponsive) {
        if (containerWidth === null && fullySSR) {
          items = data;
        } else {
          items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
        }
      } else if (typeof maxCount === "number") {
        items = data.slice(0, maxCount);
      }
      return items;
    }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
    var omittedItems = React.useMemo(function() {
      if (shouldResponsive) {
        return data.slice(mergedDisplayCount + 1);
      }
      return data.slice(mergedData.length);
    }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
    var getKey2 = React.useCallback(function(item, index2) {
      var _ref;
      if (typeof itemKey2 === "function") {
        return itemKey2(item);
      }
      return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
    }, [itemKey2]);
    var mergedRenderItem = React.useCallback(renderItem || function(item) {
      return item;
    }, [renderItem]);
    function updateDisplayCount(count, suffixFixedStartVal, notReady) {
      if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
        return;
      }
      setDisplayCount(count);
      if (!notReady) {
        setRestReady(count < data.length - 1);
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
      }
      if (suffixFixedStartVal !== void 0) {
        setSuffixFixedStart(suffixFixedStartVal);
      }
    }
    function onOverflowResize(_, element) {
      setContainerWidth(element.clientWidth);
    }
    function registerSize(key, width) {
      setItemWidths(function(origin) {
        var clone = new Map(origin);
        if (width === null) {
          clone.delete(key);
        } else {
          clone.set(key, width);
        }
        return clone;
      });
    }
    function registerOverflowSize(_, width) {
      setRestWidth(width);
      setPrevRestWidth(restWidth);
    }
    function registerSuffixSize(_, width) {
      setSuffixWidth(width);
    }
    function getItemWidth(index2) {
      return itemWidths.get(getKey2(mergedData[index2], index2));
    }
    useLayoutEffect$1(function() {
      if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
        var totalWidth = suffixWidth;
        var len = mergedData.length;
        var lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0, null);
          return;
        }
        for (var i = 0; i < len; i += 1) {
          var currentItemWidth = getItemWidth(i);
          if (fullySSR) {
            currentItemWidth = currentItemWidth || 0;
          }
          if (currentItemWidth === void 0) {
            updateDisplayCount(i - 1, void 0, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (
            // Only one means `totalWidth` is the final width
            lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
            i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
          ) {
            updateDisplayCount(lastIndex, null);
            break;
          } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
            updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
            break;
          }
        }
        if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
          setSuffixFixedStart(null);
        }
      }
    }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
    var displayRest = restReady && !!omittedItems.length;
    var suffixStyle = {};
    if (suffixFixedStart !== null && shouldResponsive) {
      suffixStyle = {
        position: "absolute",
        left: suffixFixedStart,
        top: 0
      };
    }
    var itemSharedProps = {
      prefixCls: itemPrefixCls,
      responsive: shouldResponsive,
      component: itemComponent,
      invalidate
    };
    var internalRenderItemNode = renderRawItem ? function(item, index2) {
      var key = getKey2(item, index2);
      return /* @__PURE__ */ React__namespace.createElement(OverflowContext.Provider, {
        key,
        value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
          order: index2,
          item,
          itemKey: key,
          registerSize,
          display: index2 <= mergedDisplayCount
        })
      }, renderRawItem(item, index2));
    } : function(item, index2) {
      var key = getKey2(item, index2);
      return /* @__PURE__ */ React__namespace.createElement(Item$1, _extends$7({}, itemSharedProps, {
        order: index2,
        key,
        item,
        renderItem: mergedRenderItem,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      }));
    };
    var restNode;
    var restContextProps = {
      order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
      className: "".concat(itemPrefixCls, "-rest"),
      registerSize: registerOverflowSize,
      display: displayRest
    };
    if (!renderRawRest) {
      var mergedRenderRest = renderRest || defaultRenderRest;
      restNode = /* @__PURE__ */ React__namespace.createElement(Item$1, _extends$7({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
    } else if (renderRawRest) {
      restNode = /* @__PURE__ */ React__namespace.createElement(OverflowContext.Provider, {
        value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps)
      }, renderRawRest(omittedItems));
    }
    var overflowNode = /* @__PURE__ */ React__namespace.createElement(Component2, _extends$7({
      className: classname(!invalidate && prefixCls, className),
      style: style2,
      ref
    }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React__namespace.createElement(Item$1, _extends$7({}, itemSharedProps, {
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: mergedDisplayCount,
      className: "".concat(itemPrefixCls, "-suffix"),
      registerSize: registerSuffixSize,
      display: true,
      style: suffixStyle
    }), suffix));
    if (isResponsive) {
      overflowNode = /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
        onResize: onOverflowResize,
        disabled: !shouldResponsive
      }, overflowNode);
    }
    return overflowNode;
  }
  var ForwardOverflow = /* @__PURE__ */ React__namespace.forwardRef(Overflow);
  ForwardOverflow.displayName = "Overflow";
  ForwardOverflow.Item = RawItem;
  ForwardOverflow.RESPONSIVE = RESPONSIVE;
  ForwardOverflow.INVALIDATE = INVALIDATE;
  var Input$5 = function Input(_ref, ref) {
    var _inputNode2, _inputNode2$props;
    var prefixCls = _ref.prefixCls, id = _ref.id, inputElement = _ref.inputElement, disabled = _ref.disabled, tabIndex = _ref.tabIndex, autoFocus = _ref.autoFocus, autoComplete = _ref.autoComplete, editable = _ref.editable, activeDescendantId = _ref.activeDescendantId, value = _ref.value, maxLength = _ref.maxLength, _onKeyDown = _ref.onKeyDown, _onMouseDown = _ref.onMouseDown, _onChange = _ref.onChange, onPaste = _ref.onPaste, _onCompositionStart = _ref.onCompositionStart, _onCompositionEnd = _ref.onCompositionEnd, open2 = _ref.open, attrs = _ref.attrs;
    var inputNode = inputElement || /* @__PURE__ */ React__namespace.createElement("input", null);
    var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
    var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
    warning$3(!("maxLength" in inputNode.props));
    inputNode = /* @__PURE__ */ React__namespace.cloneElement(inputNode, _objectSpread2(_objectSpread2(_objectSpread2({
      type: "search"
    }, originProps), {}, {
      // Override over origin props
      id,
      ref: composeRef(ref, originRef),
      disabled,
      tabIndex,
      autoComplete: autoComplete || "off",
      autoFocus,
      className: classname("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
      role: "combobox",
      "aria-expanded": open2 || false,
      "aria-haspopup": "listbox",
      "aria-owns": "".concat(id, "_list"),
      "aria-autocomplete": "list",
      "aria-controls": "".concat(id, "_list"),
      "aria-activedescendant": open2 ? activeDescendantId : void 0
    }, attrs), {}, {
      value: editable ? value : "",
      maxLength,
      readOnly: !editable,
      unselectable: !editable ? "on" : null,
      style: _objectSpread2(_objectSpread2({}, style2), {}, {
        opacity: editable ? null : 0
      }),
      onKeyDown: function onKeyDown(event) {
        _onKeyDown(event);
        if (onOriginKeyDown) {
          onOriginKeyDown(event);
        }
      },
      onMouseDown: function onMouseDown(event) {
        _onMouseDown(event);
        if (onOriginMouseDown) {
          onOriginMouseDown(event);
        }
      },
      onChange: function onChange(event) {
        _onChange(event);
        if (onOriginChange) {
          onOriginChange(event);
        }
      },
      onCompositionStart: function onCompositionStart(event) {
        _onCompositionStart(event);
        if (onOriginCompositionStart) {
          onOriginCompositionStart(event);
        }
      },
      onCompositionEnd: function onCompositionEnd(event) {
        _onCompositionEnd(event);
        if (onOriginCompositionEnd) {
          onOriginCompositionEnd(event);
        }
      },
      onPaste
    }));
    return inputNode;
  };
  var RefInput = /* @__PURE__ */ React__namespace.forwardRef(Input$5);
  RefInput.displayName = "Input";
  function toArray$1(value) {
    if (Array.isArray(value)) {
      return value;
    }
    return value !== void 0 ? [value] : [];
  }
  var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
  var isBrowserClient$1 = isClient;
  function hasValue(value) {
    return value !== void 0 && value !== null;
  }
  function isComboNoValue(value) {
    return !value && value !== 0;
  }
  function isTitleType$1(title) {
    return ["string", "number"].includes(_typeof(title));
  }
  function getTitle(item) {
    var title = void 0;
    if (item) {
      if (isTitleType$1(item.title)) {
        title = item.title.toString();
      } else if (isTitleType$1(item.label)) {
        title = item.label.toString();
      }
    }
    return title;
  }
  function useLayoutEffect2(effect, deps) {
    if (isBrowserClient$1) {
      React__namespace.useLayoutEffect(effect, deps);
    } else {
      React__namespace.useEffect(effect, deps);
    }
  }
  function itemKey(value) {
    var _value$key;
    return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
  }
  var onPreventMouseDown = function onPreventMouseDown2(event) {
    event.preventDefault();
    event.stopPropagation();
  };
  var SelectSelector = function SelectSelector2(props) {
    var id = props.id, prefixCls = props.prefixCls, values = props.values, open2 = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
      return "+ ".concat(omittedValues.length, " ...");
    } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
    var measureRef = React__namespace.useRef(null);
    var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
    var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
    var selectionPrefixCls = "".concat(prefixCls, "-selection");
    var inputValue = open2 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
    var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open2 || focused);
    useLayoutEffect2(function() {
      setInputWidth(measureRef.current.scrollWidth);
    }, [inputValue]);
    function defaultRenderSelector(item, content, itemDisabled, closable, onClose) {
      return /* @__PURE__ */ React__namespace.createElement("span", {
        className: classname("".concat(selectionPrefixCls, "-item"), _defineProperty$1({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
        title: getTitle(item)
      }, /* @__PURE__ */ React__namespace.createElement("span", {
        className: "".concat(selectionPrefixCls, "-item-content")
      }, content), closable && /* @__PURE__ */ React__namespace.createElement(TransBtn, {
        className: "".concat(selectionPrefixCls, "-item-remove"),
        onMouseDown: onPreventMouseDown,
        onClick: onClose,
        customizeIcon: removeIcon
      }, "×"));
    }
    function customizeRenderSelector(value, content, itemDisabled, closable, onClose) {
      var onMouseDown = function onMouseDown2(e2) {
        onPreventMouseDown(e2);
        onToggleOpen(!open2);
      };
      return /* @__PURE__ */ React__namespace.createElement("span", {
        onMouseDown
      }, tagRender({
        label: content,
        value,
        disabled: itemDisabled,
        closable,
        onClose
      }));
    }
    function renderItem(valueItem) {
      var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
      var closable = !disabled && !itemDisabled;
      var displayLabel = label;
      if (typeof maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          var strLabel = String(displayLabel);
          if (strLabel.length > maxTagTextLength) {
            displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
          }
        }
      }
      var onClose = function onClose2(event) {
        if (event)
          event.stopPropagation();
        onRemove(valueItem);
      };
      return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
    }
    function renderRest(omittedValues) {
      var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return defaultRenderSelector({
        title: content
      }, content, false);
    }
    var inputNode = /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(selectionPrefixCls, "-search"),
      style: {
        width: inputWidth
      },
      onFocus: function onFocus() {
        setFocused(true);
      },
      onBlur: function onBlur() {
        setFocused(false);
      }
    }, /* @__PURE__ */ React__namespace.createElement(RefInput, {
      ref: inputRef,
      open: open2,
      prefixCls,
      id,
      inputElement: null,
      disabled,
      autoFocus,
      autoComplete,
      editable: inputEditable,
      activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: onInputChange,
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      tabIndex,
      attrs: pickAttrs(props, true)
    }), /* @__PURE__ */ React__namespace.createElement("span", {
      ref: measureRef,
      className: "".concat(selectionPrefixCls, "-search-mirror"),
      "aria-hidden": true
    }, inputValue, " "));
    var selectionNode = /* @__PURE__ */ React__namespace.createElement(ForwardOverflow, {
      prefixCls: "".concat(selectionPrefixCls, "-overflow"),
      data: values,
      renderItem,
      renderRest,
      suffix: inputNode,
      itemKey,
      maxCount: maxTagCount
    });
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ React__namespace.createElement("span", {
      className: "".concat(selectionPrefixCls, "-placeholder")
    }, placeholder));
  };
  var SingleSelector = function SingleSelector2(props) {
    var inputElement = props.inputElement, prefixCls = props.prefixCls, id = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open2 = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, title = props.title;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
    var combobox = mode === "combobox";
    var inputEditable = combobox || showSearch;
    var item = values[0];
    var inputValue = searchValue || "";
    if (combobox && activeValue && !inputChanged) {
      inputValue = activeValue;
    }
    React__namespace.useEffect(function() {
      if (combobox) {
        setInputChanged(false);
      }
    }, [combobox, activeValue]);
    var hasTextInput = mode !== "combobox" && !open2 && !showSearch ? false : !!inputValue;
    var selectionTitle = title === void 0 ? getTitle(item) : title;
    var renderPlaceholder = function renderPlaceholder2() {
      if (item) {
        return null;
      }
      var hiddenStyle = hasTextInput ? {
        visibility: "hidden"
      } : void 0;
      return /* @__PURE__ */ React__namespace.createElement("span", {
        className: "".concat(prefixCls, "-selection-placeholder"),
        style: hiddenStyle
      }, placeholder);
    };
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("span", {
      className: "".concat(prefixCls, "-selection-search")
    }, /* @__PURE__ */ React__namespace.createElement(RefInput, {
      ref: inputRef,
      prefixCls,
      id,
      open: open2,
      inputElement,
      disabled,
      autoFocus,
      autoComplete,
      editable: inputEditable,
      activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: function onChange(e2) {
        setInputChanged(true);
        onInputChange(e2);
      },
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      tabIndex,
      attrs: pickAttrs(props, true),
      maxLength: combobox ? maxLength : void 0
    })), !combobox && item ? /* @__PURE__ */ React__namespace.createElement("span", {
      className: "".concat(prefixCls, "-selection-item"),
      title: selectionTitle,
      style: hasTextInput ? {
        visibility: "hidden"
      } : void 0
    }, item.label) : null, renderPlaceholder());
  };
  function isValidateOpenKey(currentKeyCode) {
    return ![
      // System function button
      KeyCode.ESC,
      KeyCode.SHIFT,
      KeyCode.BACKSPACE,
      KeyCode.TAB,
      KeyCode.WIN_KEY,
      KeyCode.ALT,
      KeyCode.META,
      KeyCode.WIN_KEY_RIGHT,
      KeyCode.CTRL,
      KeyCode.SEMICOLON,
      KeyCode.EQUALS,
      KeyCode.CAPS_LOCK,
      KeyCode.CONTEXT_MENU,
      // F1-F12
      KeyCode.F1,
      KeyCode.F2,
      KeyCode.F3,
      KeyCode.F4,
      KeyCode.F5,
      KeyCode.F6,
      KeyCode.F7,
      KeyCode.F8,
      KeyCode.F9,
      KeyCode.F10,
      KeyCode.F11,
      KeyCode.F12
    ].includes(currentKeyCode);
  }
  var Selector = function Selector2(props, ref) {
    var inputRef = React.useRef(null);
    var compositionStatusRef = React.useRef(false);
    var prefixCls = props.prefixCls, open2 = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
    React__namespace.useImperativeHandle(ref, function() {
      return {
        focus: function focus() {
          inputRef.current.focus();
        },
        blur: function blur() {
          inputRef.current.blur();
        }
      };
    });
    var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
    var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
      var which = event.which;
      if (which === KeyCode.UP || which === KeyCode.DOWN) {
        event.preventDefault();
      }
      if (onInputKeyDown) {
        onInputKeyDown(event);
      }
      if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open2) {
        onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
      }
      if (isValidateOpenKey(which)) {
        onToggleOpen(true);
      }
    };
    var onInternalInputMouseDown = function onInternalInputMouseDown2() {
      setInputMouseDown(true);
    };
    var pastedTextRef = React.useRef(null);
    var triggerOnSearch = function triggerOnSearch2(value) {
      if (onSearch(value, true, compositionStatusRef.current) !== false) {
        onToggleOpen(true);
      }
    };
    var onInputCompositionStart = function onInputCompositionStart2() {
      compositionStatusRef.current = true;
    };
    var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
      compositionStatusRef.current = false;
      if (mode !== "combobox") {
        triggerOnSearch(e2.target.value);
      }
    };
    var onInputChange = function onInputChange2(event) {
      var value = event.target.value;
      if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
        var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        value = value.replace(replacedText, pastedTextRef.current);
      }
      pastedTextRef.current = null;
      triggerOnSearch(value);
    };
    var onInputPaste = function onInputPaste2(e2) {
      var clipboardData = e2.clipboardData;
      var value = clipboardData.getData("text");
      pastedTextRef.current = value;
    };
    var onClick = function onClick2(_ref) {
      var target = _ref.target;
      if (target !== inputRef.current) {
        var isIE = document.body.style.msTouchAction !== void 0;
        if (isIE) {
          setTimeout(function() {
            inputRef.current.focus();
          });
        } else {
          inputRef.current.focus();
        }
      }
    };
    var onMouseDown = function onMouseDown2(event) {
      var inputMouseDown = getInputMouseDown();
      if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
        event.preventDefault();
      }
      if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open2) {
        if (open2 && autoClearSearchValue !== false) {
          onSearch("", true, false);
        }
        onToggleOpen();
      }
    };
    var sharedProps = {
      inputRef,
      onInputKeyDown: onInternalInputKeyDown,
      onInputMouseDown: onInternalInputMouseDown,
      onInputChange,
      onInputPaste,
      onInputCompositionStart,
      onInputCompositionEnd
    };
    var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ React__namespace.createElement(SelectSelector, _extends$7({}, props, sharedProps)) : /* @__PURE__ */ React__namespace.createElement(SingleSelector, _extends$7({}, props, sharedProps));
    return /* @__PURE__ */ React__namespace.createElement("div", {
      ref: domRef,
      className: "".concat(prefixCls, "-selector"),
      onClick,
      onMouseDown
    }, selectNode);
  };
  var ForwardSelector = /* @__PURE__ */ React__namespace.forwardRef(Selector);
  ForwardSelector.displayName = "Selector";
  function Arrow(props) {
    var prefixCls = props.prefixCls, align = props.align, arrow2 = props.arrow, arrowPos = props.arrowPos;
    var _ref = arrow2 || {}, className = _ref.className, content = _ref.content;
    var _arrowPos$x = arrowPos.x, x = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
    var arrowRef = React__namespace.useRef();
    if (!align || !align.points) {
      return null;
    }
    var alignStyle = {
      position: "absolute"
    };
    if (align.autoArrow !== false) {
      var popupPoints = align.points[0];
      var targetPoints = align.points[1];
      var popupTB = popupPoints[0];
      var popupLR = popupPoints[1];
      var targetTB = targetPoints[0];
      var targetLR = targetPoints[1];
      if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
        alignStyle.top = y;
      } else if (popupTB === "t") {
        alignStyle.top = 0;
      } else {
        alignStyle.bottom = 0;
      }
      if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
        alignStyle.left = x;
      } else if (popupLR === "l") {
        alignStyle.left = 0;
      } else {
        alignStyle.right = 0;
      }
    }
    return /* @__PURE__ */ React__namespace.createElement("div", {
      ref: arrowRef,
      className: classname("".concat(prefixCls, "-arrow"), className),
      style: alignStyle
    }, content);
  }
  function Mask(props) {
    var prefixCls = props.prefixCls, open2 = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
    if (!mask) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({}, motion2, {
      motionAppear: true,
      visible: open2,
      removeOnLeave: true
    }), function(_ref) {
      var className = _ref.className;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        style: {
          zIndex
        },
        className: classname("".concat(prefixCls, "-mask"), className)
      });
    });
  }
  var PopupContent = /* @__PURE__ */ React__namespace.memo(function(_ref) {
    var children = _ref.children;
    return children;
  }, function(_, next2) {
    return next2.cache;
  });
  var Popup$1 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open2 = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow2 = props.arrow, arrowPos = props.arrowPos, align = props.align, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
    var childNode = typeof popup === "function" ? popup() : popup;
    var isNodeVisible = open2 || keepDom;
    var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
    var _React$useState = React__namespace.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show2 = _React$useState2[0], setShow = _React$useState2[1];
    useLayoutEffect$1(function() {
      if (!show2 && getPopupContainerNeedParams && target) {
        setShow(true);
      }
    }, [show2, getPopupContainerNeedParams, target]);
    if (!show2) {
      return null;
    }
    var AUTO = "auto";
    var offsetStyle = {
      left: "-1000vw",
      top: "-1000vh",
      right: AUTO,
      bottom: AUTO
    };
    if (ready || !open2) {
      var _experimental;
      var points = align.points;
      var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
      var alignRight = dynamicInset && points[0][1] === "r";
      var alignBottom = dynamicInset && points[0][0] === "b";
      if (alignRight) {
        offsetStyle.right = offsetR;
        offsetStyle.left = AUTO;
      } else {
        offsetStyle.left = offsetX;
        offsetStyle.right = AUTO;
      }
      if (alignBottom) {
        offsetStyle.bottom = offsetB;
        offsetStyle.top = AUTO;
      } else {
        offsetStyle.top = offsetY;
        offsetStyle.bottom = AUTO;
      }
    }
    var miscStyle = {};
    if (stretch) {
      if (stretch.includes("height") && targetHeight) {
        miscStyle.height = targetHeight;
      } else if (stretch.includes("minHeight") && targetHeight) {
        miscStyle.minHeight = targetHeight;
      }
      if (stretch.includes("width") && targetWidth) {
        miscStyle.width = targetWidth;
      } else if (stretch.includes("minWidth") && targetWidth) {
        miscStyle.minWidth = targetWidth;
      }
    }
    if (!open2) {
      miscStyle.pointerEvents = "none";
    }
    return /* @__PURE__ */ React__namespace.createElement(Portal2, {
      open: forceRender || isNodeVisible,
      getContainer: getPopupContainer && function() {
        return getPopupContainer(target);
      },
      autoDestroy
    }, /* @__PURE__ */ React__namespace.createElement(Mask, {
      prefixCls,
      open: open2,
      zIndex,
      mask,
      motion: maskMotion
    }), /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onAlign,
      disabled: !open2
    }, function(resizeObserverRef) {
      return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        removeOnLeave: false,
        forceRender,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }, motion2, {
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        visible: open2,
        onVisibleChanged: function onVisibleChanged(nextVisible) {
          var _motion$onVisibleChan;
          motion2 === null || motion2 === void 0 || (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion2, nextVisible);
          _onVisibleChanged(nextVisible);
        }
      }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        var cls = classname(prefixCls, motionClassName, className);
        return /* @__PURE__ */ React__namespace.createElement("div", {
          ref: composeRef(resizeObserverRef, ref, motionRef),
          className: cls,
          style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
            "--arrow-x": "".concat(arrowPos.x || 0, "px"),
            "--arrow-y": "".concat(arrowPos.y || 0, "px")
          }, offsetStyle), miscStyle), motionStyle), {}, {
            boxSizing: "border-box",
            zIndex
          }, style2),
          onMouseEnter,
          onMouseLeave,
          onPointerEnter,
          onClick
        }, arrow2 && /* @__PURE__ */ React__namespace.createElement(Arrow, {
          prefixCls,
          arrow: arrow2,
          arrowPos,
          align
        }), /* @__PURE__ */ React__namespace.createElement(PopupContent, {
          cache: !open2 && !fresh
        }, childNode));
      });
    }));
  });
  var TriggerWrapper = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
    var canUseRef = supportRef(children);
    var setRef = React__namespace.useCallback(function(node2) {
      fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
    }, [getTriggerDOMNode]);
    var mergedRef = useComposeRef(setRef, children.ref);
    return canUseRef ? /* @__PURE__ */ React__namespace.cloneElement(children, {
      ref: mergedRef
    }) : children;
  });
  var TriggerContext = /* @__PURE__ */ React__namespace.createContext(null);
  function toArray(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  function useAction(mobile, action, showAction, hideAction) {
    return React__namespace.useMemo(function() {
      var mergedShowAction = toArray(showAction !== null && showAction !== void 0 ? showAction : action);
      var mergedHideAction = toArray(hideAction !== null && hideAction !== void 0 ? hideAction : action);
      var showActionSet = new Set(mergedShowAction);
      var hideActionSet = new Set(mergedHideAction);
      if (mobile) {
        if (showActionSet.has("hover")) {
          showActionSet.delete("hover");
          showActionSet.add("click");
        }
        if (hideActionSet.has("hover")) {
          hideActionSet.delete("hover");
          hideActionSet.add("click");
        }
      }
      return [showActionSet, hideActionSet];
    }, [mobile, action, showAction, hideAction]);
  }
  function isPointsEq() {
    var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    var points = align.points;
    var placements2 = Object.keys(builtinPlacements);
    for (var i = 0; i < placements2.length; i += 1) {
      var _builtinPlacements$pl;
      var placement = placements2[i];
      if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
        return "".concat(prefixCls, "-placement-").concat(placement);
      }
    }
    return "";
  }
  function getMotion$1(prefixCls, motion2, animation, transitionName) {
    if (motion2) {
      return motion2;
    }
    if (animation) {
      return {
        motionName: "".concat(prefixCls, "-").concat(animation)
      };
    }
    if (transitionName) {
      return {
        motionName: transitionName
      };
    }
    return null;
  }
  function getWin(ele) {
    return ele.ownerDocument.defaultView;
  }
  function collectScroller(ele) {
    var scrollerList = [];
    var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
    var scrollStyle = ["hidden", "scroll", "clip", "auto"];
    while (current) {
      var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
      if ([overflowX, overflowY, overflow].some(function(o) {
        return scrollStyle.includes(o);
      })) {
        scrollerList.push(current);
      }
      current = current.parentElement;
    }
    return scrollerList;
  }
  function toNum(num) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return Number.isNaN(num) ? defaultValue : num;
  }
  function getPxValue(val) {
    return toNum(parseFloat(val), 0);
  }
  function getVisibleArea(initArea, scrollerList) {
    var visibleArea = _objectSpread2({}, initArea);
    (scrollerList || []).forEach(function(ele) {
      if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
        return;
      }
      var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
      var eleRect = ele.getBoundingClientRect();
      var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
      var borderTopNum = getPxValue(borderTopWidth);
      var borderBottomNum = getPxValue(borderBottomWidth);
      var borderLeftNum = getPxValue(borderLeftWidth);
      var borderRightNum = getPxValue(borderRightWidth);
      var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
      var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
      var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
      var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
      var scaledBorderTopWidth = borderTopNum * scaleY;
      var scaledBorderBottomWidth = borderBottomNum * scaleY;
      var scaledBorderLeftWidth = borderLeftNum * scaleX;
      var scaledBorderRightWidth = borderRightNum * scaleX;
      var clipMarginWidth = 0;
      var clipMarginHeight = 0;
      if (overflow === "clip") {
        var clipNum = getPxValue(overflowClipMargin);
        clipMarginWidth = clipNum * scaleX;
        clipMarginHeight = clipNum * scaleY;
      }
      var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
      var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
      var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
      var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
      visibleArea.left = Math.max(visibleArea.left, eleLeft);
      visibleArea.top = Math.max(visibleArea.top, eleTop);
      visibleArea.right = Math.min(visibleArea.right, eleRight);
      visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    });
    return visibleArea;
  }
  function getUnitOffset(size) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var offsetStr = "".concat(offset);
    var cells = offsetStr.match(/^(.*)\%$/);
    if (cells) {
      return size * (parseFloat(cells[1]) / 100);
    }
    return parseFloat(offsetStr);
  }
  function getNumberOffset(rect, offset) {
    var _ref = offset || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
    return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
  }
  function splitPoints() {
    var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return [points[0], points[1]];
  }
  function getAlignPoint(rect, points) {
    var topBottom = points[0];
    var leftRight = points[1];
    var x;
    var y;
    if (topBottom === "t") {
      y = rect.y;
    } else if (topBottom === "b") {
      y = rect.y + rect.height;
    } else {
      y = rect.y + rect.height / 2;
    }
    if (leftRight === "l") {
      x = rect.x;
    } else if (leftRight === "r") {
      x = rect.x + rect.width;
    } else {
      x = rect.x + rect.width / 2;
    }
    return {
      x,
      y
    };
  }
  function reversePoints(points, index2) {
    var reverseMap = {
      t: "b",
      b: "t",
      l: "r",
      r: "l"
    };
    return points.map(function(point, i) {
      if (i === index2) {
        return reverseMap[point] || "c";
      }
      return point;
    }).join("");
  }
  function useAlign(open2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
    var _React$useState = React__namespace.useState({
      ready: false,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: builtinPlacements[placement] || {}
    }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
    var alignCountRef = React__namespace.useRef(0);
    var scrollerList = React__namespace.useMemo(function() {
      if (!popupEle) {
        return [];
      }
      return collectScroller(popupEle);
    }, [popupEle]);
    var prevFlipRef = React__namespace.useRef({});
    var resetFlipCache = function resetFlipCache2() {
      prevFlipRef.current = {};
    };
    if (!open2) {
      resetFlipCache();
    }
    var onAlign = useEvent(function() {
      if (popupEle && target && open2) {
        let getIntersectionVisibleArea = function(offsetX, offsetY) {
          var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
          var l2 = popupRect.x + offsetX;
          var t2 = popupRect.y + offsetY;
          var r = l2 + popupWidth;
          var b2 = t2 + popupHeight;
          var visibleL = Math.max(l2, area.left);
          var visibleT = Math.max(t2, area.top);
          var visibleR = Math.min(r, area.right);
          var visibleB = Math.min(b2, area.bottom);
          return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
        }, syncNextPopupPosition = function() {
          nextPopupY = popupRect.y + nextOffsetY;
          nextPopupBottom = nextPopupY + popupHeight;
          nextPopupX = popupRect.x + nextOffsetX;
          nextPopupRight = nextPopupX + popupWidth;
        };
        var _popupElement$parentE, _popupElement$parentE2;
        var popupElement = popupEle;
        var doc = popupElement.ownerDocument;
        var win = getWin(popupElement);
        var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height, popupPosition = _win$getComputedStyle.position;
        var originLeft = popupElement.style.left;
        var originTop = popupElement.style.top;
        var originRight = popupElement.style.right;
        var originBottom = popupElement.style.bottom;
        var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
        var placeholderElement = doc.createElement("div");
        (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
        placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
        placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
        placeholderElement.style.position = popupPosition;
        placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
        placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");
        popupElement.style.left = "0";
        popupElement.style.top = "0";
        popupElement.style.right = "auto";
        popupElement.style.bottom = "auto";
        var targetRect;
        if (Array.isArray(target)) {
          targetRect = {
            x: target[0],
            y: target[1],
            width: 0,
            height: 0
          };
        } else {
          var rect = target.getBoundingClientRect();
          targetRect = {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        }
        var popupRect = popupElement.getBoundingClientRect();
        var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
        var popupHeight = popupRect.height;
        var popupWidth = popupRect.width;
        var targetHeight = targetRect.height;
        var targetWidth = targetRect.width;
        var visibleRegion = {
          left: 0,
          top: 0,
          right: clientWidth,
          bottom: clientHeight
        };
        var scrollRegion = {
          left: -scrollLeft,
          top: -scrollTop,
          right: scrollWidth - scrollLeft,
          bottom: scrollHeight - scrollTop
        };
        var htmlRegion = placementInfo.htmlRegion;
        var VISIBLE = "visible";
        var VISIBLE_FIRST = "visibleFirst";
        if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
          htmlRegion = VISIBLE;
        }
        var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
        var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
        var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
        var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
        var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
        popupElement.style.left = "auto";
        popupElement.style.top = "auto";
        popupElement.style.right = "0";
        popupElement.style.bottom = "0";
        var popupMirrorRect = popupElement.getBoundingClientRect();
        popupElement.style.left = originLeft;
        popupElement.style.top = originTop;
        popupElement.style.right = originRight;
        popupElement.style.bottom = originBottom;
        (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
        var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
        var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
        if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {
          return;
        }
        var offset = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
        var _getNumberOffset = getNumberOffset(popupRect, offset), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
        var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
        targetRect.x -= targetOffsetX;
        targetRect.y -= targetOffsetY;
        var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
        var targetPoints = splitPoints(targetPoint);
        var popupPoints = splitPoints(popupPoint);
        var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
        var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
        var nextAlignInfo = _objectSpread2({}, placementInfo);
        var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
        var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
        var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
        var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
        var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
        var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
        var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
        var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
        var overflow = placementInfo.overflow || {};
        var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
        var supportAdjust = function supportAdjust2(val) {
          if (typeof val === "boolean") {
            return val;
          }
          return val >= 0;
        };
        var nextPopupY;
        var nextPopupBottom;
        var nextPopupX;
        var nextPopupRight;
        syncNextPopupPosition();
        var needAdjustY = supportAdjust(adjustY);
        var sameTB = popupPoints[0] === targetPoints[0];
        if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
          var tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            tmpNextOffsetY -= popupHeight - targetHeight;
          } else {
            tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
          }
          var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
          var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.bt = true;
            nextOffsetY = tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.bt = false;
          }
        }
        if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
          var _tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            _tmpNextOffsetY += popupHeight - targetHeight;
          } else {
            _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
          }
          var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
          var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.tb = true;
            nextOffsetY = _tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.tb = false;
          }
        }
        var needAdjustX = supportAdjust(adjustX);
        var sameLR = popupPoints[1] === targetPoints[1];
        if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
          var tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            tmpNextOffsetX -= popupWidth - targetWidth;
          } else {
            tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
          }
          var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.rl = true;
            nextOffsetX = tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.rl = false;
          }
        }
        if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
          var _tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            _tmpNextOffsetX += popupWidth - targetWidth;
          } else {
            _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
          }
          var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.lr = true;
            nextOffsetX = _tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.lr = false;
          }
        }
        syncNextPopupPosition();
        var numShiftX = shiftX === true ? 0 : shiftX;
        if (typeof numShiftX === "number") {
          if (nextPopupX < visibleRegionArea.left) {
            nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
            if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
            }
          }
          if (nextPopupRight > visibleRegionArea.right) {
            nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
            if (targetRect.x > visibleRegionArea.right - numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
            }
          }
        }
        var numShiftY = shiftY === true ? 0 : shiftY;
        if (typeof numShiftY === "number") {
          if (nextPopupY < visibleRegionArea.top) {
            nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
            if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
            }
          }
          if (nextPopupBottom > visibleRegionArea.bottom) {
            nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
            if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
            }
          }
        }
        var popupLeft = popupRect.x + nextOffsetX;
        var popupRight = popupLeft + popupWidth;
        var popupTop = popupRect.y + nextOffsetY;
        var popupBottom = popupTop + popupHeight;
        var targetLeft = targetRect.x;
        var targetRight = targetLeft + targetWidth;
        var targetTop = targetRect.y;
        var targetBottom = targetTop + targetHeight;
        var maxLeft = Math.max(popupLeft, targetLeft);
        var minRight = Math.min(popupRight, targetRight);
        var xCenter = (maxLeft + minRight) / 2;
        var nextArrowX = xCenter - popupLeft;
        var maxTop = Math.max(popupTop, targetTop);
        var minBottom = Math.min(popupBottom, targetBottom);
        var yCenter = (maxTop + minBottom) / 2;
        var nextArrowY = yCenter - popupTop;
        onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
        var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
        var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
        setOffsetInfo({
          ready: true,
          offsetX: nextOffsetX / _scaleX,
          offsetY: nextOffsetY / _scaleY,
          offsetR: offsetX4Right / _scaleX,
          offsetB: offsetY4Bottom / _scaleY,
          arrowX: nextArrowX / _scaleX,
          arrowY: nextArrowY / _scaleY,
          scaleX: _scaleX,
          scaleY: _scaleY,
          align: nextAlignInfo
        });
      }
    });
    var triggerAlign = function triggerAlign2() {
      alignCountRef.current += 1;
      var id = alignCountRef.current;
      Promise.resolve().then(function() {
        if (alignCountRef.current === id) {
          onAlign();
        }
      });
    };
    var resetReady = function resetReady2() {
      setOffsetInfo(function(ori) {
        return _objectSpread2(_objectSpread2({}, ori), {}, {
          ready: false
        });
      });
    };
    useLayoutEffect$1(resetReady, [placement]);
    useLayoutEffect$1(function() {
      if (!open2) {
        resetReady();
      }
    }, [open2]);
    return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
  }
  function useWatch(open2, target, popup, onAlign, onScroll) {
    useLayoutEffect$1(function() {
      if (open2 && target && popup) {
        let notifyScroll = function() {
          onAlign();
          onScroll();
        };
        var targetElement = target;
        var popupElement = popup;
        var targetScrollList = collectScroller(targetElement);
        var popupScrollList = collectScroller(popupElement);
        var win = getWin(popupElement);
        var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
        mergedList.forEach(function(scroller) {
          scroller.addEventListener("scroll", notifyScroll, {
            passive: true
          });
        });
        win.addEventListener("resize", notifyScroll, {
          passive: true
        });
        onAlign();
        return function() {
          mergedList.forEach(function(scroller) {
            scroller.removeEventListener("scroll", notifyScroll);
            win.removeEventListener("resize", notifyScroll);
          });
        };
      }
    }, [open2, target, popup]);
  }
  function useWinClick(open2, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
    var openRef = React__namespace.useRef(open2);
    var lockRef = React__namespace.useRef(false);
    if (openRef.current !== open2) {
      lockRef.current = true;
      openRef.current = open2;
    }
    React__namespace.useEffect(function() {
      var id = wrapperRaf(function() {
        lockRef.current = false;
      });
      return function() {
        wrapperRaf.cancel(id);
      };
    }, [open2]);
    React__namespace.useEffect(function() {
      if (clickToHide && popupEle && (!mask || maskClosable)) {
        var genClickEvents = function genClickEvents2() {
          var clickInside = false;
          var onWindowMouseDown = function onWindowMouseDown2(_ref) {
            var target = _ref.target;
            clickInside = inPopupOrChild(target);
          };
          var onWindowClick = function onWindowClick2(_ref2) {
            var target = _ref2.target;
            if (!lockRef.current && openRef.current && !clickInside && !inPopupOrChild(target)) {
              triggerOpen(false);
            }
          };
          return [onWindowMouseDown, onWindowClick];
        };
        var _genClickEvents = genClickEvents(), _genClickEvents2 = _slicedToArray(_genClickEvents, 2), onWinMouseDown = _genClickEvents2[0], onWinClick = _genClickEvents2[1];
        var _genClickEvents3 = genClickEvents(), _genClickEvents4 = _slicedToArray(_genClickEvents3, 2), onShadowMouseDown = _genClickEvents4[0], onShadowClick = _genClickEvents4[1];
        var win = getWin(popupEle);
        win.addEventListener("mousedown", onWinMouseDown, true);
        win.addEventListener("click", onWinClick, true);
        win.addEventListener("contextmenu", onWinClick, true);
        var targetShadowRoot = getShadowRoot(targetEle);
        if (targetShadowRoot) {
          targetShadowRoot.addEventListener("mousedown", onShadowMouseDown, true);
          targetShadowRoot.addEventListener("click", onShadowClick, true);
          targetShadowRoot.addEventListener("contextmenu", onShadowClick, true);
        }
        return function() {
          win.removeEventListener("mousedown", onWinMouseDown, true);
          win.removeEventListener("click", onWinClick, true);
          win.removeEventListener("contextmenu", onWinClick, true);
          if (targetShadowRoot) {
            targetShadowRoot.removeEventListener("mousedown", onShadowMouseDown, true);
            targetShadowRoot.removeEventListener("click", onShadowClick, true);
            targetShadowRoot.removeEventListener("contextmenu", onShadowClick, true);
          }
        };
      }
    }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
  }
  var _excluded$v = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
  function generateTrigger() {
    var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
    var Trigger2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow2 = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties$8(props, _excluded$v);
      var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
      var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      useLayoutEffect$1(function() {
        setMobile(isMobile());
      }, []);
      var subPopupElements = React__namespace.useRef({});
      var parentContext = React__namespace.useContext(TriggerContext);
      var context2 = React__namespace.useMemo(function() {
        return {
          registerSubPopup: function registerSubPopup(id2, subPopupEle) {
            subPopupElements.current[id2] = subPopupEle;
            parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id2, subPopupEle);
          }
        };
      }, [parentContext]);
      var id = useId$1();
      var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
      var setPopupRef = useEvent(function(node2) {
        if (isDOM(node2) && popupEle !== node2) {
          setPopupEle(node2);
        }
        parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node2);
      });
      var _React$useState5 = React__namespace.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
      var externalForwardRef = React__namespace.useRef(null);
      var setTargetRef = useEvent(function(node2) {
        if (isDOM(node2) && targetEle !== node2) {
          setTargetEle(node2);
          externalForwardRef.current = node2;
        }
      });
      var child = React__namespace.Children.only(children);
      var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
      var cloneProps = {};
      var inPopupOrChild = useEvent(function(ele) {
        var _getShadowRoot, _getShadowRoot2;
        var childDOM = targetEle;
        return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
          return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
        });
      });
      var mergePopupMotion = getMotion$1(prefixCls, popupMotion, popupAnimation, popupTransitionName);
      var mergeMaskMotion = getMotion$1(prefixCls, maskMotion, maskAnimation, maskTransitionName);
      var _React$useState7 = React__namespace.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
      var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
      var setMergedOpen = useEvent(function(nextOpen) {
        if (popupVisible === void 0) {
          setInternalOpen(nextOpen);
        }
      });
      useLayoutEffect$1(function() {
        setInternalOpen(popupVisible || false);
      }, [popupVisible]);
      var openRef = React__namespace.useRef(mergedOpen);
      openRef.current = mergedOpen;
      var internalTriggerOpen = useEvent(function(nextOpen) {
        ReactDOM__default.flushSync(function() {
          if (mergedOpen !== nextOpen) {
            setMergedOpen(nextOpen);
            onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
          }
        });
      });
      var delayRef = React__namespace.useRef();
      var clearDelay = function clearDelay2() {
        clearTimeout(delayRef.current);
      };
      var triggerOpen = function triggerOpen2(nextOpen) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        clearDelay();
        if (delay === 0) {
          internalTriggerOpen(nextOpen);
        } else {
          delayRef.current = setTimeout(function() {
            internalTriggerOpen(nextOpen);
          }, delay * 1e3);
        }
      };
      React__namespace.useEffect(function() {
        return clearDelay;
      }, []);
      var _React$useState9 = React__namespace.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
      useLayoutEffect$1(function(firstMount) {
        if (!firstMount || mergedOpen) {
          setInMotion(true);
        }
      }, [mergedOpen]);
      var _React$useState11 = React__namespace.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
      var _React$useState13 = React__namespace.useState([0, 0]), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
      var setMousePosByEvent = function setMousePosByEvent2(event) {
        setMousePos([event.clientX, event.clientY]);
      };
      var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
      var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
      var clickToShow = showActions.has("click");
      var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
      var triggerAlign = useEvent(function() {
        if (!inMotion) {
          onAlign();
        }
      });
      var onScroll = function onScroll2() {
        if (openRef.current && alignPoint && clickToHide) {
          triggerOpen(false);
        }
      };
      useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
      useLayoutEffect$1(function() {
        triggerAlign();
      }, [mousePos, popupPlacement]);
      useLayoutEffect$1(function() {
        if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
          triggerAlign();
        }
      }, [JSON.stringify(popupAlign)]);
      var alignedClassName = React__namespace.useMemo(function() {
        var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
        return classname(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
      }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
      React__namespace.useImperativeHandle(ref, function() {
        return {
          nativeElement: externalForwardRef.current,
          forceAlign: triggerAlign
        };
      });
      var _React$useState15 = React__namespace.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
      var _React$useState17 = React__namespace.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
      var syncTargetSize = function syncTargetSize2() {
        if (stretch && targetEle) {
          var rect = targetEle.getBoundingClientRect();
          setTargetWidth(rect.width);
          setTargetHeight(rect.height);
        }
      };
      var onTargetResize = function onTargetResize2() {
        syncTargetSize();
        triggerAlign();
      };
      var onVisibleChanged = function onVisibleChanged2(visible) {
        setInMotion(false);
        onAlign();
        afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
      };
      var onPrepare = function onPrepare2() {
        return new Promise(function(resolve) {
          syncTargetSize();
          setMotionPrepareResolve(function() {
            return resolve;
          });
        });
      };
      useLayoutEffect$1(function() {
        if (motionPrepareResolve) {
          onAlign();
          motionPrepareResolve();
          setMotionPrepareResolve(null);
        }
      }, [motionPrepareResolve]);
      function wrapperAction(eventName, nextOpen, delay, preEvent) {
        cloneProps[eventName] = function(event) {
          var _originChildProps$eve;
          preEvent === null || preEvent === void 0 || preEvent(event);
          triggerOpen(nextOpen, delay);
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
        };
      }
      if (clickToShow || clickToHide) {
        cloneProps.onClick = function(event) {
          var _originChildProps$onC;
          if (openRef.current && clickToHide) {
            triggerOpen(false);
          } else if (!openRef.current && clickToShow) {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
        };
      }
      useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
      var hoverToShow = showActions.has("hover");
      var hoverToHide = hideActions.has("hover");
      var onPopupMouseEnter;
      var onPopupMouseLeave;
      if (hoverToShow) {
        wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
          setMousePosByEvent(event);
        });
        wrapperAction("onPointerEnter", true, mouseEnterDelay, function(event) {
          setMousePosByEvent(event);
        });
        onPopupMouseEnter = function onPopupMouseEnter2() {
          if (mergedOpen || inMotion) {
            triggerOpen(true, mouseEnterDelay);
          }
        };
        if (alignPoint) {
          cloneProps.onMouseMove = function(event) {
            var _originChildProps$onM;
            (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
          };
        }
      }
      if (hoverToHide) {
        wrapperAction("onMouseLeave", false, mouseLeaveDelay);
        wrapperAction("onPointerLeave", false, mouseLeaveDelay);
        onPopupMouseLeave = function onPopupMouseLeave2() {
          triggerOpen(false, mouseLeaveDelay);
        };
      }
      if (showActions.has("focus")) {
        wrapperAction("onFocus", true, focusDelay);
      }
      if (hideActions.has("focus")) {
        wrapperAction("onBlur", false, blurDelay);
      }
      if (showActions.has("contextMenu")) {
        cloneProps.onContextMenu = function(event) {
          var _originChildProps$onC2;
          if (openRef.current && hideActions.has("contextMenu")) {
            triggerOpen(false);
          } else {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          event.preventDefault();
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
        };
      }
      if (className) {
        cloneProps.className = classname(originChildProps.className, className);
      }
      var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
      var passedProps = {};
      var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
      passedEventList.forEach(function(eventName) {
        if (restProps[eventName]) {
          passedProps[eventName] = function() {
            var _mergedChildrenProps$;
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
            restProps[eventName].apply(restProps, args);
          };
        }
      });
      var triggerNode = /* @__PURE__ */ React__namespace.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
      var arrowPos = {
        x: arrowX,
        y: arrowY
      };
      var innerArrow = arrow2 ? _objectSpread2({}, arrow2 !== true ? arrow2 : {}) : null;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
        disabled: !mergedOpen,
        ref: setTargetRef,
        onResize: onTargetResize
      }, /* @__PURE__ */ React__namespace.createElement(TriggerWrapper, {
        getTriggerDOMNode
      }, triggerNode)), /* @__PURE__ */ React__namespace.createElement(TriggerContext.Provider, {
        value: context2
      }, /* @__PURE__ */ React__namespace.createElement(Popup$1, {
        portal: PortalComponent,
        ref: setPopupRef,
        prefixCls,
        popup,
        className: classname(popupClassName, alignedClassName),
        style: popupStyle,
        target: targetEle,
        onMouseEnter: onPopupMouseEnter,
        onMouseLeave: onPopupMouseLeave,
        onPointerEnter: onPopupMouseEnter,
        zIndex,
        open: mergedOpen,
        keepDom: inMotion,
        fresh,
        onClick: onPopupClick,
        mask,
        motion: mergePopupMotion,
        maskMotion: mergeMaskMotion,
        onVisibleChanged,
        onPrepare,
        forceRender,
        autoDestroy: mergedAutoDestroy,
        getPopupContainer,
        align: alignInfo,
        arrow: innerArrow,
        arrowPos,
        ready,
        offsetX,
        offsetY,
        offsetR,
        offsetB,
        onAlign: triggerAlign,
        stretch,
        targetWidth: targetWidth / scaleX,
        targetHeight: targetHeight / scaleY
      })));
    });
    return Trigger2;
  }
  const Trigger = generateTrigger(Portal);
  var _excluded$u = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
  var getBuiltInPlacements$1 = function getBuiltInPlacements(dropdownMatchSelectWidth) {
    var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
    return {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      }
    };
  };
  var SelectTrigger = function SelectTrigger2(props, ref) {
    var prefixCls = props.prefixCls;
    props.disabled;
    var visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties$8(props, _excluded$u);
    var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
    var popupNode = popupElement;
    if (dropdownRender) {
      popupNode = dropdownRender(popupElement);
    }
    var mergedBuiltinPlacements = React__namespace.useMemo(function() {
      return builtinPlacements || getBuiltInPlacements$1(dropdownMatchSelectWidth);
    }, [builtinPlacements, dropdownMatchSelectWidth]);
    var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
    var isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
    var stretch = React__namespace.useMemo(function() {
      if (isNumberPopupWidth) {
        return null;
      }
      return dropdownMatchSelectWidth === false ? "minWidth" : "width";
    }, [dropdownMatchSelectWidth, isNumberPopupWidth]);
    var popupStyle = dropdownStyle;
    if (isNumberPopupWidth) {
      popupStyle = _objectSpread2(_objectSpread2({}, popupStyle), {}, {
        width: dropdownMatchSelectWidth
      });
    }
    var popupRef = React__namespace.useRef(null);
    React__namespace.useImperativeHandle(ref, function() {
      return {
        getPopupElement: function getPopupElement() {
          return popupRef.current;
        }
      };
    });
    return /* @__PURE__ */ React__namespace.createElement(Trigger, _extends$7({}, restProps, {
      showAction: onPopupVisibleChange ? ["click"] : [],
      hideAction: onPopupVisibleChange ? ["click"] : [],
      popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
      builtinPlacements: mergedBuiltinPlacements,
      prefixCls: dropdownPrefixCls,
      popupTransitionName: mergedTransitionName,
      popup: /* @__PURE__ */ React__namespace.createElement("div", {
        ref: popupRef,
        onMouseEnter: onPopupMouseEnter
      }, popupNode),
      stretch,
      popupAlign: dropdownAlign,
      popupVisible: visible,
      getPopupContainer,
      popupClassName: classname(dropdownClassName, _defineProperty$1({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
      popupStyle,
      getTriggerDOMNode,
      onPopupVisibleChange
    }), children);
  };
  var RefSelectTrigger = /* @__PURE__ */ React__namespace.forwardRef(SelectTrigger);
  RefSelectTrigger.displayName = "SelectTrigger";
  function getKey(data, index2) {
    var key = data.key;
    var value;
    if ("value" in data) {
      value = data.value;
    }
    if (key !== null && key !== void 0) {
      return key;
    }
    if (value !== void 0) {
      return value;
    }
    return "rc-index-key-".concat(index2);
  }
  function fillFieldNames(fieldNames, childrenAsData) {
    var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options, groupLabel = _ref.groupLabel;
    var mergedLabel = label || (childrenAsData ? "children" : "label");
    return {
      label: mergedLabel,
      value: value || "value",
      options: options || "options",
      groupLabel: groupLabel || mergedLabel
    };
  }
  function flattenOptions(options) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
    var flattenList = [];
    var _fillFieldNames = fillFieldNames(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
    function dig(list, isGroupOption) {
      list.forEach(function(data) {
        if (isGroupOption || !(fieldOptions in data)) {
          var value = data[fieldValue];
          flattenList.push({
            key: getKey(data, flattenList.length),
            groupOption: isGroupOption,
            data,
            label: data[fieldLabel],
            value
          });
        } else {
          var grpLabel = data[groupLabel];
          if (grpLabel === void 0 && childrenAsData) {
            grpLabel = data.label;
          }
          flattenList.push({
            key: getKey(data, flattenList.length),
            group: true,
            data,
            label: grpLabel
          });
          dig(data[fieldOptions], true);
        }
      });
    }
    dig(options, false);
    return flattenList;
  }
  function injectPropsWithOption(option) {
    var newOption = _objectSpread2({}, option);
    if (!("props" in newOption)) {
      Object.defineProperty(newOption, "props", {
        get: function get2() {
          warningOnce(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
          return newOption;
        }
      });
    }
    return newOption;
  }
  function getSeparatedContent(text, tokens) {
    if (!tokens || !tokens.length) {
      return null;
    }
    var match2 = false;
    function separate(str, _ref3) {
      var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
      if (!token2) {
        return [str];
      }
      var list2 = str.split(token2);
      match2 = match2 || list2.length > 1;
      return list2.reduce(function(prevList, unitStr) {
        return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
      }, []).filter(function(unit) {
        return unit;
      });
    }
    var list = separate(text, tokens);
    return match2 ? list : null;
  }
  var _excluded$t = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
  var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
  function isMultiple(mode) {
    return mode === "tags" || mode === "multiple";
  }
  var BaseSelect = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _customizeRawInputEle, _classNames2;
    var id = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open2 = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties$8(props, _excluded$t);
    var multiple = isMultiple(mode);
    var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
    var domProps = _objectSpread2({}, restProps);
    DEFAULT_OMIT_PROPS.forEach(function(propName) {
      delete domProps[propName];
    });
    omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
      delete domProps[propName];
    });
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
    React__namespace.useEffect(function() {
      setMobile(isMobile());
    }, []);
    var containerRef = React__namespace.useRef(null);
    var selectorDomRef = React__namespace.useRef(null);
    var triggerRef = React__namespace.useRef(null);
    var selectorRef = React__namespace.useRef(null);
    var listRef = React__namespace.useRef(null);
    var blurRef = React__namespace.useRef(false);
    var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
    React__namespace.useImperativeHandle(ref, function() {
      var _selectorRef$current, _selectorRef$current2;
      return {
        focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
        blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
        scrollTo: function scrollTo2(arg) {
          var _listRef$current;
          return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
        }
      };
    });
    var mergedSearchValue = React__namespace.useMemo(function() {
      var _displayValues$;
      if (mode !== "combobox") {
        return searchValue;
      }
      var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    }, [searchValue, mode, displayValues]);
    var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
    var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
    var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
    var _React$useState3 = React__namespace.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
    useLayoutEffect$1(function() {
      setRendered(true);
    }, []);
    var _useMergedState = useMergedState(false, {
      defaultValue: defaultOpen,
      value: open2
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
    var mergedOpen = rendered ? innerOpen : false;
    var emptyListContent = !notFoundContent && emptyOptions;
    if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
      mergedOpen = false;
    }
    var triggerOpen = emptyListContent ? false : mergedOpen;
    var onToggleOpen = React__namespace.useCallback(function(newOpen) {
      var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
      if (!disabled) {
        setInnerOpen(nextOpen);
        if (mergedOpen !== nextOpen) {
          onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
        }
      }
    }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
    var tokenWithEnter = React__namespace.useMemo(function() {
      return (tokenSeparators || []).some(function(tokenSeparator) {
        return ["\n", "\r\n"].includes(tokenSeparator);
      });
    }, [tokenSeparators]);
    var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
      var ret = true;
      var newSearchText = searchText;
      onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null);
      var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
      if (mode !== "combobox" && patchLabels) {
        newSearchText = "";
        onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels);
        onToggleOpen(false);
        ret = false;
      }
      if (onSearch && mergedSearchValue !== newSearchText) {
        onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      return ret;
    };
    var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
      if (!searchText || !searchText.trim()) {
        return;
      }
      onSearch(searchText, {
        source: "submit"
      });
    };
    React__namespace.useEffect(function() {
      if (!mergedOpen && !multiple && mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, [mergedOpen]);
    React__namespace.useEffect(function() {
      if (innerOpen && disabled) {
        setInnerOpen(false);
      }
      if (disabled && !blurRef.current) {
        setMockFocused(false);
      }
    }, [disabled]);
    var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
    var onInternalKeyDown = function onInternalKeyDown2(event) {
      var clearLock = getClearLock();
      var which = event.which;
      if (which === KeyCode.ENTER) {
        if (mode !== "combobox") {
          event.preventDefault();
        }
        if (!mergedOpen) {
          onToggleOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue);
      if (which === KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
        var cloneDisplayValues = _toConsumableArray(displayValues);
        var removedDisplayValue = null;
        for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
          var current = cloneDisplayValues[i];
          if (!current.disabled) {
            cloneDisplayValues.splice(i, 1);
            removedDisplayValue = current;
            break;
          }
        }
        if (removedDisplayValue) {
          onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (mergedOpen && listRef.current) {
        var _listRef$current2;
        (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
      }
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown.apply(void 0, [event].concat(rest));
    };
    var onInternalKeyUp = function onInternalKeyUp2(event) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (mergedOpen && listRef.current) {
        var _listRef$current3;
        (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
      }
      onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp.apply(void 0, [event].concat(rest));
    };
    var onSelectorRemove = function onSelectorRemove2(val) {
      var newValues = displayValues.filter(function(i) {
        return i !== val;
      });
      onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    };
    var focusRef = React__namespace.useRef(false);
    var onContainerFocus = function onContainerFocus2() {
      setMockFocused(true);
      if (!disabled) {
        if (onFocus && !focusRef.current) {
          onFocus.apply(void 0, arguments);
        }
        if (showAction.includes("focus")) {
          onToggleOpen(true);
        }
      }
      focusRef.current = true;
    };
    var onContainerBlur = function onContainerBlur2() {
      blurRef.current = true;
      setMockFocused(false, function() {
        focusRef.current = false;
        blurRef.current = false;
        onToggleOpen(false);
      });
      if (disabled) {
        return;
      }
      if (mergedSearchValue) {
        if (mode === "tags") {
          onSearch(mergedSearchValue, {
            source: "submit"
          });
        } else if (mode === "multiple") {
          onSearch("", {
            source: "blur"
          });
        }
      }
      if (onBlur) {
        onBlur.apply(void 0, arguments);
      }
    };
    var activeTimeoutIds = [];
    React__namespace.useEffect(function() {
      return function() {
        activeTimeoutIds.forEach(function(timeoutId) {
          return clearTimeout(timeoutId);
        });
        activeTimeoutIds.splice(0, activeTimeoutIds.length);
      };
    }, []);
    var onInternalMouseDown = function onInternalMouseDown2(event) {
      var _triggerRef$current;
      var target = event.target;
      var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
      if (popupElement && popupElement.contains(target)) {
        var timeoutId = setTimeout(function() {
          var index2 = activeTimeoutIds.indexOf(timeoutId);
          if (index2 !== -1) {
            activeTimeoutIds.splice(index2, 1);
          }
          cancelSetMockFocused();
          if (!mobile && !popupElement.contains(document.activeElement)) {
            var _selectorRef$current3;
            (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
          }
        });
        activeTimeoutIds.push(timeoutId);
      }
      for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        restArgs[_key3 - 1] = arguments[_key3];
      }
      onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
    };
    var _React$useState5 = React__namespace.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
    function onPopupMouseEnter() {
      forceUpdate({});
    }
    var onTriggerVisibleChange;
    if (customizeRawInputElement) {
      onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
        onToggleOpen(newOpen);
      };
    }
    useSelectTriggerControl(function() {
      var _triggerRef$current2;
      return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
    }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
    var baseSelectContext = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, props), {}, {
        notFoundContent,
        open: mergedOpen,
        triggerOpen,
        id,
        showSearch: mergedShowSearch,
        multiple,
        toggleOpen: onToggleOpen
      });
    }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]);
    var showSuffixIcon = !!suffixIcon || loading;
    var arrowNode;
    if (showSuffixIcon) {
      arrowNode = /* @__PURE__ */ React__namespace.createElement(TransBtn, {
        className: classname("".concat(prefixCls, "-arrow"), _defineProperty$1({}, "".concat(prefixCls, "-arrow-loading"), loading)),
        customizeIcon: suffixIcon,
        customizeIconProps: {
          loading,
          searchValue: mergedSearchValue,
          open: mergedOpen,
          focused: mockFocused,
          showSearch: mergedShowSearch
        }
      });
    }
    var onClearMouseDown = function onClearMouseDown2() {
      var _selectorRef$current4;
      onClear === null || onClear === void 0 ? void 0 : onClear();
      (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 ? void 0 : _selectorRef$current4.focus();
      onDisplayValuesChange([], {
        type: "clear",
        values: displayValues
      });
      onInternalSearch("", false, false);
    };
    var _useAllowClear = useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon;
    var optionList = /* @__PURE__ */ React__namespace.createElement(OptionList3, {
      ref: listRef
    });
    var mergedClassName = classname(prefixCls, className, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$1(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$1(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$1(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$1(_classNames2, "".concat(prefixCls, "-show-arrow"), showSuffixIcon), _defineProperty$1(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$1(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$1(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$1(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$1(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
    var selectorNode = /* @__PURE__ */ React__namespace.createElement(RefSelectTrigger, {
      ref: triggerRef,
      disabled,
      prefixCls,
      visible: triggerOpen,
      popupElement: optionList,
      animation,
      transitionName,
      dropdownStyle,
      dropdownClassName,
      direction,
      dropdownMatchSelectWidth,
      dropdownRender,
      dropdownAlign,
      placement,
      builtinPlacements,
      getPopupContainer,
      empty: emptyOptions,
      getTriggerDOMNode: function getTriggerDOMNode() {
        return selectorDomRef.current;
      },
      onPopupVisibleChange: onTriggerVisibleChange,
      onPopupMouseEnter
    }, customizeRawInputElement ? /* @__PURE__ */ React__namespace.cloneElement(customizeRawInputElement, {
      ref: customizeRawInputRef
    }) : /* @__PURE__ */ React__namespace.createElement(ForwardSelector, _extends$7({}, props, {
      domRef: selectorDomRef,
      prefixCls,
      inputElement: customizeInputElement,
      ref: selectorRef,
      id,
      showSearch: mergedShowSearch,
      autoClearSearchValue,
      mode,
      activeDescendantId,
      tagRender,
      values: displayValues,
      open: mergedOpen,
      onToggleOpen,
      activeValue,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      onSearchSubmit: onInternalSearchSubmit,
      onRemove: onSelectorRemove,
      tokenWithEnter
    })));
    var renderNode;
    if (customizeRawInputElement) {
      renderNode = selectorNode;
    } else {
      renderNode = /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
        className: mergedClassName
      }, domProps, {
        ref: containerRef,
        onMouseDown: onInternalMouseDown,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onFocus: onContainerFocus,
        onBlur: onContainerBlur
      }), mockFocused && !mergedOpen && /* @__PURE__ */ React__namespace.createElement("span", {
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, "".concat(displayValues.map(function(_ref) {
        var label = _ref.label, value = _ref.value;
        return ["number", "string"].includes(_typeof(label)) ? label : value;
      }).join(", "))), selectorNode, arrowNode, mergedAllowClear && clearNode);
    }
    return /* @__PURE__ */ React__namespace.createElement(BaseSelectContext.Provider, {
      value: baseSelectContext
    }, renderNode);
  });
  const useCache = function(labeledValues, valueOptions) {
    var cacheRef = React__namespace.useRef({
      values: /* @__PURE__ */ new Map(),
      options: /* @__PURE__ */ new Map()
    });
    var filledLabeledValues = React__namespace.useMemo(function() {
      var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
      var patchedValues = labeledValues.map(function(item) {
        if (item.label === void 0) {
          var _prevValueCache$get;
          return _objectSpread2(_objectSpread2({}, item), {}, {
            label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
          });
        }
        return item;
      });
      var valueCache = /* @__PURE__ */ new Map();
      var optionCache = /* @__PURE__ */ new Map();
      patchedValues.forEach(function(item) {
        valueCache.set(item.value, item);
        optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
      });
      cacheRef.current.values = valueCache;
      cacheRef.current.options = optionCache;
      return patchedValues;
    }, [labeledValues, valueOptions]);
    var getOption = React__namespace.useCallback(function(val) {
      return valueOptions.get(val) || cacheRef.current.options.get(val);
    }, [valueOptions]);
    return [filledLabeledValues, getOption];
  };
  function includes(test, search2) {
    return toArray$1(test).join("").toUpperCase().includes(search2);
  }
  const useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
    return React__namespace.useMemo(function() {
      if (!searchValue || filterOption === false) {
        return options;
      }
      var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
      var filteredOptions = [];
      var customizeFilter = typeof filterOption === "function";
      var upperSearch = searchValue.toUpperCase();
      var filterFunc = customizeFilter ? filterOption : function(_, option) {
        if (optionFilterProp) {
          return includes(option[optionFilterProp], upperSearch);
        }
        if (option[fieldOptions]) {
          return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
        }
        return includes(option[fieldValue], upperSearch);
      };
      var wrapOption = customizeFilter ? function(opt) {
        return injectPropsWithOption(opt);
      } : function(opt) {
        return opt;
      };
      options.forEach(function(item) {
        if (item[fieldOptions]) {
          var matchGroup = filterFunc(searchValue, wrapOption(item));
          if (matchGroup) {
            filteredOptions.push(item);
          } else {
            var subOptions = item[fieldOptions].filter(function(subItem) {
              return filterFunc(searchValue, wrapOption(subItem));
            });
            if (subOptions.length) {
              filteredOptions.push(_objectSpread2(_objectSpread2({}, item), {}, _defineProperty$1({}, fieldOptions, subOptions)));
            }
          }
          return;
        }
        if (filterFunc(searchValue, wrapOption(item))) {
          filteredOptions.push(item);
        }
      });
      return filteredOptions;
    }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
  };
  var uuid$1 = 0;
  var isBrowserClient = canUseDom();
  function getUUID() {
    var retId;
    if (isBrowserClient) {
      retId = uuid$1;
      uuid$1 += 1;
    } else {
      retId = "TEST_OR_SSR";
    }
    return retId;
  }
  function useId2(id) {
    var _React$useState = React__namespace.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
    React__namespace.useEffect(function() {
      setInnerId("rc_select_".concat(getUUID()));
    }, []);
    return id || innerId;
  }
  var _excluded$s = ["children", "value"], _excluded2$5 = ["children"];
  function convertNodeToOption(node2) {
    var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties$8(_ref$props, _excluded$s);
    return _objectSpread2({
      key,
      value: value !== void 0 ? value : key,
      children
    }, restProps);
  }
  function convertChildrenToData(nodes) {
    var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return toArray$3(nodes).map(function(node2, index2) {
      if (!/* @__PURE__ */ React__namespace.isValidElement(node2) || !node2.type) {
        return null;
      }
      var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties$8(_ref2$props, _excluded2$5);
      if (optionOnly || !isSelectOptGroup) {
        return convertNodeToOption(node2);
      }
      return _objectSpread2(_objectSpread2({
        key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
        label: key
      }, restProps), {}, {
        options: convertChildrenToData(children)
      });
    }).filter(function(data) {
      return data;
    });
  }
  function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
    return React__namespace.useMemo(function() {
      var mergedOptions = options;
      var childrenAsData = !options;
      if (childrenAsData) {
        mergedOptions = convertChildrenToData(children);
      }
      var valueOptions = /* @__PURE__ */ new Map();
      var labelOptions = /* @__PURE__ */ new Map();
      var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
        if (key && typeof key === "string") {
          labelOptionsMap.set(option[key], option);
        }
      };
      function dig(optionList) {
        var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        for (var i = 0; i < optionList.length; i += 1) {
          var option = optionList[i];
          if (!option[fieldNames.options] || isChildren) {
            valueOptions.set(option[fieldNames.value], option);
            setLabelOptions(labelOptions, option, fieldNames.label);
            setLabelOptions(labelOptions, option, optionFilterProp);
            setLabelOptions(labelOptions, option, optionLabelProp);
          } else {
            dig(option[fieldNames.options], true);
          }
        }
      }
      dig(mergedOptions);
      return {
        options: mergedOptions,
        valueOptions,
        labelOptions
      };
    }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
  }
  function useRefFunc(callback) {
    var funcRef = React__namespace.useRef();
    funcRef.current = callback;
    var cacheFn = React__namespace.useCallback(function() {
      return funcRef.current.apply(funcRef, arguments);
    }, []);
    return cacheFn;
  }
  var OptGroup = function OptGroup2() {
    return null;
  };
  OptGroup.isSelectOptGroup = true;
  var Option = function Option2() {
    return null;
  };
  Option.isSelectOption = true;
  var Filler = /* @__PURE__ */ React__namespace.forwardRef(function(_ref, ref) {
    var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
    var outerStyle = {};
    var innerStyle = {
      display: "flex",
      flexDirection: "column"
    };
    if (offsetY !== void 0) {
      var _objectSpread2$1;
      outerStyle = {
        height,
        position: "relative",
        overflow: "hidden"
      };
      innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, (_objectSpread2$1 = {
        transform: "translateY(".concat(offsetY, "px)")
      }, _defineProperty$1(_objectSpread2$1, rtl ? "marginRight" : "marginLeft", -offsetX), _defineProperty$1(_objectSpread2$1, "position", "absolute"), _defineProperty$1(_objectSpread2$1, "left", 0), _defineProperty$1(_objectSpread2$1, "right", 0), _defineProperty$1(_objectSpread2$1, "top", 0), _objectSpread2$1));
    }
    return /* @__PURE__ */ React__namespace.createElement("div", {
      style: outerStyle
    }, /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: function onResize2(_ref2) {
        var offsetHeight = _ref2.offsetHeight;
        if (offsetHeight && onInnerResize) {
          onInnerResize();
        }
      }
    }, /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
      style: innerStyle,
      className: classname(_defineProperty$1({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
      ref
    }, innerProps), children, extra)));
  });
  Filler.displayName = "Filler";
  function getPageXY(e2, horizontal) {
    var obj = "touches" in e2 ? e2.touches[0] : e2;
    return obj[horizontal ? "pageX" : "pageY"];
  }
  var ScrollBar = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _classNames;
    var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
    var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
    var _React$useState5 = React__namespace.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
    var isLTR = !rtl;
    var scrollbarRef = React__namespace.useRef();
    var thumbRef = React__namespace.useRef();
    var _React$useState7 = React__namespace.useState(false), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
    var visibleTimeoutRef = React__namespace.useRef();
    var delayHidden = function delayHidden2() {
      clearTimeout(visibleTimeoutRef.current);
      setVisible(true);
      visibleTimeoutRef.current = setTimeout(function() {
        setVisible(false);
      }, 3e3);
    };
    var enableScrollRange = scrollRange - containerSize || 0;
    var enableOffsetRange = containerSize - spinSize || 0;
    var canScroll = enableScrollRange > 0;
    var top = React__namespace.useMemo(function() {
      if (scrollOffset === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollOffset / enableScrollRange;
      return ptg * enableOffsetRange;
    }, [scrollOffset, enableScrollRange, enableOffsetRange]);
    var onContainerMouseDown = function onContainerMouseDown2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    };
    var stateRef = React__namespace.useRef({
      top,
      dragging,
      pageY: pageXY,
      startTop
    });
    stateRef.current = {
      top,
      dragging,
      pageY: pageXY,
      startTop
    };
    var onThumbMouseDown = function onThumbMouseDown2(e2) {
      setDragging(true);
      setPageXY(getPageXY(e2, horizontal));
      setStartTop(stateRef.current.top);
      onStartMove();
      e2.stopPropagation();
      e2.preventDefault();
    };
    React__namespace.useEffect(function() {
      var onScrollbarTouchStart = function onScrollbarTouchStart2(e2) {
        e2.preventDefault();
      };
      var scrollbarEle = scrollbarRef.current;
      var thumbEle = thumbRef.current;
      scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.addEventListener("touchstart", onThumbMouseDown);
      return function() {
        scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
        thumbEle.removeEventListener("touchstart", onThumbMouseDown);
      };
    }, []);
    var enableScrollRangeRef = React__namespace.useRef();
    enableScrollRangeRef.current = enableScrollRange;
    var enableOffsetRangeRef = React__namespace.useRef();
    enableOffsetRangeRef.current = enableOffsetRange;
    React__namespace.useEffect(function() {
      if (dragging) {
        var moveRafId;
        var onMouseMove = function onMouseMove2(e2) {
          var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
          wrapperRaf.cancel(moveRafId);
          if (stateDragging) {
            var offset = getPageXY(e2, horizontal) - statePageY;
            var newTop = stateStartTop;
            if (!isLTR && horizontal) {
              newTop -= offset;
            } else {
              newTop += offset;
            }
            var tmpEnableScrollRange = enableScrollRangeRef.current;
            var tmpEnableOffsetRange = enableOffsetRangeRef.current;
            var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
            var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
            newScrollTop = Math.max(newScrollTop, 0);
            newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
            moveRafId = wrapperRaf(function() {
              onScroll(newScrollTop, horizontal);
            });
          }
        };
        var onMouseUp = function onMouseUp2() {
          setDragging(false);
          onStopMove();
        };
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchmove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchend", onMouseUp);
        return function() {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("touchmove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          window.removeEventListener("touchend", onMouseUp);
          wrapperRaf.cancel(moveRafId);
        };
      }
    }, [dragging]);
    React__namespace.useEffect(function() {
      delayHidden();
    }, [scrollOffset]);
    React__namespace.useImperativeHandle(ref, function() {
      return {
        delayHidden
      };
    });
    var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
    var containerStyle = {
      position: "absolute",
      visibility: visible && canScroll ? null : "hidden"
    };
    var thumbStyle = {
      position: "absolute",
      background: "rgba(0, 0, 0, 0.5)",
      borderRadius: 99,
      cursor: "pointer",
      userSelect: "none"
    };
    if (horizontal) {
      containerStyle.height = 8;
      containerStyle.left = 0;
      containerStyle.right = 0;
      containerStyle.bottom = 0;
      thumbStyle.height = "100%";
      thumbStyle.width = spinSize;
      if (isLTR) {
        thumbStyle.left = top;
      } else {
        thumbStyle.right = top;
      }
    } else {
      containerStyle.width = 8;
      containerStyle.top = 0;
      containerStyle.bottom = 0;
      if (isLTR) {
        containerStyle.right = 0;
      } else {
        containerStyle.left = 0;
      }
      thumbStyle.width = "100%";
      thumbStyle.height = spinSize;
      thumbStyle.top = top;
    }
    return /* @__PURE__ */ React__namespace.createElement("div", {
      ref: scrollbarRef,
      className: classname(scrollbarPrefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), _defineProperty$1(_classNames, "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), _defineProperty$1(_classNames, "".concat(scrollbarPrefixCls, "-visible"), visible), _classNames)),
      style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
      onMouseDown: onContainerMouseDown,
      onMouseMove: delayHidden
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      ref: thumbRef,
      className: classname("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty$1({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
      style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
      onMouseDown: onThumbMouseDown
    }));
  });
  function Item(_ref) {
    var children = _ref.children, setRef = _ref.setRef;
    var refFunc = React__namespace.useCallback(function(node2) {
      setRef(node2);
    }, []);
    return /* @__PURE__ */ React__namespace.cloneElement(children, {
      ref: refFunc
    });
  }
  function useChildren(list, startIndex, endIndex, scrollWidth, setNodeRef, renderFunc, _ref) {
    var getKey2 = _ref.getKey;
    return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
      var eleIndex = startIndex + index2;
      var node2 = renderFunc(item, eleIndex, {
        style: {
          width: scrollWidth
        }
      });
      var key = getKey2(item);
      return /* @__PURE__ */ React__namespace.createElement(Item, {
        key,
        setRef: function setRef(ele) {
          return setNodeRef(item, ele);
        }
      }, node2);
    });
  }
  var CacheMap = /* @__PURE__ */ function() {
    function CacheMap2() {
      _classCallCheck(this, CacheMap2);
      this.maps = void 0;
      this.id = 0;
      this.maps = /* @__PURE__ */ Object.create(null);
    }
    _createClass(CacheMap2, [{
      key: "set",
      value: function set2(key, value) {
        this.maps[key] = value;
        this.id += 1;
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this.maps[key];
      }
    }]);
    return CacheMap2;
  }();
  function useHeights(getKey2, onItemAdd, onItemRemove) {
    var _React$useState = React__namespace.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
    var instanceRef = React.useRef(/* @__PURE__ */ new Map());
    var heightsRef = React.useRef(new CacheMap());
    var collectRafRef = React.useRef();
    function cancelRaf() {
      wrapperRaf.cancel(collectRafRef.current);
    }
    function collectHeight() {
      var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      cancelRaf();
      var doCollect = function doCollect2() {
        instanceRef.current.forEach(function(element, key) {
          if (element && element.offsetParent) {
            var htmlElement = findDOMNode(element);
            var offsetHeight = htmlElement.offsetHeight;
            if (heightsRef.current.get(key) !== offsetHeight) {
              heightsRef.current.set(key, htmlElement.offsetHeight);
            }
          }
        });
        setUpdatedMark(function(c2) {
          return c2 + 1;
        });
      };
      if (sync) {
        doCollect();
      } else {
        collectRafRef.current = wrapperRaf(doCollect);
      }
    }
    function setInstanceRef(item, instance) {
      var key = getKey2(item);
      var origin = instanceRef.current.get(key);
      if (instance) {
        instanceRef.current.set(key, instance);
        collectHeight();
      } else {
        instanceRef.current.delete(key);
      }
      if (!origin !== !instance) {
        if (instance) {
          onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
        } else {
          onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
        }
      }
    }
    React.useEffect(function() {
      return cancelRaf;
    }, []);
    return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
  }
  var MAX_TIMES = 10;
  function useScrollTo(containerRef, data, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
    var scrollRef = React__namespace.useRef();
    var _React$useState = React__namespace.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
    useLayoutEffect$1(function() {
      if (syncState && syncState.times < MAX_TIMES) {
        if (!containerRef.current) {
          setSyncState(function(ori) {
            return _objectSpread2({}, ori);
          });
          return;
        }
        collectHeight();
        var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index2 = syncState.index, offset = syncState.offset;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        var targetTop = null;
        if (height) {
          var mergedAlign = targetAlign || originAlign;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data.length - 1, index2);
          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey2(data[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
          }
          var leftHeight = mergedAlign === "top" ? offset : height - offset;
          for (var _i = maxLen; _i >= 0; _i -= 1) {
            var _key = getKey2(data[_i]);
            var _cacheHeight = heights.get(_key);
            if (_cacheHeight === void 0) {
              needCollectHeight = true;
              break;
            }
            leftHeight -= _cacheHeight;
            if (leftHeight <= 0) {
              break;
            }
          }
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset;
              break;
            default: {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null) {
            syncScrollTop(targetTop);
          }
          if (targetTop !== syncState.lastTop) {
            needCollectHeight = true;
          }
        }
        if (needCollectHeight) {
          setSyncState(function(ori) {
            return _objectSpread2(_objectSpread2({}, ori), {}, {
              times: ori.times + 1,
              targetAlign: newTargetAlign,
              lastTop: targetTop
            });
          });
        }
      }
    }, [syncState, containerRef.current]);
    return function(arg) {
      if (arg === null || arg === void 0) {
        triggerFlash();
        return;
      }
      wrapperRaf.cancel(scrollRef.current);
      if (typeof arg === "number") {
        syncScrollTop(arg);
      } else if (arg && _typeof(arg) === "object") {
        var index2;
        var align = arg.align;
        if ("index" in arg) {
          index2 = arg.index;
        } else {
          index2 = data.findIndex(function(item) {
            return getKey2(item) === arg.key;
          });
        }
        var _arg$offset = arg.offset, offset = _arg$offset === void 0 ? 0 : _arg$offset;
        setSyncState({
          times: 0,
          index: index2,
          offset,
          originAlign: align
        });
      }
    };
  }
  function findListDiffIndex(originList, targetList, getKey2) {
    var originLen = originList.length;
    var targetLen = targetList.length;
    var shortList;
    var longList;
    if (originLen === 0 && targetLen === 0) {
      return null;
    }
    if (originLen < targetLen) {
      shortList = originList;
      longList = targetList;
    } else {
      shortList = targetList;
      longList = originList;
    }
    var notExistKey = {
      __EMPTY_ITEM__: true
    };
    function getItemKey(item) {
      if (item !== void 0) {
        return getKey2(item);
      }
      return notExistKey;
    }
    var diffIndex = null;
    var multiple = Math.abs(originLen - targetLen) !== 1;
    for (var i = 0; i < longList.length; i += 1) {
      var shortKey = getItemKey(shortList[i]);
      var longKey = getItemKey(longList[i]);
      if (shortKey !== longKey) {
        diffIndex = i;
        multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
        break;
      }
    }
    return diffIndex === null ? null : {
      index: diffIndex,
      multiple
    };
  }
  function useDiffItem(data, getKey2, onDiff) {
    var _React$useState = React__namespace.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
    var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
    React__namespace.useEffect(function() {
      var diff = findListDiffIndex(prevData || [], data || [], getKey2);
      if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
        onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
        setDiffItem(data[diff.index]);
      }
      setPrevData(data);
    }, [data]);
    return [diffItem];
  }
  var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
  const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
    var lockRef = React.useRef(false);
    var lockTimeoutRef = React.useRef(null);
    function lockScroll() {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = true;
      lockTimeoutRef.current = setTimeout(function() {
        lockRef.current = false;
      }, 50);
    }
    var scrollPingRef = React.useRef({
      top: isScrollAtTop,
      bottom: isScrollAtBottom
    });
    scrollPingRef.current.top = isScrollAtTop;
    scrollPingRef.current.bottom = isScrollAtBottom;
    return function(deltaY) {
      var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var originScroll = (
        // Pass origin wheel when on the top
        deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
        deltaY > 0 && scrollPingRef.current.bottom
      );
      if (smoothOffset && originScroll) {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = false;
      } else if (!originScroll || lockRef.current) {
        lockScroll();
      }
      return !lockRef.current && originScroll;
    };
  };
  function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, horizontalScroll, onWheelDelta) {
    var offsetRef = React.useRef(0);
    var nextFrameRef = React.useRef(null);
    var wheelValueRef = React.useRef(null);
    var isMouseScrollRef = React.useRef(false);
    var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    function onWheelY(event, deltaY) {
      wrapperRaf.cancel(nextFrameRef.current);
      offsetRef.current += deltaY;
      wheelValueRef.current = deltaY;
      if (originScroll(deltaY))
        return;
      if (!isFF) {
        event.preventDefault();
      }
      nextFrameRef.current = wrapperRaf(function() {
        var patchMultiple = isMouseScrollRef.current ? 10 : 1;
        onWheelDelta(offsetRef.current * patchMultiple);
        offsetRef.current = 0;
      });
    }
    function onWheelX(event, deltaX) {
      onWheelDelta(deltaX, true);
      if (!isFF) {
        event.preventDefault();
      }
    }
    var wheelDirectionRef = React.useRef(null);
    var wheelDirectionCleanRef = React.useRef(null);
    function onWheel(event) {
      if (!inVirtual)
        return;
      wrapperRaf.cancel(wheelDirectionCleanRef.current);
      wheelDirectionCleanRef.current = wrapperRaf(function() {
        wheelDirectionRef.current = null;
      }, 2);
      var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
      var mergedDeltaX = deltaX;
      var mergedDeltaY = deltaY;
      if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
        mergedDeltaX = deltaY;
        mergedDeltaY = 0;
        wheelDirectionRef.current = "sx";
      }
      var absX = Math.abs(mergedDeltaX);
      var absY = Math.abs(mergedDeltaY);
      if (wheelDirectionRef.current === null) {
        wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
      }
      if (wheelDirectionRef.current === "y") {
        onWheelY(event, mergedDeltaY);
      } else {
        onWheelX(event, mergedDeltaX);
      }
    }
    function onFireFoxScroll(event) {
      if (!inVirtual)
        return;
      isMouseScrollRef.current = event.detail === wheelValueRef.current;
    }
    return [onWheel, onFireFoxScroll];
  }
  var SMOOTH_PTG = 14 / 15;
  function useMobileTouchMove(inVirtual, listRef, callback) {
    var touchedRef = React.useRef(false);
    var touchYRef = React.useRef(0);
    var elementRef = React.useRef(null);
    var intervalRef = React.useRef(null);
    var cleanUpEvents;
    var onTouchMove = function onTouchMove2(e2) {
      if (touchedRef.current) {
        var currentY = Math.ceil(e2.touches[0].pageY);
        var offsetY = touchYRef.current - currentY;
        touchYRef.current = currentY;
        if (callback(offsetY)) {
          e2.preventDefault();
        }
        clearInterval(intervalRef.current);
        intervalRef.current = setInterval(function() {
          offsetY *= SMOOTH_PTG;
          if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
            clearInterval(intervalRef.current);
          }
        }, 16);
      }
    };
    var onTouchEnd = function onTouchEnd2() {
      touchedRef.current = false;
      cleanUpEvents();
    };
    var onTouchStart = function onTouchStart2(e2) {
      cleanUpEvents();
      if (e2.touches.length === 1 && !touchedRef.current) {
        touchedRef.current = true;
        touchYRef.current = Math.ceil(e2.touches[0].pageY);
        elementRef.current = e2.target;
        elementRef.current.addEventListener("touchmove", onTouchMove);
        elementRef.current.addEventListener("touchend", onTouchEnd);
      }
    };
    cleanUpEvents = function cleanUpEvents2() {
      if (elementRef.current) {
        elementRef.current.removeEventListener("touchmove", onTouchMove);
        elementRef.current.removeEventListener("touchend", onTouchEnd);
      }
    };
    useLayoutEffect$1(function() {
      if (inVirtual) {
        listRef.current.addEventListener("touchstart", onTouchStart);
      }
      return function() {
        var _listRef$current;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
        cleanUpEvents();
        clearInterval(intervalRef.current);
      };
    }, [inVirtual]);
  }
  var MIN_SIZE = 20;
  function getSpinSize() {
    var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var baseSize = containerSize / scrollRange * 100;
    if (isNaN(baseSize)) {
      baseSize = 0;
    }
    baseSize = Math.max(baseSize, MIN_SIZE);
    baseSize = Math.min(baseSize, containerSize / 2);
    return Math.floor(baseSize);
  }
  function useGetSize(mergedData, getKey2, heights, itemHeight) {
    var _React$useMemo = React__namespace.useMemo(function() {
      return [/* @__PURE__ */ new Map(), []];
    }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
    var getSize3 = function getSize4(startKey) {
      var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
      var startIndex = key2Index.get(startKey);
      var endIndex = key2Index.get(endKey);
      if (startIndex === void 0 || endIndex === void 0) {
        var dataLen = mergedData.length;
        for (var i = bottomList.length; i < dataLen; i += 1) {
          var _heights$get;
          var item = mergedData[i];
          var key = getKey2(item);
          key2Index.set(key, i);
          var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
          bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
          if (key === startKey) {
            startIndex = i;
          }
          if (key === endKey) {
            endIndex = i;
          }
          if (startIndex !== void 0 && endIndex !== void 0) {
            break;
          }
        }
      }
      return {
        top: bottomList[startIndex - 1] || 0,
        bottom: bottomList[endIndex]
      };
    };
    return getSize3;
  }
  var _excluded$r = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"];
  var EMPTY_DATA = [];
  var ScrollStyle = {
    overflowY: "auto",
    overflowAnchor: "none"
  };
  function RawList(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles2 = props.styles, restProps = _objectWithoutProperties$8(props, _excluded$r);
    var useVirtual = !!(virtual !== false && height && itemHeight);
    var inVirtual = useVirtual && data && (itemHeight * data.length > height || !!scrollWidth);
    var isRTL2 = direction === "rtl";
    var mergedClassName = classname(prefixCls, _defineProperty$1({}, "".concat(prefixCls, "-rtl"), isRTL2), className);
    var mergedData = data || EMPTY_DATA;
    var componentRef = React.useRef();
    var fillerInnerRef = React.useRef();
    var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
    var _useState3 = React.useState(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
    var _useState5 = React.useState(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
    var onScrollbarStartMove = function onScrollbarStartMove2() {
      setScrollMoving(true);
    };
    var onScrollbarStopMove = function onScrollbarStopMove2() {
      setScrollMoving(false);
    };
    var getKey2 = React__namespace.useCallback(function(item) {
      if (typeof itemKey2 === "function") {
        return itemKey2(item);
      }
      return item === null || item === void 0 ? void 0 : item[itemKey2];
    }, [itemKey2]);
    var sharedConfig = {
      getKey: getKey2
    };
    function syncScrollTop(newTop) {
      setOffsetTop(function(origin) {
        var value;
        if (typeof newTop === "function") {
          value = newTop(origin);
        } else {
          value = newTop;
        }
        var alignedTop = keepInRange(value);
        componentRef.current.scrollTop = alignedTop;
        return alignedTop;
      });
    }
    var rangeRef = React.useRef({
      start: 0,
      end: mergedData.length
    });
    var diffItemRef = React.useRef();
    var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
    diffItemRef.current = diffItem;
    var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
    var _React$useMemo = React__namespace.useMemo(function() {
      if (!useVirtual) {
        return {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      if (!inVirtual) {
        var _fillerInnerRef$curre;
        return {
          scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.length;
      for (var i = 0; i < dataLen; i += 1) {
        var item = mergedData[i];
        var key = getKey2(item);
        var cacheHeight = heights.get(key);
        var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
        if (currentItemBottom >= offsetTop && startIndex === void 0) {
          startIndex = i;
          startOffset = itemTop;
        }
        if (currentItemBottom > offsetTop + height && endIndex === void 0) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === void 0) {
        endIndex = mergedData.length - 1;
      }
      endIndex = Math.min(endIndex + 1, mergedData.length - 1);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
    rangeRef.current.start = start;
    rangeRef.current.end = end;
    var _React$useState = React__namespace.useState({
      width: 0,
      height
    }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
    var onHolderResize = function onHolderResize2(sizeInfo) {
      setSize({
        width: sizeInfo.width || sizeInfo.offsetWidth,
        height: sizeInfo.height || sizeInfo.offsetHeight
      });
    };
    var verticalScrollBarRef = React.useRef();
    var horizontalScrollBarRef = React.useRef();
    var horizontalScrollBarSpinSize = React__namespace.useMemo(function() {
      return getSpinSize(size.width, scrollWidth);
    }, [size.width, scrollWidth]);
    var verticalScrollBarSpinSize = React__namespace.useMemo(function() {
      return getSpinSize(size.height, scrollHeight);
    }, [size.height, scrollHeight]);
    var maxScrollHeight = scrollHeight - height;
    var maxScrollHeightRef = React.useRef(maxScrollHeight);
    maxScrollHeightRef.current = maxScrollHeight;
    function keepInRange(newScrollTop) {
      var newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeightRef.current)) {
        newTop = Math.min(newTop, maxScrollHeightRef.current);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    var isScrollAtTop = offsetTop <= 0;
    var isScrollAtBottom = offsetTop >= maxScrollHeight;
    var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    var getVirtualScrollInfo = function getVirtualScrollInfo2() {
      return {
        x: isRTL2 ? -offsetLeft : offsetLeft,
        y: offsetTop
      };
    };
    var lastVirtualScrollInfoRef = React.useRef(getVirtualScrollInfo());
    var triggerScroll = useEvent(function() {
      if (onVirtualScroll) {
        var nextInfo = getVirtualScrollInfo();
        if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
          onVirtualScroll(nextInfo);
          lastVirtualScrollInfoRef.current = nextInfo;
        }
      }
    });
    function onScrollBar(newScrollOffset, horizontal) {
      var newOffset = newScrollOffset;
      if (horizontal) {
        ReactDOM__default.flushSync(function() {
          setOffsetLeft(newOffset);
        });
        triggerScroll();
      } else {
        syncScrollTop(newOffset);
      }
    }
    function onFallbackScroll(e2) {
      var newScrollTop = e2.currentTarget.scrollTop;
      if (newScrollTop !== offsetTop) {
        syncScrollTop(newScrollTop);
      }
      onScroll === null || onScroll === void 0 ? void 0 : onScroll(e2);
      triggerScroll();
    }
    var keepInHorizontalRange = function keepInHorizontalRange2(nextOffsetLeft) {
      var tmpOffsetLeft = nextOffsetLeft;
      var max = scrollWidth - size.width;
      tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
      tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
      return tmpOffsetLeft;
    };
    var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
      if (fromHorizontal) {
        ReactDOM__default.flushSync(function() {
          setOffsetLeft(function(left) {
            var nextOffsetLeft = left + (isRTL2 ? -offsetXY : offsetXY);
            return keepInHorizontalRange(nextOffsetLeft);
          });
        });
        triggerScroll();
      } else {
        syncScrollTop(function(top) {
          var newTop = top + offsetXY;
          return newTop;
        });
      }
    });
    var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
    useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
      if (originScroll(deltaY, smoothOffset)) {
        return false;
      }
      onRawWheel({
        preventDefault: function preventDefault() {
        },
        deltaY
      });
      return true;
    });
    useLayoutEffect$1(function() {
      function onMozMousePixelScroll(e2) {
        if (useVirtual) {
          e2.preventDefault();
        }
      }
      var componentEle = componentRef.current;
      componentEle.addEventListener("wheel", onRawWheel);
      componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      return function() {
        componentEle.removeEventListener("wheel", onRawWheel);
        componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      };
    }, [useVirtual]);
    useLayoutEffect$1(function() {
      if (scrollWidth) {
        setOffsetLeft(function(left) {
          return keepInHorizontalRange(left);
        });
      }
    }, [size.width, scrollWidth]);
    var delayHideScrollBar = function delayHideScrollBar2() {
      var _verticalScrollBarRef, _horizontalScrollBarR;
      (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 ? void 0 : _verticalScrollBarRef.delayHidden();
      (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 ? void 0 : _horizontalScrollBarR.delayHidden();
    };
    var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, function() {
      return collectHeight(true);
    }, syncScrollTop, delayHideScrollBar);
    React__namespace.useImperativeHandle(ref, function() {
      return {
        getScrollInfo: getVirtualScrollInfo,
        scrollTo: function scrollTo2(config2) {
          function isPosScroll(arg) {
            return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
          }
          if (isPosScroll(config2)) {
            if (config2.left !== void 0) {
              setOffsetLeft(keepInHorizontalRange(config2.left));
            }
            _scrollTo(config2.top);
          } else {
            _scrollTo(config2);
          }
        }
      };
    });
    useLayoutEffect$1(function() {
      if (onVisibleChange) {
        var renderList = mergedData.slice(start, end + 1);
        onVisibleChange(renderList, mergedData);
      }
    }, [start, end, mergedData]);
    var getSize3 = useGetSize(mergedData, getKey2, heights, itemHeight);
    var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
      start,
      end,
      virtual: inVirtual,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      rtl: isRTL2,
      getSize: getSize3
    });
    var listChildren = useChildren(mergedData, start, end, scrollWidth, setInstanceRef, children, sharedConfig);
    var componentStyle = null;
    if (height) {
      componentStyle = _objectSpread2(_defineProperty$1({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
      if (useVirtual) {
        componentStyle.overflowY = "hidden";
        if (scrollWidth) {
          componentStyle.overflowX = "hidden";
        }
        if (scrollMoving) {
          componentStyle.pointerEvents = "none";
        }
      }
    }
    var containerProps = {};
    if (isRTL2) {
      containerProps.dir = "rtl";
    }
    return /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
      style: _objectSpread2(_objectSpread2({}, style2), {}, {
        position: "relative"
      }),
      className: mergedClassName
    }, containerProps, restProps), /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onHolderResize
    }, /* @__PURE__ */ React__namespace.createElement(Component2, {
      className: "".concat(prefixCls, "-holder"),
      style: componentStyle,
      ref: componentRef,
      onScroll: onFallbackScroll,
      onMouseEnter: delayHideScrollBar
    }, /* @__PURE__ */ React__namespace.createElement(Filler, {
      prefixCls,
      height: scrollHeight,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      scrollWidth,
      onInnerResize: collectHeight,
      ref: fillerInnerRef,
      innerProps,
      rtl: isRTL2,
      extra: extraContent
    }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ React__namespace.createElement(ScrollBar, {
      ref: verticalScrollBarRef,
      prefixCls,
      scrollOffset: offsetTop,
      scrollRange: scrollHeight,
      rtl: isRTL2,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: verticalScrollBarSpinSize,
      containerSize: size.height,
      style: styles2 === null || styles2 === void 0 ? void 0 : styles2.verticalScrollBar,
      thumbStyle: styles2 === null || styles2 === void 0 ? void 0 : styles2.verticalScrollBarThumb
    }), inVirtual && scrollWidth && /* @__PURE__ */ React__namespace.createElement(ScrollBar, {
      ref: horizontalScrollBarRef,
      prefixCls,
      scrollOffset: offsetLeft,
      scrollRange: scrollWidth,
      rtl: isRTL2,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: horizontalScrollBarSpinSize,
      containerSize: size.width,
      horizontal: true,
      style: styles2 === null || styles2 === void 0 ? void 0 : styles2.horizontalScrollBar,
      thumbStyle: styles2 === null || styles2 === void 0 ? void 0 : styles2.horizontalScrollBarThumb
    }));
  }
  var List = /* @__PURE__ */ React__namespace.forwardRef(RawList);
  List.displayName = "List";
  var SelectContext = /* @__PURE__ */ React__namespace.createContext(null);
  function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion);
  }
  var _excluded$q = ["disabled", "title", "children", "style", "className"];
  function isTitleType(content) {
    return typeof content === "string" || typeof content === "number";
  }
  var OptionList = function OptionList2(_, ref) {
    var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id = _useBaseProps.id, open2 = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
    var _React$useContext = React__namespace.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight;
    var itemPrefixCls = "".concat(prefixCls, "-item");
    var memoFlattenOptions = useMemo(function() {
      return flattenOptions2;
    }, [open2, flattenOptions2], function(prev2, next2) {
      return next2[0] && prev2[1] !== next2[1];
    });
    var listRef = React__namespace.useRef(null);
    var onListMouseDown = function onListMouseDown2(event) {
      event.preventDefault();
    };
    var scrollIntoView = function scrollIntoView2(args) {
      if (listRef.current) {
        listRef.current.scrollTo(typeof args === "number" ? {
          index: args
        } : args);
      }
    };
    var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var len = memoFlattenOptions.length;
      for (var i = 0; i < len; i += 1) {
        var current = (index2 + i * offset + len) % len;
        var _memoFlattenOptions$c = memoFlattenOptions[current], group = _memoFlattenOptions$c.group, data = _memoFlattenOptions$c.data;
        if (!group && !data.disabled) {
          return current;
        }
      }
      return -1;
    };
    var _React$useState = React__namespace.useState(function() {
      return getEnabledActiveIndex(0);
    }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
    var setActive = function setActive2(index2) {
      var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      setActiveIndex(index2);
      var info2 = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      var flattenItem = memoFlattenOptions[index2];
      if (!flattenItem) {
        onActiveValue(null, -1, info2);
        return;
      }
      onActiveValue(flattenItem.value, index2, info2);
    };
    React.useEffect(function() {
      setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, [memoFlattenOptions.length, searchValue]);
    var isSelected = React__namespace.useCallback(function(value) {
      return rawValues.has(value) && mode !== "combobox";
    }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
    React.useEffect(function() {
      var timeoutId = setTimeout(function() {
        if (!multiple && open2 && rawValues.size === 1) {
          var value = Array.from(rawValues)[0];
          var index2 = memoFlattenOptions.findIndex(function(_ref) {
            var data = _ref.data;
            return data.value === value;
          });
          if (index2 !== -1) {
            setActive(index2);
            scrollIntoView(index2);
          }
        }
      });
      if (open2) {
        var _listRef$current;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
      }
      return function() {
        return clearTimeout(timeoutId);
      };
    }, [open2, searchValue]);
    var onSelectValue = function onSelectValue2(value) {
      if (value !== void 0) {
        onSelect(value, {
          selected: !rawValues.has(value)
        });
      }
      if (!multiple) {
        toggleOpen(false);
      }
    };
    React__namespace.useImperativeHandle(ref, function() {
      return {
        onKeyDown: function onKeyDown(event) {
          var which = event.which, ctrlKey = event.ctrlKey;
          switch (which) {
            case KeyCode.N:
            case KeyCode.P:
            case KeyCode.UP:
            case KeyCode.DOWN: {
              var offset = 0;
              if (which === KeyCode.UP) {
                offset = -1;
              } else if (which === KeyCode.DOWN) {
                offset = 1;
              } else if (isPlatformMac() && ctrlKey) {
                if (which === KeyCode.N) {
                  offset = 1;
                } else if (which === KeyCode.P) {
                  offset = -1;
                }
              }
              if (offset !== 0) {
                var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
                scrollIntoView(nextActiveIndex);
                setActive(nextActiveIndex, true);
              }
              break;
            }
            case KeyCode.ENTER: {
              var item = memoFlattenOptions[activeIndex];
              if (item && !item.data.disabled) {
                onSelectValue(item.value);
              } else {
                onSelectValue(void 0);
              }
              if (open2) {
                event.preventDefault();
              }
              break;
            }
            case KeyCode.ESC: {
              toggleOpen(false);
              if (open2) {
                event.stopPropagation();
              }
            }
          }
        },
        onKeyUp: function onKeyUp() {
        },
        scrollTo: function scrollTo2(index2) {
          scrollIntoView(index2);
        }
      };
    });
    if (memoFlattenOptions.length === 0) {
      return /* @__PURE__ */ React__namespace.createElement("div", {
        role: "listbox",
        id: "".concat(id, "_list"),
        className: "".concat(itemPrefixCls, "-empty"),
        onMouseDown: onListMouseDown
      }, notFoundContent);
    }
    var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
      return fieldNames[key];
    });
    var getLabel = function getLabel2(item) {
      return item.label;
    };
    function getItemAriaProps(item, index2) {
      var group = item.group;
      return {
        role: group ? "presentation" : "option",
        id: "".concat(id, "_list_").concat(index2)
      };
    }
    var renderItem = function renderItem2(index2) {
      var item = memoFlattenOptions[index2];
      if (!item)
        return null;
      var itemData = item.data || {};
      var value = itemData.value;
      var group = item.group;
      var attrs = pickAttrs(itemData, true);
      var mergedLabel = getLabel(item);
      return item ? /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
      }, attrs, {
        key: index2
      }, getItemAriaProps(item, index2), {
        "aria-selected": isSelected(value)
      }), value) : null;
    };
    var a11yProps = {
      role: "listbox",
      id: "".concat(id, "_list")
    };
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, virtual && /* @__PURE__ */ React__namespace.createElement("div", _extends$7({}, a11yProps, {
      style: {
        height: 0,
        width: 0,
        overflow: "hidden"
      }
    }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ React__namespace.createElement(List, {
      itemKey: "key",
      ref: listRef,
      data: memoFlattenOptions,
      height: listHeight,
      itemHeight: listItemHeight,
      fullHeight: false,
      onMouseDown: onListMouseDown,
      onScroll: onPopupScroll,
      virtual,
      direction,
      innerProps: virtual ? null : a11yProps
    }, function(item, itemIndex) {
      var _classNames;
      var group = item.group, groupOption = item.groupOption, data = item.data, label = item.label, value = item.value;
      var key = data.key;
      if (group) {
        var _data$title;
        var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
        return /* @__PURE__ */ React__namespace.createElement("div", {
          className: classname(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
          title: groupTitle
        }, label !== void 0 ? label : key);
      }
      var disabled = data.disabled, title = data.title;
      data.children;
      var style2 = data.style, className = data.className, otherProps = _objectWithoutProperties$8(data, _excluded$q);
      var passedProps = omit(otherProps, omitFieldNameList);
      var selected = isSelected(value);
      var optionPrefixCls = "".concat(itemPrefixCls, "-option");
      var optionClassName = classname(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
      var mergedLabel = getLabel(item);
      var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
      var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
      var optionTitle = isTitleType(content) ? content.toString() : void 0;
      if (title !== void 0) {
        optionTitle = title;
      }
      return /* @__PURE__ */ React__namespace.createElement("div", _extends$7({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
        "aria-selected": selected,
        className: optionClassName,
        title: optionTitle,
        onMouseMove: function onMouseMove() {
          if (activeIndex === itemIndex || disabled) {
            return;
          }
          setActive(itemIndex);
        },
        onClick: function onClick() {
          if (!disabled) {
            onSelectValue(value);
          }
        },
        style: style2
      }), /* @__PURE__ */ React__namespace.createElement("div", {
        className: "".concat(optionPrefixCls, "-content")
      }, content), /* @__PURE__ */ React__namespace.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ React__namespace.createElement(TransBtn, {
        className: "".concat(itemPrefixCls, "-option-state"),
        customizeIcon: menuItemSelectedIcon,
        customizeIconProps: {
          value,
          disabled,
          isSelected: selected
        }
      }, selected ? "✓" : null));
    }));
  };
  var RefOptionList = /* @__PURE__ */ React__namespace.forwardRef(OptionList);
  RefOptionList.displayName = "OptionList";
  var _excluded$p = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
  var OMIT_DOM_PROPS = ["inputValue"];
  function isRawValue(value) {
    return !value || _typeof(value) !== "object";
  }
  var Select$2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var id = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, restProps = _objectWithoutProperties$8(props, _excluded$p);
    var mergedId = useId2(id);
    var multiple = isMultiple(mode);
    var childrenAsData = !!(!options && children);
    var mergedFilterOption = React__namespace.useMemo(function() {
      if (filterOption === void 0 && mode === "combobox") {
        return false;
      }
      return filterOption;
    }, [filterOption, mode]);
    var mergedFieldNames = React__namespace.useMemo(
      function() {
        return fillFieldNames(fieldNames, childrenAsData);
      },
      /* eslint-disable react-hooks/exhaustive-deps */
      [
        // We stringify fieldNames to avoid unnecessary re-renders.
        JSON.stringify(fieldNames),
        childrenAsData
      ]
      /* eslint-enable react-hooks/exhaustive-deps */
    );
    var _useMergedState = useMergedState("", {
      value: searchValue !== void 0 ? searchValue : inputValue,
      postState: function postState(search2) {
        return search2 || "";
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
    var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
    var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
    var convert2LabelValues = React__namespace.useCallback(function(draftValues) {
      var valueList = toArray$1(draftValues);
      return valueList.map(function(val) {
        var rawValue;
        var rawLabel;
        var rawKey;
        var rawDisabled;
        var rawTitle;
        if (isRawValue(val)) {
          rawValue = val;
        } else {
          var _val$value;
          rawKey = val.key;
          rawLabel = val.label;
          rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
        }
        var option = valueOptions.get(rawValue);
        if (option) {
          var _option$key;
          if (rawLabel === void 0)
            rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
          if (rawKey === void 0)
            rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
          rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
          rawTitle = option === null || option === void 0 ? void 0 : option.title;
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawKey,
          disabled: rawDisabled,
          title: rawTitle
        };
      });
    }, [mergedFieldNames, optionLabelProp, valueOptions]);
    var _useMergedState3 = useMergedState(defaultValue, {
      value
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
    var rawLabeledValues = React__namespace.useMemo(function() {
      var _values$;
      var values = convert2LabelValues(internalValue);
      if (mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
        return [];
      }
      return values;
    }, [internalValue, convert2LabelValues, mode]);
    var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
    var displayValues = React__namespace.useMemo(function() {
      if (!mode && mergedValues.length === 1) {
        var firstValue = mergedValues[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.map(function(item) {
        var _item$label;
        return _objectSpread2(_objectSpread2({}, item), {}, {
          label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
        });
      });
    }, [mode, mergedValues]);
    var rawValues = React__namespace.useMemo(function() {
      return new Set(mergedValues.map(function(val) {
        return val.value;
      }));
    }, [mergedValues]);
    React__namespace.useEffect(function() {
      if (mode === "combobox") {
        var _mergedValues$;
        var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
        setSearchValue(hasValue(strValue) ? String(strValue) : "");
      }
    }, [mergedValues]);
    var createTagOption = useRefFunc(function(val, label) {
      var _ref;
      var mergedLabel = label !== null && label !== void 0 ? label : val;
      return _ref = {}, _defineProperty$1(_ref, mergedFieldNames.value, val), _defineProperty$1(_ref, mergedFieldNames.label, mergedLabel), _ref;
    });
    var filledTagOptions = React__namespace.useMemo(function() {
      if (mode !== "tags") {
        return mergedOptions;
      }
      var cloneOptions = _toConsumableArray(mergedOptions);
      var existOptions = function existOptions2(val) {
        return valueOptions.has(val);
      };
      _toConsumableArray(mergedValues).sort(function(a, b2) {
        return a.value < b2.value ? -1 : 1;
      }).forEach(function(item) {
        var val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      return cloneOptions;
    }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
    var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
    var filledSearchOptions = React__namespace.useMemo(function() {
      if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
        return item[optionFilterProp || "value"] === mergedSearchValue;
      })) {
        return filteredOptions;
      }
      if (filteredOptions.some(function(item) {
        return item[mergedFieldNames.value] === mergedSearchValue;
      })) {
        return filteredOptions;
      }
      return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
    }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
    var orderedFilteredOptions = React__namespace.useMemo(function() {
      if (!filterSort) {
        return filledSearchOptions;
      }
      return _toConsumableArray(filledSearchOptions).sort(function(a, b2) {
        return filterSort(a, b2);
      });
    }, [filledSearchOptions, filterSort]);
    var displayOptions = React__namespace.useMemo(function() {
      return flattenOptions(orderedFilteredOptions, {
        fieldNames: mergedFieldNames,
        childrenAsData
      });
    }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
    var triggerChange = function triggerChange2(values) {
      var labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (onChange && // Trigger event only when value changed
      (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
        var _mergedValues$index;
        return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
      }))) {
        var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
          return v2.value;
        });
        var returnOptions = labeledValues.map(function(v2) {
          return injectPropsWithOption(getMixedOption(v2.value));
        });
        onChange(
          // Value
          multiple ? returnValues : returnValues[0],
          // Option
          multiple ? returnOptions : returnOptions[0]
        );
      }
    };
    var _React$useState = React__namespace.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
    var _React$useState3 = React__namespace.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
    var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
    var onActiveValue = React__namespace.useCallback(function(active, index2) {
      var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
      setAccessibilityIndex(index2);
      if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
        setActiveValue(String(active));
      }
    }, [backfill, mode]);
    var triggerSelect = function triggerSelect2(val, selected, type4) {
      var getSelectEnt = function getSelectEnt2() {
        var _option$key2;
        var option = getMixedOption(val);
        return [labelInValue ? {
          label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
          value: val,
          key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
        } : val, injectPropsWithOption(option)];
      };
      if (selected && onSelect) {
        var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
        onSelect(wrappedValue, _option);
      } else if (!selected && onDeselect && type4 !== "clear") {
        var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
        onDeselect(_wrappedValue, _option2);
      }
    };
    var onInternalSelect = useRefFunc(function(val, info2) {
      var cloneValues;
      var mergedSelect = multiple ? info2.selected : true;
      if (mergedSelect) {
        cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
      } else {
        cloneValues = mergedValues.filter(function(v2) {
          return v2.value !== val;
        });
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (mode === "combobox") {
        setActiveValue("");
      } else if (!isMultiple || autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    });
    var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info2) {
      triggerChange(nextValues);
      var type4 = info2.type, values = info2.values;
      if (type4 === "remove" || type4 === "clear") {
        values.forEach(function(item) {
          triggerSelect(item.value, false, type4);
        });
      }
    };
    var onInternalSearch = function onInternalSearch2(searchText, info2) {
      setSearchValue(searchText);
      setActiveValue(null);
      if (info2.source === "submit") {
        var formatted = (searchText || "").trim();
        if (formatted) {
          var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info2.source !== "blur") {
        if (mode === "combobox") {
          triggerChange(searchText);
        }
        onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
      }
    };
    var onInternalSearchSplit = function onInternalSearchSplit2(words) {
      var patchValues = words;
      if (mode !== "tags") {
        patchValues = words.map(function(word) {
          var opt = labelOptions.get(word);
          return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter(function(val) {
          return val !== void 0;
        });
      }
      var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
      triggerChange(newRawValues);
      newRawValues.forEach(function(newRawValue) {
        triggerSelect(newRawValue, true);
      });
    };
    var selectContext = React__namespace.useMemo(function() {
      var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
      return _objectSpread2(_objectSpread2({}, parsedOptions), {}, {
        flattenOptions: displayOptions,
        onActiveValue,
        defaultActiveFirstOption: mergedDefaultActiveFirstOption,
        onSelect: onInternalSelect,
        menuItemSelectedIcon,
        rawValues,
        fieldNames: mergedFieldNames,
        virtual: realVirtual,
        direction,
        listHeight,
        listItemHeight,
        childrenAsData
      });
    }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]);
    return /* @__PURE__ */ React__namespace.createElement(SelectContext.Provider, {
      value: selectContext
    }, /* @__PURE__ */ React__namespace.createElement(BaseSelect, _extends$7({}, restProps, {
      // >>> MISC
      id: mergedId,
      prefixCls,
      ref,
      omitDomProps: OMIT_DOM_PROPS,
      mode,
      displayValues,
      onDisplayValuesChange,
      direction,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      autoClearSearchValue,
      onSearchSplit: onInternalSearchSplit,
      dropdownMatchSelectWidth,
      OptionList: RefOptionList,
      emptyOptions: !displayOptions.length,
      activeValue,
      activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
    })));
  });
  var TypedSelect = Select$2;
  TypedSelect.Option = Option;
  TypedSelect.OptGroup = OptGroup;
  function getStatusClassNames(prefixCls, status, hasFeedback) {
    return classname({
      [`${prefixCls}-status-success`]: status === "success",
      [`${prefixCls}-status-warning`]: status === "warning",
      [`${prefixCls}-status-error`]: status === "error",
      [`${prefixCls}-status-validating`]: status === "validating",
      [`${prefixCls}-has-feedback`]: hasFeedback
    });
  }
  const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
  const Empty$2 = () => {
    const [, token2] = useToken();
    const bgColor = new TinyColor(token2.colorBgBase);
    const themeStyle = bgColor.toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {};
    return /* @__PURE__ */ React__namespace.createElement("svg", {
      style: themeStyle,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(24 31.67)"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      fillOpacity: ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    })), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }), /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }))));
  };
  const DefaultEmptyImg = Empty$2;
  const Simple = () => {
    const [, token2] = useToken();
    const {
      colorFill,
      colorFillTertiary,
      colorFillQuaternary,
      colorBgContainer
    } = token2;
    const {
      borderColor,
      shadowColor,
      contentColor
    } = React.useMemo(() => ({
      borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
      shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
      contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
    }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
    return /* @__PURE__ */ React__namespace.createElement("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(0 1)",
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      fill: shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }), /* @__PURE__ */ React__namespace.createElement("g", {
      fillRule: "nonzero",
      stroke: borderColor
    }, /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: contentColor
    }))));
  };
  const SimpleEmptyImg = Simple;
  const genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
        // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            maxWidth: "100%",
            height: "100%",
            margin: "auto"
          }
        },
        [`${componentCls}-description`]: {
          color: token2.colorText
        },
        // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDisabled,
          [`${componentCls}-description`]: {
            color: token2.colorTextDisabled
          },
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  const useStyle$a = genComponentStyleHook("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG
    } = token2;
    const emptyToken = merge(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: controlHeightLG * 2.5,
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: controlHeightLG * 0.875
    });
    return [genSharedEmptyStyle(emptyToken)];
  });
  var __rest$j = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const defaultEmptyImg = /* @__PURE__ */ React__namespace.createElement(DefaultEmptyImg, null);
  const simpleEmptyImg = /* @__PURE__ */ React__namespace.createElement(SimpleEmptyImg, null);
  const Empty = (_a) => {
    var {
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      image = defaultEmptyImg,
      description,
      children,
      imageStyle,
      style: style2
    } = _a, restProps = __rest$j(_a, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
    const {
      getPrefixCls,
      direction,
      empty
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("empty", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$a(prefixCls);
    const [locale2] = useLocale$1("Empty");
    const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
    const alt = typeof des === "string" ? des : "empty";
    let imageNode = null;
    if (typeof image === "string") {
      imageNode = /* @__PURE__ */ React__namespace.createElement("img", {
        alt,
        src: image
      });
    } else {
      imageNode = image;
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", Object.assign({
      className: classname(hashId, prefixCls, empty === null || empty === void 0 ? void 0 : empty.className, {
        [`${prefixCls}-normal`]: image === simpleEmptyImg,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName),
      style: Object.assign(Object.assign({}, empty === null || empty === void 0 ? void 0 : empty.style), style2)
    }, restProps), /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-image`,
      style: imageStyle
    }, imageNode), des && /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-description`
    }, des), children && /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-footer`
    }, children)));
  };
  Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
  Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
  const Empty$1 = Empty;
  const DefaultRenderEmpty = (props) => {
    const {
      componentName
    } = props;
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefix = getPrefixCls("empty");
    switch (componentName) {
      case "Table":
      case "List":
        return /* @__PURE__ */ React.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE
        });
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return /* @__PURE__ */ React.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          className: `${prefix}-small`
        });
      default:
        return /* @__PURE__ */ React.createElement(Empty$1, null);
    }
  };
  const DefaultRenderEmpty$1 = DefaultRenderEmpty;
  const genItemStyle = (token2) => {
    const {
      optionHeight,
      optionFontSize,
      optionLineHeight,
      optionPadding
    } = token2;
    return {
      position: "relative",
      display: "block",
      minHeight: optionHeight,
      padding: optionPadding,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: optionFontSize,
      lineHeight: optionLineHeight,
      boxSizing: "border-box"
    };
  };
  const genSingleStyle$1 = (token2) => {
    const {
      antCls,
      componentCls
    } = token2;
    const selectItemCls = `${componentCls}-item`;
    const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
    const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
    const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
    const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
    return [
      {
        [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          top: -9999,
          zIndex: token2.zIndexPopup,
          boxSizing: "border-box",
          padding: token2.paddingXXS,
          overflow: "hidden",
          fontSize: token2.fontSize,
          // Fix select render lag of long text in chrome
          // https://github.com/ant-design/ant-design/issues/11456
          // https://github.com/ant-design/ant-design/issues/11843
          fontVariant: "initial",
          backgroundColor: token2.colorBgElevated,
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
            animationName: slideUpIn
          },
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownIn
          },
          [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
            animationName: slideUpOut
          },
          [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownOut
          },
          "&-hidden": {
            display: "none"
          },
          [`${selectItemCls}`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
            cursor: "pointer",
            transition: `background ${token2.motionDurationSlow} ease`,
            borderRadius: token2.borderRadiusSM,
            // =========== Group ============
            "&-group": {
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeSM,
              cursor: "default"
            },
            // =========== Option ===========
            "&-option": {
              display: "flex",
              "&-content": Object.assign({
                flex: "auto"
              }, textEllipsis),
              "&-state": {
                flex: "none",
                display: "flex",
                alignItems: "center"
              },
              [`&-active:not(${selectItemCls}-option-disabled)`]: {
                backgroundColor: token2.optionActiveBg
              },
              [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                color: token2.optionSelectedColor,
                fontWeight: token2.optionSelectedFontWeight,
                backgroundColor: token2.optionSelectedBg,
                [`${selectItemCls}-option-state`]: {
                  color: token2.colorPrimary
                }
              },
              "&-disabled": {
                [`&${selectItemCls}-option-selected`]: {
                  backgroundColor: token2.colorBgContainerDisabled
                },
                color: token2.colorTextDisabled,
                cursor: "not-allowed"
              },
              "&-grouped": {
                paddingInlineStart: token2.controlPaddingHorizontal * 2
              }
            }
          }),
          // =========================== RTL ===========================
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Follow code may reuse in other components
      initSlideMotion(token2, "slide-up"),
      initSlideMotion(token2, "slide-down"),
      initMoveMotion(token2, "move-up"),
      initMoveMotion(token2, "move-down")
    ];
  };
  const genDropdownStyle$1 = genSingleStyle$1;
  const FIXED_ITEM_MARGIN = 2;
  const getSelectItemStyle = (_ref) => {
    let {
      multipleSelectItemHeight,
      selectHeight,
      lineWidth: borderWidth
    } = _ref;
    const selectItemDist = (selectHeight - multipleSelectItemHeight) / 2 - borderWidth;
    const selectItemMargin = Math.ceil(selectItemDist / 2);
    return [selectItemDist, selectItemMargin];
  };
  function genSizeStyle$2(token2, suffix) {
    const {
      componentCls,
      iconCls
    } = token2;
    const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
    const selectItemHeight = token2.multipleSelectItemHeight;
    const [selectItemDist] = getSelectItemStyle(token2);
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    return {
      [`${componentCls}-multiple${suffixCls}`]: {
        fontSize: token2.fontSize,
        /**
         * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
         * may update to redesign with its align logic.
         */
        // =========================== Overflow ===========================
        [selectOverflowPrefixCls]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          flexWrap: "wrap",
          maxWidth: "100%",
          "&-item": {
            flex: "none",
            alignSelf: "center",
            maxWidth: "100%",
            display: "inline-flex"
          }
        },
        // ========================= Selector =========================
        [`${componentCls}-selector`]: {
          display: "flex",
          flexWrap: "wrap",
          alignItems: "center",
          height: "100%",
          // Multiple is little different that horizontal is follow the vertical
          padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${FIXED_ITEM_MARGIN * 2}px`,
          borderRadius: token2.borderRadius,
          [`${componentCls}-show-search&`]: {
            cursor: "text"
          },
          [`${componentCls}-disabled&`]: {
            background: token2.multipleSelectorBgDisabled,
            cursor: "not-allowed"
          },
          "&:after": {
            display: "inline-block",
            width: 0,
            margin: `${FIXED_ITEM_MARGIN}px 0`,
            lineHeight: `${selectItemHeight}px`,
            visibility: "hidden",
            content: '"\\a0"'
          }
        },
        [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
          paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
        },
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          display: "flex",
          alignSelf: "center",
          flex: "none",
          boxSizing: "border-box",
          maxWidth: "100%",
          height: selectItemHeight,
          marginTop: FIXED_ITEM_MARGIN,
          marginBottom: FIXED_ITEM_MARGIN,
          lineHeight: `${selectItemHeight - token2.lineWidth * 2}px`,
          background: token2.multipleItemBg,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.multipleItemBorderColor}`,
          borderRadius: token2.borderRadiusSM,
          cursor: "default",
          transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          marginInlineEnd: FIXED_ITEM_MARGIN * 2,
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS / 2,
          [`${componentCls}-disabled&`]: {
            color: token2.multipleItemColorDisabled,
            borderColor: token2.multipleItemBorderColorDisabled,
            cursor: "not-allowed"
          },
          // It's ok not to do this, but 24px makes bottom narrow in view should adjust
          "&-content": {
            display: "inline-block",
            marginInlineEnd: token2.paddingXS / 2,
            overflow: "hidden",
            whiteSpace: "pre",
            textOverflow: "ellipsis"
          },
          "&-remove": Object.assign(Object.assign({}, resetIcon()), {
            display: "inline-flex",
            alignItems: "center",
            color: token2.colorIcon,
            fontWeight: "bold",
            fontSize: 10,
            lineHeight: "inherit",
            cursor: "pointer",
            [`> ${iconCls}`]: {
              verticalAlign: "-0.2em"
            },
            "&:hover": {
              color: token2.colorIconHover
            }
          })
        },
        // ========================== Input ==========================
        [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
          [`${componentCls}-selection-search`]: {
            marginInlineStart: 0
          }
        },
        // https://github.com/ant-design/ant-design/issues/44754
        [`${selectOverflowPrefixCls}-item-suffix`]: {
          height: "100%"
        },
        [`${componentCls}-selection-search`]: {
          display: "inline-flex",
          position: "relative",
          maxWidth: "100%",
          marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
          [`
          &-input,
          &-mirror
        `]: {
            height: selectItemHeight,
            fontFamily: token2.fontFamily,
            lineHeight: `${selectItemHeight}px`,
            transition: `all ${token2.motionDurationSlow}`
          },
          "&-input": {
            width: "100%",
            minWidth: 4.1
            // fix search cursor missing
          },
          "&-mirror": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            insetInlineEnd: "auto",
            zIndex: 999,
            whiteSpace: "pre",
            visibility: "hidden"
          }
        },
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: token2.inputPaddingHorizontalBase,
          insetInlineEnd: token2.inputPaddingHorizontalBase,
          transform: "translateY(-50%)",
          transition: `all ${token2.motionDurationSlow}`
        }
      }
    };
  }
  const genMultipleStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const smallToken = merge(token2, {
      selectHeight: token2.controlHeightSM,
      multipleSelectItemHeight: token2.controlHeightXS,
      borderRadius: token2.borderRadiusSM,
      borderRadiusSM: token2.borderRadiusXS
    });
    const largeToken = merge(token2, {
      fontSize: token2.fontSizeLG,
      selectHeight: token2.controlHeightLG,
      multipleSelectItemHeight: token2.multipleItemHeightLG,
      borderRadius: token2.borderRadiusLG,
      borderRadiusSM: token2.borderRadius
    });
    const [, smSelectItemMargin] = getSelectItemStyle(token2);
    return [
      genSizeStyle$2(token2),
      // ======================== Small ========================
      genSizeStyle$2(smallToken, "sm"),
      // Padding
      {
        [`${componentCls}-multiple${componentCls}-sm`]: {
          [`${componentCls}-selection-placeholder`]: {
            insetInline: token2.controlPaddingHorizontalSM - token2.lineWidth
          },
          // https://github.com/ant-design/ant-design/issues/29559
          [`${componentCls}-selection-search`]: {
            marginInlineStart: smSelectItemMargin
          }
        }
      },
      // ======================== Large ========================
      genSizeStyle$2(largeToken, "lg")
    ];
  };
  const genMultipleStyle$1 = genMultipleStyle;
  function genSizeStyle$1(token2, suffix) {
    const {
      componentCls,
      inputPaddingHorizontalBase,
      borderRadius
    } = token2;
    const selectHeightWithoutBorder = token2.controlHeight - token2.lineWidth * 2;
    const selectionItemPadding = Math.ceil(token2.fontSize * 1.25);
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    return {
      [`${componentCls}-single${suffixCls}`]: {
        fontSize: token2.fontSize,
        height: token2.controlHeight,
        // ========================= Selector =========================
        [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2, true)), {
          display: "flex",
          borderRadius,
          [`${componentCls}-selection-search`]: {
            position: "absolute",
            top: 0,
            insetInlineStart: inputPaddingHorizontalBase,
            insetInlineEnd: inputPaddingHorizontalBase,
            bottom: 0,
            "&-input": {
              width: "100%"
            }
          },
          [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
            padding: 0,
            lineHeight: `${selectHeightWithoutBorder}px`,
            transition: `all ${token2.motionDurationSlow}, visibility 0s`,
            alignSelf: "center"
          },
          [`${componentCls}-selection-placeholder`]: {
            transition: "none",
            pointerEvents: "none"
          },
          // For common baseline align
          [[
            "&:after",
            /* For '' value baseline align */
            `${componentCls}-selection-item:empty:after`,
            /* For undefined value baseline align */
            `${componentCls}-selection-placeholder:empty:after`
          ].join(",")]: {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          }
        }),
        [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
          paddingInlineEnd: selectionItemPadding
        },
        // Opacity selection if open
        [`&${componentCls}-open ${componentCls}-selection-item`]: {
          color: token2.colorTextPlaceholder
        },
        // ========================== Input ==========================
        // We only change the style of non-customize input which is only support by `combobox` mode.
        // Not customize
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selector`]: {
            width: "100%",
            height: "100%",
            padding: `0 ${inputPaddingHorizontalBase}px`,
            [`${componentCls}-selection-search-input`]: {
              height: selectHeightWithoutBorder
            },
            "&:after": {
              lineHeight: `${selectHeightWithoutBorder}px`
            }
          }
        },
        [`&${componentCls}-customize-input`]: {
          [`${componentCls}-selector`]: {
            "&:after": {
              display: "none"
            },
            [`${componentCls}-selection-search`]: {
              position: "static",
              width: "100%"
            },
            [`${componentCls}-selection-placeholder`]: {
              position: "absolute",
              insetInlineStart: 0,
              insetInlineEnd: 0,
              padding: `0 ${inputPaddingHorizontalBase}px`,
              "&:after": {
                display: "none"
              }
            }
          }
        }
      }
    };
  }
  function genSingleStyle(token2) {
    const {
      componentCls
    } = token2;
    const inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
    return [
      genSizeStyle$1(token2),
      // ======================== Small ========================
      // Shared
      genSizeStyle$1(merge(token2, {
        controlHeight: token2.controlHeightSM,
        borderRadius: token2.borderRadiusSM
      }), "sm"),
      // padding
      {
        [`${componentCls}-single${componentCls}-sm`]: {
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selection-search`]: {
              insetInlineStart: inputPaddingHorizontalSM,
              insetInlineEnd: inputPaddingHorizontalSM
            },
            [`${componentCls}-selector`]: {
              padding: `0 ${inputPaddingHorizontalSM}px`
            },
            // With arrow should provides `padding-right` to show the arrow
            [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
              insetInlineEnd: inputPaddingHorizontalSM + token2.fontSize * 1.5
            },
            [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
              paddingInlineEnd: token2.fontSize * 1.5
            }
          }
        }
      },
      // ======================== Large ========================
      // Shared
      genSizeStyle$1(merge(token2, {
        controlHeight: token2.singleItemHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      }), "lg")
    ];
  }
  const genSelectorStyle = (token2) => {
    const {
      componentCls,
      selectorBg
    } = token2;
    return {
      position: "relative",
      backgroundColor: selectorBg,
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      input: {
        cursor: "pointer"
      },
      [`${componentCls}-show-search&`]: {
        cursor: "text",
        input: {
          cursor: "auto",
          color: "inherit",
          height: "100%"
        }
      },
      [`${componentCls}-disabled&`]: {
        color: token2.colorTextDisabled,
        background: token2.colorBgContainerDisabled,
        cursor: "not-allowed",
        [`${componentCls}-multiple&`]: {
          background: token2.multipleSelectorBgDisabled
        },
        input: {
          cursor: "not-allowed"
        }
      }
    };
  };
  const genStatusStyle$1 = function(rootSelectCls, token2) {
    let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const {
      componentCls,
      borderHoverColor,
      antCls,
      borderActiveColor,
      outlineColor,
      controlOutlineWidth
    } = token2;
    const overwriteStyle = overwriteDefaultBorder ? {
      [`${componentCls}-selector`]: {
        borderColor: borderActiveColor
      }
    } : {};
    return {
      [rootSelectCls]: {
        [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: Object.assign(Object.assign({}, overwriteStyle), {
          [`&:hover ${componentCls}-selector`]: {
            borderColor: borderHoverColor
          },
          [`${componentCls}-focused& ${componentCls}-selector`]: {
            borderColor: borderActiveColor,
            boxShadow: `0 0 0 ${controlOutlineWidth}px ${outlineColor}`,
            outline: 0
          }
        })
      }
    };
  };
  const getSearchInputWithoutBorderStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-selection-search-input`]: {
        margin: 0,
        padding: 0,
        background: "transparent",
        border: "none",
        outline: "none",
        appearance: "none",
        fontFamily: "inherit",
        "&::-webkit-search-cancel-button": {
          display: "none",
          "-webkit-appearance": "none"
        }
      }
    };
  };
  const genBaseStyle$1 = (token2) => {
    const {
      antCls,
      componentCls,
      inputPaddingHorizontalBase,
      iconCls
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        cursor: "pointer",
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
        // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
        //   ...genHoverStyle(token),
        // },
        // ======================== Selection ========================
        [`${componentCls}-selection-item`]: Object.assign(Object.assign({
          flex: 1,
          fontWeight: "normal",
          position: "relative",
          userSelect: "none"
        }, textEllipsis), {
          // https://github.com/ant-design/ant-design/issues/40421
          [`> ${antCls}-typography`]: {
            display: "inline"
          }
        }),
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
          flex: 1,
          color: token2.colorTextPlaceholder,
          pointerEvents: "none"
        }),
        // ========================== Arrow ==========================
        [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          height: token2.fontSizeIcon,
          marginTop: -token2.fontSizeIcon / 2,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          textAlign: "center",
          pointerEvents: "none",
          display: "flex",
          alignItems: "center",
          [iconCls]: {
            verticalAlign: "top",
            transition: `transform ${token2.motionDurationSlow}`,
            "> svg": {
              verticalAlign: "top"
            },
            [`&:not(${componentCls}-suffix)`]: {
              pointerEvents: "auto"
            }
          },
          [`${componentCls}-disabled &`]: {
            cursor: "not-allowed"
          },
          "> *:not(:last-child)": {
            marginInlineEnd: 8
            // FIXME: magic
          }
        }),
        // ========================== Clear ==========================
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          zIndex: 1,
          display: "inline-block",
          width: token2.fontSizeIcon,
          height: token2.fontSizeIcon,
          marginTop: -token2.fontSizeIcon / 2,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          fontStyle: "normal",
          lineHeight: 1,
          textAlign: "center",
          textTransform: "none",
          background: token2.clearBg,
          cursor: "pointer",
          opacity: 0,
          transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
          textRendering: "auto",
          "&:before": {
            display: "block"
          },
          "&:hover": {
            color: token2.colorTextTertiary
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          }
        }
      }),
      // ========================= Feedback ==========================
      [`${componentCls}-has-feedback`]: {
        [`${componentCls}-clear`]: {
          insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXS
        }
      }
    };
  };
  const genSelectStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      {
        [componentCls]: {
          // ==================== BorderLess ====================
          [`&-borderless ${componentCls}-selector`]: {
            backgroundColor: `transparent !important`,
            borderColor: `transparent !important`,
            boxShadow: `none !important`
          },
          // ==================== In Form ====================
          [`&${componentCls}-in-form-item`]: {
            width: "100%"
          }
        }
      },
      // =====================================================
      // ==                       LTR                       ==
      // =====================================================
      // Base
      genBaseStyle$1(token2),
      // Single
      genSingleStyle(token2),
      // Multiple
      genMultipleStyle$1(token2),
      // Dropdown
      genDropdownStyle$1(token2),
      // =====================================================
      // ==                       RTL                       ==
      // =====================================================
      {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      },
      // =====================================================
      // ==                     Status                      ==
      // =====================================================
      genStatusStyle$1(componentCls, merge(token2, {
        borderHoverColor: token2.colorPrimaryHover,
        borderActiveColor: token2.colorPrimary,
        outlineColor: token2.controlOutline
      })),
      genStatusStyle$1(`${componentCls}-status-error`, merge(token2, {
        borderHoverColor: token2.colorErrorHover,
        borderActiveColor: token2.colorError,
        outlineColor: token2.colorErrorOutline
      }), true),
      genStatusStyle$1(`${componentCls}-status-warning`, merge(token2, {
        borderHoverColor: token2.colorWarningHover,
        borderActiveColor: token2.colorWarning,
        outlineColor: token2.colorWarningOutline
      }), true),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(token2, {
        borderElCls: `${componentCls}-selector`,
        focusElCls: `${componentCls}-focused`
      })
    ];
  };
  const useSelectStyle = genComponentStyleHook("Select", (token2, _ref) => {
    let {
      rootPrefixCls
    } = _ref;
    const selectToken = merge(token2, {
      rootPrefixCls,
      inputPaddingHorizontalBase: token2.paddingSM - 1,
      multipleSelectItemHeight: token2.multipleItemHeight,
      selectHeight: token2.controlHeight
    });
    return [genSelectStyle(selectToken)];
  }, (token2) => {
    const {
      fontSize,
      lineHeight,
      controlHeight,
      controlPaddingHorizontal,
      zIndexPopupBase,
      colorText,
      fontWeightStrong,
      controlItemBgActive,
      controlItemBgHover,
      colorBgContainer,
      colorFillSecondary,
      controlHeightLG,
      controlHeightSM,
      colorBgContainerDisabled,
      colorTextDisabled
    } = token2;
    return {
      zIndexPopup: zIndexPopupBase + 50,
      optionSelectedColor: colorText,
      optionSelectedFontWeight: fontWeightStrong,
      optionSelectedBg: controlItemBgActive,
      optionActiveBg: controlItemBgHover,
      optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
      optionFontSize: fontSize,
      optionLineHeight: lineHeight,
      optionHeight: controlHeight,
      selectorBg: colorBgContainer,
      clearBg: colorBgContainer,
      singleItemHeightLG: controlHeightLG,
      multipleItemBg: colorFillSecondary,
      multipleItemBorderColor: "transparent",
      multipleItemHeight: controlHeightSM,
      multipleItemHeightLG: controlHeight,
      multipleSelectorBgDisabled: colorBgContainerDisabled,
      multipleItemColorDisabled: colorTextDisabled,
      multipleItemBorderColorDisabled: "transparent"
    };
  });
  const getBuiltInPlacements2 = (popupOverflow) => {
    const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
    const sharedConfig = {
      overflow: {
        adjustX: true,
        adjustY: true,
        shiftY: true
      },
      htmlRegion,
      dynamicInset: true
    };
    return {
      bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
        points: ["tl", "bl"],
        offset: [0, 4]
      }),
      bottomRight: Object.assign(Object.assign({}, sharedConfig), {
        points: ["tr", "br"],
        offset: [0, 4]
      }),
      topLeft: Object.assign(Object.assign({}, sharedConfig), {
        points: ["bl", "tl"],
        offset: [0, -4]
      }),
      topRight: Object.assign(Object.assign({}, sharedConfig), {
        points: ["br", "tr"],
        offset: [0, -4]
      })
    };
  };
  function useBuiltinPlacements(buildInPlacements, popupOverflow) {
    return buildInPlacements || getBuiltInPlacements2(popupOverflow);
  }
  function useShowArrow(suffixIcon, showArrow) {
    return showArrow !== void 0 ? showArrow : suffixIcon !== null;
  }
  var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
  const CheckOutlinedSvg = CheckOutlined$2;
  var CheckOutlined = function CheckOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: CheckOutlinedSvg
    }));
  };
  const CheckOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(CheckOutlined);
  var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
  const DownOutlinedSvg = DownOutlined$2;
  var DownOutlined = function DownOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: DownOutlinedSvg
    }));
  };
  const DownOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(DownOutlined);
  var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
  const SearchOutlinedSvg = SearchOutlined$2;
  var SearchOutlined = function SearchOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: SearchOutlinedSvg
    }));
  };
  const SearchOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(SearchOutlined);
  function useIcons(_ref) {
    let {
      suffixIcon,
      clearIcon,
      menuItemSelectedIcon,
      removeIcon,
      loading,
      multiple,
      hasFeedback,
      prefixCls,
      showSuffixIcon,
      feedbackIcon,
      showArrow,
      componentName
    } = _ref;
    const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null);
    const getSuffixIconNode = (arrowIcon) => {
      if (suffixIcon === null && !hasFeedback && !showArrow) {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
    };
    let mergedSuffixIcon = null;
    if (suffixIcon !== void 0) {
      mergedSuffixIcon = getSuffixIconNode(suffixIcon);
    } else if (loading) {
      mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ React__namespace.createElement(LoadingOutlined$1, {
        spin: true
      }));
    } else {
      const iconCls = `${prefixCls}-suffix`;
      mergedSuffixIcon = (_ref2) => {
        let {
          open: open2,
          showSearch
        } = _ref2;
        if (open2 && showSearch) {
          return getSuffixIconNode(/* @__PURE__ */ React__namespace.createElement(SearchOutlined$1, {
            className: iconCls
          }));
        }
        return getSuffixIconNode(/* @__PURE__ */ React__namespace.createElement(DownOutlined$1, {
          className: iconCls
        }));
      };
    }
    let mergedItemIcon = null;
    if (menuItemSelectedIcon !== void 0) {
      mergedItemIcon = menuItemSelectedIcon;
    } else if (multiple) {
      mergedItemIcon = /* @__PURE__ */ React__namespace.createElement(CheckOutlined$1, null);
    } else {
      mergedItemIcon = null;
    }
    let mergedRemoveIcon = null;
    if (removeIcon !== void 0) {
      mergedRemoveIcon = removeIcon;
    } else {
      mergedRemoveIcon = /* @__PURE__ */ React__namespace.createElement(CloseOutlined$1, null);
    }
    return {
      clearIcon: mergedClearIcon,
      suffixIcon: mergedSuffixIcon,
      itemIcon: mergedItemIcon,
      removeIcon: mergedRemoveIcon
    };
  }
  var __rest$i = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
  const InternalSelect = (_a, ref) => {
    var _b;
    var {
      prefixCls: customizePrefixCls,
      bordered = true,
      className,
      rootClassName,
      getPopupContainer,
      popupClassName,
      dropdownClassName,
      listHeight = 256,
      placement,
      listItemHeight = 24,
      size: customizeSize,
      disabled: customDisabled,
      notFoundContent,
      status: customStatus,
      builtinPlacements,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      direction: propDirection,
      style: style2,
      allowClear
    } = _a, props = __rest$i(_a, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear"]);
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      renderEmpty,
      direction: contextDirection,
      virtual,
      popupMatchSelectWidth: contextPopupMatchSelectWidth,
      popupOverflow,
      select
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("select", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const direction = propDirection !== null && propDirection !== void 0 ? propDirection : contextDirection;
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const [wrapSSR, hashId] = useSelectStyle(prefixCls);
    const mode = React__namespace.useMemo(() => {
      const {
        mode: m2
      } = props;
      if (m2 === "combobox") {
        return void 0;
      }
      if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return m2;
    }, [props.mode]);
    const isMultiple2 = mode === "multiple" || mode === "tags";
    const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
    const mergedPopupMatchSelectWidth = (_b = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _b !== void 0 ? _b : contextPopupMatchSelectWidth;
    const {
      status: contextStatus,
      hasFeedback,
      isFormItemInput,
      feedbackIcon
    } = React__namespace.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    let mergedNotFound;
    if (notFoundContent !== void 0) {
      mergedNotFound = notFoundContent;
    } else if (mode === "combobox") {
      mergedNotFound = null;
    } else {
      mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ React__namespace.createElement(DefaultRenderEmpty$1, {
        componentName: "Select"
      });
    }
    const {
      suffixIcon,
      itemIcon,
      removeIcon,
      clearIcon
    } = useIcons(Object.assign(Object.assign({}, props), {
      multiple: isMultiple2,
      hasFeedback,
      feedbackIcon,
      showSuffixIcon,
      prefixCls,
      showArrow: props.showArrow,
      componentName: "Select"
    }));
    const mergedAllowClear = allowClear === true ? {
      clearIcon
    } : allowClear;
    const selectProps = omit(props, ["suffixIcon", "itemIcon"]);
    const rcSelectRtlDropdownClassName = classname(popupClassName || dropdownClassName, {
      [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
    }, rootClassName, hashId);
    const mergedSize = useSize$1((ctx) => {
      var _a2;
      return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
    });
    const disabled = React__namespace.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const mergedClassName = classname({
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-borderless`]: !bordered,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, select === null || select === void 0 ? void 0 : select.className, className, rootClassName, hashId);
    const memoPlacement = React__namespace.useMemo(() => {
      if (placement !== void 0) {
        return placement;
      }
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }, [placement, direction]);
    const mergedBuiltinPlacements = useBuiltinPlacements(builtinPlacements, popupOverflow);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(TypedSelect, Object.assign({
      ref,
      virtual,
      showSearch: select === null || select === void 0 ? void 0 : select.showSearch
    }, selectProps, {
      style: Object.assign(Object.assign({}, select === null || select === void 0 ? void 0 : select.style), style2),
      dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
      builtinPlacements: mergedBuiltinPlacements,
      transitionName: getTransitionName(rootPrefixCls, "slide-up", props.transitionName),
      listHeight,
      listItemHeight,
      mode,
      prefixCls,
      placement: memoPlacement,
      direction,
      suffixIcon,
      menuItemSelectedIcon: itemIcon,
      removeIcon,
      allowClear: mergedAllowClear,
      notFoundContent: mergedNotFound,
      className: mergedClassName,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      dropdownClassName: rcSelectRtlDropdownClassName,
      disabled: mergedDisabled
    })));
  };
  const Select = /* @__PURE__ */ React__namespace.forwardRef(InternalSelect);
  const PurePanel$5 = genPurePanel(Select);
  Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
  Select.Option = Option;
  Select.OptGroup = OptGroup;
  Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$5;
  const Select$1 = Select;
  function Popup(props) {
    var children = props.children, prefixCls = props.prefixCls, id = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname("".concat(prefixCls, "-content"), className),
      style: style2
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-inner"),
      id,
      role: "tooltip",
      style: overlayInnerStyle
    }, typeof children === "function" ? children() : children));
  }
  var autoAdjustOverflowTopBottom = {
    shiftX: 64,
    adjustY: 1
  };
  var autoAdjustOverflowLeftRight = {
    adjustX: 1,
    shiftY: true
  };
  var targetOffset$1 = [0, 0];
  var placements$2 = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    }
  };
  var _excluded$o = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
  var Tooltip$2 = function Tooltip(props, ref) {
    var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
    props.arrowContent;
    var overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties$8(props, _excluded$o);
    var triggerRef = React.useRef(null);
    React.useImperativeHandle(ref, function() {
      return triggerRef.current;
    });
    var extraProps = _objectSpread2({}, restProps);
    if ("visible" in props) {
      extraProps.popupVisible = props.visible;
    }
    var getPopupElement = function getPopupElement2() {
      return /* @__PURE__ */ React__namespace.createElement(Popup, {
        key: "content",
        prefixCls,
        id,
        overlayInnerStyle
      }, overlay);
    };
    return /* @__PURE__ */ React__namespace.createElement(Trigger, _extends$7({
      popupClassName: overlayClassName,
      prefixCls,
      popup: getPopupElement,
      action: trigger,
      builtinPlacements: placements$2,
      popupPlacement: placement,
      ref: triggerRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onPopupVisibleChange: onVisibleChange,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupMotion: motion2,
      defaultPopupVisible: defaultVisible,
      autoDestroy: destroyTooltipOnHide,
      mouseLeaveDelay,
      popupStyle: overlayStyle,
      mouseEnterDelay,
      arrow: showArrow
    }, extraProps), children);
  };
  const Tooltip$3 = /* @__PURE__ */ React.forwardRef(Tooltip$2);
  const MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffset(options) {
    const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
    const {
      contentRadius,
      limitVerticalRadius
    } = options;
    const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
    const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
    return {
      dropdownArrowOffset,
      dropdownArrowOffsetVertical
    };
  }
  function isInject(valid, code) {
    if (!valid)
      return {};
    return code;
  }
  function getArrowStyle(token2, options) {
    const {
      componentCls,
      sizePopupArrow,
      borderRadiusXS,
      borderRadiusOuter,
      boxShadowPopoverArrow
    } = token2;
    const {
      colorBg,
      contentRadius = token2.borderRadiusLG,
      limitVerticalRadius,
      arrowDistance = 0,
      arrowPlacement = {
        left: true,
        right: true,
        top: true,
        bottom: true
      }
    } = options;
    const {
      dropdownArrowOffsetVertical,
      dropdownArrowOffset
    } = getArrowOffset({
      contentRadius,
      limitVerticalRadius
    });
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
        // ============================ Basic ============================
        [`${componentCls}-arrow`]: [Object.assign(Object.assign({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
          "&:before": {
            background: colorBg
          }
        })]
      }, isInject(!!arrowPlacement.top, {
        [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-topRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        }
      })), isInject(!!arrowPlacement.bottom, {
        [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        [`&-placement-bottomLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-bottomRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        }
      })), isInject(!!arrowPlacement.left, {
        [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-leftBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        }
      })), isInject(!!arrowPlacement.right, {
        [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-rightBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        }
      }))
    };
  }
  function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
    if (autoAdjustOverflow2 === false) {
      return {
        adjustX: false,
        adjustY: false
      };
    }
    const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
    const baseOverflow = {};
    switch (placement) {
      case "top":
      case "bottom":
        baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
        baseOverflow.shiftY = true;
        baseOverflow.adjustY = true;
        break;
      case "left":
      case "right":
        baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
        baseOverflow.shiftX = true;
        baseOverflow.adjustX = true;
        break;
    }
    const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
    if (!mergedOverflow.shiftX) {
      mergedOverflow.adjustX = true;
    }
    if (!mergedOverflow.shiftY) {
      mergedOverflow.adjustY = true;
    }
    return mergedOverflow;
  }
  const PlacementAlignMap = {
    left: {
      points: ["cr", "cl"]
    },
    right: {
      points: ["cl", "cr"]
    },
    top: {
      points: ["bc", "tc"]
    },
    bottom: {
      points: ["tc", "bc"]
    },
    topLeft: {
      points: ["bl", "tl"]
    },
    leftTop: {
      points: ["tr", "tl"]
    },
    topRight: {
      points: ["br", "tr"]
    },
    rightTop: {
      points: ["tl", "tr"]
    },
    bottomRight: {
      points: ["tr", "br"]
    },
    rightBottom: {
      points: ["bl", "br"]
    },
    bottomLeft: {
      points: ["tl", "bl"]
    },
    leftBottom: {
      points: ["br", "bl"]
    }
  };
  const ArrowCenterPlacementAlignMap = {
    topLeft: {
      points: ["bl", "tc"]
    },
    leftTop: {
      points: ["tr", "cl"]
    },
    topRight: {
      points: ["br", "tc"]
    },
    rightTop: {
      points: ["tl", "cr"]
    },
    bottomRight: {
      points: ["tr", "bc"]
    },
    rightBottom: {
      points: ["bl", "cr"]
    },
    bottomLeft: {
      points: ["tl", "bc"]
    },
    leftBottom: {
      points: ["br", "cl"]
    }
  };
  const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
  function getPlacements(config2) {
    const {
      arrowWidth,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowPointAtCenter,
      offset,
      borderRadius,
      visibleFirst
    } = config2;
    const halfArrowWidth = arrowWidth / 2;
    const placementMap = {};
    Object.keys(PlacementAlignMap).forEach((key) => {
      const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
      const placementInfo = Object.assign(Object.assign({}, template), {
        offset: [0, 0],
        dynamicInset: true
      });
      placementMap[key] = placementInfo;
      if (DisableAutoArrowList.has(key)) {
        placementInfo.autoArrow = false;
      }
      switch (key) {
        case "top":
        case "topLeft":
        case "topRight":
          placementInfo.offset[1] = -halfArrowWidth - offset;
          break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
          placementInfo.offset[1] = halfArrowWidth + offset;
          break;
        case "left":
        case "leftTop":
        case "leftBottom":
          placementInfo.offset[0] = -halfArrowWidth - offset;
          break;
        case "right":
        case "rightTop":
        case "rightBottom":
          placementInfo.offset[0] = halfArrowWidth + offset;
          break;
      }
      const arrowOffset = getArrowOffset({
        contentRadius: borderRadius,
        limitVerticalRadius: true
      });
      if (arrowPointAtCenter) {
        switch (key) {
          case "topLeft":
          case "bottomLeft":
            placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
            break;
          case "topRight":
          case "bottomRight":
            placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
            break;
          case "leftTop":
          case "rightTop":
            placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
            break;
          case "leftBottom":
          case "rightBottom":
            placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
            break;
        }
      }
      placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
      if (visibleFirst) {
        placementInfo.htmlRegion = "visibleFirst";
      }
    });
    return placementMap;
  }
  const genTooltipStyle = (token2) => {
    const {
      componentCls,
      // ant-tooltip
      tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      tooltipRadiusOuter
    } = token2;
    return [
      {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          width: "max-content",
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
          "&-hidden": {
            display: "none"
          },
          "--antd-arrow-background-color": tooltipBg,
          // Wrapper for the tooltip content
          [`${componentCls}-inner`]: {
            minWidth: controlHeight,
            minHeight: controlHeight,
            padding: `${paddingSM / 2}px ${paddingXS}px`,
            color: tooltipColor,
            textAlign: "start",
            textDecoration: "none",
            wordWrap: "break-word",
            backgroundColor: tooltipBg,
            borderRadius: tooltipBorderRadius,
            boxShadow: boxShadowSecondary,
            boxSizing: "border-box"
          },
          // Limit left and right placement radius
          [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          }
        }), genPresetColor(token2, (colorKey, _ref) => {
          let {
            darkColor
          } = _ref;
          return {
            [`&${componentCls}-${colorKey}`]: {
              [`${componentCls}-inner`]: {
                backgroundColor: darkColor
              },
              [`${componentCls}-arrow`]: {
                "--antd-arrow-background-color": darkColor
              }
            }
          };
        })), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Arrow Style
      getArrowStyle(merge(token2, {
        borderRadiusOuter: tooltipRadiusOuter
      }), {
        colorBg: "var(--antd-arrow-background-color)",
        contentRadius: tooltipBorderRadius,
        limitVerticalRadius: true
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: token2.sizePopupArrow
        }
      }
    ];
  };
  const useStyle$9 = (prefixCls, injectStyle) => {
    const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
      if (injectStyle === false) {
        return [];
      }
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgDefault,
        borderRadiusOuter
      } = token2;
      const TooltipToken = merge(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgDefault,
        tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, (_ref2) => {
      let {
        zIndexPopupBase,
        colorBgSpotlight
      } = _ref2;
      return {
        zIndexPopup: zIndexPopupBase + 70,
        colorBgDefault: colorBgSpotlight
      };
    }, {
      resetStyle: false
    });
    return useOriginHook(prefixCls);
  };
  const inverseColors = PresetColors.map((color) => `${color}-inverse`);
  const PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
  function isPresetColor(color) {
    let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (includeInverse) {
      return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
    }
    return PresetColors.includes(color);
  }
  function isPresetStatusColor(color) {
    return PresetStatusColorTypes.includes(color);
  }
  function parseColor(prefixCls, color) {
    const isInternalColor = isPresetColor(color);
    const className = classname({
      [`${prefixCls}-${color}`]: color && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    if (color && !isInternalColor) {
      overlayStyle.background = color;
      arrowStyle["--antd-arrow-background-color"] = color;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  }
  const PurePanel$3 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      placement = "top",
      title,
      color,
      overlayInnerStyle
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$9(prefixCls, true);
    const colorInfo = parseColor(prefixCls, color);
    const arrowContentStyle = colorInfo.arrowStyle;
    const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
    const cls = classname(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls,
      style: arrowContentStyle
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-arrow`
    }), /* @__PURE__ */ React__namespace.createElement(Popup, Object.assign({}, props, {
      className: hashId,
      prefixCls,
      overlayInnerStyle: formattedOverlayInnerStyle
    }), title)));
  };
  const PurePanel$4 = PurePanel$3;
  var __rest$h = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const Tooltip2 = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    var _a, _b;
    const {
      prefixCls: customizePrefixCls,
      openClassName,
      getTooltipContainer,
      overlayClassName,
      color,
      overlayInnerStyle,
      children,
      afterOpenChange,
      afterVisibleChange,
      destroyTooltipOnHide,
      arrow: arrow2 = true,
      title,
      overlay,
      builtinPlacements,
      arrowPointAtCenter = false,
      autoAdjustOverflow: autoAdjustOverflow2 = true
    } = props;
    const mergedShowArrow = !!arrow2;
    const [, token2] = useToken();
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const warning3 = devUseWarning();
    const tooltipRef = React__namespace.useRef(null);
    const forceAlign = () => {
      var _a2;
      (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
    };
    React__namespace.useImperativeHandle(ref, () => ({
      forceAlign,
      forcePopupAlign: () => {
        warning3.deprecated(false, "forcePopupAlign", "forceAlign");
        forceAlign();
      }
    }));
    const [open2, setOpen] = useMergedState(false, {
      value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
      defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
    });
    const noTitle = !title && !overlay && title !== 0;
    const onOpenChange = (vis) => {
      var _a2, _b2;
      setOpen(noTitle ? false : vis);
      if (!noTitle) {
        (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
        (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
      }
    };
    const tooltipPlacements = React__namespace.useMemo(() => {
      var _a2, _b2;
      let mergedArrowPointAtCenter = arrowPointAtCenter;
      if (typeof arrow2 === "object") {
        mergedArrowPointAtCenter = (_b2 = (_a2 = arrow2.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow2.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
      }
      return builtinPlacements || getPlacements({
        arrowPointAtCenter: mergedArrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius,
        offset: token2.marginXXS,
        visibleFirst: true
      });
    }, [arrowPointAtCenter, arrow2, builtinPlacements, token2]);
    const memoOverlay = React__namespace.useMemo(() => {
      if (title === 0) {
        return title;
      }
      return overlay || title || "";
    }, [overlay, title]);
    const memoOverlayWrapper = /* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
    const {
      getPopupContainer,
      placement = "top",
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      overlayStyle,
      rootClassName
    } = props, otherProps = __rest$h(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const injectFromPopover = props["data-popover-inject"];
    let tempOpen = open2;
    if (!("open" in props) && !("visible" in props) && noTitle) {
      tempOpen = false;
    }
    const child = isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ React__namespace.createElement("span", null, children);
    const childProps = child.props;
    const childCls = !childProps.className || typeof childProps.className === "string" ? classname(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
    const [wrapSSR, hashId] = useStyle$9(prefixCls, !injectFromPopover);
    const colorInfo = parseColor(prefixCls, color);
    const arrowContentStyle = colorInfo.arrowStyle;
    const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
    const customOverlayClassName = classname(overlayClassName, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, colorInfo.className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(Tooltip$3, Object.assign({}, otherProps, {
      showArrow: mergedShowArrow,
      placement,
      mouseEnterDelay,
      mouseLeaveDelay,
      prefixCls,
      overlayClassName: customOverlayClassName,
      overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
      getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
      ref: tooltipRef,
      builtinPlacements: tooltipPlacements,
      overlay: memoOverlayWrapper,
      visible: tempOpen,
      onVisibleChange: onOpenChange,
      afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
      overlayInnerStyle: formattedOverlayInnerStyle,
      arrowContent: /* @__PURE__ */ React__namespace.createElement("span", {
        className: `${prefixCls}-arrow-content`
      }),
      motion: {
        motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
        motionDeadline: 1e3
      },
      destroyTooltipOnHide: !!destroyTooltipOnHide
    }), tempOpen ? cloneElement(child, {
      className: childCls
    }) : child));
  });
  Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
  const Tooltip$1 = Tooltip2;
  var VerticalAlignTopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
  const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;
  var VerticalAlignTopOutlined = function VerticalAlignTopOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: VerticalAlignTopOutlinedSvg
    }));
  };
  const VerticalAlignTopOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(VerticalAlignTopOutlined);
  const antStatusProcessing = new Keyframe("antStatusProcessing", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(2.4)",
      opacity: 0
    }
  });
  const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
    "0%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1) translate(50%, -50%)"
    }
  });
  const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
    "0%": {
      transform: "scale(1) translate(50%, -50%)"
    },
    "100%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    }
  });
  const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
    "0%": {
      transform: "scale(0)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)"
    }
  });
  const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0)",
      opacity: 0
    }
  });
  const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
    "0%": {
      transformOrigin: "50%"
    },
    "100%": {
      transform: "translate(50%, -50%) rotate(360deg)",
      transformOrigin: "50%"
    }
  });
  const genSharedBadgeStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      antCls,
      badgeShadowSize,
      motionDurationSlow,
      textFontSize,
      textFontSizeSM,
      statusSize,
      dotSize,
      textFontWeight,
      indicatorHeight,
      indicatorHeightSM,
      marginXS
    } = token2;
    const numberPrefixCls = `${antCls}-scroll-number`;
    const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
      let {
        darkColor
      } = _ref;
      return {
        [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
          background: darkColor,
          [`&:not(${componentCls}-count)`]: {
            color: darkColor
          }
        }
      };
    });
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        width: "fit-content",
        lineHeight: 1,
        [`${componentCls}-count`]: {
          zIndex: token2.indicatorZIndex,
          minWidth: indicatorHeight,
          height: indicatorHeight,
          color: token2.badgeTextColor,
          fontWeight: textFontWeight,
          fontSize: textFontSize,
          lineHeight: `${indicatorHeight}px`,
          whiteSpace: "nowrap",
          textAlign: "center",
          background: token2.badgeColor,
          borderRadius: indicatorHeight / 2,
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`,
          transition: `background ${token2.motionDurationMid}`,
          a: {
            color: token2.badgeTextColor
          },
          "a:hover": {
            color: token2.badgeTextColor
          },
          "a:hover &": {
            background: token2.badgeColorHover
          }
        },
        [`${componentCls}-count-sm`]: {
          minWidth: indicatorHeightSM,
          height: indicatorHeightSM,
          fontSize: textFontSizeSM,
          lineHeight: `${indicatorHeightSM}px`,
          borderRadius: indicatorHeightSM / 2
        },
        [`${componentCls}-multiple-words`]: {
          padding: `0 ${token2.paddingXS}px`,
          bdi: {
            unicodeBidi: "plaintext"
          }
        },
        [`${componentCls}-dot`]: {
          zIndex: token2.indicatorZIndex,
          width: dotSize,
          minWidth: dotSize,
          height: dotSize,
          background: token2.badgeColor,
          borderRadius: "100%",
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`
        },
        [`${componentCls}-dot${numberPrefixCls}`]: {
          transition: `background ${motionDurationSlow}`
        },
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          transform: "translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&${iconCls}-spin`]: {
            animationName: antBadgeLoadingCircle,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          }
        },
        [`&${componentCls}-status`]: {
          lineHeight: "inherit",
          verticalAlign: "baseline",
          [`${componentCls}-status-dot`]: {
            position: "relative",
            top: -1,
            display: "inline-block",
            width: statusSize,
            height: statusSize,
            verticalAlign: "middle",
            borderRadius: "50%"
          },
          [`${componentCls}-status-success`]: {
            backgroundColor: token2.colorSuccess
          },
          [`${componentCls}-status-processing`]: {
            overflow: "visible",
            color: token2.colorPrimary,
            backgroundColor: token2.colorPrimary,
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: "100%",
              height: "100%",
              borderWidth: badgeShadowSize,
              borderStyle: "solid",
              borderColor: "inherit",
              borderRadius: "50%",
              animationName: antStatusProcessing,
              animationDuration: token2.badgeProcessingDuration,
              animationIterationCount: "infinite",
              animationTimingFunction: "ease-in-out",
              content: '""'
            }
          },
          [`${componentCls}-status-default`]: {
            backgroundColor: token2.colorTextPlaceholder
          },
          [`${componentCls}-status-error`]: {
            backgroundColor: token2.colorError
          },
          [`${componentCls}-status-warning`]: {
            backgroundColor: token2.colorWarning
          },
          [`${componentCls}-status-text`]: {
            marginInlineStart: marginXS,
            color: token2.colorText,
            fontSize: token2.fontSize
          }
        }
      }), colorPreset), {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`&${componentCls}-not-a-wrapper`]: {
          [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
            animationName: antNoWrapperZoomBadgeIn,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`${componentCls}-zoom-leave`]: {
            animationName: antNoWrapperZoomBadgeOut,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`&:not(${componentCls}-status)`]: {
            verticalAlign: "middle"
          },
          [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
            transform: "none"
          },
          [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
            position: "relative",
            top: "auto",
            display: "block",
            transformOrigin: "50% 50%"
          }
        },
        [`${numberPrefixCls}`]: {
          overflow: "hidden",
          [`${numberPrefixCls}-only`]: {
            position: "relative",
            display: "inline-block",
            height: indicatorHeight,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden",
            [`> p${numberPrefixCls}-only-unit`]: {
              height: indicatorHeight,
              margin: 0,
              WebkitTransformStyle: "preserve-3d",
              WebkitBackfaceVisibility: "hidden"
            }
          },
          [`${numberPrefixCls}-symbol`]: {
            verticalAlign: "top"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
            transform: "translate(-50%, -50%)"
          }
        }
      })
    };
  };
  const prepareToken$1 = (token2) => {
    const {
      fontSize,
      lineHeight,
      lineWidth,
      marginXS,
      colorBorderBg
    } = token2;
    const badgeFontHeight = Math.round(fontSize * lineHeight);
    const badgeShadowSize = lineWidth;
    const badgeTextColor = token2.colorBgContainer;
    const badgeColor = token2.colorError;
    const badgeColorHover = token2.colorErrorHover;
    const badgeToken = merge(token2, {
      badgeFontHeight,
      badgeShadowSize,
      badgeTextColor,
      badgeColor,
      badgeColorHover,
      badgeShadowColor: colorBorderBg,
      badgeProcessingDuration: "1.2s",
      badgeRibbonOffset: marginXS,
      // Follow token just by Design. Not related with token
      badgeRibbonCornerTransform: "scaleY(0.75)",
      badgeRibbonCornerFilter: `brightness(75%)`
    });
    return badgeToken;
  };
  const prepareComponentToken = (token2) => {
    const {
      fontSize,
      lineHeight,
      fontSizeSM,
      lineWidth
    } = token2;
    return {
      indicatorZIndex: "auto",
      indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
      indicatorHeightSM: fontSize,
      dotSize: fontSizeSM / 2,
      textFontSize: fontSizeSM,
      textFontSizeSM: fontSizeSM,
      textFontWeight: "normal",
      statusSize: fontSizeSM / 2
    };
  };
  const useStyle$8 = genComponentStyleHook("Badge", (token2) => {
    const badgeToken = prepareToken$1(token2);
    return [genSharedBadgeStyle(badgeToken)];
  }, prepareComponentToken);
  const genRibbonStyle = (token2) => {
    const {
      antCls,
      badgeFontHeight,
      marginXS,
      badgeRibbonOffset
    } = token2;
    const ribbonPrefixCls = `${antCls}-ribbon`;
    const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
    const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref) => {
      let {
        darkColor
      } = _ref;
      return {
        [`&${ribbonPrefixCls}-color-${colorKey}`]: {
          background: darkColor,
          color: darkColor
        }
      };
    });
    return {
      [`${ribbonWrapperPrefixCls}`]: {
        position: "relative"
      },
      [`${ribbonPrefixCls}`]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: marginXS,
        padding: `0 ${token2.paddingXS}px`,
        color: token2.colorPrimary,
        lineHeight: `${badgeFontHeight}px`,
        whiteSpace: "nowrap",
        backgroundColor: token2.colorPrimary,
        borderRadius: token2.borderRadiusSM,
        [`${ribbonPrefixCls}-text`]: {
          color: token2.colorTextLightSolid
        },
        [`${ribbonPrefixCls}-corner`]: {
          position: "absolute",
          top: "100%",
          width: badgeRibbonOffset,
          height: badgeRibbonOffset,
          color: "currentcolor",
          border: `${badgeRibbonOffset / 2}px solid`,
          transform: token2.badgeRibbonCornerTransform,
          transformOrigin: "top",
          filter: token2.badgeRibbonCornerFilter
        }
      }), statusRibbonPreset), {
        [`&${ribbonPrefixCls}-placement-end`]: {
          insetInlineEnd: -badgeRibbonOffset,
          borderEndEndRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineEnd: 0,
            borderInlineEndColor: "transparent",
            borderBlockEndColor: "transparent"
          }
        },
        [`&${ribbonPrefixCls}-placement-start`]: {
          insetInlineStart: -badgeRibbonOffset,
          borderEndStartRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineStart: 0,
            borderBlockEndColor: "transparent",
            borderInlineStartColor: "transparent"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl"
        }
      })
    };
  };
  const useStyle$7 = genComponentStyleHook(["Badge", "Ribbon"], (token2) => {
    const badgeToken = prepareToken$1(token2);
    return [genRibbonStyle(badgeToken)];
  }, prepareComponentToken);
  const Ribbon = (props) => {
    const {
      className,
      prefixCls: customizePrefixCls,
      style: style2,
      color,
      children,
      text,
      placement = "end",
      rootClassName
    } = props;
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
    const colorInPreset = isPresetColor(color, false);
    const ribbonCls = classname(prefixCls, `${prefixCls}-placement-${placement}`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-color-${color}`]: colorInPreset
    }, className);
    const [wrapSSR, hashId] = useStyle$7(prefixCls);
    const colorStyle = {};
    const cornerColorStyle = {};
    if (color && !colorInPreset) {
      colorStyle.background = color;
      cornerColorStyle.color = color;
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(`${prefixCls}-wrapper`, rootClassName, hashId)
    }, children, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(ribbonCls, hashId),
      style: Object.assign(Object.assign({}, colorStyle), style2)
    }, /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-text`
    }, text), /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-corner`,
      style: cornerColorStyle
    }))));
  };
  const Ribbon$1 = Ribbon;
  function UnitNumber(_ref) {
    let {
      prefixCls,
      value,
      current,
      offset = 0
    } = _ref;
    let style2;
    if (offset) {
      style2 = {
        position: "absolute",
        top: `${offset}00%`,
        left: 0
      };
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      style: style2,
      className: classname(`${prefixCls}-only-unit`, {
        current
      })
    }, value);
  }
  function getOffset$3(start, end, unit) {
    let index2 = start;
    let offset = 0;
    while ((index2 + 10) % 10 !== end) {
      index2 += unit;
      offset += unit;
    }
    return offset;
  }
  function SingleNumber(props) {
    const {
      prefixCls,
      count: originCount,
      value: originValue
    } = props;
    const value = Number(originValue);
    const count = Math.abs(originCount);
    const [prevValue, setPrevValue] = React__namespace.useState(value);
    const [prevCount, setPrevCount] = React__namespace.useState(count);
    const onTransitionEnd = () => {
      setPrevValue(value);
      setPrevCount(count);
    };
    React__namespace.useEffect(() => {
      const timeout = setTimeout(() => {
        onTransitionEnd();
      }, 1e3);
      return () => {
        clearTimeout(timeout);
      };
    }, [value]);
    let unitNodes;
    let offsetStyle;
    if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
      unitNodes = [/* @__PURE__ */ React__namespace.createElement(UnitNumber, Object.assign({}, props, {
        key: value,
        current: true
      }))];
      offsetStyle = {
        transition: "none"
      };
    } else {
      unitNodes = [];
      const end = value + 10;
      const unitNumberList = [];
      for (let index2 = value; index2 <= end; index2 += 1) {
        unitNumberList.push(index2);
      }
      const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
      unitNodes = unitNumberList.map((n2, index2) => {
        const singleUnit = n2 % 10;
        return /* @__PURE__ */ React__namespace.createElement(UnitNumber, Object.assign({}, props, {
          key: n2,
          value: singleUnit,
          offset: index2 - prevIndex,
          current: index2 === prevIndex
        }));
      });
      const unit = prevCount < count ? 1 : -1;
      offsetStyle = {
        transform: `translateY(${-getOffset$3(prevValue, value, unit)}00%)`
      };
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-only`,
      style: offsetStyle,
      onTransitionEnd
    }, unitNodes);
  }
  var __rest$g = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const ScrollNumber = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      count,
      className,
      motionClassName,
      style: style2,
      title,
      show: show2,
      component: Component2 = "sup",
      children
    } = props, restProps = __rest$g(props, ["prefixCls", "count", "className", "motionClassName", "style", "title", "show", "component", "children"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
    const newProps = Object.assign(Object.assign({}, restProps), {
      "data-show": show2,
      style: style2,
      className: classname(prefixCls, className, motionClassName),
      title
    });
    let numberNodes = count;
    if (count && Number(count) % 1 === 0) {
      const numberList = String(count).split("");
      numberNodes = /* @__PURE__ */ React__namespace.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ React__namespace.createElement(SingleNumber, {
        prefixCls,
        count: Number(count),
        value: num,
        // eslint-disable-next-line react/no-array-index-key
        key: numberList.length - i
      })));
    }
    if (style2 && style2.borderColor) {
      newProps.style = Object.assign(Object.assign({}, style2), {
        boxShadow: `0 0 0 1px ${style2.borderColor} inset`
      });
    }
    if (children) {
      return cloneElement(children, (oriProps) => ({
        className: classname(`${prefixCls}-custom-component`, oriProps === null || oriProps === void 0 ? void 0 : oriProps.className, motionClassName)
      }));
    }
    return /* @__PURE__ */ React__namespace.createElement(Component2, Object.assign({}, newProps, {
      ref
    }), numberNodes);
  });
  const ScrollNumber$1 = ScrollNumber;
  var __rest$f = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const InternalBadge = (props, ref) => {
    var _a, _b, _c, _d, _e;
    const {
      prefixCls: customizePrefixCls,
      scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
      children,
      status,
      text,
      color,
      count = null,
      overflowCount = 99,
      dot = false,
      size = "default",
      title,
      offset,
      style: style2,
      className,
      rootClassName,
      classNames,
      styles: styles2,
      showZero = false
    } = props, restProps = __rest$f(props, ["prefixCls", "scrollNumberPrefixCls", "children", "status", "text", "color", "count", "overflowCount", "dot", "size", "title", "offset", "style", "className", "rootClassName", "classNames", "styles", "showZero"]);
    const {
      getPrefixCls,
      direction,
      badge
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("badge", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$8(prefixCls);
    const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
    const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0;
    const ignoreCount = count === null || isZero && !showZero;
    const hasStatus = (status !== null && status !== void 0 || color !== null && color !== void 0) && ignoreCount;
    const showAsDot = dot && !isZero;
    const mergedCount = showAsDot ? "" : numberedDisplayCount;
    const isHidden = React.useMemo(() => {
      const isEmpty3 = mergedCount === null || mergedCount === void 0 || mergedCount === "";
      return (isEmpty3 || isZero && !showZero) && !showAsDot;
    }, [mergedCount, isZero, showZero, showAsDot]);
    const countRef = React.useRef(count);
    if (!isHidden) {
      countRef.current = count;
    }
    const livingCount = countRef.current;
    const displayCountRef = React.useRef(mergedCount);
    if (!isHidden) {
      displayCountRef.current = mergedCount;
    }
    const displayCount = displayCountRef.current;
    const isDotRef = React.useRef(showAsDot);
    if (!isHidden) {
      isDotRef.current = showAsDot;
    }
    const mergedStyle = React.useMemo(() => {
      if (!offset) {
        return Object.assign(Object.assign({}, badge === null || badge === void 0 ? void 0 : badge.style), style2);
      }
      const offsetStyle = {
        marginTop: offset[1]
      };
      if (direction === "rtl") {
        offsetStyle.left = parseInt(offset[0], 10);
      } else {
        offsetStyle.right = -parseInt(offset[0], 10);
      }
      return Object.assign(Object.assign(Object.assign({}, offsetStyle), badge === null || badge === void 0 ? void 0 : badge.style), style2);
    }, [direction, offset, style2, badge === null || badge === void 0 ? void 0 : badge.style]);
    const titleNode = title !== null && title !== void 0 ? title : typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0;
    const statusTextNode = isHidden || !text ? null : /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-status-text`
    }, text);
    const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
      style: Object.assign(Object.assign({}, mergedStyle), oriProps.style)
    }));
    const isInternalColor = isPresetColor(color, false);
    const statusCls = classname(classNames === null || classNames === void 0 ? void 0 : classNames.indicator, (_a = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a === void 0 ? void 0 : _a.indicator, {
      [`${prefixCls}-status-dot`]: hasStatus,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color}`]: isInternalColor
    });
    const statusStyle = {};
    if (color && !isInternalColor) {
      statusStyle.color = color;
      statusStyle.background = color;
    }
    const badgeClassName = classname(prefixCls, {
      [`${prefixCls}-status`]: hasStatus,
      [`${prefixCls}-not-a-wrapper`]: !children,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, badge === null || badge === void 0 ? void 0 : badge.className, (_b = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _b === void 0 ? void 0 : _b.root, classNames === null || classNames === void 0 ? void 0 : classNames.root, hashId);
    if (!children && hasStatus) {
      const statusTextColor = mergedStyle.color;
      return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", Object.assign({}, restProps, {
        className: badgeClassName,
        style: Object.assign(Object.assign(Object.assign({}, styles2 === null || styles2 === void 0 ? void 0 : styles2.root), (_c = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _c === void 0 ? void 0 : _c.root), mergedStyle)
      }), /* @__PURE__ */ React__namespace.createElement("span", {
        className: statusCls,
        style: Object.assign(Object.assign(Object.assign({}, styles2 === null || styles2 === void 0 ? void 0 : styles2.indicator), (_d = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _d === void 0 ? void 0 : _d.indicator), statusStyle)
      }), text && /* @__PURE__ */ React__namespace.createElement("span", {
        style: {
          color: statusTextColor
        },
        className: `${prefixCls}-status-text`
      }, text)));
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", Object.assign({
      ref
    }, restProps, {
      className: badgeClassName,
      style: Object.assign(Object.assign({}, (_e = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _e === void 0 ? void 0 : _e.root), styles2 === null || styles2 === void 0 ? void 0 : styles2.root)
    }), children, /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      visible: !isHidden,
      motionName: `${prefixCls}-zoom`,
      motionAppear: false,
      motionDeadline: 1e3
    }, (_ref) => {
      let {
        className: motionClassName,
        ref: scrollNumberRef
      } = _ref;
      var _a2, _b2;
      const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
      const isDot = isDotRef.current;
      const scrollNumberCls = classname(classNames === null || classNames === void 0 ? void 0 : classNames.indicator, (_a2 = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a2 === void 0 ? void 0 : _a2.indicator, {
        [`${prefixCls}-dot`]: isDot,
        [`${prefixCls}-count`]: !isDot,
        [`${prefixCls}-count-sm`]: size === "small",
        [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
        [`${prefixCls}-status-${status}`]: !!status,
        [`${prefixCls}-color-${color}`]: isInternalColor
      });
      let scrollNumberStyle = Object.assign(Object.assign(Object.assign({}, styles2 === null || styles2 === void 0 ? void 0 : styles2.indicator), (_b2 = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _b2 === void 0 ? void 0 : _b2.indicator), mergedStyle);
      if (color && !isInternalColor) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color;
      }
      return /* @__PURE__ */ React__namespace.createElement(ScrollNumber$1, {
        prefixCls: scrollNumberPrefixCls,
        show: !isHidden,
        motionClassName,
        className: scrollNumberCls,
        count: displayCount,
        title: titleNode,
        style: scrollNumberStyle,
        key: "scrollNumber",
        ref: scrollNumberRef
      }, displayNode);
    }), statusTextNode));
  };
  const Badge = /* @__PURE__ */ React__namespace.forwardRef(InternalBadge);
  Badge.Ribbon = Ribbon$1;
  const Badge$1 = Badge;
  var ESC$1 = KeyCode.ESC, TAB = KeyCode.TAB;
  function useAccessibility$1(_ref) {
    var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef;
    var focusMenuRef = React__namespace.useRef(false);
    var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
      if (visible) {
        var _triggerRef$current, _triggerRef$current$f;
        (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 ? void 0 : _triggerRef$current$f.call(_triggerRef$current);
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(false);
      }
    };
    var focusMenu = function focusMenu2() {
      var _overlayRef$current;
      if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
        overlayRef.current.focus();
        focusMenuRef.current = true;
        return true;
      }
      return false;
    };
    var handleKeyDown = function handleKeyDown2(event) {
      switch (event.keyCode) {
        case ESC$1:
          handleCloseMenuAndReturnFocus();
          break;
        case TAB: {
          var focusResult = false;
          if (!focusMenuRef.current) {
            focusResult = focusMenu();
          }
          if (focusResult) {
            event.preventDefault();
          } else {
            handleCloseMenuAndReturnFocus();
          }
          break;
        }
      }
    };
    React__namespace.useEffect(function() {
      if (visible) {
        window.addEventListener("keydown", handleKeyDown);
        if (autoFocus) {
          wrapperRaf(focusMenu, 3);
        }
        return function() {
          window.removeEventListener("keydown", handleKeyDown);
          focusMenuRef.current = false;
        };
      }
      return function() {
        focusMenuRef.current = false;
      };
    }, [visible]);
  }
  var Overlay = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var overlay = props.overlay, arrow2 = props.arrow, prefixCls = props.prefixCls;
    var overlayNode = React.useMemo(function() {
      var overlayElement;
      if (typeof overlay === "function") {
        overlayElement = overlay();
      } else {
        overlayElement = overlay;
      }
      return overlayElement;
    }, [overlay]);
    var composedRef = composeRef(ref, overlayNode === null || overlayNode === void 0 ? void 0 : overlayNode.ref);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, arrow2 && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-arrow")
    }), /* @__PURE__ */ React.cloneElement(overlayNode, {
      ref: supportRef(overlayNode) ? composedRef : void 0
    }));
  });
  var autoAdjustOverflow$1 = {
    adjustX: 1,
    adjustY: 1
  };
  var targetOffset = [0, 0];
  var placements$1 = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    }
  };
  var _excluded$n = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
  function Dropdown(props, ref) {
    var _children$props;
    var _props$arrow = props.arrow, arrow2 = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$1 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties$8(props, _excluded$n);
    var _React$useState = React.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
    var mergedVisible = "visible" in props ? visible : triggerVisible;
    var triggerRef = React.useRef(null);
    var overlayRef = React.useRef(null);
    var childRef = React.useRef(null);
    React.useImperativeHandle(ref, function() {
      return triggerRef.current;
    });
    var handleVisibleChange = function handleVisibleChange2(newVisible) {
      setTriggerVisible(newVisible);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(newVisible);
    };
    useAccessibility$1({
      visible: mergedVisible,
      triggerRef: childRef,
      onVisibleChange: handleVisibleChange,
      autoFocus,
      overlayRef
    });
    var onClick = function onClick2(e2) {
      var onOverlayClick = props.onOverlayClick;
      setTriggerVisible(false);
      if (onOverlayClick) {
        onOverlayClick(e2);
      }
    };
    var getMenuElement = function getMenuElement2() {
      return /* @__PURE__ */ React.createElement(Overlay, {
        ref: overlayRef,
        overlay,
        prefixCls,
        arrow: arrow2
      });
    };
    var getMenuElementOrLambda = function getMenuElementOrLambda2() {
      if (typeof overlay === "function") {
        return getMenuElement;
      }
      return getMenuElement();
    };
    var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
      var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
      if ("minOverlayWidthMatchTrigger" in props) {
        return minOverlayWidthMatchTrigger;
      }
      return !alignPoint;
    };
    var getOpenClassName = function getOpenClassName2() {
      var openClassName = props.openClassName;
      if (openClassName !== void 0) {
        return openClassName;
      }
      return "".concat(prefixCls, "-open");
    };
    var childrenNode = /* @__PURE__ */ React.cloneElement(children, {
      className: classname((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
      ref: supportRef(children) ? composeRef(childRef, children.ref) : void 0
    });
    var triggerHideAction = hideAction;
    if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
      triggerHideAction = ["click"];
    }
    return /* @__PURE__ */ React.createElement(Trigger, _extends$7({
      builtinPlacements: placements2
    }, otherProps, {
      prefixCls,
      ref: triggerRef,
      popupClassName: classname(overlayClassName, _defineProperty$1({}, "".concat(prefixCls, "-show-arrow"), arrow2)),
      popupStyle: overlayStyle,
      action: trigger,
      showAction,
      hideAction: triggerHideAction,
      popupPlacement: placement,
      popupAlign: align,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupVisible: mergedVisible,
      stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
      popup: getMenuElementOrLambda(),
      onPopupVisibleChange: handleVisibleChange,
      onPopupClick: onClick,
      getPopupContainer
    }), childrenNode);
  }
  const Dropdown$1 = /* @__PURE__ */ React.forwardRef(Dropdown);
  var IdContext = /* @__PURE__ */ React__namespace.createContext(null);
  function getMenuId(uuid2, eventKey) {
    if (uuid2 === void 0) {
      return null;
    }
    return "".concat(uuid2, "-").concat(eventKey);
  }
  function useMenuId(eventKey) {
    var id = React__namespace.useContext(IdContext);
    return getMenuId(id, eventKey);
  }
  var _excluded$m = ["children", "locked"];
  var MenuContext = /* @__PURE__ */ React__namespace.createContext(null);
  function mergeProps(origin, target) {
    var clone = _objectSpread2({}, origin);
    Object.keys(target).forEach(function(key) {
      var value = target[key];
      if (value !== void 0) {
        clone[key] = value;
      }
    });
    return clone;
  }
  function InheritableContextProvider(_ref) {
    var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties$8(_ref, _excluded$m);
    var context2 = React__namespace.useContext(MenuContext);
    var inheritableContext = useMemo(function() {
      return mergeProps(context2, restProps);
    }, [context2, restProps], function(prev2, next2) {
      return !locked && (prev2[0] !== next2[0] || !isEqual(prev2[1], next2[1], true));
    });
    return /* @__PURE__ */ React__namespace.createElement(MenuContext.Provider, {
      value: inheritableContext
    }, children);
  }
  var EmptyList = [];
  var PathRegisterContext = /* @__PURE__ */ React__namespace.createContext(null);
  function useMeasure() {
    return React__namespace.useContext(PathRegisterContext);
  }
  var PathTrackerContext = /* @__PURE__ */ React__namespace.createContext(EmptyList);
  function useFullPath(eventKey) {
    var parentKeyPath = React__namespace.useContext(PathTrackerContext);
    return React__namespace.useMemo(function() {
      return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
    }, [parentKeyPath, eventKey]);
  }
  var PathUserContext = /* @__PURE__ */ React__namespace.createContext(null);
  var PrivateContext = /* @__PURE__ */ React__namespace.createContext({});
  function focusable(node2) {
    var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isVisible(node2)) {
      var nodeName = node2.nodeName.toLowerCase();
      var isFocusableElement = (
        // Focusable element
        ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
        node2.isContentEditable || // Anchor with href element
        nodeName === "a" && !!node2.getAttribute("href")
      );
      var tabIndexAttr = node2.getAttribute("tabindex");
      var tabIndexNum = Number(tabIndexAttr);
      var tabIndex = null;
      if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
        tabIndex = tabIndexNum;
      } else if (isFocusableElement && tabIndex === null) {
        tabIndex = 0;
      }
      if (isFocusableElement && node2.disabled) {
        tabIndex = null;
      }
      return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
    }
    return false;
  }
  function getFocusNodeList(node2) {
    var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
      return focusable(child, includePositive);
    });
    if (focusable(node2, includePositive)) {
      res.unshift(node2);
    }
    return res;
  }
  var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
  var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
  function getOffset$2(mode, isRootLevel, isRtl, which) {
    var _inline, _horizontal, _vertical, _offsets;
    var prev2 = "prev";
    var next2 = "next";
    var children = "children";
    var parent = "parent";
    if (mode === "inline" && which === ENTER) {
      return {
        inlineTrigger: true
      };
    }
    var inline2 = (_inline = {}, _defineProperty$1(_inline, UP, prev2), _defineProperty$1(_inline, DOWN, next2), _inline);
    var horizontal = (_horizontal = {}, _defineProperty$1(_horizontal, LEFT, isRtl ? next2 : prev2), _defineProperty$1(_horizontal, RIGHT, isRtl ? prev2 : next2), _defineProperty$1(_horizontal, DOWN, children), _defineProperty$1(_horizontal, ENTER, children), _horizontal);
    var vertical = (_vertical = {}, _defineProperty$1(_vertical, UP, prev2), _defineProperty$1(_vertical, DOWN, next2), _defineProperty$1(_vertical, ENTER, children), _defineProperty$1(_vertical, ESC, parent), _defineProperty$1(_vertical, LEFT, isRtl ? children : parent), _defineProperty$1(_vertical, RIGHT, isRtl ? parent : children), _vertical);
    var offsets = {
      inline: inline2,
      horizontal,
      vertical,
      inlineSub: inline2,
      horizontalSub: vertical,
      verticalSub: vertical
    };
    var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
    switch (type4) {
      case prev2:
        return {
          offset: -1,
          sibling: true
        };
      case next2:
        return {
          offset: 1,
          sibling: true
        };
      case parent:
        return {
          offset: -1,
          sibling: false
        };
      case children:
        return {
          offset: 1,
          sibling: false
        };
      default:
        return null;
    }
  }
  function findContainerUL(element) {
    var current = element;
    while (current) {
      if (current.getAttribute("data-menu-list")) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusElement(activeElement, elements) {
    var current = activeElement || document.activeElement;
    while (current) {
      if (elements.has(current)) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusableElements(container, elements) {
    var list = getFocusNodeList(container, true);
    return list.filter(function(ele) {
      return elements.has(ele);
    });
  }
  function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
    var offset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    if (!parentQueryContainer) {
      return null;
    }
    var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
    var count = sameLevelFocusableMenuElementList.length;
    var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
      return focusMenuElement === ele;
    });
    if (offset < 0) {
      if (focusIndex === -1) {
        focusIndex = count - 1;
      } else {
        focusIndex -= 1;
      }
    } else if (offset > 0) {
      focusIndex += 1;
    }
    focusIndex = (focusIndex + count) % count;
    return sameLevelFocusableMenuElementList[focusIndex];
  }
  function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
    var rafRef = React__namespace.useRef();
    var activeRef = React__namespace.useRef();
    activeRef.current = activeKey;
    var cleanRaf = function cleanRaf2() {
      wrapperRaf.cancel(rafRef.current);
    };
    React__namespace.useEffect(function() {
      return function() {
        cleanRaf();
      };
    }, []);
    return function(e2) {
      var which = e2.which;
      if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
        var elements;
        var key2element;
        var element2key;
        var refreshElements = function refreshElements2() {
          elements = /* @__PURE__ */ new Set();
          key2element = /* @__PURE__ */ new Map();
          element2key = /* @__PURE__ */ new Map();
          var keys2 = getKeys();
          keys2.forEach(function(key) {
            var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
            if (element) {
              elements.add(element);
              element2key.set(element, key);
              key2element.set(key, element);
            }
          });
          return elements;
        };
        refreshElements();
        var activeElement = key2element.get(activeKey);
        var focusMenuElement = getFocusElement(activeElement, elements);
        var focusMenuKey = element2key.get(focusMenuElement);
        var offsetObj = getOffset$2(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
        if (!offsetObj && which !== HOME && which !== END) {
          return;
        }
        if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
          e2.preventDefault();
        }
        var tryFocus = function tryFocus2(menuElement) {
          if (menuElement) {
            var focusTargetElement = menuElement;
            var link = menuElement.querySelector("a");
            if (link !== null && link !== void 0 && link.getAttribute("href")) {
              focusTargetElement = link;
            }
            var targetKey = element2key.get(menuElement);
            triggerActiveKey(targetKey);
            cleanRaf();
            rafRef.current = wrapperRaf(function() {
              if (activeRef.current === targetKey) {
                focusTargetElement.focus();
              }
            });
          }
        };
        if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
          var parentQueryContainer;
          if (!focusMenuElement || mode === "inline") {
            parentQueryContainer = containerRef.current;
          } else {
            parentQueryContainer = findContainerUL(focusMenuElement);
          }
          var targetElement;
          var focusableElements = getFocusableElements(parentQueryContainer, elements);
          if (which === HOME) {
            targetElement = focusableElements[0];
          } else if (which === END) {
            targetElement = focusableElements[focusableElements.length - 1];
          } else {
            targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
          }
          tryFocus(targetElement);
        } else if (offsetObj.inlineTrigger) {
          triggerAccessibilityOpen(focusMenuKey);
        } else if (offsetObj.offset > 0) {
          triggerAccessibilityOpen(focusMenuKey, true);
          cleanRaf();
          rafRef.current = wrapperRaf(function() {
            refreshElements();
            var controlId = focusMenuElement.getAttribute("aria-controls");
            var subQueryContainer = document.getElementById(controlId);
            var targetElement2 = getNextFocusElement(subQueryContainer, elements);
            tryFocus(targetElement2);
          }, 5);
        } else if (offsetObj.offset < 0) {
          var keyPath = getKeyPath(focusMenuKey, true);
          var parentKey = keyPath[keyPath.length - 2];
          var parentMenuElement = key2element.get(parentKey);
          triggerAccessibilityOpen(parentKey, false);
          tryFocus(parentMenuElement);
        }
      }
      originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
    };
  }
  function nextSlice(callback) {
    Promise.resolve().then(callback);
  }
  var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
  var getPathStr = function getPathStr2(keyPath) {
    return keyPath.join(PATH_SPLIT);
  };
  var getPathKeys = function getPathKeys2(keyPathStr) {
    return keyPathStr.split(PATH_SPLIT);
  };
  var OVERFLOW_KEY = "rc-menu-more";
  function useKeyRecords() {
    var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
    var key2pathRef = React.useRef(/* @__PURE__ */ new Map());
    var path2keyRef = React.useRef(/* @__PURE__ */ new Map());
    var _React$useState3 = React__namespace.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
    var updateRef = React.useRef(0);
    var destroyRef = React.useRef(false);
    var forceUpdate = function forceUpdate2() {
      if (!destroyRef.current) {
        internalForceUpdate({});
      }
    };
    var registerPath = React.useCallback(function(key, keyPath) {
      var connectedPath = getPathStr(keyPath);
      path2keyRef.current.set(connectedPath, key);
      key2pathRef.current.set(key, connectedPath);
      updateRef.current += 1;
      var id = updateRef.current;
      nextSlice(function() {
        if (id === updateRef.current) {
          forceUpdate();
        }
      });
    }, []);
    var unregisterPath = React.useCallback(function(key, keyPath) {
      var connectedPath = getPathStr(keyPath);
      path2keyRef.current.delete(connectedPath);
      key2pathRef.current.delete(key);
    }, []);
    var refreshOverflowKeys = React.useCallback(function(keys2) {
      setOverflowKeys(keys2);
    }, []);
    var getKeyPath = React.useCallback(function(eventKey, includeOverflow) {
      var fullPath = key2pathRef.current.get(eventKey) || "";
      var keys2 = getPathKeys(fullPath);
      if (includeOverflow && overflowKeys.includes(keys2[0])) {
        keys2.unshift(OVERFLOW_KEY);
      }
      return keys2;
    }, [overflowKeys]);
    var isSubPathKey = React.useCallback(function(pathKeys, eventKey) {
      return pathKeys.some(function(pathKey) {
        var pathKeyList = getKeyPath(pathKey, true);
        return pathKeyList.includes(eventKey);
      });
    }, [getKeyPath]);
    var getKeys = function getKeys2() {
      var keys2 = _toConsumableArray(key2pathRef.current.keys());
      if (overflowKeys.length) {
        keys2.push(OVERFLOW_KEY);
      }
      return keys2;
    };
    var getSubPathKeys = React.useCallback(function(key) {
      var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
      var pathKeys = /* @__PURE__ */ new Set();
      _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
        if (pathKey.startsWith(connectedPath)) {
          pathKeys.add(path2keyRef.current.get(pathKey));
        }
      });
      return pathKeys;
    }, []);
    React__namespace.useEffect(function() {
      return function() {
        destroyRef.current = true;
      };
    }, []);
    return {
      // Register
      registerPath,
      unregisterPath,
      refreshOverflowKeys,
      // Util
      isSubPathKey,
      getKeyPath,
      getKeys,
      getSubPathKeys
    };
  }
  function useMemoCallback(func) {
    var funRef = React__namespace.useRef(func);
    funRef.current = func;
    var callback = React__namespace.useCallback(function() {
      var _funRef$current;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
    }, []);
    return func ? callback : void 0;
  }
  var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
  var internalId = 0;
  function useUUID(id) {
    var _useMergedState = useMergedState(id, {
      value: id
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
    React__namespace.useEffect(function() {
      internalId += 1;
      var newId = "".concat(uniquePrefix, "-").concat(internalId);
      setUUID("rc-menu-uuid-".concat(newId));
    }, []);
    return uuid2;
  }
  function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
    var _React$useContext = React__namespace.useContext(MenuContext), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
    var ret = {
      active: activeKey === eventKey
    };
    if (!disabled) {
      ret.onMouseEnter = function(domEvent) {
        onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
          key: eventKey,
          domEvent
        });
        onActive(eventKey);
      };
      ret.onMouseLeave = function(domEvent) {
        onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
          key: eventKey,
          domEvent
        });
        onInactive(eventKey);
      };
    }
    return ret;
  }
  function useDirectionStyle(level) {
    var _React$useContext = React__namespace.useContext(MenuContext), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
    if (mode !== "inline") {
      return null;
    }
    var len = level;
    return rtl ? {
      paddingRight: len * inlineIndent
    } : {
      paddingLeft: len * inlineIndent
    };
  }
  function Icon$1(_ref) {
    var icon2 = _ref.icon, props = _ref.props, children = _ref.children;
    var iconNode;
    if (icon2 === null || icon2 === false) {
      return null;
    }
    if (typeof icon2 === "function") {
      iconNode = /* @__PURE__ */ React__namespace.createElement(icon2, _objectSpread2({}, props));
    } else if (typeof icon2 !== "boolean") {
      iconNode = icon2;
    }
    return iconNode || children || null;
  }
  var _excluded$l = ["item"];
  function warnItemProp(_ref) {
    var item = _ref.item, restInfo = _objectWithoutProperties$8(_ref, _excluded$l);
    Object.defineProperty(restInfo, "item", {
      get: function get2() {
        warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
        return item;
      }
    });
    return restInfo;
  }
  var _excluded$k = ["title", "attribute", "elementRef"], _excluded2$4 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
  var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
    _inherits(LegacyMenuItem2, _React$Component);
    var _super = _createSuper(LegacyMenuItem2);
    function LegacyMenuItem2() {
      _classCallCheck(this, LegacyMenuItem2);
      return _super.apply(this, arguments);
    }
    _createClass(LegacyMenuItem2, [{
      key: "render",
      value: function render2() {
        var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$8(_this$props, _excluded$k);
        var passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
        warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
        return /* @__PURE__ */ React__namespace.createElement(ForwardOverflow.Item, _extends$7({}, attribute, {
          title: typeof title === "string" ? title : void 0
        }, passedProps, {
          ref: elementRef
        }));
      }
    }]);
    return LegacyMenuItem2;
  }(React__namespace.Component);
  var InternalMenuItem = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _classNames;
    var style2 = props.style, className = props.className, eventKey = props.eventKey;
    props.warnKey;
    var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties$8(props, _excluded2$4);
    var domDataId = useMenuId(eventKey);
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
    var _React$useContext2 = React__namespace.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
    var itemCls = "".concat(prefixCls, "-item");
    var legacyMenuItemRef = React__namespace.useRef();
    var elementRef = React__namespace.useRef();
    var mergedDisabled = contextDisabled || disabled;
    var mergedEleRef = useComposeRef(ref, elementRef);
    var connectedKeys = useFullPath(eventKey);
    var getEventInfo = function getEventInfo2(e2) {
      return {
        key: eventKey,
        // Note: For legacy code is reversed which not like other antd component
        keyPath: _toConsumableArray(connectedKeys).reverse(),
        item: legacyMenuItemRef.current,
        domEvent: e2
      };
    };
    var mergedItemIcon = itemIcon || contextItemIcon;
    var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$8(_useActive, _excluded3);
    var selected = selectedKeys.includes(eventKey);
    var directionStyle = useDirectionStyle(connectedKeys.length);
    var onInternalClick = function onInternalClick2(e2) {
      if (mergedDisabled) {
        return;
      }
      var info2 = getEventInfo(e2);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
      onItemClick(info2);
    };
    var onInternalKeyDown = function onInternalKeyDown2(e2) {
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
      if (e2.which === KeyCode.ENTER) {
        var info2 = getEventInfo(e2);
        onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
        onItemClick(info2);
      }
    };
    var onInternalFocus = function onInternalFocus2(e2) {
      onActive(eventKey);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
    };
    var optionRoleProps = {};
    if (props.role === "option") {
      optionRoleProps["aria-selected"] = selected;
    }
    var renderNode = /* @__PURE__ */ React__namespace.createElement(LegacyMenuItem, _extends$7({
      ref: legacyMenuItemRef,
      elementRef: mergedEleRef,
      role: role === null ? "none" : role || "menuitem",
      tabIndex: disabled ? null : -1,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId
    }, restProps, activeProps, optionRoleProps, {
      component: "li",
      "aria-disabled": disabled,
      style: _objectSpread2(_objectSpread2({}, directionStyle), style2),
      className: classname(itemCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$1(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$1(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
      onClick: onInternalClick,
      onKeyDown: onInternalKeyDown,
      onFocus: onInternalFocus
    }), children, /* @__PURE__ */ React__namespace.createElement(Icon$1, {
      props: _objectSpread2(_objectSpread2({}, props), {}, {
        isSelected: selected
      }),
      icon: mergedItemIcon
    }));
    if (_internalRenderMenuItem) {
      renderNode = _internalRenderMenuItem(renderNode, props, {
        selected
      });
    }
    return renderNode;
  });
  function MenuItem(props, ref) {
    var eventKey = props.eventKey;
    var measure = useMeasure();
    var connectedKeyPath = useFullPath(eventKey);
    React__namespace.useEffect(function() {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return function() {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    if (measure) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(InternalMenuItem, _extends$7({}, props, {
      ref
    }));
  }
  const MenuItem$1 = /* @__PURE__ */ React__namespace.forwardRef(MenuItem);
  var _excluded$j = ["className", "children"];
  var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
    var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties$8(_ref, _excluded$j);
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
    return /* @__PURE__ */ React__namespace.createElement("ul", _extends$7({
      className: classname(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
      role: "menu"
    }, restProps, {
      "data-menu-list": true,
      ref
    }), children);
  };
  var SubMenuList = /* @__PURE__ */ React__namespace.forwardRef(InternalSubMenuList);
  SubMenuList.displayName = "SubMenuList";
  function parseChildren(children, keyPath) {
    return toArray$3(children).map(function(child, index2) {
      if (/* @__PURE__ */ React__namespace.isValidElement(child)) {
        var _eventKey, _child$props;
        var key = child.key;
        var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
        var emptyKey = eventKey === null || eventKey === void 0;
        if (emptyKey) {
          eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
        }
        var cloneProps = {
          key: eventKey,
          eventKey
        };
        return /* @__PURE__ */ React__namespace.cloneElement(child, cloneProps);
      }
      return child;
    });
  }
  var autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  var placements = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow
    }
  };
  var placementsRtl = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow
    },
    rightTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow
    },
    rightBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow
    },
    leftTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow
    },
    leftBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow
    }
  };
  function getMotion(mode, motion2, defaultMotions) {
    if (motion2) {
      return motion2;
    }
    if (defaultMotions) {
      return defaultMotions[mode] || defaultMotions.other;
    }
    return void 0;
  }
  var popupPlacementMap = {
    horizontal: "bottomLeft",
    vertical: "rightTop",
    "vertical-left": "rightTop",
    "vertical-right": "leftTop"
  };
  function PopupTrigger(_ref) {
    var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
    var _React$useContext = React__namespace.useContext(MenuContext), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
    var placement = rtl ? _objectSpread2(_objectSpread2({}, placementsRtl), builtinPlacements) : _objectSpread2(_objectSpread2({}, placements), builtinPlacements);
    var popupPlacement = popupPlacementMap[mode];
    var targetMotion = getMotion(mode, motion2, defaultMotions);
    var targetMotionRef = React__namespace.useRef(targetMotion);
    if (mode !== "inline") {
      targetMotionRef.current = targetMotion;
    }
    var mergedMotion = _objectSpread2(_objectSpread2({}, targetMotionRef.current), {}, {
      leavedClassName: "".concat(prefixCls, "-hidden"),
      removeOnLeave: false,
      motionAppear: true
    });
    var visibleRef = React__namespace.useRef();
    React__namespace.useEffect(function() {
      visibleRef.current = wrapperRaf(function() {
        setInnerVisible(visible);
      });
      return function() {
        wrapperRaf.cancel(visibleRef.current);
      };
    }, [visible]);
    return /* @__PURE__ */ React__namespace.createElement(Trigger, {
      prefixCls,
      popupClassName: classname("".concat(prefixCls, "-popup"), _defineProperty$1({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
      stretch: mode === "horizontal" ? "minWidth" : null,
      getPopupContainer,
      builtinPlacements: placement,
      popupPlacement,
      popupVisible: innerVisible,
      popup,
      popupStyle,
      popupAlign: popupOffset && {
        offset: popupOffset
      },
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: onVisibleChange,
      forceRender: forceSubMenuRender,
      popupMotion: mergedMotion,
      fresh: true
    }, children);
  }
  function InlineSubMenuList(_ref) {
    var id = _ref.id, open2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
    var fixedMode = "inline";
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
    var sameModeRef = React__namespace.useRef(false);
    sameModeRef.current = mode === fixedMode;
    var _React$useState = React__namespace.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy2 = _React$useState2[0], setDestroy = _React$useState2[1];
    var mergedOpen = sameModeRef.current ? open2 : false;
    React__namespace.useEffect(function() {
      if (sameModeRef.current) {
        setDestroy(false);
      }
    }, [mode]);
    var mergedMotion = _objectSpread2({}, getMotion(fixedMode, motion2, defaultMotions));
    if (keyPath.length > 1) {
      mergedMotion.motionAppear = false;
    }
    var originOnVisibleChanged = mergedMotion.onVisibleChanged;
    mergedMotion.onVisibleChanged = function(newVisible) {
      if (!sameModeRef.current && !newVisible) {
        setDestroy(true);
      }
      return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
    };
    if (destroy2) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(InheritableContextProvider, {
      mode: fixedMode,
      locked: !sameModeRef.current
    }, /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({
      visible: mergedOpen
    }, mergedMotion, {
      forceRender: forceSubMenuRender,
      removeOnLeave: false,
      leavedClassName: "".concat(prefixCls, "-hidden")
    }), function(_ref2) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      return /* @__PURE__ */ React__namespace.createElement(SubMenuList, {
        id,
        className: motionClassName,
        style: motionStyle
      }, children);
    }));
  }
  var _excluded$i = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$3 = ["active"];
  var InternalSubMenu = function InternalSubMenu2(props) {
    var _classNames;
    var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
    props.warnKey;
    var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$8(props, _excluded$i);
    var domDataId = useMenuId(eventKey);
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
    var _React$useContext2 = React__namespace.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
    var _React$useContext3 = React__namespace.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
    var connectedPath = useFullPath();
    var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
    var mergedDisabled = contextDisabled || disabled;
    var elementRef = React__namespace.useRef();
    var popupRef = React__namespace.useRef();
    var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
    var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
    var originOpen = openKeys.includes(eventKey);
    var open2 = !overflowDisabled && originOpen;
    var childrenSelected = isSubPathKey(selectedKeys, eventKey);
    var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$8(_useActive, _excluded2$3);
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
    var triggerChildrenActive = function triggerChildrenActive2(newActive) {
      if (!mergedDisabled) {
        setChildrenActive(newActive);
      }
    };
    var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
      triggerChildrenActive(true);
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
    };
    var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
      triggerChildrenActive(false);
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
    };
    var mergedActive = React__namespace.useMemo(function() {
      if (active) {
        return active;
      }
      if (mode !== "inline") {
        return childrenActive || isSubPathKey([activeKey], eventKey);
      }
      return false;
    }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
    var directionStyle = useDirectionStyle(connectedPath.length);
    var onInternalTitleClick = function onInternalTitleClick2(e2) {
      if (mergedDisabled) {
        return;
      }
      onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
        key: eventKey,
        domEvent: e2
      });
      if (mode === "inline") {
        onOpenChange(eventKey, !originOpen);
      }
    };
    var onMergedItemClick = useMemoCallback(function(info2) {
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
      onItemClick(info2);
    });
    var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
      if (mode !== "inline") {
        onOpenChange(eventKey, newVisible);
      }
    };
    var onInternalFocus = function onInternalFocus2() {
      onActive(eventKey);
    };
    var popupId = domDataId && "".concat(domDataId, "-popup");
    var titleNode = /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
      role: "menuitem",
      style: directionStyle,
      className: "".concat(subMenuPrefixCls, "-title"),
      tabIndex: mergedDisabled ? null : -1,
      ref: elementRef,
      title: typeof title === "string" ? title : null,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
      "aria-expanded": open2,
      "aria-haspopup": true,
      "aria-controls": popupId,
      "aria-disabled": mergedDisabled,
      onClick: onInternalTitleClick,
      onFocus: onInternalFocus
    }, activeProps), title, /* @__PURE__ */ React__namespace.createElement(Icon$1, {
      icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
      props: _objectSpread2(_objectSpread2({}, props), {}, {
        isOpen: open2,
        // [Legacy] Not sure why need this mark
        isSubMenu: true
      })
    }, /* @__PURE__ */ React__namespace.createElement("i", {
      className: "".concat(subMenuPrefixCls, "-arrow")
    })));
    var triggerModeRef = React__namespace.useRef(mode);
    if (mode !== "inline" && connectedPath.length > 1) {
      triggerModeRef.current = "vertical";
    } else {
      triggerModeRef.current = mode;
    }
    if (!overflowDisabled) {
      var triggerMode = triggerModeRef.current;
      titleNode = /* @__PURE__ */ React__namespace.createElement(PopupTrigger, {
        mode: triggerMode,
        prefixCls: subMenuPrefixCls,
        visible: !internalPopupClose && open2 && mode !== "inline",
        popupClassName,
        popupOffset,
        popupStyle,
        popup: /* @__PURE__ */ React__namespace.createElement(
          InheritableContextProvider,
          {
            mode: triggerMode === "horizontal" ? "vertical" : triggerMode
          },
          /* @__PURE__ */ React__namespace.createElement(SubMenuList, {
            id: popupId,
            ref: popupRef
          }, children)
        ),
        disabled: mergedDisabled,
        onVisibleChange: onPopupVisibleChange
      }, titleNode);
    }
    var listNode = /* @__PURE__ */ React__namespace.createElement(ForwardOverflow.Item, _extends$7({
      role: "none"
    }, restProps, {
      component: "li",
      style: style2,
      className: classname(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-open"), open2), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
      onMouseEnter: onInternalMouseEnter,
      onMouseLeave: onInternalMouseLeave
    }), titleNode, !overflowDisabled && /* @__PURE__ */ React__namespace.createElement(InlineSubMenuList, {
      id: popupId,
      open: open2,
      keyPath: connectedPath
    }, children));
    if (_internalRenderSubMenuItem) {
      listNode = _internalRenderSubMenuItem(listNode, props, {
        selected: childrenSelected,
        active: mergedActive,
        open: open2,
        disabled: mergedDisabled
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(InheritableContextProvider, {
      onItemClick: onMergedItemClick,
      mode: mode === "horizontal" ? "vertical" : mode,
      itemIcon: mergedItemIcon,
      expandIcon: mergedExpandIcon
    }, listNode);
  };
  function SubMenu(props) {
    var eventKey = props.eventKey, children = props.children;
    var connectedKeyPath = useFullPath(eventKey);
    var childList = parseChildren(children, connectedKeyPath);
    var measure = useMeasure();
    React__namespace.useEffect(function() {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return function() {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    var renderNode;
    if (measure) {
      renderNode = childList;
    } else {
      renderNode = /* @__PURE__ */ React__namespace.createElement(InternalSubMenu, props, childList);
    }
    return /* @__PURE__ */ React__namespace.createElement(PathTrackerContext.Provider, {
      value: connectedKeyPath
    }, renderNode);
  }
  var _excluded$h = ["className", "title", "eventKey", "children"], _excluded2$2 = ["children"];
  var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
    var className = _ref.className, title = _ref.title;
    _ref.eventKey;
    var children = _ref.children, restProps = _objectWithoutProperties$8(_ref, _excluded$h);
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
    var groupPrefixCls = "".concat(prefixCls, "-item-group");
    return /* @__PURE__ */ React__namespace.createElement("li", _extends$7({
      role: "presentation"
    }, restProps, {
      onClick: function onClick(e2) {
        return e2.stopPropagation();
      },
      className: classname(groupPrefixCls, className)
    }), /* @__PURE__ */ React__namespace.createElement("div", {
      role: "presentation",
      className: "".concat(groupPrefixCls, "-title"),
      title: typeof title === "string" ? title : void 0
    }, title), /* @__PURE__ */ React__namespace.createElement("ul", {
      role: "group",
      className: "".concat(groupPrefixCls, "-list")
    }, children));
  };
  function MenuItemGroup(_ref2) {
    var children = _ref2.children, props = _objectWithoutProperties$8(_ref2, _excluded2$2);
    var connectedKeyPath = useFullPath(props.eventKey);
    var childList = parseChildren(children, connectedKeyPath);
    var measure = useMeasure();
    if (measure) {
      return childList;
    }
    return /* @__PURE__ */ React__namespace.createElement(InternalMenuItemGroup, omit(props, ["warnKey"]), childList);
  }
  function Divider(_ref) {
    var className = _ref.className, style2 = _ref.style;
    var _React$useContext = React__namespace.useContext(MenuContext), prefixCls = _React$useContext.prefixCls;
    var measure = useMeasure();
    if (measure) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement("li", {
      role: "separator",
      className: classname("".concat(prefixCls, "-item-divider"), className),
      style: style2
    });
  }
  var _excluded$g = ["label", "children", "key", "type"];
  function convertItemsToNodes(list) {
    return (list || []).map(function(opt, index2) {
      if (opt && _typeof(opt) === "object") {
        var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type4 = _ref.type, restProps = _objectWithoutProperties$8(_ref, _excluded$g);
        var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
        if (children || type4 === "group") {
          if (type4 === "group") {
            return /* @__PURE__ */ React__namespace.createElement(MenuItemGroup, _extends$7({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children));
          }
          return /* @__PURE__ */ React__namespace.createElement(SubMenu, _extends$7({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children));
        }
        if (type4 === "divider") {
          return /* @__PURE__ */ React__namespace.createElement(Divider, _extends$7({
            key: mergedKey
          }, restProps));
        }
        return /* @__PURE__ */ React__namespace.createElement(MenuItem$1, _extends$7({
          key: mergedKey
        }, restProps), label);
      }
      return null;
    }).filter(function(opt) {
      return opt;
    });
  }
  function parseItems(children, items, keyPath) {
    var childNodes = children;
    if (items) {
      childNodes = convertItemsToNodes(items);
    }
    return parseChildren(childNodes, keyPath);
  }
  var _excluded$f = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
  var EMPTY_LIST = [];
  var Menu = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _childList$, _classNames;
    var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown = _ref.onKeyDown;
    _ref.openAnimation;
    _ref.openTransitionName;
    var _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, restProps = _objectWithoutProperties$8(_ref, _excluded$f);
    var childList = React__namespace.useMemo(function() {
      return parseItems(children, items, EMPTY_LIST);
    }, [children, items]);
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
    var containerRef = React__namespace.useRef();
    var uuid2 = useUUID(id);
    var isRtl = direction === "rtl";
    var _useMergedState = useMergedState(defaultOpenKeys, {
      value: openKeys,
      postState: function postState(keys2) {
        return keys2 || EMPTY_LIST;
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
    var triggerOpenKeys = function triggerOpenKeys2(keys2) {
      var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      function doUpdate() {
        setMergedOpenKeys(keys2);
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
      }
      if (forceFlush) {
        ReactDOM__default.flushSync(doUpdate);
      } else {
        doUpdate();
      }
    };
    var _React$useState3 = React__namespace.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
    var mountRef = React__namespace.useRef(false);
    var _React$useMemo = React__namespace.useMemo(function() {
      if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
        return ["vertical", inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
    var isInlineMode = mergedMode === "inline";
    var _React$useState5 = React__namespace.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
    var _React$useState7 = React__namespace.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
    React__namespace.useEffect(function() {
      setInternalMode(mergedMode);
      setInternalInlineCollapsed(mergedInlineCollapsed);
      if (!mountRef.current) {
        return;
      }
      if (isInlineMode) {
        setMergedOpenKeys(inlineCacheOpenKeys);
      } else {
        triggerOpenKeys(EMPTY_LIST);
      }
    }, [mergedMode, mergedInlineCollapsed]);
    var _React$useState9 = React__namespace.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
    var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
    React__namespace.useEffect(function() {
      if (isInlineMode) {
        setInlineCacheOpenKeys(mergedOpenKeys);
      }
    }, [mergedOpenKeys]);
    React__namespace.useEffect(function() {
      mountRef.current = true;
      return function() {
        mountRef.current = false;
      };
    }, []);
    var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
    var registerPathContext = React__namespace.useMemo(function() {
      return {
        registerPath,
        unregisterPath
      };
    }, [registerPath, unregisterPath]);
    var pathUserContext = React__namespace.useMemo(function() {
      return {
        isSubPathKey
      };
    }, [isSubPathKey]);
    React__namespace.useEffect(function() {
      refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(function(child) {
        return child.key;
      }));
    }, [lastVisibleIndex, allVisible]);
    var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
      value: activeKey
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
    var onActive = useMemoCallback(function(key) {
      setMergedActiveKey(key);
    });
    var onInactive = useMemoCallback(function() {
      setMergedActiveKey(void 0);
    });
    React.useImperativeHandle(ref, function() {
      return {
        list: containerRef.current,
        focus: function focus(options) {
          var _childList$find;
          var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node2) {
            return !node2.props.disabled;
          })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
          if (shouldFocusKey) {
            var _containerRef$current, _containerRef$current2, _containerRef$current3;
            (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
          }
        }
      };
    });
    var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
      value: selectedKeys,
      // Legacy convert key to array
      postState: function postState(keys2) {
        if (Array.isArray(keys2)) {
          return keys2;
        }
        if (keys2 === null || keys2 === void 0) {
          return EMPTY_LIST;
        }
        return [keys2];
      }
    }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
    var triggerSelection = function triggerSelection2(info2) {
      if (selectable) {
        var targetKey = info2.key;
        var exist = mergedSelectKeys.includes(targetKey);
        var newSelectKeys;
        if (multiple) {
          if (exist) {
            newSelectKeys = mergedSelectKeys.filter(function(key) {
              return key !== targetKey;
            });
          } else {
            newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
          }
        } else {
          newSelectKeys = [targetKey];
        }
        setMergedSelectKeys(newSelectKeys);
        var selectInfo = _objectSpread2(_objectSpread2({}, info2), {}, {
          selectedKeys: newSelectKeys
        });
        if (exist) {
          onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
        } else {
          onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
        }
      }
      if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
        triggerOpenKeys(EMPTY_LIST);
      }
    };
    var onInternalClick = useMemoCallback(function(info2) {
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
      triggerSelection(info2);
    });
    var onInternalOpenChange = useMemoCallback(function(key, open2) {
      var newOpenKeys = mergedOpenKeys.filter(function(k2) {
        return k2 !== key;
      });
      if (open2) {
        newOpenKeys.push(key);
      } else if (internalMode !== "inline") {
        var subPathKeys = getSubPathKeys(key);
        newOpenKeys = newOpenKeys.filter(function(k2) {
          return !subPathKeys.has(k2);
        });
      }
      if (!isEqual(mergedOpenKeys, newOpenKeys, true)) {
        triggerOpenKeys(newOpenKeys, true);
      }
    });
    var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open2) {
      var nextOpen = open2 !== null && open2 !== void 0 ? open2 : !mergedOpenKeys.includes(key);
      onInternalOpenChange(key, nextOpen);
    };
    var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);
    React__namespace.useEffect(function() {
      setMounted(true);
    }, []);
    var privateContext = React__namespace.useMemo(function() {
      return {
        _internalRenderMenuItem,
        _internalRenderSubMenuItem
      };
    }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
    var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
      // Need wrap for overflow dropdown that do not response for open
      childList.map(function(child, index2) {
        return (
          // Always wrap provider to avoid sub node re-mount
          /* @__PURE__ */ React__namespace.createElement(InheritableContextProvider, {
            key: child.key,
            overflowDisabled: index2 > lastVisibleIndex
          }, child)
        );
      })
    );
    var container = /* @__PURE__ */ React__namespace.createElement(ForwardOverflow, _extends$7({
      id,
      ref: containerRef,
      prefixCls: "".concat(prefixCls, "-overflow"),
      component: "ul",
      itemComponent: MenuItem$1,
      className: classname(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
      dir: direction,
      style: style2,
      role: "menu",
      tabIndex,
      data: wrappedChildList,
      renderRawItem: function renderRawItem(node2) {
        return node2;
      },
      renderRawRest: function renderRawRest(omitItems) {
        var len = omitItems.length;
        var originOmitItems = len ? childList.slice(-len) : null;
        return /* @__PURE__ */ React__namespace.createElement(SubMenu, {
          eventKey: OVERFLOW_KEY,
          title: overflowedIndicator,
          disabled: allVisible,
          internalPopupClose: len === 0,
          popupClassName: overflowedIndicatorPopupClassName
        }, originOmitItems);
      },
      maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
      ssr: "full",
      "data-menu-list": true,
      onVisibleChange: function onVisibleChange(newLastIndex) {
        setLastVisibleIndex(newLastIndex);
      },
      onKeyDown: onInternalKeyDown
    }, restProps));
    return /* @__PURE__ */ React__namespace.createElement(PrivateContext.Provider, {
      value: privateContext
    }, /* @__PURE__ */ React__namespace.createElement(IdContext.Provider, {
      value: uuid2
    }, /* @__PURE__ */ React__namespace.createElement(InheritableContextProvider, {
      prefixCls,
      rootClassName,
      mode: internalMode,
      openKeys: mergedOpenKeys,
      rtl: isRtl,
      disabled,
      motion: mounted ? motion2 : null,
      defaultMotions: mounted ? defaultMotions : null,
      activeKey: mergedActiveKey,
      onActive,
      onInactive,
      selectedKeys: mergedSelectKeys,
      inlineIndent,
      subMenuOpenDelay,
      subMenuCloseDelay,
      forceSubMenuRender,
      builtinPlacements,
      triggerSubMenuAction,
      getPopupContainer,
      itemIcon,
      expandIcon,
      onItemClick: onInternalClick,
      onOpenChange: onInternalOpenChange
    }, /* @__PURE__ */ React__namespace.createElement(PathUserContext.Provider, {
      value: pathUserContext
    }, container), /* @__PURE__ */ React__namespace.createElement("div", {
      style: {
        display: "none"
      },
      "aria-hidden": true
    }, /* @__PURE__ */ React__namespace.createElement(PathRegisterContext.Provider, {
      value: registerPathContext
    }, childList)))));
  });
  var ExportMenu = Menu;
  ExportMenu.Item = MenuItem$1;
  ExportMenu.SubMenu = SubMenu;
  ExportMenu.ItemGroup = MenuItemGroup;
  ExportMenu.Divider = Divider;
  var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
  const EllipsisOutlinedSvg = EllipsisOutlined$2;
  var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: EllipsisOutlinedSvg
    }));
  };
  const EllipsisOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(EllipsisOutlined);
  const genPlaceholderStyle = (color) => ({
    // Firefox
    "&::-moz-placeholder": {
      opacity: 1
    },
    "&::placeholder": {
      color,
      userSelect: "none"
      // https://github.com/ant-design/ant-design/pull/32639
    },
    "&:placeholder-shown": {
      textOverflow: "ellipsis"
    }
  });
  const genHoverStyle = (token2) => ({
    borderColor: token2.hoverBorderColor,
    backgroundColor: token2.hoverBg
  });
  const genActiveStyle = (token2) => ({
    borderColor: token2.activeBorderColor,
    boxShadow: token2.activeShadow,
    outline: 0,
    backgroundColor: token2.activeBg
  });
  const genDisabledStyle = (token2) => ({
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    borderColor: token2.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "&:hover": Object.assign({}, genHoverStyle(merge(token2, {
      hoverBorderColor: token2.colorBorder,
      hoverBg: token2.colorBgContainerDisabled
    })))
  });
  const genInputLargeStyle = (token2) => {
    const {
      paddingBlockLG,
      fontSizeLG,
      lineHeightLG,
      borderRadiusLG,
      paddingInlineLG
    } = token2;
    return {
      padding: `${paddingBlockLG}px ${paddingInlineLG}px`,
      fontSize: fontSizeLG,
      lineHeight: lineHeightLG,
      borderRadius: borderRadiusLG
    };
  };
  const genInputSmallStyle = (token2) => ({
    padding: `${token2.paddingBlockSM}px ${token2.paddingInlineSM}px`,
    borderRadius: token2.borderRadiusSM
  });
  const genStatusStyle = (token2, parentCls) => {
    const {
      componentCls,
      colorError,
      colorWarning,
      errorActiveShadow,
      warningActiveShadow,
      colorErrorBorderHover,
      colorWarningBorderHover
    } = token2;
    return {
      [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorError,
        "&:hover": {
          borderColor: colorErrorBorderHover
        },
        "&:focus, &:focus-within": Object.assign({}, genActiveStyle(merge(token2, {
          activeBorderColor: colorError,
          activeShadow: errorActiveShadow
        }))),
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          color: colorError
        }
      },
      [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorWarning,
        "&:hover": {
          borderColor: colorWarningBorderHover
        },
        "&:focus, &:focus-within": Object.assign({}, genActiveStyle(merge(token2, {
          activeBorderColor: colorWarning,
          activeShadow: warningActiveShadow
        }))),
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          color: colorWarning
        }
      }
    };
  };
  const genBasicInputStyle = (token2) => Object.assign(Object.assign({
    position: "relative",
    display: "inline-block",
    width: "100%",
    minWidth: 0,
    padding: `${token2.paddingBlock}px ${token2.paddingInline}px`,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    backgroundColor: token2.colorBgContainer,
    backgroundImage: "none",
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: token2.colorBorder,
    borderRadius: token2.borderRadius,
    transition: `all ${token2.motionDurationMid}`
  }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
    "&:hover": Object.assign({}, genHoverStyle(token2)),
    "&:focus, &:focus-within": Object.assign({}, genActiveStyle(token2)),
    "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
    "&-borderless": {
      "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
        backgroundColor: "transparent",
        border: "none",
        boxShadow: "none"
      }
    },
    // Reset height for `textarea`s
    "textarea&": {
      maxWidth: "100%",
      height: "auto",
      minHeight: token2.controlHeight,
      lineHeight: token2.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${token2.motionDurationSlow}, height 0s`,
      resize: "vertical"
    },
    // Size
    "&-lg": Object.assign({}, genInputLargeStyle(token2)),
    "&-sm": Object.assign({}, genInputSmallStyle(token2)),
    // RTL
    "&-rtl": {
      direction: "rtl"
    },
    "&-textarea-rtl": {
      direction: "rtl"
    }
  });
  const genInputGroupStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      // Undo padding and float of grid classes
      [`&[class*='col-']`]: {
        paddingInlineEnd: token2.paddingXS,
        "&:last-child": {
          paddingInlineEnd: 0
        }
      },
      // Sizing options
      [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
      [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
      // Fix https://github.com/ant-design/ant-design/issues/5754
      [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
        height: token2.controlHeightLG
      },
      [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
        height: token2.controlHeightSM
      },
      [`> ${componentCls}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      [`${componentCls}-group`]: {
        [`&-addon, &-wrap`]: {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        "&-wrap > *": {
          display: "block !important"
        },
        "&-addon": {
          position: "relative",
          padding: `0 ${token2.paddingInline}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          textAlign: "center",
          backgroundColor: token2.addonBg,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`,
          lineHeight: 1,
          // Reset Select's style in addon
          [`${antCls}-select`]: {
            margin: `-${token2.paddingBlock + 1}px -${token2.paddingInline}px`,
            [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
              [`${antCls}-select-selector`]: {
                backgroundColor: "inherit",
                border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                boxShadow: "none"
              }
            },
            "&-open, &-focused": {
              [`${antCls}-select-selector`]: {
                color: token2.colorPrimary
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/31333
          [`${antCls}-cascader-picker`]: {
            margin: `-9px -${token2.paddingInline}px`,
            backgroundColor: "transparent",
            [`${antCls}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none"
            }
          }
        },
        "&-addon:first-child": {
          borderInlineEnd: 0
        },
        "&-addon:last-child": {
          borderInlineStart: 0
        }
      },
      [`${componentCls}`]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": {
          zIndex: 1,
          borderInlineEndWidth: 1
        },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }
      },
      // Reset rounded corners
      [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}-affix-wrapper`]: {
        [`&:not(:first-child) ${componentCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        },
        [`&:not(:last-child) ${componentCls}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${componentCls}-search &`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          }
        },
        [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
        display: "block"
      }, clearFix()), {
        [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
          "&:not(:first-child):not(:last-child)": {
            borderInlineEndWidth: token2.lineWidth,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          }
        },
        "& > *": {
          display: "inline-block",
          float: "none",
          verticalAlign: "top",
          borderRadius: 0
        },
        [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
          display: "inline-flex"
        },
        "& > *:not(:last-child)": {
          marginInlineEnd: -token2.lineWidth,
          borderInlineEndWidth: token2.lineWidth
        },
        // Undo float for .ant-input-group .ant-input
        [`${componentCls}`]: {
          float: "none"
        },
        // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
        [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderRadius: 0,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        },
        [`& > ${antCls}-select-focused`]: {
          zIndex: 1
        },
        // update z-index for arrow icon
        [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
          zIndex: 1
          // https://github.com/ant-design/ant-design/issues/20371
        },
        [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        },
        [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderStartEndRadius: token2.borderRadius,
          borderEndEndRadius: token2.borderRadius
        },
        // https://github.com/ant-design/ant-design/issues/12493
        [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
          verticalAlign: "top"
        },
        [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
          marginInlineStart: -token2.lineWidth,
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`${componentCls}-group-wrapper:not(:last-child)`]: {
          [`&${componentCls}-search > ${componentCls}-group`]: {
            [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
              borderRadius: 0
            },
            [`& > ${componentCls}`]: {
              borderStartStartRadius: token2.borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: token2.borderRadius
            }
          }
        }
      })
    };
  };
  const genInputStyle = (token2) => {
    const {
      componentCls,
      controlHeightSM,
      lineWidth
    } = token2;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
        '&[type="color"]': {
          height: token2.controlHeight,
          [`&${componentCls}-lg`]: {
            height: token2.controlHeightLG
          },
          [`&${componentCls}-sm`]: {
            height: controlHeightSM,
            paddingTop: colorSmallPadding,
            paddingBottom: colorSmallPadding
          }
        },
        '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
          "-webkit-appearance": "none"
        }
      })
    };
  };
  const genAllowClearStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // ========================= Input =========================
      [`${componentCls}-clear-icon`]: {
        margin: 0,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        verticalAlign: -1,
        // https://github.com/ant-design/ant-design/pull/18151
        // https://codesandbox.io/s/wizardly-sun-u10br
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextTertiary
        },
        "&:active": {
          color: token2.colorText
        },
        "&-hidden": {
          visibility: "hidden"
        },
        "&-has-suffix": {
          margin: `0 ${token2.inputAffixPadding}px`
        }
      }
    };
  };
  const genAffixStyle = (token2) => {
    const {
      componentCls,
      inputAffixPadding,
      colorTextDescription,
      motionDurationSlow,
      colorIcon,
      colorIconHover,
      iconCls
    } = token2;
    return {
      [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
        display: "inline-flex",
        [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: {
          zIndex: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        },
        "&-focused, &:focus": {
          zIndex: 1
        },
        "&-disabled": {
          [`${componentCls}[disabled]`]: {
            background: "transparent"
          }
        },
        [`> input${componentCls}`]: {
          padding: 0,
          fontSize: "inherit",
          border: "none",
          borderRadius: 0,
          outline: "none",
          "&::-ms-reveal": {
            display: "none"
          },
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        "&::before": {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [`${componentCls}`]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            "> *:not(:last-child)": {
              marginInlineEnd: token2.paddingXS
            }
          },
          "&-show-count-suffix": {
            color: colorTextDescription
          },
          "&-show-count-has-suffix": {
            marginInlineEnd: token2.paddingXXS
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            marginInlineStart: inputAffixPadding
          }
        }
      }), genAllowClearStyle(token2)), {
        // password
        [`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
    };
  };
  const genGroupStyle = (token2) => {
    const {
      componentCls,
      colorError,
      colorWarning,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
        "&-rtl": {
          direction: "rtl"
        },
        "&-wrapper": {
          display: "inline-block",
          width: "100%",
          textAlign: "start",
          verticalAlign: "top",
          "&-rtl": {
            direction: "rtl"
          },
          // Size
          "&-lg": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG,
              fontSize: token2.fontSizeLG
            }
          },
          "&-sm": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          },
          // Status
          "&-status-error": {
            [`${componentCls}-group-addon`]: {
              color: colorError,
              borderColor: colorError
            }
          },
          "&-status-warning": {
            [`${componentCls}-group-addon`]: {
              color: colorWarning,
              borderColor: colorWarning
            }
          },
          "&-disabled": {
            [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
          },
          // Fix the issue of using icons in Space Compact mode
          // https://github.com/ant-design/ant-design/issues/42122
          [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        }
      })
    };
  };
  const genSearchInputStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const searchPrefixCls = `${componentCls}-search`;
    return {
      [searchPrefixCls]: {
        [`${componentCls}`]: {
          "&:hover, &:focus": {
            borderColor: token2.colorPrimaryHover,
            [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              borderInlineStartColor: token2.colorPrimaryHover
            }
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        },
        // fix slight height diff in Firefox:
        // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
        [`${componentCls}-lg`]: {
          lineHeight: token2.lineHeightLG - 2e-4
        },
        [`> ${componentCls}-group`]: {
          [`> ${componentCls}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${searchPrefixCls}-button`]: {
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderStartEndRadius: token2.borderRadius,
              borderEndEndRadius: token2.borderRadius,
              borderEndStartRadius: 0,
              boxShadow: "none"
            },
            [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              color: token2.colorTextDescription,
              "&:hover": {
                color: token2.colorPrimaryHover
              },
              "&:active": {
                color: token2.colorPrimaryActive
              },
              [`&${antCls}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0
              }
            }
          }
        },
        [`${searchPrefixCls}-button`]: {
          height: token2.controlHeight,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        [`&-large ${searchPrefixCls}-button`]: {
          height: token2.controlHeightLG
        },
        [`&-small ${searchPrefixCls}-button`]: {
          height: token2.controlHeightSM
        },
        "&-rtl": {
          direction: "rtl"
        },
        // ===================== Compact Item Customized Styles =====================
        [`&${componentCls}-compact-item`]: {
          [`&:not(${componentCls}-compact-last-item)`]: {
            [`${componentCls}-group-addon`]: {
              [`${componentCls}-search-button`]: {
                marginInlineEnd: -token2.lineWidth,
                borderRadius: 0
              }
            }
          },
          [`&:not(${componentCls}-compact-first-item)`]: {
            [`${componentCls},${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
            "&:hover,&:focus,&:active": {
              zIndex: 2
            }
          },
          [`> ${componentCls}-affix-wrapper-focused`]: {
            zIndex: 2
          }
        }
      }
    };
  };
  const genTextAreaStyle = (token2) => {
    const {
      componentCls,
      paddingLG
    } = token2;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
      [textareaPrefixCls]: {
        position: "relative",
        "&-show-count": {
          // https://github.com/ant-design/ant-design/issues/33049
          [`> ${componentCls}`]: {
            height: "100%"
          },
          [`${componentCls}-data-count`]: {
            position: "absolute",
            bottom: -token2.fontSize * token2.lineHeight,
            insetInlineEnd: 0,
            color: token2.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none"
          }
        },
        "&-allow-clear": {
          [`> ${componentCls}`]: {
            paddingInlineEnd: paddingLG
          }
        },
        [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
          [`${componentCls}`]: {
            paddingInlineEnd: paddingLG
          }
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${componentCls}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          [`${componentCls}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": {
              marginInline: 0
            },
            // Clear Icon
            [`${componentCls}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              insetBlockStart: token2.paddingXS
            },
            // Feedback Icon
            [`${textareaPrefixCls}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none"
            }
          }
        }
      }
    };
  };
  function initInputToken(token2) {
    return merge(token2, {
      inputAffixPadding: token2.paddingXXS
    });
  }
  const initComponentToken = (token2) => {
    const {
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      controlHeightSM,
      controlHeightLG,
      fontSizeLG,
      lineHeightLG,
      paddingSM,
      controlPaddingHorizontalSM,
      controlPaddingHorizontal,
      colorFillAlter,
      colorPrimaryHover,
      colorPrimary,
      controlOutlineWidth,
      controlOutline,
      colorErrorOutline,
      colorWarningOutline
    } = token2;
    return {
      paddingBlock: Math.max(Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
      paddingBlockSM: Math.max(Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
      paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
      paddingInline: paddingSM - lineWidth,
      paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
      paddingInlineLG: controlPaddingHorizontal - lineWidth,
      addonBg: colorFillAlter,
      activeBorderColor: colorPrimary,
      hoverBorderColor: colorPrimaryHover,
      activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
      errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
      warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
      hoverBg: "",
      activeBg: ""
    };
  };
  const useStyle$6 = genComponentStyleHook("Input", (token2) => {
    const inputToken = merge(token2, initInputToken(token2));
    return [
      genInputStyle(inputToken),
      genTextAreaStyle(inputToken),
      genAffixStyle(inputToken),
      genGroupStyle(inputToken),
      genSearchInputStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)
    ];
  }, initComponentToken);
  var PlusOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
  const PlusOutlinedSvg = PlusOutlined$2;
  var PlusOutlined = function PlusOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: PlusOutlinedSvg
    }));
  };
  const PlusOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(PlusOutlined);
  const TabContext = /* @__PURE__ */ React.createContext(null);
  var TabPane$2 = /* @__PURE__ */ React__namespace.forwardRef(function(_ref, ref) {
    var prefixCls = _ref.prefixCls, className = _ref.className, style2 = _ref.style, id = _ref.id, active = _ref.active, tabKey = _ref.tabKey, children = _ref.children;
    return /* @__PURE__ */ React__namespace.createElement("div", {
      id: id && "".concat(id, "-panel-").concat(tabKey),
      role: "tabpanel",
      tabIndex: active ? 0 : -1,
      "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
      "aria-hidden": !active,
      style: style2,
      className: classname(prefixCls, active && "".concat(prefixCls, "-active"), className),
      ref
    }, children);
  });
  var _excluded$e = ["key", "forceRender", "style", "className"];
  function TabPanelList(_ref) {
    var id = _ref.id, activeKey = _ref.activeKey, animated = _ref.animated, tabPosition = _ref.tabPosition, destroyInactiveTabPane = _ref.destroyInactiveTabPane;
    var _React$useContext = React__namespace.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
    var tabPaneAnimated = animated.tabPane;
    var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname("".concat(prefixCls, "-content-holder"))
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$1({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
    }, tabs.map(function(_ref2) {
      var key = _ref2.key, forceRender = _ref2.forceRender, paneStyle = _ref2.style, paneClassName = _ref2.className, restTabProps = _objectWithoutProperties$8(_ref2, _excluded$e);
      var active = key === activeKey;
      return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({
        key,
        visible: active,
        forceRender,
        removeOnLeave: !!destroyInactiveTabPane,
        leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
      }, animated.tabPaneMotion), function(_ref3, ref) {
        var motionStyle = _ref3.style, motionClassName = _ref3.className;
        return /* @__PURE__ */ React__namespace.createElement(TabPane$2, _extends$7({}, restTabProps, {
          prefixCls: tabPanePrefixCls,
          id,
          tabKey: key,
          animated: tabPaneAnimated,
          active,
          style: _objectSpread2(_objectSpread2({}, paneStyle), motionStyle),
          className: classname(paneClassName, motionClassName),
          ref
        }));
      });
    })));
  }
  var DEFAULT_SIZE$1 = {
    width: 0,
    height: 0,
    left: 0,
    top: 0
  };
  function useOffsets(tabs, tabSizes, holderScrollWidth) {
    return React.useMemo(function() {
      var _tabs$;
      var map = /* @__PURE__ */ new Map();
      var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1;
      var rightOffset = lastOffset.left + lastOffset.width;
      for (var i = 0; i < tabs.length; i += 1) {
        var key = tabs[i].key;
        var data = tabSizes.get(key);
        if (!data) {
          var _tabs;
          data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
        }
        var entity = map.get(key) || _objectSpread2({}, data);
        entity.right = rightOffset - entity.left - entity.width;
        map.set(key, entity);
      }
      return map;
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_"), tabSizes, holderScrollWidth]);
  }
  function useSyncState(defaultState, onChange) {
    var stateRef = React__namespace.useRef(defaultState);
    var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    function setState(updater) {
      var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
      if (newValue !== stateRef.current) {
        onChange(newValue, stateRef.current);
      }
      stateRef.current = newValue;
      forceUpdate({});
    }
    return [stateRef.current, setState];
  }
  var MIN_SWIPE_DISTANCE = 0.1;
  var STOP_SWIPE_DISTANCE = 0.01;
  var REFRESH_INTERVAL = 20;
  var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
  function useTouchMove(ref, onOffset) {
    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
    var _useState3 = React.useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
    var _useState5 = React.useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
    var _useState7 = React.useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
    var motionRef = React.useRef();
    function onTouchStart(e2) {
      var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      window.clearInterval(motionRef.current);
    }
    function onTouchMove(e2) {
      if (!touchPosition)
        return;
      e2.preventDefault();
      var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      var offsetX = screenX - touchPosition.x;
      var offsetY = screenY - touchPosition.y;
      onOffset(offsetX, offsetY);
      var now = Date.now();
      setLastTimestamp(now);
      setLastTimeDiff(now - lastTimestamp);
      setLastOffset({
        x: offsetX,
        y: offsetY
      });
    }
    function onTouchEnd() {
      if (!touchPosition)
        return;
      setTouchPosition(null);
      setLastOffset(null);
      if (lastOffset) {
        var distanceX = lastOffset.x / lastTimeDiff;
        var distanceY = lastOffset.y / lastTimeDiff;
        var absX = Math.abs(distanceX);
        var absY = Math.abs(distanceY);
        if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
          return;
        var currentX = distanceX;
        var currentY = distanceY;
        motionRef.current = window.setInterval(function() {
          if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
            window.clearInterval(motionRef.current);
            return;
          }
          currentX *= SPEED_OFF_MULTIPLE;
          currentY *= SPEED_OFF_MULTIPLE;
          onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
        }, REFRESH_INTERVAL);
      }
    }
    var lastWheelDirectionRef = React.useRef();
    function onWheel(e2) {
      var deltaX = e2.deltaX, deltaY = e2.deltaY;
      var mixed = 0;
      var absX = Math.abs(deltaX);
      var absY = Math.abs(deltaY);
      if (absX === absY) {
        mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
      } else if (absX > absY) {
        mixed = deltaX;
        lastWheelDirectionRef.current = "x";
      } else {
        mixed = deltaY;
        lastWheelDirectionRef.current = "y";
      }
      if (onOffset(-mixed, -mixed)) {
        e2.preventDefault();
      }
    }
    var touchEventsRef = React.useRef(null);
    touchEventsRef.current = {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onWheel
    };
    React__namespace.useEffect(function() {
      function onProxyTouchStart(e2) {
        touchEventsRef.current.onTouchStart(e2);
      }
      function onProxyTouchMove(e2) {
        touchEventsRef.current.onTouchMove(e2);
      }
      function onProxyTouchEnd(e2) {
        touchEventsRef.current.onTouchEnd(e2);
      }
      function onProxyWheel(e2) {
        touchEventsRef.current.onWheel(e2);
      }
      document.addEventListener("touchmove", onProxyTouchMove, {
        passive: false
      });
      document.addEventListener("touchend", onProxyTouchEnd, {
        passive: false
      });
      ref.current.addEventListener("touchstart", onProxyTouchStart, {
        passive: false
      });
      ref.current.addEventListener("wheel", onProxyWheel);
      return function() {
        document.removeEventListener("touchmove", onProxyTouchMove);
        document.removeEventListener("touchend", onProxyTouchEnd);
      };
    }, []);
  }
  function useUpdate$1(callback) {
    var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
    var effectRef = React.useRef(0);
    var callbackRef = React.useRef();
    callbackRef.current = callback;
    useLayoutUpdateEffect(function() {
      var _callbackRef$current;
      (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef);
    }, [count]);
    return function() {
      if (effectRef.current !== count) {
        return;
      }
      effectRef.current += 1;
      setCount(effectRef.current);
    };
  }
  function useUpdateState(defaultState) {
    var batchRef = React.useRef([]);
    var _useState3 = React.useState({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
    var state = React.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
    var flushUpdate = useUpdate$1(function() {
      var current = state.current;
      batchRef.current.forEach(function(callback) {
        current = callback(current);
      });
      batchRef.current = [];
      state.current = current;
      forceUpdate({});
    });
    function updater(callback) {
      batchRef.current.push(callback);
      flushUpdate();
    }
    return [state.current, updater];
  }
  var DEFAULT_SIZE = {
    width: 0,
    height: 0,
    left: 0,
    top: 0,
    right: 0
  };
  function useVisibleRange(tabOffsets, visibleTabContentValue, transform2, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
    var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
    var charUnit;
    var position2;
    var transformSize;
    if (["top", "bottom"].includes(tabPosition)) {
      charUnit = "width";
      position2 = rtl ? "right" : "left";
      transformSize = Math.abs(transform2);
    } else {
      charUnit = "height";
      position2 = "top";
      transformSize = -transform2;
    }
    return React.useMemo(function() {
      if (!tabs.length) {
        return [0, 0];
      }
      var len = tabs.length;
      var endIndex = len;
      for (var i = 0; i < len; i += 1) {
        var offset = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE;
        if (offset[position2] + offset[charUnit] > transformSize + visibleTabContentValue) {
          endIndex = i - 1;
          break;
        }
      }
      var startIndex = 0;
      for (var _i = len - 1; _i >= 0; _i -= 1) {
        var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;
        if (_offset[position2] < transformSize) {
          startIndex = _i + 1;
          break;
        }
      }
      return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
    }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
      return tab.key;
    }).join("_"), rtl]);
  }
  function stringify$1(obj) {
    var tgt;
    if (obj instanceof Map) {
      tgt = {};
      obj.forEach(function(v2, k2) {
        tgt[k2] = v2;
      });
    } else {
      tgt = obj;
    }
    return JSON.stringify(tgt);
  }
  var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
  function genDataNodeKey(key) {
    return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
  }
  function getRemovable(closable, closeIcon, editable, disabled) {
    if (
      // Only editable tabs can be removed
      !editable || // Tabs cannot be removed when disabled
      disabled || // closable is false
      closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
      closable === void 0 && (closeIcon === false || closeIcon === null)
    ) {
      return false;
    }
    return true;
  }
  function AddButton(_ref, ref) {
    var prefixCls = _ref.prefixCls, editable = _ref.editable, locale2 = _ref.locale, style2 = _ref.style;
    if (!editable || editable.showAdd === false) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement("button", {
      ref,
      type: "button",
      className: "".concat(prefixCls, "-nav-add"),
      style: style2,
      "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
      onClick: function onClick(event) {
        editable.onEdit("add", {
          event
        });
      }
    }, editable.addIcon || "+");
  }
  const AddButton$1 = /* @__PURE__ */ React__namespace.forwardRef(AddButton);
  var ExtraContent = /* @__PURE__ */ React__namespace.forwardRef(function(_ref, ref) {
    var position2 = _ref.position, prefixCls = _ref.prefixCls, extra = _ref.extra;
    if (!extra)
      return null;
    var content;
    var assertExtra = {};
    if (_typeof(extra) === "object" && !/* @__PURE__ */ React__namespace.isValidElement(extra)) {
      assertExtra = extra;
    } else {
      assertExtra.right = extra;
    }
    if (position2 === "right") {
      content = assertExtra.right;
    }
    if (position2 === "left") {
      content = assertExtra.left;
    }
    return content ? /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-extra-content"),
      ref
    }, content) : null;
  });
  function OperationNode(_ref, ref) {
    var prefixCls = _ref.prefixCls, id = _ref.id, tabs = _ref.tabs, locale2 = _ref.locale, mobile = _ref.mobile, _ref$moreIcon = _ref.moreIcon, moreIcon = _ref$moreIcon === void 0 ? "More" : _ref$moreIcon, moreTransitionName = _ref.moreTransitionName, style2 = _ref.style, className = _ref.className, editable = _ref.editable, tabBarGutter = _ref.tabBarGutter, rtl = _ref.rtl, removeAriaLabel = _ref.removeAriaLabel, onTabClick = _ref.onTabClick, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName;
    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
    var _useState3 = React.useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
    var popupId = "".concat(id, "-more-popup");
    var dropdownPrefix = "".concat(prefixCls, "-dropdown");
    var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
    var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
    function onRemoveTab(event, key) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    var menu = /* @__PURE__ */ React__namespace.createElement(ExportMenu, {
      onClick: function onClick(_ref2) {
        var key = _ref2.key, domEvent = _ref2.domEvent;
        onTabClick(key, domEvent);
        setOpen(false);
      },
      prefixCls: "".concat(dropdownPrefix, "-menu"),
      id: popupId,
      tabIndex: -1,
      role: "listbox",
      "aria-activedescendant": selectedItemId,
      selectedKeys: [selectedKey],
      "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
    }, tabs.map(function(tab) {
      var closable = tab.closable, disabled = tab.disabled, closeIcon = tab.closeIcon, key = tab.key, label = tab.label;
      var removable = getRemovable(closable, closeIcon, editable, disabled);
      return /* @__PURE__ */ React__namespace.createElement(MenuItem$1, {
        key,
        id: "".concat(popupId, "-").concat(key),
        role: "option",
        "aria-controls": id && "".concat(id, "-panel-").concat(key),
        disabled
      }, /* @__PURE__ */ React__namespace.createElement("span", null, label), removable && /* @__PURE__ */ React__namespace.createElement("button", {
        type: "button",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: 0,
        className: "".concat(dropdownPrefix, "-menu-item-remove"),
        onClick: function onClick(e2) {
          e2.stopPropagation();
          onRemoveTab(e2, key);
        }
      }, closeIcon || editable.removeIcon || "×"));
    }));
    function selectOffset(offset) {
      var enabledTabs = tabs.filter(function(tab2) {
        return !tab2.disabled;
      });
      var selectedIndex = enabledTabs.findIndex(function(tab2) {
        return tab2.key === selectedKey;
      }) || 0;
      var len = enabledTabs.length;
      for (var i = 0; i < len; i += 1) {
        selectedIndex = (selectedIndex + offset + len) % len;
        var tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    }
    function onKeyDown(e2) {
      var which = e2.which;
      if (!open2) {
        if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
          setOpen(true);
          e2.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode.UP:
          selectOffset(-1);
          e2.preventDefault();
          break;
        case KeyCode.DOWN:
          selectOffset(1);
          e2.preventDefault();
          break;
        case KeyCode.ESC:
          setOpen(false);
          break;
        case KeyCode.SPACE:
        case KeyCode.ENTER:
          if (selectedKey !== null)
            onTabClick(selectedKey, e2);
          break;
      }
    }
    React.useEffect(function() {
      var ele = document.getElementById(selectedItemId);
      if (ele && ele.scrollIntoView) {
        ele.scrollIntoView(false);
      }
    }, [selectedKey]);
    React.useEffect(function() {
      if (!open2) {
        setSelectedKey(null);
      }
    }, [open2]);
    var moreStyle = _defineProperty$1({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
    if (!tabs.length) {
      moreStyle.visibility = "hidden";
      moreStyle.order = 1;
    }
    var overlayClassName = classname(_defineProperty$1({}, "".concat(dropdownPrefix, "-rtl"), rtl));
    var moreNode = mobile ? null : /* @__PURE__ */ React__namespace.createElement(Dropdown$1, {
      prefixCls: dropdownPrefix,
      overlay: menu,
      trigger: ["hover"],
      visible: tabs.length ? open2 : false,
      transitionName: moreTransitionName,
      onVisibleChange: setOpen,
      overlayClassName: classname(overlayClassName, popupClassName),
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      getPopupContainer
    }, /* @__PURE__ */ React__namespace.createElement("button", {
      type: "button",
      className: "".concat(prefixCls, "-nav-more"),
      style: moreStyle,
      tabIndex: -1,
      "aria-hidden": "true",
      "aria-haspopup": "listbox",
      "aria-controls": popupId,
      id: "".concat(id, "-more"),
      "aria-expanded": open2,
      onKeyDown
    }, moreIcon));
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname("".concat(prefixCls, "-nav-operations"), className),
      style: style2,
      ref
    }, moreNode, /* @__PURE__ */ React__namespace.createElement(AddButton$1, {
      prefixCls,
      locale: locale2,
      editable
    }));
  }
  const OperationNode$1 = /* @__PURE__ */ React__namespace.memo(/* @__PURE__ */ React__namespace.forwardRef(OperationNode), function(_, next2) {
    return (
      // https://github.com/ant-design/ant-design/issues/32544
      // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
      next2.tabMoving
    );
  });
  function TabNode(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls, id = _ref.id, active = _ref.active, _ref$tab = _ref.tab, key = _ref$tab.key, label = _ref$tab.label, disabled = _ref$tab.disabled, closeIcon = _ref$tab.closeIcon, closable = _ref.closable, renderWrapper = _ref.renderWrapper, removeAriaLabel = _ref.removeAriaLabel, editable = _ref.editable, onClick = _ref.onClick, onFocus = _ref.onFocus, style2 = _ref.style;
    var tabPrefix = "".concat(prefixCls, "-tab");
    var removable = getRemovable(closable, closeIcon, editable, disabled);
    function onInternalClick(e2) {
      if (disabled) {
        return;
      }
      onClick(e2);
    }
    function onRemoveTab(event) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    var node2 = /* @__PURE__ */ React__namespace.createElement("div", {
      key,
      "data-node-key": genDataNodeKey(key),
      className: classname(tabPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(tabPrefix, "-with-remove"), removable), _defineProperty$1(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$1(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
      style: style2,
      onClick: onInternalClick
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      role: "tab",
      "aria-selected": active,
      id: id && "".concat(id, "-tab-").concat(key),
      className: "".concat(tabPrefix, "-btn"),
      "aria-controls": id && "".concat(id, "-panel-").concat(key),
      "aria-disabled": disabled,
      tabIndex: disabled ? null : 0,
      onClick: function onClick2(e2) {
        e2.stopPropagation();
        onInternalClick(e2);
      },
      onKeyDown: function onKeyDown(e2) {
        if ([KeyCode.SPACE, KeyCode.ENTER].includes(e2.which)) {
          e2.preventDefault();
          onInternalClick(e2);
        }
      },
      onFocus
    }, label), removable && /* @__PURE__ */ React__namespace.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: "".concat(tabPrefix, "-remove"),
      onClick: function onClick2(e2) {
        e2.stopPropagation();
        onRemoveTab(e2);
      }
    }, closeIcon || editable.removeIcon || "×"));
    return renderWrapper ? renderWrapper(node2) : node2;
  }
  var useIndicator = function useIndicator2(_ref) {
    var activeTabOffset = _ref.activeTabOffset, horizontal = _ref.horizontal, rtl = _ref.rtl, indicatorSize = _ref.indicatorSize;
    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), inkStyle = _useState2[0], setInkStyle = _useState2[1];
    var inkBarRafRef = React.useRef();
    var getLength = function getLength2(origin) {
      if (typeof indicatorSize === "function") {
        return indicatorSize(origin);
      }
      if (typeof indicatorSize === "number") {
        return indicatorSize;
      }
      return origin;
    };
    function cleanInkBarRaf() {
      wrapperRaf.cancel(inkBarRafRef.current);
    }
    React.useEffect(function() {
      var newInkStyle = {};
      if (activeTabOffset) {
        if (horizontal) {
          if (rtl) {
            newInkStyle.right = activeTabOffset.right + activeTabOffset.width / 2;
            newInkStyle.transform = "translateX(50%)";
          } else {
            newInkStyle.left = activeTabOffset.left + activeTabOffset.width / 2;
            newInkStyle.transform = "translateX(-50%)";
          }
          newInkStyle.width = getLength(activeTabOffset.width);
        } else {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
          newInkStyle.transform = "translateY(-50%)";
          newInkStyle.height = getLength(activeTabOffset.height);
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.current = wrapperRaf(function() {
        setInkStyle(newInkStyle);
      });
      return cleanInkBarRaf;
    }, [activeTabOffset, horizontal, rtl, indicatorSize]);
    return {
      style: inkStyle
    };
  };
  var getSize = function getSize2(refObj) {
    var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
    return [offsetWidth, offsetHeight];
  };
  var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
    return size[tabPositionTopOrBottom ? 0 : 1];
  };
  function TabNavList(props, ref) {
    var _classNames;
    var _React$useContext = React__namespace.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
    var className = props.className, style2 = props.style, id = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, indicatorSize = props.indicatorSize;
    var containerRef = React.useRef();
    var extraLeftRef = React.useRef();
    var extraRightRef = React.useRef();
    var tabsWrapperRef = React.useRef();
    var tabListRef = React.useRef();
    var operationsRef = React.useRef();
    var innerAddButtonRef = React.useRef();
    var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
    var _useSyncState = useSyncState(0, function(next2, prev2) {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
    var _useSyncState3 = useSyncState(0, function(next2, prev2) {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
    var _useState = React.useState([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
    var _useState3 = React.useState([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
    var _useState5 = React.useState([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
    var _useState7 = React.useState([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
    var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
    var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
    var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
    var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
    var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
    var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
    var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
    var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
    var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
    var transformMin = 0;
    var transformMax = 0;
    if (!tabPositionTopOrBottom) {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    } else if (rtl) {
      transformMin = 0;
      transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
    } else {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    }
    function alignInRange(value) {
      if (value < transformMin) {
        return transformMin;
      }
      if (value > transformMax) {
        return transformMax;
      }
      return value;
    }
    var touchMovingRef = React.useRef();
    var _useState9 = React.useState(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
    function doLockAnimation() {
      setLockAnimation(Date.now());
    }
    function clearTouchMoving() {
      window.clearTimeout(touchMovingRef.current);
    }
    useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
      function doMove(setState, offset) {
        setState(function(value) {
          var newValue = alignInRange(value + offset);
          return newValue;
        });
      }
      if (!needScroll) {
        return false;
      }
      if (tabPositionTopOrBottom) {
        doMove(setTransformLeft, offsetX);
      } else {
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    React.useEffect(function() {
      clearTouchMoving();
      if (lockAnimation) {
        touchMovingRef.current = window.setTimeout(function() {
          setLockAnimation(0);
        }, 100);
      }
      return clearTouchMoving;
    }, [lockAnimation]);
    var _useVisibleRange = useVisibleRange(
      tabOffsets,
      // Container
      visibleTabContentValue,
      // Transform
      tabPositionTopOrBottom ? transformLeft : transformTop,
      // Tabs
      tabContentSizeValue,
      // Add
      addSizeValue,
      // Operation
      operationSizeValue,
      _objectSpread2(_objectSpread2({}, props), {}, {
        tabs
      })
    ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
    var scrollToTab = useEvent(function() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
      var tabOffset = tabOffsets.get(key) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom) {
        var newTransform = transformLeft;
        if (rtl) {
          if (tabOffset.right < transformLeft) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
            newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
          }
        } else if (tabOffset.left < -transformLeft) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
          newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        var _newTransform = transformTop;
        if (tabOffset.top < -transformTop) {
          _newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
          _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(_newTransform));
      }
    });
    var tabNodeStyle = {};
    if (tabPosition === "top" || tabPosition === "bottom") {
      tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
    } else {
      tabNodeStyle.marginTop = tabBarGutter;
    }
    var tabNodes = tabs.map(function(tab, i) {
      var key = tab.key;
      return /* @__PURE__ */ React__namespace.createElement(TabNode, {
        id,
        prefixCls,
        key,
        tab,
        style: i === 0 ? void 0 : tabNodeStyle,
        closable: tab.closable,
        editable,
        active: key === activeKey,
        renderWrapper: children,
        removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        onClick: function onClick(e2) {
          onTabClick(key, e2);
        },
        onFocus: function onFocus() {
          scrollToTab(key);
          doLockAnimation();
          if (!tabsWrapperRef.current) {
            return;
          }
          if (!rtl) {
            tabsWrapperRef.current.scrollLeft = 0;
          }
          tabsWrapperRef.current.scrollTop = 0;
        }
      });
    });
    var updateTabSizes = function updateTabSizes2() {
      return setTabSizes(function() {
        var newSizes = /* @__PURE__ */ new Map();
        tabs.forEach(function(_ref2) {
          var _tabListRef$current;
          var key = _ref2.key;
          var btnNode = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
          if (btnNode) {
            newSizes.set(key, {
              width: btnNode.offsetWidth,
              height: btnNode.offsetHeight,
              left: btnNode.offsetLeft,
              top: btnNode.offsetTop
            });
          }
        });
        return newSizes;
      });
    };
    React.useEffect(function() {
      updateTabSizes();
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_")]);
    var onListHolderResize = useUpdate$1(function() {
      var containerSize = getSize(containerRef);
      var extraLeftSize = getSize(extraLeftRef);
      var extraRightSize = getSize(extraRightRef);
      setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
      var newAddSize = getSize(innerAddButtonRef);
      setAddSize(newAddSize);
      var newOperationSize = getSize(operationsRef);
      setOperationSize(newOperationSize);
      var tabContentFullSize = getSize(tabListRef);
      setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
      updateTabSizes();
    });
    var startHiddenTabs = tabs.slice(0, visibleStart);
    var endHiddenTabs = tabs.slice(visibleEnd + 1);
    var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
    var activeTabOffset = tabOffsets.get(activeKey);
    var _useIndicator = useIndicator({
      activeTabOffset,
      horizontal: tabPositionTopOrBottom,
      rtl,
      indicatorSize
    }), indicatorStyle = _useIndicator.style;
    React.useEffect(function() {
      scrollToTab();
    }, [activeKey, transformMin, transformMax, stringify$1(activeTabOffset), stringify$1(tabOffsets), tabPositionTopOrBottom]);
    React.useEffect(function() {
      onListHolderResize();
    }, [rtl]);
    var hasDropdown = !!hiddenTabs.length;
    var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
    var pingLeft;
    var pingRight;
    var pingTop;
    var pingBottom;
    if (tabPositionTopOrBottom) {
      if (rtl) {
        pingRight = transformLeft > 0;
        pingLeft = transformLeft !== transformMax;
      } else {
        pingLeft = transformLeft < 0;
        pingRight = transformLeft !== transformMin;
      }
    } else {
      pingTop = transformTop < 0;
      pingBottom = transformTop !== transformMin;
    }
    return /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      ref: useComposeRef(ref, containerRef),
      role: "tablist",
      className: classname("".concat(prefixCls, "-nav"), className),
      style: style2,
      onKeyDown: function onKeyDown() {
        doLockAnimation();
      }
    }, /* @__PURE__ */ React__namespace.createElement(ExtraContent, {
      ref: extraLeftRef,
      position: "left",
      extra,
      prefixCls
    }), /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(wrapPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
      ref: tabsWrapperRef
    }, /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      ref: tabListRef,
      className: "".concat(prefixCls, "-nav-list"),
      style: {
        transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
        transition: lockAnimation ? "none" : void 0
      }
    }, tabNodes, /* @__PURE__ */ React__namespace.createElement(AddButton$1, {
      ref: innerAddButtonRef,
      prefixCls,
      locale: locale2,
      editable,
      style: _objectSpread2(_objectSpread2({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
        visibility: hasDropdown ? "hidden" : null
      })
    }), /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname("".concat(prefixCls, "-ink-bar"), _defineProperty$1({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
      style: indicatorStyle
    }))))), /* @__PURE__ */ React__namespace.createElement(OperationNode$1, _extends$7({}, props, {
      removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
      ref: operationsRef,
      prefixCls,
      tabs: hiddenTabs,
      className: !hasDropdown && operationsHiddenClassName,
      tabMoving: !!lockAnimation
    })), /* @__PURE__ */ React__namespace.createElement(ExtraContent, {
      ref: extraRightRef,
      position: "right",
      extra,
      prefixCls
    })));
  }
  const TabNavList$1 = /* @__PURE__ */ React__namespace.forwardRef(TabNavList);
  var _excluded$d = ["renderTabBar"], _excluded2$1 = ["label", "key"];
  function TabNavListWrapper(_ref) {
    var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties$8(_ref, _excluded$d);
    var _React$useContext = React__namespace.useContext(TabContext), tabs = _React$useContext.tabs;
    if (renderTabBar) {
      var tabNavBarProps = _objectSpread2(_objectSpread2({}, restProps), {}, {
        // Legacy support. We do not use this actually
        panes: tabs.map(function(_ref2) {
          var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties$8(_ref2, _excluded2$1);
          return /* @__PURE__ */ React__namespace.createElement(TabPane$2, _extends$7({
            tab: label,
            key,
            tabKey: key
          }, restTabProps));
        })
      });
      return renderTabBar(tabNavBarProps, TabNavList$1);
    }
    return /* @__PURE__ */ React__namespace.createElement(TabNavList$1, restProps);
  }
  function useAnimateConfig$1() {
    var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      inkBar: true,
      tabPane: false
    };
    var mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: false
      };
    } else {
      mergedAnimated = _objectSpread2({
        inkBar: true
      }, _typeof(animated) === "object" ? animated : {});
    }
    if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
      mergedAnimated.tabPane = true;
    }
    if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
      mergedAnimated.tabPane = false;
    }
    return mergedAnimated;
  }
  var _excluded$c = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicatorSize"];
  var uuid = 0;
  function Tabs$2(_ref, ref) {
    var _classNames;
    var id = _ref.id, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-tabs" : _ref$prefixCls, className = _ref.className, items = _ref.items, direction = _ref.direction, activeKey = _ref.activeKey, defaultActiveKey = _ref.defaultActiveKey, editable = _ref.editable, animated = _ref.animated, _ref$tabPosition = _ref.tabPosition, tabPosition = _ref$tabPosition === void 0 ? "top" : _ref$tabPosition, tabBarGutter = _ref.tabBarGutter, tabBarStyle = _ref.tabBarStyle, tabBarExtraContent = _ref.tabBarExtraContent, locale2 = _ref.locale, moreIcon = _ref.moreIcon, moreTransitionName = _ref.moreTransitionName, destroyInactiveTabPane = _ref.destroyInactiveTabPane, renderTabBar = _ref.renderTabBar, onChange = _ref.onChange, onTabClick = _ref.onTabClick, onTabScroll = _ref.onTabScroll, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName, indicatorSize = _ref.indicatorSize, restProps = _objectWithoutProperties$8(_ref, _excluded$c);
    var tabs = React__namespace.useMemo(function() {
      return (items || []).filter(function(item) {
        return item && _typeof(item) === "object" && "key" in item;
      });
    }, [items]);
    var rtl = direction === "rtl";
    var mergedAnimated = useAnimateConfig$1(animated);
    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
    React.useEffect(function() {
      setMobile(isMobile());
    }, []);
    var _useMergedState = useMergedState(function() {
      var _tabs$;
      return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
    }, {
      value: activeKey,
      defaultValue: defaultActiveKey
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
    var _useState3 = React.useState(function() {
      return tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey;
      });
    }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
    React.useEffect(function() {
      var newActiveIndex = tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey;
      });
      if (newActiveIndex === -1) {
        var _tabs$newActiveIndex;
        newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
        setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
      }
      setActiveIndex(newActiveIndex);
    }, [tabs.map(function(tab) {
      return tab.key;
    }).join("_"), mergedActiveKey, activeIndex]);
    var _useMergedState3 = useMergedState(null, {
      value: id
    }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
    React.useEffect(function() {
      if (!id) {
        setMergedId("rc-tabs-".concat(uuid));
        uuid += 1;
      }
    }, []);
    function onInternalTabClick(key, e2) {
      onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(key, e2);
      var isActiveChanged = key !== mergedActiveKey;
      setMergedActiveKey(key);
      if (isActiveChanged) {
        onChange === null || onChange === void 0 ? void 0 : onChange(key);
      }
    }
    var sharedProps = {
      id: mergedId,
      activeKey: mergedActiveKey,
      animated: mergedAnimated,
      tabPosition,
      rtl,
      mobile
    };
    var tabNavBarProps = _objectSpread2(_objectSpread2({}, sharedProps), {}, {
      editable,
      locale: locale2,
      moreIcon,
      moreTransitionName,
      tabBarGutter,
      onTabClick: onInternalTabClick,
      onTabScroll,
      extra: tabBarExtraContent,
      style: tabBarStyle,
      panes: null,
      getPopupContainer,
      popupClassName,
      indicatorSize
    });
    return /* @__PURE__ */ React__namespace.createElement(TabContext.Provider, {
      value: {
        tabs,
        prefixCls
      }
    }, /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
      ref,
      id,
      className: classname(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-mobile"), mobile), _defineProperty$1(_classNames, "".concat(prefixCls, "-editable"), editable), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), rtl), _classNames), className)
    }, restProps), /* @__PURE__ */ React__namespace.createElement(TabNavListWrapper, _extends$7({}, tabNavBarProps, {
      renderTabBar
    })), /* @__PURE__ */ React__namespace.createElement(TabPanelList, _extends$7({
      destroyInactiveTabPane
    }, sharedProps, {
      animated: mergedAnimated
    }))));
  }
  var ForwardTabs = /* @__PURE__ */ React__namespace.forwardRef(Tabs$2);
  const motion = {
    motionAppear: false,
    motionEnter: true,
    motionLeave: true
  };
  function useAnimateConfig(prefixCls) {
    let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      inkBar: true,
      tabPane: false
    };
    let mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: true
      };
    } else {
      mergedAnimated = Object.assign({
        inkBar: true
      }, typeof animated === "object" ? animated : {});
    }
    if (mergedAnimated.tabPane) {
      mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
        motionName: getTransitionName(prefixCls, "switch")
      });
    }
    return mergedAnimated;
  }
  var __rest$e = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function filter(items) {
    return items.filter((item) => item);
  }
  function useLegacyItems(items, children) {
    if (items) {
      return items;
    }
    const childrenItems = toArray$3(children).map((node2) => {
      if (/* @__PURE__ */ React__namespace.isValidElement(node2)) {
        const {
          key,
          props
        } = node2;
        const _a = props || {}, {
          tab
        } = _a, restProps = __rest$e(_a, ["tab"]);
        const item = Object.assign(Object.assign({
          key: String(key)
        }, restProps), {
          label: tab
        });
        return item;
      }
      return null;
    });
    return filter(childrenItems);
  }
  const genMotionStyle$2 = (token2) => {
    const {
      componentCls,
      motionDurationSlow
    } = token2;
    return [
      {
        [componentCls]: {
          [`${componentCls}-switch`]: {
            "&-appear, &-enter": {
              transition: "none",
              "&-start": {
                opacity: 0
              },
              "&-active": {
                opacity: 1,
                transition: `opacity ${motionDurationSlow}`
              }
            },
            "&-leave": {
              position: "absolute",
              transition: "none",
              inset: 0,
              "&-start": {
                opacity: 1
              },
              "&-active": {
                opacity: 0,
                transition: `opacity ${motionDurationSlow}`
              }
            }
          }
        }
      },
      // Follow code may reuse in other components
      [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
    ];
  };
  const genMotionStyle$3 = genMotionStyle$2;
  const genCardStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardBg,
      cardGutter,
      colorBorderSecondary,
      itemSelectedColor
    } = token2;
    return {
      [`${componentCls}-card`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: 0,
            padding: tabsCardPadding,
            background: cardBg,
            border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          },
          [`${componentCls}-tab-active`]: {
            color: itemSelectedColor,
            background: token2.colorBgContainer
          },
          [`${componentCls}-ink-bar`]: {
            visibility: "hidden"
          }
        },
        // ========================== Top & Bottom ==========================
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginLeft: {
                _skip_check_: true,
                value: `${cardGutter}px`
              }
            }
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
            },
            [`${componentCls}-tab-active`]: {
              borderBottomColor: token2.colorBgContainer
            }
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
            },
            [`${componentCls}-tab-active`]: {
              borderTopColor: token2.colorBgContainer
            }
          }
        },
        // ========================== Left & Right ==========================
        [`&${componentCls}-left, &${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginTop: `${cardGutter}px`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${token2.borderRadiusLG}px 0 0 ${token2.borderRadiusLG}px`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderRightColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderLeftColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        }
      }
    };
  };
  const genDropdownStyle = (token2) => {
    const {
      componentCls,
      itemHoverColor,
      dropdownEdgeChildVerticalPadding
    } = token2;
    return {
      [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: token2.zIndexPopup,
        display: "block",
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token2.tabsDropdownHeight,
          margin: 0,
          padding: `${dropdownEdgeChildVerticalPadding}px 0`,
          overflowX: "hidden",
          overflowY: "auto",
          textAlign: {
            _skip_check_: true,
            value: "left"
          },
          listStyleType: "none",
          backgroundColor: token2.colorBgContainer,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          "&-item": Object.assign(Object.assign({}, textEllipsis), {
            display: "flex",
            alignItems: "center",
            minWidth: token2.tabsDropdownWidth,
            margin: 0,
            padding: `${token2.paddingXXS}px ${token2.paddingSM}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "> span": {
              flex: 1,
              whiteSpace: "nowrap"
            },
            "&-remove": {
              flex: "none",
              marginLeft: {
                _skip_check_: true,
                value: token2.marginSM
              },
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeSM,
              background: "transparent",
              border: 0,
              cursor: "pointer",
              "&:hover": {
                color: itemHoverColor
              }
            },
            "&:hover": {
              background: token2.controlItemBgHover
            },
            "&-disabled": {
              "&, &:hover": {
                color: token2.colorTextDisabled,
                background: "transparent",
                cursor: "not-allowed"
              }
            }
          })
        }
      })
    };
  };
  const genPositionStyle = (token2) => {
    const {
      componentCls,
      margin,
      colorBorderSecondary,
      horizontalMargin,
      verticalItemPadding,
      verticalItemMargin
    } = token2;
    return {
      // ========================== Top & Bottom ==========================
      [`${componentCls}-top, ${componentCls}-bottom`]: {
        flexDirection: "column",
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          margin: horizontalMargin,
          "&::before": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            borderBottom: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
            content: "''"
          },
          [`${componentCls}-ink-bar`]: {
            height: token2.lineWidthBold,
            "&-animated": {
              transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
            }
          },
          [`${componentCls}-nav-wrap`]: {
            "&::before, &::after": {
              top: 0,
              bottom: 0,
              width: token2.controlHeight
            },
            "&::before": {
              left: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowLeft
            },
            "&::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowRight
            },
            [`&${componentCls}-nav-wrap-ping-left::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-right::after`]: {
              opacity: 1
            }
          }
        }
      },
      [`${componentCls}-top`]: {
        [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
          "&::before": {
            bottom: 0
          },
          [`${componentCls}-ink-bar`]: {
            bottom: 0
          }
        }
      },
      [`${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          marginTop: `${margin}px`,
          marginBottom: 0,
          "&::before": {
            top: 0
          },
          [`${componentCls}-ink-bar`]: {
            top: 0
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      // ========================== Left & Right ==========================
      [`${componentCls}-left, ${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          flexDirection: "column",
          minWidth: token2.controlHeight * 1.25,
          // >>>>>>>>>>> Tab
          [`${componentCls}-tab`]: {
            padding: verticalItemPadding,
            textAlign: "center"
          },
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            margin: verticalItemMargin
          },
          // >>>>>>>>>>> Nav
          [`${componentCls}-nav-wrap`]: {
            flexDirection: "column",
            "&::before, &::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.controlHeight
            },
            "&::before": {
              top: 0,
              boxShadow: token2.boxShadowTabsOverflowTop
            },
            "&::after": {
              bottom: 0,
              boxShadow: token2.boxShadowTabsOverflowBottom
            },
            [`&${componentCls}-nav-wrap-ping-top::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
              opacity: 1
            }
          },
          // >>>>>>>>>>> Ink Bar
          [`${componentCls}-ink-bar`]: {
            width: token2.lineWidthBold,
            "&-animated": {
              transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
            }
          },
          [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
            flex: "1 0 auto",
            flexDirection: "column"
          }
        }
      },
      [`${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-ink-bar`]: {
            right: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          marginLeft: {
            _skip_check_: true,
            value: `-${token2.lineWidth}px`
          },
          borderLeft: {
            _skip_check_: true,
            value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingLeft: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      },
      [`${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          [`${componentCls}-ink-bar`]: {
            left: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0,
          marginRight: {
            _skip_check_: true,
            value: -token2.lineWidth
          },
          borderRight: {
            _skip_check_: true,
            value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingRight: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      }
    };
  };
  const genSizeStyle = (token2) => {
    const {
      componentCls,
      cardPaddingSM,
      cardPaddingLG,
      horizontalItemPaddingSM,
      horizontalItemPaddingLG
    } = token2;
    return {
      [componentCls]: {
        "&-small": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingSM,
              fontSize: token2.titleFontSizeSM
            }
          }
        },
        "&-large": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingLG,
              fontSize: token2.titleFontSizeLG
            }
          }
        }
      },
      [`${componentCls}-card`]: {
        [`&${componentCls}-small`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingSM
            }
          },
          [`&${componentCls}-bottom`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `0 0 ${token2.borderRadius}px ${token2.borderRadius}px`
            }
          },
          [`&${componentCls}-top`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `${token2.borderRadius}px ${token2.borderRadius}px 0 0`
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${token2.borderRadius}px ${token2.borderRadius}px 0`
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${token2.borderRadius}px 0 0 ${token2.borderRadius}px`
              }
            }
          }
        },
        [`&${componentCls}-large`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingLG
            }
          }
        }
      }
    };
  };
  const genTabStyle = (token2) => {
    const {
      componentCls,
      itemActiveColor,
      itemHoverColor,
      iconCls,
      tabsHorizontalItemMargin,
      horizontalItemPadding,
      itemSelectedColor,
      itemColor
    } = token2;
    const tabCls = `${componentCls}-tab`;
    return {
      [tabCls]: {
        position: "relative",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        display: "inline-flex",
        alignItems: "center",
        padding: horizontalItemPadding,
        fontSize: token2.titleFontSize,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        color: itemColor,
        "&-btn, &-remove": Object.assign({
          "&:focus:not(:focus-visible), &:active": {
            color: itemActiveColor
          }
        }, genFocusStyle(token2)),
        "&-btn": {
          outline: "none",
          transition: "all 0.3s"
        },
        "&-remove": {
          flex: "none",
          marginRight: {
            _skip_check_: true,
            value: -token2.marginXXS
          },
          marginLeft: {
            _skip_check_: true,
            value: token2.marginXS
          },
          color: token2.colorTextDescription,
          fontSize: token2.fontSizeSM,
          background: "transparent",
          border: "none",
          outline: "none",
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextHeading
          }
        },
        "&:hover": {
          color: itemHoverColor
        },
        [`&${tabCls}-active ${tabCls}-btn`]: {
          color: itemSelectedColor,
          textShadow: token2.tabsActiveTextShadow
        },
        [`&${tabCls}-disabled`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
          "&:focus, &:active": {
            color: token2.colorTextDisabled
          }
        },
        [`& ${tabCls}-remove ${iconCls}`]: {
          margin: 0
        },
        [iconCls]: {
          marginRight: {
            _skip_check_: true,
            value: token2.marginSM
          }
        }
      },
      [`${tabCls} + ${tabCls}`]: {
        margin: {
          _skip_check_: true,
          value: tabsHorizontalItemMargin
        }
      }
    };
  };
  const genRtlStyle = (token2) => {
    const {
      componentCls,
      tabsHorizontalItemMarginRTL,
      iconCls,
      cardGutter
    } = token2;
    const rtlCls = `${componentCls}-rtl`;
    return {
      [rtlCls]: {
        direction: "rtl",
        [`${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: {
              _skip_check_: true,
              value: tabsHorizontalItemMarginRTL
            },
            [`${componentCls}-tab:last-of-type`]: {
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            },
            [iconCls]: {
              marginRight: {
                _skip_check_: true,
                value: 0
              },
              marginLeft: {
                _skip_check_: true,
                value: `${token2.marginSM}px`
              }
            },
            [`${componentCls}-tab-remove`]: {
              marginRight: {
                _skip_check_: true,
                value: `${token2.marginXS}px`
              },
              marginLeft: {
                _skip_check_: true,
                value: `-${token2.marginXXS}px`
              },
              [iconCls]: {
                margin: 0
              }
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav`]: {
            order: 1
          },
          [`> ${componentCls}-content-holder`]: {
            order: 0
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav`]: {
            order: 0
          },
          [`> ${componentCls}-content-holder`]: {
            order: 1
          }
        },
        // ====================== Card ======================
        [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginRight: {
                _skip_check_: true,
                value: cardGutter
              },
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            }
          }
        }
      },
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-menu-item`]: {
        [`${componentCls}-dropdown-rtl`]: {
          textAlign: {
            _skip_check_: true,
            value: "right"
          }
        }
      }
    };
  };
  const genTabsStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardHeight,
      cardGutter,
      itemHoverColor,
      itemActiveColor,
      colorBorderSecondary
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "flex",
        // ========================== Navigation ==========================
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          position: "relative",
          display: "flex",
          flex: "none",
          alignItems: "center",
          [`${componentCls}-nav-wrap`]: {
            position: "relative",
            display: "flex",
            flex: "auto",
            alignSelf: "stretch",
            overflow: "hidden",
            whiteSpace: "nowrap",
            transform: "translate(0)",
            // >>>>> Ping shadow
            "&::before, &::after": {
              position: "absolute",
              zIndex: 1,
              opacity: 0,
              transition: `opacity ${token2.motionDurationSlow}`,
              content: "''",
              pointerEvents: "none"
            }
          },
          [`${componentCls}-nav-list`]: {
            position: "relative",
            display: "flex",
            transition: `opacity ${token2.motionDurationSlow}`
          },
          // >>>>>>>> Operations
          [`${componentCls}-nav-operations`]: {
            display: "flex",
            alignSelf: "stretch"
          },
          [`${componentCls}-nav-operations-hidden`]: {
            position: "absolute",
            visibility: "hidden",
            pointerEvents: "none"
          },
          [`${componentCls}-nav-more`]: {
            position: "relative",
            padding: tabsCardPadding,
            background: "transparent",
            border: 0,
            color: token2.colorText,
            "&::after": {
              position: "absolute",
              right: {
                _skip_check_: true,
                value: 0
              },
              bottom: 0,
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.controlHeightLG / 8,
              transform: "translateY(100%)",
              content: "''"
            }
          },
          [`${componentCls}-nav-add`]: Object.assign({
            minWidth: cardHeight,
            marginLeft: {
              _skip_check_: true,
              value: cardGutter
            },
            padding: `0 ${token2.paddingXS}px`,
            background: "transparent",
            border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
            outline: "none",
            cursor: "pointer",
            color: token2.colorText,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
            "&:hover": {
              color: itemHoverColor
            },
            "&:active, &:focus:not(:focus-visible)": {
              color: itemActiveColor
            }
          }, genFocusStyle(token2))
        },
        [`${componentCls}-extra-content`]: {
          flex: "none"
        },
        // ============================ InkBar ============================
        [`${componentCls}-ink-bar`]: {
          position: "absolute",
          background: token2.inkBarColor,
          pointerEvents: "none"
        }
      }), genTabStyle(token2)), {
        // =========================== TabPanes ===========================
        [`${componentCls}-content`]: {
          position: "relative",
          width: "100%"
        },
        [`${componentCls}-content-holder`]: {
          flex: "auto",
          minWidth: 0,
          minHeight: 0
        },
        [`${componentCls}-tabpane`]: {
          outline: "none",
          "&-hidden": {
            display: "none"
          }
        }
      }),
      [`${componentCls}-centered`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-nav-wrap`]: {
            [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
              justifyContent: "center"
            }
          }
        }
      }
    };
  };
  const useStyle$5 = genComponentStyleHook("Tabs", (token2) => {
    const tabsToken = merge(token2, {
      // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
      tabsCardPadding: token2.cardPadding || `${(token2.cardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
      dropdownEdgeChildVerticalPadding: token2.paddingXXS,
      tabsActiveTextShadow: "0 0 0.25px currentcolor",
      tabsDropdownHeight: 200,
      tabsDropdownWidth: 120,
      tabsHorizontalItemMargin: `0 0 0 ${token2.horizontalItemGutter}px`,
      tabsHorizontalItemMarginRTL: `0 0 0 ${token2.horizontalItemGutter}px`
    });
    return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), genMotionStyle$3(tabsToken)];
  }, (token2) => {
    const cardHeight = token2.controlHeightLG;
    return {
      zIndexPopup: token2.zIndexPopupBase + 50,
      cardBg: token2.colorFillAlter,
      cardHeight,
      // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
      cardPadding: ``,
      cardPaddingSM: `${token2.paddingXXS * 1.5}px ${token2.padding}px`,
      cardPaddingLG: `${token2.paddingXS}px ${token2.padding}px ${token2.paddingXXS * 1.5}px`,
      titleFontSize: token2.fontSize,
      titleFontSizeLG: token2.fontSizeLG,
      titleFontSizeSM: token2.fontSize,
      inkBarColor: token2.colorPrimary,
      horizontalMargin: `0 0 ${token2.margin}px 0`,
      horizontalItemGutter: 32,
      // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
      horizontalItemMargin: ``,
      horizontalItemMarginRTL: ``,
      horizontalItemPadding: `${token2.paddingSM}px 0`,
      horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
      horizontalItemPaddingLG: `${token2.padding}px 0`,
      verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
      verticalItemMargin: `${token2.margin}px 0 0 0`,
      itemColor: token2.colorText,
      itemSelectedColor: token2.colorPrimary,
      itemHoverColor: token2.colorPrimaryHover,
      itemActiveColor: token2.colorPrimaryActive,
      cardGutter: token2.marginXXS / 2
    };
  });
  const TabPane = () => null;
  const TabPane$1 = TabPane;
  var __rest$d = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const Tabs = (props) => {
    const {
      type: type4,
      className,
      rootClassName,
      size: customSize,
      onEdit,
      hideAdd,
      centered,
      addIcon,
      popupClassName,
      children,
      items,
      animated,
      style: style2,
      indicatorSize
    } = props, otherProps = __rest$d(props, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "popupClassName", "children", "items", "animated", "style", "indicatorSize"]);
    const {
      prefixCls: customizePrefixCls,
      moreIcon = /* @__PURE__ */ React__namespace.createElement(EllipsisOutlined$1, null)
    } = otherProps;
    const {
      direction,
      tabs,
      getPrefixCls,
      getPopupContainer
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tabs", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$5(prefixCls);
    let editable;
    if (type4 === "editable-card") {
      editable = {
        onEdit: (editType, _ref) => {
          let {
            key,
            event
          } = _ref;
          onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
        },
        removeIcon: /* @__PURE__ */ React__namespace.createElement(CloseOutlined$1, null),
        addIcon: addIcon || /* @__PURE__ */ React__namespace.createElement(PlusOutlined$1, null),
        showAdd: hideAdd !== true
      };
    }
    const rootPrefixCls = getPrefixCls();
    const mergedItems = useLegacyItems(items, children);
    const mergedAnimated = useAnimateConfig(prefixCls, animated);
    const size = useSize$1(customSize);
    const mergedStyle = Object.assign(Object.assign({}, tabs === null || tabs === void 0 ? void 0 : tabs.style), style2);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(ForwardTabs, Object.assign({
      direction,
      getPopupContainer,
      moreTransitionName: `${rootPrefixCls}-slide-up`
    }, otherProps, {
      items: mergedItems,
      className: classname({
        [`${prefixCls}-${size}`]: size,
        [`${prefixCls}-card`]: ["card", "editable-card"].includes(type4),
        [`${prefixCls}-editable-card`]: type4 === "editable-card",
        [`${prefixCls}-centered`]: centered
      }, tabs === null || tabs === void 0 ? void 0 : tabs.className, className, rootClassName, hashId),
      popupClassName: classname(popupClassName, hashId),
      style: mergedStyle,
      editable,
      moreIcon,
      prefixCls,
      animated: mergedAnimated,
      indicatorSize: indicatorSize !== null && indicatorSize !== void 0 ? indicatorSize : tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize
    })));
  };
  Tabs.TabPane = TabPane$1;
  const Tabs$1 = Tabs;
  function throttle(delay, callback, options) {
    var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel(options2) {
      var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
      clearExistingTimeout();
      cancelled = !upcomingOnly;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear() {
        timeoutID = void 0;
      }
      if (!noLeading && debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay) {
        if (noLeading) {
          lastExec = Date.now();
          if (!noTrailing) {
            timeoutID = setTimeout(debounceMode ? clear : exec, delay);
          }
        } else {
          exec();
        }
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce(delay, callback, options) {
    var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
    return throttle(delay, callback, {
      debounceMode: atBegin !== false
    });
  }
  var UpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
  const UpOutlinedSvg = UpOutlined$2;
  var UpOutlined = function UpOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: UpOutlinedSvg
    }));
  };
  const UpOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(UpOutlined);
  function supportBigInt() {
    return typeof BigInt === "function";
  }
  function isEmpty$1(value) {
    return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
  }
  function trimNumber(numStr) {
    var str = numStr.trim();
    var negative = str.startsWith("-");
    if (negative) {
      str = str.slice(1);
    }
    str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
    if (str.startsWith(".")) {
      str = "0".concat(str);
    }
    var trimStr = str || "0";
    var splitNumber = trimStr.split(".");
    var integerStr = splitNumber[0] || "0";
    var decimalStr = splitNumber[1] || "0";
    if (integerStr === "0" && decimalStr === "0") {
      negative = false;
    }
    var negativeStr = negative ? "-" : "";
    return {
      negative,
      negativeStr,
      trimStr,
      integerStr,
      decimalStr,
      fullStr: "".concat(negativeStr).concat(trimStr)
    };
  }
  function isE(number4) {
    var str = String(number4);
    return !Number.isNaN(Number(str)) && str.includes("e");
  }
  function getNumberPrecision(number4) {
    var numStr = String(number4);
    if (isE(number4)) {
      var precision2 = Number(numStr.slice(numStr.indexOf("e-") + 2));
      var decimalMatch = numStr.match(/\.(\d+)/);
      if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
        precision2 += decimalMatch[1].length;
      }
      return precision2;
    }
    return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
  }
  function num2str(number4) {
    var numStr = String(number4);
    if (isE(number4)) {
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
      }
      numStr = number4.toFixed(getNumberPrecision(numStr));
    }
    return trimNumber(numStr).fullStr;
  }
  function validateNumber(num) {
    if (typeof num === "number") {
      return !Number.isNaN(num);
    }
    if (!num) {
      return false;
    }
    return (
      // Normal type: 11.28
      /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
      /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
      /^\s*-?\.\d+\s*$/.test(num)
    );
  }
  var BigIntDecimal = /* @__PURE__ */ function() {
    function BigIntDecimal2(value) {
      _classCallCheck(this, BigIntDecimal2);
      _defineProperty$1(this, "origin", "");
      _defineProperty$1(this, "negative", void 0);
      _defineProperty$1(this, "integer", void 0);
      _defineProperty$1(this, "decimal", void 0);
      _defineProperty$1(this, "decimalLen", void 0);
      _defineProperty$1(this, "empty", void 0);
      _defineProperty$1(this, "nan", void 0);
      if (isEmpty$1(value)) {
        this.empty = true;
        return;
      }
      this.origin = String(value);
      if (value === "-" || Number.isNaN(value)) {
        this.nan = true;
        return;
      }
      var mergedValue = value;
      if (isE(mergedValue)) {
        mergedValue = Number(mergedValue);
      }
      mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
      if (validateNumber(mergedValue)) {
        var trimRet = trimNumber(mergedValue);
        this.negative = trimRet.negative;
        var numbers = trimRet.trimStr.split(".");
        this.integer = BigInt(numbers[0]);
        var decimalStr = numbers[1] || "0";
        this.decimal = BigInt(decimalStr);
        this.decimalLen = decimalStr.length;
      } else {
        this.nan = true;
      }
    }
    _createClass(BigIntDecimal2, [{
      key: "getMark",
      value: function getMark2() {
        return this.negative ? "-" : "";
      }
    }, {
      key: "getIntegerStr",
      value: function getIntegerStr() {
        return this.integer.toString();
      }
      /**
       * @private get decimal string
       */
    }, {
      key: "getDecimalStr",
      value: function getDecimalStr() {
        return this.decimal.toString().padStart(this.decimalLen, "0");
      }
      /**
       * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
       * This is used for add function only.
       */
    }, {
      key: "alignDecimal",
      value: function alignDecimal(decimalLength) {
        var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
        return BigInt(str);
      }
    }, {
      key: "negate",
      value: function negate() {
        var clone = new BigIntDecimal2(this.toString());
        clone.negative = !clone.negative;
        return clone;
      }
    }, {
      key: "cal",
      value: function cal(offset, calculator, calDecimalLen) {
        var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);
        var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
        var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
        var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
        var nextDecimalLength = calDecimalLen(maxDecimalLength);
        var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
        var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
        return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
      }
    }, {
      key: "add",
      value: function add(value) {
        if (this.isInvalidate()) {
          return new BigIntDecimal2(value);
        }
        var offset = new BigIntDecimal2(value);
        if (offset.isInvalidate()) {
          return this;
        }
        return this.cal(offset, function(num1, num2) {
          return num1 + num2;
        }, function(len) {
          return len;
        });
      }
    }, {
      key: "multi",
      value: function multi(value) {
        var target = new BigIntDecimal2(value);
        if (this.isInvalidate() || target.isInvalidate()) {
          return new BigIntDecimal2(NaN);
        }
        return this.cal(target, function(num1, num2) {
          return num1 * num2;
        }, function(len) {
          return len * 2;
        });
      }
    }, {
      key: "isEmpty",
      value: function isEmpty3() {
        return this.empty;
      }
    }, {
      key: "isNaN",
      value: function isNaN2() {
        return this.nan;
      }
    }, {
      key: "isInvalidate",
      value: function isInvalidate() {
        return this.isEmpty() || this.isNaN();
      }
    }, {
      key: "equals",
      value: function equals(target) {
        return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
      }
    }, {
      key: "lessEquals",
      value: function lessEquals(target) {
        return this.add(target.negate().toString()).toNumber() <= 0;
      }
    }, {
      key: "toNumber",
      value: function toNumber() {
        if (this.isNaN()) {
          return NaN;
        }
        return Number(this.toString());
      }
    }, {
      key: "toString",
      value: function toString() {
        var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (!safe) {
          return this.origin;
        }
        if (this.isInvalidate()) {
          return "";
        }
        return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
      }
    }]);
    return BigIntDecimal2;
  }();
  var NumberDecimal = /* @__PURE__ */ function() {
    function NumberDecimal2(value) {
      _classCallCheck(this, NumberDecimal2);
      _defineProperty$1(this, "origin", "");
      _defineProperty$1(this, "number", void 0);
      _defineProperty$1(this, "empty", void 0);
      if (isEmpty$1(value)) {
        this.empty = true;
        return;
      }
      this.origin = String(value);
      this.number = Number(value);
    }
    _createClass(NumberDecimal2, [{
      key: "negate",
      value: function negate() {
        return new NumberDecimal2(-this.toNumber());
      }
    }, {
      key: "add",
      value: function add(value) {
        if (this.isInvalidate()) {
          return new NumberDecimal2(value);
        }
        var target = Number(value);
        if (Number.isNaN(target)) {
          return this;
        }
        var number4 = this.number + target;
        if (number4 > Number.MAX_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
        }
        if (number4 < Number.MIN_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
        }
        var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
        return new NumberDecimal2(number4.toFixed(maxPrecision));
      }
    }, {
      key: "multi",
      value: function multi(value) {
        var target = Number(value);
        if (this.isInvalidate() || Number.isNaN(target)) {
          return new NumberDecimal2(NaN);
        }
        var number4 = this.number * target;
        if (number4 > Number.MAX_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
        }
        if (number4 < Number.MIN_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
        }
        var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
        return new NumberDecimal2(number4.toFixed(maxPrecision));
      }
    }, {
      key: "isEmpty",
      value: function isEmpty3() {
        return this.empty;
      }
    }, {
      key: "isNaN",
      value: function isNaN2() {
        return Number.isNaN(this.number);
      }
    }, {
      key: "isInvalidate",
      value: function isInvalidate() {
        return this.isEmpty() || this.isNaN();
      }
    }, {
      key: "equals",
      value: function equals(target) {
        return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
      }
    }, {
      key: "lessEquals",
      value: function lessEquals(target) {
        return this.add(target.negate().toString()).toNumber() <= 0;
      }
    }, {
      key: "toNumber",
      value: function toNumber() {
        return this.number;
      }
    }, {
      key: "toString",
      value: function toString() {
        var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (!safe) {
          return this.origin;
        }
        if (this.isInvalidate()) {
          return "";
        }
        return num2str(this.number);
      }
    }]);
    return NumberDecimal2;
  }();
  function getMiniDecimal(value) {
    if (supportBigInt()) {
      return new BigIntDecimal(value);
    }
    return new NumberDecimal(value);
  }
  function toFixed(numStr, separatorStr, precision2) {
    var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (numStr === "") {
      return "";
    }
    var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
    var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
    var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
    if (precision2 >= 0) {
      var advancedNum = Number(decimalStr[precision2]);
      if (advancedNum >= 5 && !cutOnly) {
        var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision2)).concat(10 - advancedNum));
        return toFixed(advancedDecimal.toString(), separatorStr, precision2, cutOnly);
      }
      if (precision2 === 0) {
        return numberWithoutDecimal;
      }
      return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision2, "0").slice(0, precision2));
    }
    if (precisionDecimalStr === ".0") {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
  }
  function hasAddon(props) {
    return !!(props.addonBefore || props.addonAfter);
  }
  function hasPrefixSuffix$1(props) {
    return !!(props.prefix || props.suffix || props.allowClear);
  }
  function resolveOnChange(target, e2, onChange, targetValue) {
    if (!onChange) {
      return;
    }
    var event = e2;
    if (e2.type === "click") {
      var currentTarget = target.cloneNode(true);
      event = Object.create(e2, {
        target: {
          value: currentTarget
        },
        currentTarget: {
          value: currentTarget
        }
      });
      currentTarget.value = "";
      onChange(event);
      return;
    }
    if (targetValue !== void 0) {
      event = Object.create(e2, {
        target: {
          value: target
        },
        currentTarget: {
          value: target
        }
      });
      target.value = targetValue;
      onChange(event);
      return;
    }
    onChange(event);
  }
  function triggerFocus$1(element, option) {
    if (!element)
      return;
    element.focus(option);
    var _ref = option || {}, cursor = _ref.cursor;
    if (cursor) {
      var len = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
      }
    }
  }
  function fixControlledValue(value) {
    if (typeof value === "undefined" || value === null) {
      return "";
    }
    return String(value);
  }
  var BaseInput = function BaseInput2(props) {
    var _inputElement$props, _inputElement$props2;
    var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames = props.classNames, dataAttrs = props.dataAttrs, styles2 = props.styles, components = props.components;
    var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || "span";
    var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || "span";
    var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || "span";
    var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || "span";
    var containerRef = React.useRef(null);
    var onInputClick = function onInputClick2(e2) {
      var _containerRef$current;
      if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
        triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
      }
    };
    var getClearIcon = function getClearIcon2() {
      var _clsx;
      if (!allowClear) {
        return null;
      }
      var needClear = !disabled && !readOnly && value;
      var clearIconCls = "".concat(prefixCls, "-clear-icon");
      var iconNode = _typeof(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "✖";
      return /* @__PURE__ */ React.createElement("span", {
        onClick: handleReset,
        onMouseDown: function onMouseDown(e2) {
          return e2.preventDefault();
        },
        className: classname(clearIconCls, (_clsx = {}, _defineProperty$1(_clsx, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$1(_clsx, "".concat(clearIconCls, "-has-suffix"), !!suffix), _clsx)),
        role: "button",
        tabIndex: -1
      }, iconNode);
    };
    var element = /* @__PURE__ */ React.cloneElement(inputElement, {
      value,
      hidden,
      className: classname((_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.className, !hasPrefixSuffix$1(props) && !hasAddon(props) && className) || null,
      style: _objectSpread2(_objectSpread2({}, (_inputElement$props2 = inputElement.props) === null || _inputElement$props2 === void 0 ? void 0 : _inputElement$props2.style), !hasPrefixSuffix$1(props) && !hasAddon(props) ? style2 : {})
    });
    if (hasPrefixSuffix$1(props)) {
      var _clsx2;
      var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
      var affixWrapperCls = classname(affixWrapperPrefixCls, (_clsx2 = {}, _defineProperty$1(_clsx2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$1(_clsx2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$1(_clsx2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$1(_clsx2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _clsx2), !hasAddon(props) && className, classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames === null || classNames === void 0 ? void 0 : classNames.affixWrapper);
      var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React.createElement("span", {
        className: classname("".concat(prefixCls, "-suffix"), classNames === null || classNames === void 0 ? void 0 : classNames.suffix),
        style: styles2 === null || styles2 === void 0 ? void 0 : styles2.suffix
      }, getClearIcon(), suffix);
      element = /* @__PURE__ */ React.createElement(AffixWrapperComponent, _extends$7({
        className: affixWrapperCls,
        style: _objectSpread2(_objectSpread2({}, !hasAddon(props) ? style2 : void 0), styles2 === null || styles2 === void 0 ? void 0 : styles2.affixWrapper),
        hidden: !hasAddon(props) && hidden,
        onClick: onInputClick
      }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
        ref: containerRef
      }), prefix && /* @__PURE__ */ React.createElement("span", {
        className: classname("".concat(prefixCls, "-prefix"), classNames === null || classNames === void 0 ? void 0 : classNames.prefix),
        style: styles2 === null || styles2 === void 0 ? void 0 : styles2.prefix
      }, prefix), /* @__PURE__ */ React.cloneElement(inputElement, {
        value,
        hidden: null
      }), suffixNode);
    }
    if (hasAddon(props)) {
      var wrapperCls = "".concat(prefixCls, "-group");
      var addonCls = "".concat(wrapperCls, "-addon");
      var mergedWrapperClassName = classname("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper);
      var mergedGroupClassName = classname("".concat(prefixCls, "-group-wrapper"), className, classes === null || classes === void 0 ? void 0 : classes.group);
      return /* @__PURE__ */ React.createElement(GroupWrapperComponent, {
        className: mergedGroupClassName,
        style: style2,
        hidden
      }, /* @__PURE__ */ React.createElement(WrapperComponent, {
        className: mergedWrapperClassName
      }, addonBefore && /* @__PURE__ */ React.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonBefore), /* @__PURE__ */ React.cloneElement(element, {
        hidden: null
      }), addonAfter && /* @__PURE__ */ React.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonAfter)));
    }
    return element;
  };
  var _excluded$b = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "classes", "classNames", "styles"];
  var Input$4 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames = props.classNames, styles2 = props.styles, rest = _objectWithoutProperties$8(props, _excluded$b);
    var _useMergedState = useMergedState(props.defaultValue, {
      value: props.value
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
    var inputRef = React.useRef(null);
    var focus = function focus2(option) {
      if (inputRef.current) {
        triggerFocus$1(inputRef.current, option);
      }
    };
    React.useImperativeHandle(ref, function() {
      return {
        focus,
        blur: function blur() {
          var _inputRef$current;
          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
        },
        setSelectionRange: function setSelectionRange(start, end, direction) {
          var _inputRef$current2;
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
        },
        select: function select() {
          var _inputRef$current3;
          (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
        },
        input: inputRef.current
      };
    });
    React.useEffect(function() {
      setFocused(function(prev2) {
        return prev2 && disabled ? false : prev2;
      });
    }, [disabled]);
    var handleChange = function handleChange2(e2) {
      if (props.value === void 0) {
        setValue(e2.target.value);
      }
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e2, onChange);
      }
    };
    var handleKeyDown = function handleKeyDown2(e2) {
      if (onPressEnter && e2.key === "Enter") {
        onPressEnter(e2);
      }
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
    };
    var handleFocus = function handleFocus2(e2) {
      setFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
    };
    var handleBlur = function handleBlur2(e2) {
      setFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
    };
    var handleReset = function handleReset2(e2) {
      setValue("");
      focus();
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e2, onChange);
      }
    };
    var getInputElement = function getInputElement2() {
      var otherProps = omit(props, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "showCount",
        "classes",
        "htmlSize",
        "styles",
        "classNames"
      ]);
      return /* @__PURE__ */ React.createElement("input", _extends$7({
        autoComplete
      }, otherProps, {
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        className: classname(prefixCls, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled), classNames === null || classNames === void 0 ? void 0 : classNames.input),
        style: styles2 === null || styles2 === void 0 ? void 0 : styles2.input,
        ref: inputRef,
        size: htmlSize,
        type: type4
      }));
    };
    var getSuffix = function getSuffix2() {
      var hasMaxLength = Number(maxLength) > 0;
      if (suffix || showCount) {
        var val = fixControlledValue(value);
        var valueLength = _toConsumableArray(val).length;
        var dataCount = _typeof(showCount) === "object" ? showCount.formatter({
          value: val,
          count: valueLength,
          maxLength
        }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
        return /* @__PURE__ */ React.createElement(React.Fragment, null, !!showCount && /* @__PURE__ */ React.createElement("span", {
          className: classname("".concat(prefixCls, "-show-count-suffix"), _defineProperty$1({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames === null || classNames === void 0 ? void 0 : classNames.count),
          style: _objectSpread2({}, styles2 === null || styles2 === void 0 ? void 0 : styles2.count)
        }, dataCount), suffix);
      }
      return null;
    };
    return /* @__PURE__ */ React.createElement(BaseInput, _extends$7({}, rest, {
      prefixCls,
      className,
      inputElement: getInputElement(),
      handleReset,
      value: fixControlledValue(value),
      focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled,
      classes,
      classNames,
      styles: styles2
    }));
  });
  function useCursor(input, focused) {
    var selectionRef = React.useRef(null);
    function recordCursor() {
      try {
        var start = input.selectionStart, end = input.selectionEnd, value = input.value;
        var beforeTxt = value.substring(0, start);
        var afterTxt = value.substring(end);
        selectionRef.current = {
          start,
          end,
          value,
          beforeTxt,
          afterTxt
        };
      } catch (e2) {
      }
    }
    function restoreCursor() {
      if (input && selectionRef.current && focused) {
        try {
          var value = input.value;
          var _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start = _selectionRef$current.start;
          var startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - selectionRef.current.afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            var beforeLastChar = beforeTxt[start - 1];
            var newIndex = value.indexOf(beforeLastChar, start - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.setSelectionRange(startPos, startPos);
        } catch (e2) {
          warningOnce(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
        }
      }
    }
    return [recordCursor, restoreCursor];
  }
  var useMobile = function useMobile2() {
    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
    useLayoutEffect$1(function() {
      setMobile(isMobile());
    }, []);
    return mobile;
  };
  var STEP_INTERVAL = 200;
  var STEP_DELAY = 600;
  function StepHandler(_ref) {
    var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep;
    var stepTimeoutRef = React__namespace.useRef();
    var frameIds = React__namespace.useRef([]);
    var onStepRef = React__namespace.useRef();
    onStepRef.current = onStep;
    var onStopStep = function onStopStep2() {
      clearTimeout(stepTimeoutRef.current);
    };
    var onStepMouseDown = function onStepMouseDown2(e2, up) {
      e2.preventDefault();
      onStopStep();
      onStepRef.current(up);
      function loopStep() {
        onStepRef.current(up);
        stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
    };
    React__namespace.useEffect(function() {
      return function() {
        onStopStep();
        frameIds.current.forEach(function(id) {
          return wrapperRaf.cancel(id);
        });
      };
    }, []);
    var isMobile2 = useMobile();
    if (isMobile2) {
      return null;
    }
    var handlerClassName = "".concat(prefixCls, "-handler");
    var upClassName = classname(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$1({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
    var downClassName = classname(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$1({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
    var safeOnStopStep = function safeOnStopStep2() {
      return frameIds.current.push(wrapperRaf(onStopStep));
    };
    var sharedHandlerProps = {
      unselectable: "on",
      role: "button",
      onMouseUp: safeOnStopStep,
      onMouseLeave: safeOnStopStep
    };
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(handlerClassName, "-wrap")
    }, /* @__PURE__ */ React__namespace.createElement("span", _extends$7({}, sharedHandlerProps, {
      onMouseDown: function onMouseDown(e2) {
        onStepMouseDown(e2, true);
      },
      "aria-label": "Increase Value",
      "aria-disabled": upDisabled,
      className: upClassName
    }), upNode || /* @__PURE__ */ React__namespace.createElement("span", {
      unselectable: "on",
      className: "".concat(prefixCls, "-handler-up-inner")
    })), /* @__PURE__ */ React__namespace.createElement("span", _extends$7({}, sharedHandlerProps, {
      onMouseDown: function onMouseDown(e2) {
        onStepMouseDown(e2, false);
      },
      "aria-label": "Decrease Value",
      "aria-disabled": downDisabled,
      className: downClassName
    }), downNode || /* @__PURE__ */ React__namespace.createElement("span", {
      unselectable: "on",
      className: "".concat(prefixCls, "-handler-down-inner")
    })));
  }
  function getDecupleSteps(step) {
    var stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
    var hasPoint = stepStr.includes(".");
    if (!hasPoint) {
      return step + "0";
    }
    return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
  }
  const useFrame = function() {
    var idRef = React.useRef(0);
    var cleanUp = function cleanUp2() {
      wrapperRaf.cancel(idRef.current);
    };
    React.useEffect(function() {
      return cleanUp;
    }, []);
    return function(callback) {
      cleanUp();
      idRef.current = wrapperRaf(function() {
        callback();
      });
    };
  };
  var _excluded$a = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "controls", "classNames", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep"], _excluded2 = ["disabled", "style", "prefixCls", "value", "prefix", "suffix", "addonBefore", "addonAfter", "classes", "className", "classNames"];
  var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
    if (stringMode || decimalValue.isEmpty()) {
      return decimalValue.toString();
    }
    return decimalValue.toNumber();
  };
  var getDecimalIfValidate = function getDecimalIfValidate2(value) {
    var decimal = getMiniDecimal(value);
    return decimal.isInvalidate() ? null : decimal;
  };
  var InternalInputNumber = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _clsx;
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, className = props.className, style2 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value = props.value, disabled = props.disabled, readOnly = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$controls = props.controls, controls = _props$controls === void 0 ? true : _props$controls, classNames = props.classNames, stringMode = props.stringMode, parser2 = props.parser, formatter = props.formatter, precision2 = props.precision, decimalSeparator = props.decimalSeparator, onChange = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, inputProps = _objectWithoutProperties$8(props, _excluded$a);
    var inputClassName = "".concat(prefixCls, "-input");
    var inputRef = React__namespace.useRef(null);
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1];
    var userTypingRef = React__namespace.useRef(false);
    var compositionRef = React__namespace.useRef(false);
    var shiftKeyRef = React__namespace.useRef(false);
    var _React$useState3 = React__namespace.useState(function() {
      return getMiniDecimal(value !== null && value !== void 0 ? value : defaultValue);
    }), _React$useState4 = _slicedToArray(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
    function setUncontrolledDecimalValue(newDecimal) {
      if (value === void 0) {
        setDecimalValue(newDecimal);
      }
    }
    var getPrecision = React__namespace.useCallback(function(numStr, userTyping) {
      if (userTyping) {
        return void 0;
      }
      if (precision2 >= 0) {
        return precision2;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
    }, [precision2, step]);
    var mergedParser = React__namespace.useCallback(function(num) {
      var numStr = String(num);
      if (parser2) {
        return parser2(numStr);
      }
      var parsedStr = numStr;
      if (decimalSeparator) {
        parsedStr = parsedStr.replace(decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    }, [parser2, decimalSeparator]);
    var inputValueRef = React__namespace.useRef("");
    var mergedFormatter = React__namespace.useCallback(function(number4, userTyping) {
      if (formatter) {
        return formatter(number4, {
          userTyping,
          input: String(inputValueRef.current)
        });
      }
      var str = typeof number4 === "number" ? num2str(number4) : number4;
      if (!userTyping) {
        var mergedPrecision = getPrecision(str, userTyping);
        if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
          var separatorStr = decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    }, [formatter, getPrecision, decimalSeparator]);
    var _React$useState5 = React__namespace.useState(function() {
      var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;
      if (decimalValue.isInvalidate() && ["string", "number"].includes(_typeof(initValue))) {
        return Number.isNaN(initValue) ? "" : initValue;
      }
      return mergedFormatter(decimalValue.toString(), false);
    }), _React$useState6 = _slicedToArray(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
    inputValueRef.current = inputValue;
    function setInputValue(newValue, userTyping) {
      setInternalInputValue(mergedFormatter(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
        userTyping
      ));
    }
    var maxDecimal = React__namespace.useMemo(function() {
      return getDecimalIfValidate(max);
    }, [max, precision2]);
    var minDecimal = React__namespace.useMemo(function() {
      return getDecimalIfValidate(min);
    }, [min, precision2]);
    var upDisabled = React__namespace.useMemo(function() {
      if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return maxDecimal.lessEquals(decimalValue);
    }, [maxDecimal, decimalValue]);
    var downDisabled = React__namespace.useMemo(function() {
      if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return decimalValue.lessEquals(minDecimal);
    }, [minDecimal, decimalValue]);
    var _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
    var getRangeValue = function getRangeValue2(target) {
      if (maxDecimal && !target.lessEquals(maxDecimal)) {
        return maxDecimal;
      }
      if (minDecimal && !minDecimal.lessEquals(target)) {
        return minDecimal;
      }
      return null;
    };
    var isInRange = function isInRange2(target) {
      return !getRangeValue(target);
    };
    var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
      var updateValue = newValue;
      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!readOnly && !disabled && isRangeValidate) {
        var numStr = updateValue.toString();
        var mergedPrecision = getPrecision(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
          if (!isInRange(updateValue)) {
            updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, true));
          }
        }
        if (!updateValue.equals(decimalValue)) {
          setUncontrolledDecimalValue(updateValue);
          onChange === null || onChange === void 0 ? void 0 : onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
          if (value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue;
    };
    var onNextPromise = useFrame();
    var collectInputValue = function collectInputValue2(inputStr) {
      recordCursor();
      inputValueRef.current = inputStr;
      setInternalInputValue(inputStr);
      if (!compositionRef.current) {
        var finalValue = mergedParser(inputStr);
        var finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      onInput === null || onInput === void 0 ? void 0 : onInput(inputStr);
      onNextPromise(function() {
        var nextInputStr = inputStr;
        if (!parser2) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue2(nextInputStr);
        }
      });
    };
    var onCompositionStart = function onCompositionStart2() {
      compositionRef.current = true;
    };
    var onCompositionEnd = function onCompositionEnd2() {
      compositionRef.current = false;
      collectInputValue(inputRef.current.value);
    };
    var onInternalInput = function onInternalInput2(e2) {
      collectInputValue(e2.target.value);
    };
    var onInternalStep = function onInternalStep2(up) {
      var _inputRef$current;
      if (up && upDisabled || !up && downDisabled) {
        return;
      }
      userTypingRef.current = false;
      var stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      var target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());
      var updatedValue = triggerValueUpdate(target, false);
      onStep === null || onStep === void 0 ? void 0 : onStep(getDecimalValue(stringMode, updatedValue), {
        offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
        type: up ? "up" : "down"
      });
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
    };
    var flushInputValue = function flushInputValue2(userTyping) {
      var parsedValue = getMiniDecimal(mergedParser(inputValue));
      var formatValue = parsedValue;
      if (!parsedValue.isNaN()) {
        formatValue = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue = triggerValueUpdate(decimalValue, userTyping);
      }
      if (value !== void 0) {
        setInputValue(decimalValue, false);
      } else if (!formatValue.isNaN()) {
        setInputValue(formatValue, false);
      }
    };
    var onBeforeInput = function onBeforeInput2() {
      userTypingRef.current = true;
    };
    var onKeyDown = function onKeyDown2(event) {
      var key = event.key, shiftKey = event.shiftKey;
      userTypingRef.current = true;
      shiftKeyRef.current = shiftKey;
      if (key === "Enter") {
        if (!compositionRef.current) {
          userTypingRef.current = false;
        }
        flushInputValue(false);
        onPressEnter === null || onPressEnter === void 0 ? void 0 : onPressEnter(event);
      }
      if (keyboard === false) {
        return;
      }
      if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
        onInternalStep(key === "Up" || key === "ArrowUp");
        event.preventDefault();
      }
    };
    var onKeyUp = function onKeyUp2() {
      userTypingRef.current = false;
      shiftKeyRef.current = false;
    };
    var onBlur = function onBlur2() {
      flushInputValue(false);
      setFocus(false);
      userTypingRef.current = false;
    };
    useLayoutUpdateEffect(function() {
      if (!decimalValue.isInvalidate()) {
        setInputValue(decimalValue, false);
      }
    }, [precision2]);
    useLayoutUpdateEffect(function() {
      var newValue = getMiniDecimal(value);
      setDecimalValue(newValue);
      var currentParsedValue = getMiniDecimal(mergedParser(inputValue));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
        setInputValue(newValue, userTypingRef.current);
      }
    }, [value]);
    useLayoutUpdateEffect(function() {
      if (formatter) {
        restoreCursor();
      }
    }, [inputValue]);
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(prefixCls, classNames === null || classNames === void 0 ? void 0 : classNames.input, className, (_clsx = {}, _defineProperty$1(_clsx, "".concat(prefixCls, "-focused"), focus), _defineProperty$1(_clsx, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$1(_clsx, "".concat(prefixCls, "-readonly"), readOnly), _defineProperty$1(_clsx, "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), _defineProperty$1(_clsx, "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange(decimalValue)), _clsx)),
      style: style2,
      onFocus: function onFocus() {
        setFocus(true);
      },
      onBlur,
      onKeyDown,
      onKeyUp,
      onCompositionStart,
      onCompositionEnd,
      onBeforeInput
    }, controls && /* @__PURE__ */ React__namespace.createElement(StepHandler, {
      prefixCls,
      upNode: upHandler,
      downNode: downHandler,
      upDisabled,
      downDisabled,
      onStep: onInternalStep
    }), /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(inputClassName, "-wrap")
    }, /* @__PURE__ */ React__namespace.createElement("input", _extends$7({
      autoComplete: "off",
      role: "spinbutton",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
      step
    }, inputProps, {
      ref: composeRef(inputRef, ref),
      className: inputClassName,
      value: inputValue,
      onChange: onInternalInput,
      disabled,
      readOnly
    }))));
  });
  var InputNumber$2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var disabled = props.disabled, style2 = props.style, prefixCls = props.prefixCls, value = props.value, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, classes = props.classes, className = props.className, classNames = props.classNames, rest = _objectWithoutProperties$8(props, _excluded2);
    var inputFocusRef = React__namespace.useRef(null);
    var focus = function focus2(option) {
      if (inputFocusRef.current) {
        triggerFocus$1(inputFocusRef.current, option);
      }
    };
    return /* @__PURE__ */ React__namespace.createElement(BaseInput, {
      inputElement: /* @__PURE__ */ React__namespace.createElement(InternalInputNumber, _extends$7({
        prefixCls,
        disabled,
        classNames,
        ref: composeRef(inputFocusRef, ref)
      }, rest)),
      className,
      triggerFocus: focus,
      prefixCls,
      value,
      disabled,
      style: style2,
      prefix,
      suffix,
      addonAfter,
      addonBefore,
      classes,
      classNames,
      components: {
        affixWrapper: "div",
        groupWrapper: "div",
        wrapper: "div",
        groupAddon: "div"
      }
    });
  });
  InputNumber$2.displayName = "InputNumber";
  const genRadiusStyle = (_ref, size) => {
    let {
      componentCls,
      borderRadiusSM,
      borderRadiusLG
    } = _ref;
    const borderRadius = size === "lg" ? borderRadiusLG : borderRadiusSM;
    return {
      [`&-${size}`]: {
        [`${componentCls}-handler-wrap`]: {
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius
        },
        [`${componentCls}-handler-up`]: {
          borderStartEndRadius: borderRadius
        },
        [`${componentCls}-handler-down`]: {
          borderEndEndRadius: borderRadius
        }
      }
    };
  };
  const genInputNumberStyles = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      colorBorder,
      borderRadius,
      fontSizeLG,
      controlHeightLG,
      controlHeightSM,
      colorError,
      paddingInlineSM,
      colorTextDescription,
      motionDurationMid,
      handleHoverColor,
      paddingInline,
      paddingBlock,
      handleBg,
      handleActiveBg,
      colorTextDisabled,
      borderRadiusSM,
      borderRadiusLG,
      controlWidth,
      handleVisible,
      handleBorderColor
    } = token2;
    return [
      {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
          display: "inline-block",
          width: controlWidth,
          margin: 0,
          padding: 0,
          border: `${lineWidth}px ${lineType} ${colorBorder}`,
          borderRadius,
          "&-rtl": {
            direction: "rtl",
            [`${componentCls}-input`]: {
              direction: "rtl"
            }
          },
          "&-lg": {
            padding: 0,
            fontSize: fontSizeLG,
            borderRadius: borderRadiusLG,
            [`input${componentCls}-input`]: {
              height: controlHeightLG - 2 * lineWidth
            }
          },
          "&-sm": {
            padding: 0,
            borderRadius: borderRadiusSM,
            [`input${componentCls}-input`]: {
              height: controlHeightSM - 2 * lineWidth,
              padding: `0 ${paddingInlineSM}px`
            }
          },
          // ===================== Out Of Range =====================
          "&-out-of-range": {
            [`${componentCls}-input-wrap`]: {
              input: {
                color: colorError
              }
            }
          },
          // Style for input-group: input with label, with button or dropdown...
          "&-group": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
            "&-wrapper": {
              display: "inline-block",
              textAlign: "start",
              verticalAlign: "top",
              [`${componentCls}-affix-wrapper`]: {
                width: "100%"
              },
              // Size
              "&-lg": {
                [`${componentCls}-group-addon`]: {
                  borderRadius: borderRadiusLG,
                  fontSize: token2.fontSizeLG
                }
              },
              "&-sm": {
                [`${componentCls}-group-addon`]: {
                  borderRadius: borderRadiusSM
                }
              },
              [`${componentCls}-wrapper-disabled > ${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
            }
          }),
          [`&-disabled ${componentCls}-input`]: {
            cursor: "not-allowed"
          },
          [componentCls]: {
            "&-input": Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
              width: "100%",
              padding: `${paddingBlock}px ${paddingInline}px`,
              textAlign: "start",
              backgroundColor: "transparent",
              border: 0,
              borderRadius,
              outline: 0,
              transition: `all ${motionDurationMid} linear`,
              appearance: "textfield",
              fontSize: "inherit"
            }), genPlaceholderStyle(token2.colorTextPlaceholder)), {
              '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
                margin: 0,
                /* stylelint-disable-next-line property-no-vendor-prefix */
                webkitAppearance: "none",
                appearance: "none"
              }
            })
          }
        })
      },
      // Handler
      {
        [componentCls]: Object.assign(Object.assign(Object.assign({
          [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
            opacity: 1
          },
          [`${componentCls}-handler-wrap`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineEnd: 0,
            width: token2.handleWidth,
            height: "100%",
            background: handleBg,
            borderStartStartRadius: 0,
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius,
            borderEndStartRadius: 0,
            opacity: handleVisible === true ? 1 : 0,
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
            // Fix input number inside Menu makes icon too large
            // We arise the selector priority by nest selector here
            // https://github.com/ant-design/ant-design/issues/14367
            [`${componentCls}-handler`]: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flex: "auto",
              height: "40%",
              [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                marginInlineEnd: 0,
                fontSize: token2.handleFontSize
              }
            }
          },
          [`${componentCls}-handler`]: {
            height: "50%",
            overflow: "hidden",
            color: colorTextDescription,
            fontWeight: "bold",
            lineHeight: 0,
            textAlign: "center",
            cursor: "pointer",
            borderInlineStart: `${lineWidth}px ${lineType} ${handleBorderColor}`,
            transition: `all ${motionDurationMid} linear`,
            "&:active": {
              background: handleActiveBg
            },
            // Hover
            "&:hover": {
              height: `60%`,
              [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                color: handleHoverColor
              }
            },
            "&-up-inner, &-down-inner": Object.assign(Object.assign({}, resetIcon()), {
              color: colorTextDescription,
              transition: `all ${motionDurationMid} linear`,
              userSelect: "none"
            })
          },
          [`${componentCls}-handler-up`]: {
            borderStartEndRadius: borderRadius
          },
          [`${componentCls}-handler-down`]: {
            borderBlockStart: `${lineWidth}px ${lineType} ${handleBorderColor}`,
            borderEndEndRadius: borderRadius
          }
        }, genRadiusStyle(token2, "lg")), genRadiusStyle(token2, "sm")), {
          // Disabled
          "&-disabled, &-readonly": {
            [`${componentCls}-handler-wrap`]: {
              display: "none"
            },
            [`${componentCls}-input`]: {
              color: "inherit"
            }
          },
          [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
            cursor: "not-allowed"
          },
          [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
            color: colorTextDisabled
          }
        })
      },
      // Border-less
      {
        [`${componentCls}-borderless`]: {
          borderColor: "transparent",
          boxShadow: "none",
          [`${componentCls}-handler-down`]: {
            borderBlockStartWidth: 0
          }
        }
      }
    ];
  };
  const genAffixWrapperStyles = (token2) => {
    const {
      componentCls,
      paddingBlock,
      paddingInline,
      inputAffixPadding,
      controlWidth,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), genStatusStyle(token2, `${componentCls}-affix-wrapper`)), {
        // or number handler will cover form status
        position: "relative",
        display: "inline-flex",
        width: controlWidth,
        padding: 0,
        paddingInlineStart: paddingInline,
        "&-lg": {
          borderRadius: borderRadiusLG
        },
        "&-sm": {
          borderRadius: borderRadiusSM
        },
        [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: {
          zIndex: 1
        },
        "&-focused, &:focus": {
          zIndex: 1
        },
        [`&-disabled > ${componentCls}-disabled`]: {
          background: "transparent"
        },
        [`> div${componentCls}`]: {
          width: "100%",
          border: "none",
          outline: "none",
          [`&${componentCls}-focused`]: {
            boxShadow: "none !important"
          }
        },
        [`input${componentCls}-input`]: {
          padding: `${paddingBlock}px 0`
        },
        "&::before": {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [`${componentCls}-handler-wrap`]: {
          zIndex: 2
        },
        [componentCls]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            pointerEvents: "none"
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineEnd: 0,
            zIndex: 1,
            height: "100%",
            marginInlineEnd: paddingInline,
            marginInlineStart: inputAffixPadding
          }
        }
      })
    };
  };
  const useStyle$4 = genComponentStyleHook("InputNumber", (token2) => {
    const inputNumberToken = merge(token2, initInputToken(token2));
    return [
      genInputNumberStyles(inputNumberToken),
      genAffixWrapperStyles(inputNumberToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputNumberToken)
    ];
  }, (token2) => Object.assign(Object.assign({}, initComponentToken(token2)), {
    controlWidth: 90,
    handleWidth: token2.controlHeightSM - token2.lineWidth * 2,
    handleFontSize: token2.fontSize / 2,
    handleVisible: "auto",
    handleActiveBg: token2.colorFillAlter,
    handleBg: token2.colorBgContainer,
    handleHoverColor: token2.colorPrimary,
    handleBorderColor: token2.colorBorder
  }));
  var __rest$c = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const InputNumber = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const inputRef = React__namespace.useRef(null);
    React__namespace.useImperativeHandle(ref, () => inputRef.current);
    const {
      className,
      rootClassName,
      size: customizeSize,
      disabled: customDisabled,
      prefixCls: customizePrefixCls,
      addonBefore,
      addonAfter,
      prefix,
      bordered = true,
      readOnly,
      status: customStatus,
      controls
    } = props, others = __rest$c(props, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "bordered", "readOnly", "status", "controls"]);
    const prefixCls = getPrefixCls("input-number", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$4(prefixCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    let upIcon = /* @__PURE__ */ React__namespace.createElement(UpOutlined$1, {
      className: `${prefixCls}-handler-up-inner`
    });
    let downIcon = /* @__PURE__ */ React__namespace.createElement(DownOutlined$1, {
      className: `${prefixCls}-handler-down-inner`
    });
    const controlsTemp = typeof controls === "boolean" ? controls : void 0;
    if (typeof controls === "object") {
      upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ React__namespace.createElement("span", {
        className: `${prefixCls}-handler-up-inner`
      }, controls.upIcon);
      downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ React__namespace.createElement("span", {
        className: `${prefixCls}-handler-down-inner`
      }, controls.downIcon);
    }
    const {
      hasFeedback,
      status: contextStatus,
      isFormItemInput,
      feedbackIcon
    } = React__namespace.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const mergedSize = useSize$1((ctx) => {
      var _a;
      return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
    });
    const disabled = React__namespace.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const inputNumberClass = classname({
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-borderless`]: !bordered,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus), hashId);
    const wrapperClassName = `${prefixCls}-group`;
    const element = /* @__PURE__ */ React__namespace.createElement(InputNumber$2, Object.assign({
      ref: inputRef,
      disabled: mergedDisabled,
      className: classname(className, rootClassName, compactItemClassnames),
      upHandler: upIcon,
      downHandler: downIcon,
      prefixCls,
      readOnly,
      controls: controlsTemp,
      prefix,
      suffix: hasFeedback && feedbackIcon,
      addonAfter: addonAfter && /* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, /* @__PURE__ */ React__namespace.createElement(NoFormStyle, {
        override: true,
        status: true
      }, addonAfter)),
      addonBefore: addonBefore && /* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, /* @__PURE__ */ React__namespace.createElement(NoFormStyle, {
        override: true,
        status: true
      }, addonBefore)),
      classNames: {
        input: inputNumberClass
      },
      classes: {
        affixWrapper: classname(getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), {
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-borderless`]: !bordered
        }, hashId),
        wrapper: classname({
          [`${wrapperClassName}-rtl`]: direction === "rtl",
          [`${prefixCls}-wrapper-disabled`]: mergedDisabled
        }, hashId),
        group: classname({
          [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl"
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
      }
    }, others));
    return wrapSSR(element);
  });
  const TypedInputNumber = InputNumber;
  const PureInputNumber = (props) => /* @__PURE__ */ React__namespace.createElement(ConfigProvider, {
    theme: {
      components: {
        InputNumber: {
          handleVisible: true
        }
      }
    }
  }, /* @__PURE__ */ React__namespace.createElement(InputNumber, Object.assign({}, props)));
  TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
  const InputNumber$1 = TypedInputNumber;
  const Group$1 = (props) => {
    const {
      getPrefixCls,
      direction
    } = React.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className
    } = props;
    const prefixCls = getPrefixCls("input-group", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input");
    const [wrapSSR, hashId] = useStyle$6(inputPrefixCls);
    const cls = classname(prefixCls, {
      [`${prefixCls}-lg`]: props.size === "large",
      [`${prefixCls}-sm`]: props.size === "small",
      [`${prefixCls}-compact`]: props.compact,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, hashId, className);
    const formItemContext = React.useContext(FormItemInputContext);
    const groupFormItemContext = React.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
      isFormItemInput: false
    }), [formItemContext]);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", {
      className: cls,
      style: props.style,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      onFocus: props.onFocus,
      onBlur: props.onBlur
    }, /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
      value: groupFormItemContext
    }, props.children)));
  };
  const Group$2 = Group$1;
  function useRemovePasswordTimeout(inputRef, triggerOnMount) {
    const removePasswordTimeoutRef = React.useRef([]);
    const removePasswordTimeout = () => {
      removePasswordTimeoutRef.current.push(setTimeout(() => {
        var _a, _b, _c, _d;
        if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
          (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
        }
      }));
    };
    React.useEffect(() => {
      if (triggerOnMount) {
        removePasswordTimeout();
      }
      return () => removePasswordTimeoutRef.current.forEach((timer2) => {
        if (timer2) {
          clearTimeout(timer2);
        }
      });
    }, []);
    return removePasswordTimeout;
  }
  function hasPrefixSuffix(props) {
    return !!(props.prefix || props.suffix || props.allowClear);
  }
  var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function triggerFocus(element, option) {
    if (!element) {
      return;
    }
    element.focus(option);
    const {
      cursor
    } = option || {};
    if (cursor) {
      const len = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
          break;
      }
    }
  }
  const Input$3 = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var _a;
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      status: customStatus,
      size: customSize,
      disabled: customDisabled,
      onBlur,
      onFocus,
      suffix,
      allowClear,
      addonAfter,
      addonBefore,
      className,
      style: style2,
      styles: styles2,
      rootClassName,
      onChange,
      classNames: classes
    } = props, rest = __rest$b(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames"]);
    const {
      getPrefixCls,
      direction,
      input
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const inputRef = React.useRef(null);
    const [wrapSSR, hashId] = useStyle$6(prefixCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize$1((ctx) => {
      var _a2;
      return (_a2 = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
    });
    const disabled = React.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = React.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
    React.useRef(inputHasPrefixSuffix);
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
    const handleBlur = (e2) => {
      removePasswordTimeout();
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
    };
    const handleFocus = (e2) => {
      removePasswordTimeout();
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
    };
    const handleChange = (e2) => {
      removePasswordTimeout();
      onChange === null || onChange === void 0 ? void 0 : onChange(e2);
    };
    const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon);
    let mergedAllowClear;
    if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
      mergedAllowClear = allowClear;
    } else if (allowClear) {
      mergedAllowClear = {
        clearIcon: /* @__PURE__ */ React.createElement(CloseCircleFilled$1, null)
      };
    }
    return wrapSSR(/* @__PURE__ */ React.createElement(Input$4, Object.assign({
      ref: composeRef(ref, inputRef),
      prefixCls,
      autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
    }, rest, {
      disabled: mergedDisabled,
      onBlur: handleBlur,
      onFocus: handleFocus,
      style: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.style), style2),
      styles: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.styles), styles2),
      suffix: suffixNode,
      allowClear: mergedAllowClear,
      className: classname(className, rootClassName, compactItemClassnames, input === null || input === void 0 ? void 0 : input.className),
      onChange: handleChange,
      addonAfter: addonAfter && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
        override: true,
        status: true
      }, addonAfter)),
      addonBefore: addonBefore && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
        override: true,
        status: true
      }, addonBefore)),
      classNames: Object.assign(Object.assign(Object.assign({}, classes), input === null || input === void 0 ? void 0 : input.classNames), {
        input: classname({
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large",
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-borderless`]: !bordered
        }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), classes === null || classes === void 0 ? void 0 : classes.input, (_a = input === null || input === void 0 ? void 0 : input.classNames) === null || _a === void 0 ? void 0 : _a.input, hashId)
      }),
      classes: {
        affixWrapper: classname({
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-borderless`]: !bordered
        }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
        wrapper: classname({
          [`${prefixCls}-group-rtl`]: direction === "rtl"
        }, hashId),
        group: classname({
          [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
      }
    })));
  });
  const InternalInput = Input$3;
  var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
  const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
  var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: EyeInvisibleOutlinedSvg
    }));
  };
  const EyeInvisibleOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(EyeInvisibleOutlined);
  var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
  const EyeOutlinedSvg = EyeOutlined$2;
  var EyeOutlined = function EyeOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: EyeOutlinedSvg
    }));
  };
  const EyeOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(EyeOutlined);
  var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const defaultIconRender = (visible) => visible ? /* @__PURE__ */ React__namespace.createElement(EyeOutlined$1, null) : /* @__PURE__ */ React__namespace.createElement(EyeInvisibleOutlined$1, null);
  const ActionMap = {
    click: "onClick",
    hover: "onMouseOver"
  };
  const Password = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      visibilityToggle = true
    } = props;
    const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
    const [visible, setVisible] = React.useState(() => visibilityControlled ? visibilityToggle.visible : false);
    const inputRef = React.useRef(null);
    React__namespace.useEffect(() => {
      if (visibilityControlled) {
        setVisible(visibilityToggle.visible);
      }
    }, [visibilityControlled, visibilityToggle]);
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
    const onVisibleChange = () => {
      const {
        disabled
      } = props;
      if (disabled) {
        return;
      }
      if (visible) {
        removePasswordTimeout();
      }
      setVisible((prevState) => {
        var _a;
        const newState = !prevState;
        if (typeof visibilityToggle === "object") {
          (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
        }
        return newState;
      });
    };
    const getIcon = (prefixCls2) => {
      const {
        action = "click",
        iconRender = defaultIconRender
      } = props;
      const iconTrigger = ActionMap[action] || "";
      const icon2 = iconRender(visible);
      const iconProps = {
        [iconTrigger]: onVisibleChange,
        className: `${prefixCls2}-icon`,
        key: "passwordIcon",
        onMouseDown: (e2) => {
          e2.preventDefault();
        },
        onMouseUp: (e2) => {
          e2.preventDefault();
        }
      };
      return /* @__PURE__ */ React__namespace.cloneElement(/* @__PURE__ */ React__namespace.isValidElement(icon2) ? icon2 : /* @__PURE__ */ React__namespace.createElement("span", null, icon2), iconProps);
    };
    const {
      className,
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      size
    } = props, restProps = __rest$a(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const prefixCls = getPrefixCls("input-password", customizePrefixCls);
    const suffixIcon = visibilityToggle && getIcon(prefixCls);
    const inputClassName = classname(prefixCls, className, {
      [`${prefixCls}-${size}`]: !!size
    });
    const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
      type: visible ? "text" : "password",
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: suffixIcon
    });
    if (size) {
      omittedProps.size = size;
    }
    return /* @__PURE__ */ React__namespace.createElement(InternalInput, Object.assign({
      ref: composeRef(ref, inputRef)
    }, omittedProps));
  });
  const Password$1 = Password;
  var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const Search = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      className,
      size: customizeSize,
      suffix,
      enterButton = false,
      addonAfter,
      loading,
      disabled,
      onSearch: customOnSearch,
      onChange: customOnChange,
      onCompositionStart,
      onCompositionEnd
    } = props, restProps = __rest$9(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const composedRef = React__namespace.useRef(false);
    const prefixCls = getPrefixCls("input-search", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const {
      compactSize
    } = useCompactItemContext(prefixCls, direction);
    const size = useSize$1((ctx) => {
      var _a;
      return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
    });
    const inputRef = React__namespace.useRef(null);
    const onChange = (e2) => {
      if (e2 && e2.target && e2.type === "click" && customOnSearch) {
        customOnSearch(e2.target.value, e2, {
          source: "clear"
        });
      }
      if (customOnChange) {
        customOnChange(e2);
      }
    };
    const onMouseDown = (e2) => {
      var _a;
      if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
        e2.preventDefault();
      }
    };
    const onSearch = (e2) => {
      var _a, _b;
      if (customOnSearch) {
        customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2, {
          source: "input"
        });
      }
    };
    const onPressEnter = (e2) => {
      if (composedRef.current || loading) {
        return;
      }
      onSearch(e2);
    };
    const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ React__namespace.createElement(SearchOutlined$1, null) : null;
    const btnClassName = `${prefixCls}-button`;
    let button;
    const enterButtonAsElement = enterButton || {};
    const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
    if (isAntdButton || enterButtonAsElement.type === "button") {
      button = cloneElement(enterButtonAsElement, Object.assign({
        onMouseDown,
        onClick: (e2) => {
          var _a, _b;
          (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
          onSearch(e2);
        },
        key: "enterButton"
      }, isAntdButton ? {
        className: btnClassName,
        size
      } : {}));
    } else {
      button = /* @__PURE__ */ React__namespace.createElement(Button$3, {
        className: btnClassName,
        type: enterButton ? "primary" : void 0,
        size,
        disabled,
        key: "enterButton",
        onMouseDown,
        onClick: onSearch,
        loading,
        icon: searchIcon
      }, enterButton);
    }
    if (addonAfter) {
      button = [button, cloneElement(addonAfter, {
        key: "addonAfter"
      })];
    }
    const cls = classname(prefixCls, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${size}`]: !!size,
      [`${prefixCls}-with-button`]: !!enterButton
    }, className);
    const handleOnCompositionStart = (e2) => {
      composedRef.current = true;
      onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
    };
    const handleOnCompositionEnd = (e2) => {
      composedRef.current = false;
      onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
    };
    return /* @__PURE__ */ React__namespace.createElement(InternalInput, Object.assign({
      ref: composeRef(inputRef, ref),
      onPressEnter
    }, restProps, {
      size,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      prefixCls: inputPrefixCls,
      addonAfter: button,
      suffix,
      onChange,
      className: cls,
      disabled
    }));
  });
  const Search$1 = Search;
  var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
  var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
  var computedStyleCache = {};
  var hiddenTextarea;
  function calculateNodeStyling(node2) {
    var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
    if (useCache2 && computedStyleCache[nodeRef]) {
      return computedStyleCache[nodeRef];
    }
    var style2 = window.getComputedStyle(node2);
    var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
    var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
    var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
    var sizingStyle = SIZING_STYLE.map(function(name) {
      return "".concat(name, ":").concat(style2.getPropertyValue(name));
    }).join(";");
    var nodeInfo = {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
    if (useCache2 && nodeRef) {
      computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
  }
  function calculateAutoSizeStyle(uiTextNode) {
    var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      document.body.appendChild(hiddenTextarea);
    }
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
    } else {
      hiddenTextarea.removeAttribute("wrap");
    }
    var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    var minHeight = void 0;
    var maxHeight = void 0;
    var overflowY;
    var height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      hiddenTextarea.value = " ";
      var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    var style2 = {
      height,
      overflowY,
      resize: "none"
    };
    if (minHeight) {
      style2.minHeight = minHeight;
    }
    if (maxHeight) {
      style2.maxHeight = maxHeight;
    }
    return style2;
  }
  var _excluded$9 = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
  var RESIZE_START = 0;
  var RESIZE_MEASURING = 1;
  var RESIZE_STABLE = 2;
  var ResizableTextArea = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _ref = props, prefixCls = _ref.prefixCls;
    _ref.onPressEnter;
    var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
    _ref.onInternalAutoSize;
    var restProps = _objectWithoutProperties$8(_ref, _excluded$9);
    var _useMergedState = useMergedState(defaultValue, {
      value,
      postState: function postState(val) {
        return val !== null && val !== void 0 ? val : "";
      }
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
    var onInternalChange = function onInternalChange2(event) {
      setMergedValue(event.target.value);
      onChange === null || onChange === void 0 ? void 0 : onChange(event);
    };
    var textareaRef = React__namespace.useRef();
    React__namespace.useImperativeHandle(ref, function() {
      return {
        textArea: textareaRef.current
      };
    });
    var _React$useMemo = React__namespace.useMemo(function() {
      if (autoSize && _typeof(autoSize) === "object") {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
    var needAutoSize = !!autoSize;
    var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
      try {
        if (document.activeElement === textareaRef.current) {
          var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
          textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
          textareaRef.current.scrollTop = scrollTop;
        }
      } catch (e2) {
      }
    };
    var _React$useState = React__namespace.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
    var _React$useState3 = React__namespace.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
    var startResize = function startResize2() {
      setResizeState(RESIZE_START);
    };
    useLayoutEffect$1(function() {
      if (needAutoSize) {
        startResize();
      }
    }, [value, minRows, maxRows, needAutoSize]);
    useLayoutEffect$1(function() {
      if (resizeState === RESIZE_START) {
        setResizeState(RESIZE_MEASURING);
      } else if (resizeState === RESIZE_MEASURING) {
        var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
        setResizeState(RESIZE_STABLE);
        setAutoSizeStyle(textareaStyles);
      } else {
        fixFirefoxAutoScroll();
      }
    }, [resizeState]);
    var resizeRafRef = React__namespace.useRef();
    var cleanRaf = function cleanRaf2() {
      wrapperRaf.cancel(resizeRafRef.current);
    };
    var onInternalResize = function onInternalResize2(size) {
      if (resizeState === RESIZE_STABLE) {
        onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
        if (autoSize) {
          cleanRaf();
          resizeRafRef.current = wrapperRaf(function() {
            startResize();
          });
        }
      }
    };
    React__namespace.useEffect(function() {
      return cleanRaf;
    }, []);
    var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
    var mergedStyle = _objectSpread2(_objectSpread2({}, style2), mergedAutoSizeStyle);
    if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
      mergedStyle.overflowY = "hidden";
      mergedStyle.overflowX = "hidden";
    }
    return /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onInternalResize,
      disabled: !(autoSize || onResize2)
    }, /* @__PURE__ */ React__namespace.createElement("textarea", _extends$7({}, restProps, {
      ref: textareaRef,
      style: mergedStyle,
      className: classname(prefixCls, className, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled)),
      disabled,
      value: mergedValue,
      onChange: onInternalChange
    })));
  });
  var _excluded$8 = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize"];
  function fixEmojiLength(value, maxLength) {
    return _toConsumableArray(value || "").slice(0, maxLength).join("");
  }
  function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
    var newTriggerValue = triggerValue;
    if (isCursorInEnd) {
      newTriggerValue = fixEmojiLength(triggerValue, maxLength);
    } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
      newTriggerValue = preValue;
    }
    return newTriggerValue;
  }
  var TextArea$5 = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
    var _clsx;
    var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames = _ref.classNames, styles2 = _ref.styles, onResize2 = _ref.onResize, rest = _objectWithoutProperties$8(_ref, _excluded$8);
    var _useMergedState = useMergedState(defaultValue, {
      value: customValue,
      defaultValue
    }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
    var resizableTextAreaRef = React.useRef(null);
    var _React$useState = React.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
    var _React$useState3 = React.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), compositing = _React$useState4[0], setCompositing = _React$useState4[1];
    var oldCompositionValueRef = React.useRef();
    var oldSelectionStartRef = React.useRef(0);
    var _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), textareaResized = _React$useState6[0], setTextareaResized = _React$useState6[1];
    var focus = function focus2() {
      var _resizableTextAreaRef;
      (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea.focus();
    };
    React.useImperativeHandle(ref, function() {
      return {
        resizableTextArea: resizableTextAreaRef.current,
        focus,
        blur: function blur() {
          var _resizableTextAreaRef2;
          (_resizableTextAreaRef2 = resizableTextAreaRef.current) === null || _resizableTextAreaRef2 === void 0 ? void 0 : _resizableTextAreaRef2.textArea.blur();
        }
      };
    });
    React.useEffect(function() {
      setFocused(function(prev2) {
        return !disabled && prev2;
      });
    }, [disabled]);
    var hasMaxLength = Number(maxLength) > 0;
    var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
      setCompositing(true);
      oldCompositionValueRef.current = value;
      oldSelectionStartRef.current = e2.currentTarget.selectionStart;
      onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
    };
    var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
      setCompositing(false);
      var triggerValue = e2.currentTarget.value;
      if (hasMaxLength) {
        var _oldCompositionValueR;
        var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_oldCompositionValueR = oldCompositionValueRef.current) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
        triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
      }
      if (triggerValue !== value) {
        setValue(triggerValue);
        resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
      }
      onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
    };
    var handleChange = function handleChange2(e2) {
      var triggerValue = e2.target.value;
      if (!compositing && hasMaxLength) {
        var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
        triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
      }
      setValue(triggerValue);
      resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
    };
    var handleKeyDown = function handleKeyDown2(e2) {
      var onPressEnter = rest.onPressEnter, onKeyDown = rest.onKeyDown;
      if (e2.key === "Enter" && onPressEnter) {
        onPressEnter(e2);
      }
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
    };
    var handleFocus = function handleFocus2(e2) {
      setFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
    };
    var handleBlur = function handleBlur2(e2) {
      setFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
    };
    var handleReset = function handleReset2(e2) {
      var _resizableTextAreaRef3;
      setValue("");
      focus();
      resolveOnChange((_resizableTextAreaRef3 = resizableTextAreaRef.current) === null || _resizableTextAreaRef3 === void 0 ? void 0 : _resizableTextAreaRef3.textArea, e2, onChange);
    };
    var val = fixControlledValue(value);
    if (!compositing && hasMaxLength && (customValue === null || customValue === void 0)) {
      val = fixEmojiLength(val, maxLength);
    }
    var suffixNode = suffix;
    var dataCount;
    if (showCount) {
      var valueLength = _toConsumableArray(val).length;
      if (_typeof(showCount) === "object") {
        dataCount = showCount.formatter({
          value: val,
          count: valueLength,
          maxLength
        });
      } else {
        dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
      }
      suffixNode = /* @__PURE__ */ React.createElement(React.Fragment, null, suffixNode, /* @__PURE__ */ React.createElement("span", {
        className: classname("".concat(prefixCls, "-data-count"), classNames === null || classNames === void 0 ? void 0 : classNames.count),
        style: styles2 === null || styles2 === void 0 ? void 0 : styles2.count
      }, dataCount));
    }
    var handleResize = function handleResize2(size) {
      var _resizableTextAreaRef4;
      onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
      if ((_resizableTextAreaRef4 = resizableTextAreaRef.current) !== null && _resizableTextAreaRef4 !== void 0 && _resizableTextAreaRef4.textArea.style.height) {
        setTextareaResized(true);
      }
    };
    var isPureTextArea = !rest.autoSize && !showCount && !allowClear;
    var textarea = /* @__PURE__ */ React.createElement(BaseInput, {
      value: val,
      allowClear,
      handleReset,
      suffix: suffixNode,
      prefixCls,
      classes: {
        affixWrapper: classname(classes === null || classes === void 0 ? void 0 : classes.affixWrapper, (_clsx = {}, _defineProperty$1(_clsx, "".concat(prefixCls, "-show-count"), showCount), _defineProperty$1(_clsx, "".concat(prefixCls, "-textarea-allow-clear"), allowClear), _clsx))
      },
      disabled,
      focused,
      className,
      style: _objectSpread2(_objectSpread2({}, style2), textareaResized && !isPureTextArea ? {
        height: "auto"
      } : {}),
      dataAttrs: {
        affixWrapper: {
          "data-count": typeof dataCount === "string" ? dataCount : void 0
        }
      },
      hidden,
      inputElement: /* @__PURE__ */ React.createElement(ResizableTextArea, _extends$7({}, rest, {
        onKeyDown: handleKeyDown,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onCompositionStart: onInternalCompositionStart,
        onCompositionEnd: onInternalCompositionEnd,
        className: classNames === null || classNames === void 0 ? void 0 : classNames.textarea,
        style: _objectSpread2(_objectSpread2({}, styles2 === null || styles2 === void 0 ? void 0 : styles2.textarea), {}, {
          resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
        }),
        disabled,
        prefixCls,
        onResize: handleResize,
        ref: resizableTextAreaRef
      }))
    });
    return textarea;
  });
  var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const TextArea$3 = /* @__PURE__ */ React.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      size: customizeSize,
      disabled: customDisabled,
      status: customStatus,
      allowClear,
      showCount,
      classNames: classes,
      rootClassName,
      className
    } = props, rest = __rest$8(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "showCount", "classNames", "rootClassName", "className"]);
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const mergedSize = useSize$1(customizeSize);
    const disabled = React__namespace.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = React__namespace.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const innerRef = React__namespace.useRef(null);
    React__namespace.useImperativeHandle(ref, () => {
      var _a;
      return {
        resizableTextArea: (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea,
        focus: (option) => {
          var _a2, _b;
          triggerFocus((_b = (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
        },
        blur: () => {
          var _a2;
          return (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      };
    });
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    let mergedAllowClear;
    if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
      mergedAllowClear = allowClear;
    } else if (allowClear) {
      mergedAllowClear = {
        clearIcon: /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null)
      };
    }
    const [wrapSSR, hashId] = useStyle$6(prefixCls);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(TextArea$5, Object.assign({}, rest, {
      disabled: mergedDisabled,
      allowClear: mergedAllowClear,
      className: classname(className, rootClassName),
      classes: {
        affixWrapper: classname(`${prefixCls}-textarea-affix-wrapper`, {
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-textarea-show-count`]: showCount
        }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId)
      },
      classNames: Object.assign(Object.assign({}, classes), {
        textarea: classname({
          [`${prefixCls}-borderless`]: !bordered,
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large"
        }, getStatusClassNames(prefixCls, mergedStatus), hashId, classes === null || classes === void 0 ? void 0 : classes.textarea)
      }),
      prefixCls,
      suffix: hasFeedback && /* @__PURE__ */ React__namespace.createElement("span", {
        className: `${prefixCls}-textarea-suffix`
      }, feedbackIcon),
      showCount,
      ref: innerRef
    })));
  });
  const TextArea$4 = TextArea$3;
  const Input$1 = InternalInput;
  Input$1.Group = Group$2;
  Input$1.Search = Search$1;
  Input$1.TextArea = TextArea$4;
  Input$1.Password = Password$1;
  const Input$2 = Input$1;
  var DrawerContext = /* @__PURE__ */ React__namespace.createContext(null);
  var RefContext = /* @__PURE__ */ React__namespace.createContext({});
  var DrawerPanel$2 = function DrawerPanel(props) {
    var prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, containerRef = props.containerRef, id = props.id, onMouseEnter = props.onMouseEnter, onMouseOver = props.onMouseOver, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp;
    var eventHandlers = {
      onMouseEnter,
      onMouseOver,
      onMouseLeave,
      onClick,
      onKeyDown,
      onKeyUp
    };
    var _React$useContext = React__namespace.useContext(RefContext), panelRef = _React$useContext.panel;
    var mergedRef = useComposeRef(panelRef, containerRef);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
      id,
      className: classname("".concat(prefixCls, "-content"), className),
      style: _objectSpread2({}, style2),
      "aria-modal": "true",
      role: "dialog",
      ref: mergedRef
    }, eventHandlers), children));
  };
  function parseWidthHeight(value) {
    if (typeof value === "string" && String(Number(value)) === value) {
      warningOnce(false, "Invalid value type of `width` or `height` which should be number type instead.");
      return Number(value);
    }
    return value;
  }
  var sentinelStyle = {
    width: 0,
    height: 0,
    overflow: "hidden",
    outline: "none",
    position: "absolute"
  };
  function DrawerPopup(props, ref) {
    var _ref, _pushConfig$distance, _pushConfig, _classNames;
    var prefixCls = props.prefixCls, open2 = props.open, placement = props.placement, inline2 = props.inline, push = props.push, forceRender = props.forceRender, autoFocus = props.autoFocus, keyboard = props.keyboard, drawerClassNames = props.classNames, rootClassName = props.rootClassName, rootStyle = props.rootStyle, zIndex = props.zIndex, className = props.className, id = props.id, style2 = props.style, motion2 = props.motion, width = props.width, height = props.height, children = props.children, contentWrapperStyle = props.contentWrapperStyle, mask = props.mask, maskClosable = props.maskClosable, maskMotion = props.maskMotion, maskClassName = props.maskClassName, maskStyle = props.maskStyle, afterOpenChange = props.afterOpenChange, onClose = props.onClose, onMouseEnter = props.onMouseEnter, onMouseOver = props.onMouseOver, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, styles2 = props.styles;
    var panelRef = React__namespace.useRef();
    var sentinelStartRef = React__namespace.useRef();
    var sentinelEndRef = React__namespace.useRef();
    React__namespace.useImperativeHandle(ref, function() {
      return panelRef.current;
    });
    var onPanelKeyDown = function onPanelKeyDown2(event) {
      var keyCode = event.keyCode, shiftKey = event.shiftKey;
      switch (keyCode) {
        case KeyCode.TAB: {
          if (keyCode === KeyCode.TAB) {
            if (!shiftKey && document.activeElement === sentinelEndRef.current) {
              var _sentinelStartRef$cur;
              (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus({
                preventScroll: true
              });
            } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
              var _sentinelEndRef$curre;
              (_sentinelEndRef$curre = sentinelEndRef.current) === null || _sentinelEndRef$curre === void 0 ? void 0 : _sentinelEndRef$curre.focus({
                preventScroll: true
              });
            }
          }
          break;
        }
        case KeyCode.ESC: {
          if (onClose && keyboard) {
            event.stopPropagation();
            onClose(event);
          }
          break;
        }
      }
    };
    React__namespace.useEffect(function() {
      if (open2 && autoFocus) {
        var _panelRef$current;
        (_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.focus({
          preventScroll: true
        });
      }
    }, [open2]);
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), pushed = _React$useState2[0], setPushed = _React$useState2[1];
    var parentContext = React__namespace.useContext(DrawerContext);
    var pushConfig;
    if (push === false) {
      pushConfig = {
        distance: 0
      };
    } else if (push === true) {
      pushConfig = {};
    } else {
      pushConfig = push || {};
    }
    var pushDistance = (_ref = (_pushConfig$distance = (_pushConfig = pushConfig) === null || _pushConfig === void 0 ? void 0 : _pushConfig.distance) !== null && _pushConfig$distance !== void 0 ? _pushConfig$distance : parentContext === null || parentContext === void 0 ? void 0 : parentContext.pushDistance) !== null && _ref !== void 0 ? _ref : 180;
    var mergedContext = React__namespace.useMemo(function() {
      return {
        pushDistance,
        push: function push2() {
          setPushed(true);
        },
        pull: function pull() {
          setPushed(false);
        }
      };
    }, [pushDistance]);
    React__namespace.useEffect(function() {
      if (open2) {
        var _parentContext$push;
        parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$push = parentContext.push) === null || _parentContext$push === void 0 ? void 0 : _parentContext$push.call(parentContext);
      } else {
        var _parentContext$pull;
        parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull = parentContext.pull) === null || _parentContext$pull === void 0 ? void 0 : _parentContext$pull.call(parentContext);
      }
    }, [open2]);
    React__namespace.useEffect(function() {
      return function() {
        var _parentContext$pull2;
        parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull2 = parentContext.pull) === null || _parentContext$pull2 === void 0 ? void 0 : _parentContext$pull2.call(parentContext);
      };
    }, []);
    var maskNode = mask && /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({
      key: "mask"
    }, maskMotion, {
      visible: open2
    }), function(_ref2, maskRef) {
      var motionMaskClassName = _ref2.className, motionMaskStyle = _ref2.style;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        className: classname("".concat(prefixCls, "-mask"), motionMaskClassName, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.mask, maskClassName),
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionMaskStyle), maskStyle), styles2 === null || styles2 === void 0 ? void 0 : styles2.mask),
        onClick: maskClosable && open2 ? onClose : void 0,
        ref: maskRef
      });
    });
    var motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
    var wrapperStyle = {};
    if (pushed && pushDistance) {
      switch (placement) {
        case "top":
          wrapperStyle.transform = "translateY(".concat(pushDistance, "px)");
          break;
        case "bottom":
          wrapperStyle.transform = "translateY(".concat(-pushDistance, "px)");
          break;
        case "left":
          wrapperStyle.transform = "translateX(".concat(pushDistance, "px)");
          break;
        default:
          wrapperStyle.transform = "translateX(".concat(-pushDistance, "px)");
          break;
      }
    }
    if (placement === "left" || placement === "right") {
      wrapperStyle.width = parseWidthHeight(width);
    } else {
      wrapperStyle.height = parseWidthHeight(height);
    }
    var eventHandlers = {
      onMouseEnter,
      onMouseOver,
      onMouseLeave,
      onClick,
      onKeyDown,
      onKeyUp
    };
    var panelNode = /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$7({
      key: "panel"
    }, motionProps, {
      visible: open2,
      forceRender,
      onVisibleChanged: function onVisibleChanged(nextVisible) {
        afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
      },
      removeOnLeave: false,
      leavedClassName: "".concat(prefixCls, "-content-wrapper-hidden")
    }), function(_ref3, motionRef) {
      var motionClassName = _ref3.className, motionStyle = _ref3.style;
      return /* @__PURE__ */ React__namespace.createElement("div", _extends$7({
        className: classname("".concat(prefixCls, "-content-wrapper"), drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.wrapper, motionClassName),
        style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, wrapperStyle), motionStyle), contentWrapperStyle), styles2 === null || styles2 === void 0 ? void 0 : styles2.wrapper)
      }, pickAttrs(props, {
        data: true
      })), /* @__PURE__ */ React__namespace.createElement(DrawerPanel$2, _extends$7({
        id,
        containerRef: motionRef,
        prefixCls,
        className: classname(className, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.content),
        style: _objectSpread2(_objectSpread2({}, style2), styles2 === null || styles2 === void 0 ? void 0 : styles2.content)
      }, eventHandlers), children));
    });
    var containerStyle = _objectSpread2({}, rootStyle);
    if (zIndex) {
      containerStyle.zIndex = zIndex;
    }
    return /* @__PURE__ */ React__namespace.createElement(DrawerContext.Provider, {
      value: mergedContext
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(prefixCls, "".concat(prefixCls, "-").concat(placement), rootClassName, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-open"), open2), _defineProperty$1(_classNames, "".concat(prefixCls, "-inline"), inline2), _classNames)),
      style: containerStyle,
      tabIndex: -1,
      ref: panelRef,
      onKeyDown: onPanelKeyDown
    }, maskNode, /* @__PURE__ */ React__namespace.createElement("div", {
      tabIndex: 0,
      ref: sentinelStartRef,
      style: sentinelStyle,
      "aria-hidden": "true",
      "data-sentinel": "start"
    }), panelNode, /* @__PURE__ */ React__namespace.createElement("div", {
      tabIndex: 0,
      ref: sentinelEndRef,
      style: sentinelStyle,
      "aria-hidden": "true",
      "data-sentinel": "end"
    })));
  }
  var RefDrawerPopup = /* @__PURE__ */ React__namespace.forwardRef(DrawerPopup);
  var Drawer$2 = function Drawer(props) {
    var _props$open = props.open, open2 = _props$open === void 0 ? false : _props$open, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-drawer" : _props$prefixCls, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$width = props.width, width = _props$width === void 0 ? 378 : _props$width, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getContainer3 = props.getContainer, forceRender = props.forceRender, afterOpenChange = props.afterOpenChange, destroyOnClose = props.destroyOnClose, onMouseEnter = props.onMouseEnter, onMouseOver = props.onMouseOver, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, panelRef = props.panelRef;
    var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
    var _React$useState3 = React__namespace.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), mounted = _React$useState4[0], setMounted = _React$useState4[1];
    useLayoutEffect$1(function() {
      setMounted(true);
    }, []);
    var mergedOpen = mounted ? open2 : false;
    var popupRef = React__namespace.useRef();
    var lastActiveRef = React__namespace.useRef();
    useLayoutEffect$1(function() {
      if (mergedOpen) {
        lastActiveRef.current = document.activeElement;
      }
    }, [mergedOpen]);
    var internalAfterOpenChange = function internalAfterOpenChange2(nextVisible) {
      var _popupRef$current;
      setAnimatedVisible(nextVisible);
      afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
      if (!nextVisible && lastActiveRef.current && !((_popupRef$current = popupRef.current) !== null && _popupRef$current !== void 0 && _popupRef$current.contains(lastActiveRef.current))) {
        var _lastActiveRef$curren;
        (_lastActiveRef$curren = lastActiveRef.current) === null || _lastActiveRef$curren === void 0 ? void 0 : _lastActiveRef$curren.focus({
          preventScroll: true
        });
      }
    };
    var refContext = React__namespace.useMemo(function() {
      return {
        panel: panelRef
      };
    }, [panelRef]);
    if (!forceRender && !animatedVisible && !mergedOpen && destroyOnClose) {
      return null;
    }
    var eventHandlers = {
      onMouseEnter,
      onMouseOver,
      onMouseLeave,
      onClick,
      onKeyDown,
      onKeyUp
    };
    var drawerPopupProps = _objectSpread2(_objectSpread2({}, props), {}, {
      open: mergedOpen,
      prefixCls,
      placement,
      autoFocus,
      keyboard,
      width,
      mask,
      maskClosable,
      inline: getContainer3 === false,
      afterOpenChange: internalAfterOpenChange,
      ref: popupRef
    }, eventHandlers);
    return /* @__PURE__ */ React__namespace.createElement(RefContext.Provider, {
      value: refContext
    }, /* @__PURE__ */ React__namespace.createElement(Portal, {
      open: mergedOpen || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer3,
      autoLock: mask && (mergedOpen || animatedVisible)
    }, /* @__PURE__ */ React__namespace.createElement(RefDrawerPopup, drawerPopupProps)));
  };
  const DrawerPanel2 = (props) => {
    var _a, _b;
    const {
      prefixCls,
      title,
      footer,
      extra,
      closeIcon,
      closable,
      onClose,
      headerStyle,
      drawerStyle,
      bodyStyle,
      footerStyle,
      children,
      classNames: drawerClassNames,
      styles: drawerStyles
    } = props;
    const {
      drawer: drawerContext
    } = React__namespace.useContext(ConfigContext);
    const customCloseIconRender = React__namespace.useCallback((icon2) => /* @__PURE__ */ React__namespace.createElement("button", {
      type: "button",
      onClick: onClose,
      "aria-label": "Close",
      className: `${prefixCls}-close`
    }, icon2), [onClose]);
    const [mergedClosable, mergedCloseIcon] = useClosable(closable, closeIcon, customCloseIconRender, void 0, true);
    const headerNode = React__namespace.useMemo(() => {
      var _a2, _b2;
      if (!title && !mergedClosable) {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement("div", {
        style: Object.assign(Object.assign(Object.assign({}, (_a2 = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.styles) === null || _a2 === void 0 ? void 0 : _a2.header), headerStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.header),
        className: classname(`${prefixCls}-header`, {
          [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra
        }, (_b2 = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.classNames) === null || _b2 === void 0 ? void 0 : _b2.header, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.header)
      }, /* @__PURE__ */ React__namespace.createElement("div", {
        className: `${prefixCls}-header-title`
      }, mergedCloseIcon, title && /* @__PURE__ */ React__namespace.createElement("div", {
        className: `${prefixCls}-title`
      }, title)), extra && /* @__PURE__ */ React__namespace.createElement("div", {
        className: `${prefixCls}-extra`
      }, extra));
    }, [mergedClosable, mergedCloseIcon, extra, headerStyle, prefixCls, title]);
    const footerNode = React__namespace.useMemo(() => {
      var _a2, _b2;
      if (!footer) {
        return null;
      }
      const footerClassName = `${prefixCls}-footer`;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        className: classname(footerClassName, (_a2 = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.classNames) === null || _a2 === void 0 ? void 0 : _a2.footer, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.footer),
        style: Object.assign(Object.assign(Object.assign({}, (_b2 = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.styles) === null || _b2 === void 0 ? void 0 : _b2.footer), footerStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.footer)
      }, footer);
    }, [footer, footerStyle, prefixCls]);
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-wrapper-body`,
      style: drawerStyle
    }, headerNode, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classname(`${prefixCls}-body`, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.body, (_a = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.classNames) === null || _a === void 0 ? void 0 : _a.body),
      style: Object.assign(Object.assign(Object.assign({}, (_b = drawerContext === null || drawerContext === void 0 ? void 0 : drawerContext.styles) === null || _b === void 0 ? void 0 : _b.body), bodyStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.body)
    }, children), footerNode);
  };
  const DrawerPanel$1 = DrawerPanel2;
  const genMotionStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow
    } = token2;
    const sharedPanelMotion = {
      "&-enter, &-appear, &-leave": {
        "&-start": {
          transition: "none"
        },
        "&-active": {
          transition: `all ${motionDurationSlow}`
        }
      }
    };
    return {
      [componentCls]: {
        // ======================== Mask ========================
        [`${componentCls}-mask-motion`]: {
          "&-enter, &-appear, &-leave": {
            "&-active": {
              transition: `all ${motionDurationSlow}`
            }
          },
          "&-enter, &-appear": {
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          }
        },
        // ======================= Panel ========================
        [`${componentCls}-panel-motion`]: {
          // Left
          "&-left": [sharedPanelMotion, {
            "&-enter, &-appear": {
              "&-start": {
                transform: "translateX(-100%) !important"
              },
              "&-active": {
                transform: "translateX(0)"
              }
            },
            "&-leave": {
              transform: "translateX(0)",
              "&-active": {
                transform: "translateX(-100%)"
              }
            }
          }],
          // Right
          "&-right": [sharedPanelMotion, {
            "&-enter, &-appear": {
              "&-start": {
                transform: "translateX(100%) !important"
              },
              "&-active": {
                transform: "translateX(0)"
              }
            },
            "&-leave": {
              transform: "translateX(0)",
              "&-active": {
                transform: "translateX(100%)"
              }
            }
          }],
          // Top
          "&-top": [sharedPanelMotion, {
            "&-enter, &-appear": {
              "&-start": {
                transform: "translateY(-100%) !important"
              },
              "&-active": {
                transform: "translateY(0)"
              }
            },
            "&-leave": {
              transform: "translateY(0)",
              "&-active": {
                transform: "translateY(-100%)"
              }
            }
          }],
          // Bottom
          "&-bottom": [sharedPanelMotion, {
            "&-enter, &-appear": {
              "&-start": {
                transform: "translateY(100%) !important"
              },
              "&-active": {
                transform: "translateY(0)"
              }
            },
            "&-leave": {
              transform: "translateY(0)",
              "&-active": {
                transform: "translateY(100%)"
              }
            }
          }]
        }
      }
    };
  };
  const genMotionStyle$1 = genMotionStyle;
  const genDrawerStyle = (token2) => {
    const {
      componentCls,
      zIndexPopup,
      colorBgMask,
      colorBgElevated,
      motionDurationSlow,
      motionDurationMid,
      padding,
      paddingLG,
      fontSizeLG,
      lineHeightLG,
      lineWidth,
      lineType,
      colorSplit,
      marginSM,
      colorIcon,
      colorIconHover,
      colorText,
      fontWeightStrong,
      footerPaddingBlock,
      footerPaddingInline
    } = token2;
    const wrapperCls = `${componentCls}-content-wrapper`;
    return {
      [componentCls]: {
        position: "fixed",
        inset: 0,
        zIndex: zIndexPopup,
        pointerEvents: "none",
        "&-pure": {
          position: "relative",
          background: colorBgElevated,
          [`&${componentCls}-left`]: {
            boxShadow: token2.boxShadowDrawerLeft
          },
          [`&${componentCls}-right`]: {
            boxShadow: token2.boxShadowDrawerRight
          },
          [`&${componentCls}-top`]: {
            boxShadow: token2.boxShadowDrawerUp
          },
          [`&${componentCls}-bottom`]: {
            boxShadow: token2.boxShadowDrawerDown
          }
        },
        "&-inline": {
          position: "absolute"
        },
        // ====================== Mask ======================
        [`${componentCls}-mask`]: {
          position: "absolute",
          inset: 0,
          zIndex: zIndexPopup,
          background: colorBgMask,
          pointerEvents: "auto"
        },
        // ==================== Content =====================
        [wrapperCls]: {
          position: "absolute",
          zIndex: zIndexPopup,
          maxWidth: "100vw",
          transition: `all ${motionDurationSlow}`,
          "&-hidden": {
            display: "none"
          }
        },
        // Placement
        [`&-left > ${wrapperCls}`]: {
          top: 0,
          bottom: 0,
          left: {
            _skip_check_: true,
            value: 0
          },
          boxShadow: token2.boxShadowDrawerLeft
        },
        [`&-right > ${wrapperCls}`]: {
          top: 0,
          right: {
            _skip_check_: true,
            value: 0
          },
          bottom: 0,
          boxShadow: token2.boxShadowDrawerRight
        },
        [`&-top > ${wrapperCls}`]: {
          top: 0,
          insetInline: 0,
          boxShadow: token2.boxShadowDrawerUp
        },
        [`&-bottom > ${wrapperCls}`]: {
          bottom: 0,
          insetInline: 0,
          boxShadow: token2.boxShadowDrawerDown
        },
        [`${componentCls}-content`]: {
          width: "100%",
          height: "100%",
          overflow: "auto",
          background: colorBgElevated,
          pointerEvents: "auto"
        },
        // ===================== Panel ======================
        [`${componentCls}-wrapper-body`]: {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%"
        },
        // Header
        [`${componentCls}-header`]: {
          display: "flex",
          flex: 0,
          alignItems: "center",
          padding: `${padding}px ${paddingLG}px`,
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
          "&-title": {
            display: "flex",
            flex: 1,
            alignItems: "center",
            minWidth: 0,
            minHeight: 0
          }
        },
        [`${componentCls}-extra`]: {
          flex: "none"
        },
        [`${componentCls}-close`]: {
          display: "inline-block",
          marginInlineEnd: marginSM,
          color: colorIcon,
          fontWeight: fontWeightStrong,
          fontSize: fontSizeLG,
          fontStyle: "normal",
          lineHeight: 1,
          textAlign: "center",
          textTransform: "none",
          textDecoration: "none",
          background: "transparent",
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          textRendering: "auto",
          "&:focus, &:hover": {
            color: colorIconHover,
            textDecoration: "none"
          }
        },
        [`${componentCls}-title`]: {
          flex: 1,
          margin: 0,
          color: colorText,
          fontWeight: token2.fontWeightStrong,
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG
        },
        // Body
        [`${componentCls}-body`]: {
          flex: 1,
          minWidth: 0,
          minHeight: 0,
          padding: paddingLG,
          overflow: "auto"
        },
        // Footer
        [`${componentCls}-footer`]: {
          flexShrink: 0,
          padding: `${footerPaddingBlock}px ${footerPaddingInline}px`,
          borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl"
        }
      }
    };
  };
  const useStyle$3 = genComponentStyleHook("Drawer", (token2) => {
    const drawerToken = merge(token2, {});
    return [genDrawerStyle(drawerToken), genMotionStyle$1(drawerToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase,
    footerPaddingBlock: token2.paddingXS,
    footerPaddingInline: token2.padding
  }));
  var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const defaultPushState = {
    distance: 180
  };
  const Drawer2 = (props) => {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    const {
      rootClassName,
      width,
      height,
      size = "default",
      mask = true,
      push = defaultPushState,
      open: open2,
      afterOpenChange,
      onClose,
      prefixCls: customizePrefixCls,
      getContainer: customizeGetContainer,
      style: style2,
      className,
      // Deprecated
      visible,
      afterVisibleChange
    } = props, rest = __rest$7(props, ["rootClassName", "width", "height", "size", "mask", "push", "open", "afterOpenChange", "onClose", "prefixCls", "getContainer", "style", "className", "visible", "afterVisibleChange"]);
    const {
      getPopupContainer,
      getPrefixCls,
      direction,
      drawer
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("drawer", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$3(prefixCls);
    const getContainer3 = (
      // 有可能为 false，所以不能直接判断
      customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer
    );
    const drawerClassName = classname({
      "no-mask": !mask,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, rootClassName, hashId);
    const mergedWidth = React__namespace.useMemo(() => width !== null && width !== void 0 ? width : size === "large" ? 736 : 378, [width, size]);
    const mergedHeight = React__namespace.useMemo(() => height !== null && height !== void 0 ? height : size === "large" ? 736 : 378, [height, size]);
    const maskMotion = {
      motionName: getTransitionName(prefixCls, "mask-motion"),
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      motionDeadline: 500
    };
    const panelMotion = (motionPlacement) => ({
      motionName: getTransitionName(prefixCls, `panel-motion-${motionPlacement}`),
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      motionDeadline: 500
    });
    const panelRef = usePanelRef();
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, /* @__PURE__ */ React__namespace.createElement(NoFormStyle, {
      status: true,
      override: true
    }, /* @__PURE__ */ React__namespace.createElement(Drawer$2, Object.assign({
      prefixCls,
      onClose,
      maskMotion,
      motion: panelMotion
    }, rest, {
      classNames: {
        mask: classname((_b = rest.classNames) === null || _b === void 0 ? void 0 : _b.mask, (_c = drawer === null || drawer === void 0 ? void 0 : drawer.classNames) === null || _c === void 0 ? void 0 : _c.mask),
        content: classname((_d = rest.classNames) === null || _d === void 0 ? void 0 : _d.content, (_e = drawer === null || drawer === void 0 ? void 0 : drawer.classNames) === null || _e === void 0 ? void 0 : _e.content)
      },
      styles: {
        mask: Object.assign(Object.assign({}, (_f = rest.styles) === null || _f === void 0 ? void 0 : _f.mask), (_g = drawer === null || drawer === void 0 ? void 0 : drawer.styles) === null || _g === void 0 ? void 0 : _g.mask),
        content: Object.assign(Object.assign({}, (_h = rest.styles) === null || _h === void 0 ? void 0 : _h.content), (_j = drawer === null || drawer === void 0 ? void 0 : drawer.styles) === null || _j === void 0 ? void 0 : _j.content)
      },
      open: open2 !== null && open2 !== void 0 ? open2 : visible,
      mask,
      push,
      width: mergedWidth,
      height: mergedHeight,
      style: Object.assign(Object.assign({}, drawer === null || drawer === void 0 ? void 0 : drawer.style), style2),
      className: classname(drawer === null || drawer === void 0 ? void 0 : drawer.className, className),
      rootClassName: drawerClassName,
      getContainer: getContainer3,
      afterOpenChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
      panelRef
    }), /* @__PURE__ */ React__namespace.createElement(DrawerPanel$1, Object.assign({
      prefixCls
    }, rest, {
      onClose
    }))))));
  };
  const PurePanel$2 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2,
      className,
      placement = "right"
    } = props, restProps = __rest$7(props, ["prefixCls", "style", "className", "placement"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("drawer", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$3(prefixCls);
    const cls = classname(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, className);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls,
      style: style2
    }, /* @__PURE__ */ React__namespace.createElement(DrawerPanel$1, Object.assign({
      prefixCls
    }, restProps))));
  };
  Drawer2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
  const Drawer$1 = Drawer2;
  const FloatButtonGroupContext = /* @__PURE__ */ React.createContext(void 0);
  const {
    Provider: FloatButtonGroupProvider
  } = FloatButtonGroupContext;
  const FloatButtonGroupContext$1 = FloatButtonGroupContext;
  var FileTextOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
  const FileTextOutlinedSvg = FileTextOutlined$2;
  var FileTextOutlined = function FileTextOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$7({}, props, {
      ref,
      icon: FileTextOutlinedSvg
    }));
  };
  const FileTextOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(FileTextOutlined);
  const FloatButtonContent = (props) => {
    const {
      icon: icon2,
      description,
      prefixCls,
      className
    } = props;
    const defaultElement = /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-icon`
    }, /* @__PURE__ */ React.createElement(FileTextOutlined$1, null));
    return /* @__PURE__ */ React.createElement("div", {
      onClick: props.onClick,
      onFocus: props.onFocus,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      className: classname(className, `${prefixCls}-content`)
    }, icon2 || description ? /* @__PURE__ */ React.createElement(React.Fragment, null, icon2 && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-icon`
    }, icon2), description && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-description`
    }, description)) : defaultElement);
  };
  const Content$1 = /* @__PURE__ */ React.memo(FloatButtonContent);
  const getOffset = (radius) => {
    if (radius === 0) {
      return 0;
    }
    return radius - Math.sqrt(Math.pow(radius, 2) / 2);
  };
  const getOffset$1 = getOffset;
  const initFloatButtonGroupMotion = (token2) => {
    const {
      componentCls,
      floatButtonSize,
      motionDurationSlow,
      motionEaseInOutCirc
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    const moveDownIn2 = new Keyframe("antFloatButtonMoveDownIn", {
      "0%": {
        transform: `translate3d(0, ${floatButtonSize}px, 0)`,
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveDownOut2 = new Keyframe("antFloatButtonMoveDownOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: `translate3d(0, ${floatButtonSize}px, 0)`,
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    return [{
      [`${groupPrefixCls}-wrap`]: Object.assign({}, initMotion(`${groupPrefixCls}-wrap`, moveDownIn2, moveDownOut2, motionDurationSlow, true))
    }, {
      [`${groupPrefixCls}-wrap`]: {
        [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
          opacity: 0,
          animationTimingFunction: motionEaseInOutCirc
        },
        [`&${groupPrefixCls}-wrap-leave`]: {
          animationTimingFunction: motionEaseInOutCirc
        }
      }
    }];
  };
  const floatButtonGroupStyle = (token2) => {
    const {
      antCls,
      componentCls,
      floatButtonSize,
      margin,
      borderRadiusLG,
      borderRadiusSM,
      badgeOffset,
      floatButtonBodyPadding
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    return {
      [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        zIndex: 99,
        display: "block",
        border: "none",
        position: "fixed",
        width: floatButtonSize,
        height: "auto",
        boxShadow: "none",
        minHeight: floatButtonSize,
        insetInlineEnd: token2.floatButtonInsetInlineEnd,
        insetBlockEnd: token2.floatButtonInsetBlockEnd,
        borderRadius: borderRadiusLG,
        [`${groupPrefixCls}-wrap`]: {
          zIndex: -1,
          display: "block",
          position: "relative",
          marginBottom: margin
        },
        [`&${groupPrefixCls}-rtl`]: {
          direction: "rtl"
        },
        [componentCls]: {
          position: "static"
        }
      }),
      [`${groupPrefixCls}-circle`]: {
        [`${componentCls}-circle:not(:last-child)`]: {
          marginBottom: token2.margin,
          [`${componentCls}-body`]: {
            width: floatButtonSize,
            height: floatButtonSize,
            borderRadius: "50%"
          }
        }
      },
      [`${groupPrefixCls}-square`]: {
        [`${componentCls}-square`]: {
          borderRadius: 0,
          padding: 0,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderStartEndRadius: borderRadiusLG
          },
          "&:last-child": {
            borderEndStartRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          },
          "&:not(:last-child)": {
            borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
          },
          [`${antCls}-badge`]: {
            [`${antCls}-badge-count`]: {
              top: -(floatButtonBodyPadding + badgeOffset),
              insetInlineEnd: -(floatButtonBodyPadding + badgeOffset)
            }
          }
        },
        [`${groupPrefixCls}-wrap`]: {
          display: "block",
          borderRadius: borderRadiusLG,
          boxShadow: token2.boxShadowSecondary,
          [`${componentCls}-square`]: {
            boxShadow: "none",
            marginTop: 0,
            borderRadius: 0,
            padding: floatButtonBodyPadding,
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderStartEndRadius: borderRadiusLG
            },
            "&:last-child": {
              borderEndStartRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            },
            "&:not(:last-child)": {
              borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
            },
            [`${componentCls}-body`]: {
              width: token2.floatButtonBodySize,
              height: token2.floatButtonBodySize
            }
          }
        }
      },
      [`${groupPrefixCls}-circle-shadow`]: {
        boxShadow: "none"
      },
      [`${groupPrefixCls}-square-shadow`]: {
        boxShadow: token2.boxShadowSecondary,
        [`${componentCls}-square`]: {
          boxShadow: "none",
          padding: floatButtonBodyPadding,
          [`${componentCls}-body`]: {
            width: token2.floatButtonBodySize,
            height: token2.floatButtonBodySize,
            borderRadius: borderRadiusSM
          }
        }
      }
    };
  };
  const sharedFloatButtonStyle = (token2) => {
    const {
      antCls,
      componentCls,
      floatButtonBodyPadding,
      floatButtonIconSize,
      floatButtonSize,
      borderRadiusLG,
      badgeOffset,
      dotOffsetInSquare,
      dotOffsetInCircle
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        border: "none",
        position: "fixed",
        cursor: "pointer",
        zIndex: 99,
        // Do not remove the 'display: block' here.
        // Deleting it will cause marginBottom to become ineffective.
        // Ref: https://github.com/ant-design/ant-design/issues/44700
        display: "block",
        width: floatButtonSize,
        height: floatButtonSize,
        insetInlineEnd: token2.floatButtonInsetInlineEnd,
        insetBlockEnd: token2.floatButtonInsetBlockEnd,
        boxShadow: token2.boxShadowSecondary,
        // Pure Panel
        "&-pure": {
          position: "relative",
          inset: "auto"
        },
        "&:empty": {
          display: "none"
        },
        [`${antCls}-badge`]: {
          width: "100%",
          height: "100%",
          [`${antCls}-badge-count`]: {
            transform: "translate(0, 0)",
            transformOrigin: "center",
            top: -badgeOffset,
            insetInlineEnd: -badgeOffset
          }
        },
        [`${componentCls}-body`]: {
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          transition: `all ${token2.motionDurationMid}`,
          [`${componentCls}-content`]: {
            overflow: "hidden",
            textAlign: "center",
            minHeight: floatButtonSize,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            padding: `${floatButtonBodyPadding / 2}px ${floatButtonBodyPadding}px`,
            [`${componentCls}-icon`]: {
              textAlign: "center",
              margin: "auto",
              width: floatButtonIconSize,
              fontSize: floatButtonIconSize,
              lineHeight: 1
            }
          }
        }
      }),
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-circle`]: {
        height: floatButtonSize,
        borderRadius: "50%",
        [`${antCls}-badge`]: {
          [`${antCls}-badge-dot`]: {
            top: dotOffsetInCircle,
            insetInlineEnd: dotOffsetInCircle
          }
        },
        [`${componentCls}-body`]: {
          borderRadius: "50%"
        }
      },
      [`${componentCls}-square`]: {
        height: "auto",
        minHeight: floatButtonSize,
        borderRadius: borderRadiusLG,
        [`${antCls}-badge`]: {
          [`${antCls}-badge-dot`]: {
            top: dotOffsetInSquare,
            insetInlineEnd: dotOffsetInSquare
          }
        },
        [`${componentCls}-body`]: {
          height: "auto",
          borderRadius: borderRadiusLG
        }
      },
      [`${componentCls}-default`]: {
        backgroundColor: token2.floatButtonBackgroundColor,
        transition: `background-color ${token2.motionDurationMid}`,
        [`${componentCls}-body`]: {
          backgroundColor: token2.floatButtonBackgroundColor,
          transition: `background-color ${token2.motionDurationMid}`,
          "&:hover": {
            backgroundColor: token2.colorFillContent
          },
          [`${componentCls}-content`]: {
            [`${componentCls}-icon`]: {
              color: token2.colorText
            },
            [`${componentCls}-description`]: {
              display: "flex",
              alignItems: "center",
              lineHeight: `${token2.fontSizeLG}px`,
              color: token2.colorText,
              fontSize: token2.fontSizeSM
            }
          }
        }
      },
      [`${componentCls}-primary`]: {
        backgroundColor: token2.colorPrimary,
        [`${componentCls}-body`]: {
          backgroundColor: token2.colorPrimary,
          transition: `background-color ${token2.motionDurationMid}`,
          "&:hover": {
            backgroundColor: token2.colorPrimaryHover
          },
          [`${componentCls}-content`]: {
            [`${componentCls}-icon`]: {
              color: token2.colorTextLightSolid
            },
            [`${componentCls}-description`]: {
              display: "flex",
              alignItems: "center",
              lineHeight: `${token2.fontSizeLG}px`,
              color: token2.colorTextLightSolid,
              fontSize: token2.fontSizeSM
            }
          }
        }
      }
    };
  };
  const useStyle$2 = genComponentStyleHook("FloatButton", (token2) => {
    const {
      colorTextLightSolid,
      colorBgElevated,
      controlHeightLG,
      marginXXL,
      marginLG,
      fontSize,
      fontSizeIcon,
      controlItemBgHover,
      paddingXXS,
      borderRadiusLG
    } = token2;
    const floatButtonToken = merge(token2, {
      floatButtonBackgroundColor: colorBgElevated,
      floatButtonColor: colorTextLightSolid,
      floatButtonHoverBackgroundColor: controlItemBgHover,
      floatButtonFontSize: fontSize,
      floatButtonIconSize: fontSizeIcon * 1.5,
      floatButtonSize: controlHeightLG,
      floatButtonInsetBlockEnd: marginXXL,
      floatButtonInsetInlineEnd: marginLG,
      floatButtonBodySize: controlHeightLG - paddingXXS * 2,
      // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
      floatButtonBodyPadding: paddingXXS,
      badgeOffset: paddingXXS * 1.5,
      dotOffsetInCircle: getOffset$1(controlHeightLG / 2),
      dotOffsetInSquare: getOffset$1(borderRadiusLG)
    });
    return [floatButtonGroupStyle(floatButtonToken), sharedFloatButtonStyle(floatButtonToken), initFadeMotion(token2), initFloatButtonGroupMotion(floatButtonToken)];
  });
  var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const floatButtonPrefixCls = "float-btn";
  const FloatButton = /* @__PURE__ */ React.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      type: type4 = "default",
      shape = "circle",
      icon: icon2,
      description,
      tooltip,
      badge = {}
    } = props, restProps = __rest$6(props, ["prefixCls", "className", "rootClassName", "type", "shape", "icon", "description", "tooltip", "badge"]);
    const {
      getPrefixCls,
      direction
    } = React.useContext(ConfigContext);
    const groupShape = React.useContext(FloatButtonGroupContext$1);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$2(prefixCls);
    const mergeShape = groupShape || shape;
    const classString = classname(hashId, prefixCls, className, rootClassName, `${prefixCls}-${type4}`, `${prefixCls}-${mergeShape}`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    const badgeProps = React.useMemo(() => omit(badge, ["title", "children", "status", "text"]), [badge]);
    const contentProps = React.useMemo(() => ({
      prefixCls,
      description,
      icon: icon2,
      type: type4
    }), [prefixCls, description, icon2, type4]);
    let buttonNode = /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-body`
    }, /* @__PURE__ */ React.createElement(Content$1, Object.assign({}, contentProps)));
    if ("badge" in props) {
      buttonNode = /* @__PURE__ */ React.createElement(Badge$1, Object.assign({}, badgeProps), buttonNode);
    }
    if ("tooltip" in props) {
      buttonNode = /* @__PURE__ */ React.createElement(Tooltip$1, {
        title: tooltip,
        placement: direction === "rtl" ? "right" : "left"
      }, buttonNode);
    }
    return wrapSSR(props.href ? /* @__PURE__ */ React.createElement("a", Object.assign({
      ref
    }, restProps, {
      className: classString
    }), buttonNode) : /* @__PURE__ */ React.createElement("button", Object.assign({
      ref
    }, restProps, {
      className: classString,
      type: "button"
    }), buttonNode));
  });
  const FloatButton$1 = FloatButton;
  var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const BackTop = /* @__PURE__ */ React.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      type: type4 = "default",
      shape = "circle",
      visibilityHeight = 400,
      icon: icon2 = /* @__PURE__ */ React.createElement(VerticalAlignTopOutlined$1, null),
      target,
      onClick,
      duration = 450
    } = props, restProps = __rest$5(props, ["prefixCls", "className", "type", "shape", "visibilityHeight", "icon", "target", "onClick", "duration"]);
    const [visible, setVisible] = React.useState(visibilityHeight === 0);
    const internalRef = React.useRef(null);
    React.useImperativeHandle(ref, () => ({
      nativeElement: internalRef.current
    }));
    const getDefaultTarget = () => internalRef.current && internalRef.current.ownerDocument ? internalRef.current.ownerDocument : window;
    const handleScroll = throttleByAnimationFrame((e2) => {
      const scrollTop = getScroll(e2.target, true);
      setVisible(scrollTop >= visibilityHeight);
    });
    React.useEffect(() => {
      const getTarget = target || getDefaultTarget;
      const container = getTarget();
      handleScroll({
        target: container
      });
      container === null || container === void 0 ? void 0 : container.addEventListener("scroll", handleScroll);
      return () => {
        handleScroll.cancel();
        container === null || container === void 0 ? void 0 : container.removeEventListener("scroll", handleScroll);
      };
    }, [target]);
    const scrollToTop = (e2) => {
      scrollTo(0, {
        getContainer: target || getDefaultTarget,
        duration
      });
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    };
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const [wrapSSR] = useStyle$2(prefixCls);
    const groupShape = React.useContext(FloatButtonGroupContext$1);
    const mergeShape = groupShape || shape;
    const contentProps = Object.assign({
      prefixCls,
      icon: icon2,
      type: type4,
      shape: mergeShape
    }, restProps);
    return wrapSSR(/* @__PURE__ */ React.createElement(CSSMotion, {
      visible,
      motionName: `${rootPrefixCls}-fade`
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React.createElement(FloatButton$1, Object.assign({
        ref: internalRef
      }, contentProps, {
        onClick: scrollToTop,
        className: classname(className, motionClassName)
      }));
    }));
  });
  const BackTop$1 = BackTop;
  var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const FloatButtonGroup = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      style: style2,
      shape = "circle",
      type: type4 = "default",
      icon: icon2 = /* @__PURE__ */ React.createElement(FileTextOutlined$1, null),
      closeIcon = /* @__PURE__ */ React.createElement(CloseOutlined$1, null),
      description,
      trigger,
      children,
      onOpenChange,
      open: customOpen
    } = props, floatButtonProps = __rest$4(props, ["prefixCls", "className", "style", "shape", "type", "icon", "closeIcon", "description", "trigger", "children", "onOpenChange", "open"]);
    const {
      direction,
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$2(prefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const groupCls = classname(groupPrefixCls, hashId, className, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-${shape}`]: shape,
      [`${groupPrefixCls}-${shape}-shadow`]: !trigger
    });
    const wrapperCls = classname(hashId, `${groupPrefixCls}-wrap`);
    const [open2, setOpen] = useMergedState(false, {
      value: customOpen
    });
    const floatButtonGroupRef = React.useRef(null);
    const floatButtonRef = React.useRef(null);
    const hoverAction = React.useMemo(() => {
      const hoverTypeAction = {
        onMouseEnter() {
          setOpen(true);
          onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(true);
        },
        onMouseLeave() {
          setOpen(false);
          onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
        }
      };
      return trigger === "hover" ? hoverTypeAction : {};
    }, [trigger]);
    const handleOpenChange = () => {
      setOpen((prevState) => {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!prevState);
        return !prevState;
      });
    };
    const onClick = React.useCallback((e2) => {
      var _a, _b;
      if ((_a = floatButtonGroupRef.current) === null || _a === void 0 ? void 0 : _a.contains(e2.target)) {
        if ((_b = floatButtonRef.current) === null || _b === void 0 ? void 0 : _b.contains(e2.target)) {
          handleOpenChange();
        }
        return;
      }
      setOpen(false);
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
    }, [trigger]);
    React.useEffect(() => {
      if (trigger === "click") {
        document.addEventListener("click", onClick);
        return () => {
          document.removeEventListener("click", onClick);
        };
      }
    }, [trigger]);
    return wrapSSR(/* @__PURE__ */ React.createElement(FloatButtonGroupProvider, {
      value: shape
    }, /* @__PURE__ */ React.createElement("div", Object.assign({
      ref: floatButtonGroupRef,
      className: groupCls,
      style: style2
    }, hoverAction), trigger && ["click", "hover"].includes(trigger) ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(CSSMotion, {
      visible: open2,
      motionName: `${groupPrefixCls}-wrap`
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React.createElement("div", {
        className: classname(motionClassName, wrapperCls)
      }, children);
    }), /* @__PURE__ */ React.createElement(FloatButton$1, Object.assign({
      ref: floatButtonRef,
      type: type4,
      shape,
      icon: open2 ? closeIcon : icon2,
      description,
      "aria-label": props["aria-label"]
    }, floatButtonProps))) : children)));
  };
  const FloatButtonGroup$1 = /* @__PURE__ */ React.memo(FloatButtonGroup);
  var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const PureFloatButton = (_a) => {
    var {
      backTop
    } = _a, props = __rest$3(_a, ["backTop"]);
    return backTop ? /* @__PURE__ */ React__namespace.createElement(BackTop$1, Object.assign({}, props, {
      visibilityHeight: 0
    })) : /* @__PURE__ */ React__namespace.createElement(FloatButton$1, Object.assign({}, props));
  };
  const PurePanel = (_a) => {
    var {
      className,
      items
    } = _a, props = __rest$3(_a, ["className", "items"]);
    const {
      prefixCls: customizePrefixCls
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const pureCls = `${prefixCls}-pure`;
    if (items) {
      return /* @__PURE__ */ React__namespace.createElement(FloatButtonGroup$1, Object.assign({
        className: classname(className, pureCls)
      }, props), items.map((item, index2) => /* @__PURE__ */ React__namespace.createElement(PureFloatButton, Object.assign({
        key: index2
      }, item))));
    }
    return /* @__PURE__ */ React__namespace.createElement(PureFloatButton, Object.assign({
      className: classname(className, pureCls)
    }, props));
  };
  const PurePanel$1 = PurePanel;
  FloatButton$1.BackTop = BackTop$1;
  FloatButton$1.Group = FloatButtonGroup$1;
  FloatButton$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
  const antSpinMove = new Keyframe("antSpinMove", {
    to: {
      opacity: 1
    }
  });
  const antRotate = new Keyframe("antRotate", {
    to: {
      transform: "rotate(405deg)"
    }
  });
  const genSpinStyle = (token2) => ({
    [`${token2.componentCls}`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      display: "none",
      color: token2.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "static",
        display: "inline-block",
        opacity: 1
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${token2.componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token2.contentHeight,
          [`${token2.componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: -token2.dotSize / 2
          },
          [`${token2.componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            paddingTop: (token2.dotSize - token2.fontSize) / 2 + 2,
            textShadow: `0 1px 2px ${token2.colorBgContainer}`,
            fontSize: token2.fontSize
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.dotSize / 2) - 10
          },
          "&-sm": {
            [`${token2.componentCls}-dot`]: {
              margin: -token2.dotSizeSM / 2
            },
            [`${token2.componentCls}-text`]: {
              paddingTop: (token2.dotSizeSM - token2.fontSize) / 2 + 2
            },
            [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
              marginTop: -(token2.dotSizeSM / 2) - 10
            }
          },
          "&-lg": {
            [`${token2.componentCls}-dot`]: {
              margin: -(token2.dotSizeLG / 2)
            },
            [`${token2.componentCls}-text`]: {
              paddingTop: (token2.dotSizeLG - token2.fontSize) / 2 + 2
            },
            [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
              marginTop: -(token2.dotSizeLG / 2) - 10
            }
          }
        },
        [`${token2.componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${token2.componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          [`&::after`]: {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      [`&-tip`]: {
        color: token2.spinDotDefault
      },
      // dots
      // ------------------------------
      [`${token2.componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token2.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: (token2.dotSize - token2.marginXXS / 2) / 2,
          height: (token2.dotSize - token2.marginXXS / 2) / 2,
          backgroundColor: token2.colorPrimary,
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      // Sizes
      // ------------------------------
      // small
      [`&-sm ${token2.componentCls}-dot`]: {
        fontSize: token2.dotSizeSM,
        i: {
          width: (token2.dotSizeSM - token2.marginXXS / 2) / 2,
          height: (token2.dotSizeSM - token2.marginXXS / 2) / 2
        }
      },
      // large
      [`&-lg ${token2.componentCls}-dot`]: {
        fontSize: token2.dotSizeLG,
        i: {
          width: (token2.dotSizeLG - token2.marginXXS) / 2,
          height: (token2.dotSizeLG - token2.marginXXS) / 2
        }
      },
      [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
        display: "block"
      }
    })
  });
  const useStyle$1 = genComponentStyleHook("Spin", (token2) => {
    const spinToken = merge(token2, {
      spinDotDefault: token2.colorTextDescription
    });
    return [genSpinStyle(spinToken)];
  }, (token2) => ({
    contentHeight: 400,
    dotSize: token2.controlHeightLG / 2,
    dotSizeSM: token2.controlHeightLG * 0.35,
    dotSizeLG: token2.controlHeight
  }));
  var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  let defaultIndicator = null;
  function renderIndicator(prefixCls, props) {
    const {
      indicator
    } = props;
    const dotClassName = `${prefixCls}-dot`;
    if (indicator === null) {
      return null;
    }
    if (isValidElement(indicator)) {
      return cloneElement(indicator, {
        className: classname(indicator.props.className, dotClassName)
      });
    }
    if (isValidElement(defaultIndicator)) {
      return cloneElement(defaultIndicator, {
        className: classname(defaultIndicator.props.className, dotClassName)
      });
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      className: classname(dotClassName, `${prefixCls}-dot-spin`)
    }, /* @__PURE__ */ React__namespace.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: 1
    }), /* @__PURE__ */ React__namespace.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: 2
    }), /* @__PURE__ */ React__namespace.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: 3
    }), /* @__PURE__ */ React__namespace.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: 4
    }));
  }
  function shouldDelay(spinning, delay) {
    return !!spinning && !!delay && !isNaN(Number(delay));
  }
  const Spin$3 = (props) => {
    const {
      spinPrefixCls: prefixCls,
      spinning: customSpinning = true,
      delay = 0,
      className,
      rootClassName,
      size = "default",
      tip,
      wrapperClassName,
      style: style2,
      children,
      hashId
    } = props, restProps = __rest$2(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
    const [spinning, setSpinning] = React__namespace.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
    React__namespace.useEffect(() => {
      if (customSpinning) {
        const showSpinning = debounce(delay, () => {
          setSpinning(true);
        });
        showSpinning();
        return () => {
          var _a;
          (_a = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(showSpinning);
        };
      }
      setSpinning(false);
    }, [delay, customSpinning]);
    const isNestedPattern = React__namespace.useMemo(() => typeof children !== "undefined", [children]);
    const {
      direction,
      spin
    } = React__namespace.useContext(ConfigContext);
    const spinClassName = classname(prefixCls, spin === null || spin === void 0 ? void 0 : spin.className, {
      [`${prefixCls}-sm`]: size === "small",
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-spinning`]: spinning,
      [`${prefixCls}-show-text`]: !!tip,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId);
    const containerClassName = classname(`${prefixCls}-container`, {
      [`${prefixCls}-blur`]: spinning
    });
    const divProps = omit(restProps, ["indicator", "prefixCls"]);
    const mergedStyle = Object.assign(Object.assign({}, spin === null || spin === void 0 ? void 0 : spin.style), style2);
    const spinElement = /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, divProps, {
      style: mergedStyle,
      className: spinClassName,
      "aria-live": "polite",
      "aria-busy": spinning
    }), renderIndicator(prefixCls, props), tip && isNestedPattern ? /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-text`
    }, tip) : null);
    if (isNestedPattern) {
      return /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, divProps, {
        className: classname(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
      }), spinning && /* @__PURE__ */ React__namespace.createElement("div", {
        key: "loading"
      }, spinElement), /* @__PURE__ */ React__namespace.createElement("div", {
        className: containerClassName,
        key: "container"
      }, children));
    }
    return spinElement;
  };
  const SpinFC = (props) => {
    const {
      prefixCls: customizePrefixCls
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(spinPrefixCls);
    const spinClassProps = Object.assign(Object.assign({}, props), {
      spinPrefixCls,
      hashId
    });
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(Spin$3, Object.assign({}, spinClassProps)));
  };
  SpinFC.setDefaultIndicator = (indicator) => {
    defaultIndicator = indicator;
  };
  const Spin$4 = SpinFC;
  let message = null;
  let act = (callback) => callback();
  let taskQueue = [];
  let defaultGlobalConfig = {};
  function getGlobalContext() {
    const {
      prefixCls: globalPrefixCls2,
      getContainer: globalGetContainer,
      duration,
      rtl,
      maxCount,
      top
    } = defaultGlobalConfig;
    const mergedPrefixCls = globalPrefixCls2 !== null && globalPrefixCls2 !== void 0 ? globalPrefixCls2 : globalConfig().getPrefixCls("message");
    const mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;
    return {
      prefixCls: mergedPrefixCls,
      getContainer: () => mergedContainer,
      duration,
      rtl,
      maxCount,
      top
    };
  }
  const GlobalHolder = /* @__PURE__ */ React__namespace.forwardRef((_, ref) => {
    const [messageConfig, setMessageConfig] = React__namespace.useState(getGlobalContext);
    const [api, holder] = useInternalMessage(messageConfig);
    const global2 = globalConfig();
    const rootPrefixCls = global2.getRootPrefixCls();
    const rootIconPrefixCls = global2.getIconPrefixCls();
    const theme = global2.getTheme();
    const sync = () => {
      setMessageConfig(getGlobalContext);
    };
    React__namespace.useEffect(sync, []);
    React__namespace.useImperativeHandle(ref, () => {
      const instance = Object.assign({}, api);
      Object.keys(instance).forEach((method4) => {
        instance[method4] = function() {
          sync();
          return api[method4].apply(api, arguments);
        };
      });
      return {
        instance,
        sync
      };
    });
    return /* @__PURE__ */ React__namespace.createElement(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: rootIconPrefixCls,
      theme
    }, holder);
  });
  function flushNotice() {
    if (!message) {
      const holderFragment = document.createDocumentFragment();
      const newMessage = {
        fragment: holderFragment
      };
      message = newMessage;
      act(() => {
        render(/* @__PURE__ */ React__namespace.createElement(GlobalHolder, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newMessage.instance && instance) {
                newMessage.instance = instance;
                newMessage.sync = sync;
                flushNotice();
              }
            });
          }
        }), holderFragment);
      });
      return;
    }
    if (!message.instance) {
      return;
    }
    taskQueue.forEach((task) => {
      const {
        type: type4,
        skipped
      } = task;
      if (!skipped) {
        switch (type4) {
          case "open": {
            act(() => {
              const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
              task.setCloseFn(closeFn);
            });
            break;
          }
          case "destroy":
            act(() => {
              message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
            });
            break;
          default: {
            act(() => {
              var _message$instance;
              const closeFn = (_message$instance = message.instance)[type4].apply(_message$instance, _toConsumableArray(task.args));
              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
              task.setCloseFn(closeFn);
            });
          }
        }
      }
    });
    taskQueue = [];
  }
  function setMessageGlobalConfig(config2) {
    defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config2);
    act(() => {
      var _a;
      (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
    });
  }
  function open(config2) {
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: "open",
        config: config2,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue.push(task);
      return () => {
        if (closeFn) {
          act(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushNotice();
    return result;
  }
  function typeOpen(type4, args) {
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: type4,
        args,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue.push(task);
      return () => {
        if (closeFn) {
          act(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushNotice();
    return result;
  }
  function destroy(key) {
    taskQueue.push({
      type: "destroy",
      key
    });
    flushNotice();
  }
  const methods = ["success", "info", "warning", "error", "loading"];
  const baseStaticMethods = {
    open,
    destroy,
    config: setMessageGlobalConfig,
    useMessage,
    _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$7
  };
  const staticMethods = baseStaticMethods;
  methods.forEach((type4) => {
    staticMethods[type4] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return typeOpen(type4, args);
    };
  });
  const message$1 = staticMethods;
  const genBaseStyle = (token2) => {
    const {
      paddingXXS,
      lineWidth,
      tagPaddingHorizontal,
      componentCls
    } = token2;
    const paddingInline = tagPaddingHorizontal - lineWidth;
    const iconMarginInline = paddingXXS - lineWidth;
    return {
      // Result
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-block",
        height: "auto",
        marginInlineEnd: token2.marginXS,
        paddingInline,
        fontSize: token2.tagFontSize,
        lineHeight: token2.tagLineHeight,
        whiteSpace: "nowrap",
        background: token2.defaultBg,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusSM,
        opacity: 1,
        transition: `all ${token2.motionDurationMid}`,
        textAlign: "start",
        position: "relative",
        // RTL
        [`&${componentCls}-rtl`]: {
          direction: "rtl"
        },
        "&, a, a:hover": {
          color: token2.defaultColor
        },
        [`${componentCls}-close-icon`]: {
          marginInlineStart: iconMarginInline,
          color: token2.colorTextDescription,
          fontSize: token2.tagIconSize,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorTextHeading
          }
        },
        [`&${componentCls}-has-color`]: {
          borderColor: "transparent",
          [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
            color: token2.colorTextLightSolid
          }
        },
        [`&-checkable`]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          cursor: "pointer",
          [`&:not(${componentCls}-checkable-checked):hover`]: {
            color: token2.colorPrimary,
            backgroundColor: token2.colorFillSecondary
          },
          "&:active, &-checked": {
            color: token2.colorTextLightSolid
          },
          "&-checked": {
            backgroundColor: token2.colorPrimary,
            "&:hover": {
              backgroundColor: token2.colorPrimaryHover
            }
          },
          "&:active": {
            backgroundColor: token2.colorPrimaryActive
          }
        },
        [`&-hidden`]: {
          display: "none"
        },
        // To ensure that a space will be placed between character and `Icon`.
        [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
          marginInlineStart: paddingInline
        }
      }),
      [`${componentCls}-borderless`]: {
        borderColor: "transparent",
        background: token2.tagBorderlessBg
      }
    };
  };
  const prepareToken = (token2) => {
    const {
      lineWidth,
      fontSizeIcon
    } = token2;
    const tagFontSize = token2.fontSizeSM;
    const tagLineHeight = `${token2.lineHeightSM * tagFontSize}px`;
    const tagToken = merge(token2, {
      tagFontSize,
      tagLineHeight,
      tagIconSize: fontSizeIcon - 2 * lineWidth,
      tagPaddingHorizontal: 8,
      tagBorderlessBg: token2.colorFillTertiary
    });
    return tagToken;
  };
  const prepareCommonToken = (token2) => ({
    defaultBg: token2.colorFillQuaternary,
    defaultColor: token2.colorText
  });
  const useStyle = genComponentStyleHook("Tag", (token2) => {
    const tagToken = prepareToken(token2);
    return genBaseStyle(tagToken);
  }, prepareCommonToken);
  var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const CheckableTag = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2,
      className,
      checked,
      onChange,
      onClick
    } = props, restProps = __rest$1(props, ["prefixCls", "style", "className", "checked", "onChange", "onClick"]);
    const {
      getPrefixCls,
      tag
    } = React__namespace.useContext(ConfigContext);
    const handleClick = (e2) => {
      onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    };
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle(prefixCls);
    const cls = classname(prefixCls, `${prefixCls}-checkable`, {
      [`${prefixCls}-checkable-checked`]: checked
    }, tag === null || tag === void 0 ? void 0 : tag.className, className, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", Object.assign({}, restProps, {
      ref,
      style: Object.assign(Object.assign({}, style2), tag === null || tag === void 0 ? void 0 : tag.style),
      className: cls,
      onClick: handleClick
    })));
  });
  const CheckableTag$1 = CheckableTag;
  const genPresetStyle = (token2) => genPresetColor(token2, (colorKey, _ref) => {
    let {
      textColor,
      lightBorderColor,
      lightColor,
      darkColor
    } = _ref;
    return {
      [`${token2.componentCls}-${colorKey}`]: {
        color: textColor,
        background: lightColor,
        borderColor: lightBorderColor,
        // Inverse color
        "&-inverse": {
          color: token2.colorTextLightSolid,
          background: darkColor,
          borderColor: darkColor
        },
        [`&${token2.componentCls}-borderless`]: {
          borderColor: "transparent"
        }
      }
    };
  });
  const PresetCmp = genSubStyleComponent(["Tag", "preset"], (token2) => {
    const tagToken = prepareToken(token2);
    return genPresetStyle(tagToken);
  }, prepareCommonToken);
  function capitalize$1(str) {
    if (typeof str !== "string") {
      return str;
    }
    const ret = str.charAt(0).toUpperCase() + str.slice(1);
    return ret;
  }
  const genTagStatusStyle = (token2, status, cssVariableType) => {
    const capitalizedCssVariableType = capitalize$1(cssVariableType);
    return {
      [`${token2.componentCls}-${status}`]: {
        color: token2[`color${cssVariableType}`],
        background: token2[`color${capitalizedCssVariableType}Bg`],
        borderColor: token2[`color${capitalizedCssVariableType}Border`],
        [`&${token2.componentCls}-borderless`]: {
          borderColor: "transparent"
        }
      }
    };
  };
  const StatusCmp = genSubStyleComponent(["Tag", "status"], (token2) => {
    const tagToken = prepareToken(token2);
    return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
  }, prepareCommonToken);
  var __rest = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const InternalTag = (tagProps, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      children,
      icon: icon2,
      color,
      onClose,
      closeIcon,
      closable,
      bordered = true
    } = tagProps, props = __rest(tagProps, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "closeIcon", "closable", "bordered"]);
    const {
      getPrefixCls,
      direction,
      tag
    } = React__namespace.useContext(ConfigContext);
    const [visible, setVisible] = React__namespace.useState(true);
    React__namespace.useEffect(() => {
      if ("visible" in props) {
        setVisible(props.visible);
      }
    }, [props.visible]);
    const isPreset = isPresetColor(color);
    const isStatus = isPresetStatusColor(color);
    const isInternalColor = isPreset || isStatus;
    const tagStyle = Object.assign(Object.assign({
      backgroundColor: color && !isInternalColor ? color : void 0
    }, tag === null || tag === void 0 ? void 0 : tag.style), style2);
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle(prefixCls);
    const tagClassName = classname(prefixCls, tag === null || tag === void 0 ? void 0 : tag.className, {
      [`${prefixCls}-${color}`]: isInternalColor,
      [`${prefixCls}-has-color`]: color && !isInternalColor,
      [`${prefixCls}-hidden`]: !visible,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-borderless`]: !bordered
    }, className, rootClassName, hashId);
    const handleCloseClick = (e2) => {
      e2.stopPropagation();
      onClose === null || onClose === void 0 ? void 0 : onClose(e2);
      if (e2.defaultPrevented) {
        return;
      }
      setVisible(false);
    };
    const [, mergedCloseIcon] = useClosable(closable, closeIcon, (iconNode2) => iconNode2 === null ? /* @__PURE__ */ React__namespace.createElement(CloseOutlined$1, {
      className: `${prefixCls}-close-icon`,
      onClick: handleCloseClick
    }) : /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-close-icon`,
      onClick: handleCloseClick
    }, iconNode2), null, false);
    const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
    const iconNode = icon2 || null;
    const kids = iconNode ? /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, iconNode, children && /* @__PURE__ */ React__namespace.createElement("span", null, children)) : children;
    const tagNode = /* @__PURE__ */ React__namespace.createElement("span", Object.assign({}, props, {
      ref,
      className: tagClassName,
      style: tagStyle
    }), kids, mergedCloseIcon, isPreset && /* @__PURE__ */ React__namespace.createElement(PresetCmp, {
      key: "preset",
      prefixCls
    }), isStatus && /* @__PURE__ */ React__namespace.createElement(StatusCmp, {
      key: "status",
      prefixCls
    }));
    return wrapSSR(isNeedWave ? /* @__PURE__ */ React__namespace.createElement(Wave$2, {
      component: "Tag"
    }, tagNode) : tagNode);
  };
  const Tag$2 = /* @__PURE__ */ React__namespace.forwardRef(InternalTag);
  Tag$2.CheckableTag = CheckableTag$1;
  const Tag$3 = Tag$2;
  /* @__PURE__ */ (function(_React$Component) {
    _inherits(DomWrapper2, _React$Component);
    var _super = _createSuper(DomWrapper2);
    function DomWrapper2() {
      _classCallCheck(this, DomWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass(DomWrapper2, [{
      key: "render",
      value: function render2() {
        return this.props.children;
      }
    }]);
    return DomWrapper2;
  })(React.Component);
  var defaultOptions = {
    subtree: true,
    childList: true,
    attributeFilter: ["style", "class"]
  };
  function useMutateObserver(nodeOrList, callback) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions;
    React__namespace.useEffect(function() {
      if (!canUseDom() || !nodeOrList) {
        return;
      }
      var instance;
      var nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
      if ("MutationObserver" in window) {
        instance = new MutationObserver(callback);
        nodeList.forEach(function(element) {
          instance.observe(element, options);
        });
      }
      return function() {
        var _instance, _instance2;
        (_instance = instance) === null || _instance === void 0 ? void 0 : _instance.takeRecords();
        (_instance2 = instance) === null || _instance2 === void 0 ? void 0 : _instance2.disconnect();
      };
    }, [options, nodeOrList]);
  }
  const FontGap = 3;
  function prepareCanvas(width, height) {
    let ratio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const realWidth = width * ratio;
    const realHeight = height * ratio;
    canvas.setAttribute("width", `${realWidth}px`);
    canvas.setAttribute("height", `${realHeight}px`);
    ctx.save();
    return [ctx, canvas, realWidth, realHeight];
  }
  function useClips() {
    function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {
      const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
      if (content instanceof HTMLImageElement) {
        ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
      } else {
        const {
          color,
          fontSize,
          fontStyle,
          fontWeight,
          fontFamily,
          textAlign
        } = font;
        const mergedFontSize = Number(fontSize) * ratio;
        ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
        ctx.fillStyle = color;
        ctx.textAlign = textAlign;
        ctx.textBaseline = "top";
        const contents = Array.isArray(content) ? content : [content];
        contents === null || contents === void 0 ? void 0 : contents.forEach((item, index2) => {
          ctx.fillText(item !== null && item !== void 0 ? item : "", contentWidth / 2, index2 * (mergedFontSize + FontGap * ratio));
        });
      }
      const angle = Math.PI / 180 * Number(rotate);
      const maxSize = Math.max(width, height);
      const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
      rCtx.translate(realMaxSize / 2, realMaxSize / 2);
      rCtx.rotate(angle);
      if (contentWidth > 0 && contentHeight > 0) {
        rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
      }
      function getRotatePos(x, y) {
        const targetX = x * Math.cos(angle) - y * Math.sin(angle);
        const targetY = x * Math.sin(angle) + y * Math.cos(angle);
        return [targetX, targetY];
      }
      let left = 0;
      let right = 0;
      let top = 0;
      let bottom = 0;
      const halfWidth = contentWidth / 2;
      const halfHeight = contentHeight / 2;
      const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];
      points.forEach((_ref) => {
        let [x, y] = _ref;
        const [targetX, targetY] = getRotatePos(x, y);
        left = Math.min(left, targetX);
        right = Math.max(right, targetX);
        top = Math.min(top, targetY);
        bottom = Math.max(bottom, targetY);
      });
      const cutLeft = left + realMaxSize / 2;
      const cutTop = top + realMaxSize / 2;
      const cutWidth = right - left;
      const cutHeight = bottom - top;
      const realGapX = gapX * ratio;
      const realGapY = gapY * ratio;
      const filledWidth = (cutWidth + realGapX) * 2;
      const filledHeight = cutHeight + realGapY;
      const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
      function drawImg() {
        let targetX = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let targetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
      }
      drawImg();
      drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
      drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
      return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
    }
    return getClips;
  }
  function useRafDebounce(callback) {
    const executeRef = React.useRef(false);
    const rafRef = React.useRef();
    const wrapperCallback = useEvent(callback);
    return () => {
      if (executeRef.current) {
        return;
      }
      executeRef.current = true;
      wrapperCallback();
      rafRef.current = wrapperRaf(() => {
        executeRef.current = false;
      });
    };
  }
  function toLowercaseSeparator(key) {
    return key.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
  function getStyleStr(style2) {
    return Object.keys(style2).map((key) => `${toLowercaseSeparator(key)}: ${style2[key]};`).join(" ");
  }
  function getPixelRatio() {
    return window.devicePixelRatio || 1;
  }
  const reRendering = (mutation, isWatermarkEle) => {
    let flag = false;
    if (mutation.removedNodes.length) {
      flag = Array.from(mutation.removedNodes).some((node2) => isWatermarkEle(node2));
    }
    if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) {
      flag = true;
    }
    return flag;
  };
  const EmphasizedStyles = {
    visibility: "visible !important"
  };
  function useWatermark(markStyle) {
    const [watermarkMap] = React__namespace.useState(() => /* @__PURE__ */ new Map());
    const appendWatermark = (base64Url, markWidth, container) => {
      if (container) {
        if (!watermarkMap.get(container)) {
          const newWatermarkEle = document.createElement("div");
          watermarkMap.set(container, newWatermarkEle);
        }
        const watermarkEle = watermarkMap.get(container);
        watermarkEle.setAttribute("style", getStyleStr(Object.assign(Object.assign(Object.assign({}, markStyle), {
          backgroundImage: `url('${base64Url}')`,
          backgroundSize: `${Math.floor(markWidth)}px`
        }), EmphasizedStyles)));
        watermarkEle.removeAttribute("class");
        container.append(watermarkEle);
      }
    };
    const removeWatermark = (container) => {
      const watermarkEle = watermarkMap.get(container);
      if (watermarkEle && container) {
        container.removeChild(watermarkEle);
      }
      watermarkMap.delete(container);
    };
    const isWatermarkEle = (ele) => Array.from(watermarkMap.values()).includes(ele);
    return [appendWatermark, removeWatermark, isWatermarkEle];
  }
  function getSizeDiff(prev2, next2) {
    return prev2.size === next2.size ? prev2 : next2;
  }
  const DEFAULT_GAP_X = 100;
  const DEFAULT_GAP_Y = 100;
  const Watermark = (props) => {
    var _a, _b;
    const {
      /**
       * The antd content layer zIndex is basically below 10
       * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335
       */
      zIndex = 9,
      rotate = -22,
      width,
      height,
      image,
      content,
      font = {},
      style: style2,
      className,
      rootClassName,
      gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],
      offset,
      children
    } = props;
    const [, token2] = useToken();
    const {
      color = token2.colorFill,
      fontSize = token2.fontSizeLG,
      fontWeight = "normal",
      fontStyle = "normal",
      fontFamily = "sans-serif",
      textAlign = "center"
    } = font;
    const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
    const gapXCenter = gapX / 2;
    const gapYCenter = gapY / 2;
    const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;
    const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;
    const markStyle = React.useMemo(() => {
      const mergedStyle = {
        zIndex,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let positionLeft = offsetLeft - gapXCenter;
      let positionTop = offsetTop - gapYCenter;
      if (positionLeft > 0) {
        mergedStyle.left = `${positionLeft}px`;
        mergedStyle.width = `calc(100% - ${positionLeft}px)`;
        positionLeft = 0;
      }
      if (positionTop > 0) {
        mergedStyle.top = `${positionTop}px`;
        mergedStyle.height = `calc(100% - ${positionTop}px)`;
        positionTop = 0;
      }
      mergedStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
      return mergedStyle;
    }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);
    const [container, setContainer] = React.useState();
    const [subElements, setSubElements] = React.useState(/* @__PURE__ */ new Set());
    const targetElements = React.useMemo(() => {
      const list = container ? [container] : [];
      return [].concat(list, _toConsumableArray(Array.from(subElements)));
    }, [container, subElements]);
    const getMarkSize = (ctx) => {
      let defaultWidth = 120;
      let defaultHeight = 64;
      if (!image && ctx.measureText) {
        ctx.font = `${Number(fontSize)}px ${fontFamily}`;
        const contents = Array.isArray(content) ? content : [content];
        const sizes = contents.map((item) => {
          const metrics = ctx.measureText(item);
          return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
        });
        defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map((size) => size[0]))));
        defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map((size) => size[1])))) * contents.length + (contents.length - 1) * FontGap;
      }
      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];
    };
    const getClips = useClips();
    const [watermarkInfo, setWatermarkInfo] = React.useState(null);
    const renderWatermark = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (ctx) {
        const ratio = getPixelRatio();
        const [markWidth, markHeight] = getMarkSize(ctx);
        const drawCanvas = (drawContent) => {
          const [nextClips, clipWidth] = getClips(drawContent || "", rotate, ratio, markWidth, markHeight, {
            color,
            fontSize,
            fontStyle,
            fontWeight,
            fontFamily,
            textAlign
          }, gapX, gapY);
          setWatermarkInfo([nextClips, clipWidth]);
        };
        if (image) {
          const img = new Image();
          img.onload = () => {
            drawCanvas(img);
          };
          img.onerror = () => {
            drawCanvas(content);
          };
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = image;
        } else {
          drawCanvas(content);
        }
      }
    };
    const syncWatermark = useRafDebounce(renderWatermark);
    const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);
    React.useEffect(() => {
      if (watermarkInfo) {
        targetElements.forEach((holder) => {
          appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
        });
      }
    }, [watermarkInfo, targetElements]);
    const onMutate = (mutations) => {
      mutations.forEach((mutation) => {
        if (reRendering(mutation, isWatermarkEle)) {
          syncWatermark();
        }
      });
    };
    useMutateObserver(targetElements, onMutate);
    React.useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);
    const watermarkContext = React.useMemo(() => ({
      add: (ele) => {
        setSubElements((prev2) => {
          const clone = new Set(prev2);
          clone.add(ele);
          return getSizeDiff(prev2, clone);
        });
      },
      remove: (ele) => {
        removeWatermark(ele);
        setSubElements((prev2) => {
          const clone = new Set(prev2);
          clone.delete(ele);
          return getSizeDiff(prev2, clone);
        });
      }
    }), []);
    return /* @__PURE__ */ React.createElement("div", {
      ref: setContainer,
      className: classname(className, rootClassName),
      style: Object.assign({
        position: "relative"
      }, style2)
    }, /* @__PURE__ */ React.createElement(WatermarkContext.Provider, {
      value: watermarkContext
    }, children));
  };
  const Watermark$1 = Watermark;
  var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
  var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
  var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array4, setter, iteratee, accumulator) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index2 < length2) {
          var value = array4[index2];
          setter(accumulator, value, iteratee(value), array4);
        }
        return accumulator;
      }
      function arrayEach(array4, iteratee) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index2 < length2) {
          if (iteratee(array4[index2], index2, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function arrayEachRight(array4, iteratee) {
        var length2 = array4 == null ? 0 : array4.length;
        while (length2--) {
          if (iteratee(array4[length2], length2, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function arrayEvery(array4, predicate) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index2 < length2) {
          if (!predicate(array4[index2], index2, array4)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array4, predicate) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array4[index2];
          if (predicate(value, index2, array4)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array4, value) {
        var length2 = array4 == null ? 0 : array4.length;
        return !!length2 && baseIndexOf(array4, value, 0) > -1;
      }
      function arrayIncludesWith(array4, value, comparator) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index2 < length2) {
          if (comparator(value, array4[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array4, iteratee) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length, result = Array(length2);
        while (++index2 < length2) {
          result[index2] = iteratee(array4[index2], index2, array4);
        }
        return result;
      }
      function arrayPush(array4, values) {
        var index2 = -1, length2 = values.length, offset = array4.length;
        while (++index2 < length2) {
          array4[offset + index2] = values[index2];
        }
        return array4;
      }
      function arrayReduce(array4, iteratee, accumulator, initAccum) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        if (initAccum && length2) {
          accumulator = array4[++index2];
        }
        while (++index2 < length2) {
          accumulator = iteratee(accumulator, array4[index2], index2, array4);
        }
        return accumulator;
      }
      function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
        var length2 = array4 == null ? 0 : array4.length;
        if (initAccum && length2) {
          accumulator = array4[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array4[length2], length2, array4);
        }
        return accumulator;
      }
      function arraySome(array4, predicate) {
        var index2 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index2 < length2) {
          if (predicate(array4[index2], index2, array4)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array4, predicate, fromIndex, fromRight) {
        var length2 = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (predicate(array4[index2], index2, array4)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array4, value, fromIndex) {
        return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array4, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length2 = array4.length;
        while (++index2 < length2) {
          if (comparator(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array4, iteratee) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseSum(array4, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object4) {
          return object4 == null ? undefined$1 : object4[key];
        };
      }
      function basePropertyOf(object4) {
        return function(key) {
          return object4 == null ? undefined$1 : object4[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array4, comparer) {
        var length2 = array4.length;
        array4.sort(comparer);
        while (length2--) {
          array4[length2] = array4[length2].value;
        }
        return array4;
      }
      function baseSum(array4, iteratee) {
        var result, index2 = -1, length2 = array4.length;
        while (++index2 < length2) {
          var current = iteratee(array4[index2]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object4, props) {
        return arrayMap(props, function(key) {
          return [key, object4[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object4, props) {
        return arrayMap(props, function(key) {
          return object4[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length2 = strSymbols.length;
        while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array4, placeholder) {
        var length2 = array4.length, result = 0;
        while (length2--) {
          if (array4[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object4, key) {
        return object4 == null ? undefined$1 : object4[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array4, placeholder) {
        var index2 = -1, length2 = array4.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array4[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array4[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array4, value, fromIndex) {
        var index2 = fromIndex - 1, length2 = array4.length;
        while (++index2 < length2) {
          if (array4[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array4, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array4[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index2 = string3.length;
        while (index2-- && reWhitespace.test(string3.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context2) {
        context2 = context2 == null ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps));
        var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context2["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object4() {
          }
          return function(proto) {
            if (!isObject3(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object4.prototype = proto;
            var result2 = new object4();
            object4.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array4, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array4[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type4 = data.type, computed = iteratee2(value);
                if (type4 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type4 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined$1 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length2) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array4) {
          var length2 = array4.length;
          return length2 ? array4[baseRandom(0, length2 - 1)] : undefined$1;
        }
        function arraySampleSize(array4, n2) {
          return shuffleSelf(copyArray(array4), baseClamp(n2, 0, array4.length));
        }
        function arrayShuffle(array4) {
          return shuffleSelf(copyArray(array4));
        }
        function assignMergeValue(object4, key, value) {
          if (value !== undefined$1 && !eq(object4[key], value) || value === undefined$1 && !(key in object4)) {
            baseAssignValue(object4, key, value);
          }
        }
        function assignValue(object4, key, value) {
          var objValue = object4[key];
          if (!(hasOwnProperty2.call(object4, key) && eq(objValue, value)) || value === undefined$1 && !(key in object4)) {
            baseAssignValue(object4, key, value);
          }
        }
        function assocIndexOf(array4, key) {
          var length2 = array4.length;
          while (length2--) {
            if (eq(array4[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object4, source) {
          return object4 && copyObject(source, keys2(source), object4);
        }
        function baseAssignIn(object4, source) {
          return object4 && copyObject(source, keysIn(source), object4);
        }
        function baseAssignValue(object4, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object4, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object4[key] = value;
          }
        }
        function baseAt(object4, paths) {
          var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object4 == null;
          while (++index2 < length2) {
            result2[index2] = skip ? undefined$1 : get2(object4, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number4, lower, upper) {
          if (number4 === number4) {
            if (upper !== undefined$1) {
              number4 = number4 <= upper ? number4 : upper;
            }
            if (lower !== undefined$1) {
              number4 = number4 >= lower ? number4 : lower;
            }
          }
          return number4;
        }
        function baseClone(value, bitmask, customizer, key, object4, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object4 ? customizer(value, key, object4, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject3(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc3 = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc3 && !object4) {
              result2 = isFlat || isFunc3 ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object4 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object4) {
            return baseConformsTo(object4, source, props);
          };
        }
        function baseConformsTo(object4, source, props) {
          var length2 = props.length;
          if (object4 == null) {
            return !length2;
          }
          object4 = Object2(object4);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object4[key];
            if (value === undefined$1 && !(key in object4) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array4, values2, iteratee2, comparator) {
          var index2 = -1, includes3 = arrayIncludes, isCommon = true, length2 = array4.length, result2 = [], valuesLength = values2.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length2) {
              var value = array4[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes3(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array4, iteratee2, comparator) {
          var index2 = -1, length2 = array4.length;
          while (++index2 < length2) {
            var value = array4[index2], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array4, value, start, end) {
          var length2 = array4.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
          if (end < 0) {
            end += length2;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array4[start++] = value;
          }
          return array4;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array4, depth, predicate, isStrict, result2) {
          var index2 = -1, length2 = array4.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length2) {
            var value = array4[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object4, iteratee2) {
          return object4 && baseFor(object4, iteratee2, keys2);
        }
        function baseForOwnRight(object4, iteratee2) {
          return object4 && baseForRight(object4, iteratee2, keys2);
        }
        function baseFunctions(object4, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object4[key]);
          });
        }
        function baseGet(object4, path) {
          path = castPath(path, object4);
          var index2 = 0, length2 = path.length;
          while (object4 != null && index2 < length2) {
            object4 = object4[toKey(path[index2++])];
          }
          return index2 && index2 == length2 ? object4 : undefined$1;
        }
        function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object4);
          return isArray2(object4) ? result2 : arrayPush(result2, symbolsFunc(object4));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object4, key) {
          return object4 != null && hasOwnProperty2.call(object4, key);
        }
        function baseHasIn(object4, key) {
          return object4 != null && key in Object2(object4);
        }
        function baseInRange(number4, start, end) {
          return number4 >= nativeMin(start, end) && number4 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array4 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array4 = arrayMap(array4, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array4.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined$1;
          }
          array4 = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length2 && result2.length < maxLength) {
              var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object4, setter, iteratee2, accumulator) {
          baseForOwn(object4, function(value, key, object5) {
            setter(accumulator, iteratee2(value), key, object5);
          });
          return accumulator;
        }
        function baseInvoke(object4, path, args) {
          path = castPath(path, object4);
          object4 = parent(object4, path);
          var func = object4 == null ? object4 : object4[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object4, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object4), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object4)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object4, source, matchData, customizer) {
          var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
          if (object4 == null) {
            return !length2;
          }
          object4 = Object2(object4);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
              return false;
            }
          }
          while (++index2 < length2) {
            data = matchData[index2];
            var key = data[0], objValue = object4[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object4)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object4, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject3(value) || isMasked(value)) {
            return false;
          }
          var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern4.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object4) {
          if (!isPrototype(object4)) {
            return nativeKeys(object4);
          }
          var result2 = [];
          for (var key in Object2(object4)) {
            if (hasOwnProperty2.call(object4, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object4) {
          if (!isObject3(object4)) {
            return nativeKeysIn(object4);
          }
          var isProto = isPrototype(object4), result2 = [];
          for (var key in object4) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object4, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object4) {
            return object4 === source || baseIsMatch(object4, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object4) {
            var objValue = get2(object4, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object4, source, srcIndex, customizer, stack) {
          if (object4 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject3(srcValue)) {
              baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object4, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object4, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject3(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object4, key, newValue);
        }
        function baseNth(array4, n2) {
          var length2 = array4.length;
          if (!length2) {
            return;
          }
          n2 += n2 < 0 ? length2 : 0;
          return isIndex(n2, length2) ? array4[n2] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object4, other) {
            return compareMultiple(object4, other, orders);
          });
        }
        function basePick(object4, paths) {
          return basePickBy(object4, paths, function(value, path) {
            return hasIn(object4, path);
          });
        }
        function basePickBy(object4, paths, predicate) {
          var index2 = -1, length2 = paths.length, result2 = {};
          while (++index2 < length2) {
            var path = paths[index2], value = baseGet(object4, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object4), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object4) {
            return baseGet(object4, path);
          };
        }
        function basePullAll(array4, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array4;
          if (array4 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array4, baseUnary(iteratee2));
          }
          while (++index2 < length2) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array4) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array4, fromIndex, 1);
            }
          }
          return array4;
        }
        function basePullAt(array4, indexes) {
          var length2 = array4 ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index2 = indexes[length2];
            if (length2 == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array4, index2, 1);
              } else {
                baseUnset(array4, index2);
              }
            }
          }
          return array4;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string3, n2) {
          var result2 = "";
          if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string3;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string3 += string3;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array4 = values(collection);
          return shuffleSelf(array4, baseClamp(n2, 0, array4.length));
        }
        function baseSet(object4, path, value, customizer) {
          if (!isObject3(object4)) {
            return object4;
          }
          path = castPath(path, object4);
          var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object4;
          while (nested != null && ++index2 < length2) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object4;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object4;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string3) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array4, start, end) {
          var index2 = -1, length2 = array4.length;
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length2);
          while (++index2 < length2) {
            result2[index2] = array4[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array4, value, retHighest) {
          var low = 0, high = array4 == null ? low : array4.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array4[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array4, value, identity, retHighest);
        }
        function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
          var low = 0, high = array4 == null ? 0 : array4.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array4, iteratee2) {
          var index2 = -1, length2 = array4.length, resIndex = 0, result2 = [];
          while (++index2 < length2) {
            var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array4, iteratee2, comparator) {
          var index2 = -1, includes3 = arrayIncludes, length2 = array4.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array4);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length2) {
              var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object4, path) {
          path = castPath(path, object4);
          object4 = parent(object4, path);
          return object4 == null || delete object4[toKey(last(path))];
        }
        function baseUpdate(object4, path, updater, customizer) {
          return baseSet(object4, path, updater(baseGet(object4, path)), customizer);
        }
        function baseWhile(array4, predicate, isDrop, fromRight) {
          var length2 = array4.length, index2 = fromRight ? length2 : -1;
          while ((fromRight ? index2-- : ++index2 < length2) && predicate(array4[index2], index2, array4)) {
          }
          return isDrop ? baseSlice(array4, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array4, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length2);
          while (++index2 < length2) {
            var array4 = arrays[index2], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array4, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length2) {
            var value = index2 < valsLength ? values2[index2] : undefined$1;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object4) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object4) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array4, start, end) {
          var length2 = array4.length;
          end = end === undefined$1 ? length2 : end;
          return !start && end >= length2 ? array4 : baseSlice(array4, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp4) {
          var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
          result2.lastIndex = regexp4.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object4, other, orders) {
          var index2 = -1, objCriteria = object4.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length2) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object4.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array4) {
          var index2 = -1, length2 = source.length;
          array4 || (array4 = Array2(length2));
          while (++index2 < length2) {
            array4[index2] = source[index2];
          }
          return array4;
        }
        function copyObject(source, props, object4, customizer) {
          var isNew = !object4;
          object4 || (object4 = {});
          var index2 = -1, length2 = props.length;
          while (++index2 < length2) {
            var key = props[index2];
            var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object4, key, newValue);
            } else {
              assignValue(object4, key, newValue);
            }
          }
          return object4;
        }
        function copySymbols(source, object4) {
          return copyObject(source, getSymbols(source), object4);
        }
        function copySymbolsIn(source, object4) {
          return copyObject(source, getSymbolsIn(source), object4);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object4, sources) {
            var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined$1 : customizer;
              length2 = 1;
            }
            object4 = Object2(object4);
            while (++index2 < length2) {
              var source = sources[index2];
              if (source) {
                assigner(object4, source, index2, customizer);
              }
            }
            return object4;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length2) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object4, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object4), props = keysFunc(object4), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object4;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject3(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length2
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length2;
            while (++index2 < length2) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
              while (++index3 < length2) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index2 = length2;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object4, iteratee2) {
            return baseInverter(object4, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number4, precision2) {
            number4 = toNumber(number4);
            precision2 = precision2 == null ? 0 : nativeMin(toInteger(precision2), 292);
            if (precision2 && nativeIsFinite(number4)) {
              var pair = (toString(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision2));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision2));
            }
            return func(number4);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object4) {
            var tag = getTag(object4);
            if (tag == mapTag) {
              return mapToArray(object4);
            }
            if (tag == setTag) {
              return setToPairs(object4);
            }
            return baseToPairs(object4, keysFunc(object4));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object4) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object4, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object4, source, stack) {
          if (isObject3(objValue) && isObject3(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }
        function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array4);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array4;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array4, other);
          stack.set(other, array4);
          while (++index2 < arrLength) {
            var arrValue = array4[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array4);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
                return false;
              }
              object4 = object4.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object4), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object4, +other);
            case errorTag:
              return object4.name == other.name && object4.message == other.message;
            case regexpTag:
            case stringTag:
              return object4 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object4.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object4);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object4, other);
              var result2 = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object4);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object4) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object4);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object4;
          }
          var result2 = true;
          stack.set(object4, other);
          stack.set(other, object4);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object4[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object4.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object4);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object4) {
          return baseGetAllKeys(object4, keys2, getSymbols);
        }
        function getAllKeysIn(object4) {
          return baseGetAllKeys(object4, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array4 = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array4.length : 0;
          while (length2--) {
            var data = array4[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object4 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object4.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object4) {
          var result2 = keys2(object4), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object4[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object4, key) {
          var value = getValue2(object4, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object4) {
          if (object4 == null) {
            return [];
          }
          object4 = Object2(object4);
          return arrayFilter(nativeGetSymbols(object4), function(symbol) {
            return propertyIsEnumerable.call(object4, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
          var result2 = [];
          while (object4) {
            arrayPush(result2, getSymbols(object4));
            object4 = getPrototype(object4);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length2 = transforms.length;
          while (++index2 < length2) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object4, path, hasFunc) {
          path = castPath(path, object4);
          var index2 = -1, length2 = path.length, result2 = false;
          while (++index2 < length2) {
            var key = toKey(path[index2]);
            if (!(result2 = object4 != null && hasFunc(object4, key))) {
              break;
            }
            object4 = object4[key];
          }
          if (result2 || ++index2 != length2) {
            return result2;
          }
          length2 = object4 == null ? 0 : object4.length;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray2(object4) || isArguments(object4));
        }
        function initCloneArray(array4) {
          var length2 = array4.length, result2 = new array4.constructor(length2);
          if (length2 && typeof array4[0] == "string" && hasOwnProperty2.call(array4, "index")) {
            result2.index = array4.index;
            result2.input = array4.input;
          }
          return result2;
        }
        function initCloneObject(object4) {
          return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
        }
        function initCloneByTag(object4, tag, isDeep) {
          var Ctor = object4.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object4);
            case boolTag:
            case dateTag:
              return new Ctor(+object4);
            case dataViewTag:
              return cloneDataView(object4, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object4, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object4);
            case regexpTag:
              return cloneRegExp(object4);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object4);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length2) {
          var type4 = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index2, object4) {
          if (!isObject3(object4)) {
            return false;
          }
          var type4 = typeof index2;
          if (type4 == "number" ? isArrayLike(object4) && isIndex(index2, object4.length) : type4 == "string" && index2 in object4) {
            return eq(object4[index2], value);
          }
          return false;
        }
        function isKey(value, object4) {
          if (isArray2(value)) {
            return false;
          }
          var type4 = typeof value;
          if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object2(object4);
        }
        function isKeyable(value) {
          var type4 = typeof value;
          return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject3(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object4) {
            if (object4 == null) {
              return false;
            }
            return object4[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object4));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object4) {
          var result2 = [];
          if (object4 != null) {
            for (var key in Object2(object4)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array4 = Array2(length2);
            while (++index2 < length2) {
              array4[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform3(array4);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object4, path) {
          return path.length < 2 ? object4 : baseGet(object4, baseSlice(path, 0, -1));
        }
        function reorder(array4, indexes) {
          var arrLength = array4.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array4);
          while (length2--) {
            var index2 = indexes[length2];
            array4[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
          }
          return array4;
        }
        function safeGet(object4, key) {
          if (key === "constructor" && typeof object4[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object4[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array4, size2) {
          var index2 = -1, length2 = array4.length, lastIndex = length2 - 1;
          size2 = size2 === undefined$1 ? length2 : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array4[rand];
            array4[rand] = array4[index2];
            array4[index2] = value;
          }
          array4.length = size2;
          return array4;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match2, number4, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array4, size2, guard) {
          if (guard ? isIterateeCall(array4, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index2 < length2) {
            result2[resIndex++] = baseSlice(array4, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array4) {
          var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
          while (++index2 < length2) {
            var value = array4[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array4 = arguments[0], index2 = length2;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array4) ? copyArray(array4) : [array4], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array4, values2) {
          return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array4, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array4, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array4, n2, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array4, n2 < 0 ? 0 : n2, length2);
        }
        function dropRight(array4, n2, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length2 - n2;
          return baseSlice(array4, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true) : [];
        }
        function fill(array4, value, start, end) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array4, value, start)) {
            start = 0;
            end = length2;
          }
          return baseFill(array4, value, start, end);
        }
        function findIndex(array4, predicate, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length2 + index2, 0);
          }
          return baseFindIndex(array4, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array4, predicate, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index2 = length2 - 1;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
          }
          return baseFindIndex(array4, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseFlatten(array4, 1) : [];
        }
        function flattenDeep(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseFlatten(array4, INFINITY) : [];
        }
        function flattenDepth(array4, depth) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array4, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length2) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array4) {
          return array4 && array4.length ? array4[0] : undefined$1;
        }
        function indexOf(array4, value, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length2 + index2, 0);
          }
          return baseIndexOf(array4, value, index2);
        }
        function initial(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseSlice(array4, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array4, separator) {
          return array4 == null ? "" : nativeJoin.call(array4, separator);
        }
        function last(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? array4[length2 - 1] : undefined$1;
        }
        function lastIndexOf(array4, value, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index2 = length2;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array4, value, index2) : baseFindIndex(array4, baseIsNaN, index2, true);
        }
        function nth(array4, n2) {
          return array4 && array4.length ? baseNth(array4, toInteger(n2)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array4, values2) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
        }
        function pullAllBy(array4, values2, iteratee2) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
        }
        function pullAllWith(array4, values2, comparator) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined$1, comparator) : array4;
        }
        var pullAt = flatRest(function(array4, indexes) {
          var length2 = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
          basePullAt(array4, arrayMap(indexes, function(index2) {
            return isIndex(index2, length2) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array4, predicate) {
          var result2 = [];
          if (!(array4 && array4.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length2 = array4.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length2) {
            var value = array4[index2];
            if (predicate(value, index2, array4)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array4, indexes);
          return result2;
        }
        function reverse(array4) {
          return array4 == null ? array4 : nativeReverse.call(array4);
        }
        function slice2(array4, start, end) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array4, start, end)) {
            start = 0;
            end = length2;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length2 : toInteger(end);
          }
          return baseSlice(array4, start, end);
        }
        function sortedIndex(array4, value) {
          return baseSortedIndex(array4, value);
        }
        function sortedIndexBy(array4, value, iteratee2) {
          return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array4, value) {
          var length2 = array4 == null ? 0 : array4.length;
          if (length2) {
            var index2 = baseSortedIndex(array4, value);
            if (index2 < length2 && eq(array4[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array4, value) {
          return baseSortedIndex(array4, value, true);
        }
        function sortedLastIndexBy(array4, value, iteratee2) {
          return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array4, value) {
          var length2 = array4 == null ? 0 : array4.length;
          if (length2) {
            var index2 = baseSortedIndex(array4, value, true) - 1;
            if (eq(array4[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array4) {
          return array4 && array4.length ? baseSortedUniq(array4) : [];
        }
        function sortedUniqBy(array4, iteratee2) {
          return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseSlice(array4, 1, length2) : [];
        }
        function take(array4, n2, guard) {
          if (!(array4 && array4.length)) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array4, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array4, n2, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length2 - n2;
          return baseSlice(array4, n2 < 0 ? 0 : n2, length2);
        }
        function takeRightWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array4) {
          return array4 && array4.length ? baseUniq(array4) : [];
        }
        function uniqBy(array4, iteratee2) {
          return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array4, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array4 && array4.length ? baseUniq(array4, undefined$1, comparator) : [];
        }
        function unzip(array4) {
          if (!(array4 && array4.length)) {
            return [];
          }
          var length2 = 0;
          array4 = arrayFilter(array4, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index2) {
            return arrayMap(array4, baseProperty(index2));
          });
        }
        function unzipWith(array4, iteratee2) {
          if (!(array4 && array4.length)) {
            return [];
          }
          var result2 = unzip(array4);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array4, values2) {
          return isArrayLikeObject(array4) ? baseDifference(array4, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object4) {
            return baseAt(object4, paths);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array4) {
            if (length2 && !array4.length) {
              array4.push(undefined$1);
            }
            return array4;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes2(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString4(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc3 = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc3 ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString4(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined$1 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object4, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object4, partials, holders);
        });
        function curry2(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry2.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject3(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index2 < length2) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array4 = args[start], otherArgs = castSlice(args, 0, start);
            if (array4) {
              arrayPush(otherArgs, array4);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject3(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object4, source) {
          return source == null || baseConformsTo(object4, source, keys2(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty3(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject3(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject3(value) {
          var type4 = typeof value;
          return value != null && (type4 == "object" || type4 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object4, source) {
          return object4 === source || baseIsMatch(object4, source, getMatchData(source));
        }
        function isMatchWith(object4, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object4, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString4(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString4(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject3(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject3(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object4, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys2(source), object4);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object4, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object4, source) {
          copyObject(source, keysIn(source), object4);
        });
        var assignInWith = createAssigner(function(object4, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object4, customizer);
        });
        var assignWith = createAssigner(function(object4, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object4, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object4, sources) {
          object4 = Object2(object4);
          var index2 = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index2 < length2) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object4[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object4, key)) {
                object4[key] = source[key];
              }
            }
          }
          return object4;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object4, predicate) {
          return baseFindKey(object4, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object4, predicate) {
          return baseFindKey(object4, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object4, iteratee2) {
          return object4 == null ? object4 : baseFor(object4, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object4, iteratee2) {
          return object4 == null ? object4 : baseForRight(object4, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object4, iteratee2) {
          return object4 && baseForOwn(object4, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object4, iteratee2) {
          return object4 && baseForOwnRight(object4, getIteratee(iteratee2, 3));
        }
        function functions(object4) {
          return object4 == null ? [] : baseFunctions(object4, keys2(object4));
        }
        function functionsIn(object4) {
          return object4 == null ? [] : baseFunctions(object4, keysIn(object4));
        }
        function get2(object4, path, defaultValue) {
          var result2 = object4 == null ? undefined$1 : baseGet(object4, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object4, path) {
          return object4 != null && hasPath(object4, path, baseHas);
        }
        function hasIn(object4, path) {
          return object4 != null && hasPath(object4, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object4) {
          return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
        }
        function keysIn(object4) {
          return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
        }
        function mapKeys(object4, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object4, function(value, key, object5) {
            baseAssignValue(result2, iteratee2(value, key, object5), value);
          });
          return result2;
        }
        function mapValues(object4, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object4, function(value, key, object5) {
            baseAssignValue(result2, key, iteratee2(value, key, object5));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object4, source, srcIndex) {
          baseMerge(object4, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object4, source, srcIndex, customizer) {
          baseMerge(object4, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object4, paths) {
          var result2 = {};
          if (object4 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object4);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object4, getAllKeysIn(object4), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object4, predicate) {
          return pickBy(object4, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object4, paths) {
          return object4 == null ? {} : basePick(object4, paths);
        });
        function pickBy(object4, predicate) {
          if (object4 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object4), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object4, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object4, path, defaultValue) {
          path = castPath(path, object4);
          var index2 = -1, length2 = path.length;
          if (!length2) {
            length2 = 1;
            object4 = undefined$1;
          }
          while (++index2 < length2) {
            var value = object4 == null ? undefined$1 : object4[toKey(path[index2])];
            if (value === undefined$1) {
              index2 = length2;
              value = defaultValue;
            }
            object4 = isFunction(value) ? value.call(object4) : value;
          }
          return object4;
        }
        function set2(object4, path, value) {
          return object4 == null ? object4 : baseSet(object4, path, value);
        }
        function setWith(object4, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object4 == null ? object4 : baseSet(object4, path, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object4, iteratee2, accumulator) {
          var isArr = isArray2(object4), isArrLike = isArr || isBuffer(object4) || isTypedArray(object4);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object4 && object4.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject3(object4)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object4)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object4, function(value, index2, object5) {
            return iteratee2(accumulator, value, index2, object5);
          });
          return accumulator;
        }
        function unset(object4, path) {
          return object4 == null ? true : baseUnset(object4, path);
        }
        function update(object4, path, updater) {
          return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater));
        }
        function updateWith(object4, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater), customizer);
        }
        function values(object4) {
          return object4 == null ? [] : baseValues(object4, keys2(object4));
        }
        function valuesIn(object4) {
          return object4 == null ? [] : baseValues(object4, keysIn(object4));
        }
        function clamp(number4, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number4), lower, upper);
        }
        function inRange(number4, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number4 = toNumber(number4);
          return baseInRange(number4, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase2 = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize2(word) : word);
        });
        function capitalize2(string3) {
          return upperFirst(toString(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string3, target, position2) {
          string3 = toString(string3);
          target = baseToString(target);
          var length2 = string3.length;
          position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
          var end = position2;
          position2 -= target.length;
          return position2 >= 0 && string3.slice(position2, end) == target;
        }
        function escape(string3) {
          string3 = toString(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length2, chars) {
          string3 = toString(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          if (!length2 || strLength >= length2) {
            return string3;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length2, chars) {
          string3 = toString(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? string3 + createPadding(length2 - strLength, chars) : string3;
        }
        function padStart(string3, length2, chars) {
          string3 = toString(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n2, guard) {
          if (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string3), n2);
        }
        function replace2() {
          var args = arguments, string3 = toString(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position2) {
          string3 = toString(string3);
          position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position2, position2 + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string3, options, guard)) {
            options = undefined$1;
          }
          string3 = toString(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim2(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string3, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject3(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string3;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string3.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string3) {
          string3 = toString(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern4, guard) {
          string3 = toString(string3);
          pattern4 = guard ? undefined$1 : pattern4;
          if (pattern4 === undefined$1) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern4) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object4, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object4, key, bind(object4[key], object4));
          });
          return object4;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length2) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method4 = baseRest(function(path, args) {
          return function(object4) {
            return baseInvoke(object4, path, args);
          };
        });
        var methodOf = baseRest(function(object4, args) {
          return function(path) {
            return baseInvoke(object4, path, args);
          };
        });
        function mixin(object4, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object4;
            object4 = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc3 = isFunction(object4);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object4[methodName] = func;
            if (isFunc3) {
              object4.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object4(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object4 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object4, arrayPush([this.value()], arguments));
              };
            }
          });
          return object4;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object4) {
          return function(path) {
            return object4 == null ? undefined$1 : baseGet(object4, path);
          };
        }
        var range3 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor2 = createRound("floor");
        function max(array4) {
          return array4 && array4.length ? baseExtremum(array4, identity, baseGt) : undefined$1;
        }
        function maxBy(array4, iteratee2) {
          return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array4) {
          return baseMean(array4, identity);
        }
        function meanBy(array4, iteratee2) {
          return baseMean(array4, getIteratee(iteratee2, 2));
        }
        function min(array4) {
          return array4 && array4.length ? baseExtremum(array4, identity, baseLt) : undefined$1;
        }
        function minBy(array4, iteratee2) {
          return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array4) {
          return array4 && array4.length ? baseSum(array4, identity) : 0;
        }
        function sumBy(array4, iteratee2) {
          return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create2;
        lodash2.curry = curry2;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter2;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys2;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method4;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit2;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range3;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set2;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle2;
        lodash2.thru = thru;
        lodash2.toArray = toArray2;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform2;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase2;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor2;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes2;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty3;
        lodash2.isEqual = isEqual2;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject3;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString4;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type4 = index2 + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type4
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _ = runInContext();
      if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  function useUpdate() {
    const [, update] = React.useReducer((num) => num + 1, 0);
    return update;
  }
  const setTiming = (fn, info2) => {
    const timerEvents = window.setInterval(() => {
      const time = /* @__PURE__ */ new Date();
      const workDay = time.getDay();
      const hours = time.getHours();
      const minutes = time.getMinutes();
      const seconds = time.getSeconds();
      if (info2.day.includes(workDay) && hours === info2.hour && minutes === info2.minute && seconds >= 0 && seconds < 10) {
        fn();
        return clearInterval(timerEvents);
      }
    }, 1e3);
  };
  const getDate = () => {
    const date4 = /* @__PURE__ */ new Date();
    return `${date4.getFullYear()}-${date4.getMonth() + 1}-${date4.getDate()}`;
  };
  const getCommend = (info2, names2) => {
    var _a, _b;
    const commendList = ((_b = (_a = info2 == null ? void 0 : info2.fields) == null ? void 0 : _a.comment) == null ? void 0 : _b.comments) ?? [];
    if (names2.length === 0)
      return [];
    return names2.map((item) => {
      var _a2;
      return {
        name: item,
        value: ((_a2 = commendList.find((x) => {
          var _a3;
          return ((_a3 = x == null ? void 0 : x.author) == null ? void 0 : _a3.displayName) === item;
        })) == null ? void 0 : _a2.body) ?? ""
      };
    });
  };
  const getName$1 = (html, key, status) => {
    const result = [];
    const list = html == null ? void 0 : html.querySelectorAll(key);
    const statusList = html == null ? void 0 : html.querySelectorAll(status);
    if (list.length) {
      list.forEach((item, index2) => {
        var _a, _b, _c;
        if (((_b = (_a = statusList[index2]) == null ? void 0 : _a.textContent) == null ? void 0 : _b.indexOf("取消")) < 0) {
          result.push((_c = item.textContent) == null ? void 0 : _c.trim());
        }
      });
    }
    return Array.from(new Set(result));
  };
  const getUser = (x) => {
    var _a;
    const status = x.status;
    let result = [];
    console.log(211111, 11, x.assignees, status, x.users);
    if ((_a = x.assignees) == null ? void 0 : _a.length) {
      x.assignees.map((item, index2) => {
        var _a2, _b;
        if (((_a2 = status[index2]) == null ? void 0 : _a2.indexOf("取消")) < 0) {
          result.push({
            name: item == null ? void 0 : item.trim(),
            position: (_b = x.users.find((y) => y.label === (item == null ? void 0 : item.trim()))) == null ? void 0 : _b.position
          });
        }
      });
    }
    const uniqueUser = lodashExports.uniqBy(result, "name");
    console.log(232, uniqueUser);
    const uniquePosition = lodashExports.uniqBy(result, "position");
    return uniquePosition.map((item) => {
      var _a2;
      return {
        name: (_a2 = uniqueUser.filter((x2) => x2.position === item.position)) == null ? void 0 : _a2.map((v2) => v2.name),
        position: item.position
      };
    });
  };
  const getVal = (html, key, name) => {
    const result = [];
    const list = html == null ? void 0 : html.querySelectorAll(key);
    if (list == null ? void 0 : list.length) {
      list.forEach((item, index2) => {
        var _a;
        result.push((_a = item[name]) == null ? void 0 : _a.trim());
      });
    }
    return result;
  };
  const getNameByName = (x) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const { response, tr, users } = x;
    if ((_a = tr.key) == null ? void 0 : _a.includes("UG")) {
      const str2 = (_d = (_c = (_b = response == null ? void 0 : response.panels) == null ? void 0 : _b.leftPanels) == null ? void 0 : _c.find(
        (x2) => ["view-issue-lists", "view-subtasks"].includes(x2.id)
      )) == null ? void 0 : _d.html;
      const parser22 = new DOMParser();
      const parsedHtml2 = parser22.parseFromString(str2, "text/html");
      const elements = parsedHtml2.getElementById("issuetable");
      const assignees = getVal(elements, "#issuetable .assignee", "textContent");
      const status = getVal(elements, "#issuetable .status", "textContent");
      const allUsers = getUser({ assignees, status, users });
      return {
        [tr.key]: {
          before: ((_e = allUsers.filter((x2) => x2.position === "before")) == null ? void 0 : _e.flatMap((v2) => v2.name)) ?? [],
          // 前端
          after: ((_f = allUsers.filter((x2) => x2.position === "after")) == null ? void 0 : _f.flatMap((v2) => v2.name)) ?? [],
          // 后端
          test: ((_g = allUsers.filter((x2) => x2.position === "test")) == null ? void 0 : _g.flatMap((v2) => v2.name)) ?? [],
          // 测试
          product: (_i = (_h = tr.fields) == null ? void 0 : _h.customfield_10300) == null ? void 0 : _i.displayName,
          // 产品经理
          manager: (_k = (_j = tr.fields) == null ? void 0 : _j.customfield_11705) == null ? void 0 : _k.displayName
          // 技术经理
        }
      };
    }
    const str = (_n = (_m = (_l = response == null ? void 0 : response.panels) == null ? void 0 : _l.leftPanels) == null ? void 0 : _m.find(
      (x2) => x2.id === "view-issue-lists"
    )) == null ? void 0 : _n.html;
    const parser2 = new DOMParser();
    const parsedHtml = parser2.parseFromString(str, "text/html");
    const element = (_o = parsedHtml.getElementsByClassName("view-issue-lists")) == null ? void 0 : _o[0];
    const before = getName$1(element, "#issue-list-panel-13296 .assignee", "#issue-list-panel-13296 .status");
    const after = getName$1(element, "#issue-list-panel-13295 .assignee", "#issue-list-panel-13295 .status");
    const test = getName$1(element, "#issue-list-panel-13294 .assignee", "#issue-list-panel-13294 .status");
    return {
      [tr.key]: {
        before,
        // 前端
        after,
        // 后端
        test,
        // 测试
        product: (_q = (_p = tr.fields) == null ? void 0 : _p.customfield_10300) == null ? void 0 : _q.displayName,
        // 产品经理
        manager: (_s = (_r = tr.fields) == null ? void 0 : _r.customfield_11705) == null ? void 0 : _s.displayName
        // 技术经理
      }
    };
  };
  const formatMarkdown = (item, info2, keygen, type4) => {
    const data = getCommend(item, info2[item.key][keygen]);
    let msg = `缺少${type4 === "develop" ? "自测记录" : "测试报告"}`;
    return data.map((v2) => {
      if (v2.value) {
        return '<font color="info">' + v2.name + "</font>";
      } else {
        const val = "`" + v2.name + msg + "`";
        return '<font color="red">' + val + "</font>";
      }
    });
  };
  const createOnlineMarkdown = (list, info2) => {
    var _a, _b, _c;
    if ((list == null ? void 0 : list.length) === 0) {
      return ``;
    }
    let result = [];
    list.map((item) => {
      const before = formatMarkdown(item, info2, "before", "develop");
      const after = formatMarkdown(item, info2, "after", "develop");
      const test = formatMarkdown(item, info2, "test", "test");
      const header2 = `[${item.key}](https://jira.dotfashion.cn/browse/${item.key})
`;
      const summary = `概要：${item.fields.summary}
`;
      const productMark = info2[item.key].product ? `产品经理：${info2[item.key].product}
` : "";
      const managerMark = info2[item.key].manager ? `技术经理：${info2[item.key].manager}
` : "";
      const beforeMark = (before == null ? void 0 : before.length) ? `前端：${before.join("、")}
` : "";
      const afterMark = (after == null ? void 0 : after.length) ? `后端：${after.join("、")}
` : "";
      const testMark = (test == null ? void 0 : test.length) ? `测试：${test.join("、")}
` : "";
      result.push(`${header2}${summary}${productMark}${managerMark}${beforeMark}${afterMark}${testMark}
`);
    });
    const tips = '<font color="blue">没有自测或者测试记录的同学请补充或者进行解释说明，感谢配合~</font>';
    let multiple = 9;
    let multiplesOfNine = Math.ceil(list.length / multiple);
    let markdownList = [];
    if (multiplesOfNine > 1) {
      for (let i = 1; i < multiplesOfNine + 1; i++) {
        let data = "";
        if (i === 1) {
          data = `【今日上线需求】
 ${(_a = result.slice(multiple * (i - 1), multiple * i)) == null ? void 0 : _a.join(" ")}`;
        } else if (i === multiplesOfNine) {
          data = `${(_b = result.slice(multiple * (i - 1), multiple * i)) == null ? void 0 : _b.join(" ")}
` + tips;
        } else {
          data = `${(_c = result.slice(multiple * (i - 1), multiple * i)) == null ? void 0 : _c.join(" ")}`;
        }
        markdownList.push(data);
      }
      return markdownList;
    } else {
      return [`【今日上线需求】
 ${result == null ? void 0 : result.join(" ")}
` + tips];
    }
  };
  var propTypes$1 = { exports: {} };
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes$1.exports = factoryWithThrowingShims();
  }
  var propTypesExports = propTypes$1.exports;
  const propTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  function _regeneratorRuntime$1() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime$1 = function _regeneratorRuntime2() {
      return exports;
    };
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
      return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context2) }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method4) {
        define(prototype, method4, function(arg) {
          return this._invoke(method4, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method4, arg, resolve, reject) {
        var record = tryCatch(generator[method4], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", { value: function value(method4, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method4, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } });
    }
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context2.method = method4, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context2.method)
            context2.sent = context2._sent = context2.arg;
          else if ("throw" === context2.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            "return" === context2.method && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context2);
          if ("normal" === record.type) {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return { value: record.arg, done: context2.done };
          }
          "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var methodName = context2.method, method4 = delegate.iterator[methodName];
      if (void 0 === method4)
        return context2.delegate = null, "throw" === methodName && delegate.iterator.return && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method4, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info2 = record.arg;
      return info2 ? info2.done ? (context2[delegate.resultName] = info2.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info2 : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next2 = function next3() {
            for (; ++i < iterable.length; )
              if (hasOwn.call(iterable, i))
                return next3.value = iterable[i], next3.done = false, next3;
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return { next: doneResult };
    }
    function doneResult() {
      return { value: void 0, done: true };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return { __await: arg };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(val) {
      var object4 = Object(val), keys2 = [];
      for (var key in object4)
        keys2.push(key);
      return keys2.reverse(), function next2() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object4)
            return next2.value = key2, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports.values = values, Context2.prototype = { constructor: Context2, reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    }, stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    }, dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context2 = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    }, abrupt: function abrupt(type4, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    }, complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    }, finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    }, catch: function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = { iterator: values(iterable), resultName, nextLoc }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    } }, exports;
  }
  function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info2 = gen[key](arg);
      var value = info2.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info2.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$1(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var CDN_ADDRESS = "https://assets.dotfashion.cn/webassets";
  var BUCKET = `${CDN_ADDRESS}/shein-components/icons`;
  var getAddress = (name) => `${BUCKET}/${name}.svg`;
  var EmptySVG = '<svg style="width: 1em;" viewBox="0 0 1024 1024" />';
  function getsvgByName(_x) {
    return _getsvgByName.apply(this, arguments);
  }
  function _getsvgByName() {
    _getsvgByName = _asyncToGenerator$1(/* @__PURE__ */ _regeneratorRuntime$1().mark(function _callee(name) {
      var url2, data;
      return _regeneratorRuntime$1().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (name) {
                _context.next = 4;
                break;
              }
              console.warn("@shein-components/Icon 缺少 name 属性");
              return _context.abrupt("return", EmptySVG);
            case 4:
              if (!(typeof name !== "string")) {
                _context.next = 7;
                break;
              }
              console.warn("@shein-components/Icon的 name 属性必须为字符串");
              return _context.abrupt("return", EmptySVG);
            case 7:
              url2 = getAddress(name);
              _context.next = 10;
              return fetch(url2).then((res) => res.text());
            case 10:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](0);
              console.error(_context.t0);
              return _context.abrupt("return", EmptySVG);
            case 18:
            case "end":
              return _context.stop();
          }
      }, _callee, null, [[0, 14]]);
    }));
    return _getsvgByName.apply(this, arguments);
  }
  function getsvgByUrl(_x2) {
    return _getsvgByUrl.apply(this, arguments);
  }
  function _getsvgByUrl() {
    _getsvgByUrl = _asyncToGenerator$1(/* @__PURE__ */ _regeneratorRuntime$1().mark(function _callee2(svgUrl) {
      var data;
      return _regeneratorRuntime$1().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              if (svgUrl) {
                _context2.next = 4;
                break;
              }
              console.warn("@shein-components/Icon 缺少 svgUrl 属性");
              return _context2.abrupt("return", EmptySVG);
            case 4:
              if (!(typeof svgUrl !== "string")) {
                _context2.next = 7;
                break;
              }
              console.warn("@shein-components/Icon的 svgUrl 属性必须为字符串");
              return _context2.abrupt("return", EmptySVG);
            case 7:
              _context2.next = 9;
              return fetch(svgUrl).then((res) => res.text());
            case 9:
              data = _context2.sent;
              return _context2.abrupt("return", data);
            case 13:
              _context2.prev = 13;
              _context2.t0 = _context2["catch"](0);
              console.error(_context2.t0);
              return _context2.abrupt("return", EmptySVG);
            case 17:
            case "end":
              return _context2.stop();
          }
      }, _callee2, null, [[0, 13]]);
    }));
    return _getsvgByUrl.apply(this, arguments);
  }
  function _createForOfIteratorHelper$1(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f2() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray$1(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray$1(o, minLen);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var parser = new DOMParser();
  var transform = (str, target) => {
    if (target) {
      var dom = parser.parseFromString(str, "text/html");
      var svg = dom.querySelector("svg");
      if (svg) {
        svg.style.width = "auto";
        var _iterator = _createForOfIteratorHelper$1(svg.attributes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var attr = _step.value;
            target.setAttribute(attr.name, attr.value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        target.innerHTML = svg.innerHTML;
      }
    }
  };
  var fetchSvg = (name, svgUrl) => {
    var topic = svgUrl || name;
    if (!window.shineout_prop_svg_promises_map)
      window.shineout_prop_svg_promises_map = /* @__PURE__ */ new Map();
    var func = svgUrl ? getsvgByUrl : getsvgByName;
    if (!window.shineout_prop_svg_promises_map.get(topic)) {
      window.shineout_prop_svg_promises_map.set(topic, func(topic));
    }
    return window.shineout_prop_svg_promises_map.get(topic);
  };
  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports;
    };
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
      return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context2) }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method4) {
        define(prototype, method4, function(arg) {
          return this._invoke(method4, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method4, arg, resolve, reject) {
        var record = tryCatch(generator[method4], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", { value: function value(method4, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method4, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } });
    }
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context2.method = method4, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context2.method)
            context2.sent = context2._sent = context2.arg;
          else if ("throw" === context2.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            "return" === context2.method && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context2);
          if ("normal" === record.type) {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return { value: record.arg, done: context2.done };
          }
          "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var methodName = context2.method, method4 = delegate.iterator[methodName];
      if (void 0 === method4)
        return context2.delegate = null, "throw" === methodName && delegate.iterator.return && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method4, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info2 = record.arg;
      return info2 ? info2.done ? (context2[delegate.resultName] = info2.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info2 : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next2 = function next3() {
            for (; ++i < iterable.length; )
              if (hasOwn.call(iterable, i))
                return next3.value = iterable[i], next3.done = false, next3;
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return { next: doneResult };
    }
    function doneResult() {
      return { value: void 0, done: true };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return { __await: arg };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(val) {
      var object4 = Object(val), keys2 = [];
      for (var key in object4)
        keys2.push(key);
      return keys2.reverse(), function next2() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object4)
            return next2.value = key2, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports.values = values, Context2.prototype = { constructor: Context2, reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    }, stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    }, dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context2 = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    }, abrupt: function abrupt(type4, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    }, complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    }, finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    }, catch: function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = { iterator: values(iterable), resultName, nextLoc }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    } }, exports;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info2 = gen[key](arg);
      var value = info2.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info2.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  class SVG extends React.Component {
    constructor(props) {
      var _this;
      super(props);
      _this = this;
      this.changeLoadStatus = (failed) => {
        this.setState({
          loadFailed: failed
        });
      };
      this.renderSVG = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var _this$props, name, svgUrl, onError, svg;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                _this$props = _this.props, name = _this$props.name, svgUrl = _this$props.svgUrl, onError = _this$props.onError;
                _context.prev = 1;
                _this.changeLoadStatus(false);
                _context.next = 5;
                return fetchSvg(name, svgUrl);
              case 5:
                svg = _context.sent;
                if (!svg || svg.indexOf("<") !== 0) {
                  svg = '<svg style="width: 1em;" viewBox="0 0 1024 1024"/>';
                  _this.changeLoadStatus(true);
                  if (onError) {
                    onError(svg);
                  }
                }
                transform(svg, _this.ref.current);
                _context.next = 14;
                break;
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](1);
                _this.changeLoadStatus(true);
                if (onError) {
                  onError(_context.t0);
                }
              case 14:
              case "end":
                return _context.stop();
            }
        }, _callee, null, [[1, 10]]);
      }));
      this.ref = /* @__PURE__ */ React.createRef();
      this.state = {
        loadFailed: false
      };
    }
    componentDidMount() {
      this.renderSVG();
    }
    componentDidUpdate(prevProps) {
      var _this$props2 = this.props, name = _this$props2.name, svgUrl = _this$props2.svgUrl;
      if (prevProps.name !== name || prevProps.svgUrl !== svgUrl) {
        this.renderSVG();
      }
    }
    render() {
      var errorContent = this.props.errorContent;
      var loadFailed = this.state.loadFailed;
      if (loadFailed && errorContent) {
        return errorContent;
      }
      return /* @__PURE__ */ React.createElement("svg", {
        ref: this.ref
      });
    }
  }
  SVG.propTypes = {
    name: propTypes.string,
    svgUrl: propTypes.string,
    onError: propTypes.func,
    errorContent: propTypes.element
  };
  var _excluded$7 = ["children", "name", "svgUrl", "onError", "errorContent"];
  function _extends$5() {
    _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$5.apply(this, arguments);
  }
  function _objectWithoutProperties$7(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$7(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$7(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var less = {
    "icon": "shein-components_icon_icon"
  };
  class Icon extends React.Component {
    constructor() {
      var _this;
      super(...arguments);
      _this = this;
      this.onClick = function() {
        var _this$props = _this.props, onClick = _this$props.onClick, type4 = _this$props.type;
        if (type4 !== "disabled" && onClick) {
          onClick(...arguments);
        }
      };
      this.splicingClassName = () => {
        var _this$props2 = this.props, className = _this$props2.className, type4 = _this$props2.type;
        var finalClassName = ["so-icon", "shein-components_icon_sop_icon", less.icon];
        if (className)
          finalClassName.push(className);
        finalClassName.push(`so-icon-${type4 || "default"}`);
        return classname(finalClassName);
      };
    }
    // 拼装style
    splicingStyle() {
      var _this$props3 = this.props, _this$props3$style = _this$props3.style, style2 = _this$props3$style === void 0 ? {} : _this$props3$style, fontSize = _this$props3.fontSize, color = _this$props3.color, type4 = _this$props3.type;
      var disabledStyle = {
        color: "var(--button-disabled-bg, var(--gray-300, #cccfd7))",
        cursor: "not-allowed",
        userSelect: "none"
      };
      return Object.assign({
        fontSize,
        color
      }, style2, type4 === "disabled" ? disabledStyle : {});
    }
    render() {
      var _this$props4 = this.props, children = _this$props4.children, name = _this$props4.name, svgUrl = _this$props4.svgUrl, onError = _this$props4.onError, errorContent = _this$props4.errorContent, others = _objectWithoutProperties$7(_this$props4, _excluded$7);
      return /* @__PURE__ */ React.createElement("i", _extends$5({}, others, {
        className: this.splicingClassName(),
        style: this.splicingStyle(),
        onClick: this.onClick
      }), /* @__PURE__ */ React.createElement(SVG, {
        name,
        svgUrl,
        onError,
        errorContent
      }), children);
    }
  }
  Icon.defaultProps = {
    // theme: 'default',
  };
  Icon.propTypes = {
    /**
     * children
     */
    children: propTypes.oneOfType([propTypes.arrayOf(propTypes.node), propTypes.node]),
    /**
     * 图标名称
     */
    name: propTypes.string,
    /**
     * 远程svg的url链接，当和 name 同时传入时，svgUrl 的优先级更高
     */
    svgUrl: propTypes.string,
    /**
     * 样式
     */
    className: propTypes.string,
    /**
     * style 样式
     */
    // eslint-disable-next-line react/forbid-prop-types
    style: propTypes.object,
    /**
     * 图标大小，和 style.fontSize 相同
     */
    fontSize: propTypes.oneOfType([propTypes.string, propTypes.number]),
    /**
     * 图标颜色，和 style.color 相同
     */
    color: propTypes.string,
    /**
     * 内置颜色，引用了shineout样式文件方可生效，
     * 可选值为 ['default', 'primary', 'secondary', 'success', 'info', 'warning', 'danger', 'disabled'],
     * 📌 disabled 仅支持单色图标, 多色图标下颜色不会被更改
     */
    type: propTypes.oneOf(["default", "primary", "secondary", "success", "info", "warning", "danger", "disabled"]),
    /**
     * icon加载失败时触发, (error) => void
     */
    onError: propTypes.func,
    /**
     * icon加载失败时展示内容, 默认为空
     */
    errorContent: propTypes.element,
    /**
     * 点击事件
     */
    onClick: propTypes.func
  };
  Icon.defaultProps = {};
  Icon.isShineoutIcon = true;
  Icon.displayName = "shein-components-icon";
  const pdcHost = "https://pdc.biz.sheincorp.cn";
  const pdcFetch = async (fn, options) => {
    const { url: url2, method: method4 = "POST", data = {}, headers = {}, ...payload } = options;
    _GM_xmlhttpRequest({
      headers: {
        "Content-Type": "application/json",
        "token": null,
        "Cookie": null,
        ...headers
      },
      responseType: "json",
      url: pdcHost + url2,
      data: JSON.stringify(data),
      method: method4,
      ...payload,
      onreadystatechange: (res) => {
        if (res.readyState === 4) {
          const { code, msg, info: info2 } = (res == null ? void 0 : res.response) ?? {};
          if (code == "400106") {
            return fn(false);
          }
          if (code == 0) {
            fn(info2);
            return;
          } else {
            message$1.error(msg || "请求失败");
            return fn(false);
          }
        }
      }
    });
  };
  const header = {
    Cookie: document.cookie,
    "Content-Type": "application/json;charset=UTF-8"
  };
  const getDetail = "https://jira.dotfashion.cn/rest/api/2/search";
  const getTrInfo = (tr) => `https://jira.dotfashion.cn/secure/AjaxIssueAction!default.jspa?issueKey=${tr}&decorator=none&prefetch=false&shouldUpdateCurrentProject=false&loadFields=false&_=${( new Date()).getTime()}`;
  const detailBody = {
    startAt: "0",
    maxResults: 300,
    fields: [
      "summary",
      "status",
      "assignee",
      "comment",
      "customfield_10300",
      // 产品经理
      "customfield_11705",
      // 技术经理
      "customfield_47335"
      // 所属产品线
    ]
  };
  const getTrData = (tr) => fetch(getTrInfo(tr), {
    method: "GET",
    headers: header
  }).then((response) => {
    return response == null ? void 0 : response.json();
  }).then((res) => {
    if (res) {
      return res;
    }
  }).catch((err) => console.error("e ==>", err));
  const getTrDetail = (JQL) => fetch(getDetail, {
    method: "POST",
    headers: header,
    body: JSON.stringify({
      ...detailBody,
      jql: JQL
    })
  }).then((response) => {
    return response == null ? void 0 : response.json();
  }).then((res) => {
    if (res) {
      return res;
    }
  }).catch((err) => console.error("e ==>", err));
  function curry(f2) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (args.length >= f2.length) {
      return f2.apply(void 0, args);
    }
    return function() {
      for (var _len3 = arguments.length, next2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        next2[_key3] = arguments[_key3];
      }
      return curry.apply(void 0, [f2.bind.apply(f2, [f2].concat(args))].concat(next2));
    };
  }
  var nameIs = curry(function(name, val) {
    return val && val.constructor && val.constructor.name === name;
  });
  var isArray = Array.isArray;
  var isNan = function isNan2(a) {
    return a !== a;
  };
  var isFunc = function isFunc2(f2) {
    return typeof f2 === "function";
  };
  var isObject = function isObject2(val) {
    return val && typeof val === "object" && !isArray(val);
  };
  var isString$1 = function isString(s) {
    return typeof s === "string";
  };
  nameIs("Map");
  nameIs("Set");
  nameIs("Symbol");
  var isPromise = function isPromise2(p2) {
    return p2 && (nameIs("Promise", p2) || isFunc(p2.then));
  };
  var isEmpty = function isEmpty2(val) {
    if (val == null)
      return true;
    if (isNan(val))
      return true;
    if (val.length !== void 0)
      return val.length === 0;
    if (val instanceof Date)
      return false;
    if (typeof val === "object")
      return Object.keys(val).length === 0;
    return false;
  };
  var isOne = function isOne2(val) {
    if (val === 1)
      return true;
    return typeof val === "string" && val.indexOf(".") !== -1 && parseFloat(val) === 1;
  };
  var isPercent = function isPercent2(n2) {
    return typeof n2 === "string" && /\d{1,3}%$/.test(n2);
  };
  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2.push.apply(ownKeys2, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    }
    return target;
  }
  function insertPoint(name) {
    var reg = /(\[\d+\])/gi;
    return name.replace(reg, function(s, m2, i) {
      return s.replace(m2, i === 0 ? m2 : "." + m2);
    });
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var PATH_MODE = {
    loose: "?",
    strict: "!",
    insert: "^",
    append: "$"
  };
  var objectValues = function objectValues2(obj) {
    if (!obj)
      return [];
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  function pathGenerator(raw) {
    var path = insertPoint(raw);
    var reg = /^\[(\d+)\]$/;
    var pathModeValues = objectValues(PATH_MODE);
    var index2 = 0;
    var last = 0;
    var prop = "";
    var results = [];
    while (index2 >= 0) {
      index2 = path.indexOf(".", last);
      prop = path.substring(last, index2 === -1 ? void 0 : index2);
      var mode = void 0;
      var lastChar = prop.charAt(prop.length - 1);
      if (pathModeValues.includes(lastChar)) {
        mode = lastChar;
        prop = prop.substring(0, prop.length - 1);
      }
      var match2 = reg.exec(prop);
      if (match2)
        prop = parseInt(match2[1], 10);
      last = index2 + 1;
      results.push([prop, index2 === -1 ? void 0 : path.substring(last), mode]);
    }
    return results;
  }
  var deepGet = function deepGet2(target, path, options) {
    if (options === void 0) {
      options = {};
    }
    if (!isObject(target))
      throw new Error("Target must be an object.");
    if (typeof path !== "string")
      throw new Error("Path must be a string.");
    if (path === "")
      return target;
    var _options3 = options, defaultValue = _options3.defaultValue, strictMode = _options3.strictMode;
    var current = target;
    for (var _iterator2 = pathGenerator(path), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
      var _ref3;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref3 = _i2.value;
      }
      var _ref4 = _ref3, prop = _ref4[0], mode = _ref4[2];
      var isStrict = mode === PATH_MODE.strict || strictMode && defaultValue === void 0 && mode !== PATH_MODE.loose;
      if (current != null && hasOwnProperty.call(current, prop)) {
        current = current[prop];
      } else if (isStrict) {
        throw new Error("Path " + path + " is not exist.");
      } else {
        current = defaultValue;
        break;
      }
    }
    return current;
  };
  var Notification = /* @__PURE__ */ function() {
    function Notification2() {
      this.$events = {};
    }
    var _proto = Notification2.prototype;
    _proto.dispatch = function dispatch(name) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var event = this.$events[name];
      if (!event)
        return;
      event.forEach(function(fn) {
        return fn.apply(void 0, args);
      });
    };
    _proto.subscribe = function subscribe(name, fn) {
      if (!this.$events[name])
        this.$events[name] = [];
      var events2 = this.$events[name];
      if (fn in events2)
        return;
      events2.push(fn);
    };
    _proto.unsubscribe = function unsubscribe(name, fn) {
      if (!this.$events[name])
        return;
      if (fn)
        this.$events[name] = this.$events[name].filter(function(e2) {
          return e2 !== fn;
        });
      else
        delete this.$events[name];
    };
    return Notification2;
  }();
  var noti = new Notification();
  var config = {
    cssModule: {}.CSS_MODULE || false,
    prefix: {}.SO_PREFIX || "so",
    locale: {}.LOCALE || "en-US",
    autoSSL: false,
    delay: void 0,
    scrollRatio: 100,
    trim: void 0,
    spin: void 0,
    caret: void 0,
    direction: "ltr",
    popupContainer: void 0
  };
  const config$1 = config;
  function isRTL() {
    return config.direction === "rtl";
  }
  function getDefaultContainer() {
    if (isFunc(config.popupContainer)) {
      var container = config.popupContainer();
      if (container instanceof HTMLElement) {
        return container;
      }
    }
    if (config.popupContainer instanceof HTMLElement)
      return config.popupContainer;
    return document.body;
  }
  var getDirectionClass = function getDirectionClass2(c2) {
    return c2 + " " + c2 + "-" + (isRTL() ? "rtl" : "ltr");
  };
  const genaration = function(style2, module, prefix) {
    if (prefix === void 0) {
      prefix = config$1.prefix;
    }
    return function() {
      var className = classname.apply(void 0, arguments);
      if (!className)
        return "";
      var ns = "" + prefix + (module ? "-" + module : "-");
      var list = className.split(" ").map(function(c2) {
        return c2 === "_" ? ns : ns + "-" + c2;
      });
      if (config$1.cssModule) {
        list = list.map(function(c2) {
          return style2[c2] || c2;
        });
      }
      return list.join(" ");
    };
  };
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var floor = Math.floor;
  var MATCH = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  var isString2 = function isString3(string3) {
    if (!string3) {
      console.error(new Error("the color is empty"));
      return false;
    }
    if (typeof string3 !== "string") {
      console.error(new Error("the color is get a " + typeof string3 + ", expect string"));
      return false;
    }
    return true;
  };
  var dealPointZero = function dealPointZero2(string3) {
    var num = string3.toFixed(1);
    var reg = /\.0*$/;
    if (reg.test(num))
      return floor(num);
    return num;
  };
  var parseHex = function parseHex2(value) {
    return parseInt(value, 16);
  };
  var formatHexArray = function formatHexArray2(array4, length2) {
    if (length2 === 6)
      return ["" + array4[1], "" + array4[2], "" + array4[3]];
    if (length2 === 3)
      return ["" + array4[1] + array4[1], "" + array4[2] + array4[2], "" + array4[3] + array4[3]];
    if (length2 === 8)
      return ["" + array4[1], "" + array4[2], "" + array4[3], "" + array4[4]];
    return ["" + array4[1] + array4[1], "" + array4[2] + array4[2], "" + array4[3] + array4[3], "" + array4[4] + array4[4]];
  };
  var getRgb = function getRgb2(arr, length2) {
    var array4 = formatHexArray(arr, length2);
    return "rgb(" + parseHex(array4[0]) + ", " + parseHex(array4[1]) + ", " + parseHex(array4[2]) + ")";
  };
  var getRgba = function getRgba2(arr, length2) {
    var array4 = formatHexArray(arr, length2);
    return "rgba(" + parseHex(array4[0]) + ", " + parseHex(array4[1]) + ", " + parseHex(array4[2]) + ", " + dealPointZero(parseHex(array4[3]) / 255) + ")";
  };
  var toBound01 = function toBound012(val, max) {
    if (isOne(val)) {
      val = "100%";
    }
    var processPercent = isPercent(val);
    val = Math.min(max, Math.max(0, parseInt(val, 10)));
    if (processPercent) {
      val = parseInt(val * max, 10) / 100;
    }
    if (Math.abs(val - max) < 1e-6) {
      return 1;
    }
    return val % max / parseInt(max, 10);
  };
  var hueToRgb = function hueToRgb2(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  };
  var translateHsl = function translateHsl2(matchs, a) {
    var h2 = matchs[1], s = matchs[2], l2 = matchs[3];
    var r;
    var g2;
    var b2;
    h2 = toBound01(h2, 360);
    s = toBound01(s, 100);
    l2 = toBound01(l2, 100);
    if (s === 0) {
      r = l2;
      g2 = l2;
      b2 = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
      var p2 = 2 * l2 - q2;
      r = hueToRgb(p2, q2, h2 + 1 / 3);
      g2 = hueToRgb(p2, q2, h2);
      b2 = hueToRgb(p2, q2, h2 - 1 / 3);
    }
    r = floor(r * 255);
    g2 = floor(g2 * 255);
    b2 = floor(b2 * 255);
    return a ? "rgba(" + r + ", " + g2 + ", " + b2 + ", " + a + ")" : "rgb(" + r + ", " + g2 + ", " + b2 + ")";
  };
  var isDarkRgb = function isDarkRgb2(color) {
    var matchs = MATCH.rgb.exec(color) || MATCH.rgba.exec(color);
    if (matchs) {
      var r = matchs[1], g2 = matchs[2], b2 = matchs[3];
      return r * 0.299 + g2 * 0.578 + b2 * 0.114 < 192;
    }
    console.error(new Error("the string '" + color + "' is not a legal color"));
    return void 0;
  };
  function hexToRgb(hex2) {
    if (!isString2(hex2))
      return "";
    var matchs;
    matchs = MATCH.hex3.exec(hex2);
    if (matchs) {
      return getRgb(matchs, 3);
    }
    matchs = MATCH.hex6.exec(hex2);
    if (matchs) {
      return getRgb(matchs, 6);
    }
    matchs = MATCH.hex4.exec(hex2);
    if (matchs) {
      return getRgba(matchs, 4);
    }
    matchs = MATCH.hex8.exec(hex2);
    if (matchs) {
      return getRgba(matchs, 8);
    }
    console.error(new Error("the string '" + hex2 + "' is not a hex color"));
    return "";
  }
  function hslToRgb(hsl) {
    if (!isString2(hsl))
      return "";
    var matchs;
    matchs = MATCH.hsl.exec(hsl);
    if (matchs) {
      return translateHsl(matchs);
    }
    matchs = MATCH.hsla.exec(hsl);
    if (matchs) {
      return translateHsl(matchs, matchs[4]);
    }
    console.error(new Error("the string '" + hsl + "' is not a hsl color"));
    return "";
  }
  function judgeDark(color) {
    if (!isString2(color))
      return void 0;
    var rgbString = color;
    if (MATCH.hsl.test(color) || MATCH.hsla.test(color)) {
      rgbString = hslToRgb(color);
    }
    if (MATCH.hex3.test(color) || MATCH.hex4.test(color) || MATCH.hex6.test(color) || MATCH.hex8.test(color)) {
      rgbString = hexToRgb(color);
    }
    return isDarkRgb(rgbString);
  }
  function isDark(color) {
    var result = judgeDark(color);
    if (result === void 0)
      return false;
    return result;
  }
  function range2(end, start) {
    if (start === void 0) {
      start = 0;
    }
    var delta = end - start;
    if (typeof delta !== "number" || Number.isNaN(delta)) {
      console.error(new Error("end can not computed with start"));
    }
    return Array.from({
      length: end - start
    }, function(v2, k2) {
      return k2 + start;
    });
  }
  function capitalize(str) {
    if (typeof str !== "string") {
      console.error(new Error("str should be a string"));
    }
    return str && str[0].toUpperCase() + str.slice(1);
  }
  var docScroll = {
    get top() {
      return document.documentElement.scrollTop || document.body.scrollTop;
    },
    get left() {
      return document.documentElement.scrollLeft || document.body.scrollLeft;
    },
    set top(value) {
      document.documentElement.scrollTop = value;
      document.body.scrollTop = value;
    },
    set left(value) {
      document.documentElement.scrollLeft = value;
      document.body.scrollLeft = value;
    }
  };
  var docSize = {
    get width() {
      return document.documentElement.clientWidth || document.body.clientWidth;
    },
    get height() {
      return document.documentElement.clientHeight || document.body.clientHeight;
    }
  };
  if (Element && !Element.prototype.matches) {
    var proto = Element.prototype;
    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
  }
  function getParent(el, target) {
    if (!target) {
      return null;
    }
    var temp = el;
    while (temp) {
      if (typeof target === "string") {
        if (temp.matches && temp.matches(target)) {
          return temp;
        }
      } else if (temp === target) {
        return temp;
      }
      temp = temp.parentElement;
    }
    return null;
  }
  var isTwoCNChar = function isTwoCNChar2(str) {
    return /^[\u4e00-\u9fa5]{2}$/.test(str);
  };
  var SPACE = " ";
  function wrapSpan(children, insertSpace) {
    if (insertSpace === void 0) {
      insertSpace = false;
    }
    if (!children)
      return children;
    return React.Children.map(children, function(item) {
      if (typeof item === "string") {
        if (insertSpace && isTwoCNChar(item))
          return React.createElement("span", null, item.split("").join(SPACE));
        return React.createElement("span", null, item);
      }
      return item;
    });
  }
  var posKeys = ["left", "top", "bottom", "right"];
  var getPosition = function getPosition2(position2, el, container) {
    if (container === void 0) {
      container = document.body;
    }
    var rect = el.getBoundingClientRect();
    var containerRect = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    };
    if (container.tagName === "BODY")
      container = void 0;
    if (container)
      containerRect = container.getBoundingClientRect();
    var scrollTop = container ? 0 : docScroll.top;
    var scrollLeft = container ? 0 : docScroll.left;
    var pos = {};
    switch (position2) {
      case "top-left":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
      case "top":
        pos.left = scrollLeft + rect.left - containerRect.left + rect.width / 2;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
      case "top-right":
        pos.right = (containerRect.right || docSize.width) - rect.right - scrollLeft;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
      case "left-top":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
      case "left":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.top - containerRect.top + rect.height / 2;
        break;
      case "left-bottom":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.bottom - containerRect.bottom;
        break;
      case "right-top":
        pos.left = scrollLeft + rect.left - containerRect.left + rect.width;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
      case "right":
        pos.left = scrollLeft + rect.left - containerRect.left + rect.width;
        pos.top = scrollTop + rect.top - containerRect.top + rect.height / 2;
        break;
      case "right-bottom":
        pos.left = scrollLeft + rect.left - containerRect.left + rect.width;
        pos.top = scrollTop + rect.bottom - containerRect.bottom;
        break;
      case "bottom-left":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.top - containerRect.top + rect.height;
        break;
      case "bottom":
        pos.left = scrollLeft + rect.left - containerRect.left + rect.width / 2;
        pos.top = scrollTop + rect.top - containerRect.top + rect.height;
        break;
      case "bottom-right":
        pos.right = (containerRect.right || docSize.width) - rect.right - scrollLeft;
        pos.top = scrollTop + rect.top - containerRect.top + rect.height;
        break;
      case "cover":
        pos.left = scrollLeft + rect.left - containerRect.left;
        pos.top = scrollTop + rect.top - containerRect.top;
        break;
    }
    return posKeys.reduce(function(data, key) {
      var _objectSpread22;
      return _objectSpread$1({}, data, (_objectSpread22 = {}, _objectSpread22[key] = typeof pos[key] === "number" ? Math.round(pos[key]) + "px" : "auto", _objectSpread22));
    }, {});
  };
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  const buttonLess = "";
  var buttonClass = genaration(buttonLess, "button");
  const inputLess = "";
  genaration(inputLess, "form");
  var inputBorderClass = genaration(inputLess, "inputBorder");
  const alertLess = "";
  var alertClass = genaration(alertLess, "alert");
  const popoverLess = "";
  var popoverClass = genaration(popoverLess, "popover");
  var inputClass = genaration(inputLess, "input");
  const tooltipLess = "";
  var tooltipClass = genaration(tooltipLess, "tooltip");
  const tagLess = "";
  var tagClass = genaration(tagLess, "tag");
  const cn = {
    weekdayValues: {
      narrow: ["一", "二", "三", "四", "五", "六", "日"],
      short: ["周一", "周二", "周三", "周四", "周五", "周六", "周日"],
      long: ["星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期日"]
    },
    startOfWeek: 1,
    monthValues: {
      short: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
      long: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
    },
    pickerTitle: ["开始时间", "结束时间"],
    timeOfDayValues: ["上午", "下午"],
    ok: "确定",
    cancel: "取消",
    noData: "无数据",
    selectAll: "全选",
    loading: "加载中...",
    rules: {
      required: {
        array: "{title} 不能为空",
        string: "{title} 不能为空"
      },
      type: "请输入正确的 {title}",
      length: {
        max: {
          string: "{title} 不能超过 {max} 个字符",
          number: "{title} 不能大于 {max}",
          array: "{title} 不能超过 {max} 个选项"
        },
        min: {
          string: "{title} 不能少于 {min} 个字符",
          number: "{title} 不能小于 {min}",
          array: "{title} 至少选择 {min} 个选项"
        }
      },
      reg: "{title} 格式不正确"
    },
    selected: "项",
    search: "搜索",
    urlInvalidMsg: "图片格式不正确，请重新上传",
    invalidAccept: "文件格式不正确",
    notFound: "未找到"
  };
  const en = {
    weekdayValues: {
      narrow: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    startOfWeek: 0,
    monthValues: {
      short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    pickerTitle: ["Start Time", "End Time"],
    timeOfDayValues: ["a.m.", "p.m."],
    ok: "Ok",
    cancel: "Cancel",
    noData: "Data not found",
    selectAll: "Select All",
    loading: "loading...",
    rules: {
      required: {
        array: "Please select {title}",
        string: "Please enter {title}"
      },
      type: "Please enter a valid {title}",
      length: {
        max: {
          string: "{title} must less than {max} choices",
          number: "{title} must less than {max}",
          array: "{title} must select less than {max} choices"
        },
        min: {
          string: "{title} must be at least {min} characters",
          number: "{title} must greater than {min}",
          array: "{title} must select at least {min} choices"
        }
      },
      reg: "{title} is invalid."
    },
    selected: "selected",
    search: "search",
    urlInvalidMsg: "Picture format is incorrect, please upload again",
    invalidAccept: "Invalid file format",
    notFound: "not found"
  };
  var locale = config$1.locale === "zh-CN" ? cn : en;
  function getLocale(name, def) {
    if (!name)
      return locale;
    if (def && def[name])
      return def[name];
    return deepGet(locale, name);
  }
  function create$1(name) {
    var Base = React[name];
    return /* @__PURE__ */ function(_Base) {
      _inheritsLoose(_class, _Base);
      function _class() {
        return _Base.apply(this, arguments) || this;
      }
      var _proto = _class.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.$isMounted = true;
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.$isMounted = false;
      };
      _proto.setState = function setState() {
        var _Base$prototype$setSt;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (this.$isMounted !== false)
          (_Base$prototype$setSt = _Base.prototype.setState).call.apply(_Base$prototype$setSt, [this].concat(args));
      };
      _proto.forceUpdate = function forceUpdate() {
        if (this.$isMounted === true)
          _Base.prototype.forceUpdate.call(this);
        if (this.$isMounted === void 0) {
          if (this.forceUpdateTimer)
            clearTimeout(this.forceUpdateTimer);
          this.forceUpdateTimer = setTimeout(this.forceUpdate.bind(this));
        }
      };
      return _class;
    }(Base);
  }
  var Component$1 = create$1("Component");
  var PureComponent = create$1("PureComponent");
  function getProps(PropTypes) {
    var props = {
      className: PropTypes.string,
      style: PropTypes.object
    };
    var propSets = {
      disabled: PropTypes.bool,
      keygen: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.bool]).isRequired,
      grid: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),
      placeholder: PropTypes.oneOfType([PropTypes.string, PropTypes.element, PropTypes.func]),
      size: PropTypes.oneOf(["small", "default", "large"]),
      type: PropTypes.oneOf(["primary", "default", "secondary", "success", "info", "warning", "error", "danger", "link", "confirmwarning"])
    };
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    args.forEach(function(name) {
      var prop = propSets[name];
      if (prop)
        props[name] = prop;
    });
    return props;
  }
  var defaultProps = {
    className: "",
    size: "default",
    style: {},
    type: "default"
  };
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid2) {
    return typeof uuid2 === "string" && REGEX.test(uuid2);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid2)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid2;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify(rnds);
  }
  function getUidStr() {
    return "a" + v4.apply(void 0, arguments);
  }
  typeof Promise === "function" ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
  var MAX_SIGNED_31_BIT_INT = 1073741823;
  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    }
    return x !== x && y !== y;
  }
  function createEventEmitter(value) {
    var handlers = [];
    return {
      on: function on(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function(h2) {
          return h2 !== handler;
        });
      },
      get: function get2() {
        return value;
      },
      set: function set2(newValue, changedBits) {
        value = newValue;
        handlers.forEach(function(handler) {
          return handler(value, changedBits);
        });
      }
    };
  }
  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }
  function createReactContext$1(defaultValue, calculateChangedBits) {
    var _defineProperty2, _defineProperty3;
    var contextProp = "__create-react-context-" + getUidStr() + "__";
    var Provider2 = /* @__PURE__ */ function(_Component) {
      _inheritsLoose(Provider3, _Component);
      function Provider3() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _defineProperty$1(_assertThisInitialized(_assertThisInitialized(_this)), "emitter", createEventEmitter(_this.props.value));
        return _this;
      }
      var _proto = Provider3.prototype;
      _proto.getChildContext = function getChildContext() {
        var _ref;
        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };
      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits;
          if (objectIs(oldValue, newValue)) {
            changedBits = 0;
          } else {
            changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            changedBits |= 0;
            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };
      _proto.render = function render2() {
        return this.props.children;
      };
      return Provider3;
    }(React.Component);
    _defineProperty$1(Provider2, "childContextTypes", (_defineProperty2 = {}, _defineProperty2[contextProp] = propTypes.object.isRequired, _defineProperty2));
    var Consumer2 = /* @__PURE__ */ function(_Component2) {
      _inheritsLoose(Consumer3, _Component2);
      function Consumer3() {
        var _this2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _this2 = _Component2.call.apply(_Component2, [this].concat(args)) || this;
        _defineProperty$1(_assertThisInitialized(_assertThisInitialized(_this2)), "observedBits", void 0);
        _defineProperty$1(_assertThisInitialized(_assertThisInitialized(_this2)), "state", {
          value: _this2.getValue()
        });
        _defineProperty$1(_assertThisInitialized(_assertThisInitialized(_this2)), "onUpdate", function(newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;
          if ((observedBits & changedBits) !== 0) {
            _this2.setState({
              value: _this2.getValue()
            });
          }
        });
        return _this2;
      }
      var _proto2 = Consumer3.prototype;
      _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var observedBits = nextProps.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
        var observedBits = this.props.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };
      _proto2.getValue = function getValue2() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        }
        return defaultValue;
      };
      _proto2.render = function render2() {
        return onlyChild(this.props.children)(this.state.value);
      };
      return Consumer3;
    }(React.Component);
    _defineProperty$1(Consumer2, "contextTypes", (_defineProperty3 = {}, _defineProperty3[contextProp] = propTypes.object, _defineProperty3));
    return {
      Provider: Provider2,
      Consumer: Consumer2
    };
  }
  const createReactContext = React.createContext || createReactContext$1;
  var context$2 = createReactContext();
  var Consumer$1 = context$2.Consumer;
  context$2.Provider;
  var scrollConsumer = function scrollConsumer2(Origin) {
    return function(props) {
      return React.createElement(Consumer$1, null, function(value) {
        if (value === void 0) {
          value = {};
        }
        return React.createElement(Origin, _extends$7({}, props, {
          scrollElement: value.element,
          scrollLeft: value.left,
          scrollTop: value.top
        }));
      });
    };
  };
  const configable = function(Com, name) {
    return /* @__PURE__ */ function(_Component) {
      _inheritsLoose(_class, _Component);
      function _class(props) {
        var _this;
        _this = _Component.call(this, props) || this;
        _this.handleUpdate = _this.forceUpdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        noti.subscribe(name, _this.handleUpdate);
        return _this;
      }
      var _proto = _class.prototype;
      _proto.componentWillUnmount = function componentWillUnmount() {
        noti.unsubscribe(name, this.handleUpdate);
      };
      _proto.render = function render2() {
        return React.createElement(Com, this.props);
      };
      return _class;
    }(Component$1);
  };
  const spinLess = "";
  const defaultLess = "";
  const ringLess = "";
  const planeLess = "";
  const pulseLess = "";
  const waveLess = "";
  const chasingDotsLess = "";
  const doubleBounceLess = "";
  const cubeGridLess = "";
  const chasingRingLess = "";
  const scaleCircleLess = "";
  const threeBounceLess = "";
  const fourDotsLess = "";
  var spinClass = genaration(spinLess, "spin");
  var defaultClass = genaration(defaultLess, "spin-default");
  var ringClass = genaration(ringLess, "spin-ring");
  var planeClass = genaration(planeLess, "spin-plane");
  var pulseClass = genaration(pulseLess, "spin-pulse");
  var waveClass = genaration(waveLess, "spin-wave");
  var chasingDotsClass = genaration(chasingDotsLess, "chasing-dots");
  var doubleBounceClass = genaration(doubleBounceLess, "double-bounce");
  var cubeGridClass = genaration(cubeGridLess, "cube-grid");
  var chasingRingClass = genaration(chasingRingLess, "chasing-ring");
  var scaleCircleClass = genaration(scaleCircleLess, "scale-circle");
  var threeBounceClass = genaration(threeBounceLess, "three-bounce");
  var fourDotsClass = genaration(fourDotsLess, "four-dots");
  function Spin$2(props) {
    var spinClass2 = props.spinClass, count = props.count, render2 = props.render, size = props.size, wrapperClass = props.wrapperClass, wrapperStyle = props.wrapperStyle;
    var style2 = Object.assign({
      width: size,
      height: size
    }, props.style, wrapperStyle);
    var className = classname(spinClass2("_"), wrapperClass);
    if (count < 1) {
      return React.createElement("div", {
        style: style2,
        className
      });
    }
    return React.createElement("div", {
      style: style2,
      className
    }, range2(count + 1, 1).map(function(i) {
      return render2(spinClass2, i, props);
    }));
  }
  Spin$2.propTypes = {
    count: propTypes.number,
    render: propTypes.func,
    size: propTypes.oneOfType([propTypes.number, propTypes.string]),
    spinClass: propTypes.func,
    style: propTypes.object,
    wrapperClass: propTypes.string,
    wrapperStyle: propTypes.object
  };
  Spin$2.defaultProps = {
    count: 0
  };
  function formatSize$1(size) {
    var ss = /^(\d+)([%|\w]*)$/.exec(size);
    return {
      value: parseFloat(ss[1]),
      unit: ss[2] || "px"
    };
  }
  function simpleRender(classname2, i, _ref) {
    var color = _ref.color, itemStyle = _ref.itemStyle;
    var style2 = Object.assign({
      backgroundColor: color
    }, itemStyle);
    return React.createElement("div", {
      key: i,
      style: style2,
      className: classname2("item")
    });
  }
  function DoubleBounce(props) {
    return React.createElement(Spin$2, _extends$7({}, props, {
      count: 2,
      spinClass: doubleBounceClass,
      render: simpleRender
    }));
  }
  function Wave(prop) {
    var _formatSize = formatSize$1(prop.size), value = _formatSize.value, unit = _formatSize.unit;
    var width = value / 7;
    var margin = value / 20;
    if (unit === "px") {
      width = Math.floor(width);
      margin = Math.ceil(margin) + unit;
    } else {
      margin = "2px";
    }
    return React.createElement(Spin$2, _extends$7({}, prop, {
      itemStyle: {
        width: width + unit,
        marginRight: margin
      },
      count: 5,
      spinClass: waveClass,
      render: simpleRender
    }));
  }
  function CubeGrid(props) {
    return React.createElement(Spin$2, _extends$7({}, props, {
      count: 9,
      spinClass: cubeGridClass,
      render: simpleRender
    }));
  }
  function ChasingRing(prop) {
    var _formatSize2 = formatSize$1(prop.size), value = _formatSize2.value, unit = _formatSize2.unit;
    var borderWidth = "" + value / 10 + unit;
    var style2 = {
      borderWidth,
      borderTopColor: prop.color,
      backgroundColor: "transparent"
    };
    return React.createElement(Spin$2, _extends$7({}, prop, {
      count: 4,
      itemStyle: style2,
      spinClass: chasingRingClass,
      render: simpleRender
    }));
  }
  function multRenderDiv(className, i, _ref2) {
    var color = _ref2.color, itemStyle = _ref2.itemStyle, itemClass = _ref2.itemClass;
    var style2 = Object.assign({
      backgroundColor: color
    }, itemStyle);
    return React.createElement("div", {
      key: i,
      className: className("item", itemClass)
    }, React.createElement("div", {
      style: style2
    }));
  }
  function Default(prop) {
    var _formatSize3 = formatSize$1(prop.size), value = _formatSize3.value, unit = _formatSize3.unit;
    var size = Math.ceil(value / 12.5) + unit;
    return React.createElement(Spin$2, _extends$7({}, prop, {
      count: 12,
      itemStyle: {
        width: size,
        borderRadius: size
      },
      spinClass: defaultClass,
      render: multRenderDiv
    }));
  }
  function multRenderSvg(className, i, _ref3) {
    var color = _ref3.color, itemSize = _ref3.itemSize, itemClass = _ref3.itemClass;
    return React.createElement("div", {
      key: i,
      className: className("item", itemClass)
    }, React.createElement("svg", {
      width: itemSize,
      height: itemSize,
      viewBox: "0 0 100 100"
    }, React.createElement("circle", {
      fill: color,
      cx: 50,
      cy: 50,
      r: 50
    })));
  }
  function twelveCircle(prop, type4) {
    var _formatSize4 = formatSize$1(prop.size), value = _formatSize4.value, unit = _formatSize4.unit;
    var itemSize = (value / 7).toFixed(3) + unit;
    return React.createElement(Spin$2, _extends$7({}, prop, {
      count: 12,
      itemSize,
      itemClass: type4,
      spinClass: scaleCircleClass,
      render: multRenderSvg
    }));
  }
  var ScaleCircle = function ScaleCircle2(opt) {
    return twelveCircle(opt, "scale");
  };
  var FadingCircle = function FadingCircle2(opt) {
    return twelveCircle(opt, "fade");
  };
  function ThreeBounce(prop) {
    var _formatSize5 = formatSize$1(prop.size), value = _formatSize5.value, unit = _formatSize5.unit;
    return React.createElement(Spin$2, _extends$7({}, prop, {
      count: 3,
      style: {
        width: value * 2 + unit,
        height: "auto"
      },
      itemSize: value / 2 + unit,
      spinClass: threeBounceClass,
      render: multRenderSvg
    }));
  }
  function ChasingDots(props) {
    return React.createElement(Spin$2, _extends$7({}, props, {
      count: 2,
      spinClass: chasingDotsClass,
      render: multRenderSvg
    }));
  }
  function FourDots(props) {
    return React.createElement(Spin$2, _extends$7({}, props, {
      count: 4,
      spinClass: fourDotsClass,
      render: multRenderSvg
    }));
  }
  function formatSize(size) {
    var ss = /^(\d+)([%|\w]*)$/.exec(size);
    return {
      value: parseFloat(ss[1]),
      unit: ss[2] || "px"
    };
  }
  function Ring(obj) {
    var _formatSize = formatSize(obj.size), value = _formatSize.value, unit = _formatSize.unit;
    var style2 = {
      borderWidth: value / 10 + unit,
      borderTopColor: obj.color
    };
    return React.createElement(Spin$2, _extends$7({}, obj, {
      style: style2,
      spinClass: ringClass
    }));
  }
  function Plane(obj) {
    var style2 = {
      backgroundColor: obj.color
    };
    return React.createElement(Spin$2, _extends$7({}, obj, {
      style: style2,
      spinClass: planeClass
    }));
  }
  function Pulse(obj) {
    var style2 = {
      backgroundColor: obj.color
    };
    return React.createElement(Spin$2, _extends$7({}, obj, {
      style: style2,
      spinClass: pulseClass
    }));
  }
  var spins = {
    plane: Plane,
    pulse: Pulse,
    ring: Ring,
    wave: Wave,
    default: Default,
    "chasing-ring": ChasingRing,
    "chasing-dots": ChasingDots,
    "cube-grid": CubeGrid,
    "double-bounce": DoubleBounce,
    "fading-circle": FadingCircle,
    "four-dots": FourDots,
    "scale-circle": ScaleCircle,
    "three-bounce": ThreeBounce
  };
  function renderContainer(Loading, props) {
    var loading = props.loading, children = props.children;
    return React.createElement("div", {
      className: spinClass("container", loading && "show")
    }, React.createElement("div", {
      className: spinClass("content")
    }, children), loading && React.createElement("div", {
      className: spinClass("loading")
    }, Loading));
  }
  function getName(name) {
    if (name !== void 0)
      return name;
    if (config$1.spin !== void 0)
      return config$1.spin;
    return "default";
  }
  function Spin(props) {
    var children = props.children, style2 = props.style, className = props.className, rest = _objectWithoutPropertiesLoose$8(props, ["children", "style", "className"]);
    var name = getName(props.name);
    var Component2 = spins[name];
    if (!Component2) {
      console.warn("Spin type '" + name + "' not existed.");
      return null;
    }
    var classes = classname(spinClass("_"), className);
    var wrapperStyle = Object.assign({
      margin: props.margin,
      color: props.color
    }, style2);
    var Content2;
    if (!("tip" in props)) {
      Content2 = React.createElement(Component2, _extends$7({}, rest, {
        sry: true,
        wrapperStyle,
        wrapperClass: className
      }));
    } else {
      Content2 = React.createElement("div", {
        className: classes,
        style: wrapperStyle
      }, React.createElement(Component2, rest), props.tip && React.createElement("div", {
        className: spinClass("tip")
      }, typeof props.tip === "string" ? React.createElement("span", null, props.tip) : props.tip));
    }
    if (children)
      return renderContainer(Content2, props);
    return Content2;
  }
  Spin.displayName = "ShineoutSpin";
  Spin.propTypes = _objectSpread$1({}, getProps(propTypes), {
    color: propTypes.string,
    tip: propTypes.oneOfType([propTypes.node, propTypes.string]),
    children: propTypes.node,
    size: propTypes.oneOfType([propTypes.number, propTypes.string]),
    name: propTypes.oneOf(["default", "chasing-ring", "chasing-dots", "cube-grid", "double-bounce", "fading-circle", "four-dots", "plane", "pulse", "ring", "scale-circle", "three-bounce", "wave"])
  });
  Spin.defaultProps = {
    color: "#6c757d",
    size: 40
  };
  const Spin$1 = configable(Spin, "spin");
  const getDataset = function(props) {
    if (!props)
      return {};
    var keys2 = Object.keys(props);
    return keys2.reduce(function(acc, key) {
      if (key.indexOf("data-") !== 0)
        return acc;
      acc[key] = props[key];
      return acc;
    }, {});
  };
  function create(options) {
    var show2 = options.show, hide2 = options.hide, move2 = options.move, isCurrent2 = options.isCurrent;
    var Container2 = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose(Container3, _PureComponent);
      function Container3(props) {
        var _this;
        _this = _PureComponent.call(this, props) || this;
        _this.handleShow = _this.handleShow.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.handleDismiss = _this.handleDismiss.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.tryHide = _this.tryHide.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.elementRef = _this.elementRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.id = getUidStr();
        return _this;
      }
      var _proto = Container3.prototype;
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (!move2 || !isCurrent2(this.id))
          return;
        var _this$props = this.props, scrollLeft = _this$props.scrollLeft, scrollTop = _this$props.scrollTop;
        if (prevProps.scrollLeft !== scrollLeft || prevProps.scrollTop !== scrollTop) {
          var pos = this.getPosition();
          move2(this.id, pos);
          this.tryHide();
        }
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        hide2();
      };
      _proto.getElement = function getElement() {
        return this.placeholderElement.nextSibling;
      };
      _proto.getPosition = function getPosition$1() {
        var position2 = this.props.position;
        var el = this.getElement();
        return getPosition(position2, el);
      };
      _proto.elementRef = function elementRef(el) {
        this.placeholderElement = el;
      };
      _proto.tryHide = function tryHide() {
        var scrollElement = this.props.scrollElement;
        var rect = this.getElement().getBoundingClientRect();
        var scrollRect = scrollElement ? scrollElement.getBoundingClientRect() : {};
        if (rect.bottom < scrollRect.top || rect.top > scrollRect.bottom || rect.right < scrollRect.left || rect.left > scrollRect.right) {
          hide2(0);
        }
      };
      _proto.handleShow = function handleShow() {
        var _this2 = this;
        if (this.showTimer)
          clearTimeout(this.showTimer);
        var delay = this.props.delay;
        if (!delay) {
          this.showSync();
        } else {
          this.showTimer = setTimeout(function() {
            _this2.showSync();
          }, delay);
        }
      };
      _proto.handleDismiss = function handleDismiss() {
        clearTimeout(this.showTimer);
        hide2();
      };
      _proto.showSync = function showSync() {
        var pos = this.getPosition();
        var style2 = Object.keys(pos).reduce(function(data, key) {
          data[key] = pos[key];
          return data;
        }, {});
        var props = Object.assign({}, this.props, {
          style: style2
        });
        show2(props, this.id, this.props.style);
      };
      _proto.render = function render2() {
        var _this3 = this;
        var _this$props2 = this.props, children = _this$props2.children, trigger = _this$props2.trigger, disabledChild = _this$props2.disabledChild, tip = _this$props2.tip, content = _this$props2.content;
        if (!React.isValidElement(children)) {
          console.error(new Error("Tooltip children expect a single ReactElement."));
          return null;
        }
        if (!tip && !content)
          return children;
        var inner2 = disabledChild ? React.createElement("span", {
          className: tooltipClass("disabled-wrapper"),
          style: {
            cursor: "not-allowed"
          }
        }, React.cloneElement(children, {
          style: _objectSpread$1({}, children.props.style, {
            pointerEvents: "none"
          })
        })) : children;
        var props = {
          key: "el"
        };
        if (trigger === "hover") {
          props.onMouseEnter = this.handleShow;
          props.onMouseLeave = this.handleDismiss;
        } else {
          props.onClick = function(e2) {
            if (e2)
              e2.stopPropagation();
            setTimeout(_this3.handleShow, 10);
            if (children.props.onClick)
              children.props.onClick();
          };
        }
        return [React.createElement("noscript", {
          ref: this.elementRef,
          key: "ns"
        }), React.cloneElement(inner2, props)];
      };
      return Container3;
    }(React.PureComponent);
    Container2.propTypes = {
      // eslint-disable-next-line
      animation: propTypes.bool,
      children: propTypes.element.isRequired,
      // eslint-disable-next-line
      content: propTypes.oneOfType([propTypes.element, propTypes.func]),
      delay: propTypes.number,
      position: propTypes.oneOf(["top-left", "top", "top-right", "left-top", "left", "left-bottom", "right-top", "right", "right-bottom", "bottom-left", "bottom", "bottom-right"]),
      scrollElement: propTypes.object,
      scrollLeft: propTypes.number,
      scrollTop: propTypes.number,
      style: propTypes.object,
      trigger: propTypes.oneOf(["click", "hover"]),
      disabledChild: propTypes.bool,
      tip: propTypes.node
    };
    Container2.defaultProps = {
      animation: true,
      delay: 0,
      position: "top",
      trigger: "hover"
    };
    return scrollConsumer(Container2);
  }
  function isInDocument(element) {
    if (element && "isConnected" in element) {
      return element.isConnected;
    }
    return document.documentElement.contains(element);
  }
  var Container = null;
  var getContainer = function getContainer2() {
    if (Container && isInDocument(Container)) {
      return Container;
    }
    Container = document.createElement("div");
    Container.setAttribute("style", "position: absolute; top: 0; left: 0; width: 100%; contain: size");
    var target = getDefaultContainer();
    target.appendChild(Container);
    return Container;
  };
  const getCommonContainer = getContainer;
  var currentProps = null;
  var div = null;
  var arrow = null;
  var inner = null;
  var timer = null;
  var currentId;
  function hide(delay) {
    if (delay === void 0) {
      delay = 500;
    }
    timer = setTimeout(function() {
      if (div) {
        div.style.display = "none";
        div.className = "";
      }
      currentId = void 0;
    }, delay);
  }
  var hide0 = hide.bind(null, 0);
  function clickaway(e2) {
    if (div.contains(e2.target))
      return;
    hide(0);
    document.removeEventListener("click", clickaway);
  }
  function show(props, id) {
    var position2 = props.position, style2 = props.style, content = props.content, background = props.background, border = props.border, noArrow = props.noArrow, type4 = props.type;
    if (!div) {
      div = document.createElement("div");
      div.style.display = "none";
      getCommonContainer().appendChild(div);
      div.addEventListener("mouseenter", function() {
        if (!timer)
          return;
        clearTimeout(timer);
        document.addEventListener("click", clickaway);
      });
      div.addEventListener("mouseleave", function() {
        clearTimeout(timer);
        if (currentProps && currentProps.trigger === "click")
          return;
        hide();
      });
    }
    if (!arrow) {
      arrow = document.createElement("div");
      arrow.className = popoverClass("arrow");
      div.appendChild(arrow);
    }
    if (!inner) {
      inner = document.createElement("div");
      inner.className = popoverClass("content");
      div.appendChild(inner);
    }
    currentProps = props;
    currentId = id;
    if (timer)
      clearTimeout(timer);
    div.style.cssText = "display: none";
    Object.keys(style2).forEach(function(k2) {
      div.style[k2] = style2[k2];
    });
    if (style2.right)
      div.setAttribute("raw-right", style2.right);
    if (style2.left)
      div.setAttribute("raw-left", style2.left);
    div.setAttribute("raw-top", style2.top);
    div.style.background = background || "";
    inner.style.background = background || "";
    arrow.style.background = background || "";
    div.style.borderColor = border || "";
    arrow.style.borderColor = border || "";
    var className = popoverClass("_", position2, type4);
    arrow.style.display = noArrow ? "none" : "block";
    setTimeout(function() {
      div.style.display = "block";
      div.className = className;
    }, 0);
    var newContent = typeof content === "function" ? content(hide0) : content;
    if (typeof newContent === "string")
      newContent = React.createElement("span", {
        className: popoverClass("text")
      }, newContent);
    ReactDOM__default.render(newContent, inner);
    document.addEventListener("click", clickaway);
  }
  function move(id, pos) {
    if (id === currentId) {
      Object.keys(pos).map(function(key) {
        return div.style[key] = pos[key];
      });
    }
  }
  function isCurrent(id) {
    return id === currentId;
  }
  const events = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hide,
    isCurrent,
    move,
    show
  }, Symbol.toStringTag, { value: "Module" }));
  function isDOMElement(el) {
    return typeof HTMLElement === "function" ? el instanceof HTMLElement : el && typeof el === "object" && el.nodeType === 1 && typeof el.nodeName === "string";
  }
  var context$1 = createReactContext();
  var Provider$1 = context$1.Provider;
  var context = createReactContext();
  var Consumer = context.Consumer;
  var Provider = context.Provider;
  var consumer = function consumer2(Origin) {
    return function(props) {
      return React.createElement(Consumer, null, function(bindChain) {
        return React.createElement(Origin, _extends$7({}, props, {
          bindChain
        }));
      });
    };
  };
  var emptyEvent = function emptyEvent2(e2) {
    return e2.stopPropagation();
  };
  var Panel = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Panel2, _Component);
    function Panel2(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.state = {
        show: props.defaultVisible || false
      };
      _this.isRendered = false;
      _this.chain = [];
      _this.id = "popover_" + getUidStr();
      _this.placeholderRef = _this.placeholderRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.clickAway = _this.clickAway.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleShow = _this.handleShow.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleHide = _this.handleHide.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.setShow = _this.setShow.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.bindChain = _this.bindChain.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleCancel = _this.handleCancel.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.createContainer = _this.createContainer.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.element = document.createElement("div");
      return _this;
    }
    var _proto = Panel2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      _Component.prototype.componentDidMount.call(this);
      var bindChain = this.props.bindChain;
      if (bindChain)
        bindChain(this.id);
      this.parentElement = this.placeholder.parentElement;
      this.bindEvents();
      if (this.props.visible) {
        this.createContainer();
        this.forceUpdate();
      }
    };
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.visible === true || nextProps.visible === true)
        return true;
      if (this.state.show === true || nextState.show === true)
        return true;
      return false;
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.trigger !== prevProps.trigger) {
        this.bindEvents();
      }
      if (this.props.zIndex !== prevProps.zIndex && this.element) {
        this.element.style.zIndex = this.props.zIndex;
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      _Component.prototype.componentWillUnmount.call(this);
      this.parentElement.removeEventListener("mouseenter", this.handleShow);
      this.parentElement.removeEventListener("mouseleave", this.handleHide);
      this.parentElement.removeEventListener("click", this.handleShow);
      document.removeEventListener("click", this.clickAway);
      document.removeEventListener("mousedown", this.clickAway);
      if (!this.container)
        return;
      if (this.container === getCommonContainer()) {
        if (this.element && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
      } else {
        this.container.parentNode.removeChild(this.container);
      }
    };
    _proto.setShow = function setShow(show2) {
      var _this2 = this;
      var _this$props = this.props, onVisibleChange = _this$props.onVisibleChange, mouseEnterDelay = _this$props.mouseEnterDelay, mouseLeaveDelay = _this$props.mouseLeaveDelay, trigger = _this$props.trigger;
      var delay = show2 ? mouseEnterDelay : mouseLeaveDelay;
      this.delayTimeout = setTimeout(function() {
        if (onVisibleChange)
          onVisibleChange(show2);
        _this2.setState({
          show: show2
        });
        if (show2 && _this2.props.onOpen)
          _this2.props.onOpen();
        if (!show2 && _this2.props.onClose)
          _this2.props.onClose();
        if (show2) {
          _this2.bindScrollDismiss(true);
          document.addEventListener("mousedown", _this2.clickAway);
        } else {
          _this2.bindScrollDismiss(false);
          document.removeEventListener("mousedown", _this2.clickAway);
        }
      }, trigger === "hover" ? delay : 0);
    };
    _proto.getPositionStr = function getPositionStr() {
      var position2 = this.props.position;
      var priorityDirection = this.props.priorityDirection;
      if (position2)
        return position2;
      var rect = this.parentElement.getBoundingClientRect();
      var horizontalPoint = rect.left + rect.width / 2;
      var verticalPoint = rect.top + rect.height / 2;
      var windowHeight = docSize.height;
      var windowWidth = docSize.width;
      var tempPriorityDirection = priorityDirection;
      if (priorityDirection === "auto") {
        var maxX = Math.max(rect.left, windowWidth - rect.left - rect.width);
        var maxY = Math.max(rect.top, windowHeight - rect.top - rect.height);
        tempPriorityDirection = maxX > maxY ? "horizontal" : "vertical";
      }
      if (tempPriorityDirection === "horizontal") {
        if (horizontalPoint > windowWidth / 2)
          position2 = "left";
        else
          position2 = "right";
        if (verticalPoint > windowHeight * 0.6) {
          position2 += "-bottom";
        } else if (verticalPoint < windowHeight * 0.4) {
          position2 += "-top";
        }
      } else {
        if (verticalPoint > windowHeight / 2)
          position2 = "top";
        else
          position2 = "bottom";
        if (horizontalPoint > windowWidth * 0.6) {
          position2 += "-right";
        } else if (horizontalPoint < windowWidth * 0.4) {
          position2 += "-left";
        }
      }
      return position2;
    };
    _proto.getContainer = function getContainer3() {
      var getPopupContainer = this.props.getPopupContainer;
      var container;
      if (getPopupContainer)
        container = getPopupContainer();
      if (container && isDOMElement(container)) {
        var child = document.createElement("div");
        child.setAttribute("style", " position: absolute; top: 0px; left: 0px; width: 100% ");
        return container.appendChild(child);
      }
      return getCommonContainer();
    };
    _proto.createContainer = function createContainer() {
      var zIndex = this.props.zIndex;
      if (!this.container || !isInDocument(this.container)) {
        this.container = this.getContainer();
        this.element.style.zIndex = zIndex;
        this.container.appendChild(this.element);
      }
    };
    _proto.updatePosition = function updatePosition(position2) {
      var _this3 = this;
      var pos = getPosition(position2, this.parentElement, this.container);
      Object.keys(pos).forEach(function(attr) {
        _this3.element.style[attr] = pos[attr];
      });
    };
    _proto.bindEvents = function bindEvents() {
      var _this$props2 = this.props, trigger = _this$props2.trigger, clickToCancelDelay = _this$props2.clickToCancelDelay, mouseEnterDelay = _this$props2.mouseEnterDelay;
      if (trigger === "hover") {
        this.parentElement.addEventListener("mouseenter", this.handleShow);
        this.parentElement.addEventListener("mouseleave", this.handleHide);
        this.element.addEventListener("mouseenter", this.handleShow);
        this.element.addEventListener("mouseleave", this.handleHide);
        this.parentElement.removeEventListener("click", this.handleShow);
        if (clickToCancelDelay && mouseEnterDelay > 0) {
          this.parentElement.addEventListener("click", this.handleCancel);
        }
      } else {
        this.parentElement.addEventListener("click", this.handleShow);
        this.parentElement.removeEventListener("click", this.handleCancel);
        this.parentElement.removeEventListener("mouseenter", this.handleShow);
        this.parentElement.removeEventListener("mouseleave", this.handleHide);
        this.element.removeEventListener("mouseenter", this.handleShow);
        this.element.removeEventListener("mouseleave", this.handleHide);
      }
    };
    _proto.placeholderRef = function placeholderRef(el) {
      this.placeholder = el;
    };
    _proto.clickAway = function clickAway(e2) {
      if (this.parentElement.contains(e2.target))
        return;
      if (this.element.contains(e2.target))
        return;
      if (getParent(e2.target, "." + popoverClass("_")))
        return;
      this.handleHide(0);
    };
    _proto.bindScrollDismiss = function bindScrollDismiss(show2) {
      var scrollDismiss = this.props.scrollDismiss;
      if (!scrollDismiss)
        return;
      var target = document;
      if (typeof scrollDismiss === "function")
        target = scrollDismiss();
      var method4 = show2 ? target.addEventListener : target.removeEventListener;
      method4.call(target, "scroll", this.handleHide);
    };
    _proto.bindChain = function bindChain(id) {
      this.chain.push(id);
    };
    _proto.handleShow = function handleShow() {
      this.createContainer();
      if (this.delayTimeout)
        clearTimeout(this.delayTimeout);
      if (this.state.show)
        return;
      this.setShow(true);
    };
    _proto.isChildren = function isChildren(el) {
      for (var i = 0; i < this.chain.length; i++) {
        if (getParent(el, "." + this.chain[i]))
          return true;
      }
      return false;
    };
    _proto.handleCancel = function handleCancel() {
      if (this.delayTimeout)
        clearTimeout(this.delayTimeout);
    };
    _proto.handleHide = function handleHide(e2) {
      if (e2 && this.isChildren(e2.relatedTarget))
        return;
      if (this.delayTimeout)
        clearTimeout(this.delayTimeout);
      this.setShow(false);
    };
    _proto.render = function render2() {
      var _this$props3 = this.props, background = _this$props3.background, border = _this$props3.border, children = _this$props3.children, type4 = _this$props3.type, visible = _this$props3.visible, showArrow = _this$props3.showArrow, useTextStyle = _this$props3.useTextStyle, destroy2 = _this$props3.destroy;
      var show2 = typeof visible === "boolean" ? visible : this.state.show;
      if ((!this.isRendered || destroy2) && !show2 || !this.parentElement || !children) {
        return React.createElement("noscript", {
          ref: this.placeholderRef
        });
      }
      this.isRendered = true;
      var colorStyle = {
        background,
        borderColor: border
      };
      var innerStyle = Object.assign({}, this.props.style, {
        background
      });
      var position2 = this.getPositionStr();
      var style2 = this.element.style;
      if (show2) {
        style2.display = "none";
        this.updatePosition(position2);
        if (background)
          style2.background = background;
        if (border)
          style2.borderColor = border;
        style2.display = "block";
      } else {
        style2.display = "none";
      }
      this.element.className = classname(popoverClass("_", position2, type4), this.props.className, this.id);
      var childrened = isFunc(children) ? children(this.handleHide) : children;
      if (typeof childrened === "string" || useTextStyle)
        childrened = React.createElement("span", {
          className: popoverClass("text")
        }, childrened);
      return ReactDOM__default.createPortal([showArrow && React.createElement("div", {
        key: "arrow",
        className: popoverClass("arrow"),
        style: colorStyle
      }), React.createElement("div", {
        key: "content",
        onClick: emptyEvent,
        className: popoverClass("content"),
        style: innerStyle
      }, React.createElement(Provider, {
        value: this.bindChain
      }, React.createElement(Provider$1, {
        value: false
      }, childrened)))], this.element);
    };
    return Panel2;
  }(Component$1);
  Panel.propTypes = {
    background: propTypes.string,
    border: propTypes.string,
    children: propTypes.any,
    onClose: propTypes.func,
    onOpen: propTypes.func,
    position: propTypes.string,
    style: propTypes.object,
    trigger: propTypes.oneOf(["click", "hover"]),
    type: propTypes.string,
    visible: propTypes.bool,
    onVisibleChange: propTypes.func,
    defaultVisible: propTypes.bool,
    mouseEnterDelay: propTypes.number,
    mouseLeaveDelay: propTypes.number,
    className: propTypes.string,
    priorityDirection: propTypes.string,
    getPopupContainer: propTypes.func,
    scrollDismiss: propTypes.oneOfType([propTypes.bool, propTypes.func]),
    showArrow: propTypes.bool,
    bindChain: propTypes.func,
    zIndex: propTypes.number,
    clickToCancelDelay: propTypes.bool,
    useTextStyle: propTypes.bool,
    destroy: propTypes.bool
  };
  Panel.defaultProps = {
    background: "",
    trigger: "hover",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0,
    priorityDirection: "vertical",
    showArrow: true
  };
  const Panel$1 = consumer(Panel);
  var Button = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(Button2, _PureComponent);
    function Button2() {
      return _PureComponent.apply(this, arguments) || this;
    }
    var _proto = Button2.prototype;
    _proto.getChildren = function getChildren() {
      var _this$props = this.props, children = _this$props.children, loading = _this$props.loading, space = _this$props.space;
      if (!children)
        return children;
      var parsed = React.Children.map(wrapSpan(children, space), function(item) {
        if (loading && React.isValidElement(item) && item.type.isShineoutIcon)
          return null;
        return item;
      }).filter(function(v2) {
        return v2 !== null;
      });
      return parsed;
    };
    _proto.render = function render2() {
      var _this$props2 = this.props, outlineProp = _this$props2.outline, typeProp = _this$props2.type, size = _this$props2.size, href = _this$props2.href, htmlType = _this$props2.htmlType, loading = _this$props2.loading, disabled = _this$props2.disabled, onRef = _this$props2.onRef, shape = _this$props2.shape, text = _this$props2.text;
      _this$props2.space;
      var others = _objectWithoutPropertiesLoose$8(_this$props2, ["outline", "type", "size", "href", "htmlType", "loading", "disabled", "onRef", "shape", "text", "space"]);
      var isSecondary = typeProp === "secondary" && !outlineProp && !text;
      var type4 = isSecondary ? "primary" : typeProp;
      var outline = outlineProp || isSecondary;
      var color = outline || type4 === "default" ? void 0 : "#fff";
      if (text)
        color = "currentColor";
      var className = classname(buttonClass("_", shape, type4, outline && "outline", {
        large: size === "large",
        small: size === "small",
        text: text && "text",
        rtl: isRTL(),
        disabled
      }), this.props.className);
      if (href && !disabled) {
        return React.createElement("a", _extends$7({
          href
        }, others, {
          className
        }), this.props.children);
      }
      var children = this.getChildren();
      return (
        // eslint-disable-next-line
        React.createElement("button", _extends$7({}, others, {
          ref: onRef,
          disabled: disabled || loading,
          type: htmlType,
          className
        }), loading && React.createElement("span", {
          className: buttonClass(getDirectionClass("spin"))
        }, React.createElement(Spin$1, {
          size: 12,
          name: "ring",
          color
        })), children)
      );
    };
    return Button2;
  }(React.PureComponent);
  Button.propTypes = _objectSpread$1({}, getProps(propTypes, "disabled", "size", "type"), {
    children: propTypes.any,
    href: propTypes.string,
    htmlType: propTypes.oneOf(["button", "reset", "submit"]),
    loading: propTypes.bool,
    onRef: propTypes.func,
    shape: propTypes.oneOf(["round", "circle"]),
    outline: propTypes.bool,
    text: propTypes.bool,
    space: propTypes.bool
  });
  Button.defaultProps = _objectSpread$1({}, defaultProps, {
    htmlType: "button",
    outline: false,
    type: "default"
  });
  const Button$1 = Button;
  var OnceButton = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(OnceButton2, _PureComponent);
    function OnceButton2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this.state = {
        loading: props.loading
      };
      _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }
    var _proto = OnceButton2.prototype;
    _proto.handleClick = function handleClick(e2) {
      var onClick = this.props.onClick;
      this.setState({
        loading: true
      });
      if (onClick)
        onClick(e2);
    };
    _proto.render = function render2() {
      return React.createElement(Button$1, _extends$7({}, this.props, {
        loading: this.state.loading,
        onClick: this.handleClick
      }));
    };
    return OnceButton2;
  }(React.PureComponent);
  OnceButton.propTypes = {
    loading: propTypes.bool,
    onClick: propTypes.func
  };
  const Once = OnceButton;
  var ButtonGroup = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(ButtonGroup2, _PureComponent);
    function ButtonGroup2() {
      return _PureComponent.apply(this, arguments) || this;
    }
    var _proto = ButtonGroup2.prototype;
    _proto.render = function render2() {
      var _this$props = this.props, children = _this$props.children, outline = _this$props.outline, size = _this$props.size, type4 = _this$props.type;
      var typeSetted = type4 !== "default";
      var className = classname(buttonClass("group", (outline || !typeSetted) && "outline", isRTL() && "group-rtl"), this.props.className);
      return React.createElement("div", {
        className
      }, React.Children.toArray(children).map(function(child) {
        return React.cloneElement(child, {
          size,
          outline,
          type: typeSetted ? type4 : child.props.type
        });
      }));
    };
    return ButtonGroup2;
  }(React.PureComponent);
  ButtonGroup.propTypes = _objectSpread$1({}, getProps(propTypes, "size"), {
    children: propTypes.any.isRequired,
    outline: propTypes.bool,
    type: propTypes.string
  });
  ButtonGroup.defaultProps = {
    outline: false,
    type: "default"
  };
  const Group = ButtonGroup;
  Button$1.Group = Group;
  Button$1.Once = Once;
  Button$1.displayName = "ShineoutButton";
  function icon(path) {
    return React.createElement("svg", {
      viewBox: "0 0 1024 1024"
    }, path.map(function(p2, i) {
      return React.createElement("path", {
        key: i,
        d: p2
      });
    }));
  }
  var success = ["M512 981.333333C252.8 981.333333 42.666667 771.2 42.666667 512S252.8 42.666667 512 42.666667s469.333333 210.133333 469.333333 469.333333-210.133333 469.333333-469.333333 469.333333z m-82.986667-276.48a42.453333 42.453333 0 0 0 22.613334-11.818666l301.738666-301.696a42.666667 42.666667 0 0 0-60.330666-60.373334l-272.469334 272.469334-91.136-91.136a42.666667 42.666667 0 0 0-60.330666 60.330666l120.704 120.704a42.666667 42.666667 0 0 0 39.210666 11.52z"];
  var close = ["M602.512147 511.99738l402.747939-402.747939a63.999673 63.999673 0 0 0-90.509537-90.509537L512.00261 421.487843 109.254671 18.749904a63.999673 63.999673 0 0 0-90.509537 90.509537L421.493073 511.99738 18.755134 914.745319a63.999673 63.999673 0 0 0 90.509537 90.509537L512.00261 602.506917l402.747939 402.747939a63.999673 63.999673 0 0 0 90.509537-90.509537z"];
  var warning2 = ["M512 981.333333C252.8 981.333333 42.666667 771.2 42.666667 512S252.8 42.666667 512 42.666667s469.333333 210.133333 469.333333 469.333333-210.133333 469.333333-469.333333 469.333333z m0-170.666666a85.333333 85.333333 0 1 0 0-170.666667 85.333333 85.333333 0 0 0 0 170.666667z m0-597.333334a64 64 0 0 0-64 64v256a64 64 0 0 0 128 0v-256A64 64 0 0 0 512 213.333333z"];
  var info = ["M512 981.333333C252.8 981.333333 42.666667 771.2 42.666667 512S252.8 42.666667 512 42.666667s469.333333 210.133333 469.333333 469.333333-210.133333 469.333333-469.333333 469.333333z m0-597.333333a85.333333 85.333333 0 1 0 0-170.666667 85.333333 85.333333 0 0 0 0 170.666667z m0 42.666667a64 64 0 0 0-64 64v256a64 64 0 0 0 128 0v-256A64 64 0 0 0 512 426.666667z"];
  var danger = ["M512 981.333333C252.757333 981.333333 42.666667 771.242667 42.666667 512S252.757333 42.666667 512 42.666667s469.333333 210.090667 469.333333 469.333333-210.090667 469.333333-469.333333 469.333333z m0-529.664L361.130667 300.8A42.666667 42.666667 0 0 0 300.8 361.130667L451.669333 512 300.8 662.869333a42.666667 42.666667 0 0 0 60.330667 60.330667L512 572.330667l150.869333 150.869333a42.666667 42.666667 0 0 0 60.330667-60.330667L572.330667 512l150.869333-150.869333a42.666667 42.666667 0 1 0-60.330667-60.330667L512 451.669333z"];
  var confirm = ["M514.048 54.272q95.232 0 178.688 36.352t145.92 98.304 98.304 145.408 35.84 178.688-35.84 178.176-98.304 145.408-145.92 98.304-178.688 35.84-178.176-35.84-145.408-98.304-98.304-145.408-35.84-178.176 35.84-178.688 98.304-145.408 145.408-98.304 178.176-36.352zM515.072 826.368q26.624 0 44.544-17.92t17.92-43.52q0-26.624-17.92-44.544t-44.544-17.92-44.544 17.92-17.92 44.544q0 25.6 17.92 43.52t44.544 17.92zM567.296 574.464q-1.024-16.384 20.48-34.816t48.128-40.96 49.152-50.688 24.576-65.024q2.048-39.936-8.192-74.752t-33.792-59.904-60.928-39.936-87.552-14.848q-62.464 0-103.936 22.016t-67.072 53.248-35.84 64.512-9.216 55.808q1.024 26.624 16.896 38.912t34.304 12.8 33.792-10.24 15.36-31.232q0-12.288 7.68-30.208t20.992-34.304 32.256-27.648 42.496-11.264q46.08 0 73.728 23.04t25.6 57.856q0 17.408-10.24 32.256t-26.112 28.672-33.792 27.648-33.792 28.672-26.624 32.256-11.776 37.888l1.024 38.912q0 15.36 14.336 29.184t37.888 14.848q23.552-1.024 37.376-15.36t12.8-32.768l0-24.576z"];
  var calendar = ["M888 128H768v-28c0-19.9-16.1-36-36-36s-36 16.1-36 36v28H328v-28c0-19.9-16.1-36-36-36s-36 16.1-36 36v28H136c-39.8 0-72 32.2-72 72v688c0 39.8 32.2 72 72 72h752c39.8 0 72-32.3 72-72V200c0-39.8-32.2-72-72-72z m-752 72h120v20c0 19.9 16.1 36 36 36s36-16.1 36-36v-20h368v20c0 19.9 16.1 36 36 36s36-16.1 36-36v-20h120v112H136V200z m752 688H136V384h752v504zM288 512h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32s14.3-32 32-32z m192 0h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32s14.3-32 32-32z m192 0h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32s14.3-32 32-32zM288 706h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32s14.3-32 32-32z m192 0h64c17.7 0 32 14.3 32 32s-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32s14.3-32 32-32z"];
  var clock = ["M512 0C229.2 0 0 229.2 0 512s229.2 512 512 512 512-229.2 512-512S794.8 0 512 0z m311.1 823.1c-40.4 40.4-87.5 72.2-139.9 94.3C629 940.4 571.4 952 512 952s-117-11.6-171.2-34.5c-52.4-22.2-99.4-53.9-139.9-94.3-40.4-40.4-72.2-87.5-94.3-139.9C83.6 629 72 571.4 72 512s11.6-117 34.5-171.2c22.2-52.4 53.9-99.4 94.3-139.9 40.4-40.4 87.5-72.2 139.9-94.3C395 83.6 452.6 72 512 72s117 11.6 171.2 34.5c52.4 22.2 99.4 53.9 139.9 94.3 40.4 40.4 72.2 87.5 94.3 139.9C940.4 395 952 452.6 952 512s-11.6 117-34.5 171.2c-22.2 52.4-53.9 99.5-94.4 139.9zM733 504H548V264c0-19.9-16.1-36-36-36s-36 16.1-36 36v240c0 39.8 32.2 72 72 72h185c19.9 0 36-16.1 36-36s-16.1-36-36-36z"];
  var closeCircle = ["M512 0C229.2 0 0 229.2 0 512s229.2 512 512 512 512-229.2 512-512S794.8 0 512 0z m205.3 666.9c14 14.1 14 36.9-0.1 50.9-7 7-16.2 10.5-25.4 10.5s-18.5-3.5-25.5-10.6L512 563 357.7 717.7c-7 7.1-16.3 10.6-25.5 10.6s-18.4-3.5-25.4-10.5c-14.1-14-14.1-36.8-0.1-50.9L461.2 512 306.7 357.1c-14-14.1-14-36.9 0.1-50.9s36.9-14 50.9 0.1L512 461l154.3-154.8c14-14.1 36.8-14.1 50.9-0.1 14.1 14 14.1 36.8 0.1 50.9L562.8 512l154.5 154.9z"];
  var recovery = ["M172.48576 236.450998C136.975206 271.874676 110.324493 311.941187 92.439616 356.650531 74.383834 401.273 65.011296 447.272653 64.065638 494.689368 63.206854 542.107506 70.772109 589.267867 86.937997 636.257327 102.92729 683.20121 127.60409 726.449344 160.706355 766.041606 162.597664 768.791699 164.316653 771.201414 165.866163 773.262208 167.586573 775.369997 169.476467 777.563238 171.711008 779.840506L291.222662 899.312282C299.047117 907.135309 308.161882 913.454406 318.564102 918.269568 328.882304 923.084723 339.374253 926.13817 350.292032 927.253306 361.038906 928.415437 371.698912 927.683405 382.017107 925.191091 392.335306 922.653197 401.018543 917.924915 407.897342 911.004813 414.863016 904.126016 419.676751 895.613677 422.426847 885.426502 425.178366 875.364659 425.866246 865.003738 424.490486 854.429184 423.114726 843.81191 420.10543 833.449562 415.549472 823.34784 410.906639 813.204813 404.71572 804.260954 396.891264 796.436493L289.160442 690.081434C264.742842 665.662413 246.25696 638.234091 233.61735 607.624148 220.892282 576.974328 214.185811 546.021158 213.238726 514.723335 212.293069 483.471086 217.451456 452.905293 228.802189 423.242431 240.066042 393.579569 257.433946 366.967306 280.904461 343.495363 303.003494 321.39918 327.851194 304.848761 355.362118 293.755808 383.048218 282.751154 411.76542 276.860737 441.428282 276.172858 471.091144 275.484977 500.323903 280.085085 529.041108 289.97318 557.843764 299.859852 584.669655 314.950484 609.517357 335.198079 610.463014 336.143735 610.893117 336.831615 610.893117 337.304444 610.893117 337.778696 611.408671 338.379701 612.268877 339.325358L722.066185 449.121242 667.468746 503.675956C659.731165 511.500412 656.979645 520.355974 659.558839 530.242646 662.138033 540.130741 674.432995 547.82702 696.530603 553.371361 702.549196 554.789846 712.350416 556.638434 726.278915 558.917125 740.036513 561.194392 756.200978 563.861885 774.944637 566.828456 793.51597 569.834904 813.205285 572.931076 833.925709 576.155424L894.627192 584.454132C907.094481 585.828468 918.013684 586.859575 927.471676 587.591605 936.929668 588.278061 944.839575 585.399789 951.286847 578.949668 956.876761 573.44663 959.626856 564.719243 959.971508 553.069434 960.14241 541.290025 959.541405 528.737286 958.251096 515.411215 956.876761 500.236556 954.984023 482.266228 952.748058 461.587106 950.342614 440.866683 947.934323 420.489487 945.44058 400.45552 942.946837 380.422977 940.712296 362.367197 938.819558 346.289608 937.015119 330.125142 935.552484 318.861287 934.692278 312.412591 931.510656 293.540756 924.116303 282.964781 912.681546 280.68609 901.159914 278.364673 890.498488 281.589021 880.86817 290.316408L825.669725 345.557578 715.788391 235.761694C713.55385 233.483003 710.887781 231.333912 707.878484 229.183398 704.954639 227.163908 702.030794 225.228445 699.279274 223.379857 659.729741 191.095076 616.652509 167.020704 570.138726 150.900388 523.70897 134.735923 476.765085 127.169244 429.304221 128.072175 381.930234 129.017832 336.016032 138.561276 291.564461 156.745231 247.202618 174.933459 207.479334 201.501573 172.48576 236.450998"];
  var del = ["M974.991554 109.146486 647.781177 109.146486c0-2.225921 2.225921-4.451842 2.225921-6.677763 0-55.648023-46.74434-102.392363-102.392363-102.392363l-66.777628 0C422.963163-2.14956 378.444744 44.594779 378.444744 100.242803c0 2.225921 0 4.451842 2.225921 6.677763L49.008446 106.920565c-22.259209 0-40.066577 17.807367-40.066577 40.066577s17.807367 40.066577 40.066577 40.066577l77.907233 0 0 636.613387c0 111.296047 91.262758 200.332884 200.332884 200.332884l389.536163 0c111.296047 0 200.332884-91.262758 200.332884-200.332884L917.11761 189.27964l60.099865 0c22.259209 0 40.066577-17.807367 40.066577-40.066577S997.250763 109.146486 974.991554 109.146486zM458.577898 100.242803c0-11.129605 11.129605-22.259209 22.259209-22.259209l66.777628 0c11.129605 0 22.259209 11.129605 22.259209 22.259209 0 2.225921 0 4.451842 2.225921 6.677763l-113.521968 0C456.351977 106.920565 458.577898 102.468724 458.577898 100.242803zM836.984456 825.893026c0 66.777628-53.422102 120.19973-120.19973 120.19973L327.248563 946.092757c-66.777628 0-120.19973-53.422102-120.19973-120.19973L207.048832 189.27964l629.935624 0L836.984456 825.893026z", "M411.833558 756.889478c22.259209 0 40.066577-17.807367 40.066577-40.066577l0-311.62893c0-22.259209-17.807367-40.066577-40.066577-40.066577s-40.066577 17.807367-40.066577 40.066577l0 311.62893C371.766981 739.08211 389.574349 756.889478 411.833558 756.889478z", "M632.19973 756.889478c22.259209 0 40.066577-17.807367 40.066577-40.066577l0-311.62893c0-22.259209-17.807367-40.066577-40.066577-40.066577-22.259209 0-40.066577 17.807367-40.066577 40.066577l0 311.62893C592.133154 739.08211 609.940521 756.889478 632.19973 756.889478z"];
  var angleLeft = ["M304.905 561.68c-11.785 0-23.57-4.496-32.562-13.488-17.984-17.983-17.984-47.139 0-65.122l402.522-402.522c17.982-17.983 47.14-17.983 65.122 0 17.984 17.984 17.984 47.14 0 65.123l-402.521 402.521c-8.992 8.993-20.776 13.488-32.562 13.488z", "M707.426 964.201c-11.785 0-23.57-4.496-32.561-13.488l-402.523-402.522c-17.984-17.983-17.984-47.139 0-65.122 17.983-17.983 47.14-17.983 65.123 0l402.521 402.522c17.984 17.983 17.984 47.139 0 65.122-8.991 8.992-20.776 13.488-32.561 13.488z"];
  var angleRight = ["M728.76 561.68c-11.785 0-23.57-4.496-32.561-13.488l-402.523-402.521c-17.984-17.984-17.984-47.14 0-65.123 17.983-17.983 47.14-17.983 65.123 0l402.521 402.522c17.984 17.984 17.984 47.14 0 65.122-8.991 8.993-20.776 13.488-32.561 13.488z", "M326.238 964.202c-11.785 0-23.57-4.496-32.562-13.488-17.984-17.983-17.984-47.139 0-65.122l402.522-402.522c17.982-17.983 47.14-17.983 65.122 0 17.984 17.984 17.984 47.14 0 65.122l-402.521 402.522c-8.992 8.992-20.776 13.488-32.562 13.488z"];
  var angleDoubleLeft = ["M219.5 511.3l336.7-336.7c25-25 25-65.4 0-90.4-25-24.9-65.4-24.9-90.4 0L86.5 463.5c-0.9 0.8-1.8 1.7-2.7 2.5-25 25-25 65.4 0 90.4l381.3 381.3c25 25 65.4 25 90.4 0s25-65.4 0-90.4l-336-336z", "M601.5 511.5l336.7-336.7c25-25 25-65.4 0-90.4-25-24.9-65.4-24.9-90.4 0L468.5 463.7c-0.9 0.8-1.8 1.7-2.7 2.5-25 25-25 65.4 0 90.4l381.3 381.3c25 25 65.4 25 90.4 0s25-65.4 0-90.4l-336-336z"];
  var angleDoubleRight = ["M802.5 511.3L465.8 174.6c-25-25-25-65.4 0-90.4 25-24.9 65.4-24.9 90.4 0l379.3 379.3c0.9 0.8 1.8 1.7 2.7 2.5 25 25 25 65.4 0 90.4L556.9 937.7c-25 25-65.4 25-90.4 0s-25-65.4 0-90.4l336-336z", "M420.5 511.5L83.8 174.8c-25-25-25-65.4 0-90.4 25-24.9 65.4-24.9 90.4 0l379.3 379.3c0.9 0.8 1.8 1.7 2.7 2.5 25 25 25 65.4 0 90.4L174.9 937.9c-25 25-65.4 25-90.4 0s-25-65.4 0-90.4l336-336z"];
  var check = ["M913.017 237.02c-25.311-25.312-66.349-25.312-91.66 0l-412.475 412.474-206.237-206.237c-25.312-25.312-66.35-25.312-91.661 0s-25.312 66.35 0 91.66l252.067 252.067c0.729 0.73 1.439 1.402 2.134 2.029 25.434 23.257 64.913 22.585 89.527-2.029l458.303-458.303c25.313-25.312 25.313-66.35 0.001-91.661z"];
  var search = ["M994.112 858.368L769.152 633.408C808.32 569.984 832 496 832 416 832 186.24 645.76 0 416 0S0 186.24 0 416 186.24 832 416 832c80 0 153.984-23.68 217.344-62.784l225.024 224.96a96.021333 96.021333 0 0 0 135.744-135.808zM416 704C256.96 704 128 575.04 128 416S256.96 128 416 128 704 256.96 704 416 575.04 704 416 704z"];
  var caretLine = ["M149.973333 434.005333l120.661334-120.704L512 554.666667l241.365333-241.365334 120.661334 120.704-241.365334 241.322667L512 796.032l-362.026667-362.026667z"];
  var caretFill = ["M194.048 341.333333h636.842667c18.005333 0 30.592 23.125333 16.213333 39.125334l-311.253333 376.874666c-10.794667 14.208-34.133333 14.208-44.970667 0L176.085333 380.458667C163.498667 364.458667 174.293333 341.333333 194.048 341.333333z"];
  var preview = ["M732.885333 479.914667C651.008 417.109333 572.970667 384 512 384c-61.013333 0-139.093333 33.066667-220.928 95.829333-15.189333 11.648-30.037333 24.021333-43.946667 36.48 13.909333 12.501333 28.8 24.874667 43.989334 36.522667 81.92 62.762667 160 95.872 221.013333 95.872 61.013333 0 139.050667-33.066667 220.885333-95.786667 15.146667-11.648 29.994667-23.978667 43.861334-36.437333a741.461333 741.461333 0 0 0-43.989334-36.565333z m145.237334 16.213333c6.912 7.424 12.970667 14.336 17.877333 20.352-4.906667 5.973333-10.965333 12.885333-17.834667 20.266667a778.922667 778.922667 0 0 1-93.269333 83.882666c-92.245333 70.741333-187.818667 113.408-272.768 113.408-84.949333 0-180.565333-42.709333-272.896-113.493333a780.373333 780.373333 0 0 1-93.354667-83.925333A427.648 427.648 0 0 1 128 516.352c4.906667-6.016 10.965333-12.928 17.877333-20.309333A779.52 779.52 0 0 1 239.146667 412.16C331.52 341.333333 427.093333 298.666667 512 298.666667c84.906667 0 180.48 42.709333 272.810667 113.536a780.544 780.544 0 0 1 93.312 83.968zM128 128v128a42.666667 42.666667 0 1 1-85.333333 0V85.333333a42.666667 42.666667 0 0 1 42.666666-42.666666h170.666667a42.666667 42.666667 0 1 1 0 85.333333H128z m0 768h128a42.666667 42.666667 0 0 1 0 85.333333H85.333333a42.666667 42.666667 0 0 1-42.666666-42.666666v-170.666667a42.666667 42.666667 0 0 1 85.333333 0v128zM896 128h-128a42.666667 42.666667 0 0 1 0-85.333333h170.666667a42.666667 42.666667 0 0 1 42.666666 42.666666v170.666667a42.666667 42.666667 0 0 1-85.333333 0V128z m0 768v-128a42.666667 42.666667 0 0 1 85.333333 0v170.666667a42.666667 42.666667 0 0 1-42.666666 42.666666h-170.666667a42.666667 42.666667 0 0 1 0-85.333333h128z m-384-277.333333a106.666667 106.666667 0 1 1 0-213.333334 106.666667 106.666667 0 0 1 0 213.333334z m0-85.333334a21.333333 21.333333 0 1 0 0-42.666666 21.333333 21.333333 0 0 0 0 42.666666z"];
  const icons = {
    AngleLeft: icon(angleLeft),
    AngleRight: icon(angleRight),
    AngleDoubleLeft: icon(angleDoubleLeft),
    AngleDoubleRight: icon(angleDoubleRight),
    CaretLine: icon(caretLine),
    CaretFill: icon(caretFill),
    Calendar: icon(calendar),
    Clock: icon(clock),
    Close: icon(close),
    CloseCircle: icon(closeCircle),
    Confirm: icon(confirm),
    Danger: icon(danger),
    Delete: icon(del),
    Error: icon(danger),
    Info: icon(info),
    SEARCH: icon(search),
    Success: icon(success),
    Recovery: icon(recovery),
    Warning: icon(warning2),
    Check: icon(check),
    Preview: icon(preview),
    Confirmwarning: icon(warning2)
  };
  var Alert = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(Alert2, _PureComponent);
    function Alert2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this.state = {
        dismiss: 0
      };
      _this.bindRef = _this.bindRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.dismiss = _this.dismiss.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleClose = _this.handleClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.renderClose = _this.renderClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }
    var _proto = Alert2.prototype;
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.dismiss !== prevProps.dismiss && this.props.dismiss) {
        this.handleClose();
      }
    };
    _proto.bindRef = function bindRef(el) {
      this.element = el;
    };
    _proto.dismiss = function dismiss() {
      var onClose = this.props.onClose;
      this.setState({
        dismiss: 2
      });
      if (typeof onClose === "function") {
        onClose();
      }
    };
    _proto.handleClose = function handleClose() {
      var _this2 = this;
      if (this.state.dismiss > 0)
        return;
      var _this$props = this.props, duration = _this$props.duration, outAnimation = _this$props.outAnimation, onClose = _this$props.onClose;
      if (outAnimation) {
        if (typeof onClose === "function") {
          onClose(duration, this.element.offsetHeight);
        }
        return;
      }
      if (duration > 0) {
        this.setState({
          dismiss: 1
        }, function() {
          setTimeout(_this2.dismiss, duration);
        });
      } else {
        this.dismiss();
      }
    };
    _proto.renderIcon = function renderIcon() {
      var icon2 = this.props.icon;
      var _this$props2 = this.props, type4 = _this$props2.type, iconSize = _this$props2.iconSize;
      if (typeof icon2 === "boolean" && icon2) {
        icon2 = icons[capitalize(type4)];
      }
      if (!icon2)
        return null;
      var style2 = {
        width: iconSize,
        height: iconSize,
        marginRight: iconSize / 2
      };
      if (isRTL()) {
        style2.marginLeft = style2.marginRight;
        delete style2.marginRight;
      }
      return React.createElement("div", {
        className: alertClass("icon"),
        style: style2
      }, icon2);
    };
    _proto.renderClose = function renderClose() {
      var closeItem = this.props.closeItem;
      if (React.isValidElement(closeItem))
        return React.cloneElement(closeItem, {
          onClick: this.handleClose
        });
      return React.createElement("a", {
        className: alertClass("close"),
        onClick: this.handleClose
      }, closeItem || icons.Close);
    };
    _proto.render = function render2() {
      var dismiss = this.state.dismiss;
      if (dismiss === 2)
        return null;
      var _this$props3 = this.props, children = _this$props3.children, className = _this$props3.className, type4 = _this$props3.type, onClose = _this$props3.onClose, outAnimation = _this$props3.outAnimation, hideClose = _this$props3.hideClose;
      var icon2 = this.renderIcon();
      var style2 = this.props.style;
      var showClose = onClose && !hideClose;
      var wrapClassName = alertClass("_", type4, !outAnimation && dismiss === 1 && "dismissed", showClose && "with-close", icon2 && "with-icon", isRTL() && "rtl");
      if (className)
        wrapClassName += " " + className;
      return React.createElement("div", {
        ref: this.bindRef,
        className: wrapClassName,
        style: style2
      }, showClose && this.renderClose(), icon2, React.createElement("div", {
        className: alertClass("content")
      }, children));
    };
    return Alert2;
  }(PureComponent);
  Alert.propTypes = _objectSpread$1({}, getProps(propTypes, "type"), {
    children: propTypes.any,
    dismiss: propTypes.bool,
    duration: propTypes.number,
    icon: propTypes.oneOfType([propTypes.bool, propTypes.element]),
    iconSize: propTypes.number,
    onClose: propTypes.oneOfType([propTypes.func, propTypes.bool]),
    hideClose: propTypes.bool
  });
  Alert.defaultProps = _objectSpread$1({}, defaultProps, {
    duration: 200,
    iconSize: 16,
    type: "warning"
  });
  Alert.displayName = "ShineoutAlert";
  const Alert$1 = Alert;
  var Confirm = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(Confirm2, _Component);
    function Confirm2(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.state = {
        ok: false,
        cancel: false
      };
      _this.handleCancel = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)), "cancel");
      _this.handleOk = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)), "ok");
      return _this;
    }
    var _proto = Confirm2.prototype;
    _proto.handleClick = function handleClick(type4, close2) {
      var _this2 = this;
      var _this$props = this.props, onOk = _this$props.onOk, onCancel = _this$props.onCancel;
      var fn = type4 === "ok" ? onOk : onCancel;
      var callback;
      if (fn)
        callback = fn();
      if (callback && typeof callback.then === "function") {
        var _this$setState;
        this.setState((_this$setState = {}, _this$setState[type4] = true, _this$setState), function() {
          callback.then(function() {
            var _this2$setState;
            close2();
            _this2.setState((_this2$setState = {}, _this2$setState[type4] = false, _this2$setState));
          });
        });
      } else {
        close2();
      }
    };
    _proto.render = function render2() {
      var _this3 = this;
      var _this$props2 = this.props, children = _this$props2.children, type4 = _this$props2.type, text = _this$props2.text;
      _this$props2.onOk;
      var okType = _this$props2.okType;
      _this$props2.onCancel;
      var icon2 = _this$props2.icon, other = _objectWithoutPropertiesLoose$8(_this$props2, ["children", "type", "text", "onOk", "okType", "onCancel", "icon"]);
      var _this$state = this.state, ok = _this$state.ok, cancel = _this$state.cancel;
      return React.createElement(Popover, _extends$7({}, other, {
        trigger: "click"
      }), function(close2) {
        return React.createElement("div", {
          className: popoverClass("confirm")
        }, React.createElement("div", {
          className: popoverClass("mention")
        }, React.createElement(Alert$1, {
          type: type4,
          icon: icon2,
          className: popoverClass("alert")
        }, children)), React.createElement("div", {
          className: popoverClass("footer")
        }, React.createElement(Button$1, {
          loading: cancel,
          size: "small",
          onClick: function onClick() {
            return _this3.handleCancel(close2);
          }
        }, getLocale("cancel", text)), React.createElement(Button$1, {
          loading: ok,
          size: "small",
          type: okType,
          onClick: function onClick() {
            return _this3.handleOk(close2);
          }
        }, getLocale("ok", text))));
      });
    };
    return Confirm2;
  }(Component$1);
  Confirm.propTypes = _objectSpread$1({}, getProps(propTypes, "type"), {
    children: propTypes.oneOfType([propTypes.element, propTypes.string]),
    text: propTypes.object,
    onOk: propTypes.func,
    onCancel: propTypes.func,
    okType: propTypes.string,
    icon: propTypes.oneOfType([propTypes.bool, propTypes.node])
  });
  Confirm.defaultProps = {
    type: "confirmwarning",
    icon: true,
    okType: "danger"
  };
  function Content(props) {
    return React.createElement(Panel$1, _extends$7({}, props, {
      useTextStyle: true
    }));
  }
  var Component = create(events);
  function Popover(props) {
    if (props.content)
      return React.createElement(Component, props);
    return React.createElement(Panel$1, props);
  }
  Popover.displayName = "ShineoutPopover";
  Popover.Confirm = Confirm;
  Popover.Confirm.displayName = "ShineoutPopoverConfirm";
  Popover.Content = Content;
  const inputBorder = curry(function(options, Origin) {
    var _class, _temp;
    return _temp = _class = /* @__PURE__ */ function(_Component) {
      _inheritsLoose(_class2, _Component);
      function _class2(props) {
        var _this;
        _this = _Component.call(this, props) || this;
        _this.el = null;
        _this.state = {
          focus: props.autoFocus
        };
        _this.bindRef = _this.bindRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.handleBlur = _this.handleBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.handleFocus = _this.handleFocus.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }
      var _proto = _class2.prototype;
      _proto.bindRef = function bindRef(el) {
        this.el = el;
      };
      _proto.handleBlur = function handleBlur(event) {
        this.setState({
          focus: false
        });
        var onBlur = this.props.onBlur;
        if (onBlur)
          onBlur(event);
      };
      _proto.handleFocus = function handleFocus(event) {
        this.setState({
          focus: true
        });
        var onFocus = this.props.onFocus;
        if (onFocus)
          onFocus(event);
      };
      _proto.renderHelp = function renderHelp(focus) {
        var _this2 = this;
        var _this$props = this.props, error = _this$props.error, tip = _this$props.tip, popover = _this$props.popover, popoverProps = _this$props.popoverProps;
        var classList = ["input-tip"];
        var position2 = popover || (isRTL() ? "bottom-right" : "bottom-left");
        var styles2 = popoverProps.style && popoverProps.style.width ? popoverProps.style : Object.assign({
          minWidth: 200,
          maxWidth: 400
        }, popoverProps.style || {});
        if (error && popover || tip && focus) {
          if (error)
            classList.push("input-error");
          return React.createElement(Popover, _extends$7({
            getPopupContainer: function getPopupContainer() {
              return _this2.el;
            }
          }, popoverProps, {
            visible: true,
            style: styles2,
            className: popoverClass.apply(void 0, classList),
            position: position2
          }), error ? error.message : tip);
        }
        return null;
      };
      _proto.render = function render2() {
        var _this$props2 = this.props;
        _this$props2.className;
        var border = _this$props2.border, size = _this$props2.size;
        _this$props2.tip;
        var popover = _this$props2.popover, width = _this$props2.width, style2 = _this$props2.style, error = _this$props2.error;
        _this$props2.popoverProps;
        var underline = _this$props2.underline, other = _objectWithoutPropertiesLoose$8(_this$props2, ["className", "border", "size", "tip", "popover", "width", "style", "error", "popoverProps", "underline"]);
        var focus = this.state.focus;
        var rtl = isRTL();
        var Tag2 = options.tag || "label";
        var newStyle = Object.assign({
          width
        }, style2);
        var isDisabled = typeof other.disabled === "function" ? false : !!other.disabled;
        var newClassName = classname(inputBorderClass(rtl && "rtl"), inputClass("_", rtl && "rtl", focus && !isDisabled && "focus", isDisabled && "disabled", options.isGroup && "group", size, newStyle.width && "inline", !border && "no-border", options.overflow && "overflow-" + options.overflow, error && "invalid", popover && error && "focus", underline && "underline"), buttonClass(options.isGroup && "group", options.from === "input" && options.isGroup && "from-input-group"), typeof options.className === "function" ? options.className(this.props) : options.className, this.props.className);
        return React.createElement(Tag2, _extends$7({
          ref: this.bindRef,
          className: newClassName,
          style: newStyle,
          tabIndex: options.enterPress ? "0" : void 0
        }, getDataset(other)), React.createElement(Origin, _extends$7({}, other, {
          size,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          inputFocus: focus
        })), this.renderHelp(focus));
      };
      return _class2;
    }(Component$1), _defineProperty$1(_class, "propTypes", {
      autoFocus: propTypes.bool,
      border: propTypes.bool,
      className: propTypes.string,
      disabled: propTypes.oneOfType([propTypes.bool, propTypes.func]),
      error: propTypes.object,
      onBlur: propTypes.func,
      onFocus: propTypes.func,
      size: propTypes.string,
      style: propTypes.object,
      tip: propTypes.any,
      width: propTypes.oneOfType([propTypes.number, propTypes.string]),
      popover: propTypes.oneOf(["top-left", "top", "top-right", "bottom-left", "bottom", "bottom-right"]),
      popoverProps: propTypes.object,
      underline: propTypes.bool
    }), _defineProperty$1(_class, "defaultProps", {
      border: true,
      style: {},
      popoverProps: {}
    }), _temp;
  });
  var TagInput = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(TagInput2, _PureComponent);
    function TagInput2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this.bindRef = _this.bindRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleBlur = _this.handleBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleKeyUp = _this.handleKeyUp.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }
    var _proto = TagInput2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      _PureComponent.prototype.componentDidMount.call(this);
      if (this.element)
        this.element.focus();
    };
    _proto.bindRef = function bindRef(el) {
      this.element = el;
    };
    _proto.handleChange = function handleChange(e2) {
      var value = e2.target.value;
      var onChange = this.props.onChange;
      if (onChange)
        onChange(value);
    };
    _proto.handleKeyUp = function handleKeyUp(e2) {
      var _this$props = this.props, onBlur = _this$props.onBlur, onKeyUp = _this$props.onKeyUp, onEnterPress = _this$props.onEnterPress;
      if (e2.keyCode === 13) {
        if (onEnterPress)
          onEnterPress(e2.target.value, e2);
        else if (onBlur)
          onBlur(e2.target.value, e2);
      }
      if (onKeyUp)
        onKeyUp(e2);
    };
    _proto.handleBlur = function handleBlur(e2) {
      var onBlur = this.props.onBlur;
      if (onBlur)
        onBlur(e2.target.value, e2);
    };
    _proto.render = function render2() {
      var _this$props2 = this.props, value = _this$props2.value, onFocus = _this$props2.onFocus;
      return React.createElement("input", {
        ref: this.bindRef,
        type: "text",
        value,
        onFocus,
        onChange: this.handleChange,
        onKeyUp: this.handleKeyUp,
        onBlur: this.handleBlur
      });
    };
    return TagInput2;
  }(PureComponent);
  TagInput.propTypes = {
    value: propTypes.string,
    onBlur: propTypes.func,
    onChange: propTypes.func,
    onKeyUp: propTypes.func,
    onEnterPress: propTypes.func,
    onFocus: propTypes.func
  };
  const Input2 = inputBorder({
    className: tagClass("input")
  })(TagInput);
  var hideInput = 0;
  var showInput = 1;
  var Tag = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(Tag2, _PureComponent);
    function Tag2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this.state = {
        dismiss: 0,
        inputVisible: hideInput,
        // tag input status
        value: null
      };
      _this.dismiss = _this.dismiss.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.handleClose = _this.handleClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.renderClose = _this.renderClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.closeTag = _this.closeTag.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.toggleInputVisible = _this.toggleInputVisible.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.inputBlur = _this.inputBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.inputChange = _this.inputChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }
    var _proto = Tag2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      var _this$props = this.props, children = _this$props.children, onCompleted = _this$props.onCompleted;
      if (onCompleted && isString$1(children) && !isEmpty(children)) {
        this.setState({
          value: children
        });
      }
    };
    _proto.closeTag = function closeTag(dismiss) {
      if (dismiss === void 0) {
        dismiss = 2;
      }
      this.setState({
        dismiss
      });
    };
    _proto.dismiss = function dismiss(e2) {
      var _this2 = this;
      var onClose = this.props.onClose;
      var callback;
      if (onClose === true) {
        this.closeTag();
        return;
      }
      if (typeof onClose === "function") {
        callback = onClose(e2);
      }
      if (isPromise(callback)) {
        this.setState({
          dismiss: 1
        });
        callback.then(function() {
          _this2.closeTag();
        }).catch(function() {
          _this2.closeTag(0);
        });
        return;
      }
      if (e2.defaultPrevented) {
        return;
      }
      this.closeTag();
    };
    _proto.inputBlur = function inputBlur(value) {
      var onCompleted = this.props.onCompleted;
      if (isFunc(onCompleted))
        onCompleted(value);
      this.setState({
        inputVisible: hideInput
      });
    };
    _proto.inputChange = function inputChange(value) {
      this.setState({
        value
      });
    };
    _proto.toggleInputVisible = function toggleInputVisible() {
      var _this$state = this.state, inputVisible = _this$state.inputVisible, value = _this$state.value;
      var onCompleted = this.props.onCompleted;
      if (onCompleted && !isEmpty(value)) {
        this.setState({
          inputVisible: inputVisible === hideInput ? showInput : hideInput
        });
      }
    };
    _proto.handleClick = function handleClick(e2) {
      var _this$props2 = this.props, onClick = _this$props2.onClick, disabled = _this$props2.disabled;
      if (disabled)
        return;
      this.toggleInputVisible();
      if (typeof onClick === "function") {
        onClick(e2);
      }
    };
    _proto.handleClose = function handleClose(e2) {
      var disabled = this.props.disabled;
      if (this.state.dismiss > 0 || disabled)
        return;
      this.dismiss(e2);
    };
    _proto.renderClose = function renderClose(dismiss) {
      var onClose = this.props.onClose;
      if (!onClose)
        return null;
      var closeClass = tagClass("close-icon");
      var loadingClass = tagClass("close-loading");
      if (dismiss === 0) {
        return React.createElement("div", {
          className: closeClass,
          onClick: this.handleClose
        }, icons.Close);
      }
      return React.createElement("div", {
        className: loadingClass
      }, React.createElement(Spin$1, {
        name: "ring",
        size: 10
      }));
    };
    _proto.render = function render2() {
      var _this$state2 = this.state, dismiss = _this$state2.dismiss, inputVisible = _this$state2.inputVisible, value = _this$state2.value;
      if (dismiss === 2)
        return null;
      var _this$props3 = this.props, children = _this$props3.children, className = _this$props3.className, type4 = _this$props3.type, backgroundColor = _this$props3.backgroundColor, onClose = _this$props3.onClose, disabled = _this$props3.disabled, onCompleted = _this$props3.onCompleted, onEnterPress = _this$props3.onEnterPress, onKeyUp = _this$props3.onKeyUp;
      var rtl = isRTL();
      if (onCompleted && inputVisible === showInput)
        return React.createElement(Input2, {
          value,
          onBlur: this.inputBlur,
          onChange: this.inputChange,
          onEnterPress,
          onKeyUp
        });
      var childrenParsed = wrapSpan(children);
      var style2 = this.props.style;
      var tagClassName = tagClass("_", disabled && "disabled", type4, rtl && "rtl");
      var inlineClassName = tagClass("inline");
      var click = !onClose ? {
        onClick: this.handleClick
      } : {};
      var tagStyle = style2 || {};
      if (className)
        tagClassName += " " + className;
      if (backgroundColor) {
        tagStyle = _objectSpread$1({
          color: isDark(backgroundColor) ? "#fff" : "#000",
          backgroundColor,
          borderColor: "transparent"
        }, style2);
      }
      return React.createElement("div", _extends$7({
        className: tagClassName,
        style: tagStyle
      }, click, getDataset(this.props)), onClose ? React.createElement("div", {
        onClick: this.handleClick,
        className: inlineClassName
      }, childrenParsed) : childrenParsed, this.renderClose(dismiss));
    };
    return Tag2;
  }(PureComponent);
  Tag.propTypes = _objectSpread$1({}, getProps(propTypes, "type"), {
    children: propTypes.any,
    onClose: propTypes.oneOfType([propTypes.func, propTypes.bool]),
    backgroundColor: propTypes.string,
    onCompleted: propTypes.func,
    onKeyUp: propTypes.func,
    onEnterPress: propTypes.func
  });
  Tag.defaultProps = _objectSpread$1({}, defaultProps, {
    type: "default"
  });
  const Tag$1 = Tag;
  Tag$1.Input = Input2;
  Tag$1.displayName = "ShinoutTag";
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f2() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var ieVersion = Number(document.documentMode);
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var camelCase = (name) => name.replace(SPECIAL_CHARS_REGEXP, (_, separator, letter, offset) => offset ? letter.toUpperCase() : letter).replace(MOZ_HACK_REGEXP, "Moz$1");
  var precision = (num, prc) => {
    var reg = new RegExp(`^\\d+(?:\\.\\d{0,${prc}})?`);
    return Number(num.toString().match(reg));
  };
  var getStyle = ieVersion < 9 ? (element, styleName) => {
    if (!element || !styleName)
      return null;
    var name = camelCase(styleName);
    if (name === "float") {
      name = "styleFloat";
    }
    try {
      switch (name) {
        case "opacity":
          try {
            return element.filters.item("alpha").opacity / 100;
          } catch (e2) {
            return 1;
          }
        default:
          return element.style[name] || element.currentStyle ? element.currentStyle[name] : null;
      }
    } catch (e2) {
      return element.style[name];
    }
  } : (element, styleName) => {
    var name = camelCase(styleName);
    if (!element || !name)
      return null;
    name = camelCase(name);
    if (name === "float") {
      name = "cssFloat";
    }
    try {
      var computed = document.defaultView.getComputedStyle(element, "");
      return element.style[name] || computed ? computed[name] : null;
    } catch (e2) {
      return element.style[name];
    }
  };
  function isOverX(ref) {
    var target = ref.current || ref;
    var range3 = document.createRange();
    range3.setStart(target, 0);
    range3.setEnd(target, target.childNodes.length);
    var rangeWidth = range3.getBoundingClientRect().width;
    var targetWidth = target.getBoundingClientRect().width;
    var padding = (parseInt(getStyle(target, "paddingLeft"), 10) || 0) + (parseInt(getStyle(target, "paddingRight"), 10) || 0);
    var textResult = precision(rangeWidth + padding, 2);
    var containerResult = precision(targetWidth, 2);
    return textResult > containerResult || target.scrollWidth > target.offsetWidth;
  }
  function isOverY(ref) {
    var target = ref.current || ref;
    return target.scrollHeight > target.clientHeight || isOverX(ref);
  }
  function resizeCall(el, cb) {
    if (window.ResizeObserver) {
      var ro = new window.ResizeObserver((entries) => {
        var _iterator = _createForOfIteratorHelper(entries), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var entry = _step.value;
            cb(entry);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      ro.observe(el);
      return () => {
        ro.disconnect();
      };
    }
    window.addEventListener("resize", cb);
    return () => {
      window.removeEventListener("resize", cb);
    };
  }
  var _excluded$6 = ["value", "max", "popClass", "popProps", "renderItem", "overHide", "rows", "isArLang", "observeResize"];
  function _extends$4() {
    _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$4.apply(this, arguments);
  }
  function _objectWithoutProperties$6(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$6(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$6(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var styles$2 = {
    "ellipsis": "shein-components_ellipsis_ellipsis",
    "hide": "shein-components_ellipsis_hide",
    "more": "shein-components_ellipsis_more",
    "popStyle": "shein-components_ellipsis_popStyle",
    "pointer": "shein-components_ellipsis_pointer",
    "ellipsisWrap": "shein-components_ellipsis_ellipsisWrap",
    "beforeText": "shein-components_ellipsis_beforeText",
    "endText": "shein-components_ellipsis_endText",
    "text": "shein-components_ellipsis_text",
    "autoSizeWrap": "shein-components_ellipsis_autoSizeWrap",
    "autoSizeIn": "shein-components_ellipsis_autoSizeIn",
    "flexWrap": "shein-components_ellipsis_flexWrap",
    "grow": "shein-components_ellipsis_grow",
    "arLang": "shein-components_ellipsis_arLang",
    "tagWrap": "shein-components_ellipsis_tagWrap",
    "arrayEllipsis": "shein-components_ellipsis_arrayEllipsis"
  };
  class OverPop extends React.Component {
    constructor(props) {
      super(props);
      this.onResize = () => {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this.timer = setTimeout(this.updatePop, 0);
      };
      this.state = {
        renderList: props.value,
        popList: [],
        pop: false
      };
      this.updatePop = this.updatePop.bind(this);
    }
    componentDidMount() {
      this.updatePop();
      var observeResize = this.props.observeResize;
      if (observeResize && this.myRef) {
        this.disconnect = resizeCall(this.myRef.parentElement, this.onResize);
      }
    }
    componentDidUpdate(prevProps) {
      var _this$props = this.props, max = _this$props.max, value = _this$props.value;
      if (prevProps.max !== max || prevProps.value !== value) {
        this.updatePop();
      }
    }
    componentWillUnmount() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      if (this.disconnect) {
        this.disconnect();
      }
    }
    // 屏幕resize
    // 获取是否溢出
    updatePop() {
      var _this$props2 = this.props, value = _this$props2.value, max = _this$props2.max, overHide = _this$props2.overHide, rows = _this$props2.rows;
      var $ref = this.myRef;
      var maxWidth = $ref.parentElement.offsetWidth;
      var height = $ref.offsetHeight;
      var len = false, num = false, m2 = 0;
      if (overHide && $ref.scrollWidth > maxWidth || $ref.children.length && rows && height > $ref.children[0].offsetHeight * rows) {
        var itemCount = $ref.childElementCount;
        var W = 36;
        m2 = itemCount;
        var currentRow = 1;
        for (var i = 0; i < itemCount; i++) {
          W += $ref.children[i].offsetWidth;
          if (rows) {
            if (currentRow < rows && W > currentRow * maxWidth) {
              W = maxWidth * currentRow + $ref.children[i].offsetWidth;
              currentRow += 1;
            }
            if (W > maxWidth * rows) {
              m2 = i;
              break;
            }
          } else if (W > maxWidth) {
            m2 = i;
            break;
          }
        }
        len = true;
      } else {
        len = false;
      }
      if (value.length > max) {
        num = true;
      } else {
        num = false;
      }
      if (len && num) {
        m2 = Math.min(m2, max);
        this.setState({
          renderList: value.slice(0, m2),
          popList: value.slice(m2),
          pop: true
        });
      } else if (len && !num) {
        this.setState({
          renderList: value.slice(0, m2),
          popList: value.slice(m2),
          pop: true
        });
      } else if (!len && num) {
        this.setState({
          renderList: value.slice(0, max - 1),
          popList: value.slice(max - 1),
          pop: true
        });
      } else if (!len && !num) {
        this.setState({
          renderList: value,
          popList: [],
          pop: false
        });
      }
    }
    render() {
      var _this$props3 = this.props, value = _this$props3.value;
      _this$props3.max;
      var _this$props3$popClass = _this$props3.popClass, popClass = _this$props3$popClass === void 0 ? "" : _this$props3$popClass, popProps = _this$props3.popProps, _this$props3$renderIt = _this$props3.renderItem, renderItem = _this$props3$renderIt === void 0 ? (item) => /* @__PURE__ */ React.createElement(Tag$1, {
        key: item
      }, item) : _this$props3$renderIt, overHide = _this$props3.overHide, rows = _this$props3.rows, isArLang = _this$props3.isArLang;
      _this$props3.observeResize;
      var rest = _objectWithoutProperties$6(_this$props3, _excluded$6);
      var _this$state = this.state, renderList = _this$state.renderList, popList = _this$state.popList, pop = _this$state.pop;
      var renderPop = (data, index2) => /* @__PURE__ */ React.createElement("div", {
        className: styles$2.tagWrap,
        key: index2
      }, renderItem(data, "pop"));
      var renderShow = (data, index2) => /* @__PURE__ */ React.createElement("div", {
        className: styles$2.tagWrap,
        key: index2
      }, renderItem(data, "show"));
      var renderEllipsis = (data) => /* @__PURE__ */ React.createElement("div", {
        className: styles$2.tagWrap
      }, renderItem(data, "ellipsis"));
      return /* @__PURE__ */ React.createElement("div", {
        className: styles$2.arrayEllipsis
      }, /* @__PURE__ */ React.createElement("div", _extends$4({}, rest, {
        ref: (r) => {
          this.myRef = r;
        },
        style: {
          visibility: "hidden",
          position: "absolute",
          pointerEvents: "none"
        },
        className: "ellipsis-hidden"
      }), value.map(renderShow)), /* @__PURE__ */ React.createElement("div", _extends$4({}, rest, {
        // ref={(r) => { this.myRef = r }}
        style: overHide && !rows ? {
          whiteSpace: "nowrap"
        } : {},
        className: isArLang && styles$2.arLang
      }), renderList.map(renderShow), pop ? /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement(Popover, popProps, /* @__PURE__ */ React.createElement("div", {
        className: [styles$2.popStyle, popClass, isArLang && styles$2.arLang].join(" ")
      }, popList.map(renderPop))), renderEllipsis("...")) : null));
    }
  }
  OverPop.defaultProps = {
    overHide: true,
    rows: 1
  };
  OverPop.propTypes = {
    /**
     * 数组形式的数据
     */
    value: propTypes.arrayOf(propTypes.oneOfType([propTypes.string, propTypes.object])).isRequired,
    /**
     * 超过外部div时，收缩展示
     */
    overHide: propTypes.bool,
    /**
     * 最大个数, 如果同时受外部div宽度限制，两者都有限制的时候取最小值
     */
    max: propTypes.number,
    /**
     * 渲染函数
     * 入参：数据对象、类型（show-展示的值，pop-Popover中的值，ellipsis-省略符号）
     * 返回值：渲染结果
     */
    renderItem: propTypes.func,
    /**
     * Popover class
     */
    popClass: propTypes.string,
    /**
     * Popover组件的属性，具体用法看shineout文档
     */
    // eslint-disable-next-line
    popProps: propTypes.object,
    /**
     * row 行数超过限制
     */
    rows: propTypes.number,
    /**
     * 当设置isArLang 为true 使用阿语模式
     */
    isArLang: propTypes.bool,
    /**
     * 是否监听容器宽度变化重新计算
     */
    observeResize: propTypes.bool
  };
  var _excluded$5 = ["value", "popClass", "popContent", "noPop", "isArLang", "popProps"];
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  function ownKeys(object4, enumerableOnly) {
    var keys2 = Object.keys(object4);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object4);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties$5(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$5(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$5(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var styles$1 = {
    "ellipsis": "shein-components_ellipsis_ellipsis",
    "hide": "shein-components_ellipsis_hide",
    "more": "shein-components_ellipsis_more",
    "popStyle": "shein-components_ellipsis_popStyle",
    "pointer": "shein-components_ellipsis_pointer",
    "ellipsisWrap": "shein-components_ellipsis_ellipsisWrap",
    "beforeText": "shein-components_ellipsis_beforeText",
    "endText": "shein-components_ellipsis_endText",
    "text": "shein-components_ellipsis_text",
    "autoSizeWrap": "shein-components_ellipsis_autoSizeWrap",
    "autoSizeIn": "shein-components_ellipsis_autoSizeIn",
    "flexWrap": "shein-components_ellipsis_flexWrap",
    "grow": "shein-components_ellipsis_grow",
    "arLang": "shein-components_ellipsis_arLang",
    "tagWrap": "shein-components_ellipsis_tagWrap",
    "arrayEllipsis": "shein-components_ellipsis_arrayEllipsis"
  };
  class Ellipsis extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        shouldBack: props.floatMode,
        maxHeight: "auto",
        overPop: false
      };
      this.spanRef = null;
      this.myRef = null;
      this.updatePop = this.updatePop.bind(this);
    }
    componentDidMount() {
      var getChildEllipsis = this.props.getChildEllipsis;
      if (getChildEllipsis) {
        getChildEllipsis(this);
      }
      this.handleDiffRows();
    }
    componentDidUpdate(prevProps) {
      var _this$props = this.props, rows = _this$props.rows, floatMode = _this$props.floatMode;
      if (prevProps.rows !== rows || prevProps.floatMode !== floatMode) {
        this.handleDiffRows();
      }
    }
    // 处理不同行数
    handleDiffRows() {
      var _this$props2 = this.props, rows = _this$props2.rows, floatMode = _this$props2.floatMode;
      if (floatMode || this.myRef.style.webkitLineClamp === void 0 && rows !== 1) {
        this.setState({
          shouldBack: true
        });
        this.setState({
          maxHeight: this.spanRef.clientHeight * rows
        });
      } else if (rows === 1) {
        this.myRef.style.whiteSpace = "pre";
      } else {
        this.myRef.style.cssText = `-webkit-line-clamp: ${rows};display: -webkit-box; -webkit-box-orient: vertical`;
      }
    }
    // 更新并获取是否溢出
    updatePop() {
      var rows = this.props.rows;
      var _this$state = this.state, overPop = _this$state.overPop, maxHeight = _this$state.maxHeight, shouldBack = _this$state.shouldBack;
      if (shouldBack) {
        if (this.myRef.clientHeight > maxHeight) {
          if (!overPop) {
            this.setState({
              overPop: true
            }, () => {
              this.timeout = null;
            });
          }
          return true;
        }
        if (overPop) {
          this.setState({
            overPop: false
          }, () => {
            this.timeout = null;
          });
        }
        return false;
      }
      if (rows === 1) {
        if (isOverX(this.myRef)) {
          if (!overPop) {
            this.setState({
              overPop: true
            }, () => {
              this.timeout = null;
            });
          }
          return true;
        }
        if (overPop) {
          this.setState({
            overPop: false
          }, () => {
            this.timeout = null;
          });
        }
        return false;
      }
      if (isOverY(this.myRef)) {
        if (!overPop) {
          this.setState({
            overPop: true
          }, () => {
            this.timeout = null;
          });
        }
        return true;
      }
      if (overPop) {
        this.setState({
          overPop: false
        }, () => {
          this.timeout = null;
        });
      }
      return false;
    }
    /**
     * render method
     * @return {jsx} rendered nodes
     */
    render() {
      var _this$state2 = this.state, overPop = _this$state2.overPop, shouldBack = _this$state2.shouldBack, maxHeight = _this$state2.maxHeight;
      var _this$props3 = this.props, value = _this$props3.value, popClass = _this$props3.popClass, popContent = _this$props3.popContent, noPop = _this$props3.noPop, isArLang = _this$props3.isArLang, _this$props3$popProps = _this$props3.popProps, popProps = _this$props3$popProps === void 0 ? {} : _this$props3$popProps, rest = _objectWithoutProperties$5(_this$props3, _excluded$5);
      delete rest.getChildEllipsis;
      delete rest.floatMode;
      var text = /* @__PURE__ */ React.createElement(React.Fragment, null, value, /* @__PURE__ */ React.createElement("span", {
        ref: (r) => {
          this.spanRef = r;
        },
        className: styles$1.hide,
        unselectable: "on"
      }, "."));
      var Pop = !noPop && overPop ? /* @__PURE__ */ React.createElement(Popover, popProps, /* @__PURE__ */ React.createElement("div", {
        className: [styles$1.popStyle, popClass, isArLang && styles$1.arLang].join(" ")
      }, popContent || value)) : null;
      return /* @__PURE__ */ React.createElement("div", _extends$3({
        style: _objectSpread(_objectSpread({}, rest.style || {}), {}, {
          overflow: "hidden"
        }),
        className: isArLang && styles$1.arLang
      }, rest), shouldBack ? /* @__PURE__ */ React.createElement("div", {
        className: styles$1.ellipsisWrap,
        style: {
          maxHeight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: styles$1.beforeText,
        style: {
          height: maxHeight
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: [styles$1.text, overPop ? styles$1.pointer : void 0].join(" "),
        onMouseOver: !noPop ? this.updatePop : void 0,
        ref: (r) => {
          this.myRef = r;
        }
      }, text), /* @__PURE__ */ React.createElement("div", {
        className: styles$1.endText
      }, "..."), Pop) : /* @__PURE__ */ React.createElement("div", {
        // 解决在safari浏览器ellipsis默认会有tooltip
        onFocus: () => 0,
        onMouseOver: !noPop ? this.updatePop : void 0,
        ref: (r) => {
          this.myRef = r;
        },
        className: [styles$1.ellipsis, overPop ? styles$1.pointer : void 0].join(" "),
        style: {
          maxHeight
        }
      }, text, Pop));
    }
  }
  Ellipsis.defaultProps = {
    rows: 1
  };
  Ellipsis.propTypes = {
    /**
     * 截断行数
     */
    rows: propTypes.number,
    /**
     * 文本内容 可以扩展为element 但必须为行内元素；
     * 多行截断模式下，最好不要给某一段文字设置特殊的字体大小和行高，否则在ie<10、iOS Safari、Opera Mobile 会有问题
     */
    value: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.number, propTypes.arrayOf(propTypes.oneOfType([propTypes.string, propTypes.object]))]),
    /**
     * Popover 样式
     */
    popClass: propTypes.string,
    /**
     * Popover 内容 不传默认为value的值
     */
    popContent: propTypes.oneOfType([propTypes.string, propTypes.element]),
    /**
     * Popover组件的属性，具体用法看shineout文档
     */
    // eslint-disable-next-line
    popProps: propTypes.object,
    /**
     *  为true时不展示popOver组件
     */
    noPop: propTypes.bool,
    /**
     * 当设置floatMode 为true 使用浮动模式
     */
    floatMode: propTypes.bool,
    /**
     * 当设置isArLang 为true 使用阿语模式
     */
    isArLang: propTypes.bool
  };
  var _excluded$4 = ["children", "popContent", "popClass", "popProps", "onMouseOver"];
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  function _objectWithoutProperties$4(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$4(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var styles = {
    "ellipsis": "shein-components_ellipsis_ellipsis",
    "hide": "shein-components_ellipsis_hide",
    "more": "shein-components_ellipsis_more",
    "popStyle": "shein-components_ellipsis_popStyle",
    "pointer": "shein-components_ellipsis_pointer",
    "ellipsisWrap": "shein-components_ellipsis_ellipsisWrap",
    "beforeText": "shein-components_ellipsis_beforeText",
    "endText": "shein-components_ellipsis_endText",
    "text": "shein-components_ellipsis_text",
    "autoSizeWrap": "shein-components_ellipsis_autoSizeWrap",
    "autoSizeIn": "shein-components_ellipsis_autoSizeIn",
    "flexWrap": "shein-components_ellipsis_flexWrap",
    "grow": "shein-components_ellipsis_grow",
    "arLang": "shein-components_ellipsis_arLang",
    "tagWrap": "shein-components_ellipsis_tagWrap",
    "arrayEllipsis": "shein-components_ellipsis_arrayEllipsis"
  };
  let View$2 = class View extends React.Component {
    constructor(props) {
      super(props);
      this.childList = [];
      this.state = {
        overPop: false
      };
      this.mouseOverHandler = this.mouseOverHandler.bind(this);
      this.getChildEllipsis = this.getChildEllipsis.bind(this);
    }
    getChildEllipsis(ctx) {
      this.childList.push(ctx);
    }
    mouseOverHandler() {
      var overPop = false;
      this.childList.forEach((item) => {
        if (item && item.updatePop) {
          overPop = overPop || item.updatePop();
        }
      });
      this.setState({
        overPop
      });
    }
    render() {
      var _this$props = this.props, children = _this$props.children, popContent = _this$props.popContent, popClass = _this$props.popClass, _this$props$popProps = _this$props.popProps, popProps = _this$props$popProps === void 0 ? {} : _this$props$popProps, _onMouseOver = _this$props.onMouseOver, rest = _objectWithoutProperties$4(_this$props, _excluded$4);
      var overPop = this.state.overPop;
      return /* @__PURE__ */ React.createElement("div", _extends$2({
        onMouseOver: () => {
          this.mouseOverHandler();
          if (_onMouseOver && typeof _onMouseOver === "function") {
            _onMouseOver();
          }
        }
      }, rest), React.Children.map(children, (child) => /* @__PURE__ */ React.cloneElement(child, {
        noPop: true,
        getChildEllipsis: this.getChildEllipsis
      })), overPop ? /* @__PURE__ */ React.createElement(Popover, popProps, /* @__PURE__ */ React.createElement("div", {
        className: [styles.popStyle, popClass].join(" ")
      }, popContent)) : null);
    }
  };
  View$2.propTypes = {
    /**
     * Ellipsis 子组件
     */
    children: propTypes.oneOfType([propTypes.element, propTypes.arrayOf(propTypes.element)]).isRequired,
    /**
     * Popover 样式
     */
    popClass: propTypes.string,
    /**
     * Popover 内容
     */
    popContent: propTypes.oneOfType([propTypes.string, propTypes.element]).isRequired,
    /**
     * Popover组件的属性，具体用法看shineout文档
     */
    // eslint-disable-next-line
    popProps: propTypes.object,
    /**
     * 父容器是自适应宽度的情况下设为true
     */
    // eslint-disable-next-line
    autoSize: propTypes.bool
  };
  var _excluded$3 = ["className"];
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function _objectWithoutProperties$3(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$3(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Style = {
    "ellipsis": "shein-components_ellipsis_ellipsis",
    "hide": "shein-components_ellipsis_hide",
    "more": "shein-components_ellipsis_more",
    "popStyle": "shein-components_ellipsis_popStyle",
    "pointer": "shein-components_ellipsis_pointer",
    "ellipsisWrap": "shein-components_ellipsis_ellipsisWrap",
    "beforeText": "shein-components_ellipsis_beforeText",
    "endText": "shein-components_ellipsis_endText",
    "text": "shein-components_ellipsis_text",
    "autoSizeWrap": "shein-components_ellipsis_autoSizeWrap",
    "autoSizeIn": "shein-components_ellipsis_autoSizeIn",
    "flexWrap": "shein-components_ellipsis_flexWrap",
    "grow": "shein-components_ellipsis_grow",
    "arLang": "shein-components_ellipsis_arLang",
    "tagWrap": "shein-components_ellipsis_tagWrap",
    "arrayEllipsis": "shein-components_ellipsis_arrayEllipsis"
  };
  const auto = (Component2) => (_ref) => {
    var className = _ref.className, props = _objectWithoutProperties$3(_ref, _excluded$3);
    return /* @__PURE__ */ React.createElement("div", {
      className: Style.autoSizeWrap
    }, new Array(props.rows || 1).fill(void 0).map((v2, i) => /* @__PURE__ */ React.createElement("br", {
      key: i
    })), /* @__PURE__ */ React.createElement(Component2, _extends$1({}, props, {
      className: className ? `${className} ${Style.autoSizeIn}` : Style.autoSizeIn
    })));
  };
  var _excluded$2 = ["autoSize"];
  function _objectWithoutProperties$2(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var View$1 = (props) => {
    var autoSize = props.autoSize, rest = _objectWithoutProperties$2(props, _excluded$2);
    var Component2 = View$2;
    if (autoSize) {
      Component2 = auto(View$2);
    }
    return /* @__PURE__ */ React.createElement(Component2, rest);
  };
  View$1.propTypes = {
    /**
     * 父容器是自适应宽度的情况下设为true
     */
    autoSize: propTypes.bool
  };
  var _excluded$1 = ["header", "footer"];
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$1(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var style = {
    "ellipsis": "shein-components_ellipsis_ellipsis",
    "hide": "shein-components_ellipsis_hide",
    "more": "shein-components_ellipsis_more",
    "popStyle": "shein-components_ellipsis_popStyle",
    "pointer": "shein-components_ellipsis_pointer",
    "ellipsisWrap": "shein-components_ellipsis_ellipsisWrap",
    "beforeText": "shein-components_ellipsis_beforeText",
    "endText": "shein-components_ellipsis_endText",
    "text": "shein-components_ellipsis_text",
    "autoSizeWrap": "shein-components_ellipsis_autoSizeWrap",
    "autoSizeIn": "shein-components_ellipsis_autoSizeIn",
    "flexWrap": "shein-components_ellipsis_flexWrap",
    "grow": "shein-components_ellipsis_grow",
    "arLang": "shein-components_ellipsis_arLang",
    "tagWrap": "shein-components_ellipsis_tagWrap",
    "arrayEllipsis": "shein-components_ellipsis_arrayEllipsis"
  };
  const layout = (Component2) => (_ref) => {
    var header2 = _ref.header, footer = _ref.footer, rest = _objectWithoutProperties$1(_ref, _excluded$1);
    return /* @__PURE__ */ React.createElement("div", {
      className: style.flexWrap
    }, /* @__PURE__ */ React.createElement("div", null, header2), /* @__PURE__ */ React.createElement("div", {
      className: style.grow
    }, /* @__PURE__ */ React.createElement(Component2, rest)), /* @__PURE__ */ React.createElement("div", null, footer));
  };
  var _excluded = ["type", "autoSize", "header", "footer"];
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function View2(props) {
    var type4 = props.type, autoSize = props.autoSize, header2 = props.header, footer = props.footer, rest = _objectWithoutProperties(props, _excluded);
    var shouldLayout = !!(header2 || footer);
    var Component2 = React.useMemo(() => {
      var comp = type4 === "array" ? OverPop : Ellipsis;
      if (autoSize) {
        comp = auto(comp);
      }
      if (shouldLayout) {
        comp = layout(comp);
      }
      return comp;
    }, [autoSize, shouldLayout, type4]);
    return /* @__PURE__ */ React.createElement(Component2, _extends({}, rest, {
      header: header2,
      footer
    }));
  }
  View2.defaultProps = {
    type: "default"
  };
  View2.PopWrap = View$1;
  View2.propTypes = {
    /**
     * 组件类型， 默认为default,默认根据容器大小和文本长度自适应文本截断和显示，支持单行截断和多行截断。
     * 当 type = "array" 的时候为标签模式
     */
    type: propTypes.string,
    /**
     * 父容器是自适应宽度的情况下设为true
     */
    autoSize: propTypes.bool,
    /**
     * 头部
     */
    header: propTypes.element,
    /**
     * 尾部
     */
    footer: propTypes.element,
    /**
     * 文本内容 可以扩展为element 但必须为行内元素；
     * 多行截断模式下，最好不要给某一段文字设置特殊的字体大小和行高，否则在ie<10、iOS Safari、Opera Mobile 会有问题
     */
    value: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.number, propTypes.arrayOf(propTypes.oneOfType([propTypes.string, propTypes.object]))]).isRequired,
    /**
     * 超过外部div时，收缩展示
     */
    overHide: propTypes.bool,
    /**
     * 最大个数, 如果同时受外部div宽度限制，两者都有限制的时候取最小值
     */
    max: propTypes.number,
    /**
     * 渲染函数
     * 入参：数据对象、类型（show-展示的值，pop-Popover中的值，ellipsis-省略符号）
     * 返回值：渲染结果
     */
    renderItem: propTypes.func,
    /**
     * Popover class
     */
    popClass: propTypes.string,
    /**
     * row 行数超过限制
     */
    rows: propTypes.number,
    /**
     * 当设置isArLang 为true 使用阿语模式
     */
    isArLang: propTypes.bool,
    /**
     * 是否监听容器宽度变化重新计算
     */
    observeResize: propTypes.bool,
    /**
     * Popover 内容 不传默认为value的值
     */
    popContent: propTypes.oneOfType([propTypes.string, propTypes.element]),
    /**
     * Popover组件的属性，具体用法看shineout文档
     */
    // eslint-disable-next-line
    popProps: propTypes.object,
    /**
     *  为true时不展示popOver组件
     */
    noPop: propTypes.bool,
    /**
     * 当设置floatMode 为true 使用浮动模式
     */
    floatMode: propTypes.bool
  };
  let Index$5 = class Index extends React.Component {
    render() {
      var _a, _b;
      let {
        info: info2,
        name,
        keygen,
        type: type4,
        trUser
      } = this.props;
      if ((_b = (_a = trUser == null ? void 0 : trUser[info2.key]) == null ? void 0 : _a[keygen]) == null ? void 0 : _b.length) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_p", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "涉及",
              name,
              "："
            ] }),
            trUser[info2.key][keygen].map((item) => {
              var _a2;
              if (getCommend(info2, trUser[info2.key][keygen]).some((x) => x.value && x.name === item)) {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Tooltip$1,
                  {
                    title: (_a2 = getCommend(info2, trUser[info2.key][keygen]).find((x) => x.name === item)) == null ? void 0 : _a2.value,
                    color: "#87d068",
                    trigger: "click",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tag$3, { bordered: false, color: "#87d068", className: "success_tag", children: item })
                  }
                );
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag$3, { bordered: false, color: "#108ee9", children: item });
            })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_red", children: [
            getCommend(info2, trUser[info2.key][keygen]).filter((x) => !x.value).map((v2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              v2.name,
              getCommend(info2, trUser[info2.key][keygen]).length - 1 === i ? "" : "、"
            ] })),
            getCommend(info2, trUser[info2.key][keygen]).filter((x) => !x.value).length ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "缺少",
              type4 === "develop" ? "自测记录" : "测试报告"
            ] }) : null
          ] })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tr_p", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        "涉及",
        name,
        "："
      ] }) });
    }
  };
  const Index$4 = (props) => {
    let buttonRef = React.useRef(null);
    const [trData, setTrData] = React.useState({});
    const [load, setLoad] = React.useState(false);
    const [trList, setTrList] = React.useState([]);
    const getData = async () => {
      let trRes = {};
      setLoad(true);
      getTrDetail(_GM_getValue("online_jql", "")).then((res) => {
        const data = (res == null ? void 0 : res.issues) ?? [];
        if (data.length) {
          setTrList(data);
          data.map((item, index2) => {
            getTrData(item.key).then((response) => {
              const value = getNameByName({ response, tr: item, users: props.users });
              trRes = { ...trRes, ...value };
              setTrData({ ...trRes, ...value });
              if (index2 + 1 === data.length) {
                setLoad(false);
              }
            });
          });
        } else {
          setTrList([]);
          setLoad(false);
        }
      }).catch((res) => {
        setLoad(false);
      });
    };
    React.useEffect(() => {
      if (props.open) {
        getData();
      }
    }, [props.open]);
    React.useEffect(() => {
      var _a;
      if (props.signal === "sendMsg") {
        (_a = buttonRef.current) == null ? void 0 : _a.click();
      }
    }, [props.signal]);
    const sendMsg = (data) => {
      const robIds = _GM_getValue("online_robId", []);
      const groups = _GM_getValue("online_group", []);
      const markList = groups.filter((x) => robIds.includes(x.value));
      markList.map((item, index2) => {
        var _a;
        const keyList = (_a = item.keygen) == null ? void 0 : _a.split(",");
        const belongList = data.filter((item2) => {
          var _a2;
          return keyList.includes((_a2 = item2 == null ? void 0 : item2.fields) == null ? void 0 : _a2.customfield_47335);
        });
        const markdownList = createOnlineMarkdown(belongList, trData);
        if (markdownList == null ? void 0 : markdownList.length) {
          markdownList.map((_item, _index) => {
            setTimeout(() => {
              pdcFetch(() => {
                message$1.success("发送成功");
              }, {
                url: "/pim/ulp/v3_send_msg_to_wechat_group",
                data: {
                  markdown: {
                    content: _item
                  },
                  msgtype: "markdown",
                  robotid: item.value
                }
              });
            }, _index * 1e3);
          });
        }
      });
    };
    const NewText = () => {
      if ((trList == null ? void 0 : trList.length) === 0) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "今日无上线内容" });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Watermark$1,
        {
          font: { fontSize: 14 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#000" }, children: trList == null ? void 0 : trList.map((item) => {
            var _a, _b, _c;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ["143", "689"].includes((_a = item == null ? void 0 : item.fields) == null ? void 0 : _a.customfield_47335) ? "【商家】" : "【中台】" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "tr_link", href: `https://jira.dotfashion.cn/browse/${item.key}`, target: "_blank", children: item.key }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tr_title", children: /* @__PURE__ */ jsxRuntimeExports.jsx(View2, { value: (_b = item == null ? void 0 : item.fields) == null ? void 0 : _b.summary, rows: 1 }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_body", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_p", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "涉及产品：" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Tag$3, { bordered: false, color: "#87d068", className: "success_tag", children: (_c = trData[item.key]) == null ? void 0 : _c.product })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tr_p", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "技术经理：" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Tag$3, { bordered: false, color: "#87d068", className: "success_tag", children: trData[item.key] ? trData[item.key].manager : void 0 })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Index$5, { info: item, name: "前端", type: "develop", trUser: trData, keygen: "before" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Index$5, { info: item, name: "后端", type: "develop", trUser: trData, keygen: "after" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Index$5, { info: item, name: "测试", type: "test", trUser: trData, keygen: "test" })
              ] })
            ] });
          }) })
        }
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$3,
        {
          type: "primary",
          disabled: load,
          ref: buttonRef,
          onClick: () => {
            sendMsg(trList);
          },
          children: "一键发送"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Spin$4, { spinning: load, children: !load ? /* @__PURE__ */ jsxRuntimeExports.jsx(NewText, {}) : null })
    ] });
  };
  const groupList = [
    {
      value: "102721",
      label: "测试",
      keygen: "146,6,144,143,689"
    },
    {
      value: "102844",
      label: "商家",
      keygen: "143,689"
    },
    {
      value: "102731",
      label: "中台",
      keygen: "6,144,146"
    }
  ];
  const { TextArea: TextArea$2 } = Input$2;
  const Index$3 = () => {
    const [robId, setRobId] = React.useState(_GM_getValue("online_robId", []));
    const [day, setDay] = React.useState(_GM_getValue("online_day", [2, 4]));
    const [hour, setHour] = React.useState(_GM_getValue("online_hour", 16));
    const [minute, setMinute] = React.useState(_GM_getValue("online_minute", 0));
    const [jql, setJql] = React.useState(_GM_getValue("online_jql", ""));
    const [path, setPath] = React.useState(_GM_getValue("online_path", ""));
    const [group, setGroup] = React.useState(_GM_getValue("online_group", groupList));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "发送日期：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Select$1,
          {
            value: day,
            style: { width: 300 },
            mode: "multiple",
            onChange: (d2) => {
              _GM_setValue("online_day", d2);
              setDay(d2);
            },
            options: [
              { value: 1, label: "周一" },
              { value: 2, label: "周二" },
              { value: 3, label: "周三" },
              { value: 4, label: "周四" },
              { value: 5, label: "周五" },
              { value: 6, label: "周六" },
              { value: 7, label: "周日" }
            ]
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "发送小时：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InputNumber$1,
          {
            style: { width: 300 },
            value: hour,
            max: 24,
            min: 0,
            onChange: (e2) => {
              if (e2 || e2 === 0) {
                setHour(e2);
                _GM_setValue("online_hour", e2);
              }
            },
            placeholder: "小时，默认16点"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "发送分钟：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InputNumber$1,
          {
            max: 60,
            min: 0,
            style: { width: 300 },
            value: minute,
            onChange: (e2) => {
              if (e2 || e2 === 0) {
                setMinute(e2);
                _GM_setValue("online_minute", e2);
              }
            },
            placeholder: "分钟，默认0分钟"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "群管理：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_content", children: [
          group == null ? void 0 : group.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                value: item.label,
                style: { width: 90 },
                className: "data_input",
                placeholder: "群名称",
                onChange: (e2) => {
                  const val = e2.target.value;
                  const result = [
                    ...group.slice(0, index2),
                    Object.assign({}, group[index2], { label: val }),
                    ...group.slice(index2 + 1)
                  ];
                  setGroup(result);
                  _GM_setValue("online_group", result);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                value: item.value,
                style: { width: 100 },
                className: "data_input",
                placeholder: "群ID",
                onChange: (e2) => {
                  const val = e2.target.value;
                  const result = [
                    ...group.slice(0, index2),
                    Object.assign({}, group[index2], { value: val }),
                    ...group.slice(index2 + 1)
                  ];
                  setGroup(result);
                  _GM_setValue("online_group", result);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                value: item.keygen,
                style: { width: 180 },
                className: "data_input",
                placeholder: "群对应的jira ID",
                onChange: (e2) => {
                  const val = e2.target.value;
                  const result = [
                    ...group.slice(0, index2),
                    Object.assign({}, group[index2], { keygen: val }),
                    ...group.slice(index2 + 1)
                  ];
                  setGroup(result);
                  _GM_setValue("online_group", result);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { type: "text", onClick: () => {
              const result = [
                ...group.slice(0, index2),
                ...group.slice(index2 + 1)
              ];
              setGroup(result);
              _GM_setValue("online_group", result);
            }, children: "删" })
          ] })),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { type: "primary", style: { width: 120 }, onClick: () => {
            setGroup([...group, { label: "", value: "", keygen: "" }]);
          }, children: "加一条" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "JQL：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextArea$2,
          {
            value: jql,
            rows: 6,
            onChange: (e2) => {
              const val = e2.target.value;
              setJql(val);
              _GM_setValue("online_jql", val);
            }
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "群名称：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select$1,
            {
              value: robId,
              mode: "multiple",
              onChange: (d2) => {
                _GM_setValue("online_robId", d2);
                setRobId(d2);
              },
              options: group
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tr_red", children: "最终要发布的群聊" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "data_title", children: "人员路径：" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "data_content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea$2,
            {
              value: path,
              rows: 1,
              onChange: (e2) => {
                const val = e2.target.value;
                setPath(val);
                _GM_setValue("online_path", val);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tr_red", children: "这个字段暂时用不到" })
        ] })
      ] })
    ] });
  };
  const { TextArea: TextArea$1 } = Input$2;
  const Index$2 = () => {
    const [user, setUser] = React.useState("");
    const getUser2 = async function(data) {
      let params = data ? { key: "jira_user", value: data } : { key: "jira_user" };
      await pdcFetch((res) => {
        if (data) {
          message$1.success("导入成功");
        }
        if (res) {
          setUser(res);
        }
      }, {
        url: "/pim/apollo/front_end_development",
        data: params,
        headers: {
          "Cookie": _GM_getValue("online_token", "")
        }
      });
    };
    React.useEffect(() => {
      getUser2(null);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea$1,
        {
          value: user,
          rows: 30,
          placeholder: "人员",
          onChange: (e2) => {
            const val = e2.target.value;
            setUser(val);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { type: "primary", onClick: () => getUser2(user), style: { marginTop: 10 }, children: "录入数据" })
    ] });
  };
  const { TextArea } = Input$2;
  const Index$1 = () => {
    const [token2, setToken] = React.useState(_GM_getValue("online_token", ""));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextArea,
      {
        value: token2,
        rows: 15,
        placeholder: "token",
        onChange: (e2) => {
          const val = e2.target.value;
          setToken(val);
          _GM_setValue("online_token", val);
        }
      }
    ) });
  };
  const Index2 = () => {
    const [open2, setOpen] = React.useState(false);
    const [activeKey, setActiveKey] = React.useState("1");
    const [users, setUsers] = React.useState([]);
    const [signal, setSignal] = React.useState("common");
    const getUser2 = async () => {
      await pdcFetch((res) => {
        const currentUser = JSON.parse(res);
        setUsers(currentUser);
      }, {
        headers: {
          "Cookie": _GM_getValue("online_token", "")
        },
        url: "/pim/apollo/front_end_development",
        data: {
          key: "jira_user"
        }
      });
    };
    React.useEffect(() => {
      getUser2();
      setTiming(() => {
        setOpen(false);
        setTimeout(() => {
          setOpen(true);
        }, 5e3);
        setTimeout(() => {
          setSignal("sendMsg");
        }, 4e4);
        setTimeout(() => {
          setSignal("common");
        }, 45e3);
      }, {
        day: _GM_getValue("online_day"),
        hour: _GM_getValue("online_hour"),
        minute: _GM_getValue("online_minute")
      });
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatButton$1,
        {
          type: "primary",
          style: { bottom: 200, zIndex: 9999999999999 },
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { fontSize: 20, name: "shein-s-circle" }),
          onClick: async (e2) => {
            e2.stopPropagation();
            setOpen((v2) => !v2);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Drawer$1,
        {
          width: 600,
          title: "定时上线任务",
          placement: "right",
          closable: false,
          open: open2,
          className: "drawer_container",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs$1, { activeKey, items: [{
            label: `上线清单`,
            key: "1",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Index$4, { open: open2, users, signal })
          }, {
            label: `基础配置`,
            key: "2",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Index$3, {})
          }, {
            label: `人员配置`,
            key: "3",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Index$2, {})
          }, {
            label: `token(临时)`,
            key: "4",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Index$1, {})
          }], onChange: (d2) => setActiveKey(d2) })
        },
        "right"
      )
    ] });
  };
  const warningFunc2 = () => {
  };
  const AllDataContext = React.createContext({
    setStoreValue: warningFunc2,
    getStoreValue: warningFunc2,
    registerField: warningFunc2,
    unRegisterField: warningFunc2
  });
  const storeDefault = {};
  const dataDefault = {
    count: 0
  };
  const MARKETING_Info_Data = "marketing_info_data";
  const MARKETING_TIME_DATE = "marketing_time_data";
  class AllDataStore {
    constructor(initialValues) {
      __publicField(this, "store", storeDefault);
      __publicField(this, "update_store", {});
      __publicField(this, "data", dataDefault);
      // 用于暴露方法
      __publicField(this, "getDetail", () => ({
        getStoreValue: this.getStoreValue,
        registerField: this.registerField,
        setStoreValue: this.setStoreValue,
        unRegisterField: this.unRegisterField
      }));
      // 获取数据
      __publicField(this, "getStoreValue", (name) => {
        if (name === "data")
          return this.data;
        return this.store;
      });
      // 设置数据
      __publicField(this, "setStoreValue", (name, value) => {
        if (name === "data")
          this.data = { ...this.data, ...value };
        if (name === "storeInfo" && value.info) {
          const { en_name, employee_id } = value.info;
          localStorage.setItem(
            MARKETING_Info_Data,
            JSON.stringify({ en_name, employee_id })
          );
          localStorage.setItem(MARKETING_TIME_DATE, getDate());
          this.store = { ...this.store, en_name, employee_id };
        }
        if (name === "store")
          this.store = { ...this.store, ...value };
        this.updateStore();
      });
      // 更新
      __publicField(this, "updateStore", () => {
        const { update } = this.update_store;
        if (update)
          update();
      });
      // 注册方法
      __publicField(this, "registerField", (payload, updateChange2) => {
        this.store = { ...this.store, ...payload };
        this.update_store = updateChange2;
      });
      // 卸载方法
      __publicField(this, "unRegisterField", () => {
        this.store = storeDefault;
        this.update_store = {};
        this.data = dataDefault;
      });
      const info2 = JSON.parse(localStorage.getItem(MARKETING_Info_Data) || "{}");
      this.store = { ...initialValues, ...info2 };
    }
  }
  const useAllData = (initialValues) => {
    const dataRef = React.useRef();
    if (!dataRef.current) {
      dataRef.current = new AllDataStore(initialValues).getDetail();
    }
    return [dataRef.current];
  };
  function App() {
    const [dataRef] = useAllData({});
    const update = useUpdate();
    React.useEffect(() => {
      const res = localStorage.getItem(MARKETING_TIME_DATE);
      if (!res || res !== getDate()) {
        localStorage.removeItem(MARKETING_Info_Data);
      }
      dataRef.registerField({ mark: "初始数据" }, { update: () => update() });
      return () => {
        dataRef.unRegisterField();
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AllDataContext.Provider, { value: dataRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Index2, {}) });
  }
  client.createRoot(
    (() => {
      const app = document.createElement("div");
      document.body.append(app);
      return app;
    })()
  ).render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
  );

})(React, ReactDOM);